<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📳 ☯️ 🌋 Automatisierung von End-2-End-Tests eines integrierten Informationssystems. Teil 1. Organisatorisch 😠 🖕🏽 👴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit diesem Artikel eröffnen wir eine Reihe von Veröffentlichungen darüber, wie wir den Prozess des manuellen Testens eines großen Informationssystems ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisierung von End-2-End-Tests eines integrierten Informationssystems. Teil 1. Organisatorisch</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/473426/">  Mit diesem Artikel eröffnen wir eine Reihe von Veröffentlichungen darüber, wie wir den Prozess des manuellen Testens eines großen Informationssystems in einem der Hauptprojekte von LANIT automatisiert haben und was daraus entstanden ist. <br><br>  <i>Der erste Teil - organisatorisch und verwaltungstechnisch - sollte in erster Linie für diejenigen nützlich sein, die für das Testen der Automatisierung verantwortlich sind und solche Systeme als Ganzes erstellen.</i>  <i>Projektmanager, Gruppenleiter und Eigentümer von funktionalen und automatischen Testdiensten, die sich <b>alle mit der Frage beschäftigen, wie ein kostengünstiger End-2-End-Test ihres IT-Systems erstellt werden kann, finden hier einen konkreten Plan und eine konkrete Methodik.</b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/664/45f/8f366445ff952429d3a43ff7911ef34d.jpg"></div>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a></i> <br><a name="habracut"></a><br><h1>  Teil 1 - Organisation und Management.  Warum brauchten wir Automatisierung?  Organisation des Entwicklungs- und Managementprozesses.  Organisation der Nutzung </h1><br>  Am Anfang gab es ein großes und komplexes Informationssystem (wir werden es das „System“ nennen) mit zahlreichen komplexen, langen und miteinander verbundenen Geschäftsszenarien.  Alle Skripte wurden als E2E über Webschnittstellen ausschließlich im manuellen Modus getestet (es gab mehr als eineinhalb Tausend solcher Szenarien mit nur der kritischsten Priorität).  Darüber hinaus mussten alle diese Szenarien mindestens einmal während der Regression jeder neuen Version oder jedes neuen Hotfixes vor dem nächsten Bereitstellungsupdate für das Produkt abgeschlossen werden. <br><br>  Zu einem bestimmten Zeitpunkt, als es völlig unerträglich wurde, im manuellen Modus mit der Maus zu klicken, beschlossen wir, alles zu automatisieren.  Dies haben sie durch die Entwicklung eines separaten Dienstes auf der Basis von Java + Selen + Selenid + Selenoid getan, der auch als <b>"Test-Framework"</b> oder einfach <b>"Autotests" bezeichnet wird</b> . <br><br>  In der Vergangenheit wurde der Test-Framework-Code von zwei Teams entwickelt.  Zunächst erstellte das erste Team einen Prototyp mit ein paar Dutzend Szenarien.  Dann skalierte das zweite Team für ein Jahr den Prototyp sowohl in der Breite (Anzahl der Tests) als auch in der Tiefe (typische Codierungs- und Implementierungsmuster wurden eingeführt). <br><br>  Ich bin das Team und der Teamleiter des zweiten Teams, das das Prototyp-Framework für die Skalierung übernommen hat (im Mai 2018). <br><br>  Zum Zeitpunkt dieses Schreibens war die vor einem Jahr festgelegte Aufgabe abgeschlossen und das Projektteam erhielt einen stabilen Automatisierungsservice.  Es war nicht umsonst, dass ich den <u><b>Service</b></u> hervorhob, da die Aufgabe ursprünglich nicht darin bestand, eine Anwendung zu entwickeln, sondern einen Service-Service zum Testen der Automatisierung für eine Gruppe von „Funktionstests“ bereitzustellen.  Diese Funktion hat in der Folge die Organisation der Entwicklung und die Architektur des Testframeworks stark beeinflusst. <br><br><blockquote><h2>  Zusammenfassung </h2><br>  Etwa 1.500 Testszenarien wurden automatisiert: In jedem Test wurden 200 bis 2000 Benutzeroperationen durchgeführt. <br><br>  Die Gesamtkapazität des Dienstes beträgt bis zu 60 gleichzeitig arbeitende Browser, und dies ist nicht die Grenze (die Anzahl kann aufgrund virtueller Maschinen um das Fünffache erhöht werden). <br>  Die Gesamtdauer einer vollständigen Regression beträgt nicht mehr als 3 Stunden, und der PreQA-Test beträgt weniger als eine Stunde. <br><br>  Eine umfangreiche Palette von Funktionen wurde implementiert: <br><br><ul><li>  lokale Nutzung (Echtzeitausführung) und Remote (über Bambuspläne); </li><li>  Begrenzung der Zusammensetzung laufender Tests durch Filter; </li><li>  einen detaillierten Bericht mit den Ergebnissen jedes Schritts des Testszenarios (über das Allure-Framework); </li><li>  Herunterladen und Hochladen von Dateien von / in den Browser, gefolgt von der Überprüfung der Ergebnisse ihrer Verarbeitung hinsichtlich Format und Inhalt der Dateien; </li><li>  Abrechnung und Steuerung der asynchronen Natur der Winkelschnittstelle.  Einschließlich der Kontrolle von blockierten Anforderungen (ausstehende Anforderung) zwischen Angular- und REST-Diensten; </li><li>  Kontrolle von Browserprotokollen; </li><li>  Video-Testaufzeichnung; </li><li>  Entfernen des Schnappschusses der Seite zum Zeitpunkt des "Sturzes" des Tests; </li><li>  Ereignisübertragung in ELK; </li><li>  viel mehr über die kleinen Dinge ... </li></ul><br></blockquote><br><h1>  Warum wurde das alles gebraucht? </h1><br>  Zu Beginn war der Zweck des Systems recht einfach und klar. <br><br>  Stellen Sie sich vor, Sie verfügen über ein großes Registrierungssystem für die Verwaltung einer Vielzahl von Dokumenten und deren Lebenszyklus, die einige hundert Geschäftsprozesse bereitstellen.  Darüber hinaus gibt es Millionen von Menschen, Lieferanten - Zehntausende, Dienstleistungen - Tausende, komplexe Dokumente, einschließlich Framework und Vorlage, und die Bereitstellung von Geschäftsprozessen wird auf Hunderte verschiedener Arten bereitgestellt ... <br><br>  All dies führt zu anderthalb Tausend Testszenarien, und dies ist nur die höchste Priorität und nur positiv. <br><br>  Während des Automatisierungsprozesses wurden verschiedene Nuancen entdeckt, die die Verwendung verschiedener Lösungen erforderten. <br><br>  Beispielsweise kann ein Skript bis zu Hunderte von separaten Vorgängen enthalten, darunter interessante wie: „Laden Sie eine EXCEL-Datei mit Daten herunter und überprüfen Sie, ob das System jeden Datensatz aus der Datei verarbeitet“ (um dieses Problem zu lösen, waren mehrere Schritte erforderlich, um die Daten vorzubereiten und das Ergebnis des Ladens zu überprüfen System).  Und jetzt fügen wir die Einschränkung der Wiederverwendung von Testdaten hinzu: Die Testdaten für den erfolgreichen Abschluss der meisten Testszenarien sollten "frisch" sein und zuvor nicht in ähnlichen Szenarien verwendet werden (während der Tests ändert sich der Status der Daten im System, sodass sie nicht wiederverwendet werden können die gleichen Schecks). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/242/0a7/ccc/2420a7ccc161bb7ee6537a73cd6bd33a.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> <br><br>  Irgendwann schien das manuelle Testen des Systems als Teil der Regression nicht mehr kostengünstig und schnell genug zu sein, und sie beschlossen, es über die Webbenutzeroberfläche zu automatisieren. <br><br>  Mit anderen Worten, die Funktionstestgruppe öffnet die "Seite", wählt die "Testgruppe" aus und drückt die "Ausführen" -Taste (wir haben Bamboo verwendet).  Dann emulieren Autotests (im Folgenden als Autotests bezeichnet. Das erstellte Produkt zum Testen im Allgemeinen festlegen) automatisch die Aktionen der Benutzer im System über den Browser (drücken Sie die erforderlichen Schaltflächen, geben Sie Werte in die Felder ein usw.) und zeigen Sie nach Abschluss einen detaillierten Bericht über alle an Schritte und abgeschlossene Aktionen und Ergebnisse der Überprüfung (Entsprechung der erwarteten Reaktion des Systems auf sein tatsächliches Verhalten). <br><br>  Insgesamt ist der Zweck von Autotests die Automatisierung manueller E2E-Tests.  Dies ist ein „externes“ System, das nicht am Entwicklungsprozess des zu testenden Systems teilnimmt und in keiner Weise mit den von den Entwicklern verwendeten Einheiten- oder Integrationstests verbunden ist. <br><br><h2>  Ziele </h2><br>  Es war notwendig, die Arbeitskosten für die Durchführung von End-2-End-Tests erheblich zu senken und die Geschwindigkeit vollständiger und reduzierter Regressionen in Bezug auf das Volumen zu erhöhen. <br><br><div class="spoiler">  <b class="spoiler_title">Zusätzliche Ziele</b> <div class="spoiler_text"><ul><li>  Gewährleistung einer hohen Entwicklungsgeschwindigkeit von Autotests mit einem hohen Maß an Autonomie (die Notwendigkeit einer vorläufigen Befüllung mit Testdaten der Systemstände / Einrichtung von Autotests für jeden Stand sollte minimiert werden); </li><li>  Optimierung der Ausgaben (Zeit und Finanzen) für die Kommunikation zwischen Automatisierungs-, Funktionstest- und Systementwicklungsteams; </li><li>  Minimieren Sie das Risiko von Diskrepanzen zwischen den tatsächlich implementierten Autotests und den anfänglichen Erwartungen des Funktionstestteams (das Funktionstestteam sollte den Ergebnissen der AutoTests unbedingt vertrauen). </li></ul></div></div><br><h2>  Die Aufgaben </h2><br>  Die Hauptaufgabe der Entwicklung wurde sehr einfach formuliert - in den nächsten 6 Monaten 1000 Testszenarien mit höchster Priorität zu automatisieren. <br><br>  Die vorhergesagte Anzahl grundlegender Testaktionen lag zwischen 100 und 300, was uns ungefähr 200.000 Testmethoden mit 10 bis 20 Codezeilen ergab, ohne die allgemeinen und zusätzlichen Klassen von Helfern, Datenanbietern und Datenmodellen zu berücksichtigen. <br><br>  So stellte sich heraus, dass unter Berücksichtigung der Zeitbeschränkungen (130 Arbeitstage) mindestens 10 Tests pro Tag durchgeführt werden mussten und gleichzeitig die Relevanz der durchgeführten Selbsttests unter Berücksichtigung der im System auftretenden Änderungen sichergestellt werden musste (das System entwickelt sich aktiv). <br><br>  Nach Schätzungen von Experten betrug der Arbeitsaufwand für die Entwicklung eines Autotests 4 bis 8 Stunden.  Wir haben also mindestens ein Team von 5 Personen (in Wirklichkeit hatte das Team auf dem Höhepunkt der Entwicklung von Autotests mehr als 10 Automatisierungsingenieure). <br><br>  Verständlich waren auch die Aufgaben, die gelöst werden mussten. <br><br><ul><li>  <b>Prozesse und Befehle konfigurieren:</b> </li><li>  Definieren Sie den Prozess der Interaktion mit dem Kunden (Funktionstestgruppe), legen Sie das Testfallbeschreibungsformat als Eingabe für das Automatisierungsteam fest. </li><li>  den Entwicklungs- und Wartungsprozess organisieren; </li><li>  ein Team bilden. <br></li><li>  <b>Entwickeln Sie Autotests mit den folgenden Funktionen:</b> </li><li>  Klicken Sie automatisch auf die Schaltflächen im Browser und überprüfen Sie vorab, ob Elemente und die erforderlichen Informationen auf der Seite vorhanden sind. </li><li>  Arbeiten mit komplexen Elementen wie Yandex.Map; </li><li>  um das Laden automatisch generierter Dateien in das System sicherzustellen, um das Herunterladen von Dateien vom System mit Überprüfung ihres Formats und Inhalts sicherzustellen. </li><li>  Stellen Sie einen Datensatz aus den Browser-Screenshots, Videos und internen Protokollen bereit. </li><li>  Um die Integration in externe Systeme wie einen Mailserver zu ermöglichen, überprüft das Task Tracking System (JIRA) die Integrationsprozesse zwischen dem getesteten System und externen Systemen. </li><li>  Bereitstellung eines dokumentierten Berichts über alle ergriffenen Maßnahmen, einschließlich einer Anzeige der eingegebenen und überprüften Werte sowie aller erforderlichen Investitionen. </li><li>  Führen Sie im parallelen Modus Tests mit dem erforderlichen Volumen durch. </li><li>  Stellen Sie Autotests in der vorhandenen Infrastruktur bereit. </li><li>  Verfeinern Sie die bereits automatisierten Testskripte des Konsonantenzielkonzepts (Verfeinerungsgeschwindigkeit - etwa 50 Tests pro Woche Sprint). </li></ul><br>  Wie ich in der Einleitung erwähnt habe, hatten wir zu Beginn einen funktionierenden MVP-Prototyp, der von einem anderen Team implementiert wurde. Dieser musste von 20 auf 1000 Tests erhöht werden, um neue Funktionen hinzuzufügen und eine akzeptable Skalierbarkeit und Flexibilität bei Änderungen sicherzustellen. <br><br>  Das Vorhandensein eines funktionierenden Prototyps am Eingang gab uns einen technologischen Stapel, der Folgendes umfasste: Java SE8, JUnit4, Selen + Selenid + Selenoid, Bambus als „Läufer“ von Tests und als „Erbauer“ von Allure-Berichten.  Da der Prototyp einwandfrei funktionierte und die erforderlichen Grundfunktionen bereitstellte, haben wir beschlossen, den technologischen Stack nicht zu ändern, sondern uns auf die Entwicklung der Skalierbarkeit der Lösung, die Erhöhung der Stabilität und die Entwicklung fehlender erforderlicher Funktionen zu konzentrieren. <br><br>  Grundsätzlich sah alles machbar und optimistisch aus.  Darüber hinaus haben wir die Aufgaben zu einem bestimmten Zeitpunkt vollständig bewältigt. <br><br>  Im Folgenden werden die einzelnen technologischen und prozessualen Aspekte der Entwicklung von AutoTests beschrieben. <br><br><h1>  Beschreibung der Autotests.  User Stories und Features </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/e52/429/345e524291244a67e411a344257eafa8.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> <br><br>  Autotests implementieren die folgenden User Stories im Kontext ihrer Verwendung durch die Testgruppe: <br><br><ul><li>  manuelle Testautomatisierung; </li><li>  automatische vollständige Regression; </li><li>  Qualitätskontrolle von Baugruppen in der CI \ CD-Kette. </li></ul><br>  Die Implementierungsdetails und Architekturentscheidungen werden in <b>Teil 2 - Technisch</b> erörtert <b>.</b>  <b>Architektur und technischer Stack.</b>  <b>Implementierungsdetails und technische Überraschungen</b> . <br><br><h2>  Automatisches und manuelles Testen (User Stories) </h2><br>  Als Tester möchte ich den Ziel-E2E-Test durchführen, der ohne meine direkte Teilnahme (im automatischen Modus) durchgeführt wird, und mir einen detaillierten Bericht im Kontext der durchgeführten Schritte einschließlich der eingegebenen Daten und der erhaltenen Ergebnisse sowie Folgendes zur Verfügung stellen. <br><br><ul><li>  Vor Beginn des Tests sollten verschiedene Zielstände ausgewählt werden können. </li><li>  sollte in der Lage sein, die Zusammensetzung der laufenden Tests von allen implementierten zu verwalten; </li><li>  Am Ende des Tests müssen Sie ein Video des Tests vom Browserbildschirm abrufen. </li><li>  Wenn der Test abstürzt, müssen Sie einen Screenshot des aktiven Browserfensters erhalten. </li></ul><br><h2>  Automatische vollständige Regression </h2><br>  Als Testgruppe möchte ich alle Tests jeden Abend auf einem bestimmten Prüfstand im automatischen Modus durchführen, einschließlich aller Funktionen des "automatischen manuellen Tests". <br><br><h2>  Qualitätskontrolle der Baugruppe in der CI \ CD-Kette </h2><br>  Als Testgruppe möchte ich automatische Tests der bereitgestellten Aktualisierungen des Systems auf einem dedizierten preQA-Stand durchführen, bevor ich die Ziel-Teststände für die Funktionstests aktualisiere, die später für Funktionstests verwendet wurden. <br><br><h1>  Grundfunktionen implementiert </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/92c/432/34792c43244275202d123378b2b6b72e.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> <br><br>  Hier finden Sie eine kurze Übersicht über die wichtigsten implementierten Funktionen von AutoTests, die sich als wichtig oder einfach nützlich erwiesen haben.  Details zur Implementierung einiger interessanter Funktionen finden Sie im zweiten Teil des Artikels. <br><br><h2>  Lokale und Remote-Verwendung </h2><br>  Die Funktion bot zwei Optionen zum Ausführen von Autotests - lokal und remote. <br><br>  Im lokalen Modus führte der Tester den erforderlichen Autotest an seinem Arbeitsplatz durch und konnte gleichzeitig beobachten, was im Browser geschah.  Der Start erfolgte durch das "grüne Dreieck" in IntelliJ IIDEA -).  Die Funktion war zu Beginn des Projekts sehr nützlich für Debugging und Demonstrationen, wird aber jetzt nur noch von den Entwicklern von Autotests verwendet. <br><br>  Im Remote-Modus startet der Tester den Autotest über die Schnittstelle des Bamboo-Plans mit den Parametern der Zusammensetzung der laufenden Tests, einem Stand und einigen anderen Parametern. <br><br>  <i>Die Funktion wurde mit der Umgebungsvariablen MODE = REMOTE | LOCAL implementiert, je nachdem, welcher lokale oder entfernte Webbrowser in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Selenoid-</a> Cloud initialisiert wurde.</i> <br><br><h2>  Begrenzung der Zusammensetzung laufender Tests nach Filter </h2><br>  Die Funktion ermöglicht es, die Zusammensetzung der laufenden Tests im Remote-Verwendungsmodus für Benutzer zu beschränken und die Testzeit zu verkürzen.  Es wird eine zweistufige Filtration verwendet.  Der erste Schritt blockiert die Ausführung von Tests basierend auf der Variablen FILTER_BLOCK und wird hauptsächlich verwendet, um große Gruppen von Tests von der Ausführung auszuschließen.  Im zweiten Schritt werden nur Tests übersprungen, die mit der Variablen FILTER übereinstimmen. <br><br>  Der Wert der Filter wird als Satz regulärer Ausdrücke REGEXP1, ..., REGEXPN angegeben, die nach dem Prinzip "ODER" angewendet werden. <br><br>  Beim Starten im manuellen Modus wurde der Tester aufgefordert, eine spezielle Umgebungsvariable als Liste regulärer Ausdrücke festzulegen, die auf die spezielle Annotation @ Filter (String value) anwendbar sind, mit der alle Testmethoden in den Testklassen kommentiert wurden.  Für jeden Test ist diese Anmerkung eindeutig und basiert auf einer Reihe von Tags, die durch einen Unterstrich getrennt sind.  Wir verwenden die folgende Mindestvorlage SUBSYSTEM_FUNCTION_TEST-ID_ {DEFAULT}, wobei das DEFAULT-Tag für Tests vorgesehen ist, die in der automatischen Nachtregression enthalten sind. <br><br>  <i>Die Funktion wird durch eine benutzerdefinierte Erweiterung der Klasse org.junit.runners.BlockJUnit4ClassRunner implementiert (Details werden in Teil 2-1 der Fortsetzung dieses Artikels angegeben).</i> <br><br><h2>  Dokumentation des Berichts mit den Ergebnissen für alle Schritte </h2><br>  Die Testergebnisse werden für alle Testaktionen (Schritte) mit allen erforderlichen Informationen angezeigt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> im Allure Framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfügbar sind</a> .  Sie aufzulisten macht keinen Sinn.  Sowohl auf der offiziellen Website als auch im gesamten Internet gibt es genügend Informationen.  Es gab keine Überraschungen bei der Verwendung des Allure Frameworks, und im Allgemeinen empfehle ich es zur Verwendung. <br><br>  Die Hauptfunktionen sind: <br><br><ul><li>  Anzeige jedes Testschritts (der Name des Schritts entspricht seinem Namen in der Testspezifikation - Testskript); </li><li>  Anzeigen von Schrittparametern in einer für Menschen lesbaren Form (durch die erforderliche Implementierung der toString-Methode aller übertragenen Werte); </li><li>  Anhängen von Screenshots, Videos und verschiedenen zusätzlichen Dateien an den Bericht; </li><li>  Klassifizierung von Tests nach Typen und Subsystemen sowie Verknüpfung des Autotests mit der Testspezifikation im Test Link-Testfallmanagementsystem durch Verwendung spezieller Anmerkungen. </li></ul><br><h2>  Laden Sie Dateien vom / in den Browser herunter und laden Sie sie hoch, um sie anschließend zu überprüfen und zu analysieren </h2><br>  Das Arbeiten mit Dateien ist ein äußerst wichtiger Aspekt von Testskripten.  Es war notwendig, sowohl verschiedene Dateien hochzuladen als auch herunterzuladen. <br><br>  <b>Das Herunterladen von Dateien</b> implizierte zunächst das Laden dynamisch generierter EXCEL-Dateien in das System gemäß dem Kontext der Ausführung des Testskripts.  Der Download wurde mit Standardmethoden implementiert, die von Selen-Tools bereitgestellt wurden. <br><br>  <b>Das Hochladen von Dateien</b> implizierte das Herunterladen von Dateien durch Drücken der Schaltfläche im Browser in ein lokales Verzeichnis und die anschließende Übertragung dieser Datei auf den Server, auf dem die AutoTests ausgeführt wurden (den Server, auf dem der Remote-Bamboo-Agent installiert war).  Außerdem wurde diese Datei analysiert und hinsichtlich Format und Inhalt analysiert.  Die Hauptdateitypen waren EXCEL- und PDF-Dateien. <br><br>  Die Implementierung dieser Funktion stellte sich als nicht triviale Aufgabe heraus, vor allem aufgrund des Mangels an Standardfunktionen für die Dateiverwaltung: Derzeit wird die Funktion nur für den Chrome-Browser über die Service-Seite "chrome: // downloads /" implementiert. <br><br>  Ich werde Sie im zweiten Teil ausführlich über die Implementierungsdetails informieren. <br><br><h2>  Abrechnung und Kontrolle der Asynchronität der Angular-Schnittstelle.  Ausstehende Anforderungssteuerung zwischen Angular- und REST-Diensten </h2><br>  Da das Objekt unserer Tests auf Angular basierte, mussten wir lernen, mit der Asynchronität des Frontends und der Zeitüberschreitungen zu „kämpfen“. <br><br>  Im Allgemeinen verwenden wir zusätzlich zu org.openqa.selenium.support.ui.FluentWait eine speziell entwickelte Wartemethode, die Javascript auf „unvollständige“ Interaktionen mit Front-End-REST-Diensten überprüft. Basierend auf diesem dynamischen Zeitlimit erhalten Tests Informationen darüber, ob sie folgen sollen dann etwas länger warten. <br><br>  Unter dem Gesichtspunkt der Funktionalität konnten wir den Zeitaufwand für die Durchführung der Tests erheblich reduzieren, da statische Erwartungen abgelehnt wurden, bei denen es nicht möglich ist, den Abschluss der Operation anders zu bestimmen.  Darüber hinaus konnten wir so „hängende“ REST-Services mit Leistungsproblemen definieren.  Sie haben beispielsweise einen REST-Service abgefangen, für den die Anzahl der auf der Seite angezeigten Einträge auf 10.000 Elemente festgelegt wurde. <br><br>  Informationen über den "eingefrorenen" REST-Dienst mit allen Parametern seines Aufrufs, aufgrund derer der Test aus infrastrukturellen Gründen "fällt", werden zu den Ergebnissen des abgebrochenen Tests hinzugefügt und zusätzlich als Ereignis in ELK gesendet.  Auf diese Weise können Sie die erkannten Probleme sofort an die entsprechenden Entwicklungsteams des Systems übertragen. <br><br><h2>  Browser-Protokollsteuerung </h2><br>  Die Browser-Protokollsteuerungsfunktion wurde hinzugefügt, um Fehler auf den SEVERE-Level-Seiten zu steuern und zusätzliche Informationen für abgebrochene Tests zu erhalten, z. B. um Fehler wie "... Ressource konnte nicht geladen werden: Der Server hat mit dem Status 500 (Interner Serverfehler) geantwortet" zu überwachen. <br><br>  Die Zusammensetzung der Seitenverarbeitungsfehler im Browser wird auf jedes Testergebnis angewendet und zusätzlich als Ereignisse im ELK entladen. <br><br><h2>  Videoaufzeichnung des Tests und Entfernen des Schnappschusses der Seite zum Zeitpunkt des "Sturzes" des Tests </h2><br>  Funktionen werden implementiert, um das Diagnostizieren und Parsen von abgelegten Tests zu vereinfachen. <br><br>  Die Videoaufzeichnung wird für den ausgewählten Remote-Testlaufmodus separat aktiviert.  Das Video wird als Anhang zu den Ergebnissen im Allure-Bericht angehängt. <br>  Ein Screenshot wird automatisch erstellt, wenn der Test abstürzt, und die Ergebnisse werden auch auf den Allure-Bericht angewendet. <br><br><h2>  Weitergabe von Ereignissen an ELK </h2><br>  Die Funktion zum Senden von Ereignissen an ELK ist implementiert, um eine statistische Analyse des allgemeinen Verhaltens von AutoTests und der Stabilität des Testobjekts zu ermöglichen.  Im Moment wurden das Senden von Ereignissen über den Abschluss von Tests mit den Ergebnissen und der Dauer sowie Browserfehler der SEVERE-Ebene und aufgezeichnete "eingefrorene" REST-Services implementiert. <br><br><h1>  Entwicklungsorganisation </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ee/a24/368/2eea243683bc7a87f0453db38b6c7947.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> <br><br><h2>  Entwicklungsteam </h2><br>  Wir brauchten also mindestens 5 Entwickler.  Fügen Sie eine weitere Person hinzu, um ungeplante Abwesenheiten auszugleichen.  Wir erhalten 6. Plus einen Teamleiter, der für die Querschnittsfunktionalität und die Codeüberprüfung verantwortlich ist. <br><br>  Daher mussten 6 Java-Entwickler hinzugezogen werden (in Wirklichkeit waren auf dem Höhepunkt der Entwicklung von Autotests mehr als 10 Automatisierungsingenieure im Team). <br><br>  Angesichts der allgemeinen Marktlage und eines relativ einfachen technologischen Stacks bestand das Team hauptsächlich aus Praktikanten, von denen die meisten entweder gerade ihren Abschluss an einer Universität gemacht hatten oder im letzten Jahr waren.  Tatsächlich suchten wir Leute mit Grundkenntnissen in Java.  Bevorzugt wurden manuelle Testspezialisten, die Programmierer werden möchten, und motivierte Kandidaten mit (unbedeutender) Entwicklungserfahrung, die künftig Programmierer werden wollten. <br><br>             ,           (    <b> 2 – .    .     </b> ). <br><br>    ,           ,             .        CodeRush .    . <br><br><h2>   </h2><br>       . ,    , «»        . <br><br>           () .    code review   merge request ( GitLab).   code review   «»    (  )       . <br><br>     –           .           /   ,         . <br><br> ode review   , ,      ()   -   ,    . ode review  . <br><br>     code review         ,        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08f/c89/1c7/08fc891c7ccd91d6e6c2235c06149a69.jpg" align="left" width="300">  :     ,      ,      ,     ,         .        ,     ,    ,    / . <br><br>      « »,      -   -.         -. <br><br>                   ,               .    sprint retrospective event. <br><br><h2>     </h2><br>         - ( )    ,      stakeholder  . <br><br>        –    .   ,            ,          .   ,      -    .       . <br><br>        - ( ,      . .),          .     () ,       « » / « » ( ,      ,            ). <br><br>  -             -   ( :    -  – ,   - ,   — ,    ).  ,       -       /  :    « -      (  )». <br><br>      -  ,     - (-)      - («» ).     «» -          -  «     X» ( ,       -). <br><br><h2>   </h2><br>     ,    .      master,    -. -   -         code review. <br><br>     ,        –     ,        . <br><br>  Eigenschaften: <br><br> <b>(+)</b>        ; <br> <b>(+)</b>              ; <br> <b>(+)</b>  «»      ; <br> <b>(-)</b>      (); <br> <b>(-)</b>       hotfix . <br><br>       . <br><br>  <b>Entwickler</b> <br><br><ul><li>      MASTER. </li><li>  . </li><li>      FEATURE . </li><li>           ,   «   »  rebase. </li><li> <b>     Gitlab   merge request    .  merge request- :</b> </li><li>  —       «Jira»; </li><li>  —       Bamboo. </li></ul><br> <b>GateKeeper ( )</b> <br><br><ul><li>         Bamboo. </li><li>          . </li><li>  (merge) FEATURE  DEVELOP,            . </li><li>    . </li></ul><br><hr><br> <i><b>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">kotalesssk</a> . <br><br>    1,      , .         2.</b> <br><br>   –  –        UI end-2-end    -.           ,   -          .            UI -     .   ,      .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473426/">https://habr.com/ru/post/de473426/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473412/index.html">Erstellen eines Plugins für Clang Static Analyzer zur Suche nach Ganzzahlüberläufen</a></li>
<li><a href="../de473416/index.html">ZeroNights 2019 Konferenzprogramm</a></li>
<li><a href="../de473418/index.html">OSCP - Offensive Sicherheit</a></li>
<li><a href="../de473420/index.html">Wir eröffnen die Saison der PHP-Meetups am 2. November in Nischni Nowgorod</a></li>
<li><a href="../de473424/index.html">ARM kündigte die Grafiklösungen Mali-G57 Valhall und Mali-D37 sowie die Neuroprozessoren Ethos-N57 und N37 an</a></li>
<li><a href="../de473430/index.html">FAQ zur Arbeit des Assistenten</a></li>
<li><a href="../de473432/index.html">Drei der besten Saint TeamLead Conf-Berichte</a></li>
<li><a href="../de473434/index.html">Ein systematischer Ansatz in Türkistönen an Bord der June</a></li>
<li><a href="../de473436/index.html">Transformation Management als Kompetenz</a></li>
<li><a href="../de473438/index.html">Wie chinesische Strategien bei der Arbeit helfen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>