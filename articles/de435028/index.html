<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üñäÔ∏è üíë C-Tests ohne SMS und Registrierung ü•É üèîÔ∏è üë®üèø‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√ºrzlich schrieb zerocost einen interessanten Artikel mit dem Titel ‚ÄûTests in C ++ ohne Makros und dynamischer Speicher‚Äú , in dem ein minimalistisches...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C-Tests ohne SMS und Registrierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435028/"><p><img src="https://habrastorage.org/webt/lg/12/b3/lg12b3c-s5uuok0_nialgfngc9e.png" alt="Screenshot Cutter" align="right">  K√ºrzlich schrieb <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">zerocost</a> einen interessanten Artikel mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûTests in C ++ ohne Makros und dynamischer Speicher‚Äú</a> , in dem ein minimalistisches Framework zum Testen von C ++ - Code er√∂rtert wird.  Der Autor hat es (fast) geschafft, die Verwendung von Makros zum Registrieren von Tests zu vermeiden, aber stattdessen erschienen im Code ‚Äûmagische‚Äú Vorlagen, die mir pers√∂nlich, sorry, unvorstellbar h√§sslich erscheinen.  Nachdem ich den Artikel gelesen hatte, hatte ich ein vages Gef√ºhl der Unzufriedenheit, da ich <em>wusste,</em> was besser gemacht werden k√∂nnte.  Ich konnte mich nicht sofort erinnern, wo, aber ich <em>sah definitiv</em> den Testcode, der kein einziges zus√§tzliches Zeichen enth√§lt, um sie zu registrieren: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-string"><span class="hljs-string">"2 + 2 = ?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Schlie√ülich erinnerte ich mich daran, dass dieses Framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Cutter</strong></a> hei√üt und auf geniale Weise Testfunktionen auf seine eigene Weise identifiziert. </p><a name="habracut"></a><br><p>  (KDPV von der Cutter-Website unter CC BY-SA.) </p><br><h2 id="v-chyom-zhe-tryuk">  Was ist der Trick? </h2><br><p>  Der Testcode wird in einer separaten gemeinsam genutzten Bibliothek zusammengestellt.  Testfunktionen werden aus exportierten Bibliothekssymbolen extrahiert und durch Namen identifiziert.  Tests werden von einem speziellen externen Dienstprogramm durchgef√ºhrt.  Sapienti sa√ü. </p><br><pre> <code class="cpp hljs">$ cat test_addition.c <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cutter.h&gt; void test_addition() { cut_assert_equal_int(2 + 2, 5); }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ cc -shared -o test_addition.so \ -I/usr/include/cutter -lcutter \ test_addition.c</code> </pre> <br><pre> <code class="plaintext hljs">$ cutter . F ========================================================================= Failure: test_addition &lt;2 + 2 == 5&gt; expected: &lt;4&gt; actual: &lt;5&gt; test_addition.c:5: void test_addition(): cut_assert_equal_int(2 + 2, 5, ) ========================================================================= Finished in 0.000943 seconds (total: 0.000615 seconds) 1 test(s), 0 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s) 0% passed</code> </pre> <br><p>  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel aus der Cutter-Dokumentation</a> .  Sie k√∂nnen sicher durch alles bl√§ttern, was mit Autotools zu tun hat, und nur den Code anzeigen.  Das Framework ist ein bisschen seltsam, ja, wie alles Japanische. </p><br><p>  Ich werde nicht zu sehr auf die Implementierungsfunktionen eingehen.  Ich habe auch keinen vollwertigen Code (und zumindest keinen Entwurf), da ich ihn pers√∂nlich nicht wirklich brauche (in Rust ist alles sofort einsatzbereit).  F√ºr Interessierte kann dies jedoch eine gute √úbung sein. </p><br><h2 id="detali-i-vozmozhnosti-realizacii">  Details und Implementierungsoptionen </h2><br><p>  Ber√ºcksichtigen Sie einige der Aufgaben, die Sie beim Schreiben eines Frameworks zum Testen mit dem Cutter-Ansatz l√∂sen m√ºssen. </p><br><h3 id="poluchenie-eksportiruemyh-funkciy">  Exportierte Funktionen abrufen </h3><br><p>  Zuerst m√ºssen Sie irgendwie zu den Testfunktionen gelangen.  Der C ++ - Standard beschreibt nat√ºrlich √ºberhaupt keine gemeinsam genutzten Bibliotheken.  Windows hat k√ºrzlich ein Linux-Subsystem erworben, mit dem alle drei Hauptbetriebssysteme auf POSIX reduziert werden k√∂nnen.  Wie Sie wissen, bieten POSIX-Systeme die Funktionen <code>dlopen()</code> , <code>dlsym()</code> , <code>dlclose()</code> , mit denen Sie die Adresse der Funktion <code>dlclose()</code> k√∂nnen, den Namen ihres Symbols kennen und ... das ist alles.  Die Liste der in der geladenen Bibliothek enthaltenen Funktionen wird von POSIX nicht ver√∂ffentlicht. </p><br><p>  Leider (obwohl zum Gl√ºck) gibt es keine tragbare Standardmethode, um alle aus der Bibliothek exportierten Funktionen zu ermitteln.  Vielleicht ist die Tatsache, dass das Konzept einer <em>Bibliothek</em> nicht auf allen Plattformen existiert (sprich: eingebettet), hier irgendwie beteiligt.  Aber das ist nicht der Punkt.  Die Hauptsache ist, dass Sie plattformspezifische Funktionen verwenden m√ºssen. </p><br><p>  In erster N√§herung k√∂nnen Sie einfach das Dienstprogramm <strong>nm</strong> aufrufen: </p><br><pre> <code class="cpp hljs">$ cat test.<span class="hljs-function"><span class="hljs-function">cpp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><pre> <code class="plaintext hljs">$ clang -shared test.cpp</code> </pre> <br><pre> <code class="plaintext hljs">$ nm -gj ./a.out __Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  Analysieren Sie die Ausgabe und verwenden Sie <code>dlsym()</code> . </p><br><p>  F√ºr eine tiefere Selbstbeobachtung sind Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libelf</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libMachO</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pe-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parse</a> hilfreich, mit denen Sie ausf√ºhrbare Dateien und Bibliotheken von Plattformen, die f√ºr Sie von Interesse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind</a> , programmgesteuert analysieren k√∂nnen.  Tats√§chlich verwenden <strong>nm</strong> und das Unternehmen sie nur. </p><br><h3 id="filtraciya-testovyh-funkciy">  Testfunktionsfilterung </h3><br><p>  Wie Sie vielleicht bemerkt haben, enthalten die Bibliotheken einige seltsame Zeichen: </p><br><pre> <code class="plaintext hljs">__Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  Dies ist <code>__Z20test_object_additionv</code> , wenn wir die Funktion nur <code>test_object_addition</code> ?  Und was ist das √ºbrig <code>dyld_stub_binder</code> ? </p><br><p>  Die " <code>__Z20...</code> " Zeichen <code>__Z20...</code> sind die sogenannte <em>Namensdekoration</em> (Name Mangling).  C ++ Kompilierungsfunktion, nichts kann getan werden, leben Sie damit.  Dies ist, was Funktionen aus Sicht des Systems (und <code>dlsym()</code> ) <code>dlsym()</code> .  Um sie einer Person in ihrer normalen Form zu zeigen, k√∂nnen Sie Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libdemangle verwenden</a> .  Nat√ºrlich h√§ngt die Bibliothek, die Sie ben√∂tigen, vom verwendeten Compiler ab, aber das Dekorationsformat ist im Rahmen der Plattform normalerweise dasselbe. </p><br><p>  Seltsame Funktionen wie <code>dyld_stub_binder</code> sind ebenfalls Plattformfunktionen, die ber√ºcksichtigt werden m√ºssen.  Sie m√ºssen zu Beginn der Tests keine Funktionen aufrufen, da dort keine Fische vorhanden sind. </p><br><p>  Eine logische Fortsetzung dieser Idee besteht darin, die Funktion nach Namen zu filtern.  Beispielsweise k√∂nnen Sie Funktionen nur mit <code>test</code> im Namen ausf√ºhren.  Oder funktioniert einfach aus dem <code>tests</code> Namespace.  Verwenden Sie auch verschachtelte Namespaces, um Tests zu gruppieren.  Ihrer Fantasie sind keine Grenzen gesetzt. </p><br><h3 id="peredacha-konteksta-ispolnyaemogo-testa">  √úbergeben des Kontexts eines ausf√ºhrbaren Tests </h3><br><p>  Objektdateien mit Tests werden in einer gemeinsam genutzten Bibliothek gesammelt, deren Ausf√ºhrung vollst√§ndig von einem externen Dienstprogramm-Treiber gesteuert wird - <code>cutter</code> for Cutter.  Dementsprechend k√∂nnen interne Testfunktionen dies nutzen. </p><br><p>  Beispielsweise kann der Kontext eines ausf√ºhrbaren Tests ( <code>IRuntime</code> im Originalartikel) sicher durch eine globale ( <code>IRuntime</code> ) Variable √ºbergeben werden.  Der Fahrer ist f√ºr die Verwaltung und Weitergabe des Kontexts verantwortlich. </p><br><p>  In diesem Fall erfordern die Testfunktionen keine Argumente, behalten jedoch alle erweiterten Funktionen bei, z. B. die willk√ºrliche Benennung der getesteten F√§lle: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_vector_add_element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ testing::description(<span class="hljs-string"><span class="hljs-string">"vector size grows after push_back()"</span></span>); }</code> </pre> <br><p>  Die Funktion <code>description()</code> greift √ºber eine globale Variable auf die bedingte <code>IRuntime</code> und kann somit einen Kommentar an das Framework f√ºr eine Person √ºbergeben.  Die Sicherheit der Verwendung des globalen Kontexts wird durch das Framework garantiert und liegt nicht in der Verantwortung des Testschreibers. </p><br><p>  Bei diesem Ansatz tritt weniger Code im Code auf, wenn der Kontext auf die Vergleichsanweisungen und internen Testfunktionen √ºbertragen wird, die m√∂glicherweise von der Hauptanweisung aufgerufen werden m√ºssen. </p><br><h3 id="konstruktory-i-destruktory">  Konstruktoren und Destruktoren </h3><br><p>  Da die Ausf√ºhrung von Tests vollst√§ndig vom Treiber gesteuert wird, kann zus√§tzlicher Code <em>um die</em> Tests <em>herum ausgef√ºhrt</em> werden. </p><br><p>  Die Cutter-Bibliothek verwendet hierf√ºr folgende Funktionen: </p><br><ul><li>  <code>cut_setup()</code> - vor jedem einzelnen Test </li><li>  <code>cut_teardown()</code> - nach jedem einzelnen Test </li><li>  <code>cut_startup()</code> - bevor alle Tests ausgef√ºhrt werden </li><li>  <code>cut_shutdown()</code> - nach Abschluss aller Tests </li></ul><br><p>  Diese Funktionen werden nur aufgerufen, wenn sie in der Testdatei definiert sind.  Sie k√∂nnen die Vorbereitung und Reinigung der Testumgebung (Fixture) in sie einf√ºgen: die Erstellung der erforderlichen tempor√§ren Dateien, die schwierige Einrichtung der getesteten Objekte und andere Testmuster. </p><br><p>  F√ºr C ++ ist es m√∂glich, eine idiomatischere Oberfl√§che zu entwickeln: </p><br><ul><li>  objektorientierter und typsicherer </li><li>  mit besserer Unterst√ºtzung des RAII-Konzepts </li><li>  Verwendung von Lambdas zur verz√∂gerten Ausf√ºhrung </li><li>  mit Testausf√ºhrungskontext </li></ul><br><p>  Aber jetzt denke ich noch einmal ausf√ºhrlich dar√ºber nach. </p><br><h3 id="samodostatochnye-ispolnimye-fayly-s-testami">  In sich geschlossene ausf√ºhrbare Testdateien </h3><br><p>  Cutter verwendet zur Vereinfachung einen Ansatz f√ºr gemeinsam genutzte Bibliotheken.  Verschiedene Tests werden in einer Reihe von Bibliotheken kompiliert, die von einem separaten Testdienstprogramm gefunden und ausgef√ºhrt werden.  Auf Wunsch kann nat√ºrlich der gesamte Code des Testtreibers direkt in die ausf√ºhrbare Datei eingebettet werden, wobei die √ºblichen separaten Dateien abgerufen werden.  Dies erfordert jedoch die Zusammenarbeit mit dem Build-System, um das Layout dieser ausf√ºhrbaren Dateien richtig zu organisieren: ohne ‚Äûunbenutzte‚Äú Funktionen mit den richtigen Abh√§ngigkeiten usw. auszuschneiden. </p><br><h3 id="prochee">  Andere </h3><br><p>  Cutter und andere Frameworks haben auch viele andere n√ºtzliche Dinge, die das Leben beim Schreiben von Tests erleichtern k√∂nnen: </p><br><ul><li>  flexible und <em>erweiterbare</em> Testanweisungen </li><li>  Erstellen und Abrufen von Testdaten aus Dateien </li><li>  Stack-Trace-Studien, Ausnahme- und Drop-Handling </li><li>  anpassbare ‚ÄûAufschl√ºsselungsstufen‚Äú von Tests </li><li>  Ausf√ºhren von Tests in mehreren Prozessen </li></ul><br><p>  Es lohnt sich, beim Schreiben Ihres Fahrrads auf vorhandene Rahmenbedingungen zur√ºckzublicken.  UX ist ein viel tieferes Thema. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der vom Cutter-Framework verwendete Ansatz erm√∂glicht die Identifizierung von Testfunktionen mit minimaler kognitiver Belastung des Programmierers: Schreiben Sie einfach Testfunktionen und fertig.  Der Code erfordert keine speziellen Vorlagen oder Makros, was die Lesbarkeit erh√∂ht. </p><br><p>  Die Funktionen zum Zusammenstellen und Ausf√ºhren von Tests k√∂nnen in wiederverwendbaren Modulen f√ºr Montagesysteme wie Makefile, CMake usw. verborgen sein. Fragen zu einer separaten Zusammenstellung von Tests m√ºssen noch auf die eine oder andere Weise gestellt werden. </p><br><p>  Zu den Nachteilen dieses Ansatzes geh√∂rt die Schwierigkeit, Tests in derselben Datei (derselben √úbersetzungseinheit) wie der Hauptcode abzulegen.  Leider ist es in diesem Fall ohne zus√§tzliche Hinweise nicht mehr m√∂glich herauszufinden, welche Funktionen gestartet werden m√ºssen und welche nicht.  Gl√ºcklicherweise ist es in C ++ normalerweise √ºblich, Tests und Implementierung in verschiedene Dateien zu verteilen. </p><br><p>  Was die endg√ºltige Entsorgung von Makros betrifft, so scheint es mir, dass sie im <em>Prinzip</em> nicht aufgegeben werden sollten.  Mit Makros k√∂nnen beispielsweise k√ºrzere Vergleichsanweisungen geschrieben werden, um Codeduplikationen zu vermeiden: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br><p>  aber gleichzeitig den gleichen Informationsgehalt des Problems im Fehlerfall beibehalten: </p><br><pre> <code class="plaintext hljs">Failure: test_object_addition &lt;ensure_equals(2 + 2, 5)&gt; expected: &lt;5&gt; actual: &lt;4&gt; test.c:5: test_object_addition()</code> </pre> <br><p>  Der Name der getesteten Funktion, der Dateiname und die Zeilennummer des Funktionsstarts k√∂nnen theoretisch aus den Debuginformationen extrahiert werden, die in der gesammelten Bibliothek enthalten sind.  Der erwartete und der tats√§chliche Wert der verglichenen Ausdr√ºcke sind der Funktion <code>ensure_equals()</code> .  Mit dem Makro k√∂nnen Sie die urspr√ºngliche Schreibweise der Testanweisung "wiederherstellen", wodurch klarer wird, warum der Wert <code>4</code> erwartet wird. </p><br><p>  Dies ist jedoch nicht jedermanns Sache.  Endet der Nutzen von Makros f√ºr Testcode dort?  Ich habe noch nicht wirklich √ºber diesen Moment nachgedacht, der sich als ein gutes Feld f√ºr weitere herausstellen k√∂nnte <del>  Perversionen </del>  Forschung.  Eine viel interessantere Frage: Ist es m√∂glich, ein <em>Mock-Framework</em> f√ºr C ++ ohne Makros zu erstellen? </p><br><p>  Der aufmerksame Leser bemerkte auch, dass die Implementierung wirklich keine SMS und Asbest enth√§lt, was zweifellos ein Plus f√ºr die √ñkologie und √ñkonomie der Erde ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435028/">https://habr.com/ru/post/de435028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435014/index.html">Dart vs Node.js: Vergleich der Leistung bei HTTP-Server-Implementierungen</a></li>
<li><a href="../de435016/index.html">Was Larry Ellison zu Tesla bringen wird</a></li>
<li><a href="../de435018/index.html">Im Jahr 2018 haben wir endlich begonnen, die Zeit, die wir mit dem Smartphone verbracht haben, ernst zu nehmen</a></li>
<li><a href="../de435020/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Ger√§te der letzten 50 Jahre, Teil 2</a></li>
<li><a href="../de435026/index.html">Wir machen einen Boten *, der auch im Aufzug funktioniert</a></li>
<li><a href="../de435032/index.html">Das Chang'e-4-Raumschiff landete erfolgreich auf der anderen Seite des Mondes und schickte das erste Foto</a></li>
<li><a href="../de435036/index.html">Gedanken zur modernen C ++ - und Spieleentwicklung</a></li>
<li><a href="../de435038/index.html">Weltkraft im Jahr 2018</a></li>
<li><a href="../de435040/index.html">Bitcoin vor 10 Jahren</a></li>
<li><a href="../de435044/index.html">Altert√ºmer: Minidisc in seinem nat√ºrlichen Lebensraum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>