<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👦 🖊️ 💑 C-Tests ohne SMS und Registrierung 🥃 🏔️ 👨🏿‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kürzlich schrieb zerocost einen interessanten Artikel mit dem Titel „Tests in C ++ ohne Makros und dynamischer Speicher“ , in dem ein minimalistisches...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C-Tests ohne SMS und Registrierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435028/"><p><img src="https://habrastorage.org/webt/lg/12/b3/lg12b3c-s5uuok0_nialgfngc9e.png" alt="Screenshot Cutter" align="right">  Kürzlich schrieb <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">zerocost</a> einen interessanten Artikel mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Tests in C ++ ohne Makros und dynamischer Speicher“</a> , in dem ein minimalistisches Framework zum Testen von C ++ - Code erörtert wird.  Der Autor hat es (fast) geschafft, die Verwendung von Makros zum Registrieren von Tests zu vermeiden, aber stattdessen erschienen im Code „magische“ Vorlagen, die mir persönlich, sorry, unvorstellbar hässlich erscheinen.  Nachdem ich den Artikel gelesen hatte, hatte ich ein vages Gefühl der Unzufriedenheit, da ich <em>wusste,</em> was besser gemacht werden könnte.  Ich konnte mich nicht sofort erinnern, wo, aber ich <em>sah definitiv</em> den Testcode, der kein einziges zusätzliches Zeichen enthält, um sie zu registrieren: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-string"><span class="hljs-string">"2 + 2 = ?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Schließlich erinnerte ich mich daran, dass dieses Framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Cutter</strong></a> heißt und auf geniale Weise Testfunktionen auf seine eigene Weise identifiziert. </p><a name="habracut"></a><br><p>  (KDPV von der Cutter-Website unter CC BY-SA.) </p><br><h2 id="v-chyom-zhe-tryuk">  Was ist der Trick? </h2><br><p>  Der Testcode wird in einer separaten gemeinsam genutzten Bibliothek zusammengestellt.  Testfunktionen werden aus exportierten Bibliothekssymbolen extrahiert und durch Namen identifiziert.  Tests werden von einem speziellen externen Dienstprogramm durchgeführt.  Sapienti saß. </p><br><pre> <code class="cpp hljs">$ cat test_addition.c <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cutter.h&gt; void test_addition() { cut_assert_equal_int(2 + 2, 5); }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ cc -shared -o test_addition.so \ -I/usr/include/cutter -lcutter \ test_addition.c</code> </pre> <br><pre> <code class="plaintext hljs">$ cutter . F ========================================================================= Failure: test_addition &lt;2 + 2 == 5&gt; expected: &lt;4&gt; actual: &lt;5&gt; test_addition.c:5: void test_addition(): cut_assert_equal_int(2 + 2, 5, ) ========================================================================= Finished in 0.000943 seconds (total: 0.000615 seconds) 1 test(s), 0 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s) 0% passed</code> </pre> <br><p>  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel aus der Cutter-Dokumentation</a> .  Sie können sicher durch alles blättern, was mit Autotools zu tun hat, und nur den Code anzeigen.  Das Framework ist ein bisschen seltsam, ja, wie alles Japanische. </p><br><p>  Ich werde nicht zu sehr auf die Implementierungsfunktionen eingehen.  Ich habe auch keinen vollwertigen Code (und zumindest keinen Entwurf), da ich ihn persönlich nicht wirklich brauche (in Rust ist alles sofort einsatzbereit).  Für Interessierte kann dies jedoch eine gute Übung sein. </p><br><h2 id="detali-i-vozmozhnosti-realizacii">  Details und Implementierungsoptionen </h2><br><p>  Berücksichtigen Sie einige der Aufgaben, die Sie beim Schreiben eines Frameworks zum Testen mit dem Cutter-Ansatz lösen müssen. </p><br><h3 id="poluchenie-eksportiruemyh-funkciy">  Exportierte Funktionen abrufen </h3><br><p>  Zuerst müssen Sie irgendwie zu den Testfunktionen gelangen.  Der C ++ - Standard beschreibt natürlich überhaupt keine gemeinsam genutzten Bibliotheken.  Windows hat kürzlich ein Linux-Subsystem erworben, mit dem alle drei Hauptbetriebssysteme auf POSIX reduziert werden können.  Wie Sie wissen, bieten POSIX-Systeme die Funktionen <code>dlopen()</code> , <code>dlsym()</code> , <code>dlclose()</code> , mit denen Sie die Adresse der Funktion <code>dlclose()</code> können, den Namen ihres Symbols kennen und ... das ist alles.  Die Liste der in der geladenen Bibliothek enthaltenen Funktionen wird von POSIX nicht veröffentlicht. </p><br><p>  Leider (obwohl zum Glück) gibt es keine tragbare Standardmethode, um alle aus der Bibliothek exportierten Funktionen zu ermitteln.  Vielleicht ist die Tatsache, dass das Konzept einer <em>Bibliothek</em> nicht auf allen Plattformen existiert (sprich: eingebettet), hier irgendwie beteiligt.  Aber das ist nicht der Punkt.  Die Hauptsache ist, dass Sie plattformspezifische Funktionen verwenden müssen. </p><br><p>  In erster Näherung können Sie einfach das Dienstprogramm <strong>nm</strong> aufrufen: </p><br><pre> <code class="cpp hljs">$ cat test.<span class="hljs-function"><span class="hljs-function">cpp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><pre> <code class="plaintext hljs">$ clang -shared test.cpp</code> </pre> <br><pre> <code class="plaintext hljs">$ nm -gj ./a.out __Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  Analysieren Sie die Ausgabe und verwenden Sie <code>dlsym()</code> . </p><br><p>  Für eine tiefere Selbstbeobachtung sind Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libelf</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libMachO</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pe-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parse</a> hilfreich, mit denen Sie ausführbare Dateien und Bibliotheken von Plattformen, die für Sie von Interesse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind</a> , programmgesteuert analysieren können.  Tatsächlich verwenden <strong>nm</strong> und das Unternehmen sie nur. </p><br><h3 id="filtraciya-testovyh-funkciy">  Testfunktionsfilterung </h3><br><p>  Wie Sie vielleicht bemerkt haben, enthalten die Bibliotheken einige seltsame Zeichen: </p><br><pre> <code class="plaintext hljs">__Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  Dies ist <code>__Z20test_object_additionv</code> , wenn wir die Funktion nur <code>test_object_addition</code> ?  Und was ist das übrig <code>dyld_stub_binder</code> ? </p><br><p>  Die " <code>__Z20...</code> " Zeichen <code>__Z20...</code> sind die sogenannte <em>Namensdekoration</em> (Name Mangling).  C ++ Kompilierungsfunktion, nichts kann getan werden, leben Sie damit.  Dies ist, was Funktionen aus Sicht des Systems (und <code>dlsym()</code> ) <code>dlsym()</code> .  Um sie einer Person in ihrer normalen Form zu zeigen, können Sie Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libdemangle verwenden</a> .  Natürlich hängt die Bibliothek, die Sie benötigen, vom verwendeten Compiler ab, aber das Dekorationsformat ist im Rahmen der Plattform normalerweise dasselbe. </p><br><p>  Seltsame Funktionen wie <code>dyld_stub_binder</code> sind ebenfalls Plattformfunktionen, die berücksichtigt werden müssen.  Sie müssen zu Beginn der Tests keine Funktionen aufrufen, da dort keine Fische vorhanden sind. </p><br><p>  Eine logische Fortsetzung dieser Idee besteht darin, die Funktion nach Namen zu filtern.  Beispielsweise können Sie Funktionen nur mit <code>test</code> im Namen ausführen.  Oder funktioniert einfach aus dem <code>tests</code> Namespace.  Verwenden Sie auch verschachtelte Namespaces, um Tests zu gruppieren.  Ihrer Fantasie sind keine Grenzen gesetzt. </p><br><h3 id="peredacha-konteksta-ispolnyaemogo-testa">  Übergeben des Kontexts eines ausführbaren Tests </h3><br><p>  Objektdateien mit Tests werden in einer gemeinsam genutzten Bibliothek gesammelt, deren Ausführung vollständig von einem externen Dienstprogramm-Treiber gesteuert wird - <code>cutter</code> for Cutter.  Dementsprechend können interne Testfunktionen dies nutzen. </p><br><p>  Beispielsweise kann der Kontext eines ausführbaren Tests ( <code>IRuntime</code> im Originalartikel) sicher durch eine globale ( <code>IRuntime</code> ) Variable übergeben werden.  Der Fahrer ist für die Verwaltung und Weitergabe des Kontexts verantwortlich. </p><br><p>  In diesem Fall erfordern die Testfunktionen keine Argumente, behalten jedoch alle erweiterten Funktionen bei, z. B. die willkürliche Benennung der getesteten Fälle: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_vector_add_element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ testing::description(<span class="hljs-string"><span class="hljs-string">"vector size grows after push_back()"</span></span>); }</code> </pre> <br><p>  Die Funktion <code>description()</code> greift über eine globale Variable auf die bedingte <code>IRuntime</code> und kann somit einen Kommentar an das Framework für eine Person übergeben.  Die Sicherheit der Verwendung des globalen Kontexts wird durch das Framework garantiert und liegt nicht in der Verantwortung des Testschreibers. </p><br><p>  Bei diesem Ansatz tritt weniger Code im Code auf, wenn der Kontext auf die Vergleichsanweisungen und internen Testfunktionen übertragen wird, die möglicherweise von der Hauptanweisung aufgerufen werden müssen. </p><br><h3 id="konstruktory-i-destruktory">  Konstruktoren und Destruktoren </h3><br><p>  Da die Ausführung von Tests vollständig vom Treiber gesteuert wird, kann zusätzlicher Code <em>um die</em> Tests <em>herum ausgeführt</em> werden. </p><br><p>  Die Cutter-Bibliothek verwendet hierfür folgende Funktionen: </p><br><ul><li>  <code>cut_setup()</code> - vor jedem einzelnen Test </li><li>  <code>cut_teardown()</code> - nach jedem einzelnen Test </li><li>  <code>cut_startup()</code> - bevor alle Tests ausgeführt werden </li><li>  <code>cut_shutdown()</code> - nach Abschluss aller Tests </li></ul><br><p>  Diese Funktionen werden nur aufgerufen, wenn sie in der Testdatei definiert sind.  Sie können die Vorbereitung und Reinigung der Testumgebung (Fixture) in sie einfügen: die Erstellung der erforderlichen temporären Dateien, die schwierige Einrichtung der getesteten Objekte und andere Testmuster. </p><br><p>  Für C ++ ist es möglich, eine idiomatischere Oberfläche zu entwickeln: </p><br><ul><li>  objektorientierter und typsicherer </li><li>  mit besserer Unterstützung des RAII-Konzepts </li><li>  Verwendung von Lambdas zur verzögerten Ausführung </li><li>  mit Testausführungskontext </li></ul><br><p>  Aber jetzt denke ich noch einmal ausführlich darüber nach. </p><br><h3 id="samodostatochnye-ispolnimye-fayly-s-testami">  In sich geschlossene ausführbare Testdateien </h3><br><p>  Cutter verwendet zur Vereinfachung einen Ansatz für gemeinsam genutzte Bibliotheken.  Verschiedene Tests werden in einer Reihe von Bibliotheken kompiliert, die von einem separaten Testdienstprogramm gefunden und ausgeführt werden.  Auf Wunsch kann natürlich der gesamte Code des Testtreibers direkt in die ausführbare Datei eingebettet werden, wobei die üblichen separaten Dateien abgerufen werden.  Dies erfordert jedoch die Zusammenarbeit mit dem Build-System, um das Layout dieser ausführbaren Dateien richtig zu organisieren: ohne „unbenutzte“ Funktionen mit den richtigen Abhängigkeiten usw. auszuschneiden. </p><br><h3 id="prochee">  Andere </h3><br><p>  Cutter und andere Frameworks haben auch viele andere nützliche Dinge, die das Leben beim Schreiben von Tests erleichtern können: </p><br><ul><li>  flexible und <em>erweiterbare</em> Testanweisungen </li><li>  Erstellen und Abrufen von Testdaten aus Dateien </li><li>  Stack-Trace-Studien, Ausnahme- und Drop-Handling </li><li>  anpassbare „Aufschlüsselungsstufen“ von Tests </li><li>  Ausführen von Tests in mehreren Prozessen </li></ul><br><p>  Es lohnt sich, beim Schreiben Ihres Fahrrads auf vorhandene Rahmenbedingungen zurückzublicken.  UX ist ein viel tieferes Thema. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der vom Cutter-Framework verwendete Ansatz ermöglicht die Identifizierung von Testfunktionen mit minimaler kognitiver Belastung des Programmierers: Schreiben Sie einfach Testfunktionen und fertig.  Der Code erfordert keine speziellen Vorlagen oder Makros, was die Lesbarkeit erhöht. </p><br><p>  Die Funktionen zum Zusammenstellen und Ausführen von Tests können in wiederverwendbaren Modulen für Montagesysteme wie Makefile, CMake usw. verborgen sein. Fragen zu einer separaten Zusammenstellung von Tests müssen noch auf die eine oder andere Weise gestellt werden. </p><br><p>  Zu den Nachteilen dieses Ansatzes gehört die Schwierigkeit, Tests in derselben Datei (derselben Übersetzungseinheit) wie der Hauptcode abzulegen.  Leider ist es in diesem Fall ohne zusätzliche Hinweise nicht mehr möglich herauszufinden, welche Funktionen gestartet werden müssen und welche nicht.  Glücklicherweise ist es in C ++ normalerweise üblich, Tests und Implementierung in verschiedene Dateien zu verteilen. </p><br><p>  Was die endgültige Entsorgung von Makros betrifft, so scheint es mir, dass sie im <em>Prinzip</em> nicht aufgegeben werden sollten.  Mit Makros können beispielsweise kürzere Vergleichsanweisungen geschrieben werden, um Codeduplikationen zu vermeiden: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br><p>  aber gleichzeitig den gleichen Informationsgehalt des Problems im Fehlerfall beibehalten: </p><br><pre> <code class="plaintext hljs">Failure: test_object_addition &lt;ensure_equals(2 + 2, 5)&gt; expected: &lt;5&gt; actual: &lt;4&gt; test.c:5: test_object_addition()</code> </pre> <br><p>  Der Name der getesteten Funktion, der Dateiname und die Zeilennummer des Funktionsstarts können theoretisch aus den Debuginformationen extrahiert werden, die in der gesammelten Bibliothek enthalten sind.  Der erwartete und der tatsächliche Wert der verglichenen Ausdrücke sind der Funktion <code>ensure_equals()</code> .  Mit dem Makro können Sie die ursprüngliche Schreibweise der Testanweisung "wiederherstellen", wodurch klarer wird, warum der Wert <code>4</code> erwartet wird. </p><br><p>  Dies ist jedoch nicht jedermanns Sache.  Endet der Nutzen von Makros für Testcode dort?  Ich habe noch nicht wirklich über diesen Moment nachgedacht, der sich als ein gutes Feld für weitere herausstellen könnte <del>  Perversionen </del>  Forschung.  Eine viel interessantere Frage: Ist es möglich, ein <em>Mock-Framework</em> für C ++ ohne Makros zu erstellen? </p><br><p>  Der aufmerksame Leser bemerkte auch, dass die Implementierung wirklich keine SMS und Asbest enthält, was zweifellos ein Plus für die Ökologie und Ökonomie der Erde ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435028/">https://habr.com/ru/post/de435028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435014/index.html">Dart vs Node.js: Vergleich der Leistung bei HTTP-Server-Implementierungen</a></li>
<li><a href="../de435016/index.html">Was Larry Ellison zu Tesla bringen wird</a></li>
<li><a href="../de435018/index.html">Im Jahr 2018 haben wir endlich begonnen, die Zeit, die wir mit dem Smartphone verbracht haben, ernst zu nehmen</a></li>
<li><a href="../de435020/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Geräte der letzten 50 Jahre, Teil 2</a></li>
<li><a href="../de435026/index.html">Wir machen einen Boten *, der auch im Aufzug funktioniert</a></li>
<li><a href="../de435032/index.html">Das Chang'e-4-Raumschiff landete erfolgreich auf der anderen Seite des Mondes und schickte das erste Foto</a></li>
<li><a href="../de435036/index.html">Gedanken zur modernen C ++ - und Spieleentwicklung</a></li>
<li><a href="../de435038/index.html">Weltkraft im Jahr 2018</a></li>
<li><a href="../de435040/index.html">Bitcoin vor 10 Jahren</a></li>
<li><a href="../de435044/index.html">Altertümer: Minidisc in seinem natürlichen Lebensraum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>