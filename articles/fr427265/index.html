<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå∑ üè´ ü§∞üèª Les protobuffers ont tort üó°Ô∏è ü§® üíá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendant la majeure partie de ma vie professionnelle, je suis oppos√© √† l'utilisation de tampons de protocole. Ils sont clairement √©crits par des amateu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les protobuffers ont tort</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427265/"> Pendant la majeure partie de ma vie professionnelle, je suis oppos√© √† l'utilisation de tampons de protocole.  Ils sont clairement √©crits par des amateurs, incroyablement hautement sp√©cialis√©s, souffrent de nombreux pi√®ges, sont difficiles √† compiler et √† r√©soudre un probl√®me que personne d'autre que Google n'a r√©ellement.  Si ces probl√®mes de proto-tampons restaient dans la quarantaine des abstractions de s√©rialisation, alors mes revendications s'arr√™teraient l√†.  Mais malheureusement, la mauvaise conception des Protobuffers est si intrusive que ces probl√®mes peuvent s'infiltrer dans votre code. <br><br>  <b>Sp√©cialisation √©troite et d√©veloppement par des amateurs</b> <br><br>  Arr√™te.  Fermez votre client de messagerie, o√π vous m'avez d√©j√† √©crit une lettre disant que "les meilleurs ing√©nieurs du monde travaillent chez Google", que "leurs conceptions, par d√©finition, ne peuvent pas √™tre cr√©√©es par des amateurs".  Je ne veux pas entendre √ßa. <br><br>  Ne discutons tout simplement pas de ce sujet.  Divulgation compl√®te: je travaillais chez Google.  Ce fut le premier (mais malheureusement pas le dernier) endroit o√π j'ai jamais utilis√© Protobuffers.  Tous les probl√®mes dont je veux parler existent dans la base de code Google;  il ne s‚Äôagit pas seulement de ¬´mauvaise utilisation des protobuffers¬ª et autres. <br><a name="habracut"></a><br>  De loin, le plus gros probl√®me avec Protobuffers est le syst√®me de type horrible.  Les fans de Java devraient se sentir chez eux ici, mais malheureusement, personne ne pense que Java est un syst√®me de type bien con√ßu.  Les gars du camp de frappe dynamique se plaignent de restrictions inutiles, tandis que les repr√©sentants du camp de frappe statique, comme moi, se plaignent de restrictions inutiles et du manque de tout ce que vous attendez vraiment du syst√®me de frappe.  Perdre dans les deux cas. <br><br>  La sp√©cialisation et le d√©veloppement √©troits des amateurs vont de pair.  Une grande partie des sp√©cifications semblaient √™tre boulonn√©es au dernier moment - et c'√©tait √©videmment boulonn√© au dernier moment.  Certaines restrictions vous obligeront √† vous arr√™ter, √† vous gratter la t√™te et √† vous demander: ¬´Qu'est-ce qui se passe?¬ª  Mais ce ne sont que les sympt√¥mes d'un probl√®me plus profond: <br><br>  √âvidemment, les protobuffers sont cr√©√©s par des amateurs car ils offrent des solutions m√©diocres √† des probl√®mes bien connus et d√©j√† r√©solus. <br><br><h1>  Manque de composition </h1><br>  Les protobuffers offrent plusieurs fonctionnalit√©s qui ne fonctionnent pas les unes avec les autres.  Par exemple, regardez la liste des fonctions orthogonales, mais en m√™me temps limit√©es que j'ai trouv√©es dans la documentation. <br><br><ul><li> <code>oneof</code> champs ne peut pas √™tre <code>repeated</code> . </li><li>  Les champs <code>map&lt;k,v&gt;</code> ont une syntaxe sp√©ciale pour les cl√©s et les valeurs, mais elle n'est utilis√©e dans aucun autre type. </li><li>  Bien que les champs de <code>map</code> puissent √™tre param√©tr√©s, aucun type d√©fini par l'utilisateur n'est plus autoris√©.  Cela signifie que vous √™tes oblig√© de sp√©cifier manuellement vos propres sp√©cialisations dans les structures de donn√©es communes. </li><li>  <code>map</code> champs de la <code>map</code> ne peuvent pas √™tre <code>repeated</code> . </li><li>  <code>map</code> cl√©s de mappage <i>peuvent</i> √™tre des <code>string</code> , mais <i>pas des</i> <code>bytes</code> .  L'√©num√©ration est √©galement interdite, bien que ces derniers soient consid√©r√©s comme √©quivalents aux entiers dans toutes les autres parties de la sp√©cification Protobuffers. </li><li>  <code>map</code> valeurs de <code>map</code> ne peuvent pas √™tre une autre <code>map</code> . </li></ul><br>  Cette liste folle de restrictions est le r√©sultat d'un choix sans principes de conception et de fonctions de vissage au dernier moment.  Par exemple, l'un <code>oneof</code> champs ne peut pas √™tre <code>repeated</code> , car au lieu d'un type lat√©ral, le g√©n√©rateur de code produira des champs facultatifs mutuellement exclusifs.  Une telle transformation n'est valable que pour un champ singulier (et, comme nous le verrons plus loin, elle ne fonctionne m√™me pas pour lui). <br><br>  La restriction des champs de <code>map</code> , qui ne peut pas √™tre <code>repeated</code> , est approximativement du m√™me op√©ra, mais montre une restriction diff√©rente du syst√®me de type.  Dans les coulisses, la <code>map&lt;k,v&gt;</code> transforme en quelque chose de similaire √† <code>repeated Pair&lt;k,v&gt;</code> .  Et puisque <code>repeated</code> est le mot-cl√© magique de la langue, et non le type normal, il ne se combine pas avec lui-m√™me. <br><br>  Vos suppositions sur le probl√®me avec <code>enum</code> sont aussi vraies que les miennes. <br><br>  Ce qui est si frustrant dans tout cela, c'est une mauvaise compr√©hension du fonctionnement des syst√®mes de type modernes.  Cette compr√©hension <i>simplifierait consid√©rablement la</i> sp√©cification des Protobuffers et en m√™me temps <i>supprimerait toutes les restrictions arbitraires</i> . <br><br>  La solution est la suivante: <br><br><ul><li>  Faites tous les champs dans le message <code>required</code> .  Cela fait de chaque message <i>un</i> type de produit. </li><li>  Augmentez la valeur du champ <code>oneof</code> en types de donn√©es autonomes.  Ce sera un type de coproduit. </li><li>  Permettre le param√©trage de types de produits et coproduits d'autres types. </li></ul><br>  C'est tout!  Ces trois changements sont tout ce dont vous avez besoin pour d√©terminer les donn√©es possibles.  Avec ce syst√®me simple, vous pouvez refaire toutes les autres sp√©cifications de Protobuffers. <br><br>  Par exemple, vous pouvez refaire les champs <code>optional</code> : <br><br><pre> <code class="hljs pgsql">product Unit { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> fields } coproduct Optional&lt;t&gt; { t <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Unit unset = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  La cr√©ation de champs <code>repeated</code> est √©galement simple: <br><br><pre> <code class="hljs php">coproduct <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt; { Unit <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Pair&lt;t, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt;&gt; cons = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Bien s√ªr, la vraie logique de la s√©rialisation vous permet de faire quelque chose de plus intelligent que de pousser des listes li√©es sur le r√©seau - apr√®s tout, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©mentation et la s√©mantique n'ont pas √† correspondre</a> . <br><br><h1>  Choix douteux </h1><br>  Les tampons de style Java distinguent les types <i>scalaires</i> et les types de <i>messages</i> .  Les scalaires correspondent plus ou moins aux primitives de la machine - des choses comme <code>int32</code> , <code>bool</code> et <code>string</code> .  Les types de messages, en revanche, sont tout le reste.  Tous les types de biblioth√®ques et d'utilisateurs sont des messages. <br><br>  Bien s√ªr, les deux types de types ont une s√©mantique compl√®tement diff√©rente. <br><br>  Les champs avec des types scalaires sont toujours pr√©sents.  M√™me si vous ne les avez pas install√©s.  J'ai d√©j√† dit que (au moins dans proto3 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><sup>1</sup></a> <a name="1_1"></a>  ) tous les proto-tampons sont-ils initialis√©s √† z√©ro, m√™me s'ils n'ont absolument aucune donn√©e?  Les champs scalaires obtiennent de fausses valeurs: par exemple, <code>uint32</code> initialis√© √† <code>0</code> et la <code>string</code> initialis√©e √† <code>""</code> . <br><br>  Il n'est pas possible de distinguer un champ qui n'√©tait pas dans le proto-tampon d'un champ auquel une valeur par d√©faut est affect√©e.  Vraisemblablement, cette d√©cision a √©t√© prise pour l'optimisation afin de ne pas transmettre les valeurs par d√©faut scalaires.  Ce n'est qu'une hypoth√®se, car la documentation ne mentionne pas cette optimisation, donc votre hypoth√®se ne sera pas pire que la mienne. <br><br>  Lorsque nous discuterons des revendications de Protobuffers pour une solution id√©ale pour la compatibilit√© en amont et en aval des API, nous verrons que cette incapacit√© √† distinguer les valeurs non d√©finies des valeurs par d√©faut est un v√©ritable cauchemar.  Surtout si c'est vraiment une d√©cision consciente d'enregistrer un bit (d√©fini ou non) pour le champ. <br><br>  Comparez ce comportement avec les types de message.  Alors que les champs scalaires sont ¬´stupides¬ª, le comportement des champs de message est compl√®tement <i>fou</i> .  En interne, les champs de message sont l√† ou non, mais le comportement est fou.  Un petit pseudo-code pour leur accesseur vaut mille mots.  Imaginez cela en Java ou ailleurs: <br><br><pre> <code class="hljs pgsql">private Foo m_foo; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Foo foo { // <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an expression <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); } // <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an lvalue mutable <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) m_foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; } }</code> </pre> <br>  En th√©orie, si le champ <code>foo</code> n'est pas d√©fini, vous verrez une copie initialis√©e par d√©faut, que vous le demandiez ou non, mais vous ne pouvez pas changer le conteneur.  Mais si vous changez <code>foo</code> , il changera √©galement son parent!  Tout cela est juste pour √©viter d'utiliser le type <code>Maybe Foo</code> et son ¬´mal de t√™te¬ª associ√© pour comprendre ce que devrait signifier une valeur non d√©finie. <br><br>  Un tel comportement est particuli√®rement flagrant car il viole la loi!  Nous attendons le travail <code>msg.foo = msg.foo;</code>  ne fonctionnera pas.  Au lieu de cela, l'impl√©mentation modifie discr√®tement <code>msg</code> en une copie de <code>foo</code> avec une initialisation nulle si elle n'existait pas auparavant. <br><br>  Contrairement aux champs scalaires, vous pouvez au moins d√©terminer que le champ de message n'est pas d√©fini.  Les liaisons de langage pour les protobuffers offrent quelque chose comme la <code>bool has_foo()</code> g√©n√©r√©e.  S'il est pr√©sent, dans le cas d'une copie fr√©quente du champ de message d'un proto-tampon √† un autre, vous devez √©crire le code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src.has_foo(src)) { dst.set_foo(src.foo()); }</code> </pre> <br>  Veuillez noter que, au moins dans les langues avec typage statique, ce mod√®le <i>ne peut pas √™tre abstrait en</i> raison de la relation nominale entre les <code>has_foo()</code> <code>foo()</code> , <code>set_foo()</code> et <code>has_foo()</code> .  √âtant donn√© que toutes ces fonctions sont leurs propres <i>identifiants</i> , nous n'avons pas les moyens de les g√©n√©rer par programmation, √† l'exception de la macro du pr√©processeur: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COPY_IFF_SET(src, dst, field) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (src.has_##field(src)) { \ dst.set_##field(src.field()); \ }</span></span></code> </pre> <br>  (mais les macros de pr√©processeur sont interdites par le guide de style Google). <br><br>  Si, √† la place, tous les champs suppl√©mentaires √©taient impl√©ment√©s comme <code>Maybe</code> - <code>Maybe</code> , vous pourriez d√©finir en toute s√©curit√© les homologues de num√©rotation abstraits. <br><br>  Pour changer de sujet, parlons d'une autre d√©cision douteuse.  Bien que vous puissiez d√©finir l'un des champs dans les <code>oneof</code> , leur s√©mantique <i>ne correspond pas au</i> type de coproduit!  Les d√©butants se trompent les gars!  Au lieu de cela, vous obtenez un champ facultatif pour chaque cas et code magique dans les setters, qui annulera simplement tout autre champ s'il est d√©fini. <br><br>  √Ä premi√®re vue, il semble que cela devrait √™tre s√©mantiquement √©quivalent au type d'union correct.  Mais √† la place, nous obtenons une source d'erreur d√©go√ªtante et indescriptible!  Lorsque ce comportement est combin√© avec une impl√©mentation ill√©gale <code>msg.foo = msg.foo;</code>  , une telle affectation apparemment normale supprime silencieusement des quantit√©s arbitraires de donn√©es! <br><br>  En cons√©quence, cela signifie que l'un <code>oneof</code> champs <code>oneof</code> forme pas un <code>Prism</code> respectueux des lois et que les messages ne forment pas une <code>Lens</code> respectueuse des lois.  Alors bonne chance avec vos tentatives d'√©crire des manipulations de tampons non triviaux sans bugs.  <i>Il est litt√©ralement impossible d'√©crire un code polymorphe universel et sans erreur sur les tampons tampons</i> . <br><br>  Ce n'est pas tr√®s agr√©able √† entendre, surtout pour ceux d'entre nous qui aiment le polymorphisme param√©trique, ce qui <i>promet exactement le contraire</i> . <br><br><h1>  La compatibilit√© ascendante et future r√©side </h1><br>  L'une des ¬´caract√©ristiques tueuses¬ª souvent mentionn√©es des Protobuffers est leur ¬´capacit√© sans probl√®me √† √©crire des API compatibles en amont et en aval¬ª.  Cette d√©claration a √©t√© suspendue sous vos yeux pour obscurcir la v√©rit√©. <br><br>  Que les protobuffers sont <i>permissifs</i> .  Ils parviennent √† faire face aux messages du pass√© ou du futur, car ils ne font absolument aucune promesse sur l'apparence de vos donn√©es.  Tout est facultatif!  Mais si vous en avez besoin, Protobuffers se fera un plaisir de pr√©parer et de vous donner quelque chose avec une v√©rification de type, que cela ait du sens. <br><br>  Cela signifie que les Protobuffers effectuent le "voyage dans le temps" promis tout en <i>faisant tranquillement la mauvaise chose par d√©faut</i> .  Bien s√ªr, un programmeur prudent peut (et devrait) √©crire du code qui v√©rifie l'exactitude des protobuffers re√ßus.  Mais si vous effectuez des contr√¥les d'exactitude de protection sur chaque site, cela signifie peut-√™tre simplement que l'√©tape de d√©s√©rialisation √©tait trop permissive.  Tout ce que vous avez r√©ussi √† faire √©tait de d√©centraliser la logique de validation √† partir d'une fronti√®re bien d√©finie et de l'√©taler sur toute la base de code. <br><br>  L'un des arguments possibles est que les protobuffers enregistreront toutes les informations qu'ils ne comprennent pas dans le message.  En principe, cela signifie une transmission non destructive du message par un interm√©diaire qui ne comprend pas cette version du sch√©ma.  C'est une nette victoire, non? <br><br>  Bien s√ªr, sur le papier, c'est une fonctionnalit√© int√©ressante.  Mais je n'ai jamais vu d'application o√π cette propri√©t√© est vraiment stock√©e.  √Ä l'exception du logiciel de routage, aucun programme ne veut v√©rifier uniquement certains bits d'un message, puis le transmettre tel quel.  La grande majorit√© des programmes sur les protobuffers d√©codera le message, le transformera en un autre et l'enverra √† un autre endroit.  H√©las, ces conversions sont faites sur commande et encod√©es manuellement.  Et les conversions manuelles d'un tampon tampon √† un autre ne pr√©servent pas les champs inconnus, car elles sont litt√©ralement inutiles. <br><br>  Cette attitude omnipr√©sente envers les proto-tampons comme universellement compatibles se manifeste √©galement sous d'autres formes laides.  Les guides de style pour Protobuffers s'opposent activement √† DRY et sugg√®rent d'incorporer des d√©finitions dans le code chaque fois que possible.  Ils soutiennent que cela permettra l'utilisation de messages distincts √† l'avenir si les d√©finitions divergent.  J'insiste sur le fait qu'ils proposent d'abandonner la pratique de 60 ans d'une bonne programmation <i>au cas o√π</i> , tout √† coup, dans le futur, vous auriez besoin de changer quelque chose. <br><br>  La racine du probl√®me est que Google combine la signification des donn√©es avec leur repr√©sentation physique.  Lorsque vous √™tes √† l'√©chelle de Google, cela a du sens.  En fin de compte, ils ont un outil interne qui compare le salaire horaire du programmeur utilisant le r√©seau, le co√ªt de stockage de X octets et d'autres choses.  Contrairement √† la plupart des entreprises technologiques, le salaire des programmeurs est l'un des plus petits postes de d√©penses de Google.  Financi√®rement, il est logique pour eux de passer le temps des programmeurs pour √©conomiser quelques octets. <br><br>  En plus des cinq principales soci√©t√©s technologiques, personne d'autre ne fait partie des cinq ordres de grandeur de Google.  Votre startup <i>ne peut pas se permettre de</i> passer des heures d'ing√©nierie √† √©conomiser des octets.  Mais √©conomiser des octets et perdre du temps aux programmeurs dans le processus est exactement ce pour quoi les Protobuffers sont optimis√©s. <br><br>  Avouons-le.  Vous ne correspondez pas √† l'√©chelle de Google et vous ne vous adapterez jamais.  Cessez d'utiliser le culte du fret de la technologie simplement parce que "Google l'utilise" et parce que "ce sont les meilleures pratiques de l'industrie". <br><br><h1>  Protobuffers pollue les bases de code </h1><br>  S'il √©tait possible de limiter l'utilisation des Protobuffers au seul r√©seau, je ne parlerais pas aussi durement de cette technologie.  Malheureusement, bien qu'il existe en principe plusieurs solutions, aucune d'entre elles n'est suffisamment bonne pour √™tre r√©ellement utilis√©e dans de vrais logiciels. <br><br>  Les protobuffers correspondent aux donn√©es que vous souhaitez envoyer sur le canal de communication.  Ils sont souvent <i>coh√©rents</i> , mais pas <i>identiques</i> , avec les donn√©es r√©elles avec lesquelles l'application aimerait travailler.  Cela nous met dans une position inconfortable, vous devez choisir entre l'une des trois mauvaises options: <br><br><ol><li>  G√©rez un type distinct qui d√©crit les donn√©es dont vous avez r√©ellement besoin et assurez-vous que les deux types sont pris en charge simultan√©ment. </li><li>  Emballez les donn√©es compl√®tes dans un format pour la transmission et l'utilisation par l'application. </li><li>  R√©cup√©rez des donn√©es compl√®tes chaque fois que vous en avez besoin √† partir du format court pour la transmission. </li></ol><br>  L'option 1 est clairement la ¬´bonne¬ª solution, mais elle ne convient pas aux Protobuffers.  Le langage n'est pas assez puissant pour encoder des types qui peuvent faire un double travail dans deux formats.  Cela signifie que vous devez √©crire un type de donn√©es compl√®tement s√©par√©, le d√©velopper de mani√®re synchrone avec Protobuffers et <i>√©crire sp√©cifiquement le code de s√©rialisation pour eux</i> .  Mais comme la plupart des gens semblent utiliser Protobuffers pour ne pas √©crire de code de s√©rialisation, cette option n'est √©videmment jamais impl√©ment√©e. <br><br>  Au lieu de cela, le code utilisant des protobuffers permet de les distribuer √† travers la base de code.  C'est une r√©alit√©.  Mon projet principal chez Google √©tait un compilateur qui prenait un ¬´programme¬ª √©crit dans une variante de Protobuffers et produisait un ¬´programme¬ª √©quivalent sur une autre.  Les formats d'entr√©e et de sortie √©taient tr√®s diff√©rents, de sorte que leurs versions parall√®les correctes de C ++ n'ont jamais fonctionn√©.  En cons√©quence, mon code ne pouvait utiliser aucune des techniques d'√©criture de compilateur riche, car les donn√©es Protobuffers (et le code g√©n√©r√©) √©taient trop difficiles √† faire avec elles. <br><br>  En cons√©quence, au lieu de 50 lignes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sch√©mas</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©cursivit√©</a> , 10 000 lignes de r√©arrangement de tampon sp√©cial ont √©t√© utilis√©es.  Le code que je voulais √©crire √©tait litt√©ralement impossible avec les proto-tampons. <br><br>  Bien qu'il s'agisse d'un cas, il n'est pas unique.  En raison de la nature s√©v√®re de la g√©n√©ration de code, les manifestations des proto-tampons dans les langages ne seront jamais idiomatiques, et elles ne peuvent pas l'√™tre, √† moins que vous ne r√©√©criviez le g√©n√©rateur de code. <br><br>  Mais m√™me dans ce cas, vous avez toujours un probl√®me d'int√©gration d'un syst√®me de type merdique dans votre langue cible.  Comme la plupart des fonctions des Protobuffers sont mal pens√©es, ces propri√©t√©s douteuses s'infiltrent dans nos bases de code.  Cela signifie que nous sommes oblig√©s non seulement de mettre en ≈ìuvre, mais √©galement d'utiliser ces mauvaises id√©es dans tout projet qui esp√®re interagir avec Protobuffers. <br><br>  Sur une base solide, il est facile de r√©aliser des choses d√©nu√©es de sens, mais si vous allez dans une direction diff√©rente, au mieux vous rencontrerez des difficult√©s, et au pire, avec une v√©ritable horreur ancienne. <br><br>  En g√©n√©ral, abandonnez tout espoir √† quiconque impl√©mente des Protobuffers dans ses projets. <br><br><hr><br><a name="1"></a>  1. √Ä ce jour, il y a une discussion anim√©e sur Google √† propos de proto2 et si les champs doivent jamais √™tre marqu√©s comme <code>required</code> .  Les manifestes ¬´ <code>optional</code> est consid√©r√© comme nuisible¬ª <i>et</i> ¬´ <code>required</code> consid√©r√©s comme nuisibles¬ª sont distribu√©s en m√™me temps.  Bonne chance, comprenez-le.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">‚Üë</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427265/">https://habr.com/ru/post/fr427265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427253/index.html">typeof Tout et les malentendus de canard</a></li>
<li><a href="../fr427255/index.html">Cowon D2: Musical Long-Liver</a></li>
<li><a href="../fr427257/index.html">Cameron Craig: sept le√ßons tir√©es de 10 ans de gestion des relations publiques d'Apple</a></li>
<li><a href="../fr427259/index.html">Ce que le test de Turing v√©rifie vraiment</a></li>
<li><a href="../fr427263/index.html">Soyez un ninja de la s√©curit√©: enregistrement de webinaire et niveau bonus</a></li>
<li><a href="../fr427267/index.html">SNMP + Java - exp√©rience personnelle. √âcriture d'un analyseur de fichiers MIB</a></li>
<li><a href="../fr427269/index.html">Vid√©o Google OKR cinq ans plus tard - Un examen de l'exp√©rience de Google Ventures dans la mise en ≈ìuvre d'OKR (2012-2017)</a></li>
<li><a href="../fr427271/index.html">Histoire et exp√©rience de l'utilisation de la traduction automatique. Conf√©rence Yandex</a></li>
<li><a href="../fr427273/index.html">L'intelligence artificielle peut-elle laisser les bookmakers sans travail?</a></li>
<li><a href="../fr427275/index.html">Architecture de l'information Internet, partie 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>