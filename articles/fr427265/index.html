<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌷 🏫 🤰🏻 Les protobuffers ont tort 🗡️ 🤨 💇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendant la majeure partie de ma vie professionnelle, je suis opposé à l'utilisation de tampons de protocole. Ils sont clairement écrits par des amateu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les protobuffers ont tort</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427265/"> Pendant la majeure partie de ma vie professionnelle, je suis opposé à l'utilisation de tampons de protocole.  Ils sont clairement écrits par des amateurs, incroyablement hautement spécialisés, souffrent de nombreux pièges, sont difficiles à compiler et à résoudre un problème que personne d'autre que Google n'a réellement.  Si ces problèmes de proto-tampons restaient dans la quarantaine des abstractions de sérialisation, alors mes revendications s'arrêteraient là.  Mais malheureusement, la mauvaise conception des Protobuffers est si intrusive que ces problèmes peuvent s'infiltrer dans votre code. <br><br>  <b>Spécialisation étroite et développement par des amateurs</b> <br><br>  Arrête.  Fermez votre client de messagerie, où vous m'avez déjà écrit une lettre disant que "les meilleurs ingénieurs du monde travaillent chez Google", que "leurs conceptions, par définition, ne peuvent pas être créées par des amateurs".  Je ne veux pas entendre ça. <br><br>  Ne discutons tout simplement pas de ce sujet.  Divulgation complète: je travaillais chez Google.  Ce fut le premier (mais malheureusement pas le dernier) endroit où j'ai jamais utilisé Protobuffers.  Tous les problèmes dont je veux parler existent dans la base de code Google;  il ne s’agit pas seulement de «mauvaise utilisation des protobuffers» et autres. <br><a name="habracut"></a><br>  De loin, le plus gros problème avec Protobuffers est le système de type horrible.  Les fans de Java devraient se sentir chez eux ici, mais malheureusement, personne ne pense que Java est un système de type bien conçu.  Les gars du camp de frappe dynamique se plaignent de restrictions inutiles, tandis que les représentants du camp de frappe statique, comme moi, se plaignent de restrictions inutiles et du manque de tout ce que vous attendez vraiment du système de frappe.  Perdre dans les deux cas. <br><br>  La spécialisation et le développement étroits des amateurs vont de pair.  Une grande partie des spécifications semblaient être boulonnées au dernier moment - et c'était évidemment boulonné au dernier moment.  Certaines restrictions vous obligeront à vous arrêter, à vous gratter la tête et à vous demander: «Qu'est-ce qui se passe?»  Mais ce ne sont que les symptômes d'un problème plus profond: <br><br>  Évidemment, les protobuffers sont créés par des amateurs car ils offrent des solutions médiocres à des problèmes bien connus et déjà résolus. <br><br><h1>  Manque de composition </h1><br>  Les protobuffers offrent plusieurs fonctionnalités qui ne fonctionnent pas les unes avec les autres.  Par exemple, regardez la liste des fonctions orthogonales, mais en même temps limitées que j'ai trouvées dans la documentation. <br><br><ul><li> <code>oneof</code> champs ne peut pas être <code>repeated</code> . </li><li>  Les champs <code>map&lt;k,v&gt;</code> ont une syntaxe spéciale pour les clés et les valeurs, mais elle n'est utilisée dans aucun autre type. </li><li>  Bien que les champs de <code>map</code> puissent être paramétrés, aucun type défini par l'utilisateur n'est plus autorisé.  Cela signifie que vous êtes obligé de spécifier manuellement vos propres spécialisations dans les structures de données communes. </li><li>  <code>map</code> champs de la <code>map</code> ne peuvent pas être <code>repeated</code> . </li><li>  <code>map</code> clés de mappage <i>peuvent</i> être des <code>string</code> , mais <i>pas des</i> <code>bytes</code> .  L'énumération est également interdite, bien que ces derniers soient considérés comme équivalents aux entiers dans toutes les autres parties de la spécification Protobuffers. </li><li>  <code>map</code> valeurs de <code>map</code> ne peuvent pas être une autre <code>map</code> . </li></ul><br>  Cette liste folle de restrictions est le résultat d'un choix sans principes de conception et de fonctions de vissage au dernier moment.  Par exemple, l'un <code>oneof</code> champs ne peut pas être <code>repeated</code> , car au lieu d'un type latéral, le générateur de code produira des champs facultatifs mutuellement exclusifs.  Une telle transformation n'est valable que pour un champ singulier (et, comme nous le verrons plus loin, elle ne fonctionne même pas pour lui). <br><br>  La restriction des champs de <code>map</code> , qui ne peut pas être <code>repeated</code> , est approximativement du même opéra, mais montre une restriction différente du système de type.  Dans les coulisses, la <code>map&lt;k,v&gt;</code> transforme en quelque chose de similaire à <code>repeated Pair&lt;k,v&gt;</code> .  Et puisque <code>repeated</code> est le mot-clé magique de la langue, et non le type normal, il ne se combine pas avec lui-même. <br><br>  Vos suppositions sur le problème avec <code>enum</code> sont aussi vraies que les miennes. <br><br>  Ce qui est si frustrant dans tout cela, c'est une mauvaise compréhension du fonctionnement des systèmes de type modernes.  Cette compréhension <i>simplifierait considérablement la</i> spécification des Protobuffers et en même temps <i>supprimerait toutes les restrictions arbitraires</i> . <br><br>  La solution est la suivante: <br><br><ul><li>  Faites tous les champs dans le message <code>required</code> .  Cela fait de chaque message <i>un</i> type de produit. </li><li>  Augmentez la valeur du champ <code>oneof</code> en types de données autonomes.  Ce sera un type de coproduit. </li><li>  Permettre le paramétrage de types de produits et coproduits d'autres types. </li></ul><br>  C'est tout!  Ces trois changements sont tout ce dont vous avez besoin pour déterminer les données possibles.  Avec ce système simple, vous pouvez refaire toutes les autres spécifications de Protobuffers. <br><br>  Par exemple, vous pouvez refaire les champs <code>optional</code> : <br><br><pre> <code class="hljs pgsql">product Unit { // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> fields } coproduct Optional&lt;t&gt; { t <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Unit unset = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  La création de champs <code>repeated</code> est également simple: <br><br><pre> <code class="hljs php">coproduct <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt; { Unit <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Pair&lt;t, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;t&gt;&gt; cons = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Bien sûr, la vraie logique de la sérialisation vous permet de faire quelque chose de plus intelligent que de pousser des listes liées sur le réseau - après tout, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implémentation et la sémantique n'ont pas à correspondre</a> . <br><br><h1>  Choix douteux </h1><br>  Les tampons de style Java distinguent les types <i>scalaires</i> et les types de <i>messages</i> .  Les scalaires correspondent plus ou moins aux primitives de la machine - des choses comme <code>int32</code> , <code>bool</code> et <code>string</code> .  Les types de messages, en revanche, sont tout le reste.  Tous les types de bibliothèques et d'utilisateurs sont des messages. <br><br>  Bien sûr, les deux types de types ont une sémantique complètement différente. <br><br>  Les champs avec des types scalaires sont toujours présents.  Même si vous ne les avez pas installés.  J'ai déjà dit que (au moins dans proto3 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><sup>1</sup></a> <a name="1_1"></a>  ) tous les proto-tampons sont-ils initialisés à zéro, même s'ils n'ont absolument aucune donnée?  Les champs scalaires obtiennent de fausses valeurs: par exemple, <code>uint32</code> initialisé à <code>0</code> et la <code>string</code> initialisée à <code>""</code> . <br><br>  Il n'est pas possible de distinguer un champ qui n'était pas dans le proto-tampon d'un champ auquel une valeur par défaut est affectée.  Vraisemblablement, cette décision a été prise pour l'optimisation afin de ne pas transmettre les valeurs par défaut scalaires.  Ce n'est qu'une hypothèse, car la documentation ne mentionne pas cette optimisation, donc votre hypothèse ne sera pas pire que la mienne. <br><br>  Lorsque nous discuterons des revendications de Protobuffers pour une solution idéale pour la compatibilité en amont et en aval des API, nous verrons que cette incapacité à distinguer les valeurs non définies des valeurs par défaut est un véritable cauchemar.  Surtout si c'est vraiment une décision consciente d'enregistrer un bit (défini ou non) pour le champ. <br><br>  Comparez ce comportement avec les types de message.  Alors que les champs scalaires sont «stupides», le comportement des champs de message est complètement <i>fou</i> .  En interne, les champs de message sont là ou non, mais le comportement est fou.  Un petit pseudo-code pour leur accesseur vaut mille mots.  Imaginez cela en Java ou ailleurs: <br><br><pre> <code class="hljs pgsql">private Foo m_foo; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Foo foo { // <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an expression <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); } // <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> `foo` <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> an lvalue mutable <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_foo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) m_foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_foo; } }</code> </pre> <br>  En théorie, si le champ <code>foo</code> n'est pas défini, vous verrez une copie initialisée par défaut, que vous le demandiez ou non, mais vous ne pouvez pas changer le conteneur.  Mais si vous changez <code>foo</code> , il changera également son parent!  Tout cela est juste pour éviter d'utiliser le type <code>Maybe Foo</code> et son «mal de tête» associé pour comprendre ce que devrait signifier une valeur non définie. <br><br>  Un tel comportement est particulièrement flagrant car il viole la loi!  Nous attendons le travail <code>msg.foo = msg.foo;</code>  ne fonctionnera pas.  Au lieu de cela, l'implémentation modifie discrètement <code>msg</code> en une copie de <code>foo</code> avec une initialisation nulle si elle n'existait pas auparavant. <br><br>  Contrairement aux champs scalaires, vous pouvez au moins déterminer que le champ de message n'est pas défini.  Les liaisons de langage pour les protobuffers offrent quelque chose comme la <code>bool has_foo()</code> générée.  S'il est présent, dans le cas d'une copie fréquente du champ de message d'un proto-tampon à un autre, vous devez écrire le code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src.has_foo(src)) { dst.set_foo(src.foo()); }</code> </pre> <br>  Veuillez noter que, au moins dans les langues avec typage statique, ce modèle <i>ne peut pas être abstrait en</i> raison de la relation nominale entre les <code>has_foo()</code> <code>foo()</code> , <code>set_foo()</code> et <code>has_foo()</code> .  Étant donné que toutes ces fonctions sont leurs propres <i>identifiants</i> , nous n'avons pas les moyens de les générer par programmation, à l'exception de la macro du préprocesseur: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> COPY_IFF_SET(src, dst, field) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (src.has_##field(src)) { \ dst.set_##field(src.field()); \ }</span></span></code> </pre> <br>  (mais les macros de préprocesseur sont interdites par le guide de style Google). <br><br>  Si, à la place, tous les champs supplémentaires étaient implémentés comme <code>Maybe</code> - <code>Maybe</code> , vous pourriez définir en toute sécurité les homologues de numérotation abstraits. <br><br>  Pour changer de sujet, parlons d'une autre décision douteuse.  Bien que vous puissiez définir l'un des champs dans les <code>oneof</code> , leur sémantique <i>ne correspond pas au</i> type de coproduit!  Les débutants se trompent les gars!  Au lieu de cela, vous obtenez un champ facultatif pour chaque cas et code magique dans les setters, qui annulera simplement tout autre champ s'il est défini. <br><br>  À première vue, il semble que cela devrait être sémantiquement équivalent au type d'union correct.  Mais à la place, nous obtenons une source d'erreur dégoûtante et indescriptible!  Lorsque ce comportement est combiné avec une implémentation illégale <code>msg.foo = msg.foo;</code>  , une telle affectation apparemment normale supprime silencieusement des quantités arbitraires de données! <br><br>  En conséquence, cela signifie que l'un <code>oneof</code> champs <code>oneof</code> forme pas un <code>Prism</code> respectueux des lois et que les messages ne forment pas une <code>Lens</code> respectueuse des lois.  Alors bonne chance avec vos tentatives d'écrire des manipulations de tampons non triviaux sans bugs.  <i>Il est littéralement impossible d'écrire un code polymorphe universel et sans erreur sur les tampons tampons</i> . <br><br>  Ce n'est pas très agréable à entendre, surtout pour ceux d'entre nous qui aiment le polymorphisme paramétrique, ce qui <i>promet exactement le contraire</i> . <br><br><h1>  La compatibilité ascendante et future réside </h1><br>  L'une des «caractéristiques tueuses» souvent mentionnées des Protobuffers est leur «capacité sans problème à écrire des API compatibles en amont et en aval».  Cette déclaration a été suspendue sous vos yeux pour obscurcir la vérité. <br><br>  Que les protobuffers sont <i>permissifs</i> .  Ils parviennent à faire face aux messages du passé ou du futur, car ils ne font absolument aucune promesse sur l'apparence de vos données.  Tout est facultatif!  Mais si vous en avez besoin, Protobuffers se fera un plaisir de préparer et de vous donner quelque chose avec une vérification de type, que cela ait du sens. <br><br>  Cela signifie que les Protobuffers effectuent le "voyage dans le temps" promis tout en <i>faisant tranquillement la mauvaise chose par défaut</i> .  Bien sûr, un programmeur prudent peut (et devrait) écrire du code qui vérifie l'exactitude des protobuffers reçus.  Mais si vous effectuez des contrôles d'exactitude de protection sur chaque site, cela signifie peut-être simplement que l'étape de désérialisation était trop permissive.  Tout ce que vous avez réussi à faire était de décentraliser la logique de validation à partir d'une frontière bien définie et de l'étaler sur toute la base de code. <br><br>  L'un des arguments possibles est que les protobuffers enregistreront toutes les informations qu'ils ne comprennent pas dans le message.  En principe, cela signifie une transmission non destructive du message par un intermédiaire qui ne comprend pas cette version du schéma.  C'est une nette victoire, non? <br><br>  Bien sûr, sur le papier, c'est une fonctionnalité intéressante.  Mais je n'ai jamais vu d'application où cette propriété est vraiment stockée.  À l'exception du logiciel de routage, aucun programme ne veut vérifier uniquement certains bits d'un message, puis le transmettre tel quel.  La grande majorité des programmes sur les protobuffers décodera le message, le transformera en un autre et l'enverra à un autre endroit.  Hélas, ces conversions sont faites sur commande et encodées manuellement.  Et les conversions manuelles d'un tampon tampon à un autre ne préservent pas les champs inconnus, car elles sont littéralement inutiles. <br><br>  Cette attitude omniprésente envers les proto-tampons comme universellement compatibles se manifeste également sous d'autres formes laides.  Les guides de style pour Protobuffers s'opposent activement à DRY et suggèrent d'incorporer des définitions dans le code chaque fois que possible.  Ils soutiennent que cela permettra l'utilisation de messages distincts à l'avenir si les définitions divergent.  J'insiste sur le fait qu'ils proposent d'abandonner la pratique de 60 ans d'une bonne programmation <i>au cas où</i> , tout à coup, dans le futur, vous auriez besoin de changer quelque chose. <br><br>  La racine du problème est que Google combine la signification des données avec leur représentation physique.  Lorsque vous êtes à l'échelle de Google, cela a du sens.  En fin de compte, ils ont un outil interne qui compare le salaire horaire du programmeur utilisant le réseau, le coût de stockage de X octets et d'autres choses.  Contrairement à la plupart des entreprises technologiques, le salaire des programmeurs est l'un des plus petits postes de dépenses de Google.  Financièrement, il est logique pour eux de passer le temps des programmeurs pour économiser quelques octets. <br><br>  En plus des cinq principales sociétés technologiques, personne d'autre ne fait partie des cinq ordres de grandeur de Google.  Votre startup <i>ne peut pas se permettre de</i> passer des heures d'ingénierie à économiser des octets.  Mais économiser des octets et perdre du temps aux programmeurs dans le processus est exactement ce pour quoi les Protobuffers sont optimisés. <br><br>  Avouons-le.  Vous ne correspondez pas à l'échelle de Google et vous ne vous adapterez jamais.  Cessez d'utiliser le culte du fret de la technologie simplement parce que "Google l'utilise" et parce que "ce sont les meilleures pratiques de l'industrie". <br><br><h1>  Protobuffers pollue les bases de code </h1><br>  S'il était possible de limiter l'utilisation des Protobuffers au seul réseau, je ne parlerais pas aussi durement de cette technologie.  Malheureusement, bien qu'il existe en principe plusieurs solutions, aucune d'entre elles n'est suffisamment bonne pour être réellement utilisée dans de vrais logiciels. <br><br>  Les protobuffers correspondent aux données que vous souhaitez envoyer sur le canal de communication.  Ils sont souvent <i>cohérents</i> , mais pas <i>identiques</i> , avec les données réelles avec lesquelles l'application aimerait travailler.  Cela nous met dans une position inconfortable, vous devez choisir entre l'une des trois mauvaises options: <br><br><ol><li>  Gérez un type distinct qui décrit les données dont vous avez réellement besoin et assurez-vous que les deux types sont pris en charge simultanément. </li><li>  Emballez les données complètes dans un format pour la transmission et l'utilisation par l'application. </li><li>  Récupérez des données complètes chaque fois que vous en avez besoin à partir du format court pour la transmission. </li></ol><br>  L'option 1 est clairement la «bonne» solution, mais elle ne convient pas aux Protobuffers.  Le langage n'est pas assez puissant pour encoder des types qui peuvent faire un double travail dans deux formats.  Cela signifie que vous devez écrire un type de données complètement séparé, le développer de manière synchrone avec Protobuffers et <i>écrire spécifiquement le code de sérialisation pour eux</i> .  Mais comme la plupart des gens semblent utiliser Protobuffers pour ne pas écrire de code de sérialisation, cette option n'est évidemment jamais implémentée. <br><br>  Au lieu de cela, le code utilisant des protobuffers permet de les distribuer à travers la base de code.  C'est une réalité.  Mon projet principal chez Google était un compilateur qui prenait un «programme» écrit dans une variante de Protobuffers et produisait un «programme» équivalent sur une autre.  Les formats d'entrée et de sortie étaient très différents, de sorte que leurs versions parallèles correctes de C ++ n'ont jamais fonctionné.  En conséquence, mon code ne pouvait utiliser aucune des techniques d'écriture de compilateur riche, car les données Protobuffers (et le code généré) étaient trop difficiles à faire avec elles. <br><br>  En conséquence, au lieu de 50 lignes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schémas</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récursivité</a> , 10 000 lignes de réarrangement de tampon spécial ont été utilisées.  Le code que je voulais écrire était littéralement impossible avec les proto-tampons. <br><br>  Bien qu'il s'agisse d'un cas, il n'est pas unique.  En raison de la nature sévère de la génération de code, les manifestations des proto-tampons dans les langages ne seront jamais idiomatiques, et elles ne peuvent pas l'être, à moins que vous ne réécriviez le générateur de code. <br><br>  Mais même dans ce cas, vous avez toujours un problème d'intégration d'un système de type merdique dans votre langue cible.  Comme la plupart des fonctions des Protobuffers sont mal pensées, ces propriétés douteuses s'infiltrent dans nos bases de code.  Cela signifie que nous sommes obligés non seulement de mettre en œuvre, mais également d'utiliser ces mauvaises idées dans tout projet qui espère interagir avec Protobuffers. <br><br>  Sur une base solide, il est facile de réaliser des choses dénuées de sens, mais si vous allez dans une direction différente, au mieux vous rencontrerez des difficultés, et au pire, avec une véritable horreur ancienne. <br><br>  En général, abandonnez tout espoir à quiconque implémente des Protobuffers dans ses projets. <br><br><hr><br><a name="1"></a>  1. À ce jour, il y a une discussion animée sur Google à propos de proto2 et si les champs doivent jamais être marqués comme <code>required</code> .  Les manifestes « <code>optional</code> est considéré comme nuisible» <i>et</i> « <code>required</code> considérés comme nuisibles» sont distribués en même temps.  Bonne chance, comprenez-le.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">↑</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427265/">https://habr.com/ru/post/fr427265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427253/index.html">typeof Tout et les malentendus de canard</a></li>
<li><a href="../fr427255/index.html">Cowon D2: Musical Long-Liver</a></li>
<li><a href="../fr427257/index.html">Cameron Craig: sept leçons tirées de 10 ans de gestion des relations publiques d'Apple</a></li>
<li><a href="../fr427259/index.html">Ce que le test de Turing vérifie vraiment</a></li>
<li><a href="../fr427263/index.html">Soyez un ninja de la sécurité: enregistrement de webinaire et niveau bonus</a></li>
<li><a href="../fr427267/index.html">SNMP + Java - expérience personnelle. Écriture d'un analyseur de fichiers MIB</a></li>
<li><a href="../fr427269/index.html">Vidéo Google OKR cinq ans plus tard - Un examen de l'expérience de Google Ventures dans la mise en œuvre d'OKR (2012-2017)</a></li>
<li><a href="../fr427271/index.html">Histoire et expérience de l'utilisation de la traduction automatique. Conférence Yandex</a></li>
<li><a href="../fr427273/index.html">L'intelligence artificielle peut-elle laisser les bookmakers sans travail?</a></li>
<li><a href="../fr427275/index.html">Architecture de l'information Internet, partie 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>