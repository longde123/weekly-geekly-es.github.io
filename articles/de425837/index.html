<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèΩ ‚úñÔ∏è üë®üèΩ‚ÄçüöÄ Kopieren Sie Semantik und Ressourcenverwaltung in C ++ üïõ üè¨ üë•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ muss der Programmierer entscheiden, wie die verwendeten Ressourcen freigegeben werden. Es gibt keine automatischen Tools wie den Garbage Colle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kopieren Sie Semantik und Ressourcenverwaltung in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>In C ++ muss der Programmierer entscheiden, wie die verwendeten Ressourcen freigegeben werden. Es gibt keine automatischen Tools wie den Garbage Collector.</i>  <i>Der Artikel beschreibt m√∂gliche L√∂sungen f√ºr dieses Problem, untersucht m√∂gliche Probleme im Detail sowie eine Reihe verwandter Probleme.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Inhaltsverzeichnis </h1><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Grundlegende Strategien f√ºr den Besitz von Kopien</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kopierverbotsstrategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Exklusive Eigent√ºmerstrategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deep Copy-Strategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Miteigentumsstrategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Deep Copy-Strategie - Probleme und L√∂sungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufzeichnen kopieren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definieren einer Zustandsaustauschfunktion f√ºr eine Klasse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwischenkopien vom Compiler entfernen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung der Verschiebungssemantik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterkunft vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºgen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Optionen zur Implementierung einer Shared-Ownership-Strategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Exklusive Eigentumsstrategie und Bewegungssemantik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Kopierverbotsstrategie - Schnellstart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Der Lebenszyklus der Ressource und des Ressourcenbesitzerobjekts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ressourcenerfassung bei der Initialisierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Optionen f√ºr die Verwaltung des Ressourcenlebenszyklus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterter Ressourcenlebenszyklus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erfassung einzelner Ressourcen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erh√∂hte Indirektion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Miteigentum</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Zusammenfassung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anhang A. Rvalue Links</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anhang B. Semantik der Verschiebung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzliste</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  Einf√ºhrung </h1><br><p> Ressourcenverwaltung ist etwas, das ein C ++ - Programmierer st√§ndig tun muss.  Zu den Ressourcen geh√∂ren Speicherbl√∂cke, Betriebssystemkernobjekte, Multithread-Sperren, Netzwerkverbindungen, Datenbankverbindungen und nur alle im dynamischen Speicher erstellten Objekte.  Der Zugriff auf die Ressource erfolgt √ºber einen Deskriptor. Der Typ des Deskriptors ist normalerweise ein Zeiger oder einer seiner Aliase ( <code>HANDLE</code> usw.), manchmal der gesamte (UNIX-Dateideskriptoren).  Nachdem Sie die Ressource verwendet haben, m√ºssen Sie sie freigeben. Andernfalls gehen einer Anwendung, die keine Ressourcen freigibt (und m√∂glicherweise anderen Anwendungen), fr√ºher oder sp√§ter die Ressourcen aus.  Dieses Problem ist sehr akut. Wir k√∂nnen sagen, dass eine der Hauptfunktionen von .NET, Java und mehreren anderen Plattformen ein einheitliches Ressourcenverwaltungssystem ist, das auf der Speicherbereinigung basiert. </p><br><p>  Die objektorientierten Funktionen von C ++ f√ºhren nat√ºrlich zu der folgenden L√∂sung: Die Klasse, die die Ressource verwaltet, enth√§lt den Ressourcendeskriptor als Mitglied, initialisiert den Deskriptor, wenn die Ressource erfasst wird, und gibt die Ressource im Destruktor frei.  Aber nach einigem Nachdenken (oder Erleben) kommt das Verst√§ndnis, dass es nicht so einfach ist.  Das Hauptproblem ist die Semantik des Kopierens.  Wenn die Klasse, die die Ressource verwaltet, den vom Standard-Compiler generierten Kopierkonstruktor verwendet, erhalten wir nach dem Kopieren des Objekts zwei Kopien des Handles derselben Ressource.  Wenn ein Objekt eine Ressource freigibt, kann das zweite danach versuchen, die bereits freigegebene Ressource zu verwenden oder freizugeben. Dies ist in jedem Fall falsch und kann zu einem sogenannten undefinierten Verhalten f√ºhren, dh es kann alles passieren, z. B. eine abnormale Beendigung des Programms. </p><br><p>  Gl√ºcklicherweise kann ein Programmierer in C ++ den Kopiervorgang vollst√§ndig steuern, indem er selbst einen Kopierkonstruktor und einen Kopierzuweisungsoperator definiert, wodurch wir das oben genannte Problem l√∂sen k√∂nnen, und dies normalerweise auf mehrere Arten.  Die Implementierung des Kopierens sollte eng mit dem Mechanismus der Freigabe der Ressource verkn√ºpft sein, und wir werden dies gemeinsam als Strategie f√ºr den Besitz von Kopien bezeichnen.  Die sogenannte ‚ÄûRegel der gro√üen Drei‚Äú ist bekannt. Wenn ein Programmierer mindestens eine der drei Operationen definiert - Kopierkonstruktor, Kopierzuweisungsoperator oder Destruktor -, muss er alle drei Operationen definieren.  Copy-Ownership-Strategien legen lediglich fest, wie dies zu tun ist.  Es gibt vier grundlegende Strategien f√ºr den Besitz von Kopien. </p><br><a name="id-1"></a><br><h1>  1. Grundlegende Strategien f√ºr den Besitz von Kopien </h1><br><p>  Vor der Erfassung der Ressource oder nach ihrer Freigabe muss der Deskriptor einen speziellen Wert annehmen, der angibt, dass er nicht mit der Ressource verkn√ºpft ist.  Normalerweise ist dies Null, manchmal -1, umgewandelt in einen Deskriptortyp.  In jedem Fall wird ein solcher Deskriptor als Null bezeichnet.  Die Klasse, die die Ressource verwaltet, muss den Nulldeskriptor erkennen und darf in diesem Fall nicht versuchen, die Ressource zu verwenden oder freizugeben. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Kopierverbotsstrategie </h2><br><p>  Dies ist die einfachste Strategie.  In diesem Fall ist es einfach verboten, Klasseninstanzen zu kopieren und zuzuweisen.  Der Destruktor gibt die erfasste Ressource frei.  In C ++ ist es nicht schwierig, das Kopieren zu verhindern. Die Klasse muss den geschlossenen Kopierkonstruktor und den Kopierzuweisungsoperator deklarieren, aber nicht definieren. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Kopierversuche werden vom Compiler und Linker vereitelt. </p><br><p>  Der C ++ 11-Standard bietet f√ºr diesen Fall eine spezielle Syntax: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Diese Syntax ist visueller und gibt dem Compiler beim Versuch, zu kopieren, verst√§ndlichere Meldungen. </p><br><p>  In der vorherigen Version der Standardbibliothek (C ++ 98) verwendeten die Klassen von Eingabe- / Ausgabestreams ( <code>std::fstream</code> usw.) die <code>std::fstream</code> und unter Windows viele Klassen von MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> usw.).  In der C ++ 11-Standardbibliothek verwenden einige Klassen diese Strategie, um die Multithread-Synchronisation zu unterst√ºtzen. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Exklusive Eigent√ºmerstrategie </h2><br><p>  In diesem Fall wird beim Implementieren des Kopierens und Zuweisen der Ressourcendeskriptor vom Quellobjekt zum Zielobjekt verschoben, dh er verbleibt in einer einzelnen Kopie.  Nach dem Kopieren oder Zuweisen hat das Quellobjekt einen Nulldeskriptor und kann die Ressource nicht verwenden.  Der Destruktor gibt die erfasste Ressource frei.  F√ºr diese Strategie werden auch die Begriffe exklusives oder striktes Eigentum [Josuttis] verwendet, Andrei Alexandrescu verwendet den Begriff destruktives Kopieren.  In C ++ 11 geschieht dies wie folgt: Regelm√§√üiges Kopieren und Kopieren ist auf die oben beschriebene Weise verboten, und die Bewegungssemantik wird implementiert, dh der Verschiebungskonstruktor und der Verschiebungszuweisungsoperator werden definiert.  (Mehr zur Semantik der Bewegung sp√§ter.) </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Somit kann die Exklusivbesitzstrategie als Erweiterung der Kopierverbotsstrategie angesehen werden. </p><br><p>  In der C ++ 11-Standardbibliothek verwendet diese Strategie den Smart Pointer <code>std::unique_ptr&lt;&gt;</code> und einige andere Klassen, z. B. <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , sowie Klassen, die zuvor die <code>std::unique_lock&lt;&gt;</code> ( <code>std::unique_lock&lt;&gt;</code> verwendet haben <code>std::fstream</code> usw.).  Unter Windows verwendeten MFC-Klassen, die zuvor die <code>CFile</code> , auch die exklusive Eigentumsstrategie ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> usw.). </p><br><a name="id-1-3"></a><br><h2>  1.3.  Deep Copy-Strategie </h2><br><p>  In diesem Fall k√∂nnen Sie Klasseninstanzen kopieren und zuweisen.  Es ist erforderlich, den Kopierkonstruktor und den Kopierzuweisungsoperator zu definieren, damit das Zielobjekt die Ressource vom Quellobjekt in sich selbst kopiert.  Danach besitzt jedes Objekt seine Kopie der Ressource und kann die Ressource unabh√§ngig verwenden, √§ndern und freigeben.  Der Destruktor gibt die erfasste Ressource frei.  Manchmal wird f√ºr Objekte, die die Deep Copy-Strategie verwenden, der Begriff Wertobjekte verwendet. </p><br><p>  Diese Strategie gilt nicht f√ºr alle Ressourcen.  Es kann auf Ressourcen angewendet werden, die einem Speicherpuffer zugeordnet sind, z. B. Zeichenfolgen. Es ist jedoch nicht klar, wie es auf Objekte des Betriebssystemkerns wie Dateien, Mutexe usw. angewendet werden soll. </p><br><p>  Die Deep Copy-Strategie wird in allen Arten von Objektzeichenfolgen, <code>std::vector&lt;&gt;</code> und anderen Containern der Standardbibliothek verwendet. </p><br><a name="id-1-4"></a><br><h2>  1.4.  Miteigentumsstrategie </h2><br><p>  In diesem Fall k√∂nnen Sie Klasseninstanzen kopieren und zuweisen.  Sie m√ºssen den Kopierkonstruktor und den Kopierzuweisungsoperator definieren, in den der Ressourcendeskriptor (sowie andere Daten) kopiert wird, nicht jedoch die Ressource selbst.  Danach hat jedes Objekt eine eigene Kopie des Deskriptors, kann die Ressource verwenden, √§ndern, aber nicht freigeben, solange mindestens ein weiteres Objekt eine Kopie des Deskriptors besitzt.  Eine Ressource wird freigegeben, nachdem das letzte Objekt, das eine Kopie des Handles besitzt, den G√ºltigkeitsbereich verlassen hat.  Wie dies implementiert werden kann, wird unten beschrieben. </p><br><p>  Miteigentumsstrategien werden h√§ufig von intelligenten Zeigern verwendet, und es ist auch selbstverst√§ndlich, sie f√ºr unver√§nderliche Ressourcen zu verwenden.  Der Smart Pointer <code>std::shared_ptr&lt;&gt;</code> implementiert diese Strategie in der C ++ 11-Standardbibliothek. </p><br><a name="id-2"></a><br><h1>  2. Deep Copy-Strategie - Probleme und L√∂sungen </h1><br><p>  Betrachten Sie eine Vorlage f√ºr die Statusaustauschfunktion von Objekten vom Typ <code>T</code> in der C ++ 98-Standardbibliothek. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  Wenn Typ <code>T</code> eine Ressource besitzt und eine Deep-Copy-Strategie verwendet, haben wir drei Operationen, um eine neue Ressource zuzuweisen, drei Kopieroperationen und drei Operationen, um Ressourcen freizugeben.  W√§hrend dieser Vorgang in den meisten F√§llen ausgef√ºhrt werden kann, ohne neue Ressourcen zuzuweisen und √ºberhaupt zu kopieren, reicht es aus, wenn die Objekte interne Daten austauschen, einschlie√ülich eines Ressourcendeskriptors.  Es gibt viele √§hnliche Beispiele, wenn Sie tempor√§re Kopien einer Ressource erstellen und diese sofort freigeben m√ºssen.  Eine solche ineffektive Implementierung des t√§glichen Betriebs stimulierte die Suche nach L√∂sungen f√ºr ihre Optimierung.  Betrachten wir die Hauptoptionen. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Aufzeichnen kopieren </h2><br><p>  Copy on Write (COW), auch als verz√∂gerte Kopie bezeichnet, kann als Versuch angesehen werden, eine Deep-Copy-Strategie und eine Shared-Ownership-Strategie zu kombinieren.  Beim Kopieren eines Objekts wird zun√§chst der Ressourcendeskriptor ohne die Ressource selbst kopiert, und f√ºr Eigent√ºmer wird die Ressource freigegeben und schreibgesch√ºtzt. Sobald jedoch ein Eigent√ºmer die freigegebene Ressource √§ndern muss, wird die Ressource kopiert, und dieser Eigent√ºmer arbeitet mit seiner eine Kopie.  Die Implementierung von COW l√∂st das Problem des staatlichen Austauschs: Eine zus√§tzliche Zuweisung von Ressourcen und ein Kopieren erfolgt nicht.  Die Verwendung von COW ist bei der Implementierung von Zeichenfolgen sehr beliebt, z. B. <code>CString</code> (MFC, ATL).  Eine Diskussion m√∂glicher Wege zur Implementierung von COW und neu auftretenden Problemen findet sich in [Meyers1], [Sutter].  [Guntheroth] schlug eine COW-Implementierung mit <code>std::shared_ptr&lt;&gt;</code> .  Bei der Implementierung von COW in einer Multithread-Umgebung treten Probleme auf. Daher ist es verboten, COW f√ºr Zeichenfolgen in der Standard-C ++ 11-Bibliothek zu verwenden (siehe [Josuttis], [Guntheroth]). </p><br><p>  Die Entwicklung der COW-Idee f√ºhrt zu folgendem Ressourcenverwaltungsschema: Die Ressource ist unver√§nderlich und wird von Objekten mithilfe der gemeinsamen Eigent√ºmerstrategie verwaltet. Falls erforderlich, um die Ressource zu √§ndern, wird eine neue, entsprechend ge√§nderte Ressource erstellt und ein neues Eigent√ºmerobjekt zur√ºckgegeben.  Dieses Schema wird f√ºr Zeichenfolgen und andere unver√§nderliche Objekte auf den .NET- und Java-Plattformen verwendet.  In der funktionalen Programmierung wird es f√ºr komplexere Datenstrukturen verwendet. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Definieren einer Zustandsaustauschfunktion f√ºr eine Klasse </h2><br><p>  Es wurde oben gezeigt, wie ineffizient die Zustandsaustauschfunktion sein kann, die auf einfache Weise durch Kopieren und Zuweisen implementiert wird.  Und es wird ziemlich h√§ufig verwendet, zum Beispiel wird es von vielen Algorithmen der Standardbibliothek verwendet.  Damit die Algorithmen nicht ein anderes <code>std::swap()</code> , sondern eine andere speziell f√ºr die Klasse definierte Funktion, m√ºssen zwei Schritte ausgef√ºhrt werden. </p><br><p>  1. Definieren Sie in der Klasse eine Mitgliedsfunktion <code>Swap()</code> (der Name ist nicht wichtig), die den Austausch von Zust√§nden implementiert. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Sie m√ºssen sicherstellen, dass diese Funktion keine Ausnahmen <code>noexcept</code> . In C ++ 11 m√ºssen solche Funktionen als <code>noexcept</code> deklariert werden. </p><br><p>  2. Definieren Sie im selben Namespace wie Klasse <code>X</code> (normalerweise in derselben Header-Datei) die freie Funktion (nicht Mitglied) <code>swap()</code> wie folgt (Name und Signatur sind grundlegend): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  Danach wird es von den Algorithmen der Standardbibliothek verwendet, nicht von <code>std::swap()</code> .  Dies bietet einen Mechanismus, der als argumentabh√§ngige Suche (ADL) bezeichnet wird.  Weitere Informationen zu ADL finden Sie unter [Dewhurst1]. </p><br><p>  In der C ++ - Standardbibliothek implementieren alle Container, Smart Pointer sowie andere Klassen die Statusaustauschfunktion wie oben beschrieben. </p><br><p>  Die <code>Swap()</code> -Mitgliedsfunktion ist normalerweise einfach zu definieren: Es ist erforderlich, nacheinander eine Statusaustauschoperation auf die Datenbanken und Mitglieder anzuwenden, sofern sie dies unterst√ºtzen, und ansonsten auf <code>std::swap()</code> . </p><br><p>  Die obige Beschreibung ist etwas vereinfacht, eine detailliertere findet sich in [Meyers2].  Eine Diskussion von Fragen im Zusammenhang mit der staatlichen Austauschfunktion findet sich auch in [Sutter / Alexandrescu]. </p><br><p>  Die Zustandsaustauschfunktion kann einer der Grundoperationen der Klasse zugeordnet werden.  Mit dieser Funktion k√∂nnen Sie andere Vorg√§nge ordnungsgem√§√ü definieren.  Beispielsweise wird der Kopierzuweisungsoperator durch copy und <code>Swap()</code> wie folgt definiert: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Diese Vorlage wird als Kopier- und Austauschsprache oder Herb Sutter-Sprache bezeichnet. Weitere Informationen finden Sie unter [Sutter], [Sutter / Alexandrescu], [Meyers2].  Seine Modifikation kann angewendet werden, um die Semantik der Verschiebung zu implementieren, siehe Abschnitte 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Zwischenkopien vom Compiler entfernen </h2><br><p>  Betrachten Sie die Klasse </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Und funktionieren </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  Mit einem einfachen Ansatz wird die R√ºckkehr von der <code>Foo()</code> Funktion durch Kopieren der Instanz von <code>X</code>  Compiler k√∂nnen den Kopiervorgang jedoch aus dem Code entfernen, das Objekt wird direkt am Aufrufpunkt erstellt.  Dies wird als R√ºckgabewertoptimierung (RVO) bezeichnet.  RVO wird seit einiger Zeit von Compiler-Entwicklern verwendet und ist derzeit im C ++ 11-Standard festgelegt.  Obwohl die Entscheidung √ºber RVO vom Compiler getroffen wird, kann der Programmierer Code basierend auf seiner Verwendung schreiben.  Zu diesem Zweck ist es w√ºnschenswert, dass die Funktion einen R√ºckgabepunkt hat und der Typ des zur√ºckgegebenen Ausdrucks mit dem Typ des R√ºckgabewerts der Funktion √ºbereinstimmt.  In einigen F√§llen ist es ratsam, einen speziellen geschlossenen Konstruktor zu definieren, der als ‚ÄûRechenkonstruktor‚Äú bezeichnet wird. Weitere Einzelheiten finden Sie unter [Dewhurst2].  RVO wird auch in [Meyers3] und [Guntheroth] diskutiert. </p><br><p>  Compiler k√∂nnen in anderen Situationen Zwischenkopien l√∂schen. </p><br><a name="id-2-4"></a><br><h2>  2.4.  Implementierung der Verschiebungssemantik </h2><br><p>  Die Implementierung der Verschiebungssemantik besteht darin, einen Verschiebungskonstruktor zu definieren, der einen Parameter vom Typ rWertreferenz auf die Quelle und einen Verschiebungszuweisungsoperator mit demselben Parameter enth√§lt. </p><br><p>  In der C ++ 11-Standardbibliothek ist die Funktionsvorlage f√ºr den Statusaustausch wie folgt definiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  In √úbereinstimmung mit den Regeln zum Aufl√∂sen von √úberladungen von Funktionen mit Parametern vom Typ rWertreferenz (siehe Anhang A) werden diese verwendet, wenn der Typ <code>T</code> einen sich bewegenden Konstruktor und einen sich bewegenden Zuweisungsoperator hat, und es werden keine tempor√§ren Ressourcen zugewiesen und kopiert.  Andernfalls werden der Kopierkonstruktor und der Kopierzuweisungsoperator verwendet. </p><br><p>  Durch die Verwendung der Semantik der Verlagerung wird vermieden, dass tempor√§re Kopien in einem viel breiteren Kontext als der oben beschriebenen Zustandsaustauschfunktion erstellt werden.  Die Bewegungssemantik gilt f√ºr jeden r-Wert, dh einen tempor√§ren, unbenannten Wert, sowie f√ºr den R√ºckgabewert einer Funktion, wenn sie lokal erstellt wurde (einschlie√ülich l-Wert) und RVO nicht angewendet wurde.  In all diesen F√§llen ist garantiert, dass das Quellobjekt nach dem Verschieben in keiner Weise verwendet werden kann.  Die Verschiebungssemantik gilt auch f√ºr den Wert lvalue, auf den die Transformation <code>std::move()</code> angewendet wird.  In diesem Fall ist der Programmierer jedoch daf√ºr verantwortlich, wie die Quellobjekte nach dem Verschieben verwendet werden (Beispiel <code>std::swap()</code> ). </p><br><p>  Die Standard-C ++ 11-Bibliothek wurde unter Ber√ºcksichtigung der Bewegungssemantik neu gestaltet.  Viele Klassen haben einen Verschiebungskonstruktor und einen Verschiebungszuweisungsoperator sowie andere Elementfunktionen mit Parametern vom Typ rWertreferenz hinzugef√ºgt.  Zum Beispiel hat <code>std::vector&lt;T&gt;</code> eine √ºberladene Version von <code>void push_back(T&amp;&amp; src)</code> .  All dies erm√∂glicht es in vielen F√§llen, das Erstellen tempor√§rer Kopien zu vermeiden. </p><br><p>  Durch die Implementierung der Verschiebungssemantik werden die Definitionen der Statusaustauschfunktion f√ºr eine Klasse nicht aufgehoben.  Eine speziell definierte Zustandsaustauschfunktion kann effizienter sein als die Standardfunktion <code>std::swap()</code> .  Dar√ºber hinaus lassen sich der Verschiebungskonstruktor und der Verschiebungszuweisungsoperator sehr einfach unter Verwendung der Elementfunktion des Zustandsaustauschs wie folgt definieren (Variation der Kopier- und Austauschsprache): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  Der Verschiebungskonstruktor und der Verschiebungszuweisungsoperator sind diejenigen <code>noexcept</code> f√ºr die es √§u√üerst w√ºnschenswert ist, sicherzustellen, dass sie keine Ausnahmen <code>noexcept</code> und dementsprechend als <code>noexcept</code> deklariert werden.  Auf diese Weise k√∂nnen Sie einige Operationen der Standardbibliothekscontainer optimieren, ohne die strikte Garantie f√ºr die Sicherheit von Ausnahmen zu verletzen. Weitere Informationen finden Sie unter [Meyers3] und [Guntheroth].  Die vorgeschlagene Vorlage bietet eine solche Garantie, sofern der Standardkonstruktor und die Mitgliedsfunktion des Staatenaustauschs keine Ausnahmen ausl√∂sen. </p><br><p>  Der C ++ 11-Standard sieht vor, dass der Compiler automatisch einen Verschiebungskonstruktor und einen Verschiebungszuweisungsoperator generiert. Dazu m√ºssen sie mit dem Konstrukt <code>"=default"</code> deklariert werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Operationen werden implementiert, indem die Verschiebungsoperation nacheinander auf die Basen und Mitglieder der Klasse angewendet wird, sofern sie die Verschiebung unterst√ºtzen, und Operationen ansonsten kopiert werden.  Es ist klar, dass diese Option bei weitem nicht immer akzeptabel ist.  Rohe Deskriptoren werden nicht verschoben, k√∂nnen jedoch normalerweise nicht kopiert werden.  Unter bestimmten Bedingungen kann der Compiler unabh√§ngig voneinander einen √§hnlichen Verschiebungskonstruktor und Verschiebungszuweisungsoperator generieren. Es ist jedoch besser, diese Gelegenheit nicht zu nutzen. Diese Bedingungen sind ziemlich verwirrend und k√∂nnen sich leicht √§ndern, wenn die Klasse verfeinert wird.  Siehe [Meyers3] f√ºr Details. </p><br><p>  Im Allgemeinen ist die Implementierung und Verwendung der Semantik der Verschiebung eine ziemlich "subtile Sache".  Der Compiler kann das Kopieren dort anwenden, wo der Programmierer eine Verschiebung erwartet.  Hier sind einige Regeln, um die Wahrscheinlichkeit einer solchen Situation zu beseitigen oder zumindest zu verringern. </p><br><ol><li>  Verwenden Sie nach M√∂glichkeit das Kopierverbot. </li><li>  Deklarieren Sie den Verschiebungskonstruktor und den Verschiebungszuweisungsoperator als <code>noexcept</code> . </li><li>  Implementieren Sie die Bewegungssemantik f√ºr Basisklassen und Mitglieder. </li><li>  Wenden Sie die Transformation <code>std::move()</code> auf die Parameter von Funktionen vom Typ rvalue reference an. </li></ol><br><p>  Regel 2 wurde oben diskutiert.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5.  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      ‚Äî   (variadic templates),         .  ,      C++11 ‚Äî     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6.  Zusammenfassung </h2><br><p>     ,    ,     .               -  .                   .   ‚Äî     :    ,    .     ,       ,     ,  .      :     ,     ,  ¬´¬ª   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    ‚Äî   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    ‚Äî   .     6. </p><br><p>   ,     -  -,  ¬´  ¬ª,   -     .         -    . ,   ,     ,     ,    -       .      ¬´¬ª. </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2>  6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          ¬´   ¬ª (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      ¬´¬ª RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2>  6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     ¬´  ¬ª,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  ¬´¬ª RAII,   ‚Äî          .      ,     ,    . 3.       .    ¬´¬ª,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        ‚Äî    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Anwendungen </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- ‚Äî      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         ‚Äî    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Referenzliste </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: .  aus dem Englischen  - M.: LLC ‚ÄúI.D. ¬ª, 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: .  aus dem Englischen ‚Äî .:  ¬´-¬ª, 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  aus dem Englischen  - M.: LLC ‚ÄúI.D. ¬ª, 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  aus dem Englischen ‚Äî .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  aus dem Englischen ‚Äî .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  aus dem Englischen ‚Äî .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  aus dem Englischen ‚Äî .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  aus dem Englischen  - M.: LLC ‚ÄúI.D. ¬ª, 2016. </p><br><p> [Sutter] <br> , .     C++.: .  aus dem Englischen ‚Äî :  ¬´.. ¬ª, 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  aus dem Englischen  - M.: LLC ‚ÄúI.D. ¬ª, 2015. </p><br><p> [Schildt] <br> , .    C++.: .  aus dem Englischen ‚Äî .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  aus dem Englischen ‚Äî .:  ¬´ ¬´¬ª, 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425837/">https://habr.com/ru/post/de425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425827/index.html">Google+ Lektion: Projekte m√ºssen sicherstellen, dass die Grenzen zwischen den Interessen der Nutzer im wirklichen Leben online respektiert werden</a></li>
<li><a href="../de425829/index.html">Wie wir mit Roskomnadzor gek√§mpft haben und was daraus wurde</a></li>
<li><a href="../de425831/index.html">RKN Alert - Roskomnadzor-Datenbank in Ihrem Browser</a></li>
<li><a href="../de425833/index.html">Ein Tool, mit dem Sie die besten Ideen f√ºr Ihr Produkt ausw√§hlen k√∂nnen.</a></li>
<li><a href="../de425835/index.html">"Breaking Bugs" in Sberbank: So beheben Sie die Fehlerrate von sieben Tagen pro Tag</a></li>
<li><a href="../de425839/index.html">Atlassian Conference Review</a></li>
<li><a href="../de425843/index.html">Python f√ºr das Kind: Auswahl eines Tutorials</a></li>
<li><a href="../de425845/index.html">Apps bei Google Play automatisch sperren</a></li>
<li><a href="../de425847/index.html">Ein Beispiel f√ºr die Verwendung von Microsoft Flow oder So geben Sie Ihrer Frau Blumen</a></li>
<li><a href="../de425849/index.html">Amazon gab auf und erh√∂hte die Geh√§lter der Mitarbeiter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>