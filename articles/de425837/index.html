<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏽 ✖️ 👨🏽‍🚀 Kopieren Sie Semantik und Ressourcenverwaltung in C ++ 🕛 🏬 👥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ muss der Programmierer entscheiden, wie die verwendeten Ressourcen freigegeben werden. Es gibt keine automatischen Tools wie den Garbage Colle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kopieren Sie Semantik und Ressourcenverwaltung in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>In C ++ muss der Programmierer entscheiden, wie die verwendeten Ressourcen freigegeben werden. Es gibt keine automatischen Tools wie den Garbage Collector.</i>  <i>Der Artikel beschreibt mögliche Lösungen für dieses Problem, untersucht mögliche Probleme im Detail sowie eine Reihe verwandter Probleme.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Inhaltsverzeichnis </h1><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Grundlegende Strategien für den Besitz von Kopien</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kopierverbotsstrategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Exklusive Eigentümerstrategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deep Copy-Strategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Miteigentumsstrategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Deep Copy-Strategie - Probleme und Lösungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufzeichnen kopieren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definieren einer Zustandsaustauschfunktion für eine Klasse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwischenkopien vom Compiler entfernen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung der Verschiebungssemantik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterkunft vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einfügen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Optionen zur Implementierung einer Shared-Ownership-Strategie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Exklusive Eigentumsstrategie und Bewegungssemantik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Kopierverbotsstrategie - Schnellstart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Der Lebenszyklus der Ressource und des Ressourcenbesitzerobjekts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ressourcenerfassung bei der Initialisierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Optionen für die Verwaltung des Ressourcenlebenszyklus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterter Ressourcenlebenszyklus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erfassung einzelner Ressourcen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erhöhte Indirektion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Miteigentum</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Zusammenfassung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anhang A. Rvalue Links</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anhang B. Semantik der Verschiebung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzliste</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  Einführung </h1><br><p> Ressourcenverwaltung ist etwas, das ein C ++ - Programmierer ständig tun muss.  Zu den Ressourcen gehören Speicherblöcke, Betriebssystemkernobjekte, Multithread-Sperren, Netzwerkverbindungen, Datenbankverbindungen und nur alle im dynamischen Speicher erstellten Objekte.  Der Zugriff auf die Ressource erfolgt über einen Deskriptor. Der Typ des Deskriptors ist normalerweise ein Zeiger oder einer seiner Aliase ( <code>HANDLE</code> usw.), manchmal der gesamte (UNIX-Dateideskriptoren).  Nachdem Sie die Ressource verwendet haben, müssen Sie sie freigeben. Andernfalls gehen einer Anwendung, die keine Ressourcen freigibt (und möglicherweise anderen Anwendungen), früher oder später die Ressourcen aus.  Dieses Problem ist sehr akut. Wir können sagen, dass eine der Hauptfunktionen von .NET, Java und mehreren anderen Plattformen ein einheitliches Ressourcenverwaltungssystem ist, das auf der Speicherbereinigung basiert. </p><br><p>  Die objektorientierten Funktionen von C ++ führen natürlich zu der folgenden Lösung: Die Klasse, die die Ressource verwaltet, enthält den Ressourcendeskriptor als Mitglied, initialisiert den Deskriptor, wenn die Ressource erfasst wird, und gibt die Ressource im Destruktor frei.  Aber nach einigem Nachdenken (oder Erleben) kommt das Verständnis, dass es nicht so einfach ist.  Das Hauptproblem ist die Semantik des Kopierens.  Wenn die Klasse, die die Ressource verwaltet, den vom Standard-Compiler generierten Kopierkonstruktor verwendet, erhalten wir nach dem Kopieren des Objekts zwei Kopien des Handles derselben Ressource.  Wenn ein Objekt eine Ressource freigibt, kann das zweite danach versuchen, die bereits freigegebene Ressource zu verwenden oder freizugeben. Dies ist in jedem Fall falsch und kann zu einem sogenannten undefinierten Verhalten führen, dh es kann alles passieren, z. B. eine abnormale Beendigung des Programms. </p><br><p>  Glücklicherweise kann ein Programmierer in C ++ den Kopiervorgang vollständig steuern, indem er selbst einen Kopierkonstruktor und einen Kopierzuweisungsoperator definiert, wodurch wir das oben genannte Problem lösen können, und dies normalerweise auf mehrere Arten.  Die Implementierung des Kopierens sollte eng mit dem Mechanismus der Freigabe der Ressource verknüpft sein, und wir werden dies gemeinsam als Strategie für den Besitz von Kopien bezeichnen.  Die sogenannte „Regel der großen Drei“ ist bekannt. Wenn ein Programmierer mindestens eine der drei Operationen definiert - Kopierkonstruktor, Kopierzuweisungsoperator oder Destruktor -, muss er alle drei Operationen definieren.  Copy-Ownership-Strategien legen lediglich fest, wie dies zu tun ist.  Es gibt vier grundlegende Strategien für den Besitz von Kopien. </p><br><a name="id-1"></a><br><h1>  1. Grundlegende Strategien für den Besitz von Kopien </h1><br><p>  Vor der Erfassung der Ressource oder nach ihrer Freigabe muss der Deskriptor einen speziellen Wert annehmen, der angibt, dass er nicht mit der Ressource verknüpft ist.  Normalerweise ist dies Null, manchmal -1, umgewandelt in einen Deskriptortyp.  In jedem Fall wird ein solcher Deskriptor als Null bezeichnet.  Die Klasse, die die Ressource verwaltet, muss den Nulldeskriptor erkennen und darf in diesem Fall nicht versuchen, die Ressource zu verwenden oder freizugeben. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Kopierverbotsstrategie </h2><br><p>  Dies ist die einfachste Strategie.  In diesem Fall ist es einfach verboten, Klasseninstanzen zu kopieren und zuzuweisen.  Der Destruktor gibt die erfasste Ressource frei.  In C ++ ist es nicht schwierig, das Kopieren zu verhindern. Die Klasse muss den geschlossenen Kopierkonstruktor und den Kopierzuweisungsoperator deklarieren, aber nicht definieren. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Kopierversuche werden vom Compiler und Linker vereitelt. </p><br><p>  Der C ++ 11-Standard bietet für diesen Fall eine spezielle Syntax: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Diese Syntax ist visueller und gibt dem Compiler beim Versuch, zu kopieren, verständlichere Meldungen. </p><br><p>  In der vorherigen Version der Standardbibliothek (C ++ 98) verwendeten die Klassen von Eingabe- / Ausgabestreams ( <code>std::fstream</code> usw.) die <code>std::fstream</code> und unter Windows viele Klassen von MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> usw.).  In der C ++ 11-Standardbibliothek verwenden einige Klassen diese Strategie, um die Multithread-Synchronisation zu unterstützen. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Exklusive Eigentümerstrategie </h2><br><p>  In diesem Fall wird beim Implementieren des Kopierens und Zuweisen der Ressourcendeskriptor vom Quellobjekt zum Zielobjekt verschoben, dh er verbleibt in einer einzelnen Kopie.  Nach dem Kopieren oder Zuweisen hat das Quellobjekt einen Nulldeskriptor und kann die Ressource nicht verwenden.  Der Destruktor gibt die erfasste Ressource frei.  Für diese Strategie werden auch die Begriffe exklusives oder striktes Eigentum [Josuttis] verwendet, Andrei Alexandrescu verwendet den Begriff destruktives Kopieren.  In C ++ 11 geschieht dies wie folgt: Regelmäßiges Kopieren und Kopieren ist auf die oben beschriebene Weise verboten, und die Bewegungssemantik wird implementiert, dh der Verschiebungskonstruktor und der Verschiebungszuweisungsoperator werden definiert.  (Mehr zur Semantik der Bewegung später.) </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Somit kann die Exklusivbesitzstrategie als Erweiterung der Kopierverbotsstrategie angesehen werden. </p><br><p>  In der C ++ 11-Standardbibliothek verwendet diese Strategie den Smart Pointer <code>std::unique_ptr&lt;&gt;</code> und einige andere Klassen, z. B. <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , sowie Klassen, die zuvor die <code>std::unique_lock&lt;&gt;</code> ( <code>std::unique_lock&lt;&gt;</code> verwendet haben <code>std::fstream</code> usw.).  Unter Windows verwendeten MFC-Klassen, die zuvor die <code>CFile</code> , auch die exklusive Eigentumsstrategie ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> usw.). </p><br><a name="id-1-3"></a><br><h2>  1.3.  Deep Copy-Strategie </h2><br><p>  In diesem Fall können Sie Klasseninstanzen kopieren und zuweisen.  Es ist erforderlich, den Kopierkonstruktor und den Kopierzuweisungsoperator zu definieren, damit das Zielobjekt die Ressource vom Quellobjekt in sich selbst kopiert.  Danach besitzt jedes Objekt seine Kopie der Ressource und kann die Ressource unabhängig verwenden, ändern und freigeben.  Der Destruktor gibt die erfasste Ressource frei.  Manchmal wird für Objekte, die die Deep Copy-Strategie verwenden, der Begriff Wertobjekte verwendet. </p><br><p>  Diese Strategie gilt nicht für alle Ressourcen.  Es kann auf Ressourcen angewendet werden, die einem Speicherpuffer zugeordnet sind, z. B. Zeichenfolgen. Es ist jedoch nicht klar, wie es auf Objekte des Betriebssystemkerns wie Dateien, Mutexe usw. angewendet werden soll. </p><br><p>  Die Deep Copy-Strategie wird in allen Arten von Objektzeichenfolgen, <code>std::vector&lt;&gt;</code> und anderen Containern der Standardbibliothek verwendet. </p><br><a name="id-1-4"></a><br><h2>  1.4.  Miteigentumsstrategie </h2><br><p>  In diesem Fall können Sie Klasseninstanzen kopieren und zuweisen.  Sie müssen den Kopierkonstruktor und den Kopierzuweisungsoperator definieren, in den der Ressourcendeskriptor (sowie andere Daten) kopiert wird, nicht jedoch die Ressource selbst.  Danach hat jedes Objekt eine eigene Kopie des Deskriptors, kann die Ressource verwenden, ändern, aber nicht freigeben, solange mindestens ein weiteres Objekt eine Kopie des Deskriptors besitzt.  Eine Ressource wird freigegeben, nachdem das letzte Objekt, das eine Kopie des Handles besitzt, den Gültigkeitsbereich verlassen hat.  Wie dies implementiert werden kann, wird unten beschrieben. </p><br><p>  Miteigentumsstrategien werden häufig von intelligenten Zeigern verwendet, und es ist auch selbstverständlich, sie für unveränderliche Ressourcen zu verwenden.  Der Smart Pointer <code>std::shared_ptr&lt;&gt;</code> implementiert diese Strategie in der C ++ 11-Standardbibliothek. </p><br><a name="id-2"></a><br><h1>  2. Deep Copy-Strategie - Probleme und Lösungen </h1><br><p>  Betrachten Sie eine Vorlage für die Statusaustauschfunktion von Objekten vom Typ <code>T</code> in der C ++ 98-Standardbibliothek. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  Wenn Typ <code>T</code> eine Ressource besitzt und eine Deep-Copy-Strategie verwendet, haben wir drei Operationen, um eine neue Ressource zuzuweisen, drei Kopieroperationen und drei Operationen, um Ressourcen freizugeben.  Während dieser Vorgang in den meisten Fällen ausgeführt werden kann, ohne neue Ressourcen zuzuweisen und überhaupt zu kopieren, reicht es aus, wenn die Objekte interne Daten austauschen, einschließlich eines Ressourcendeskriptors.  Es gibt viele ähnliche Beispiele, wenn Sie temporäre Kopien einer Ressource erstellen und diese sofort freigeben müssen.  Eine solche ineffektive Implementierung des täglichen Betriebs stimulierte die Suche nach Lösungen für ihre Optimierung.  Betrachten wir die Hauptoptionen. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Aufzeichnen kopieren </h2><br><p>  Copy on Write (COW), auch als verzögerte Kopie bezeichnet, kann als Versuch angesehen werden, eine Deep-Copy-Strategie und eine Shared-Ownership-Strategie zu kombinieren.  Beim Kopieren eines Objekts wird zunächst der Ressourcendeskriptor ohne die Ressource selbst kopiert, und für Eigentümer wird die Ressource freigegeben und schreibgeschützt. Sobald jedoch ein Eigentümer die freigegebene Ressource ändern muss, wird die Ressource kopiert, und dieser Eigentümer arbeitet mit seiner eine Kopie.  Die Implementierung von COW löst das Problem des staatlichen Austauschs: Eine zusätzliche Zuweisung von Ressourcen und ein Kopieren erfolgt nicht.  Die Verwendung von COW ist bei der Implementierung von Zeichenfolgen sehr beliebt, z. B. <code>CString</code> (MFC, ATL).  Eine Diskussion möglicher Wege zur Implementierung von COW und neu auftretenden Problemen findet sich in [Meyers1], [Sutter].  [Guntheroth] schlug eine COW-Implementierung mit <code>std::shared_ptr&lt;&gt;</code> .  Bei der Implementierung von COW in einer Multithread-Umgebung treten Probleme auf. Daher ist es verboten, COW für Zeichenfolgen in der Standard-C ++ 11-Bibliothek zu verwenden (siehe [Josuttis], [Guntheroth]). </p><br><p>  Die Entwicklung der COW-Idee führt zu folgendem Ressourcenverwaltungsschema: Die Ressource ist unveränderlich und wird von Objekten mithilfe der gemeinsamen Eigentümerstrategie verwaltet. Falls erforderlich, um die Ressource zu ändern, wird eine neue, entsprechend geänderte Ressource erstellt und ein neues Eigentümerobjekt zurückgegeben.  Dieses Schema wird für Zeichenfolgen und andere unveränderliche Objekte auf den .NET- und Java-Plattformen verwendet.  In der funktionalen Programmierung wird es für komplexere Datenstrukturen verwendet. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Definieren einer Zustandsaustauschfunktion für eine Klasse </h2><br><p>  Es wurde oben gezeigt, wie ineffizient die Zustandsaustauschfunktion sein kann, die auf einfache Weise durch Kopieren und Zuweisen implementiert wird.  Und es wird ziemlich häufig verwendet, zum Beispiel wird es von vielen Algorithmen der Standardbibliothek verwendet.  Damit die Algorithmen nicht ein anderes <code>std::swap()</code> , sondern eine andere speziell für die Klasse definierte Funktion, müssen zwei Schritte ausgeführt werden. </p><br><p>  1. Definieren Sie in der Klasse eine Mitgliedsfunktion <code>Swap()</code> (der Name ist nicht wichtig), die den Austausch von Zuständen implementiert. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Sie müssen sicherstellen, dass diese Funktion keine Ausnahmen <code>noexcept</code> . In C ++ 11 müssen solche Funktionen als <code>noexcept</code> deklariert werden. </p><br><p>  2. Definieren Sie im selben Namespace wie Klasse <code>X</code> (normalerweise in derselben Header-Datei) die freie Funktion (nicht Mitglied) <code>swap()</code> wie folgt (Name und Signatur sind grundlegend): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  Danach wird es von den Algorithmen der Standardbibliothek verwendet, nicht von <code>std::swap()</code> .  Dies bietet einen Mechanismus, der als argumentabhängige Suche (ADL) bezeichnet wird.  Weitere Informationen zu ADL finden Sie unter [Dewhurst1]. </p><br><p>  In der C ++ - Standardbibliothek implementieren alle Container, Smart Pointer sowie andere Klassen die Statusaustauschfunktion wie oben beschrieben. </p><br><p>  Die <code>Swap()</code> -Mitgliedsfunktion ist normalerweise einfach zu definieren: Es ist erforderlich, nacheinander eine Statusaustauschoperation auf die Datenbanken und Mitglieder anzuwenden, sofern sie dies unterstützen, und ansonsten auf <code>std::swap()</code> . </p><br><p>  Die obige Beschreibung ist etwas vereinfacht, eine detailliertere findet sich in [Meyers2].  Eine Diskussion von Fragen im Zusammenhang mit der staatlichen Austauschfunktion findet sich auch in [Sutter / Alexandrescu]. </p><br><p>  Die Zustandsaustauschfunktion kann einer der Grundoperationen der Klasse zugeordnet werden.  Mit dieser Funktion können Sie andere Vorgänge ordnungsgemäß definieren.  Beispielsweise wird der Kopierzuweisungsoperator durch copy und <code>Swap()</code> wie folgt definiert: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Diese Vorlage wird als Kopier- und Austauschsprache oder Herb Sutter-Sprache bezeichnet. Weitere Informationen finden Sie unter [Sutter], [Sutter / Alexandrescu], [Meyers2].  Seine Modifikation kann angewendet werden, um die Semantik der Verschiebung zu implementieren, siehe Abschnitte 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Zwischenkopien vom Compiler entfernen </h2><br><p>  Betrachten Sie die Klasse </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Und funktionieren </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  Mit einem einfachen Ansatz wird die Rückkehr von der <code>Foo()</code> Funktion durch Kopieren der Instanz von <code>X</code>  Compiler können den Kopiervorgang jedoch aus dem Code entfernen, das Objekt wird direkt am Aufrufpunkt erstellt.  Dies wird als Rückgabewertoptimierung (RVO) bezeichnet.  RVO wird seit einiger Zeit von Compiler-Entwicklern verwendet und ist derzeit im C ++ 11-Standard festgelegt.  Obwohl die Entscheidung über RVO vom Compiler getroffen wird, kann der Programmierer Code basierend auf seiner Verwendung schreiben.  Zu diesem Zweck ist es wünschenswert, dass die Funktion einen Rückgabepunkt hat und der Typ des zurückgegebenen Ausdrucks mit dem Typ des Rückgabewerts der Funktion übereinstimmt.  In einigen Fällen ist es ratsam, einen speziellen geschlossenen Konstruktor zu definieren, der als „Rechenkonstruktor“ bezeichnet wird. Weitere Einzelheiten finden Sie unter [Dewhurst2].  RVO wird auch in [Meyers3] und [Guntheroth] diskutiert. </p><br><p>  Compiler können in anderen Situationen Zwischenkopien löschen. </p><br><a name="id-2-4"></a><br><h2>  2.4.  Implementierung der Verschiebungssemantik </h2><br><p>  Die Implementierung der Verschiebungssemantik besteht darin, einen Verschiebungskonstruktor zu definieren, der einen Parameter vom Typ rWertreferenz auf die Quelle und einen Verschiebungszuweisungsoperator mit demselben Parameter enthält. </p><br><p>  In der C ++ 11-Standardbibliothek ist die Funktionsvorlage für den Statusaustausch wie folgt definiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  In Übereinstimmung mit den Regeln zum Auflösen von Überladungen von Funktionen mit Parametern vom Typ rWertreferenz (siehe Anhang A) werden diese verwendet, wenn der Typ <code>T</code> einen sich bewegenden Konstruktor und einen sich bewegenden Zuweisungsoperator hat, und es werden keine temporären Ressourcen zugewiesen und kopiert.  Andernfalls werden der Kopierkonstruktor und der Kopierzuweisungsoperator verwendet. </p><br><p>  Durch die Verwendung der Semantik der Verlagerung wird vermieden, dass temporäre Kopien in einem viel breiteren Kontext als der oben beschriebenen Zustandsaustauschfunktion erstellt werden.  Die Bewegungssemantik gilt für jeden r-Wert, dh einen temporären, unbenannten Wert, sowie für den Rückgabewert einer Funktion, wenn sie lokal erstellt wurde (einschließlich l-Wert) und RVO nicht angewendet wurde.  In all diesen Fällen ist garantiert, dass das Quellobjekt nach dem Verschieben in keiner Weise verwendet werden kann.  Die Verschiebungssemantik gilt auch für den Wert lvalue, auf den die Transformation <code>std::move()</code> angewendet wird.  In diesem Fall ist der Programmierer jedoch dafür verantwortlich, wie die Quellobjekte nach dem Verschieben verwendet werden (Beispiel <code>std::swap()</code> ). </p><br><p>  Die Standard-C ++ 11-Bibliothek wurde unter Berücksichtigung der Bewegungssemantik neu gestaltet.  Viele Klassen haben einen Verschiebungskonstruktor und einen Verschiebungszuweisungsoperator sowie andere Elementfunktionen mit Parametern vom Typ rWertreferenz hinzugefügt.  Zum Beispiel hat <code>std::vector&lt;T&gt;</code> eine überladene Version von <code>void push_back(T&amp;&amp; src)</code> .  All dies ermöglicht es in vielen Fällen, das Erstellen temporärer Kopien zu vermeiden. </p><br><p>  Durch die Implementierung der Verschiebungssemantik werden die Definitionen der Statusaustauschfunktion für eine Klasse nicht aufgehoben.  Eine speziell definierte Zustandsaustauschfunktion kann effizienter sein als die Standardfunktion <code>std::swap()</code> .  Darüber hinaus lassen sich der Verschiebungskonstruktor und der Verschiebungszuweisungsoperator sehr einfach unter Verwendung der Elementfunktion des Zustandsaustauschs wie folgt definieren (Variation der Kopier- und Austauschsprache): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  Der Verschiebungskonstruktor und der Verschiebungszuweisungsoperator sind diejenigen <code>noexcept</code> für die es äußerst wünschenswert ist, sicherzustellen, dass sie keine Ausnahmen <code>noexcept</code> und dementsprechend als <code>noexcept</code> deklariert werden.  Auf diese Weise können Sie einige Operationen der Standardbibliothekscontainer optimieren, ohne die strikte Garantie für die Sicherheit von Ausnahmen zu verletzen. Weitere Informationen finden Sie unter [Meyers3] und [Guntheroth].  Die vorgeschlagene Vorlage bietet eine solche Garantie, sofern der Standardkonstruktor und die Mitgliedsfunktion des Staatenaustauschs keine Ausnahmen auslösen. </p><br><p>  Der C ++ 11-Standard sieht vor, dass der Compiler automatisch einen Verschiebungskonstruktor und einen Verschiebungszuweisungsoperator generiert. Dazu müssen sie mit dem Konstrukt <code>"=default"</code> deklariert werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Operationen werden implementiert, indem die Verschiebungsoperation nacheinander auf die Basen und Mitglieder der Klasse angewendet wird, sofern sie die Verschiebung unterstützen, und Operationen ansonsten kopiert werden.  Es ist klar, dass diese Option bei weitem nicht immer akzeptabel ist.  Rohe Deskriptoren werden nicht verschoben, können jedoch normalerweise nicht kopiert werden.  Unter bestimmten Bedingungen kann der Compiler unabhängig voneinander einen ähnlichen Verschiebungskonstruktor und Verschiebungszuweisungsoperator generieren. Es ist jedoch besser, diese Gelegenheit nicht zu nutzen. Diese Bedingungen sind ziemlich verwirrend und können sich leicht ändern, wenn die Klasse verfeinert wird.  Siehe [Meyers3] für Details. </p><br><p>  Im Allgemeinen ist die Implementierung und Verwendung der Semantik der Verschiebung eine ziemlich "subtile Sache".  Der Compiler kann das Kopieren dort anwenden, wo der Programmierer eine Verschiebung erwartet.  Hier sind einige Regeln, um die Wahrscheinlichkeit einer solchen Situation zu beseitigen oder zumindest zu verringern. </p><br><ol><li>  Verwenden Sie nach Möglichkeit das Kopierverbot. </li><li>  Deklarieren Sie den Verschiebungskonstruktor und den Verschiebungszuweisungsoperator als <code>noexcept</code> . </li><li>  Implementieren Sie die Bewegungssemantik für Basisklassen und Mitglieder. </li><li>  Wenden Sie die Transformation <code>std::move()</code> auf die Parameter von Funktionen vom Typ rvalue reference an. </li></ol><br><p>  Regel 2 wurde oben diskutiert.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5.  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      —   (variadic templates),         .  ,      C++11 —     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6.  Zusammenfassung </h2><br><p>     ,    ,     .               -  .                   .   —     :    ,    .     ,       ,     ,  .      :     ,     ,  «»   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    —   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    —   .     6. </p><br><p>   ,     -  -,  «  »,   -     .         -    . ,   ,     ,     ,    -       .      «». </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2>  6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          «   » (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      «» RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2>  6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     «  »,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  «» RAII,   —          .      ,     ,    . 3.       .    «»,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        —    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Anwendungen </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Ein Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- —      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         —    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Referenzliste </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: .  aus dem Englischen  - M.: LLC “I.D. », 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: .  aus dem Englischen — .:  «-», 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  aus dem Englischen  - M.: LLC “I.D. », 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  aus dem Englischen — .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  aus dem Englischen — .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  aus dem Englischen — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  aus dem Englischen — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  aus dem Englischen  - M.: LLC “I.D. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  aus dem Englischen — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  aus dem Englischen  - M.: LLC “I.D. », 2015. </p><br><p> [Schildt] <br> , .    C++.: .  aus dem Englischen — .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  aus dem Englischen — .:  « «», 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425837/">https://habr.com/ru/post/de425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425827/index.html">Google+ Lektion: Projekte müssen sicherstellen, dass die Grenzen zwischen den Interessen der Nutzer im wirklichen Leben online respektiert werden</a></li>
<li><a href="../de425829/index.html">Wie wir mit Roskomnadzor gekämpft haben und was daraus wurde</a></li>
<li><a href="../de425831/index.html">RKN Alert - Roskomnadzor-Datenbank in Ihrem Browser</a></li>
<li><a href="../de425833/index.html">Ein Tool, mit dem Sie die besten Ideen für Ihr Produkt auswählen können.</a></li>
<li><a href="../de425835/index.html">"Breaking Bugs" in Sberbank: So beheben Sie die Fehlerrate von sieben Tagen pro Tag</a></li>
<li><a href="../de425839/index.html">Atlassian Conference Review</a></li>
<li><a href="../de425843/index.html">Python für das Kind: Auswahl eines Tutorials</a></li>
<li><a href="../de425845/index.html">Apps bei Google Play automatisch sperren</a></li>
<li><a href="../de425847/index.html">Ein Beispiel für die Verwendung von Microsoft Flow oder So geben Sie Ihrer Frau Blumen</a></li>
<li><a href="../de425849/index.html">Amazon gab auf und erhöhte die Gehälter der Mitarbeiter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>