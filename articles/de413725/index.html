<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëæ üí∫ üßïüèº Arbeiten mit Arrays in Bash üöõ üê¥ üî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programmierer verwenden Bash regelm√§√üig, um viele Aufgaben im Zusammenhang mit der Softwareentwicklung zu l√∂sen. Gleichzeitig werden Bash-Arrays oft a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten mit Arrays in Bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/413725/">  Programmierer verwenden Bash regelm√§√üig, um viele Aufgaben im Zusammenhang mit der Softwareentwicklung zu l√∂sen.  Gleichzeitig werden Bash-Arrays oft als eines der unverst√§ndlichsten Merkmale dieser Shell angesehen (wahrscheinlich sind Arrays in dieser Hinsicht nach regul√§ren Ausdr√ºcken an zweiter Stelle).  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, l√§dt alle in die wunderbare Welt der Bash-Arrays ein, die, wenn Sie sich an ihre ungew√∂hnliche Syntax gew√∂hnen, viele Vorteile bringen k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efa/72d/7c7/efa72d7c779f3915863c44ac528143a2.jpg" alt="Bild"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Die wahre Herausforderung, die Bash-Arrays bieten</font> </h2><br>  Das Schreiben √ºber Bash ist umstritten.  Tatsache ist, dass Artikel √ºber Bash h√§ufig zu Benutzerhandb√ºchern werden, die sich mit Geschichten √ºber die syntaktischen Merkmale der betreffenden Befehle befassen.  Dieser Artikel ist anders geschrieben. Wir hoffen, dass Sie ihn nicht im n√§chsten "Benutzerhandbuch" finden. <br><br>  Stellen Sie sich vor diesem Hintergrund ein reales Szenario f√ºr die Verwendung von Arrays in Bash vor.  Angenommen, Sie stehen vor der Aufgabe, ein Dienstprogramm anhand eines neuen internen Satzes von Tools zu bewerten und zu optimieren, die in Ihrem Unternehmen verwendet werden.  Im ersten Schritt dieser Studie m√ºssen Sie sie mit verschiedenen Parameters√§tzen testen.  Der Test zielt darauf ab zu untersuchen, wie sich ein neuer Satz von Werkzeugen verh√§lt, wenn sie eine andere Anzahl von Threads verwenden.  Zur Vereinfachung der Darstellung nehmen wir an, dass die ‚ÄûToolbox‚Äú eine aus C ++ - Code kompilierte ‚ÄûBlack Box‚Äú ist.  Bei Verwendung ist der einzige Parameter, den wir beeinflussen k√∂nnen, die Anzahl der f√ºr die Datenverarbeitung reservierten Threads.  Das Aufrufen des zu untersuchenden Systems √ºber die Befehlszeile sieht folgenderma√üen aus: <br><br><pre><code class="hljs pgsql">./pipeline <span class="hljs-comment"><span class="hljs-comment">--threads 4</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Die Grundlagen</font> </h2><br>  Zun√§chst deklarieren wir ein Array, das die Werte des Parameters <code>--threads</code> , mit dem wir das System testen m√∂chten.  Dieses Array sieht folgenderma√üen aus: <br><br><pre> <code class="hljs lisp">allThreads=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span>)</code> </pre> <br>  In diesem Beispiel sind alle Elemente Zahlen, aber tats√§chlich k√∂nnen Sie in Bash-Arrays sowohl Zahlen als auch Zeichenfolgen gleichzeitig speichern.  Zum Beispiel ist die Deklaration eines solchen Arrays durchaus akzeptabel: <br><br><pre> <code class="hljs lisp">myArray=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">"three"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-string"><span class="hljs-string">"five"</span></span>)</code> </pre> <br>  Stellen Sie wie bei anderen Bash-Variablen sicher, dass um das <code>=</code> -Zeichen keine Leerzeichen vorhanden sind.  Andernfalls betrachtet bash den Variablennamen als den Namen des Programms, das ausgef√ºhrt werden soll, und <code>=</code> das erste Argument! <br><br>  Nachdem wir das Array initialisiert haben, extrahieren wir einige Elemente daraus.  Hier k√∂nnen Sie beispielsweise feststellen, dass der <code>echo $allThreads</code> nur das erste Element des Arrays ausgibt. <br><br>  Um die Gr√ºnde f√ºr dieses Verhalten zu verstehen, lassen Sie uns ein wenig von Arrays abweichen und uns daran erinnern, wie man mit Variablen in bash arbeitet.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=<span class="hljs-string"><span class="hljs-string">"article"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Found 42 </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$type</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  Angenommen, Sie haben eine Variable vom <code>$type</code> , die eine Zeichenfolge enth√§lt, die ein Substantiv darstellt.  F√ºgen Sie nach diesem Wort den Buchstaben <code>s</code> .  Sie k√∂nnen diesen Buchstaben jedoch nicht einfach am Ende des Variablennamens einf√ºgen, da dadurch der Befehl zum Zugriff auf die Variable in <code>$types</code> wird. Das hei√üt, wir arbeiten mit einer v√∂llig anderen Variablen.  In dieser Situation k√∂nnen Sie ein Konstrukt wie <code>echo "Found 42 "$type"s"</code> .  Es ist jedoch am besten, dieses Problem in geschweiften Klammern zu l√∂sen: <code>echo "Found 42 ${type}s"</code> , mit dem wir bash mitteilen k√∂nnen, wo der Variablenname beginnt und endet (interessanterweise wird in JavaScript ES6 dieselbe Syntax zum Einbetten von Variablen verwendet in Ausdr√ºcken in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musterzeichenfolgen</a> ). <br><br>  Nun zur√ºck zu den Arrays.  Es stellt sich heraus, dass geschweifte Klammern normalerweise nicht ben√∂tigt werden, wenn mit Variablen gearbeitet wird, sie werden jedoch ben√∂tigt, um mit Arrays zu arbeiten.  Mit ihnen k√∂nnen Sie Indizes festlegen, um auf die Elemente des Arrays zuzugreifen.  Beispielsweise gibt ein Befehl der Form <code>echo ${allThreads[1]}</code> das zweite Element des Arrays aus.  Wenn Sie geschweifte Klammern in der obigen Konstruktion vergessen, nimmt bash <code>[1]</code> als Zeichenfolge wahr und verarbeitet, was entsprechend geschieht. <br><br>  Wie Sie sehen k√∂nnen, haben Arrays in Bash eine seltsame Syntax, aber in ihnen beginnt zumindest die Nummerierung der Elemente von vorne.  Dies macht sie √§hnlich wie Arrays aus vielen anderen Programmiersprachen. <br><br><h2>  <font color="#3AC1EF">M√∂glichkeiten, auf Array-Elemente zuzugreifen</font> </h2><br>  Im obigen Beispiel haben wir ganzzahlige Indizes in Arrays verwendet, die explizit angegeben sind.  Betrachten Sie nun zwei weitere M√∂glichkeiten, um mit Arrays zu arbeiten. <br><br>  Die erste Methode ist anwendbar, wenn wir das <code>$i</code> te Element des Arrays ben√∂tigen, wobei <code>$i</code> eine Variable ist, die den Index des gew√ºnschten Array-Elements enth√§lt.  Sie k√∂nnen dieses Element mit einem Konstrukt der Form <code>echo ${allThreads[$i]}</code> aus dem Array extrahieren. <br><br>  Mit der zweiten Methode k√∂nnen Sie alle Elemente des Arrays anzeigen.  Es besteht darin, den numerischen Index durch das <code>@</code> -Symbol zu ersetzen (es kann als Befehl interpretiert werden, der auf alle Elemente des Arrays verweist).  Es sieht so aus: <code>echo ${allThreads[@]}</code> . <br><br><h2>  <font color="#3AC1EF">Iterieren √ºber Array-Elemente in Schleifen</font> </h2><br>  Die obigen Prinzipien der Arbeit mit Array-Elementen sind f√ºr uns n√ºtzlich, um das Problem der Aufz√§hlung von Array-Elementen zu l√∂sen.  In unserem Fall bedeutet dies, dass der zu untersuchende <code>pipeline</code> Befehl mit jedem der Werte gestartet wird, der die Anzahl der Threads symbolisiert und in einem Array gespeichert ist.  Es sieht so aus: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$t</span></span> done</code> </pre> <br><h2>  <font color="#3AC1EF">Array-Indizes in Schleifen auflisten</font> </h2><br>  Betrachten Sie nun einen etwas anderen Ansatz zum Sortieren von Arrays.  Anstatt √ºber die Elemente zu iterieren, k√∂nnen wir √ºber die Indizes des Arrays iterieren: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{!allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-variable"><span class="hljs-variable">$i</span></span>]} done</code> </pre> <br>  Lassen Sie uns analysieren, was hier passiert.  Wie wir bereits gesehen haben, repr√§sentiert eine Konstruktion der Form <code>${allThreads[@]}</code> alle Elemente des Arrays.  Wenn wir hier ein Ausrufezeichen <code>${!allThreads[@]}</code> , verwandeln wir dieses Konstrukt in <code>${!allThreads[@]}</code> , was dazu f√ºhrt, dass die Indizes des Arrays zur√ºckgegeben werden (in unserem Fall von 0 bis 7). <br><br>  Mit anderen Worten, die <code>for</code> Schleife <code>for</code> alle Indizes des als Variable <code>$i</code> dargestellten Arrays, und im Hauptteil der Schleife wird auf die Elemente des Arrays, die als Werte des Parameters <code>--thread</code> dienen, mit dem Konstrukt <code>${allThreads[$i]}</code> <code>--thread</code> . <br><br>  Das Lesen dieses Codes ist schwieriger als im vorherigen Beispiel.  Daher stellt sich die Frage, wof√ºr all diese Schwierigkeiten sind.  Und wir brauchen dies, weil Sie in einigen Situationen bei der Verarbeitung von Arrays in Schleifen sowohl die Indizes als auch die Werte der Elemente kennen m√ºssen.  Wenn Sie beispielsweise das erste Element des Arrays √ºberspringen m√ºssen, erspart uns das Durchlaufen der Indizes beispielsweise die Notwendigkeit, eine zus√§tzliche Variable zu erstellen und diese in einer Schleife zu erh√∂hen, um mit Array-Elementen zu arbeiten. <br><br><h2>  <font color="#3AC1EF">Arrays f√ºllen</font> </h2><br>  Bisher haben wir das System untersucht, indem wir den <code>pipeline</code> Befehl <code>--threads</code> und ihm jeden der Werte des Parameters <code>--threads</code> uns interessiert.  Angenommen, dieser Befehl gibt die Dauer eines bestimmten Prozesses in Sekunden an.  Wir m√∂chten die bei jeder Iteration zur√ºckgegebenen Daten abfangen und in einem anderen Array speichern.  Dies gibt uns die M√∂glichkeit, nach Abschluss aller Tests mit den gespeicherten Daten zu arbeiten. <br><br><h2>  <font color="#3AC1EF">N√ºtzliche Syntaxkonstrukte</font> </h2><br>  Bevor wir uns mit dem Hinzuf√ºgen von Daten zu Arrays befassen, schauen wir uns einige n√ºtzliche Syntaxkonstrukte an.  Zun√§chst ben√∂tigen wir einen Mechanismus, um Daten zu erhalten, die von Bash-Befehlen ausgegeben werden.  Um die Ausgabe eines Befehls zu erfassen, m√ºssen Sie die folgende Konstruktion verwenden: <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">output</span></span>=$( ./my_script.sh )</code> </pre> <br>  Nach Ausf√ºhrung dieses Befehls wird die <code>$output</code> <code>myscript.sh</code> in der <code>$output</code> gespeichert. <br><br>  Die zweite Konstruktion, die sehr bald n√ºtzlich sein wird, erm√∂glicht es uns, neue Daten an Arrays anzuh√§ngen.  Es sieht so aus: <br><br><pre> <code class="hljs lisp">myArray+=( <span class="hljs-string"><span class="hljs-string">"newElement1"</span></span> <span class="hljs-string"><span class="hljs-string">"newElement2"</span></span> )</code> </pre> <br><h2>  <font color="#3AC1EF">Probleml√∂sung</font> </h2><br>  Wenn Sie nun alles zusammenstellen, was wir gerade gelernt haben, k√∂nnen Sie ein Skript zum Testen des Systems erstellen, das einen Befehl mit jedem der Parameterwerte aus dem Array ausf√ºhrt und im anderen Array speichert, was dieser Befehl anzeigt. <br><br><pre> <code class="hljs powershell">allThreads=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span>) allRuntimes=() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> runtime=<span class="hljs-variable"><span class="hljs-variable">$</span></span>(./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$t</span></span>) allRuntimes+=( <span class="hljs-variable"><span class="hljs-variable">$runtime</span></span> ) done</code> </pre> <br><h2>  <font color="#3AC1EF">Was weiter?</font> </h2><br>  Wir haben gerade untersucht, wie Bash-Arrays verwendet werden, um die beim Starten eines Programms verwendeten Parameter zu durchlaufen und die von diesem Programm zur√ºckgegebenen Daten zu speichern.  Die Optionen f√ºr die Verwendung von Arrays sind jedoch nicht auf dieses Szenario beschr√§nkt.  Hier noch ein paar Beispiele. <br><br><h2>  <font color="#3AC1EF">Problemwarnungen</font> </h2><br>  In diesem Szenario betrachten wir eine Anwendung, die in Module unterteilt ist.  Jedes dieser Module verf√ºgt √ºber eine eigene Protokolldatei.  Wir k√∂nnen ein <code>cron</code> Job-Skript schreiben, das bei Problemen in der entsprechenden Protokolldatei die Person, die f√ºr jedes der Module verantwortlich ist, per E-Mail benachrichtigt: <br><br><pre> <code class="hljs kotlin">#  -    logPaths=(<span class="hljs-string"><span class="hljs-string">"api.log"</span></span> <span class="hljs-string"><span class="hljs-string">"auth.log"</span></span> <span class="hljs-string"><span class="hljs-string">"jenkins.log"</span></span> <span class="hljs-string"><span class="hljs-string">"data.log"</span></span>) logEmails=(<span class="hljs-string"><span class="hljs-string">"jay@email"</span></span> <span class="hljs-string"><span class="hljs-string">"emma@email"</span></span> <span class="hljs-string"><span class="hljs-string">"jon@email"</span></span> <span class="hljs-string"><span class="hljs-string">"sophia@email"</span></span>) #         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ${!logPaths[@]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> log=${logPaths[$i]} stakeholder=${logEmails[$i]} numErrors=$( tail -n <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$log</span></span></span><span class="hljs-string">"</span></span> | grep <span class="hljs-string"><span class="hljs-string">"ERROR"</span></span> | wc -l ) #       <span class="hljs-number"><span class="hljs-number">5</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$numErrors</span></span></span><span class="hljs-string">"</span></span> -gt <span class="hljs-number"><span class="hljs-number">5</span></span> ]]; then   emailRecipient=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$stakeholder</span></span></span><span class="hljs-string">"</span></span>   emailSubject=<span class="hljs-string"><span class="hljs-string">"WARNING: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${log}</span></span></span><span class="hljs-string"> showing unusual levels of errors"</span></span>   emailBody=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${numErrors}</span></span></span><span class="hljs-string"> errors found in log </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${log}</span></span></span><span class="hljs-string">"</span></span>   echo <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailBody</span></span></span><span class="hljs-string">"</span></span> | mailx -s <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailSubject</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailRecipient</span></span></span><span class="hljs-string">"</span></span> fi done</code> </pre> <br><h2>  <font color="#3AC1EF">API-Anfragen</font> </h2><br>  Angenommen, Sie m√∂chten Informationen dar√ºber sammeln, welche Benutzer Ihre Beitr√§ge auf Medium kommentieren.  Da wir keinen direkten Zugriff auf die Datenbank dieser Site haben, werden SQL-Abfragen nicht behandelt.  Sie k√∂nnen jedoch verschiedene APIs verwenden, um auf diese Art von Daten zuzugreifen. <br><br>  Um lange Gespr√§che √ºber Authentifizierung und Token zu vermeiden, verwenden wir als Endpunkt den √∂ffentlichen API- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testdienst JSONPlaceholder</a> .  Nachdem wir eine Ver√∂ffentlichung vom Dienst erhalten und Daten aus seinem Code an den E-Mail-Adressen der Kommentatoren extrahiert haben, k√∂nnen wir diese Daten in ein Array einf√ºgen: <br><br><pre> <code class="hljs kotlin">endpoint=<span class="hljs-string"><span class="hljs-string">"https://jsonplaceholder.typicode.com/comments"</span></span> allEmails=() #   <span class="hljs-number"><span class="hljs-number">10</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> postId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> #    API       response=$(curl <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${endpoint}</span></span></span><span class="hljs-string">?postId=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${postId}</span></span></span><span class="hljs-string">"</span></span>) #  jq   JSON       allEmails+=( $( jq <span class="hljs-string"><span class="hljs-string">'.[].email'</span></span> &lt;&lt;&lt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$response</span></span></span><span class="hljs-string">"</span></span> ) ) done</code> </pre> <br>  Bitte beachten Sie, dass hier das Tool <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jq</a> verwendet wird, mit dem JSON in der Befehlszeile analysiert werden kann.  Wir werden nicht n√§her auf die Arbeit mit jq eingehen, wenn Sie an diesem Tool interessiert sind - siehe die Dokumentation dazu. <br><br><h2>  <font color="#3AC1EF">Bash oder Python?</font> </h2><br>  Arrays - eine n√ºtzliche Funktion, die nicht nur in Bash verf√ºgbar ist.  Derjenige, der Skripte f√ºr die Befehlszeile schreibt, hat m√∂glicherweise eine logische Frage, in welchen Situationen es sich lohnt, bash zu verwenden, und in welchen beispielsweise Python. <br><br>  Meiner Meinung nach liegt die Antwort auf diese Frage darin, wie sehr der Programmierer von einer bestimmten Technologie abh√§ngt.  Angenommen, wenn das Problem direkt in der Befehlszeile gel√∂st werden kann, verhindert nichts die Verwendung von Bash.  F√ºr den Fall, dass beispielsweise das Skript, an dem Sie interessiert sind, Teil eines in Python geschriebenen Projekts ist, k√∂nnen Sie Python gut verwenden. <br><br>  Um das hier betrachtete Problem zu l√∂sen, k√∂nnen Sie beispielsweise ein in Python geschriebenes Skript verwenden. Dies f√ºhrt jedoch dazu, dass Wrapper f√ºr Python-Wrapper f√ºr bash geschrieben werden: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess all_threads = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>] all_runtimes = [] #         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_threads: cmd = <span class="hljs-string"><span class="hljs-string">'./pipeline --threads {}'</span></span>.format(t) #   subprocess   ,    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) output = p.communicate()[<span class="hljs-number"><span class="hljs-number">0</span></span>] all_runtimes.append(output)</code> </pre> <br>  Vielleicht ist die L√∂sung f√ºr dieses Problem mit Bash ohne andere Technologien k√ºrzer und verst√§ndlicher, und hier k√∂nnen Sie ganz auf Python verzichten. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Material haben wir viele Designs analysiert, die f√ºr die Arbeit mit Arrays verwendet wurden.  Hier ist eine Tabelle, in der Sie finden, was wir √ºberpr√ºft haben und etwas Neues. <br><table><tbody><tr><td>  Syntaxkonstrukt </td><td>  Beschreibung </td></tr><tr><td> <code>arr=()</code> </td> <td>  Erstellen Sie ein leeres Array </td></tr><tr><td> <code>arr=(1 2 3)</code> </td> <td>  Array-Initialisierung </td></tr><tr><td> <code>${arr[2]}</code> </td> <td>  Das dritte Element eines Arrays abrufen </td></tr><tr><td> <code>${arr[@]}</code> </td> <td>  Alle Array-Elemente abrufen </td></tr><tr><td> <code>${!arr[@]}</code> </td> <td>  Array-Indizes abrufen </td></tr><tr><td> <code>${#arr[@]}</code> </td> <td>  Berechnung der Arraygr√∂√üe </td></tr><tr><td> <code>arr[0]=3</code> </td> <td>  √úberschreiben des ersten Elements eines Arrays </td></tr><tr><td> <code>arr+=(4)</code> </td> <td>  Verbinden eines Array von Werten </td></tr><tr><td> <code>str=$(ls)</code> </td> <td>  Speichern der <code>ls</code> als Zeichenfolge </td></tr><tr><td> <code>arr=( $(ls) )</code> </td> <td>  Speichern der Ausgabe des <code>ls</code> als Array von Dateinamen </td></tr><tr><td> <code>${arr[@]:s:n}</code> </td> <td>  Abrufen von Array-Elementen vom Element mit dem Index <code>s</code> zum Element mit dem Index <code>s+(n-1)</code> <br></td></tr></tbody></table><br>  Auf den ersten Blick m√∂gen Bash-Arrays ziemlich seltsam erscheinen, aber die M√∂glichkeiten, die sie bieten, sind es wert, mit diesen Kuriosit√§ten umzugehen.  Wir glauben, dass Sie Bash-Arrays, wenn Sie sie beherrschen, ziemlich oft verwenden werden.  Es ist leicht vorstellbar, dass unz√§hlige Szenarien n√ºtzlich sein k√∂nnen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie interessante Beispiele f√ºr die Verwendung von Arrays in Bash-Skripten haben, teilen Sie diese bitte mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413725/">https://habr.com/ru/post/de413725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413715/index.html">IT-Altersrente</a></li>
<li><a href="../de413717/index.html">GraphQL f√ºr InterSystems-Plattformen</a></li>
<li><a href="../de413719/index.html">C ++ 20 unterwegs! Treffen bei Rapperswil Yona</a></li>
<li><a href="../de413721/index.html">Zeitcheck: Timejacking gegen Bitcoin</a></li>
<li><a href="../de413723/index.html">Saga der elektronischen Dienste und ihrer Standorte. Teil 2. Elektronischer Schrank</a></li>
<li><a href="../de413729/index.html">Wie und warum haben wir unser ECS geschrieben?</a></li>
<li><a href="../de413731/index.html">BA / SA Arbeitsmarktforschung</a></li>
<li><a href="../de413733/index.html">Mikrosh, Krista, Apogee, Lviv - die ersten sowjetischen Computer zum Mitnehmen</a></li>
<li><a href="../de413739/index.html">Wie wir das gesamte Internet gescannt haben und was wir gelernt haben</a></li>
<li><a href="../de413741/index.html">Was es war und wie: Eindr√ºcke des WWDC Redmadrobot-Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>