<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👾 💺 🧕🏼 Arbeiten mit Arrays in Bash 🚛 🐴 🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programmierer verwenden Bash regelmäßig, um viele Aufgaben im Zusammenhang mit der Softwareentwicklung zu lösen. Gleichzeitig werden Bash-Arrays oft a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten mit Arrays in Bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/413725/">  Programmierer verwenden Bash regelmäßig, um viele Aufgaben im Zusammenhang mit der Softwareentwicklung zu lösen.  Gleichzeitig werden Bash-Arrays oft als eines der unverständlichsten Merkmale dieser Shell angesehen (wahrscheinlich sind Arrays in dieser Hinsicht nach regulären Ausdrücken an zweiter Stelle).  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, lädt alle in die wunderbare Welt der Bash-Arrays ein, die, wenn Sie sich an ihre ungewöhnliche Syntax gewöhnen, viele Vorteile bringen können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efa/72d/7c7/efa72d7c779f3915863c44ac528143a2.jpg" alt="Bild"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Die wahre Herausforderung, die Bash-Arrays bieten</font> </h2><br>  Das Schreiben über Bash ist umstritten.  Tatsache ist, dass Artikel über Bash häufig zu Benutzerhandbüchern werden, die sich mit Geschichten über die syntaktischen Merkmale der betreffenden Befehle befassen.  Dieser Artikel ist anders geschrieben. Wir hoffen, dass Sie ihn nicht im nächsten "Benutzerhandbuch" finden. <br><br>  Stellen Sie sich vor diesem Hintergrund ein reales Szenario für die Verwendung von Arrays in Bash vor.  Angenommen, Sie stehen vor der Aufgabe, ein Dienstprogramm anhand eines neuen internen Satzes von Tools zu bewerten und zu optimieren, die in Ihrem Unternehmen verwendet werden.  Im ersten Schritt dieser Studie müssen Sie sie mit verschiedenen Parametersätzen testen.  Der Test zielt darauf ab zu untersuchen, wie sich ein neuer Satz von Werkzeugen verhält, wenn sie eine andere Anzahl von Threads verwenden.  Zur Vereinfachung der Darstellung nehmen wir an, dass die „Toolbox“ eine aus C ++ - Code kompilierte „Black Box“ ist.  Bei Verwendung ist der einzige Parameter, den wir beeinflussen können, die Anzahl der für die Datenverarbeitung reservierten Threads.  Das Aufrufen des zu untersuchenden Systems über die Befehlszeile sieht folgendermaßen aus: <br><br><pre><code class="hljs pgsql">./pipeline <span class="hljs-comment"><span class="hljs-comment">--threads 4</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Die Grundlagen</font> </h2><br>  Zunächst deklarieren wir ein Array, das die Werte des Parameters <code>--threads</code> , mit dem wir das System testen möchten.  Dieses Array sieht folgendermaßen aus: <br><br><pre> <code class="hljs lisp">allThreads=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span>)</code> </pre> <br>  In diesem Beispiel sind alle Elemente Zahlen, aber tatsächlich können Sie in Bash-Arrays sowohl Zahlen als auch Zeichenfolgen gleichzeitig speichern.  Zum Beispiel ist die Deklaration eines solchen Arrays durchaus akzeptabel: <br><br><pre> <code class="hljs lisp">myArray=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">"three"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-string"><span class="hljs-string">"five"</span></span>)</code> </pre> <br>  Stellen Sie wie bei anderen Bash-Variablen sicher, dass um das <code>=</code> -Zeichen keine Leerzeichen vorhanden sind.  Andernfalls betrachtet bash den Variablennamen als den Namen des Programms, das ausgeführt werden soll, und <code>=</code> das erste Argument! <br><br>  Nachdem wir das Array initialisiert haben, extrahieren wir einige Elemente daraus.  Hier können Sie beispielsweise feststellen, dass der <code>echo $allThreads</code> nur das erste Element des Arrays ausgibt. <br><br>  Um die Gründe für dieses Verhalten zu verstehen, lassen Sie uns ein wenig von Arrays abweichen und uns daran erinnern, wie man mit Variablen in bash arbeitet.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=<span class="hljs-string"><span class="hljs-string">"article"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Found 42 </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$type</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  Angenommen, Sie haben eine Variable vom <code>$type</code> , die eine Zeichenfolge enthält, die ein Substantiv darstellt.  Fügen Sie nach diesem Wort den Buchstaben <code>s</code> .  Sie können diesen Buchstaben jedoch nicht einfach am Ende des Variablennamens einfügen, da dadurch der Befehl zum Zugriff auf die Variable in <code>$types</code> wird. Das heißt, wir arbeiten mit einer völlig anderen Variablen.  In dieser Situation können Sie ein Konstrukt wie <code>echo "Found 42 "$type"s"</code> .  Es ist jedoch am besten, dieses Problem in geschweiften Klammern zu lösen: <code>echo "Found 42 ${type}s"</code> , mit dem wir bash mitteilen können, wo der Variablenname beginnt und endet (interessanterweise wird in JavaScript ES6 dieselbe Syntax zum Einbetten von Variablen verwendet in Ausdrücken in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musterzeichenfolgen</a> ). <br><br>  Nun zurück zu den Arrays.  Es stellt sich heraus, dass geschweifte Klammern normalerweise nicht benötigt werden, wenn mit Variablen gearbeitet wird, sie werden jedoch benötigt, um mit Arrays zu arbeiten.  Mit ihnen können Sie Indizes festlegen, um auf die Elemente des Arrays zuzugreifen.  Beispielsweise gibt ein Befehl der Form <code>echo ${allThreads[1]}</code> das zweite Element des Arrays aus.  Wenn Sie geschweifte Klammern in der obigen Konstruktion vergessen, nimmt bash <code>[1]</code> als Zeichenfolge wahr und verarbeitet, was entsprechend geschieht. <br><br>  Wie Sie sehen können, haben Arrays in Bash eine seltsame Syntax, aber in ihnen beginnt zumindest die Nummerierung der Elemente von vorne.  Dies macht sie ähnlich wie Arrays aus vielen anderen Programmiersprachen. <br><br><h2>  <font color="#3AC1EF">Möglichkeiten, auf Array-Elemente zuzugreifen</font> </h2><br>  Im obigen Beispiel haben wir ganzzahlige Indizes in Arrays verwendet, die explizit angegeben sind.  Betrachten Sie nun zwei weitere Möglichkeiten, um mit Arrays zu arbeiten. <br><br>  Die erste Methode ist anwendbar, wenn wir das <code>$i</code> te Element des Arrays benötigen, wobei <code>$i</code> eine Variable ist, die den Index des gewünschten Array-Elements enthält.  Sie können dieses Element mit einem Konstrukt der Form <code>echo ${allThreads[$i]}</code> aus dem Array extrahieren. <br><br>  Mit der zweiten Methode können Sie alle Elemente des Arrays anzeigen.  Es besteht darin, den numerischen Index durch das <code>@</code> -Symbol zu ersetzen (es kann als Befehl interpretiert werden, der auf alle Elemente des Arrays verweist).  Es sieht so aus: <code>echo ${allThreads[@]}</code> . <br><br><h2>  <font color="#3AC1EF">Iterieren über Array-Elemente in Schleifen</font> </h2><br>  Die obigen Prinzipien der Arbeit mit Array-Elementen sind für uns nützlich, um das Problem der Aufzählung von Array-Elementen zu lösen.  In unserem Fall bedeutet dies, dass der zu untersuchende <code>pipeline</code> Befehl mit jedem der Werte gestartet wird, der die Anzahl der Threads symbolisiert und in einem Array gespeichert ist.  Es sieht so aus: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$t</span></span> done</code> </pre> <br><h2>  <font color="#3AC1EF">Array-Indizes in Schleifen auflisten</font> </h2><br>  Betrachten Sie nun einen etwas anderen Ansatz zum Sortieren von Arrays.  Anstatt über die Elemente zu iterieren, können wir über die Indizes des Arrays iterieren: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{!allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-variable"><span class="hljs-variable">$i</span></span>]} done</code> </pre> <br>  Lassen Sie uns analysieren, was hier passiert.  Wie wir bereits gesehen haben, repräsentiert eine Konstruktion der Form <code>${allThreads[@]}</code> alle Elemente des Arrays.  Wenn wir hier ein Ausrufezeichen <code>${!allThreads[@]}</code> , verwandeln wir dieses Konstrukt in <code>${!allThreads[@]}</code> , was dazu führt, dass die Indizes des Arrays zurückgegeben werden (in unserem Fall von 0 bis 7). <br><br>  Mit anderen Worten, die <code>for</code> Schleife <code>for</code> alle Indizes des als Variable <code>$i</code> dargestellten Arrays, und im Hauptteil der Schleife wird auf die Elemente des Arrays, die als Werte des Parameters <code>--thread</code> dienen, mit dem Konstrukt <code>${allThreads[$i]}</code> <code>--thread</code> . <br><br>  Das Lesen dieses Codes ist schwieriger als im vorherigen Beispiel.  Daher stellt sich die Frage, wofür all diese Schwierigkeiten sind.  Und wir brauchen dies, weil Sie in einigen Situationen bei der Verarbeitung von Arrays in Schleifen sowohl die Indizes als auch die Werte der Elemente kennen müssen.  Wenn Sie beispielsweise das erste Element des Arrays überspringen müssen, erspart uns das Durchlaufen der Indizes beispielsweise die Notwendigkeit, eine zusätzliche Variable zu erstellen und diese in einer Schleife zu erhöhen, um mit Array-Elementen zu arbeiten. <br><br><h2>  <font color="#3AC1EF">Arrays füllen</font> </h2><br>  Bisher haben wir das System untersucht, indem wir den <code>pipeline</code> Befehl <code>--threads</code> und ihm jeden der Werte des Parameters <code>--threads</code> uns interessiert.  Angenommen, dieser Befehl gibt die Dauer eines bestimmten Prozesses in Sekunden an.  Wir möchten die bei jeder Iteration zurückgegebenen Daten abfangen und in einem anderen Array speichern.  Dies gibt uns die Möglichkeit, nach Abschluss aller Tests mit den gespeicherten Daten zu arbeiten. <br><br><h2>  <font color="#3AC1EF">Nützliche Syntaxkonstrukte</font> </h2><br>  Bevor wir uns mit dem Hinzufügen von Daten zu Arrays befassen, schauen wir uns einige nützliche Syntaxkonstrukte an.  Zunächst benötigen wir einen Mechanismus, um Daten zu erhalten, die von Bash-Befehlen ausgegeben werden.  Um die Ausgabe eines Befehls zu erfassen, müssen Sie die folgende Konstruktion verwenden: <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">output</span></span>=$( ./my_script.sh )</code> </pre> <br>  Nach Ausführung dieses Befehls wird die <code>$output</code> <code>myscript.sh</code> in der <code>$output</code> gespeichert. <br><br>  Die zweite Konstruktion, die sehr bald nützlich sein wird, ermöglicht es uns, neue Daten an Arrays anzuhängen.  Es sieht so aus: <br><br><pre> <code class="hljs lisp">myArray+=( <span class="hljs-string"><span class="hljs-string">"newElement1"</span></span> <span class="hljs-string"><span class="hljs-string">"newElement2"</span></span> )</code> </pre> <br><h2>  <font color="#3AC1EF">Problemlösung</font> </h2><br>  Wenn Sie nun alles zusammenstellen, was wir gerade gelernt haben, können Sie ein Skript zum Testen des Systems erstellen, das einen Befehl mit jedem der Parameterwerte aus dem Array ausführt und im anderen Array speichert, was dieser Befehl anzeigt. <br><br><pre> <code class="hljs powershell">allThreads=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span>) allRuntimes=() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> runtime=<span class="hljs-variable"><span class="hljs-variable">$</span></span>(./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$t</span></span>) allRuntimes+=( <span class="hljs-variable"><span class="hljs-variable">$runtime</span></span> ) done</code> </pre> <br><h2>  <font color="#3AC1EF">Was weiter?</font> </h2><br>  Wir haben gerade untersucht, wie Bash-Arrays verwendet werden, um die beim Starten eines Programms verwendeten Parameter zu durchlaufen und die von diesem Programm zurückgegebenen Daten zu speichern.  Die Optionen für die Verwendung von Arrays sind jedoch nicht auf dieses Szenario beschränkt.  Hier noch ein paar Beispiele. <br><br><h2>  <font color="#3AC1EF">Problemwarnungen</font> </h2><br>  In diesem Szenario betrachten wir eine Anwendung, die in Module unterteilt ist.  Jedes dieser Module verfügt über eine eigene Protokolldatei.  Wir können ein <code>cron</code> Job-Skript schreiben, das bei Problemen in der entsprechenden Protokolldatei die Person, die für jedes der Module verantwortlich ist, per E-Mail benachrichtigt: <br><br><pre> <code class="hljs kotlin">#  -    logPaths=(<span class="hljs-string"><span class="hljs-string">"api.log"</span></span> <span class="hljs-string"><span class="hljs-string">"auth.log"</span></span> <span class="hljs-string"><span class="hljs-string">"jenkins.log"</span></span> <span class="hljs-string"><span class="hljs-string">"data.log"</span></span>) logEmails=(<span class="hljs-string"><span class="hljs-string">"jay@email"</span></span> <span class="hljs-string"><span class="hljs-string">"emma@email"</span></span> <span class="hljs-string"><span class="hljs-string">"jon@email"</span></span> <span class="hljs-string"><span class="hljs-string">"sophia@email"</span></span>) #         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ${!logPaths[@]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> log=${logPaths[$i]} stakeholder=${logEmails[$i]} numErrors=$( tail -n <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$log</span></span></span><span class="hljs-string">"</span></span> | grep <span class="hljs-string"><span class="hljs-string">"ERROR"</span></span> | wc -l ) #       <span class="hljs-number"><span class="hljs-number">5</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$numErrors</span></span></span><span class="hljs-string">"</span></span> -gt <span class="hljs-number"><span class="hljs-number">5</span></span> ]]; then   emailRecipient=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$stakeholder</span></span></span><span class="hljs-string">"</span></span>   emailSubject=<span class="hljs-string"><span class="hljs-string">"WARNING: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${log}</span></span></span><span class="hljs-string"> showing unusual levels of errors"</span></span>   emailBody=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${numErrors}</span></span></span><span class="hljs-string"> errors found in log </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${log}</span></span></span><span class="hljs-string">"</span></span>   echo <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailBody</span></span></span><span class="hljs-string">"</span></span> | mailx -s <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailSubject</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailRecipient</span></span></span><span class="hljs-string">"</span></span> fi done</code> </pre> <br><h2>  <font color="#3AC1EF">API-Anfragen</font> </h2><br>  Angenommen, Sie möchten Informationen darüber sammeln, welche Benutzer Ihre Beiträge auf Medium kommentieren.  Da wir keinen direkten Zugriff auf die Datenbank dieser Site haben, werden SQL-Abfragen nicht behandelt.  Sie können jedoch verschiedene APIs verwenden, um auf diese Art von Daten zuzugreifen. <br><br>  Um lange Gespräche über Authentifizierung und Token zu vermeiden, verwenden wir als Endpunkt den öffentlichen API- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testdienst JSONPlaceholder</a> .  Nachdem wir eine Veröffentlichung vom Dienst erhalten und Daten aus seinem Code an den E-Mail-Adressen der Kommentatoren extrahiert haben, können wir diese Daten in ein Array einfügen: <br><br><pre> <code class="hljs kotlin">endpoint=<span class="hljs-string"><span class="hljs-string">"https://jsonplaceholder.typicode.com/comments"</span></span> allEmails=() #   <span class="hljs-number"><span class="hljs-number">10</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> postId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> #    API       response=$(curl <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${endpoint}</span></span></span><span class="hljs-string">?postId=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${postId}</span></span></span><span class="hljs-string">"</span></span>) #  jq   JSON       allEmails+=( $( jq <span class="hljs-string"><span class="hljs-string">'.[].email'</span></span> &lt;&lt;&lt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$response</span></span></span><span class="hljs-string">"</span></span> ) ) done</code> </pre> <br>  Bitte beachten Sie, dass hier das Tool <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jq</a> verwendet wird, mit dem JSON in der Befehlszeile analysiert werden kann.  Wir werden nicht näher auf die Arbeit mit jq eingehen, wenn Sie an diesem Tool interessiert sind - siehe die Dokumentation dazu. <br><br><h2>  <font color="#3AC1EF">Bash oder Python?</font> </h2><br>  Arrays - eine nützliche Funktion, die nicht nur in Bash verfügbar ist.  Derjenige, der Skripte für die Befehlszeile schreibt, hat möglicherweise eine logische Frage, in welchen Situationen es sich lohnt, bash zu verwenden, und in welchen beispielsweise Python. <br><br>  Meiner Meinung nach liegt die Antwort auf diese Frage darin, wie sehr der Programmierer von einer bestimmten Technologie abhängt.  Angenommen, wenn das Problem direkt in der Befehlszeile gelöst werden kann, verhindert nichts die Verwendung von Bash.  Für den Fall, dass beispielsweise das Skript, an dem Sie interessiert sind, Teil eines in Python geschriebenen Projekts ist, können Sie Python gut verwenden. <br><br>  Um das hier betrachtete Problem zu lösen, können Sie beispielsweise ein in Python geschriebenes Skript verwenden. Dies führt jedoch dazu, dass Wrapper für Python-Wrapper für bash geschrieben werden: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess all_threads = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>] all_runtimes = [] #         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_threads: cmd = <span class="hljs-string"><span class="hljs-string">'./pipeline --threads {}'</span></span>.format(t) #   subprocess   ,    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) output = p.communicate()[<span class="hljs-number"><span class="hljs-number">0</span></span>] all_runtimes.append(output)</code> </pre> <br>  Vielleicht ist die Lösung für dieses Problem mit Bash ohne andere Technologien kürzer und verständlicher, und hier können Sie ganz auf Python verzichten. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Material haben wir viele Designs analysiert, die für die Arbeit mit Arrays verwendet wurden.  Hier ist eine Tabelle, in der Sie finden, was wir überprüft haben und etwas Neues. <br><table><tbody><tr><td>  Syntaxkonstrukt </td><td>  Beschreibung </td></tr><tr><td> <code>arr=()</code> </td> <td>  Erstellen Sie ein leeres Array </td></tr><tr><td> <code>arr=(1 2 3)</code> </td> <td>  Array-Initialisierung </td></tr><tr><td> <code>${arr[2]}</code> </td> <td>  Das dritte Element eines Arrays abrufen </td></tr><tr><td> <code>${arr[@]}</code> </td> <td>  Alle Array-Elemente abrufen </td></tr><tr><td> <code>${!arr[@]}</code> </td> <td>  Array-Indizes abrufen </td></tr><tr><td> <code>${#arr[@]}</code> </td> <td>  Berechnung der Arraygröße </td></tr><tr><td> <code>arr[0]=3</code> </td> <td>  Überschreiben des ersten Elements eines Arrays </td></tr><tr><td> <code>arr+=(4)</code> </td> <td>  Verbinden eines Array von Werten </td></tr><tr><td> <code>str=$(ls)</code> </td> <td>  Speichern der <code>ls</code> als Zeichenfolge </td></tr><tr><td> <code>arr=( $(ls) )</code> </td> <td>  Speichern der Ausgabe des <code>ls</code> als Array von Dateinamen </td></tr><tr><td> <code>${arr[@]:s:n}</code> </td> <td>  Abrufen von Array-Elementen vom Element mit dem Index <code>s</code> zum Element mit dem Index <code>s+(n-1)</code> <br></td></tr></tbody></table><br>  Auf den ersten Blick mögen Bash-Arrays ziemlich seltsam erscheinen, aber die Möglichkeiten, die sie bieten, sind es wert, mit diesen Kuriositäten umzugehen.  Wir glauben, dass Sie Bash-Arrays, wenn Sie sie beherrschen, ziemlich oft verwenden werden.  Es ist leicht vorstellbar, dass unzählige Szenarien nützlich sein können. <br><br>  <b>Liebe Leser!</b>  Wenn Sie interessante Beispiele für die Verwendung von Arrays in Bash-Skripten haben, teilen Sie diese bitte mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413725/">https://habr.com/ru/post/de413725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413715/index.html">IT-Altersrente</a></li>
<li><a href="../de413717/index.html">GraphQL für InterSystems-Plattformen</a></li>
<li><a href="../de413719/index.html">C ++ 20 unterwegs! Treffen bei Rapperswil Yona</a></li>
<li><a href="../de413721/index.html">Zeitcheck: Timejacking gegen Bitcoin</a></li>
<li><a href="../de413723/index.html">Saga der elektronischen Dienste und ihrer Standorte. Teil 2. Elektronischer Schrank</a></li>
<li><a href="../de413729/index.html">Wie und warum haben wir unser ECS geschrieben?</a></li>
<li><a href="../de413731/index.html">BA / SA Arbeitsmarktforschung</a></li>
<li><a href="../de413733/index.html">Mikrosh, Krista, Apogee, Lviv - die ersten sowjetischen Computer zum Mitnehmen</a></li>
<li><a href="../de413739/index.html">Wie wir das gesamte Internet gescannt haben und was wir gelernt haben</a></li>
<li><a href="../de413741/index.html">Was es war und wie: Eindrücke des WWDC Redmadrobot-Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>