<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿 👌 🤹🏾 Vereinfachen Sie Ihren Code mit Rocket Science: C ++ 20s Raumschiff-Operator 🍧 🏢 🚡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 fügt einen neuen Operator hinzu, der liebevoll als "Raumschiff" -Operator bezeichnet wird: <=> . Vor einiger Zeit gab es einen Beitrag von uns...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vereinfachen Sie Ihren Code mit Rocket Science: C ++ 20s Raumschiff-Operator</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> C ++ 20 fügt einen neuen Operator hinzu, der liebevoll als "Raumschiff" -Operator bezeichnet wird: <code>&lt;=&gt;</code> .  Vor einiger Zeit gab es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> von unserem eigenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simon Brand,</a> in dem einige Informationen zu diesem neuen Operator sowie einige konzeptionelle Informationen darüber, was er ist und tut, aufgeführt sind.  Das Ziel dieses Beitrags ist es, einige konkrete Anwendungen dieses seltsamen neuen Operators und seines zugehörigen Gegenstücks, des <code>operator==</code> (ja, es wurde zum Besseren geändert!) Zu untersuchen und gleichzeitig einige Richtlinien für die Verwendung im alltäglichen Code bereitzustellen. <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2>  Vergleiche </h2><br>  Es ist nicht ungewöhnlich, Code wie den folgenden zu sehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Hinweis: Leser mit Adleraugen werden feststellen, dass dies sogar noch weniger ausführlich ist als im Code vor C ++ 20, da diese Funktionen eigentlich alle Freunde von Nichtmitgliedern sein sollten, dazu später mehr.</i> <br><br>  Das ist eine Menge Code, den man schreiben muss, um sicherzustellen, dass mein Typ mit etwas vom gleichen Typ vergleichbar ist.  Okay, wir beschäftigen uns eine Weile damit.  Dann kommt jemand, der dies schreibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Das erste, was Sie bemerken werden, ist, dass dieses Programm nicht kompiliert wird. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Ah!  Das Problem ist, dass wir <code>constexpr</code> für unsere Vergleichsfunktion vergessen <code>constexpr</code> , drat!  Also fügt man allen Vergleichsoperatoren <code>constexpr</code> hinzu.  Ein paar Tage später fügt jemand einen <code>is_gt</code> Helfer hinzu, <code>is_gt</code> jedoch fest, dass alle Vergleichsoperatoren keine Ausnahmespezifikation haben, und durchläuft denselben mühsamen Prozess, <code>noexcept</code> dem jeder der 5 Überladungen <code>noexcept</code> hinzugefügt wird. <br><br>  Hier setzt der neue Raumschiff-Operator von C ++ 20 an, um uns zu helfen.  Mal sehen, wie der ursprüngliche <code>IntWrapper</code> in einer C ++ 20-Welt geschrieben werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Der erste Unterschied, den Sie möglicherweise bemerken, ist die neue Aufnahme von <code>&lt;compare&gt;</code> .  Der <code>&lt;compare&gt;</code> -Header ist dafür verantwortlich, den Compiler mit allen Vergleichskategorietypen zu füllen, die der Raumschiffoperator benötigt, um einen für unsere Standardfunktion geeigneten Typ zurückzugeben.  Im obigen Snippet wird der Rückgabetyp <code>auto</code> zu <code>std::strong_ordering</code> . <br><br>  Wir haben nicht nur 5 überflüssige Zeilen entfernt, sondern müssen auch nichts definieren, der Compiler erledigt das für uns!  Unser <code>is_lt</code> bleibt unverändert und funktioniert nur, während es noch <code>constexpr</code> , obwohl wir dies in unserem Standardoperator <code>operator&lt;=&gt;</code> nicht explizit angegeben haben.  Das ist gut und schön, aber einige Leute kratzen sich vielleicht am Kopf, warum <code>is_lt</code> immer noch kompilieren darf, obwohl der Raumschiffoperator überhaupt nicht verwendet wird.  Lassen Sie uns die Antwort auf diese Frage untersuchen. <br><br><h2>  Ausdrücke umschreiben </h2><br>  In C ++ 20 wird dem Compiler ein neues Konzept vorgestellt, das sich auf "umgeschriebene" Ausdrücke bezieht.  Der Raumschiffoperator gehört zusammen mit dem <code>operator==</code> zu den ersten beiden Kandidaten, für die umgeschriebene Ausdrücke gelten.  Für ein konkreteres Beispiel für das Umschreiben von Ausdrücken wollen wir das in <code>is_lt</code> bereitgestellte Beispiel <code>is_lt</code> . <br><br>  Während der Überlastungsauflösung wählt der Compiler aus einer Reihe brauchbarer Kandidaten aus, die alle dem gesuchten Operator entsprechen.  Der Kandidatensammelprozess wird für relationale und Äquivalenzoperationen geringfügig geändert, bei denen der Compiler auch spezielle umgeschriebene und synthetisierte Kandidaten sammeln muss ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Für unseren Ausdruck <code>a &lt; b</code> der Standard an, dass wir den Typ a nach einem <code>operator&lt;=&gt;</code> oder einem Namespace-Bereichsfunktionsoperator <code>operator&lt;=&gt;</code> durchsuchen können, der seinen Typ akzeptiert.  Der Compiler stellt also fest, dass der Typ von a <code>IntWrapper::operator&lt;=&gt;</code> .  Der Compiler darf dann diesen Operator verwenden und den Ausdruck <code>a &lt; b</code> als <code>(a &lt;=&gt; b) &lt; 0</code> umschreiben.  Dieser umgeschriebene Ausdruck wird dann als Kandidat für eine normale Überlastungsauflösung verwendet. <br><br>  Möglicherweise fragen Sie sich, warum dieser umgeschriebene Ausdruck gültig und korrekt ist.  Die Richtigkeit des Ausdrucks ergibt sich tatsächlich aus der Semantik, die der Raumschiffoperator bereitstellt.  Das <code>&lt;=&gt;</code> ist ein Drei-Wege-Vergleich, der impliziert, dass Sie nicht nur ein binäres Ergebnis, sondern (in den meisten Fällen) eine Reihenfolge erhalten. Wenn Sie eine Reihenfolge haben, können Sie diese Reihenfolge in Form von relationalen Operationen ausdrücken.  Ein kurzes Beispiel: Der Ausdruck 4 &lt;=&gt; 5 in C ++ 20 gibt Ihnen das Ergebnis <code>std::strong_ordering::less</code> .  Das Ergebnis <code>std::strong_ordering::less</code> impliziert, dass <code>4</code> nicht nur von <code>5</code> verschieden ist, sondern strikt unter diesem Wert liegt. Dies macht die Anwendung der Operation <code>(4 &lt;=&gt; 5) &lt; 0</code> korrekt und genau, um unser Ergebnis zu beschreiben. <br><br>  Unter Verwendung der obigen Informationen kann der Compiler jeden verallgemeinerten relationalen Operator (dh <code>&lt;</code> , <code>&gt;</code> usw.) nehmen und ihn in Bezug auf den Raumschiffoperator umschreiben.  Im Standard wird der umgeschriebene Ausdruck häufig als <code>(a &lt;=&gt; b) @ 0</code> wobei das <code>@</code> eine relationale Operation darstellt. <br><br><h2>  Ausdrücke synthetisieren </h2><br>  Die Leser haben möglicherweise die subtile Erwähnung von "synthetisierten" Ausdrücken oben bemerkt und spielen auch eine Rolle bei diesem Umschreibungsprozess des Operators.  Betrachten Sie eine andere Prädikatfunktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Wenn wir unsere ursprüngliche Definition für <code>IntWrapper</code> dieser Code nicht kompiliert. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Dies ist in Land vor C ++ 20 <code>IntWrapper</code> dieses Problem zu lösen, müssen Sie <code>IntWrapper</code> einige zusätzliche <code>friend</code> Funktionen <code>IntWrapper</code> die sich auf der linken Seite von <code>int</code> .  Wenn Sie versuchen, dieses Beispiel mit einem C ++ 20-Compiler und unserer C ++ 20-Definition von <code>IntWrapper</code> Sie möglicherweise feststellen, dass es wieder „einfach funktioniert“ - ein weiterer Head Scratcher.  Lassen Sie uns untersuchen, warum der obige Code in C ++ 20 noch kompiliert werden darf. <br><br>  Während der Überlastungsauflösung sammelt der Compiler auch das, was der Standard als "synthetisierte" Kandidaten bezeichnet, oder einen umgeschriebenen Ausdruck mit umgekehrter Reihenfolge der Parameter.  Im obigen Beispiel versucht der Compiler, den umgeschriebenen Ausdruck <code>(42 &lt;=&gt; a) &lt; 0</code> , stellt jedoch fest, dass keine Konvertierung von <code>IntWrapper</code> nach <code>int</code> , um die linke Seite zu erfüllen, sodass der umgeschriebene Ausdruck gelöscht wird.  Der Compiler zaubert auch den "synthetisierten" Ausdruck <code>0 &lt; (a &lt;=&gt; 42)</code> und stellt fest, dass über seinen Konvertierungskonstruktor eine Konvertierung von <code>int</code> nach <code>IntWrapper</code> , sodass dieser Kandidat verwendet wird. <br><br>  Das Ziel der synthetisierten Ausdrücke ist es, das Durcheinander zu vermeiden, dass das Boilerplate der <code>friend</code> Funktionen geschrieben werden muss, um Lücken zu füllen, in denen Ihr Objekt von anderen Typen konvertiert werden könnte.  Synthetisierte Ausdrücke werden auf <code>0 @ (b &lt;=&gt; a)</code> verallgemeinert. <br><br><h2>  Komplexere Typen </h2><br>  Der vom Compiler generierte Raumschiffoperator stoppt nicht bei einzelnen Mitgliedern von Klassen, sondern generiert einen korrekten Satz von Vergleichen für alle Unterobjekte in Ihren Typen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Der Compiler weiß, wie Mitglieder von Klassen, die Arrays sind, in ihre Listen von Unterobjekten erweitert und rekursiv verglichen werden.  Wenn Sie die Körper dieser Funktionen selbst schreiben möchten, haben Sie natürlich immer noch den Vorteil, dass der Compiler Ausdrücke für Sie neu schreibt. <br><br><h2>  Sieht aus wie eine Ente, schwimmt wie eine Ente und quakt wie <code>operator==</code> </h2><br>  Einige sehr kluge Leute im Standardisierungskomitee bemerkten, dass der Raumschiffbetreiber immer einen lexikografischen Vergleich von Elementen durchführen wird, egal was passiert.  Die bedingungslose Durchführung lexikografischer Vergleiche kann insbesondere mit dem Gleichheitsoperator zu ineffizientem generiertem Code führen. <br><br>  Das kanonische Beispiel vergleicht zwei Zeichenfolgen.  Wenn Sie die Zeichenfolge <code>"foobar"</code> und sie mit == mit der Zeichenfolge <code>"foo"</code> , würde man erwarten, dass diese Operation nahezu konstant ist.  Der effiziente String-Vergleichsalgorithmus lautet also: <br><br><ul><li>  Vergleichen Sie zuerst die Größe der beiden Zeichenfolgen, wenn sich die Größen unterscheiden, geben Sie andernfalls <code>false</code> </li><li>  Gehen Sie jedes Element der beiden Zeichenfolgen gemeinsam durch und vergleichen Sie es, bis sich eines unterscheidet oder das Ende erreicht ist. Geben Sie das Ergebnis zurück. </li></ul><br>  Nach den Regeln für Raumschiffoperatoren müssen wir zuerst mit dem tiefen Vergleich jedes Elements beginnen, bis wir das andere finden.  In unserem Beispiel von <code>"foobar"</code> und <code>"foo"</code> nur dann <code>false</code> wenn Sie <code>'b'</code> mit <code>'\0'</code> . <br><br>  Um dem entgegenzuwirken, gab es ein Papier, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1185R2,</a> das eine Möglichkeit für den Compiler beschreibt, <code>operator==</code> unabhängig vom Raumschiffoperator neu zu schreiben und zu generieren.  Unser <code>IntWrapper</code> könnte wie folgt geschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Nur noch ein Schritt ... es gibt jedoch gute Nachrichten;  Sie müssen den obigen Code nicht wirklich schreiben, da das einfache Schreiben des <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> ausreicht, damit der Compiler implizit den separaten - und effizienteren - <code>operator==</code> für Sie generiert! <br><br>  Der Compiler wendet eine leicht geänderte Regel zum Umschreiben an, die für <code>==</code> und <code>!=</code> Speziell ist. Dabei werden in diesen Operatoren <code>operator==</code> und nicht <code>operator&lt;=&gt;</code> umgeschrieben.  Dies bedeutet, dass <code>!=</code> Auch von der Optimierung profitiert. <br><br><h2>  Alter Code wird nicht brechen </h2><br>  An diesem Punkt könnten Sie denken, OK, wenn der Compiler dieses Operator-Umschreibungsgeschäft ausführen darf, was passiert, wenn ich versuche, den Compiler zu überlisten: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  Die Antwort hier ist, dass Sie es nicht getan haben.  Das Überlastungsauflösungsmodell in C ++ hat diese Arena, in der alle Kandidaten kämpfen, und in diesem speziellen Kampf haben wir 3 Kandidaten: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (umgeschrieben) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (synthetisiert) <br><br>  Wenn wir die Überlastungsauflösungsregeln in C ++ 17 akzeptiert hätten, wäre das Ergebnis dieses Aufrufs nicht eindeutig gewesen, aber die C ++ 20-Überlastungsauflösungsregeln wurden geändert, damit der Compiler diese Situation auf die logischste Überladung auflösen kann. <br><br>  Es gibt eine Phase der Überlastungsauflösung, in der der Compiler einen Serien-Tiebreaker ausführen muss.  In C ++ 20 gibt es einen neuen Tiebreaker, der besagt, dass wir Überladungen bevorzugen müssen, die nicht neu geschrieben oder synthetisiert werden. Dies macht unseren Überlastungs- <code>IntWrapper::operator&lt;</code> zum besten Kandidaten und löst die Mehrdeutigkeit.  Dieselbe Maschinerie verhindert, dass synthetisierte Kandidaten auf reguläre umgeschriebene Ausdrücke stampfen. <br><br><h2>  Gedanken schließen </h2><br>  Der Raumschiff-Operator ist eine willkommene Ergänzung zu C ++ und eine der Funktionen, die es Ihnen erleichtern und Ihnen helfen, <i>weniger</i> Code zu schreiben, und manchmal ist weniger mehr.  Schnallen Sie sich also mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raumschiff-</a> Operator von C ++ 20 an! <br><br>  Wir empfehlen Ihnen dringend, den Raumschiff-Operator auszuprobieren. Er ist ab sofort in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio 2019</a> unter <code>/std:c++latest</code> verfügbar.  Hinweis: Die durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1185R2</a> eingeführten Änderungen sind in Visual Studio 2019 Version 16.2 verfügbar.  Bitte beachten Sie, dass der Raumschiffoperator Teil von C ++ 20 ist und bis zu dem Zeitpunkt, an dem C ++ 20 abgeschlossen ist, einigen Änderungen unterworfen ist. <br><br>  Wie immer freuen wir uns über Ihr Feedback.  Sie können Kommentare per E-Mail an <a href="">visualcpp@microsoft.com</a> , über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter @visualc</a> oder Facebook an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Visual Cpp senden</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folgen Sie</a> mir auch auf Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@starfreakclone</a> . <br><br>  Wenn Sie in VS 2019 auf andere Probleme mit MSVC stoßen, teilen Sie uns dies bitte über die Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> melden mit, entweder vom Installationsprogramm oder von der Visual Studio-IDE selbst.  Für Vorschläge oder Fehlerberichte lassen Sie es uns über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevComm</a> wissen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458248/">https://habr.com/ru/post/de458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458230/index.html">Wie KI, Drohnen und Kameras unsere Straßen und Brücken schützen</a></li>
<li><a href="../de458240/index.html">Wie künstliche Intelligenz, Drohnen und Kameras die Sicherheit von Straßen und Brücken gewährleisten</a></li>
<li><a href="../de458242/index.html">Der neue Raumschiffoperator in C ++ 20</a></li>
<li><a href="../de458244/index.html">Eine endlose und lächerliche Liste dessen, was Sie wissen müssen, um öffentliche Wi-Fi-Netzwerke sicher nutzen zu können</a></li>
<li><a href="../de458246/index.html">Zufällige Zufälle im Leben oder wie sich herausstellte, dass Ihnen in einer Traktorenfabrik ein Kuchen präsentiert wurde</a></li>
<li><a href="../de458250/index.html">BTRFS für die Kleinsten</a></li>
<li><a href="../de458252/index.html">Mathematisches Modell eines superlangen Radioteleskops</a></li>
<li><a href="../de458256/index.html">Ist es nicht Zeit für eine Gehirnwäsche?</a></li>
<li><a href="../de458260/index.html">Eine andere Möglichkeit, Docker-Images für Java-Anwendungen zu optimieren</a></li>
<li><a href="../de458262/index.html">Online-Designer des Besprechungsraums - Auswahl der optimalen Lösung für die Videokonferenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>