<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø üëå ü§πüèæ Vereinfachen Sie Ihren Code mit Rocket Science: C ++ 20s Raumschiff-Operator üçß üè¢ üö°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 f√ºgt einen neuen Operator hinzu, der liebevoll als "Raumschiff" -Operator bezeichnet wird: <=> . Vor einiger Zeit gab es einen Beitrag von uns...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vereinfachen Sie Ihren Code mit Rocket Science: C ++ 20s Raumschiff-Operator</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> C ++ 20 f√ºgt einen neuen Operator hinzu, der liebevoll als "Raumschiff" -Operator bezeichnet wird: <code>&lt;=&gt;</code> .  Vor einiger Zeit gab es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> von unserem eigenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simon Brand,</a> in dem einige Informationen zu diesem neuen Operator sowie einige konzeptionelle Informationen dar√ºber, was er ist und tut, aufgef√ºhrt sind.  Das Ziel dieses Beitrags ist es, einige konkrete Anwendungen dieses seltsamen neuen Operators und seines zugeh√∂rigen Gegenst√ºcks, des <code>operator==</code> (ja, es wurde zum Besseren ge√§ndert!) Zu untersuchen und gleichzeitig einige Richtlinien f√ºr die Verwendung im allt√§glichen Code bereitzustellen. <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2>  Vergleiche </h2><br>  Es ist nicht ungew√∂hnlich, Code wie den folgenden zu sehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Hinweis: Leser mit Adleraugen werden feststellen, dass dies sogar noch weniger ausf√ºhrlich ist als im Code vor C ++ 20, da diese Funktionen eigentlich alle Freunde von Nichtmitgliedern sein sollten, dazu sp√§ter mehr.</i> <br><br>  Das ist eine Menge Code, den man schreiben muss, um sicherzustellen, dass mein Typ mit etwas vom gleichen Typ vergleichbar ist.  Okay, wir besch√§ftigen uns eine Weile damit.  Dann kommt jemand, der dies schreibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Das erste, was Sie bemerken werden, ist, dass dieses Programm nicht kompiliert wird. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Ah!  Das Problem ist, dass wir <code>constexpr</code> f√ºr unsere Vergleichsfunktion vergessen <code>constexpr</code> , drat!  Also f√ºgt man allen Vergleichsoperatoren <code>constexpr</code> hinzu.  Ein paar Tage sp√§ter f√ºgt jemand einen <code>is_gt</code> Helfer hinzu, <code>is_gt</code> jedoch fest, dass alle Vergleichsoperatoren keine Ausnahmespezifikation haben, und durchl√§uft denselben m√ºhsamen Prozess, <code>noexcept</code> dem jeder der 5 √úberladungen <code>noexcept</code> hinzugef√ºgt wird. <br><br>  Hier setzt der neue Raumschiff-Operator von C ++ 20 an, um uns zu helfen.  Mal sehen, wie der urspr√ºngliche <code>IntWrapper</code> in einer C ++ 20-Welt geschrieben werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Der erste Unterschied, den Sie m√∂glicherweise bemerken, ist die neue Aufnahme von <code>&lt;compare&gt;</code> .  Der <code>&lt;compare&gt;</code> -Header ist daf√ºr verantwortlich, den Compiler mit allen Vergleichskategorietypen zu f√ºllen, die der Raumschiffoperator ben√∂tigt, um einen f√ºr unsere Standardfunktion geeigneten Typ zur√ºckzugeben.  Im obigen Snippet wird der R√ºckgabetyp <code>auto</code> zu <code>std::strong_ordering</code> . <br><br>  Wir haben nicht nur 5 √ºberfl√ºssige Zeilen entfernt, sondern m√ºssen auch nichts definieren, der Compiler erledigt das f√ºr uns!  Unser <code>is_lt</code> bleibt unver√§ndert und funktioniert nur, w√§hrend es noch <code>constexpr</code> , obwohl wir dies in unserem Standardoperator <code>operator&lt;=&gt;</code> nicht explizit angegeben haben.  Das ist gut und sch√∂n, aber einige Leute kratzen sich vielleicht am Kopf, warum <code>is_lt</code> immer noch kompilieren darf, obwohl der Raumschiffoperator √ºberhaupt nicht verwendet wird.  Lassen Sie uns die Antwort auf diese Frage untersuchen. <br><br><h2>  Ausdr√ºcke umschreiben </h2><br>  In C ++ 20 wird dem Compiler ein neues Konzept vorgestellt, das sich auf "umgeschriebene" Ausdr√ºcke bezieht.  Der Raumschiffoperator geh√∂rt zusammen mit dem <code>operator==</code> zu den ersten beiden Kandidaten, f√ºr die umgeschriebene Ausdr√ºcke gelten.  F√ºr ein konkreteres Beispiel f√ºr das Umschreiben von Ausdr√ºcken wollen wir das in <code>is_lt</code> bereitgestellte Beispiel <code>is_lt</code> . <br><br>  W√§hrend der √úberlastungsaufl√∂sung w√§hlt der Compiler aus einer Reihe brauchbarer Kandidaten aus, die alle dem gesuchten Operator entsprechen.  Der Kandidatensammelprozess wird f√ºr relationale und √Ñquivalenzoperationen geringf√ºgig ge√§ndert, bei denen der Compiler auch spezielle umgeschriebene und synthetisierte Kandidaten sammeln muss ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  F√ºr unseren Ausdruck <code>a &lt; b</code> der Standard an, dass wir den Typ a nach einem <code>operator&lt;=&gt;</code> oder einem Namespace-Bereichsfunktionsoperator <code>operator&lt;=&gt;</code> durchsuchen k√∂nnen, der seinen Typ akzeptiert.  Der Compiler stellt also fest, dass der Typ von a <code>IntWrapper::operator&lt;=&gt;</code> .  Der Compiler darf dann diesen Operator verwenden und den Ausdruck <code>a &lt; b</code> als <code>(a &lt;=&gt; b) &lt; 0</code> umschreiben.  Dieser umgeschriebene Ausdruck wird dann als Kandidat f√ºr eine normale √úberlastungsaufl√∂sung verwendet. <br><br>  M√∂glicherweise fragen Sie sich, warum dieser umgeschriebene Ausdruck g√ºltig und korrekt ist.  Die Richtigkeit des Ausdrucks ergibt sich tats√§chlich aus der Semantik, die der Raumschiffoperator bereitstellt.  Das <code>&lt;=&gt;</code> ist ein Drei-Wege-Vergleich, der impliziert, dass Sie nicht nur ein bin√§res Ergebnis, sondern (in den meisten F√§llen) eine Reihenfolge erhalten. Wenn Sie eine Reihenfolge haben, k√∂nnen Sie diese Reihenfolge in Form von relationalen Operationen ausdr√ºcken.  Ein kurzes Beispiel: Der Ausdruck 4 &lt;=&gt; 5 in C ++ 20 gibt Ihnen das Ergebnis <code>std::strong_ordering::less</code> .  Das Ergebnis <code>std::strong_ordering::less</code> impliziert, dass <code>4</code> nicht nur von <code>5</code> verschieden ist, sondern strikt unter diesem Wert liegt. Dies macht die Anwendung der Operation <code>(4 &lt;=&gt; 5) &lt; 0</code> korrekt und genau, um unser Ergebnis zu beschreiben. <br><br>  Unter Verwendung der obigen Informationen kann der Compiler jeden verallgemeinerten relationalen Operator (dh <code>&lt;</code> , <code>&gt;</code> usw.) nehmen und ihn in Bezug auf den Raumschiffoperator umschreiben.  Im Standard wird der umgeschriebene Ausdruck h√§ufig als <code>(a &lt;=&gt; b) @ 0</code> wobei das <code>@</code> eine relationale Operation darstellt. <br><br><h2>  Ausdr√ºcke synthetisieren </h2><br>  Die Leser haben m√∂glicherweise die subtile Erw√§hnung von "synthetisierten" Ausdr√ºcken oben bemerkt und spielen auch eine Rolle bei diesem Umschreibungsprozess des Operators.  Betrachten Sie eine andere Pr√§dikatfunktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Wenn wir unsere urspr√ºngliche Definition f√ºr <code>IntWrapper</code> dieser Code nicht kompiliert. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Dies ist in Land vor C ++ 20 <code>IntWrapper</code> dieses Problem zu l√∂sen, m√ºssen Sie <code>IntWrapper</code> einige zus√§tzliche <code>friend</code> Funktionen <code>IntWrapper</code> die sich auf der linken Seite von <code>int</code> .  Wenn Sie versuchen, dieses Beispiel mit einem C ++ 20-Compiler und unserer C ++ 20-Definition von <code>IntWrapper</code> Sie m√∂glicherweise feststellen, dass es wieder ‚Äûeinfach funktioniert‚Äú - ein weiterer Head Scratcher.  Lassen Sie uns untersuchen, warum der obige Code in C ++ 20 noch kompiliert werden darf. <br><br>  W√§hrend der √úberlastungsaufl√∂sung sammelt der Compiler auch das, was der Standard als "synthetisierte" Kandidaten bezeichnet, oder einen umgeschriebenen Ausdruck mit umgekehrter Reihenfolge der Parameter.  Im obigen Beispiel versucht der Compiler, den umgeschriebenen Ausdruck <code>(42 &lt;=&gt; a) &lt; 0</code> , stellt jedoch fest, dass keine Konvertierung von <code>IntWrapper</code> nach <code>int</code> , um die linke Seite zu erf√ºllen, sodass der umgeschriebene Ausdruck gel√∂scht wird.  Der Compiler zaubert auch den "synthetisierten" Ausdruck <code>0 &lt; (a &lt;=&gt; 42)</code> und stellt fest, dass √ºber seinen Konvertierungskonstruktor eine Konvertierung von <code>int</code> nach <code>IntWrapper</code> , sodass dieser Kandidat verwendet wird. <br><br>  Das Ziel der synthetisierten Ausdr√ºcke ist es, das Durcheinander zu vermeiden, dass das Boilerplate der <code>friend</code> Funktionen geschrieben werden muss, um L√ºcken zu f√ºllen, in denen Ihr Objekt von anderen Typen konvertiert werden k√∂nnte.  Synthetisierte Ausdr√ºcke werden auf <code>0 @ (b &lt;=&gt; a)</code> verallgemeinert. <br><br><h2>  Komplexere Typen </h2><br>  Der vom Compiler generierte Raumschiffoperator stoppt nicht bei einzelnen Mitgliedern von Klassen, sondern generiert einen korrekten Satz von Vergleichen f√ºr alle Unterobjekte in Ihren Typen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Der Compiler wei√ü, wie Mitglieder von Klassen, die Arrays sind, in ihre Listen von Unterobjekten erweitert und rekursiv verglichen werden.  Wenn Sie die K√∂rper dieser Funktionen selbst schreiben m√∂chten, haben Sie nat√ºrlich immer noch den Vorteil, dass der Compiler Ausdr√ºcke f√ºr Sie neu schreibt. <br><br><h2>  Sieht aus wie eine Ente, schwimmt wie eine Ente und quakt wie <code>operator==</code> </h2><br>  Einige sehr kluge Leute im Standardisierungskomitee bemerkten, dass der Raumschiffbetreiber immer einen lexikografischen Vergleich von Elementen durchf√ºhren wird, egal was passiert.  Die bedingungslose Durchf√ºhrung lexikografischer Vergleiche kann insbesondere mit dem Gleichheitsoperator zu ineffizientem generiertem Code f√ºhren. <br><br>  Das kanonische Beispiel vergleicht zwei Zeichenfolgen.  Wenn Sie die Zeichenfolge <code>"foobar"</code> und sie mit == mit der Zeichenfolge <code>"foo"</code> , w√ºrde man erwarten, dass diese Operation nahezu konstant ist.  Der effiziente String-Vergleichsalgorithmus lautet also: <br><br><ul><li>  Vergleichen Sie zuerst die Gr√∂√üe der beiden Zeichenfolgen, wenn sich die Gr√∂√üen unterscheiden, geben Sie andernfalls <code>false</code> </li><li>  Gehen Sie jedes Element der beiden Zeichenfolgen gemeinsam durch und vergleichen Sie es, bis sich eines unterscheidet oder das Ende erreicht ist. Geben Sie das Ergebnis zur√ºck. </li></ul><br>  Nach den Regeln f√ºr Raumschiffoperatoren m√ºssen wir zuerst mit dem tiefen Vergleich jedes Elements beginnen, bis wir das andere finden.  In unserem Beispiel von <code>"foobar"</code> und <code>"foo"</code> nur dann <code>false</code> wenn Sie <code>'b'</code> mit <code>'\0'</code> . <br><br>  Um dem entgegenzuwirken, gab es ein Papier, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1185R2,</a> das eine M√∂glichkeit f√ºr den Compiler beschreibt, <code>operator==</code> unabh√§ngig vom Raumschiffoperator neu zu schreiben und zu generieren.  Unser <code>IntWrapper</code> k√∂nnte wie folgt geschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Nur noch ein Schritt ... es gibt jedoch gute Nachrichten;  Sie m√ºssen den obigen Code nicht wirklich schreiben, da das einfache Schreiben des <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> ausreicht, damit der Compiler implizit den separaten - und effizienteren - <code>operator==</code> f√ºr Sie generiert! <br><br>  Der Compiler wendet eine leicht ge√§nderte Regel zum Umschreiben an, die f√ºr <code>==</code> und <code>!=</code> Speziell ist. Dabei werden in diesen Operatoren <code>operator==</code> und nicht <code>operator&lt;=&gt;</code> umgeschrieben.  Dies bedeutet, dass <code>!=</code> Auch von der Optimierung profitiert. <br><br><h2>  Alter Code wird nicht brechen </h2><br>  An diesem Punkt k√∂nnten Sie denken, OK, wenn der Compiler dieses Operator-Umschreibungsgesch√§ft ausf√ºhren darf, was passiert, wenn ich versuche, den Compiler zu √ºberlisten: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  Die Antwort hier ist, dass Sie es nicht getan haben.  Das √úberlastungsaufl√∂sungsmodell in C ++ hat diese Arena, in der alle Kandidaten k√§mpfen, und in diesem speziellen Kampf haben wir 3 Kandidaten: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (umgeschrieben) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (synthetisiert) <br><br>  Wenn wir die √úberlastungsaufl√∂sungsregeln in C ++ 17 akzeptiert h√§tten, w√§re das Ergebnis dieses Aufrufs nicht eindeutig gewesen, aber die C ++ 20-√úberlastungsaufl√∂sungsregeln wurden ge√§ndert, damit der Compiler diese Situation auf die logischste √úberladung aufl√∂sen kann. <br><br>  Es gibt eine Phase der √úberlastungsaufl√∂sung, in der der Compiler einen Serien-Tiebreaker ausf√ºhren muss.  In C ++ 20 gibt es einen neuen Tiebreaker, der besagt, dass wir √úberladungen bevorzugen m√ºssen, die nicht neu geschrieben oder synthetisiert werden. Dies macht unseren √úberlastungs- <code>IntWrapper::operator&lt;</code> zum besten Kandidaten und l√∂st die Mehrdeutigkeit.  Dieselbe Maschinerie verhindert, dass synthetisierte Kandidaten auf regul√§re umgeschriebene Ausdr√ºcke stampfen. <br><br><h2>  Gedanken schlie√üen </h2><br>  Der Raumschiff-Operator ist eine willkommene Erg√§nzung zu C ++ und eine der Funktionen, die es Ihnen erleichtern und Ihnen helfen, <i>weniger</i> Code zu schreiben, und manchmal ist weniger mehr.  Schnallen Sie sich also mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raumschiff-</a> Operator von C ++ 20 an! <br><br>  Wir empfehlen Ihnen dringend, den Raumschiff-Operator auszuprobieren. Er ist ab sofort in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio 2019</a> unter <code>/std:c++latest</code> verf√ºgbar.  Hinweis: Die durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1185R2</a> eingef√ºhrten √Ñnderungen sind in Visual Studio 2019 Version 16.2 verf√ºgbar.  Bitte beachten Sie, dass der Raumschiffoperator Teil von C ++ 20 ist und bis zu dem Zeitpunkt, an dem C ++ 20 abgeschlossen ist, einigen √Ñnderungen unterworfen ist. <br><br>  Wie immer freuen wir uns √ºber Ihr Feedback.  Sie k√∂nnen Kommentare per E-Mail an <a href="">visualcpp@microsoft.com</a> , √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter @visualc</a> oder Facebook an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Visual Cpp senden</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folgen Sie</a> mir auch auf Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@starfreakclone</a> . <br><br>  Wenn Sie in VS 2019 auf andere Probleme mit MSVC sto√üen, teilen Sie uns dies bitte √ºber die Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> melden mit, entweder vom Installationsprogramm oder von der Visual Studio-IDE selbst.  F√ºr Vorschl√§ge oder Fehlerberichte lassen Sie es uns √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevComm</a> wissen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458248/">https://habr.com/ru/post/de458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458230/index.html">Wie KI, Drohnen und Kameras unsere Stra√üen und Br√ºcken sch√ºtzen</a></li>
<li><a href="../de458240/index.html">Wie k√ºnstliche Intelligenz, Drohnen und Kameras die Sicherheit von Stra√üen und Br√ºcken gew√§hrleisten</a></li>
<li><a href="../de458242/index.html">Der neue Raumschiffoperator in C ++ 20</a></li>
<li><a href="../de458244/index.html">Eine endlose und l√§cherliche Liste dessen, was Sie wissen m√ºssen, um √∂ffentliche Wi-Fi-Netzwerke sicher nutzen zu k√∂nnen</a></li>
<li><a href="../de458246/index.html">Zuf√§llige Zuf√§lle im Leben oder wie sich herausstellte, dass Ihnen in einer Traktorenfabrik ein Kuchen pr√§sentiert wurde</a></li>
<li><a href="../de458250/index.html">BTRFS f√ºr die Kleinsten</a></li>
<li><a href="../de458252/index.html">Mathematisches Modell eines superlangen Radioteleskops</a></li>
<li><a href="../de458256/index.html">Ist es nicht Zeit f√ºr eine Gehirnw√§sche?</a></li>
<li><a href="../de458260/index.html">Eine andere M√∂glichkeit, Docker-Images f√ºr Java-Anwendungen zu optimieren</a></li>
<li><a href="../de458262/index.html">Online-Designer des Besprechungsraums - Auswahl der optimalen L√∂sung f√ºr die Videokonferenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>