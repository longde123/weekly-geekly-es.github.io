<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💆🏽 ✌🏾 👨🏻‍🏫 Persatuan Arduino dan prosesor klasik 💵 🍁 🌹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Retrocomputer datang dalam berbagai tingkat rewel. Beberapa puas dengan persaingan. Yang lain lebih suka FPGA, karena dengan demikian ternyata bukan p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Persatuan Arduino dan prosesor klasik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446048/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/8r/yr/ol8ryrltwjene6e2frje_pacnti.jpeg"></div><br>  Retrocomputer datang dalam berbagai tingkat rewel.  Beberapa puas dengan persaingan.  Yang lain lebih suka FPGA, karena dengan demikian ternyata bukan persaingan, tetapi rekreasi.  Akhirnya, sajikan prosesor ketiga. <br><br>  Tetapi prosesor membutuhkan banyak hal untuk bekerja!  Sekali lagi, dilema: mengambil chip nyata dari tahun yang sama, atau meletakkan semuanya di FPGA, meninggalkan prosesor di luar?  Namun, mengapa FPGA diperlukan?  Hidup penyatuan Arduino dan prosesor klasik! <a name="habracut"></a><br><br>  Berikan Arduino Anda "otak kedua" dan membuatnya lebih pintar. <br><br>  Sebuah mikroprosesor delapan bit yang benar menjalankan program, sementara Arduino mengemulasi ROM, RAM, dan periferal sederhana. <br><br>  Desain periferal virtual di Arduino IDE, dan jalankan kode assembler pada mikroprosesor.  Tidak perlu memasang sirkuit yang rumit dan mem-flash ROM paralel. <br><br>  Mikroprosesor yang didukung: 6502, 6809 dan Z80 (18581), yang lain sedang dalam perjalanan. <br><br>  Sebuah perisai dengan mikroprosesor tidak mengganggu menghubungkan perisai lain: dengan LCD, kartu memori, dll. <br><br>  Selain bahasa self-assembly, Anda dapat mencoba menjalankan beberapa kode klasik pada mikroprosesor. <br><br>  Benar, mikroprosesor akan beroperasi pada frekuensi yang sangat rendah - sekitar 95 kHz, nilai pastinya tergantung pada optimalisasi kode emulasi periferal. <br><br>  Distribusi ruang alamat diatur secara program dalam sketsa.  Mikroprosesor dapat dialokasikan dari 4 hingga 6 kB dari 8 kB RAM yang tersedia di Arduino Mega.  ROM dapat mengalokasikan lebih dari 200 kB dari 256 yang tersedia. <br><br>  Port serial Arduino Mega dapat meniru UART. <br><br>  Sirkuit, gambar papan, file Gerber tersedia di bawah CC-BY-SA 4.0 di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Pada saat yang sama, ada persyaratan untuk melampirkan file README.md, karena berisi peringatan berikut: <br><blockquote>  Jangan hubungkan pelindung sampai sketsa emulasi perangkat diunggah!  Jika tidak, mungkin mempersingkat jalur output mikroprosesor. </blockquote>  Ya, dan dalam sketsa itu sendiri, sesuatu perlu diulang dengan hati-hati untuk alasan yang sama. <br><br>  Skema perangkat pada 6502: <br><br><img src="https://habrastorage.org/webt/e0/n8/6k/e0n86kpozlcttklifjihnl51quo.png"><br><br>  Skema perangkat pada 6809: <br><br><img src="https://habrastorage.org/webt/qf/yi/kx/qfyikx1tktdjuad0hocivlpsolw.png"><br><br>  Skema perangkat pada Z80: <br><br><img src="https://habrastorage.org/webt/ct/uh/qs/ctuhqskjmmp1rvxrhs8abcoqvne.png"><br><br>  Anda sudah dapat menjalankan: <br><br>  Pada perangkat dengan 6502 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple I, Woz Monitor + ROM dengan BASIC</a> <br><br>  Pada perangkat dengan 6809 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sebuah analog dari komputer buatan rumah Simon6809 dari pengembang yang sama, monitor pelatihan dengan assembler dan disassembler</a> <br><br>  Pada perangkat dengan Z80 - sejauh ini hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes gema port serial</a> , memungkinkan Anda untuk memeriksa kinerja virtual 8251 (KR580VV51A). <br><br>  Firmware untuk meniru periferal - di bawah lisensi MIT. <br><br>  Deskripsi singkat tentang prinsip tindakan: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ke 6502 perangkat</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ke perangkat pada 6809</a> <br><br>  Untuk perangkat pada Z80 - dalam persiapan. <br><br>  Pengembang mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjual</a> perangkat, tetapi dengan pengiriman hanya di Amerika Serikat.  Tidak ada alasan khusus untuk membeli, karena skema ini sangat sederhana, Anda dapat mengulanginya di selembar papan tempat memotong roti dalam satu jam. <br><br>  Direncanakan untuk mengembangkan papan serupa di RCA1802, 68008, 8085 (182185), 8088 (181088).  Tentang K1801BM1 tidak dikatakan, tetapi Anda dapat memberikan ide seperti itu kepada penulis. <br><br>  File: <br><br>  Ke perangkat pada 6502: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi perakitan</a> , <a href="">sablon sutra</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram</a> <br><br>  Ke perangkat pada 6809: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi perakitan</a> , <a href="">sablon sutra</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram</a> <br><br>  Ke perangkat pada Z80: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi perakitan</a> , <a href="">sablon sutra</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram</a> <br><br>  Pertimbangkan interaksi perangkat Arduino dan 6502. Arduino secara berkala mengubah level input dari mikroprosesor yang dirancang untuk memasok pulsa clock dari nol ke satu dan sebaliknya.  Pada setiap siklus, ia memeriksa apa yang terjadi pada jalur kontrol dan bus alamat, dan, tergantung pada situasinya, membaca informasi dari bus data atau mengirimkannya ke sana.  Arduino juga dapat mengontrol jalur IRQ dan NMI, yang menyebabkan gangguan.  Gambar tersebut menunjukkan jenis data dan arah transmisi mereka: <br><br><img src="https://habrastorage.org/webt/tr/in/je/trinjeibi9cwwrngfq628lm4yns.png"><br><br>  Korespondensi port Arduino dan output mikroprosesor dikonfigurasi dalam sketsa: <br><br><pre><code class="plaintext hljs">/* Digital Pin Assignments */ #define DATA_OUT PORTL #define DATA_IN PINL #define ADDR_H PINC #define ADDR_L PINA #define ADDR ((unsigned int) (ADDR_H &lt;&lt; 8 | ADDR_L)) #define uP_RESET_N 38 #define uP_RW_N 40 #define uP_RDY 39 #define uP_SO_N 41 #define uP_IRQ_N 50 #define uP_NMI_N 51 #define uP_E 52 #define uP_GPIO 53</code> </pre> <br>  Kami akan membagi masing-masing ukuran menjadi peristiwa berikut: <br><br>  CLK mengubah status dari satu ke nol (tolak) <br>  CLK dalam kondisi nol <br>  CLK mengubah status dari satu ke nol (naik) <br>  CLK dalam kondisi unit <br>  CLK sekali lagi mengubah status dari satu ke nol ... <br><br>  Apa yang terjadi selama masa transisi negara? <br><br>  6502 menerima pulsa clock pada input CLK0, buffer mereka dan mengirimkannya ke dua output: CLK1 dan CLK2.  Meskipun semua peristiwa dalam mikroprosesor terikat ke CLK1, kami menganggap bahwa penundaannya kecil, dan mereka terikat pada CLK0 - garis di mana mikroprosesor menerima pulsa clock dari Arduino.  Dan sebut saja sinyal CLK saja. <br><br><img src="https://habrastorage.org/webt/9i/kq/hc/9ikqhcytwd4sjg6rwjnvmohgkvi.png"><br><br>  1. CLK mengubah status dari satu ke nol. <br><br>  2. Mikroprosesor mengeluarkan alamat baru ke bus alamat, dan sinyal sakelar antara membaca dan menulis ke keluaran R / W.  Tapi dia belum siap untuk pertukaran data. <br><br>  3. CLK masuk ke unit state, dan ini berarti bahwa pertukaran data telah dimulai.  Jika ini adalah operasi baca, mikroprosesor mentransfer output bus data ke status input dan menerima data, dan jika operasi tulis, itu mentransfernya ke status output dan mengirim data.  Dan sinyal R / W mengalihkan perangkat eksternal ke mode tulis atau baca, kebalikan dari kondisi mikroprosesor yang sesuai. <br><br>  4. CLK pergi ke nol.  Sekarang baik mikroprosesor maupun perangkat input-output tidak mengeluarkan apa pun ke bus data.  Mikroprosesor dapat mengatur jalur bus data dan pin R / W ke status baru. <br><br>  Penjelasan sederhana, dapat dimengerti oleh anak.  Siapa yang tidak pernah berpikir tentang "intrik di balik layar" ini, jika ia hanya akan memprogram mikrokontroler.  Bahkan di assembler. <br><br>  Jika Anda perlu menghubungkan perangkat periferal Anda, ia harus memiliki waktu untuk menyiapkan data sebelum unit (waktu persiapan) muncul di jalur CLK, dan ketika unit ada di sana, jangan mengubahnya.  Jika perangkat periferal tidak memiliki waktu untuk menyiapkan data saat CLK nol, atau mengubahnya ketika unit ada di sana, Anda akan bertanya-tanya dalam waktu lama mengapa kode Anda tidak berfungsi.  Karena frekuensi clock mikroprosesor adalah sepuluh hingga lima belas kali lebih rendah dari frekuensi nominal, mudah untuk mematuhi persyaratan ini.  Tapi itu perlu. <br><br>  Jadi, Anda perlu "mengajar" Arduino untuk menghasilkan pulsa clock, terus menerus memeriksa apa yang terjadi pada alamat dan jalur R / W, dan berinteraksi dengan bus data yang sesuai.  Untuk melakukan ini, sketsa menggunakan timer1 timer interrupt, yang menghasilkan pulsa dengan frekuensi 95 kHz.  Arduino bekerja lebih cepat daripada mikroprosesor, dan karenanya, di antara jam-jamnya, ia berhasil membaca dan menyiapkan segalanya.  Penting untuk memastikan bahwa setelah memodifikasi sketsa, kondisi ini terus terpenuhi. <br><br>  Berikut adalah kutipan dari sketsa, yang menunjukkan bagaimana CLK berubah dari nol menjadi satu, dan apa yang terjadi selanjutnya: <br><br><pre> <code class="plaintext hljs">//////////////////////////////////////////////////////////////////// // Processor Control Loop //////////////////////////////////////////////////////////////////// // This is where the action is. // it reads processor control signals and acts accordingly. // ISR(TIMER1_COMPA_vect) { // Drive CLK high CLK_E_HIGH; // Let's capture the ADDR bus uP_ADDR = ADDR; if (STATE_RW_N) ////////////////////////////////////////////////////////////////// // HIGH = READ transaction { // uP wants to read so Arduino to drive databus to uP: DATA_DIR = DIR_OUT; // Check what device uP_ADDR corresponds to: // ROM? if ( (ROM_START &lt;= uP_ADDR) &amp;&amp; (uP_ADDR &lt;= ROM_END) ) DATA_OUT = pgm_read_byte_near(rom_bin + (uP_ADDR - ROM_START)); else if ( (BASIC_START &lt;= uP_ADDR) &amp;&amp; (uP_ADDR &lt;= BASIC_END) ) DATA_OUT = pgm_read_byte_near(basic_bin + (uP_ADDR - BASIC_START)); else // RAM? if ( (uP_ADDR &lt;= RAM_END) &amp;&amp; (RAM_START &lt;= uP_ADDR) ) DATA_OUT = RAM[uP_ADDR - RAM_START]; else // 6821? if ( KBD &lt;=uP_ADDR &amp;&amp; uP_ADDR &lt;= DSPCR ) { // KBD? if (uP_ADDR == KBD) { ... // handle KBD register } else // KBDCR? if (uP_ADDR == KBDCR) { ... // handle KBDCR register } else // DSP? if (uP_ADDR == DSP) { ... // handle DSP register } else // DSPCR? if (uP_ADDR == DSPCR) { ... // handle DSPCR register } } } else ////////////////////////////////////////////////////////////////// // R/W = LOW = WRITE { // RAM? if ( (uP_ADDR &lt;= RAM_END) &amp;&amp; (RAM_START &lt;= uP_ADDR) ) RAM[uP_ADDR - RAM_START] = DATA_IN; else // 6821? if ( KBD &lt;=uP_ADDR &amp;&amp; uP_ADDR &lt;= DSPCR ) { // KBD? if (uP_ADDR == KBD) { ... // handle KBD register } else // KBDCR? if (uP_ADDR == KBDCR) { ... // handle KBDCR register } else // DSP? if (uP_ADDR == DSP) { ... // handle DSP register } else // DSPCR? if (uP_ADDR == DSPCR) { ... // handle DSPCR register } } } //////////////////////////////////////////////////////////////// // We are done with this cycle. // one full cycle complete clock_cycle_count ++; // start next cycle CLK_E_LOW; // If Arduino was driving the bus, no need anymore. // natural delay for DATA Hold time after CLK goes low (t_HR) DATA_DIR = DIR_IN; }</code> </pre> <br>  Alokasi ruang alamat dapat dilakukan dengan cara apa pun, dalam sketsa yang tidak dimodifikasi sama dengan di Apple 1 dengan 256 byte ROM, 8 kilobyte ROM untuk BASIC, 4 kilobyte RAM dan perangkat input-output 6821. <br><br><pre> <code class="plaintext hljs">// MEMORY LAYOUT // 4K MEMORY #define RAM_START 0x0000 #define RAM_END 0x0FFF byte RAM[RAM_END-RAM_START+1]; // ROMs (Monitor + Basic) #define ROM_START 0xFF00 #define ROM_END 0xFFFF #define BASIC_START 0xE000 #define BASIC_END 0xEFFF //////////////////////////////////////////////////////////////////// // Woz Monitor Code //////////////////////////////////////////////////////////////////// // PROGMEM const unsigned char rom_bin[] = { 0xd8, 0x58, 0xa0, 0x7f, 0x8c, 0x12, 0xd0, 0xa9, 0xa7, 0x8d, 0x11, 0xd0, ... 0x00, 0xff, 0x00, 0x00 }; // BASIC ROM starts at E000 PROGMEM const unsigned char basic_bin[] = { 0x4C, 0xB0, 0xE2, 0xAD, 0x11, 0xD0, 0x10, 0xFB, ... 0xE0, 0x80, 0xD0, 0x01, 0x88, 0x4C, 0x0C, 0xE0 };</code> </pre> <br>  RAM ditiru oleh array RAM byte [RAM_END-RAM_START + 1].  Dibutuhkan dua kata kunci PROGMEM sehingga isi dari emulasi ROM disimpan dalam memori flash mikrokontroler. <br><br>  6821 cukup ditiru sehingga keyboard dan tampilan virtual bekerja melalui "terminal".  Woz Monitor dan BASIC bekerja, itulah yang dicari penulis. <br><br>  Untuk meniru perangkat periferal apa pun, Anda perlu membaca lembar datanya dengan hati-hati dan mencari tahu apa yang dimiliki register dan untuk apa mereka.  Kemudahan emulasi terletak pada fleksibilitas yang dengannya Anda dapat membuat analog perangkat lunak periferal. <br><br>  Perangkat I / O terletak di ruang alamat mikroprosesor, mereka diakses dengan cara yang sama seperti sel memori.  Untuk menggunakan periferal "besi", seperti layar LCD, kartu memori, output suara, Anda perlu mengalokasikan tempat di ruang alamat. <br><br>  Referensi: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.6502.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.callapple.org/soft/ap1/emul.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skilldrick.github.io/easy6502</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">searle.hostei.com/grant/6502/Simple6502.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wilsonminesco.com/6502primer</a> <br>  SB-Assembler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.sbprojects.net/sbasm</a> <br><br>  Pergi ke 6809, ini berisi: <br><br>  Dua baterai delapan-bit A dan B, yang dapat digabungkan menjadi satu baterai enam-bit <br>  Dua indeks tumpukan 16-bit <br>  Mengatasi relatif ke konter instruksi <br>  Secara otomatis menambah atau mengurangi 1 atau 2 <br>  Perkalian dua angka tanpa tanda delapan digit <br>  Aritmatika 16-bit <br>  Transfer dan pertukaran data antara semua register <br>  Menulis dan membaca semua register dan kombinasi mereka <br><br>  Mikroprosesor 6809E (eksternal) membutuhkan jam eksternal, sedangkan 6809 memiliki jam internal.  Di Hitachi, mereka dipanggil, masing-masing, 6309E dan 6309, mereka berbeda dari yang biasa di mana mereka beroperasi dalam bentuk 32-bit di dalam operasi, tetapi dimungkinkan untuk beralih ke mode kompatibilitas dengan versi klasik. <br><br>  Sebenarnya, seluruh proyek RetroShield dimulai karena penulis ingin memutakhirkan komputer buatannya Simon6809 dan beri nama hasil Simon6809 Turbo.  Tetapi ternyata chip logika standar untuk semua yang ingin dia implementasikan di sana akan membutuhkan banyak.  Oleh karena itu, penulis merumuskan ide RetroShield untuk pertama kalinya dalam kaitannya dengan 6809, dan hanya kemudian berpikir: "bagaimana jika yang sama dengan prosesor lain melakukan hal yang sama?". <br><br>  Perangkat, tentu saja, menggunakan 6809E, yang membutuhkan jam eksternal, sehingga dapat menyinkronkan kerjanya dari luar.  Garis E dan Q untuk kedua prosesor diberi nama yang sama, hanya 6809 yang memiliki keluaran, dan 6809E yang memiliki input. <br><br>  Arduino berinteraksi dengan 6809 dengan cara yang sama seperti dengan 6502, tetapi memiliki dua input jam: E dan Q, dan tiga input interupsi: IRQ, FIRQ dan NMI. <br><br><img src="https://habrastorage.org/webt/0i/uk/dn/0iukdn25vkrhbsvd8spjlhr-s3q.png"><br><br>  Kali ini, korespondensi antara port Arduino dan pin mikroprosesor dikonfigurasi sebagai berikut: <br><br><pre> <code class="plaintext hljs">/* Digital Pin Assignments */ #define DATA_OUT PORTL #define DATA_IN PINL #define ADDR_H PINC #define ADDR_L PINA #define ADDR ((unsigned int) (ADDR_H &lt;&lt; 8 | ADDR_L)) #define uP_RESET_N 38 #define uP_E 52 #define uP_Q 53 #define uP_RW_N 40 #define uP_FIRQ_N 41 #define uP_IRQ_N 50 #define uP_NMI_N 51 #define uP_GPIO 39</code> </pre> <br>  Seperti dapat dilihat dari grafik, sinyal Q bergeser relatif terhadap E dengan seperempat periode: <br><br>  Kami hampir tidak akan memperhatikan Q, karena semua acara terkait dengan E. Dan semuanya terjadi seperti ini: <br><br><img src="https://habrastorage.org/webt/ao/hj/qv/aohjqvkk89mbouy7_njtjqbz3ku.png"><br><br><ol><li>  E beralih ke nol.  Prosesor menetapkan alamat baru pada bus alamat dan mengubah status jalur R / W. </li><li>  E beralih ke satu, prosesor menjadi siap untuk pertukaran data. </li><li>  Tidak masalah apa yang terjadi pada bus data selama E adalah satu, hal utama adalah bahwa data yang diperlukan ada di sana pada saat E kembali ke nol. </li><li>  Saat membaca data, perangkat I / O harus memasok data yang diperlukan ke bus data sebelum garis E melewati dari satu ke nol (penundaan minimum ditunjukkan oleh angka 17 dalam lingkaran). </li><li>  Saat merekam, perangkat I / O harus memperbaiki data dalam beberapa register dalam bentuk yang pada saat itu E berubah dari satu ke nol.  Prosesor akan memberikan data ini pada bus bahkan lebih awal - pada saat transisi dari Q ke satu (nomor 20 dalam lingkaran). </li><li>  Setelah transisi E ke nol, semuanya terulang. </li></ol><br>  Semua yang dikatakan di atas sekitar 6502 tentang perlunya perangkat periferal (termasuk yang virtual) untuk mengembangkan semua sinyal tepat waktu 6809. <br><br>  Generasi sinyal E dan Q, seperti dalam kasus 6502, dengan satu-satunya perbedaan bahwa ada dua sinyal, dan mereka harus diaktifkan sesuai dengan grafik.  Dan seperti itu, subrutin yang dipanggil untuk melakukan interupsi melakukan input atau output data pada saat-saat yang diperlukan. <br><br>  Ruang alamat di sketsa yang tidak dimodifikasi didistribusikan dengan cara yang sama seperti di komputer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simon6809</a> buatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rumah</a> : <br><br><pre> <code class="plaintext hljs">// MEMORY #define RAM_START 0x0000 #define RAM_END 0x0FFF #define ROM_START 0xE000 #define ROM_END 0xFFFF byte RAM[RAM_END-RAM_START+1]; //////////////////////////////////////////////////////////////////// // Monitor Code //////////////////////////////////////////////////////////////////// // static const unsigned char PROGMEM const unsigned char simon09_bin[] = { 0x1a, 0xff, 0x4f, 0x1f, 0x8b, 0x0f, 0x36, 0x7f, 0x01, 0xa5, 0x10, 0xce, ... 0x00, 0x09, 0x00, 0x0c, 0x00, 0x0f, 0xe0, 0x00 };</code> </pre> <br>  RAM dan ROM disimpan dalam array dengan cara yang sama seperti pada varian 6502, dengan satu-satunya perbedaan adalah bahwa hanya ada satu array dengan data ROM. <br><br>  Perangkat I / O juga dialokasikan bagian dari ruang alamat, dan mereka bisa berupa virtual atau nyata.  Karena Simon6809 adalah mesin modern yang didasarkan pada basis elemen vintage, ia bertukar data melalui FTDI dari PC yang menjalankan “terminal”.  Ini ditiru. <br><br>  Referensi: <br><br>  Banyak informasi tentang 6809 pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman Arto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Wikipedia pada 6809</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem SWTPc 6809</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Wikipedia tentang sistem operasi FLEX</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446048/">https://habr.com/ru/post/id446048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446036/index.html">Aplikasi Oracle Express. Aplikasi dan halaman</a></li>
<li><a href="../id446038/index.html">Panduan singkat tentang membuat nubuat, dewa mobil dan kesalahan orde kedua</a></li>
<li><a href="../id446040/index.html">Pengakuan Penuh Stack: Profesi, Agama, Mimpi</a></li>
<li><a href="../id446042/index.html">DJI Mavic 2 Pro setelah enam bulan digunakan</a></li>
<li><a href="../id446046/index.html">Perluasan alam semesta adalah kesalahan terbesar dalam sejarah sains</a></li>
<li><a href="../id446050/index.html">Bergetar. Kunci! Untuk apa mereka?</a></li>
<li><a href="../id446052/index.html">Menciptakan suara & nada produk Anda</a></li>
<li><a href="../id446054/index.html">Siap cadangan: menghancurkan mitos liburan</a></li>
<li><a href="../id446056/index.html">Cara Sederhana untuk Berbicara di Situs Web Anda</a></li>
<li><a href="../id446058/index.html">Cara Membangun SDN - Delapan Alat Sumber Terbuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>