<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèæ üßô üë©üèº‚Äçüíª √çndices de portada para GiST üìΩÔ∏è ‚óªÔ∏è üê≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El √≠ndice de cobertura no es solo otra caracter√≠stica que puede ser √∫til. Esta cosa es puramente pr√°ctica. Sin ellos, Index Only Scan no puede dar una...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices de portada para GiST</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/474166/"> El √≠ndice de cobertura no es solo otra caracter√≠stica que puede ser √∫til.  Esta cosa es puramente pr√°ctica.  Sin ellos, Index Only Scan no puede dar una victoria.  Aunque el √≠ndice de cobertura en diferentes situaciones es efectivo de diferentes maneras. <br><br>  No se trata realmente de cubrir √≠ndices: estrictamente hablando, los llamados √≠ndices inclusivos han aparecido en Postgres.  Pero, en orden: un √≠ndice de cobertura es un √≠ndice que contiene todos los valores de columna requeridos por la consulta;  sin embargo, ya no se requiere acceso a la tabla en s√≠.  Casi.  Puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leer</a> sobre "casi" y otros matices en un art√≠culo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Yegor Rogov</a> , incluido en su serie de √≠ndice de 10 (!) Partes.  Y el <b>√≠ndice inclusivo</b> se crea espec√≠ficamente para buscar consultas t√≠picas: los valores de los campos que no se pueden buscar se agregan al √≠ndice de b√∫squeda, solo se necesitan para no volver a consultar la tabla.  Dichos √≠ndices se forman con la palabra clave INCLUDE. <br><br>  Anastasia Lubennikova (Postgres Professional) finaliz√≥ el m√©todo btree para que se pudieran incluir columnas adicionales en el √≠ndice.  Este parche se incluy√≥ en PostgreSQL 11. Pero los parches para los m√©todos de acceso GiST / SP-GiST no tuvieron tiempo de madurar antes del lanzamiento de esta versi√≥n.  Para el 12¬∫ GiST madur√≥. <br><a name="habracut"></a><br>  Un deseo constructivo de tener √≠ndices inclusivos para GiST surgi√≥ hace mucho tiempo: un parche de prueba de Andrey Borodin fue <a href="">ofrecido a la</a> comunidad a mediados de abril de 2018.  Hizo todo el trabajo b√°sico, muy dif√≠cil. <br><br>  A principios de agosto de 2019, Alexander Korotkov agreg√≥ mejoras cosm√©ticas y comprometi√≥ el parche. <br><br>  Para demostraciones y algunas investigaciones, generaremos un conjunto de 3 millones de rect√°ngulos.  Al mismo tiempo, algunas palabras sobre el tipo de cuadro, ya que no todas las manipulaciones con √©l son intuitivas. <br><br>  El tipo de cuadro, es decir, el rect√°ngulo, ha estado durante mucho tiempo en Postgres, est√° definido por 2 puntos (el punto de tipo geom√©trico): los v√©rtices opuestos del rect√°ngulo (es decir, el rect√°ngulo no puede ser oblicuo, lleno a un lado).  Leemos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> : "los valores del cuadro de tipo se escriben en una de las siguientes formas: <br><br><pre><code class="plaintext hljs">( ( x1 , y1 ) , ( x2 , y2 ) ) ( x1 , y1 ) , ( x2 , y2 ) x1 , y1 , x2 , y2</code> </pre> <br>  En la pr√°ctica, tienes que escribir, por ejemplo, as√≠: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box(<span class="hljs-string"><span class="hljs-string">'1,2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3,4'</span></span>); <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-comment"><span class="hljs-comment">------------- (3,4),(1,2) (1 row)</span></span></code> </pre> <br>  Primero, Postgres nos muestra el v√©rtice superior derecho, luego el inferior izquierdo.  Si escribimos as√≠, <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box(<span class="hljs-string"><span class="hljs-string">'5,2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3,4'</span></span>); <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-comment"><span class="hljs-comment">------------- (5,4),(3,2) (1 row)</span></span></code> </pre> <br>  entonces nos aseguraremos de que Postgres no haya dado los picos que le dieron.  Calcul√≥ la esquina superior derecha e inferior izquierda desde nuestra esquina superior izquierda e inferior derecha.  Esta es una propiedad conveniente cuando la ubicaci√≥n de los v√©rtices no se conoce de antemano, por ejemplo, en caso de generaci√≥n aleatoria.  La notaci√≥n '1,2', '3,4' es equivalente al punto (1,2), punto (3,4).  Este formulario es a veces m√°s conveniente. <br><br><br><h3>  Para negocios: busque en 3 millones de rect√°ngulos </h3><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> boxes(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, thebox <span class="hljs-type"><span class="hljs-type">box</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>);</code> </pre><br>  Generaremos 3 millones de rect√°ngulos aleatorios.  Queremos una distribuci√≥n normal, pero para no usar la extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablefunc</a> , usamos el enfoque "pobre": usamos random () - random (), que tambi√©n da una buena imagen (ver fig.) Con rect√°ngulos, cuanto m√°s grande, m√°s cerca del centro.  Sus centros de gravedad tambi√©n son aleatorios.  Dichas distribuciones son caracter√≠sticas de algunos tipos de datos de ciudades reales.  Y aquellos que quieran profundizar en las leyes de estad√≠sticas o actualizar recuerdos pueden leer sobre la diferencia de variables aleatorias, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><img src="https://habrastorage.org/webt/2p/df/j4/2pdfj4sxnjja1ztiikvrkzrdniw.jpeg"><br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> boxes(thebox, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box( <span class="hljs-type"><span class="hljs-type">point</span></span>( random()-random(), random()-random() ), <span class="hljs-type"><span class="hljs-type">point</span></span>( random()-random(), random()-random() ) ), <span class="hljs-string"><span class="hljs-string">'box no.'</span></span> || x <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x);</code> </pre> <br><br>  El tama√±o de la tabla que muestra <code>\dt+</code> es de 242 MB.  Ahora puedes comenzar la b√∫squeda. <br><br>  Estamos buscando sin un √≠ndice: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------- Gather (cost=1000.00..47853.00 rows=3000 width=46) (actual time=0.140..246.998 rows=139189 loops=1) Workers Planned: 2 Workers Launched: 2 -&gt; Parallel Seq Scan on boxes (cost=0.00..46553.00 rows=1250 width=46) (actual time=0.011..106.708 rows=46396 loops=3) Filter: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Rows Removed by Filter: 953604 Planning Time: 0.040 ms Execution Time: 259.262 ms (8 rows)</span></span></code> </pre> <br>  Vemos que hay una exploraci√≥n paralela secuencial - exploraci√≥n secuencial (aunque paralelizada). <br><br>  Cree un √≠ndice regular, no inclusivo: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(thebox);</code> </pre> <br>  El tama√±o del √≠ndice <code>boxes_thebox_idx</code> , que muestra <code>\di+</code> , 262MB.  En respuesta a la misma solicitud, obtenemos: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on boxes (cost=159.66..9033.30 rows=3000 width=46) (actual time=29.101..80.283 rows=139189 loops=1) Recheck Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Blocks: exact=30629 -&gt; Bitmap Index Scan on boxes_thebox_idx (cost=0.00..158.91 rows=3000 width=0) (actual time=25.029..25.029 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Planning Time: 0.053 ms Execution Time: 86.206 ms (7 rows)</span></span></code> </pre><br>  El tiempo de b√∫squeda se redujo en un factor de tres y, en lugar de la exploraci√≥n paralela paralela, recibieron una exploraci√≥n de √≠ndice de mapa de bits.  No se paraleliza, pero funciona m√°s r√°pido. <br><br>  Ahora elimine el √≠ndice anterior y cree uno inclusivo: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> spgist(thebox) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre> <br>  √çndice de <code>boxes_thebox_name_idx</code> fatter: 356MB.  Vamos: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------ Bitmap Heap Scan on boxes (cost=207.66..9081.30 rows=3000 width=46) (actual time=86.822..152.014 rows=139189 loops=1) Recheck Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Blocks: exact=30629 -&gt; Bitmap Index Scan on boxes_thebox_name_idx (cost=0.00..206.91 rows=3000 width=0) (actual time=83.044..83.044 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Planning Time: 3.807 ms Execution Time: 157.997 ms (7 rows)</span></span></code> </pre> <br><br>  Se utiliza Index Only Scan, pero la imagen es triste: el tiempo es casi 2 veces m√°s largo que sin ella.  Leemos el manual del creador de √≠ndices, en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte I</a> : <br><br>  ‚ÄπLos √≠ndices Rang PostgreSQL no contienen informaci√≥n que le permita juzgar la visibilidad de las filas.  Por lo tanto, el m√©todo de acceso devuelve todas las versiones de filas que se encuentran bajo la condici√≥n de b√∫squeda, independientemente de si son visibles para la transacci√≥n actual o no.  Sin embargo, si el mecanismo de indexaci√≥n tuviera que mirar en la tabla cada vez para determinar la visibilidad, este m√©todo de escaneo no ser√≠a diferente del escaneo de √≠ndice ordinario.  El problema se resuelve por el hecho de que PostgreSQL admite el llamado mapa de visibilidad para tablas, en el que el proceso de vac√≠o marca p√°ginas en las que los datos no han cambiado lo suficiente como para que todas las transacciones lo vean, independientemente de la hora de inicio y el nivel de aislamiento.  Si el identificador de la fila devuelta por el √≠ndice se refiere a dicha p√°gina, entonces no se puede verificar la visibilidad. ‚Ä∫‚Ä∫ <br><br>  Hacemos VAC√çO.  Repetir <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Index Only Scan using boxes_thebox_name_idx on boxes (cost=0.41..236.91 rows=3000 width=46) (actual time=0.104..38.651 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Fetches: 0 Planning Time: 0.052 ms Execution Time: 44.337 ms (5 rows)</span></span></code> </pre> <br>  ¬°Un asunto completamente diferente!  El doble de la ganancia en comparaci√≥n con el √≠ndice no inclusivo. <br><br><br><h3>  Selectividad y ganancia </h3><br>  El rendimiento de los √≠ndices inclusivos depende en gran medida de la selectividad de las condiciones en las consultas.  Para investigar un poco esta dependencia, resolveremos el problema inverso: generaremos una etiqueta con un √≠ndice de punto de tipo y buscaremos cu√°ntos puntos caer√°n en el cuadro dado.  Extiende los puntos al cuadrado de manera uniforme. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test_covergist(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, tochka <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>);</code> </pre> <br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> test_covergist(tochka, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>(trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random()), trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random())), <span class="hljs-string"><span class="hljs-string">'point no.'</span></span> || gx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x);</code> </pre> <br>  El tama√±o de la tabla es de 211 MB. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka);</code> </pre> <br>  Tama√±o 213 MB. <br><br>  Obviamente tomaremos todos los puntos disponibles en un cuadrado: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=1087.964..1864.059 rows=3000000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27025 Buffers: shared read=54287 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=1084.949..1084.949 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared read=27262 Planning Time: 0.102 ms Execution Time: 2029.501 ms (9 rows)</span></span></code> </pre> <br>  Le pedimos a EXPLAIN que mostrara los tampones.  Ser√° √∫til.  Ahora el tiempo de ejecuci√≥n de la solicitud es m√°s de 2 segundos, se puede ver que Buffers: lectura compartida = 54287.  En otra situaci√≥n, podr√≠amos ver una mezcla de lectura compartida y √©xito compartido, es decir, algunos b√∫feres se leen desde el disco (o desde el cach√© del sistema operativo) y otros desde el cach√© del b√∫fer.  Conocemos el tama√±o aproximado de la tabla y los √≠ndices, por lo que nos protegeremos configurando buffers compartidos para que todo encaje: reinicie Postgres con la opci√≥n <br><br><pre> <code class="plaintext hljs">-o "-c shared_buffers=1GB"</code> </pre> <br>  Ahora: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=231.032..613.326 rows=3000000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27025 Buffers: shared hit=54248 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=228.068..228.068 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared hit=27223 Planning Time: 0.070 ms Execution Time: 755.915 ms (9 rows)</span></span></code> </pre> <br>  Es decir, la lectura compartida se convirti√≥ en un √©xito compartido, y el tiempo se redujo tres veces. <br><br>  Otro detalle importante en EXPLICAR: se devuelven 3 millones de puntos, y el pron√≥stico del n√∫mero de registros devuelto es de 3 mil. Spoiler: este n√∫mero no cambiar√° con ninguna selectividad.  El optimizador no sabe c√≥mo evaluar la cardinalidad cuando se trabaja con tipos de cuadro o punto.  Y el plan no cambiar√°: para cualquier tama√±o del rect√°ngulo, habr√° un Escaneo de √≠ndice de mapa de bits en test_covergist_tochka_idx. <br><br>  Aqu√≠ hay dos medidas m√°s con el n√∫mero de registros emitidos, que difieren en √≥rdenes de magnitud: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=27.889..134.054 rows=269882 loops=1) Recheck Cond: ('(300000,300000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27024 Buffers: shared hit=29534 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=24.847..24.847 rows=269882 loops=1) Index Cond: (tochka &lt;@ '(300000,300000),(0,0)'::box) Buffers: shared hit=2510 Planning Time: 0.074 ms Execution Time: 151.269 ms (9 rows)</span></span></code> </pre> <br>  Devuelve 10 veces menos registros (real ... filas = 269882), el tiempo ha disminuido en aproximadamente 5 veces. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'30000,30000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=1.882..16.095 rows=2780 loops=1) Recheck Cond: ('(30000,30000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=2624 Buffers: shared hit=2655 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=1.035..1.035 rows=2780 loops=1) Index Cond: (tochka &lt;@ '(30000,30000),(0,0)'::box) Buffers: shared hit=31 Planning Time: 0.154 ms Execution Time: 16.702 ms (9 rows)</span></span></code> </pre> <br>  El contenido de un cuadrado de 30K √ó 30K (2780) se cuenta en solo 16 ms.  Y cuando hay docenas de registros, ya se extraen en fracciones de ms, y tales mediciones no son muy confiables. <br><br>  Finalmente, mida lo mismo con el √≠ndice inclusivo: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre> <br>  Tama√±o 316 MB. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.160..568.707 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=40492 Planning Time: 0.090 ms Execution Time: 709.837 ms (6 rows)</span></span></code> </pre> <br>  El tiempo es casi el mismo que con un √≠ndice convencional, aunque Index Only Scan. <br><br>  Pero: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.083..53.277 rows=269882 loops=1) Index Cond: (tochka &lt;@ '(300000,300000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=3735 Planning Time: 0.077 ms Execution Time: 66.162 ms (6 rows)</span></span></code> </pre> <br>  Y fue de 151 ms.  Y, en consecuencia: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.043..0.639 rows=2780 loops=1) Index Cond: (tochka &lt;@ '(30000,30000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=52 Planning Time: 0.053 ms Execution Time: 0.791 ms (6 rows)</span></span></code> </pre><br>  Esto ya es una fracci√≥n de ms para los mismos registros de 2780 puntos. <br><br><h3>  Amortiguadores como pistolas </h3><br>  Se puede buscar y encontrar una explicaci√≥n en una escopeta que a√∫n no ha disparado pero que estaba colgada en la pared: la cantidad de bloques le√≠dos.  En el caso de un √≠ndice inclusivo, solo se leen los bloques del √≠ndice (Heap Fetches: 0).  En tres casos, estos fueron los n√∫meros 40492, 3735 y 52. ‚Äã‚ÄãPero cuando se usa el √≠ndice regular, los bloques le√≠dos consisten en la suma de los bits le√≠dos en el √≠ndice de Bitmap Heap Scan (54248 con 3 millones de registros) y los que tuvieron que leerse del mont√≥n (27223) , ya que el campo de nombre no se puede extraer de un √≠ndice regular.  54248 + 27223 = 81471.  La exclusiva fue 40492. Para otros dos casos: 29534 + 2510 = 31044 y 2655 + 31 = 2686.  En el caso de un √≠ndice regular, se leen m√°s bloques de todos modos, pero con una mejora en la selectividad, el n√∫mero de bloques le√≠dos comienza a diferir en √≥rdenes de magnitud en lugar de 2 veces debido al hecho de que el n√∫mero de bloques necesarios de un mont√≥n disminuye m√°s lentamente que leer bloques de √≠ndice. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Total de registros devueltos</b> (miles) </td><td>  <b>3000</b> </td><td>  <b>270</b> </td><td>  <b>2.7</b> </td></tr><tr><td>  <b>Leer bloques</b> (Normal / Incluido) </td><td>  81471/40492 </td><td>  31044/3735 </td><td>  2686/52 </td></tr><tr><td>  <b>Tiempo</b> </td><td>  755/710 </td><td>  151/66 </td><td>  16 / 0.7 </td></tr></tbody></table></div><br><br>  Pero tal vez el punto no es la selectividad, sino simplemente el tama√±o de la tabla.  Por si acaso, repetimos los mismos pasos, generando una tabla con 300 mil, y no 3 millones de registros: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test_covergist_small(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, tochka <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> test_covergist_small(tochka, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>(trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random()), trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random())), <span class="hljs-string"><span class="hljs-string">'point no.'</span></span> || gx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">300000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> test_covergist_small <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist_small <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist_small (cost=14.61..867.19 rows=300 width=31) (actual time=36.115..130.435 rows=300000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=2500 Buffers: shared hit=5225 -&gt; Bitmap Index Scan on test_covergist_small_tochka_idx (cost=0.00..14.53 rows=300 width=0) (actual time=35.894..35.895 rows=300000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared hit=2725 Planning Time: 0.060 ms Execution Time: 158.580 (9 rows)</span></span></code> </pre><br>  Luego, repita lo mismo para el √≠ndice inclusivo.  Aqu√≠ est√°n los resultados: <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Total de registros devueltos</b> (miles) </td><td>  <b>300</b> </td><td>  <b>27</b> </td><td>  <b>0.25</b> </td></tr><tr><td>  <b>Leer bloques</b> (Normal / Incluido) </td><td>  5225/3726 </td><td>  3026/352 </td><td>  270/8 </td></tr><tr><td>  <b>Tiempo</b> </td><td>  158/178 </td><td>  20/13 </td><td>  0.4 / 0.2 </td></tr></tbody></table></div><br><br>  En el caso del 100% de cobertura de puntos, la consulta fue incluso un poco m√°s lenta que con el √≠ndice habitual.  Adem√°s, como en el caso de 3 millones, todo encaj√≥.  Es decir, la selectividad es importante. <br><br>  Nuestra compa√±√≠a prob√≥ √≠ndices GiST inclusivos en datos reales, un conjunto con varios millones de rect√°ngulos en un mapa de Mosc√∫.  La conclusi√≥n es la misma: en muchas situaciones, tales √≠ndices aceleran notablemente las consultas.  Pero el art√≠culo no puede ilustrarse con im√°genes y n√∫meros de pruebas: estos datos no son de dominio p√∫blico. <br><br><h3>  En lugar de una conclusi√≥n </h3><br>  Regresemos por un momento a rect√°ngulos aleatorios.  Tratemos de hacer lo mismo con spgist.  Puede recordar o descubrir qu√© es entender las diferencias entre SP-GiST y GiST leyendo el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√çndices en PostgreSQL - 6</a> .  Crea un √≠ndice inclusivo: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> spgist(thebox) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>); ERROR: <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> "spgist" does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support included <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span></code> </pre> <br>  Por desgracia, para SP-GiST, los √≠ndices inclusivos a√∫n no se implementan. <br>  ¬°Entonces hay margen de mejora! <br><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474166/">https://habr.com/ru/post/474166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474144/index.html">C√≥mo crear una startup: proyecto IoT desde la idea hasta la producci√≥n</a></li>
<li><a href="../474146/index.html">Mayor velocidad de respaldo y la posibilidad de elegir la relaci√≥n de compresi√≥n en la nueva versi√≥n de Zextras Backup</a></li>
<li><a href="../474150/index.html">Derivaci√≥n de un modelo de un sistema din√°mico de un filtro de Kalman discreto para un sistema lineal arbitrario</a></li>
<li><a href="../474154/index.html">Vitrectom√≠a: aramos los espacios abiertos del mundo delimitados por la cavidad ocular</a></li>
<li><a href="../474164/index.html">Zimbra es nuestro todo</a></li>
<li><a href="../474170/index.html">Confesi√≥n de dise√±o - 15 de noviembre, Mosc√∫, DI Telegraph</a></li>
<li><a href="../474172/index.html">Una multa de 30 mil euros por el uso ilegal de cookies.</a></li>
<li><a href="../474176/index.html">11 videos del primer d√≠a de DevFest 2019 en Kaliningrado</a></li>
<li><a href="../474178/index.html">IVR en Webhook</a></li>
<li><a href="../474180/index.html">C√≥mo se implementa la arquitectura web tolerante a fallas en la plataforma Mail.ru Cloud Solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>