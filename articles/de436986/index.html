<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéë üíÉüèº üçû Linux API Verwalten der Kernel-Datei-E / A-Pufferung üë©üèª‚Äçüåæ üéöÔ∏è üë±üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Wir haben bereits √ºber Michael Kerrisks Buch ‚ÄûLinux API. Umfassender Leitfaden . ‚Äú Jetzt haben wir beschlossen, einen Auszug aus d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux API Verwalten der Kernel-Datei-E / A-Pufferung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/436986/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/qk/pj/rf/qkpjrftqtsq-bnryowiwf_v88us.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  Wir haben bereits √ºber Michael Kerrisks Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûLinux API.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umfassender Leitfaden</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äú</a>  Jetzt haben wir beschlossen, einen Auszug aus dem Buch "Verwalten der im Kernel verwalteten Datei-E / A-Pufferung" zu ver√∂ffentlichen. <br><br>  Das Zur√ºcksetzen des Kernel-Pufferspeichers f√ºr Ausgabedateien kann erzwungen werden.  Manchmal ist dies erforderlich, wenn die Anwendung vor der Fortsetzung der Arbeit (z. B. √Ñnderungen einer Prozessprotokollierungsdatenbank) sicherstellen muss, dass die tats√§chliche Ausgabe auf die Festplatte (oder zumindest in den Hardware-Festplatten-Cache) geschrieben wird. <br><br>  Bevor auf die Systemaufrufe eingegangen wird, die zur Steuerung der Kernel-Pufferung verwendet werden, sollten einige verwandte Definitionen aus SUSv3 betrachtet werden. <br><a name="habracut"></a><br>  <b>Synchronisierte E / A mit Daten- und Dateiintegrit√§t</b> <br><br>  In SUSv3 bedeutet das Konzept der synchronisierten E / A-Vervollst√§ndigung "eine E / A-Operation, die entweder zu einer erfolgreichen Daten√ºbertragung [auf die Festplatte] f√ºhrte oder als nicht erfolgreich diagnostiziert wurde". <br><br>  SUSv3 definiert zwei verschiedene Arten von synchronisierten E / A-Abschl√ºssen.  Der Unterschied zwischen den Typen bezieht sich auf Metadaten (‚ÄûDaten √ºber Daten‚Äú), die die Datei beschreiben.  Der Kernel speichert sie zusammen mit den Daten der Datei selbst.  Details zu Dateimetadaten werden in Abschnitt 14.4 bei der Untersuchung von Dateiinodes erl√§utert.  In der Zwischenzeit reicht es aus zu beachten, dass Dateimetadaten Informationen wie Informationen √ºber den Eigent√ºmer der Datei und ihre Gruppe, Zugriffsrechte auf die Datei, Dateigr√∂√üe, Anzahl der festen Links zur Datei, Zeitstempel, die den Zeitpunkt des letzten Zugriffs auf die Datei und den Zeitpunkt der letzten √Ñnderung enthalten, enthalten und die Zeit der letzten Metadaten√§nderung sowie Zeiger auf Datenbl√∂cke. <br><br>  Die erste Art der synchronisierten E / A-Vervollst√§ndigung in SUSv3 ist die Vervollst√§ndigung der Datenintegrit√§t.  Bei der Aktualisierung der Dateidaten sollte die √úbertragung von Informationen sichergestellt sein, die ausreichen, um die weitere Extraktion dieser Daten zu erm√∂glichen, damit sie weiterarbeiten k√∂nnen. <br><br>  - F√ºr einen Lesevorgang bedeutet dies, dass die angeforderten Dateidaten (von der Festplatte) an den Prozess √ºbertragen wurden.  Wenn anstehende Schreibvorg√§nge vorliegen, die sich auf die angeforderten Daten auswirken k√∂nnen, werden die Daten vor dem Lesen auf die Festplatte √ºbertragen. <br><br>  - F√ºr einen Schreibvorgang bedeutet dies, dass die in der Schreibanforderung angegebenen Daten (auf die Festplatte) √ºbertragen wurden, wie alle zum Extrahieren dieser Daten erforderlichen Dateimetadaten.  Der wichtigste Punkt, den Sie beachten sollten: Um sicherzustellen, dass Daten aus der ge√§nderten Datei extrahiert werden, m√ºssen nicht alle Medatendateien √ºbertragen werden.  Ein Beispiel f√ºr das Metadatenattribut einer ge√§nderten Datei, die migriert werden muss, ist ihre Gr√∂√üe (wenn der Schreibvorgang die Dateigr√∂√üe erh√∂ht).  Im Gegensatz dazu m√ºssen die Zeitstempel der zu √§ndernden Datei nicht auf die Festplatte √ºbertragen werden, bevor der anschlie√üende Datenabruf erfolgt. <br><br>  Der zweite in SUSv3 definierte Typ der synchronisierten E / A-Vervollst√§ndigung ist die Vervollst√§ndigung der Dateiintegrit√§t.  Dies ist eine erweiterte Option zum Abschlie√üen synchronisierter E / A mit Datenintegrit√§t.  Der Unterschied zwischen diesem Modus besteht darin, dass w√§hrend der Aktualisierung der Datei alle Metadaten auf die Festplatte √ºbertragen werden, auch wenn dies f√ºr die nachfolgende Extraktion der Dateidaten nicht erforderlich ist. <br><br>  <b>Systemaufrufe zur Steuerung der Kernel-Pufferung w√§hrend der Datei-E / A.</b> <br><br>  Der Systemaufruf fsync () setzt alle gepufferten Daten und alle Metadaten zur√ºck, die einer ge√∂ffneten Datei mit einem fd-Deskriptor zugeordnet sind.  Durch Aufrufen von fsync () wird die Datei nach Abschluss der synchronen E / A in einen Integrit√§tszustand (Datei) versetzt. <br><br>  Der Aufruf von fsync () gibt die Steuerung erst zur√ºck, nachdem die Daten√ºbertragung zum Festplattenger√§t (oder zumindest zu seinem Cache) abgeschlossen ist. <br><br><pre><code class="plaintext hljs">#include &lt;unistd.h&gt; int fsync(int fd);</code> </pre> <br>  Gibt bei Erfolg 0 oder -1 bei Fehler zur√ºck <br><br>  Der Systemaufruf fdatasync () funktioniert genau wie fsync (), versetzt die Datei jedoch nach Abschluss der synchronen E / A in einen Integrit√§tszustand (Daten). <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; int fdatasync(int fd);</code> </pre> <br>  Gibt bei Erfolg 0 oder -1 bei Fehler zur√ºck <br><br>  Durch die Verwendung von fdatasync () wird m√∂glicherweise die Anzahl der f√ºr den Systemaufruf fsync () erforderlichen Festplattenvorg√§nge von zwei auf eins reduziert.  Wenn sich beispielsweise die Dateidaten ge√§ndert haben, die Gr√∂√üe jedoch gleich bleibt, werden beim Aufrufen von fdatasync () nur die Daten aktualisiert.  (Es wurde bereits oben erw√§hnt, dass zum Abschlie√üen eines synchronen E / A-Vorgangs mit Datenintegrit√§t keine √Ñnderungen an Attributen wie dem Zeitpunkt der letzten √Ñnderung der Datei √ºbertragen werden m√ºssen.) Im Gegensatz dazu erzwingt der Aufruf von fsync () auch die √úbertragung von Metadaten auf die Festplatte. <br><br>  Eine solche Reduzierung der Anzahl der Festplatten-E / A-Vorg√§nge ist f√ºr einzelne Anwendungen n√ºtzlich, f√ºr die die Leistung und die genaue Aktualisierung bestimmter Metadaten (z. B. Zeitstempel) eine entscheidende Rolle spielen.  Dies kann zu erheblichen Leistungsverbesserungen f√ºr Anwendungen f√ºhren, die mehrere Dateiaktualisierungen gleichzeitig erstellen.  Da sich Dateidaten und Metadaten normalerweise in verschiedenen Teilen der Festplatte befinden, erfordert das Aktualisieren beider Daten eine wiederholte Vorw√§rts- und R√ºckw√§rtssuche auf der Festplatte. <br><br>  Unter Linux 2.2 und fr√ºheren Versionen wird fdatasync () als Aufruf von fsync () implementiert, sodass keine Leistungssteigerung erzielt wird. <br><br><blockquote>  Ab der Kernel-Version 2.6.17 bietet Linux einen nicht standardm√§√üigen Systemaufruf sync_file_range ().  Damit k√∂nnen Sie den Vorgang des L√∂schens von Dateidaten auf die Festplatte genauer steuern als mit fdatasync ().  Beim Aufrufen k√∂nnen Sie den Bereich angeben, der in der Datei gel√∂scht werden soll, und Flags setzen, die die Bedingungen f√ºr das Blockieren dieses Anrufs festlegen.  Weitere Informationen finden Sie auf der Handbuchseite von sync_file_range (2). </blockquote><br>  Der Systemaufruf sync () bewirkt, dass alle Kernelpuffer, die aktualisierte Dateiinformationen enthalten (d. H. Datenbl√∂cke, Zeigerbl√∂cke, Metadaten usw.), auf die Festplatte geleert werden. <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; void sync(void);</code> </pre> <br>  In der Linux-Implementierung gibt die Funktion sync () die Steuerung erst zur√ºck, nachdem alle Daten auf das Festplattenger√§t (oder zumindest in dessen Cache) √ºbertragen wurden.  In SUSv3 ist es jedoch zul√§ssig, dass sync () einfach die Daten√ºbertragung f√ºr die E / A-Operation in den Plan einf√ºhrt und die Steuerung zur√ºckgibt, bis die √úbertragung abgeschlossen ist. <br><br><blockquote>  Ein kontinuierlich ausgef√ºhrter Kernel-Thread l√∂scht ge√§nderte Kernel-Puffer auf die Festplatte, wenn sie 30 Sekunden lang nicht explizit synchronisiert wurden.  Dies geschieht, um zu verhindern, dass die Datenpuffer f√ºr l√§ngere Zeit nicht mit der entsprechenden Festplattendatei synchron sind (und um sie nicht dem Risiko eines Verlusts bei einem Systemausfall auszusetzen).  Unter Linux 2.6 wird diese Aufgabe vom pdflush-Kernel-Thread ausgef√ºhrt.  (Unter Linux 2.4 wurde es vom kupdated Kernel-Thread ausgef√ºhrt.) <br><br>  Der Zeitraum (in Hundertstelsekunden), nach dem der ge√§nderte Puffer durch den pdflush-Stream-Code auf die Festplatte geleert werden soll, ist in der Datei / proc / sys / vm / dirty_expire_centisecs definiert.  Zus√§tzliche Dateien im selben Verzeichnis steuern andere Funktionen des vom pdflush-Stream ausgef√ºhrten Vorgangs. <br></blockquote><br>  <b>Aktivieren Sie den Synchronisierungsmodus f√ºr alle Datens√§tze: O_SYNC</b> <br><br>  Wenn Sie beim Aufrufen von open () das O_SYNC-Flag angeben, werden alle nachfolgenden Ausgabeoperationen im synchronen Modus ausgef√ºhrt: <br><br><pre> <code class="plaintext hljs">fd = open(pathname, O_WRONLY | O_SYNC);</code> </pre> <br>  Nach diesem Aufruf von open () werden bei jeder write () -Operation, die f√ºr eine Datei ausgef√ºhrt wird, automatisch Daten und Dateimetadaten auf die Festplatte gel√∂scht (dh Schreibvorg√§nge werden als synchronisierte Schreibvorg√§nge mit Dateiintegrit√§t ausgef√ºhrt). <br><br><blockquote>  In √§lteren Versionen des BSD-Systems wurde das O_FSYNC-Flag verwendet, um die im O_SYNC-Flag enthaltenen Funktionen bereitzustellen.  In glibc ist das O_FSYNC-Flag als Synonym f√ºr O_SYNC definiert. </blockquote><br>  <b>Auswirkungen des O_SYNC-Flags auf die Leistung</b> <br><br>  Die Verwendung des O_SYNC-Flags (oder h√§ufige Aufrufe von fsync (), fdatasync () oder sync ()) kann die Leistung erheblich beeintr√§chtigen.  In der Tabelle.  Abbildung 13.3 zeigt die Zeit, die erforderlich ist, um 1 Million Byte in eine Datei zu schreiben, die gerade (im ext2-Dateisystem) f√ºr verschiedene Puffergr√∂√üen erstellt wurde, wobei das O_SYNC-Flag gesetzt und deaktiviert ist.  Die Ergebnisse wurden (unter Verwendung des im Quellcode des Buches enthaltenen Programms filebuff / write_bytes.c) unter Verwendung des Vanille-Kernels Version 2.6.30 und des ext2-Dateisystems mit einer Blockgr√∂√üe von 4096 Byte erhalten.  Jede Zeile enth√§lt den Durchschnittswert, der nach 20 Starts f√ºr eine bestimmte Puffergr√∂√üe erhalten wurde. <br><br>  Tabelle 13.3.  Die Auswirkung des O_SYNC-Flags auf eine Schreibgeschwindigkeit von 1 Million Bytes <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/va/c0/_rvac0j3fu9affstt4_poiq5ybw.png" alt="Bild"></div><br>  Wie Sie sehen k√∂nnen, f√ºhrt die Angabe des O_SYNC-Flags zu einer ungeheuren Zunahme der Zeit, die aufgewendet wird, wenn ein Puffer von 1 Byte mehr als 1000 Mal verwendet wird.  Beachten Sie auch den gro√üen Unterschied, der beim Ausf√ºhren von Datens√§tzen mit dem O_SYNC-Flag zwischen der verstrichenen Zeit und der CPU-Auslastungszeit auftritt.  Dies ist eine Folge des Blockierens der Programmausf√ºhrung, wenn der tats√§chliche Inhalt jedes Puffers auf die Festplatte geleert wird. <br><br>  In den in der Tabelle gezeigten Ergebnissen.  13.3, ein weiterer Faktor, der die Leistung bei Verwendung von O_SYNC beeinflusst, wird nicht ber√ºcksichtigt.  Moderne Festplatten haben einen gro√üen internen Cache, und standardm√§√üig √ºbertr√§gt das Setzen des O_SYNC-Flags einfach Daten in diesen Cache.  Wenn Sie das Festplatten-Caching deaktivieren (mit dem Befehl hdparm ‚ÄìW0), werden die Auswirkungen auf die Leistung von O_SYNC noch bedeutender.  Bei einer Puffergr√∂√üe von 1 Byte erh√∂ht sich die verstrichene Zeit von 1030 Sekunden auf ungef√§hr 16.000 Sekunden.  Bei einer Puffergr√∂√üe von 4096 Bytes erh√∂ht sich die verstrichene Zeit von 0,34 Sekunden auf 4 Sekunden.  Wenn Sie erzwingen m√ºssen, dass die Kernel-Puffer auf die Festplatte geleert werden, sollten Sie daher √ºberlegen, ob Sie Ihre Anwendung mit gr√∂√üeren Puffern f√ºr write () oder mit periodischen Aufrufen von fsync () oder fdatasync () anstelle des O_SYNC-Flags entwerfen k√∂nnen. <br><br>  <b>Flags O_DSYNC und O_RSYNC</b> <br><br>  SUSv3 definiert zwei zus√§tzliche Statusflags f√ºr offene Dateien, die sich auf synchronisierte E / A beziehen: O_DSYNC und O_RSYNC. <br><br>  Das O_DSYNC-Flag f√ºhrt zu nachfolgenden synchronisierten Schreibvorg√§ngen mit Datenintegrit√§t der abgeschlossenen E / A (√§hnlich wie bei Verwendung von fdatasync ()).  Der Effekt seiner Operation unterscheidet sich von der Wirkung, die durch das O_SYNC-Flag verursacht wird, dessen Verwendung zu nachfolgenden synchronisierten Schreiboperationen mit Dateiintegrit√§t f√ºhrt (wie fsync ()). <br><br>  Das O_RSYNC-Flag wird zusammen mit O_SYNC oder O_DSYNC angegeben und f√ºhrt zu einer Erweiterung des Verhaltens, das diesen Flags w√§hrend Lesevorg√§ngen zugeordnet ist.  Das Angeben der Flags O_RSYNC und O_DSYNC beim √ñffnen der Datei f√ºhrt zu nachfolgenden synchronisierten Lesevorg√§ngen mit Datenintegrit√§t (dh bevor der Lesevorgang abgeschlossen ist, werden alle ausstehenden Dateieintr√§ge aufgrund des Vorhandenseins von O_DSYNC abgeschlossen).  Die Angabe der O_RSYNC- und O_SYNC-Flags beim √ñffnen der Datei f√ºhrt zu nachfolgenden synchronisierten Lesevorg√§ngen mit Dateiintegrit√§t (dh bevor der Lesevorgang abgeschlossen ist, werden alle ausstehenden Dateieintr√§ge aufgrund des Vorhandenseins von O_SYNC abgeschlossen). <br><br>  Vor der Ver√∂ffentlichung der Kernel-Version 2.6.33 waren die Flags O_DSYNC und O_RSYNC unter Linux nicht implementiert, und diese Konstanten wurden in den Glibc-Header-Dateien als Setzen des O_SYNC-Flags definiert.  (Im Fall von O_RSYNC war dies nicht der Fall, da O_SYNC keine Funktionsmerkmale von Leseoperationen beeinflusst.) <br><br>  Ab der Kernel-Version 2.6.33 implementiert Linux das O_DSYNC-Flag, und die Implementierung des O_RSYNC-Flags wird wahrscheinlich in zuk√ºnftigen Kernel-Versionen hinzugef√ºgt. <br><br><blockquote>  Vor der Ver√∂ffentlichung des 2.6.33-Kernels unter Linux gab es keine vollst√§ndige Implementierung der O_SYNC-Semantik.  Stattdessen wurde das O_SYNC-Flag als O_DSYNC implementiert.  In Anwendungen, die mit √§lteren Versionen der GNU C-Bibliothek f√ºr √§ltere Kernel verkn√ºpft sind, verh√§lt sich das O_SYNC-Flag unter Linux-Versionen 2.6.33 und h√∂her weiterhin wie O_DSYNC.  Dies geschieht, um das vertraute Verhalten solcher Programme beizubehalten.  (Um die Abw√§rts-Bin√§rkompatibilit√§t in Kernel 2.6.33 zu gew√§hrleisten, wurde dem O_DSYNC-Flag das alte O_SYNC-Flag zugewiesen, und das neue O_SYNC-Flag enth√§lt das O_DSYNC-Flag (04010000 bzw. 010000 auf einem der Computer). Dies erm√∂glicht Anwendungen, die mit neuen Header-Dateien kompiliert wurden.) , mindestens O_DSYNC-Semantik in Kerneln erhalten, die vor Version 2.6.33 ver√∂ffentlicht wurden.) </blockquote><br><h3>  13.4.  √úbersicht √ºber die E / A-Pufferung </h3><br>  In Abb.  Abbildung 13.1 zeigt das Pufferschema (f√ºr Ausgabedateien), das von der stdio-Bibliothek und dem Kernel verwendet wird, sowie die Mechanismen zur Steuerung der einzelnen Puffertypen.  Wenn Sie das Diagramm in die Mitte verschieben, sehen Sie die √úbertragung von Benutzerdaten durch die Funktionen der stdio-Bibliothek in den stdio-Puffer, der im Benutzerspeicher arbeitet.  Wenn dieser Puffer voll ist, greift die stdio-Bibliothek auf den Systemaufruf write () zur√ºck, der Daten an den Kernel-Puffer-Cache (im Kernel-Speicher) √ºbertr√§gt.  Infolgedessen initiiert der Kernel eine Plattenoperation, um Daten auf die Platte zu √ºbertragen. <br><br>  Im linken Teil der Schaltung in Abb.  13.1 zeigt Aufrufe, die jederzeit verwendet werden k√∂nnen, um das L√∂schen eines der Puffer explizit zu erzwingen.  Der rechte Teil zeigt die Aufrufe, mit denen automatisch ein Reset durchgef√ºhrt werden kann, indem entweder die Pufferung in der stdio-Bibliothek deaktiviert oder die Dateiausgabe eines synchronen Ausf√ºhrungsmodus f√ºr Systemaufrufe aktiviert wird, sodass jeder write () -Aufruf sofort auf die Festplatte √ºbertragen wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/1f/of/cc1fofbz5pqtee-lktnypfahsac.png" alt="Bild"></div><br><br><h3>  13.5.  Kernel-E / A-Benachrichtigung </h3><br>  Mit dem Systemaufruf posix_fadvise () kann der Prozess den Kernel √ºber seine bevorzugte Methode f√ºr den Zugriff auf Dateidaten informieren. <br><br>  Der Kernel kann (muss aber nicht) die vom Systemaufruf posix_fadvise () bereitgestellten Informationen verwenden, um die Verwendung des Puffercaches zu optimieren und dadurch die E / A-Leistung f√ºr den Prozess und das gesamte System zu erh√∂hen.  Das Aufrufen von posix_fadvise () hat keinen Einfluss auf die Semantik des Programms. <br><br><pre> <code class="plaintext hljs">#define _XOPEN_SOURCE 600 #include &lt;fcntl.h&gt; int posix_fadvise(int fd, off_t offset, off_t len, int advice);</code> </pre> <br>  Gibt bei Erfolg 0 oder eine positive Fehlernummer zur√ºck, wenn sie auftritt <br><br>  Das Argument fd ist ein Dateideskriptor, der die Datei angibt, f√ºr die der Kernel kontaktiert werden muss.  Die Argumente offset und len geben den Bereich der Datei an, auf den sich die Benachrichtigung bezieht: offset gibt den anf√§nglichen Offset des Bereichs an und len gibt die Gr√∂√üe in Byte an.  Wenn Sie len auf 0 setzen, sind alle Bytes gemeint, beginnend mit dem Offset und endend mit dem Ende der Datei.  (In Kernelversionen vor 2.6.6 wurde der Wert 0 f√ºr len w√∂rtlich als 0 Byte interpretiert.) <br><br>  Das Hinweisargument zeigt die beabsichtigte Art des Zugriffs des Prozesses auf die Datei.  Es wird mit einem der folgenden Werte definiert. <br><br>  POSIX_FADV_NORMAL - Der Prozess hat keine spezielle Benachrichtigung bez√ºglich der Behandlungsmuster.  Dies ist das Standardverhalten, wenn f√ºr die Datei keine Benachrichtigungen angegeben werden.  Unter Linux wird durch diesen Vorgang das Fenster so eingestellt, dass proaktiv Daten aus einer Datei auf ihre urspr√ºngliche Gr√∂√üe (128 KB) gelesen werden. <br><br>  POSIX_FADV_SEQUENTIAL - Der Prozess umfasst das sequentielle Lesen von Daten von kleineren zu gr√∂√üeren Offsets.  Unter Linux wird durch diese Operation das Fenster so eingestellt, dass proaktiv Daten aus einer Datei gelesen werden, um den urspr√ºnglichen Wert zu verdoppeln. <br><br>  POSIX_FADV_RANDOM - Der Prozess beinhaltet den Zugriff auf Daten in zuf√§lliger Reihenfolge.  Unter Linux deaktiviert diese Option das proaktive Lesen von Daten aus einer Datei. <br><br>  POSIX_FADV_WILLNEED - Der Prozess beinhaltet den Zugriff auf den angegebenen Bereich der Datei in naher Zukunft.  Der Kernel liest pr√§ventiv Daten, um den Puffercache mit Dateidaten in dem durch die Argumente offset und len angegebenen Bereich zu f√ºllen.  Nachfolgende read () - Aufrufe der Datei blockieren nicht die Festplatten-E / A, sondern rufen einfach Daten aus dem Puffercache ab.  Der Kernel √ºbernimmt keine Garantie daf√ºr, wie lange sich die aus der Datei abgerufenen Daten im Puffercache befinden.  Wenn w√§hrend des Betriebs eines anderen Prozesses oder Kernels ein besonderer Speicherbedarf besteht, wird die Seite m√∂glicherweise wiederverwendet.  Mit anderen Worten, wenn Speicherbedarf besteht, m√ºssen wir eine kleine Zeitl√ºcke zwischen dem Aufruf von posix_fadvise () und dem nachfolgenden Aufruf (oder den Aufrufen) von read () gew√§hrleisten.  (Die Funktionalit√§t, die der Operation POSIX_FADV_WILLNEED entspricht, wird durch den Linux-spezifischen Systemaufruf readahead () bereitgestellt.) <br><br>  POSIX_FADV_DONTNEED - Der Prozess beinhaltet in naher Zukunft keine Aufrufe des angegebenen Dateibereichs.  Auf diese Weise wird der Kernel benachrichtigt, dass er die entsprechenden Cache-Seiten (falls vorhanden) freigeben kann.  Unter Linux wird dieser Vorgang in zwei Schritten ausgef√ºhrt.  Wenn die Schreibwarteschlange auf dem Hostger√§t nicht mit einer Reihe von Anforderungen gef√ºllt ist, verwirft der Kernel zun√§chst alle ge√§nderten Cache-Seiten im angegebenen Bereich.  Der Kernel versucht dann, alle Cache-Seiten aus dem angegebenen Bereich freizugeben.  Bei ge√§nderten Seiten in diesem Bereich wird die zweite Stufe nur dann erfolgreich abgeschlossen, wenn sie w√§hrend der ersten Stufe auf dem Basisger√§t aufgezeichnet wurden, dh die Aufzeichnungswarteschlange auf dem Ger√§t ist nicht voll.  Da die Anwendung den Status der Warteschlange auf dem Ger√§t nicht √ºberpr√ºfen kann, k√∂nnen Sie sicherstellen, dass die Cache-Seiten freigegeben werden, indem Sie fsync () oder fdatasync () auf dem fd-Handle aufrufen, bevor Sie POSIX_FADV_DONTNEED anwenden. <br><br>  POSIX_FADV_NOREUSE - Der Prozess beinhaltet einen einmaligen Zugriff auf Daten im angegebenen Bereich der Datei, ohne diese wiederzuverwenden.  Somit wird der Kernel benachrichtigt, dass er Seiten nach einem einzigen Zugriff auf sie freigeben kann.  Unter Linux wird dieser Vorgang derzeit ignoriert. <br><br>  Die Spezifikation posix_fadvise () wurde nur in SUSv3 angezeigt, und diese Schnittstelle wird nicht von allen UNIX-Implementierungen unterst√ºtzt.  Unter Linux wurde der Aufruf posix_fadvise () seit Kernel Version 2.6 bereitgestellt. <br><br><h3>  13.6.  Puffer-Cache-Bypass: Direkte E / A. </h3><br>  Ab Kernel Version 2.4 erm√∂glicht Linux einer Anwendung, den Puffercache bei der Ausf√ºhrung von Festplatten-E / A zu umgehen, indem Daten direkt aus dem Benutzerspeicher in eine Datei oder auf ein Festplattenger√§t verschoben werden.  Manchmal wird dieser Modus als direkte oder unverarbeitete E / A bezeichnet. <br><br><blockquote>  Die hier bereitgestellten Informationen gelten nur f√ºr Linux und sind in SUSv3 nicht standardisiert.  Einige direkte E / A-Zugriffsoptionen f√ºr Ger√§te oder Dateien werden jedoch von den meisten UNIX-Implementierungen bereitgestellt. </blockquote><br>  Manchmal wird direkte E / A missverstanden, um eine hohe E / A-Leistung zu erzielen.  Bei den meisten Anwendungen kann die Verwendung von direkten E / A die Leistung erheblich verringern.  Tatsache ist, dass der Kernel mehrere Optimierungen durchf√ºhrt, um die E / A-Leistung durch die Verwendung eines Puffercaches zu verbessern, einschlie√ülich des sequentiellen proaktiven Lesens von Daten, der Durchf√ºhrung von E / A in Clustern von Plattenbl√∂cken und der Erm√∂glichung des Zugriffs von Prozessen auf dasselbe Volume Teilen Sie in derselben Datei Puffer im Cache.  Alle diese Arten der Optimierung bei Verwendung von direkten E / A gehen verloren.  Es ist nur f√ºr Anwendungen mit speziellen E / A-Anforderungen vorgesehen, z. B. Datenbankverwaltungssysteme, die ihr eigenes Caching und ihre eigene E / A-Optimierung durchf√ºhren und f√ºr die der Kernel keine CPU-Zeit und keinen Arbeitsspeicher verschwenden muss, um dieselben Aufgaben auszuf√ºhren. <br><br>  Die direkte Eingabe / Ausgabe kann entweder in Bezug auf eine einzelne Datei oder in Bezug auf ein Blockger√§t (z. B. eine Festplatte) erfolgen.  Zu diesem Zweck wird beim √ñffnen einer Datei oder eines Ger√§ts mit dem Aufruf open () das Flag O_DIRECT angegeben. <br><br>  Das O_DIRECT-Flag funktioniert seit Kernel-Version 2.4.10.  Die Verwendung dieses Flags wird nicht von allen Dateisystemen und Versionen des Linux-Kernels unterst√ºtzt.  Die meisten grundlegenden Dateisysteme unterst√ºtzen das O_DIRECT-Flag, viele Nicht-UNIX-Dateisysteme (wie VFAT) jedoch nicht.  Sie k√∂nnen die Unterst√ºtzung f√ºr diese Funktion testen, indem Sie das ausgew√§hlte Dateisystem testen (wenn das Dateisystem O_DIRECT nicht unterst√ºtzt, schl√§gt der Aufruf von open () mit einem EINVAL-Fehler fehl) oder indem Sie den Kernel-Quellcode darauf untersuchen. <br><br><blockquote>  Wenn ein Prozess die Datei mit dem O_DIRECT-Flag ge√∂ffnet hat und der andere auf die √ºbliche Weise (dh unter Verwendung des Puffercaches), besteht keine Konsistenz zwischen dem Inhalt des Puffercaches und den Daten, die √ºber direkte E / A gelesen oder geschrieben wurden.  Eine solche Entwicklung sollte vermieden werden. <br><br>  Informationen zur veralteten (jetzt nicht empfohlenen) Methode, um unformatierten Zugriff auf ein Festplattenger√§t zu erhalten, finden Sie auf der rohen (8) Handbuchseite. </blockquote><br>  <b>Ausrichtungsbeschr√§nkungen f√ºr direkte E / A.</b> <br><br>  Da direkte E / A (sowohl auf Festplattenger√§ten als auch in Bezug auf Dateien) direkten Zugriff auf die Festplatte beinhalten, m√ºssen bei der Ausf√ºhrung von E / A einige Einschr√§nkungen beachtet werden. <br><br>  - Der tragbare Datenpuffer sollte an der Speichergrenze ausgerichtet sein, ein Vielfaches der Blockgr√∂√üe. <br><br>  - Der Offset in der Datei oder im Ger√§t, von dem aus die √ºbertragenen Daten beginnen, muss ein Vielfaches der Blockgr√∂√üe betragen. <br><br>  - Die L√§nge der √ºbertragenen Daten muss ein Vielfaches der Blockgr√∂√üe betragen. <br><br>  Die Nichteinhaltung einer dieser Einschr√§nkungen f√ºhrt zu einem EINVAL-Fehler.  In der obigen Liste bezieht sich die Blockgr√∂√üe auf die Gr√∂√üe des physischen Blocks des Ger√§ts (normalerweise 512 Byte). <br><br><blockquote>  Bei der Ausf√ºhrung direkter E / A unter Linux 2.4 gelten mehr Einschr√§nkungen als unter Linux 2.6: Ausrichtung, L√§nge und Versatz m√ºssen ein Vielfaches der Gr√∂√üe des logischen Blocks des verwendeten Dateisystems betragen.  (Normalerweise betr√§gt die Gr√∂√üe der logischen Bl√∂cke in einem Dateisystem 1024, 2048 oder 4096 Byte.) <br></blockquote><br>  <b>Programmbeispiel</b> <br><br>   13.1     O_DIRECT     .        ,  (  ) ,     ,     , ,     ,       ,    ,  read().               4096 . <br><br>   ,      : <br><br><pre> <code class="plaintext hljs">$ ./direct_read /test/x 512  512    0 Read 512 bytes  $ ./direct_read /test/x 256 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 512 1 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 4096 8192 512 Read 4096 bytes  $ ./direct_read /test/x 4096 512 256 ERROR [EINVAL Invalid argument] read    512</code> </pre> <br><blockquote>    13.1   ,    ,    ,      memalign().  memalign()    7.1.4. </blockquote><br><pre> <code class="plaintext hljs">#define _GNU_SOURCE /*   O_DIRECT  &lt;fcntl.h&gt; */ #include &lt;fcntl.h&gt; #include &lt;malloc.h&gt; #include "tlpi_hdr.h" int main(int argc, char *argv[]) { int fd; ssize_t numRead; size_t length, alignment; off_t offset; void *buf; if (argc &lt; 3 || strcmp(argv[1], "‚Äìhelp") == 0) usageErr("%s file length [offset [alignment]]\n", argv[0]); length = getLong(argv[2], GN_ANY_BASE, "length"); offset = (argc &gt; 3) ? getLong(argv[3], GN_ANY_BASE, "offset") : 0; alignment = (argc &gt; 4) ? getLong(argv[4], GN_ANY_BASE, "alignment") : 4096; fd = open(argv[1], O_RDONLY | O_DIRECT); if (fd == -1) errExit("open"); /*  memalign()   ,   ,    .     'buf'  ,  'alignment',     .    ,   ,  ,    ,  256 ,     ,     512- .    '(char *)'        (     'void *',   memalign(). */ buf = (char *) memalign(alignment * 2, length + alignment) + alignment; if (buf == NULL) errExit("memalign"); if (lseek(fd, offset, SEEK_SET) == -1) errExit("lseek"); numRead = read(fd, buf, length); if (numRead == -1) errExit("read"); printf("Read %ld bytes\n", (long) numRead); exit(EXIT_SUCCESS); } _______________________________________________________________filebuff/direct_read.c</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ªWeitere Informationen zum Buch finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Website des Herausgebers</font></font></a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20% Rabatt auf Gutschein f√ºr </font><b><font style="vertical-align: inherit;">Linux</font></b><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436986/">https://habr.com/ru/post/de436986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436976/index.html">Integration der KeePass-Kennwort√ºberpr√ºfung in die Leckdatenbank</a></li>
<li><a href="../de436978/index.html">Programmierbare TOTP-Token in einem Schl√ºsselanh√§nger-Formfaktor</a></li>
<li><a href="../de436980/index.html">K√ºnstliche Intelligenz - Der Weltuntergang oder das goldene Zeitalter des globalen Wohlstands</a></li>
<li><a href="../de436982/index.html">Sicherheitswoche 04: Was tun mit Passw√∂rtern?</a></li>
<li><a href="../de436984/index.html">Microsoft unterst√ºtzt Windows 10 Mobile nicht mehr</a></li>
<li><a href="../de436988/index.html">Kamera, Motor, Big Data: Wie Filmstudios mithilfe von KI nach neuen Filmen suchen</a></li>
<li><a href="../de436990/index.html">Zimbra und Zextras Suite sind vollst√§ndig kompatibel mit NTC IT ROSA-Betriebssystemen</a></li>
<li><a href="../de436992/index.html">Versuch und Irrtum bei der Auswahl von HTTP Reverse Proxy</a></li>
<li><a href="../de436994/index.html">Liquibase und Maven</a></li>
<li><a href="../de436996/index.html">Abschlusskurs zur Python-Spezialisierung von Mail.ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>