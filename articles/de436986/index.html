<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎑 💃🏼 🍞 Linux API Verwalten der Kernel-Datei-E / A-Pufferung 👩🏻‍🌾 🎚️ 👱🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Wir haben bereits über Michael Kerrisks Buch „Linux API. Umfassender Leitfaden . “ Jetzt haben wir beschlossen, einen Auszug aus d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux API Verwalten der Kernel-Datei-E / A-Pufferung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/436986/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/qk/pj/rf/qkpjrftqtsq-bnryowiwf_v88us.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  Wir haben bereits über Michael Kerrisks Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Linux API.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umfassender Leitfaden</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">“</a>  Jetzt haben wir beschlossen, einen Auszug aus dem Buch "Verwalten der im Kernel verwalteten Datei-E / A-Pufferung" zu veröffentlichen. <br><br>  Das Zurücksetzen des Kernel-Pufferspeichers für Ausgabedateien kann erzwungen werden.  Manchmal ist dies erforderlich, wenn die Anwendung vor der Fortsetzung der Arbeit (z. B. Änderungen einer Prozessprotokollierungsdatenbank) sicherstellen muss, dass die tatsächliche Ausgabe auf die Festplatte (oder zumindest in den Hardware-Festplatten-Cache) geschrieben wird. <br><br>  Bevor auf die Systemaufrufe eingegangen wird, die zur Steuerung der Kernel-Pufferung verwendet werden, sollten einige verwandte Definitionen aus SUSv3 betrachtet werden. <br><a name="habracut"></a><br>  <b>Synchronisierte E / A mit Daten- und Dateiintegrität</b> <br><br>  In SUSv3 bedeutet das Konzept der synchronisierten E / A-Vervollständigung "eine E / A-Operation, die entweder zu einer erfolgreichen Datenübertragung [auf die Festplatte] führte oder als nicht erfolgreich diagnostiziert wurde". <br><br>  SUSv3 definiert zwei verschiedene Arten von synchronisierten E / A-Abschlüssen.  Der Unterschied zwischen den Typen bezieht sich auf Metadaten („Daten über Daten“), die die Datei beschreiben.  Der Kernel speichert sie zusammen mit den Daten der Datei selbst.  Details zu Dateimetadaten werden in Abschnitt 14.4 bei der Untersuchung von Dateiinodes erläutert.  In der Zwischenzeit reicht es aus zu beachten, dass Dateimetadaten Informationen wie Informationen über den Eigentümer der Datei und ihre Gruppe, Zugriffsrechte auf die Datei, Dateigröße, Anzahl der festen Links zur Datei, Zeitstempel, die den Zeitpunkt des letzten Zugriffs auf die Datei und den Zeitpunkt der letzten Änderung enthalten, enthalten und die Zeit der letzten Metadatenänderung sowie Zeiger auf Datenblöcke. <br><br>  Die erste Art der synchronisierten E / A-Vervollständigung in SUSv3 ist die Vervollständigung der Datenintegrität.  Bei der Aktualisierung der Dateidaten sollte die Übertragung von Informationen sichergestellt sein, die ausreichen, um die weitere Extraktion dieser Daten zu ermöglichen, damit sie weiterarbeiten können. <br><br>  - Für einen Lesevorgang bedeutet dies, dass die angeforderten Dateidaten (von der Festplatte) an den Prozess übertragen wurden.  Wenn anstehende Schreibvorgänge vorliegen, die sich auf die angeforderten Daten auswirken können, werden die Daten vor dem Lesen auf die Festplatte übertragen. <br><br>  - Für einen Schreibvorgang bedeutet dies, dass die in der Schreibanforderung angegebenen Daten (auf die Festplatte) übertragen wurden, wie alle zum Extrahieren dieser Daten erforderlichen Dateimetadaten.  Der wichtigste Punkt, den Sie beachten sollten: Um sicherzustellen, dass Daten aus der geänderten Datei extrahiert werden, müssen nicht alle Medatendateien übertragen werden.  Ein Beispiel für das Metadatenattribut einer geänderten Datei, die migriert werden muss, ist ihre Größe (wenn der Schreibvorgang die Dateigröße erhöht).  Im Gegensatz dazu müssen die Zeitstempel der zu ändernden Datei nicht auf die Festplatte übertragen werden, bevor der anschließende Datenabruf erfolgt. <br><br>  Der zweite in SUSv3 definierte Typ der synchronisierten E / A-Vervollständigung ist die Vervollständigung der Dateiintegrität.  Dies ist eine erweiterte Option zum Abschließen synchronisierter E / A mit Datenintegrität.  Der Unterschied zwischen diesem Modus besteht darin, dass während der Aktualisierung der Datei alle Metadaten auf die Festplatte übertragen werden, auch wenn dies für die nachfolgende Extraktion der Dateidaten nicht erforderlich ist. <br><br>  <b>Systemaufrufe zur Steuerung der Kernel-Pufferung während der Datei-E / A.</b> <br><br>  Der Systemaufruf fsync () setzt alle gepufferten Daten und alle Metadaten zurück, die einer geöffneten Datei mit einem fd-Deskriptor zugeordnet sind.  Durch Aufrufen von fsync () wird die Datei nach Abschluss der synchronen E / A in einen Integritätszustand (Datei) versetzt. <br><br>  Der Aufruf von fsync () gibt die Steuerung erst zurück, nachdem die Datenübertragung zum Festplattengerät (oder zumindest zu seinem Cache) abgeschlossen ist. <br><br><pre><code class="plaintext hljs">#include &lt;unistd.h&gt; int fsync(int fd);</code> </pre> <br>  Gibt bei Erfolg 0 oder -1 bei Fehler zurück <br><br>  Der Systemaufruf fdatasync () funktioniert genau wie fsync (), versetzt die Datei jedoch nach Abschluss der synchronen E / A in einen Integritätszustand (Daten). <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; int fdatasync(int fd);</code> </pre> <br>  Gibt bei Erfolg 0 oder -1 bei Fehler zurück <br><br>  Durch die Verwendung von fdatasync () wird möglicherweise die Anzahl der für den Systemaufruf fsync () erforderlichen Festplattenvorgänge von zwei auf eins reduziert.  Wenn sich beispielsweise die Dateidaten geändert haben, die Größe jedoch gleich bleibt, werden beim Aufrufen von fdatasync () nur die Daten aktualisiert.  (Es wurde bereits oben erwähnt, dass zum Abschließen eines synchronen E / A-Vorgangs mit Datenintegrität keine Änderungen an Attributen wie dem Zeitpunkt der letzten Änderung der Datei übertragen werden müssen.) Im Gegensatz dazu erzwingt der Aufruf von fsync () auch die Übertragung von Metadaten auf die Festplatte. <br><br>  Eine solche Reduzierung der Anzahl der Festplatten-E / A-Vorgänge ist für einzelne Anwendungen nützlich, für die die Leistung und die genaue Aktualisierung bestimmter Metadaten (z. B. Zeitstempel) eine entscheidende Rolle spielen.  Dies kann zu erheblichen Leistungsverbesserungen für Anwendungen führen, die mehrere Dateiaktualisierungen gleichzeitig erstellen.  Da sich Dateidaten und Metadaten normalerweise in verschiedenen Teilen der Festplatte befinden, erfordert das Aktualisieren beider Daten eine wiederholte Vorwärts- und Rückwärtssuche auf der Festplatte. <br><br>  Unter Linux 2.2 und früheren Versionen wird fdatasync () als Aufruf von fsync () implementiert, sodass keine Leistungssteigerung erzielt wird. <br><br><blockquote>  Ab der Kernel-Version 2.6.17 bietet Linux einen nicht standardmäßigen Systemaufruf sync_file_range ().  Damit können Sie den Vorgang des Löschens von Dateidaten auf die Festplatte genauer steuern als mit fdatasync ().  Beim Aufrufen können Sie den Bereich angeben, der in der Datei gelöscht werden soll, und Flags setzen, die die Bedingungen für das Blockieren dieses Anrufs festlegen.  Weitere Informationen finden Sie auf der Handbuchseite von sync_file_range (2). </blockquote><br>  Der Systemaufruf sync () bewirkt, dass alle Kernelpuffer, die aktualisierte Dateiinformationen enthalten (d. H. Datenblöcke, Zeigerblöcke, Metadaten usw.), auf die Festplatte geleert werden. <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; void sync(void);</code> </pre> <br>  In der Linux-Implementierung gibt die Funktion sync () die Steuerung erst zurück, nachdem alle Daten auf das Festplattengerät (oder zumindest in dessen Cache) übertragen wurden.  In SUSv3 ist es jedoch zulässig, dass sync () einfach die Datenübertragung für die E / A-Operation in den Plan einführt und die Steuerung zurückgibt, bis die Übertragung abgeschlossen ist. <br><br><blockquote>  Ein kontinuierlich ausgeführter Kernel-Thread löscht geänderte Kernel-Puffer auf die Festplatte, wenn sie 30 Sekunden lang nicht explizit synchronisiert wurden.  Dies geschieht, um zu verhindern, dass die Datenpuffer für längere Zeit nicht mit der entsprechenden Festplattendatei synchron sind (und um sie nicht dem Risiko eines Verlusts bei einem Systemausfall auszusetzen).  Unter Linux 2.6 wird diese Aufgabe vom pdflush-Kernel-Thread ausgeführt.  (Unter Linux 2.4 wurde es vom kupdated Kernel-Thread ausgeführt.) <br><br>  Der Zeitraum (in Hundertstelsekunden), nach dem der geänderte Puffer durch den pdflush-Stream-Code auf die Festplatte geleert werden soll, ist in der Datei / proc / sys / vm / dirty_expire_centisecs definiert.  Zusätzliche Dateien im selben Verzeichnis steuern andere Funktionen des vom pdflush-Stream ausgeführten Vorgangs. <br></blockquote><br>  <b>Aktivieren Sie den Synchronisierungsmodus für alle Datensätze: O_SYNC</b> <br><br>  Wenn Sie beim Aufrufen von open () das O_SYNC-Flag angeben, werden alle nachfolgenden Ausgabeoperationen im synchronen Modus ausgeführt: <br><br><pre> <code class="plaintext hljs">fd = open(pathname, O_WRONLY | O_SYNC);</code> </pre> <br>  Nach diesem Aufruf von open () werden bei jeder write () -Operation, die für eine Datei ausgeführt wird, automatisch Daten und Dateimetadaten auf die Festplatte gelöscht (dh Schreibvorgänge werden als synchronisierte Schreibvorgänge mit Dateiintegrität ausgeführt). <br><br><blockquote>  In älteren Versionen des BSD-Systems wurde das O_FSYNC-Flag verwendet, um die im O_SYNC-Flag enthaltenen Funktionen bereitzustellen.  In glibc ist das O_FSYNC-Flag als Synonym für O_SYNC definiert. </blockquote><br>  <b>Auswirkungen des O_SYNC-Flags auf die Leistung</b> <br><br>  Die Verwendung des O_SYNC-Flags (oder häufige Aufrufe von fsync (), fdatasync () oder sync ()) kann die Leistung erheblich beeinträchtigen.  In der Tabelle.  Abbildung 13.3 zeigt die Zeit, die erforderlich ist, um 1 Million Byte in eine Datei zu schreiben, die gerade (im ext2-Dateisystem) für verschiedene Puffergrößen erstellt wurde, wobei das O_SYNC-Flag gesetzt und deaktiviert ist.  Die Ergebnisse wurden (unter Verwendung des im Quellcode des Buches enthaltenen Programms filebuff / write_bytes.c) unter Verwendung des Vanille-Kernels Version 2.6.30 und des ext2-Dateisystems mit einer Blockgröße von 4096 Byte erhalten.  Jede Zeile enthält den Durchschnittswert, der nach 20 Starts für eine bestimmte Puffergröße erhalten wurde. <br><br>  Tabelle 13.3.  Die Auswirkung des O_SYNC-Flags auf eine Schreibgeschwindigkeit von 1 Million Bytes <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/va/c0/_rvac0j3fu9affstt4_poiq5ybw.png" alt="Bild"></div><br>  Wie Sie sehen können, führt die Angabe des O_SYNC-Flags zu einer ungeheuren Zunahme der Zeit, die aufgewendet wird, wenn ein Puffer von 1 Byte mehr als 1000 Mal verwendet wird.  Beachten Sie auch den großen Unterschied, der beim Ausführen von Datensätzen mit dem O_SYNC-Flag zwischen der verstrichenen Zeit und der CPU-Auslastungszeit auftritt.  Dies ist eine Folge des Blockierens der Programmausführung, wenn der tatsächliche Inhalt jedes Puffers auf die Festplatte geleert wird. <br><br>  In den in der Tabelle gezeigten Ergebnissen.  13.3, ein weiterer Faktor, der die Leistung bei Verwendung von O_SYNC beeinflusst, wird nicht berücksichtigt.  Moderne Festplatten haben einen großen internen Cache, und standardmäßig überträgt das Setzen des O_SYNC-Flags einfach Daten in diesen Cache.  Wenn Sie das Festplatten-Caching deaktivieren (mit dem Befehl hdparm –W0), werden die Auswirkungen auf die Leistung von O_SYNC noch bedeutender.  Bei einer Puffergröße von 1 Byte erhöht sich die verstrichene Zeit von 1030 Sekunden auf ungefähr 16.000 Sekunden.  Bei einer Puffergröße von 4096 Bytes erhöht sich die verstrichene Zeit von 0,34 Sekunden auf 4 Sekunden.  Wenn Sie erzwingen müssen, dass die Kernel-Puffer auf die Festplatte geleert werden, sollten Sie daher überlegen, ob Sie Ihre Anwendung mit größeren Puffern für write () oder mit periodischen Aufrufen von fsync () oder fdatasync () anstelle des O_SYNC-Flags entwerfen können. <br><br>  <b>Flags O_DSYNC und O_RSYNC</b> <br><br>  SUSv3 definiert zwei zusätzliche Statusflags für offene Dateien, die sich auf synchronisierte E / A beziehen: O_DSYNC und O_RSYNC. <br><br>  Das O_DSYNC-Flag führt zu nachfolgenden synchronisierten Schreibvorgängen mit Datenintegrität der abgeschlossenen E / A (ähnlich wie bei Verwendung von fdatasync ()).  Der Effekt seiner Operation unterscheidet sich von der Wirkung, die durch das O_SYNC-Flag verursacht wird, dessen Verwendung zu nachfolgenden synchronisierten Schreiboperationen mit Dateiintegrität führt (wie fsync ()). <br><br>  Das O_RSYNC-Flag wird zusammen mit O_SYNC oder O_DSYNC angegeben und führt zu einer Erweiterung des Verhaltens, das diesen Flags während Lesevorgängen zugeordnet ist.  Das Angeben der Flags O_RSYNC und O_DSYNC beim Öffnen der Datei führt zu nachfolgenden synchronisierten Lesevorgängen mit Datenintegrität (dh bevor der Lesevorgang abgeschlossen ist, werden alle ausstehenden Dateieinträge aufgrund des Vorhandenseins von O_DSYNC abgeschlossen).  Die Angabe der O_RSYNC- und O_SYNC-Flags beim Öffnen der Datei führt zu nachfolgenden synchronisierten Lesevorgängen mit Dateiintegrität (dh bevor der Lesevorgang abgeschlossen ist, werden alle ausstehenden Dateieinträge aufgrund des Vorhandenseins von O_SYNC abgeschlossen). <br><br>  Vor der Veröffentlichung der Kernel-Version 2.6.33 waren die Flags O_DSYNC und O_RSYNC unter Linux nicht implementiert, und diese Konstanten wurden in den Glibc-Header-Dateien als Setzen des O_SYNC-Flags definiert.  (Im Fall von O_RSYNC war dies nicht der Fall, da O_SYNC keine Funktionsmerkmale von Leseoperationen beeinflusst.) <br><br>  Ab der Kernel-Version 2.6.33 implementiert Linux das O_DSYNC-Flag, und die Implementierung des O_RSYNC-Flags wird wahrscheinlich in zukünftigen Kernel-Versionen hinzugefügt. <br><br><blockquote>  Vor der Veröffentlichung des 2.6.33-Kernels unter Linux gab es keine vollständige Implementierung der O_SYNC-Semantik.  Stattdessen wurde das O_SYNC-Flag als O_DSYNC implementiert.  In Anwendungen, die mit älteren Versionen der GNU C-Bibliothek für ältere Kernel verknüpft sind, verhält sich das O_SYNC-Flag unter Linux-Versionen 2.6.33 und höher weiterhin wie O_DSYNC.  Dies geschieht, um das vertraute Verhalten solcher Programme beizubehalten.  (Um die Abwärts-Binärkompatibilität in Kernel 2.6.33 zu gewährleisten, wurde dem O_DSYNC-Flag das alte O_SYNC-Flag zugewiesen, und das neue O_SYNC-Flag enthält das O_DSYNC-Flag (04010000 bzw. 010000 auf einem der Computer). Dies ermöglicht Anwendungen, die mit neuen Header-Dateien kompiliert wurden.) , mindestens O_DSYNC-Semantik in Kerneln erhalten, die vor Version 2.6.33 veröffentlicht wurden.) </blockquote><br><h3>  13.4.  Übersicht über die E / A-Pufferung </h3><br>  In Abb.  Abbildung 13.1 zeigt das Pufferschema (für Ausgabedateien), das von der stdio-Bibliothek und dem Kernel verwendet wird, sowie die Mechanismen zur Steuerung der einzelnen Puffertypen.  Wenn Sie das Diagramm in die Mitte verschieben, sehen Sie die Übertragung von Benutzerdaten durch die Funktionen der stdio-Bibliothek in den stdio-Puffer, der im Benutzerspeicher arbeitet.  Wenn dieser Puffer voll ist, greift die stdio-Bibliothek auf den Systemaufruf write () zurück, der Daten an den Kernel-Puffer-Cache (im Kernel-Speicher) überträgt.  Infolgedessen initiiert der Kernel eine Plattenoperation, um Daten auf die Platte zu übertragen. <br><br>  Im linken Teil der Schaltung in Abb.  13.1 zeigt Aufrufe, die jederzeit verwendet werden können, um das Löschen eines der Puffer explizit zu erzwingen.  Der rechte Teil zeigt die Aufrufe, mit denen automatisch ein Reset durchgeführt werden kann, indem entweder die Pufferung in der stdio-Bibliothek deaktiviert oder die Dateiausgabe eines synchronen Ausführungsmodus für Systemaufrufe aktiviert wird, sodass jeder write () -Aufruf sofort auf die Festplatte übertragen wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/1f/of/cc1fofbz5pqtee-lktnypfahsac.png" alt="Bild"></div><br><br><h3>  13.5.  Kernel-E / A-Benachrichtigung </h3><br>  Mit dem Systemaufruf posix_fadvise () kann der Prozess den Kernel über seine bevorzugte Methode für den Zugriff auf Dateidaten informieren. <br><br>  Der Kernel kann (muss aber nicht) die vom Systemaufruf posix_fadvise () bereitgestellten Informationen verwenden, um die Verwendung des Puffercaches zu optimieren und dadurch die E / A-Leistung für den Prozess und das gesamte System zu erhöhen.  Das Aufrufen von posix_fadvise () hat keinen Einfluss auf die Semantik des Programms. <br><br><pre> <code class="plaintext hljs">#define _XOPEN_SOURCE 600 #include &lt;fcntl.h&gt; int posix_fadvise(int fd, off_t offset, off_t len, int advice);</code> </pre> <br>  Gibt bei Erfolg 0 oder eine positive Fehlernummer zurück, wenn sie auftritt <br><br>  Das Argument fd ist ein Dateideskriptor, der die Datei angibt, für die der Kernel kontaktiert werden muss.  Die Argumente offset und len geben den Bereich der Datei an, auf den sich die Benachrichtigung bezieht: offset gibt den anfänglichen Offset des Bereichs an und len gibt die Größe in Byte an.  Wenn Sie len auf 0 setzen, sind alle Bytes gemeint, beginnend mit dem Offset und endend mit dem Ende der Datei.  (In Kernelversionen vor 2.6.6 wurde der Wert 0 für len wörtlich als 0 Byte interpretiert.) <br><br>  Das Hinweisargument zeigt die beabsichtigte Art des Zugriffs des Prozesses auf die Datei.  Es wird mit einem der folgenden Werte definiert. <br><br>  POSIX_FADV_NORMAL - Der Prozess hat keine spezielle Benachrichtigung bezüglich der Behandlungsmuster.  Dies ist das Standardverhalten, wenn für die Datei keine Benachrichtigungen angegeben werden.  Unter Linux wird durch diesen Vorgang das Fenster so eingestellt, dass proaktiv Daten aus einer Datei auf ihre ursprüngliche Größe (128 KB) gelesen werden. <br><br>  POSIX_FADV_SEQUENTIAL - Der Prozess umfasst das sequentielle Lesen von Daten von kleineren zu größeren Offsets.  Unter Linux wird durch diese Operation das Fenster so eingestellt, dass proaktiv Daten aus einer Datei gelesen werden, um den ursprünglichen Wert zu verdoppeln. <br><br>  POSIX_FADV_RANDOM - Der Prozess beinhaltet den Zugriff auf Daten in zufälliger Reihenfolge.  Unter Linux deaktiviert diese Option das proaktive Lesen von Daten aus einer Datei. <br><br>  POSIX_FADV_WILLNEED - Der Prozess beinhaltet den Zugriff auf den angegebenen Bereich der Datei in naher Zukunft.  Der Kernel liest präventiv Daten, um den Puffercache mit Dateidaten in dem durch die Argumente offset und len angegebenen Bereich zu füllen.  Nachfolgende read () - Aufrufe der Datei blockieren nicht die Festplatten-E / A, sondern rufen einfach Daten aus dem Puffercache ab.  Der Kernel übernimmt keine Garantie dafür, wie lange sich die aus der Datei abgerufenen Daten im Puffercache befinden.  Wenn während des Betriebs eines anderen Prozesses oder Kernels ein besonderer Speicherbedarf besteht, wird die Seite möglicherweise wiederverwendet.  Mit anderen Worten, wenn Speicherbedarf besteht, müssen wir eine kleine Zeitlücke zwischen dem Aufruf von posix_fadvise () und dem nachfolgenden Aufruf (oder den Aufrufen) von read () gewährleisten.  (Die Funktionalität, die der Operation POSIX_FADV_WILLNEED entspricht, wird durch den Linux-spezifischen Systemaufruf readahead () bereitgestellt.) <br><br>  POSIX_FADV_DONTNEED - Der Prozess beinhaltet in naher Zukunft keine Aufrufe des angegebenen Dateibereichs.  Auf diese Weise wird der Kernel benachrichtigt, dass er die entsprechenden Cache-Seiten (falls vorhanden) freigeben kann.  Unter Linux wird dieser Vorgang in zwei Schritten ausgeführt.  Wenn die Schreibwarteschlange auf dem Hostgerät nicht mit einer Reihe von Anforderungen gefüllt ist, verwirft der Kernel zunächst alle geänderten Cache-Seiten im angegebenen Bereich.  Der Kernel versucht dann, alle Cache-Seiten aus dem angegebenen Bereich freizugeben.  Bei geänderten Seiten in diesem Bereich wird die zweite Stufe nur dann erfolgreich abgeschlossen, wenn sie während der ersten Stufe auf dem Basisgerät aufgezeichnet wurden, dh die Aufzeichnungswarteschlange auf dem Gerät ist nicht voll.  Da die Anwendung den Status der Warteschlange auf dem Gerät nicht überprüfen kann, können Sie sicherstellen, dass die Cache-Seiten freigegeben werden, indem Sie fsync () oder fdatasync () auf dem fd-Handle aufrufen, bevor Sie POSIX_FADV_DONTNEED anwenden. <br><br>  POSIX_FADV_NOREUSE - Der Prozess beinhaltet einen einmaligen Zugriff auf Daten im angegebenen Bereich der Datei, ohne diese wiederzuverwenden.  Somit wird der Kernel benachrichtigt, dass er Seiten nach einem einzigen Zugriff auf sie freigeben kann.  Unter Linux wird dieser Vorgang derzeit ignoriert. <br><br>  Die Spezifikation posix_fadvise () wurde nur in SUSv3 angezeigt, und diese Schnittstelle wird nicht von allen UNIX-Implementierungen unterstützt.  Unter Linux wurde der Aufruf posix_fadvise () seit Kernel Version 2.6 bereitgestellt. <br><br><h3>  13.6.  Puffer-Cache-Bypass: Direkte E / A. </h3><br>  Ab Kernel Version 2.4 ermöglicht Linux einer Anwendung, den Puffercache bei der Ausführung von Festplatten-E / A zu umgehen, indem Daten direkt aus dem Benutzerspeicher in eine Datei oder auf ein Festplattengerät verschoben werden.  Manchmal wird dieser Modus als direkte oder unverarbeitete E / A bezeichnet. <br><br><blockquote>  Die hier bereitgestellten Informationen gelten nur für Linux und sind in SUSv3 nicht standardisiert.  Einige direkte E / A-Zugriffsoptionen für Geräte oder Dateien werden jedoch von den meisten UNIX-Implementierungen bereitgestellt. </blockquote><br>  Manchmal wird direkte E / A missverstanden, um eine hohe E / A-Leistung zu erzielen.  Bei den meisten Anwendungen kann die Verwendung von direkten E / A die Leistung erheblich verringern.  Tatsache ist, dass der Kernel mehrere Optimierungen durchführt, um die E / A-Leistung durch die Verwendung eines Puffercaches zu verbessern, einschließlich des sequentiellen proaktiven Lesens von Daten, der Durchführung von E / A in Clustern von Plattenblöcken und der Ermöglichung des Zugriffs von Prozessen auf dasselbe Volume Teilen Sie in derselben Datei Puffer im Cache.  Alle diese Arten der Optimierung bei Verwendung von direkten E / A gehen verloren.  Es ist nur für Anwendungen mit speziellen E / A-Anforderungen vorgesehen, z. B. Datenbankverwaltungssysteme, die ihr eigenes Caching und ihre eigene E / A-Optimierung durchführen und für die der Kernel keine CPU-Zeit und keinen Arbeitsspeicher verschwenden muss, um dieselben Aufgaben auszuführen. <br><br>  Die direkte Eingabe / Ausgabe kann entweder in Bezug auf eine einzelne Datei oder in Bezug auf ein Blockgerät (z. B. eine Festplatte) erfolgen.  Zu diesem Zweck wird beim Öffnen einer Datei oder eines Geräts mit dem Aufruf open () das Flag O_DIRECT angegeben. <br><br>  Das O_DIRECT-Flag funktioniert seit Kernel-Version 2.4.10.  Die Verwendung dieses Flags wird nicht von allen Dateisystemen und Versionen des Linux-Kernels unterstützt.  Die meisten grundlegenden Dateisysteme unterstützen das O_DIRECT-Flag, viele Nicht-UNIX-Dateisysteme (wie VFAT) jedoch nicht.  Sie können die Unterstützung für diese Funktion testen, indem Sie das ausgewählte Dateisystem testen (wenn das Dateisystem O_DIRECT nicht unterstützt, schlägt der Aufruf von open () mit einem EINVAL-Fehler fehl) oder indem Sie den Kernel-Quellcode darauf untersuchen. <br><br><blockquote>  Wenn ein Prozess die Datei mit dem O_DIRECT-Flag geöffnet hat und der andere auf die übliche Weise (dh unter Verwendung des Puffercaches), besteht keine Konsistenz zwischen dem Inhalt des Puffercaches und den Daten, die über direkte E / A gelesen oder geschrieben wurden.  Eine solche Entwicklung sollte vermieden werden. <br><br>  Informationen zur veralteten (jetzt nicht empfohlenen) Methode, um unformatierten Zugriff auf ein Festplattengerät zu erhalten, finden Sie auf der rohen (8) Handbuchseite. </blockquote><br>  <b>Ausrichtungsbeschränkungen für direkte E / A.</b> <br><br>  Da direkte E / A (sowohl auf Festplattengeräten als auch in Bezug auf Dateien) direkten Zugriff auf die Festplatte beinhalten, müssen bei der Ausführung von E / A einige Einschränkungen beachtet werden. <br><br>  - Der tragbare Datenpuffer sollte an der Speichergrenze ausgerichtet sein, ein Vielfaches der Blockgröße. <br><br>  - Der Offset in der Datei oder im Gerät, von dem aus die übertragenen Daten beginnen, muss ein Vielfaches der Blockgröße betragen. <br><br>  - Die Länge der übertragenen Daten muss ein Vielfaches der Blockgröße betragen. <br><br>  Die Nichteinhaltung einer dieser Einschränkungen führt zu einem EINVAL-Fehler.  In der obigen Liste bezieht sich die Blockgröße auf die Größe des physischen Blocks des Geräts (normalerweise 512 Byte). <br><br><blockquote>  Bei der Ausführung direkter E / A unter Linux 2.4 gelten mehr Einschränkungen als unter Linux 2.6: Ausrichtung, Länge und Versatz müssen ein Vielfaches der Größe des logischen Blocks des verwendeten Dateisystems betragen.  (Normalerweise beträgt die Größe der logischen Blöcke in einem Dateisystem 1024, 2048 oder 4096 Byte.) <br></blockquote><br>  <b>Programmbeispiel</b> <br><br>   13.1     O_DIRECT     .        ,  (  ) ,     ,     , ,     ,       ,    ,  read().               4096 . <br><br>   ,      : <br><br><pre> <code class="plaintext hljs">$ ./direct_read /test/x 512  512    0 Read 512 bytes  $ ./direct_read /test/x 256 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 512 1 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 4096 8192 512 Read 4096 bytes  $ ./direct_read /test/x 4096 512 256 ERROR [EINVAL Invalid argument] read    512</code> </pre> <br><blockquote>    13.1   ,    ,    ,      memalign().  memalign()    7.1.4. </blockquote><br><pre> <code class="plaintext hljs">#define _GNU_SOURCE /*   O_DIRECT  &lt;fcntl.h&gt; */ #include &lt;fcntl.h&gt; #include &lt;malloc.h&gt; #include "tlpi_hdr.h" int main(int argc, char *argv[]) { int fd; ssize_t numRead; size_t length, alignment; off_t offset; void *buf; if (argc &lt; 3 || strcmp(argv[1], "–help") == 0) usageErr("%s file length [offset [alignment]]\n", argv[0]); length = getLong(argv[2], GN_ANY_BASE, "length"); offset = (argc &gt; 3) ? getLong(argv[3], GN_ANY_BASE, "offset") : 0; alignment = (argc &gt; 4) ? getLong(argv[4], GN_ANY_BASE, "alignment") : 4096; fd = open(argv[1], O_RDONLY | O_DIRECT); if (fd == -1) errExit("open"); /*  memalign()   ,   ,    .     'buf'  ,  'alignment',     .    ,   ,  ,    ,  256 ,     ,     512- .    '(char *)'        (     'void *',   memalign(). */ buf = (char *) memalign(alignment * 2, length + alignment) + alignment; if (buf == NULL) errExit("memalign"); if (lseek(fd, offset, SEEK_SET) == -1) errExit("lseek"); numRead = read(fd, buf, length); if (numRead == -1) errExit("read"); printf("Read %ld bytes\n", (long) numRead); exit(EXIT_SUCCESS); } _______________________________________________________________filebuff/direct_read.c</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">»Weitere Informationen zum Buch finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Website des Herausgebers</font></font></a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20% Rabatt auf Gutschein für </font><b><font style="vertical-align: inherit;">Linux</font></b><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436986/">https://habr.com/ru/post/de436986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436976/index.html">Integration der KeePass-Kennwortüberprüfung in die Leckdatenbank</a></li>
<li><a href="../de436978/index.html">Programmierbare TOTP-Token in einem Schlüsselanhänger-Formfaktor</a></li>
<li><a href="../de436980/index.html">Künstliche Intelligenz - Der Weltuntergang oder das goldene Zeitalter des globalen Wohlstands</a></li>
<li><a href="../de436982/index.html">Sicherheitswoche 04: Was tun mit Passwörtern?</a></li>
<li><a href="../de436984/index.html">Microsoft unterstützt Windows 10 Mobile nicht mehr</a></li>
<li><a href="../de436988/index.html">Kamera, Motor, Big Data: Wie Filmstudios mithilfe von KI nach neuen Filmen suchen</a></li>
<li><a href="../de436990/index.html">Zimbra und Zextras Suite sind vollständig kompatibel mit NTC IT ROSA-Betriebssystemen</a></li>
<li><a href="../de436992/index.html">Versuch und Irrtum bei der Auswahl von HTTP Reverse Proxy</a></li>
<li><a href="../de436994/index.html">Liquibase und Maven</a></li>
<li><a href="../de436996/index.html">Abschlusskurs zur Python-Spezialisierung von Mail.ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>