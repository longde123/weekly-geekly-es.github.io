<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏻 💱 💆🏿 Implementando o modelo de status no Unity 🚫 🐛 👢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No processo de programação de entidades no jogo, surgem situações em que elas devem agir em condições diferentes e de maneiras diferentes, o que suger...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementando o modelo de status no Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484176/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fa/bf6/c19/4fabf6c19761d028d621903401a84746.png" alt="imagem"></div><br>  No processo de programação de entidades no jogo, surgem situações em que elas devem agir em condições diferentes e de maneiras diferentes, o que sugere o uso de <i>estados</i> . <br><br>  Mas se você decidir usar força bruta, o código rapidamente se transformará em caos emaranhado com muitas instruções if-else aninhadas. <br><br>  Para uma solução simples para esse problema, você pode usar o padrão de design do Estado.  Vamos dedicar este tutorial para ele! <br><br>  No tutorial você: <br><br><ul><li>  Aprenda o básico do modelo State no Unity. </li><li>  Você aprenderá o que é uma máquina de estado e quando usá-la. </li><li>  Aprenda a usar esses conceitos para controlar o movimento do seu personagem. </li></ul><br><blockquote>  <em>Nota</em> : este tutorial é para usuários avançados;  presume-se que você já saiba trabalhar no Unity e tenha um nível médio de conhecimento de C #.  Além disso, este tutorial usa o Unity 2019.2 e C # 7. </blockquote><a name="habracut"></a><br><h2>  Começando a trabalhar </h2><br>  Faça o download dos <a href="">materiais do projeto</a> .  Descompacte o <em>arquivo zip</em> e abra o projeto <em>inicial</em> no Unity. <br><br>  Existem várias pastas no projeto que ajudarão você a começar.  A pasta <em>Assets / RW</em> contém as pastas <em>Animations</em> , <em>Materials</em> , <em>Models</em> , <em>Prefabs</em> , <em>Resources</em> , <em>Scenes</em> , <em>Scripts</em> e <em>Sounds</em> , nomeadas de acordo com os recursos que contêm. <br><br>  Para concluir o tutorial, trabalharemos apenas com <em>cenas</em> e <em>scripts</em> . <br><br>  Vá para <em>RW / Scenes</em> e abra <em>Main</em> .  No modo de jogo, você verá um personagem em uma capa dentro de um castelo medieval. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/f1b/4e1/478f1b4e1ec3a2e8702e365e4082a605.png"></div><br>  Clique em <em>Reproduzir</em> e observe como a <em>câmera</em> se move para se ajustar ao quadro do <em>personagem</em> .  No momento, em nosso joguinho, não há interações, trabalharemos nelas no tutorial. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/62c/536/ba362c53682371294f90576b5fd5adc6.gif"></div><br><h2>  Explore o personagem </h2><br>  Na <em>hierarquia,</em> selecione <em>Caractere</em> .  Confira o <em>Inspetor</em> .  Você verá um <em>componente</em> com o mesmo nome que contém a lógica de controle de <em>caracteres</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/ffd/2ba/957ffd2ba0299d4b509b75bedb094581.png"></div><br>  Abra <em>Character.cs</em> localizado em <em>RW / Scripts</em> . <br><br>  O script executa muitas ações, mas a maioria delas não é importante para nós.  Por enquanto, vamos prestar atenção aos seguintes métodos. <br><br><ul><li> <code>Move</code> : move o personagem, recebendo valores do tipo <code>speed</code> flutuação como velocidade de movimento e <code>rotationSpeed</code> velocidade como velocidade angular. </li><li>  <code>ResetMoveParams</code> : esse método redefine os parâmetros usados ​​para <i>animar o movimento</i> e a velocidade angular do caractere.  É usado apenas para limpeza. </li><li>  <code>SetAnimationBool</code> : Define o <code>param</code> animação <code>param</code> do tipo Bool como valor. </li><li>  <code>CheckCollisionOverlap</code> : recebe um <code></code> tipo <code>Vector3</code> e retorna um <code>bool</code> que determina se existem coletores dentro do raio especificado a partir do <code></code> . </li><li>  <code>TriggerAnimation</code> : <code>TriggerAnimation</code> o <code>param</code> animação do parâmetro de entrada. </li><li>  <code>ApplyImpulse</code> : <code>ApplyImpulse</code> pulso ao caractere igual à <code>force</code> parâmetro de entrada <code>force</code> tipo <code>Vector3</code> . </li></ul><br>  Abaixo você verá esses métodos.  Em nosso tutorial, seu conteúdo e trabalho interno não são importantes. <br><br><h2>  O que são máquinas de estado </h2><br>  Uma máquina de estado é um conceito em que um contêiner armazena o estado de algo em um determinado momento no tempo.  Com base nos dados de entrada, ele pode fornecer uma conclusão dependendo do estado atual, passando esse processo para um novo estado.  Máquinas de estado podem ser representadas como um <a href="https://www.geeksforgeeks.org/unified-modeling-language-uml-state-diagrams/" rel="noopener">diagrama de estado</a> .  A preparação de um diagrama de estados permite refletir sobre todos os estados possíveis do sistema e as transições entre eles. <br><br><h3>  Máquinas de estado </h3><br>  <em>Máquinas de estado finito</em> ou <em>FSM (máquina de estado finito)</em> é uma das quatro principais famílias de <em>máquinas</em> .  Os autômatos são modelos abstratos de máquinas simples.  Eles são estudados no âmbito da <a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/2004-05/automata-theory/basics.html" rel="noopener"><em>teoria dos autômatos</em></a> - o ramo teórico da ciência da computação. <br><br>  Em poucas palavras: <br><br><ul><li>  O FSM consiste em uma quantidade finita de <em>condição</em> .  A qualquer momento <em>,</em> apenas um desses estados está <em>ativo</em> . </li><li>  Cada estado determina em qual estado entrará como uma <em>saída com</em> base na sequência <em>recebida das informações recebidas</em> . </li><li>  O estado de saída se torna o novo estado ativo.  Em outras palavras, há uma <em>transição entre estados</em> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c43/111/f04/c43111f045f3727ab5f3b02c05c6ecc2.png"></div><br>  Para entender melhor isso, considere o caráter de um jogo de plataforma que está no terreno.  O personagem está no estado <i>Permanente</i> .  Este será o seu <em>estado ativo</em> até o jogador pressionar o botão para que o personagem salte. <br><br>  O estado <i>Permanente</i> identifica o pressionar de um botão como uma <em>entrada</em> significativa e, como <em>saída</em> , alterna para o estado <i>Salto</i> . <br><br>  Suponha que exista um certo número desses estados de movimento e que um personagem possa estar apenas em um dos estados de cada vez.  Este é um exemplo de FSM. <br><br><h3>  Máquinas de estado hierárquico </h3><br>  Considere um jogo de plataformas usando FSM, no qual vários estados compartilham uma lógica física comum.  Por exemplo, você pode mover e pular nos estados <em>Agachado</em> e <em>Parado</em> .  Nesse caso, várias variáveis ​​recebidas levam ao mesmo comportamento e saída de informações para dois estados diferentes. <br><br>  Em tal situação, seria lógico delegar o comportamento geral a algum outro estado.  Felizmente, isso pode ser alcançado usando máquinas de estado <em>hierárquico</em> . <br><br>  Em um FSM hierárquico, há <em>subestados</em> delegando informações <i>brutas de</i> entrada em seus <em>subestados</em> .  Isso, por sua vez, permite reduzir graciosamente o tamanho e a complexidade do FSM, mantendo sua lógica. <br><br><h2>  Modelo de status </h2><br>  Em seu livro <i>Design Patterns: Elements of Reusable Oriented Object Software,</i> Erich Gamma, Richard Helm, Ralph Johnson e John Vlissidis ( <em>The Gang of Four</em> ) definiram a <i>tarefa</i> do modelo State da seguinte maneira: <br><br>  “Ele deve permitir que o objeto mude seu comportamento quando seu estado interno mudar.  Nesse caso, parece que o objeto mudou de classe. ” <br><br>  Para entender melhor isso, considere o seguinte exemplo: <br><br><ul><li>  Um script que recebe informações de entrada para a lógica do movimento é anexado a uma entidade no jogo. </li><li>  Essa classe armazena uma variável de <i>estado atual</i> que simplesmente se refere a uma instância da classe de <i>estado</i> . </li><li>  As informações recebidas são delegadas para esse estado atual, que as processa e cria um comportamento definido dentro de si.  Ele também lida com as transições de estado necessárias. </li></ul><br>  Portanto, devido ao fato de que, em momentos diferentes, a variável de <i>estado atual</i> se refere a estados diferentes, parece que a mesma classe de script se comporta de maneira diferente.  Essa é a essência do modelo "Status". <br><br>  Em nosso projeto, a classe <em>Character</em> mencionada se comportará de maneira diferente, dependendo dos diferentes estados.  Mas precisamos que ele se comporte! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d8/d20/f59/3d8d20f5921bf342b2ac84b5677e9a3b.png"></div><br>  No caso geral, existem três pontos principais para cada classe de estado que permitem o comportamento do estado como um todo: <br><br><ul><li>  <em>Entrada</em> : é o momento em que uma entidade entra em um estado e executa ações que precisam ser executadas apenas uma vez ao entrar no estado. </li><li>  <em>Saída</em> : semelhante à entrada - todas as operações de redefinição são executadas aqui, que devem ser executadas apenas antes que o estado mude. </li><li>  <em>Loop de atualização</em> : Aqui está a <i>lógica</i> básica de <i>atualização</i> que é executada em cada quadro.  Pode ser dividido em várias partes, por exemplo, um ciclo para atualizar a física e um ciclo para processar a entrada do jogador. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a26/847/8e6/a268478e6da2566cc58d1083fefed27f.png"></div><br><h3>  Definindo um estado e uma máquina de estado </h3><br>  Vá para <em>RW / Scripts</em> e abra <em>StateMachine.cs</em> . <br><br>  <em>A Máquina de Estado</em> , como você pode imaginar, fornece uma abstração para a máquina de estado.  Observe que o <code>CurrentState</code> localizado corretamente dentro desta classe.  Ele armazenará um link para o estado atual da máquina de estado ativo. <br><br>  Agora, para definir o conceito de <i>estado</i> , vamos para <em>RW / Scripts</em> e abra o script <em>State.cs</em> no IDE. <br><br>  <em>State</em> é uma classe abstrata que usaremos como <i>modelo a</i> partir do qual todas as <i>classes de estados do</i> projeto são derivadas.  Parte do código nos materiais do projeto já está pronta. <br><br>  <code>DisplayOnUI</code> exibe apenas o nome do estado atual na interface do usuário na tela.  Você não precisa conhecer seu dispositivo interno, apenas entenda que ele recebe um enumerador do tipo <code>UIManager.Alignment</code> como um parâmetro de entrada, que pode ser <code>Left</code> ou <code>Right</code> .  A exibição do nome do status na parte inferior esquerda ou direita da tela depende disso. <br><br>  Além disso, existem duas variáveis ​​protegidas, <code>character</code> e <code>stateMachine</code> .  A variável de <code>character</code> refere-se a uma instância da classe <em>Character</em> e <code>stateMachine</code> refere-se a uma instância <em>da máquina de estados</em> associada ao estado. <br><br>  Ao criar uma instância de estado, o construtor vincula o <code>character</code> e <code>stateMachine</code> . <br><br>  Cada uma das muitas instâncias de <code>Character</code> em uma cena pode ter seu próprio conjunto de estados e máquinas de estados. <br><br>  Agora adicione os seguintes métodos ao <em>State.cs</em> e salve o arquivo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DisplayOnUI(UIManager.Alignment.Left); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Esses métodos virtuais definem os principais pontos de status descritos acima.  Quando <em>a máquina de estados</em> faz uma transição entre estados, chamamos <code>Exit</code> para o estado anterior e <code>Enter</code> novo <i>estado ativo</i> . <br><br>  <code>HandleInput</code> , <code>LogicUpdate</code> e <code>PhysicsUpdate</code> juntos definem <i>um loop de atualização</i> .  <code>HandleInput</code> lida com a entrada do player.  <code>LogicUpdate</code> processa a lógica básica, enquanto o <code>PhyiscsUpdate</code> processa os cálculos da lógica e da física. <br><br>  Agora abra <em>StateMachine.cs</em> novamente, adicione os seguintes métodos e salve o arquivo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State startingState</span></span></span><span class="hljs-function">)</span></span> { CurrentState = startingState; startingState.Enter(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State newState</span></span></span><span class="hljs-function">)</span></span> { CurrentState.Exit(); CurrentState = newState; newState.Enter(); }</code> </pre> <br>  <code>Initialize</code> configura a máquina de estado, definindo <code>CurrentState</code> como <code>CurrentState</code> e chamando <code>Enter</code> para ela.  Isso inicializa a máquina de estado, definindo pela primeira vez o estado ativo. <br><br>  <code>ChangeState</code> lida com transições de <em>estado</em> .  Ele chama <code>Exit</code> para o antigo <code>CurrentState</code> antes de substituir sua referência por <code>newState</code> .  No final, chama <code>Enter</code> para <code>newState</code> . <br><br>  Assim, definimos o <em>estado</em> e a <em>máquina de estado</em> . <br><br><h3>  Criando estados de movimento </h3><br>  Veja o diagrama de estados a seguir, que mostra os diferentes <i>estados de movimento da</i> essência <i>do</i> jogador no jogo.  Nesta seção, implementamos o modelo "Status" para o <i>movimento</i> mostrado na figura <i>FSM</i> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fa/bf6/c19/4fabf6c19761d028d621903401a84746.png"></div><br>  Preste atenção aos estados de movimento, como <em>Permanente</em> , <em>Ducking</em> e <em>Jumping</em> , bem como como os dados recebidos causam transições entre os estados.  Este é um FSM hierárquico no qual <em>Grounded</em> é um <em>subestado</em> dos <em>subestados Ducking</em> e <em>Standing</em> . <br><br>  Retorne ao Unity e vá para <em>RW / Scripts / States</em> .  Lá você encontrará vários arquivos C # com nomes que terminam em <i>State</i> . <br><br>  Cada um desses arquivos define uma classe, cada uma das quais é herdada do <code>State</code> .  Portanto, essas classes definem os estados que usaremos no projeto. <br><br>  Agora abra <em>Character.cs</em> na pasta <em>RW / Scripts</em> . <br><br>  Role acima do arquivo <code>#region Variables</code> e adicione o seguinte código: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StateMachine movementSM; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StandingState standing; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DuckingState ducking; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> JumpingState jumping;</code> </pre> <br>  Este <code>movementSM</code> refere-se a uma máquina de estado que processa a lógica de movimento da instância <code>Character</code> .  Também adicionamos links para três estados que implementamos para cada tipo de movimento. <br><br>  Vá para <code>#region MonoBehaviour Callbacks</code> no mesmo arquivo.  Adicione os seguintes métodos <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" rel="noopener">MonoBehaviour</a> e salve <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateMachine(); standing = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); ducking = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DuckingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); jumping = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JumpingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); movementSM.Initialize(standing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM.CurrentState.HandleInput(); movementSM.CurrentState.LogicUpdate(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM.CurrentState.PhysicsUpdate(); }</code> </pre> <br><ul><li>  Em <code>Start</code> código cria uma instância da <em>Máquina de Estado</em> e a atribui a <code>movementSM</code> , além de instanciar vários estados de movimento.  Ao criar cada um dos estados de movimento, passamos referências à instância <code>Character</code> usando a <code>this</code> , bem como a instância MovementSM.  No final, chamamos <code>Initialize</code> para o <code>movementSM</code> e passamos <code>Standing</code> como o estado inicial. </li><li>  No método <code>Update</code> , chamamos <code>HandleInput</code> e <code>LogicUpdate</code> para o <code>CurrentState</code> da máquina <code>LogicUpdate</code> .  Da mesma forma, em <code>FixedUpdate</code> chamamos <code>PhysicsUpdate</code> para o <code>CurrentState</code> da máquina <code>PhysicsUpdate</code> .  Em essência, isso delega tarefas para um estado ativo;  esse é o significado do modelo "Status". </li></ul><br>  Agora precisamos definir o comportamento dentro de cada um dos estados de movimento.  Prepare-se, haverá muito código! <br><br><h3>  Empresa Permanente </h3><br>  Retorne para <em>RW / Scripts / States</em> na janela Projeto. <br><br>  Abra <em>Grounded.cs</em> e observe que esta classe possui um construtor que corresponde ao construtor <code>State</code> .  Isso é lógico porque essa classe é herdada dela.  Você verá a mesma coisa em todas as outras classes de <i>estado</i> . <br><br>  Adicione o seguinte código: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); horizontalInput = verticalInput = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Exit(); character.ResetMoveParams(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); verticalInput = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); horizontalInput = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); character.Move(verticalInput * speed, horizontalInput * rotationSpeed); }</code> </pre> <br>  Aqui está o que acontece aqui: <br><br><ul><li>  Redefinimos um dos métodos virtuais definidos na classe pai.  Para preservar toda a funcionalidade que possa existir no pai, chamamos o método <code>base</code> com o mesmo nome de cada método substituído.  Este é um modelo importante que continuaremos a usar. </li><li>  A próxima linha, <code>Enter</code> define <code>horizontalInput</code> e <code>verticalInput</code> seus valores padrão. </li><li>  Dentro da <code>Exit</code> como mencionado acima, chamamos o método <code>ResetMoveParams</code> <code></code> para redefinir ao mudar para outro estado. </li><li>  No método <code>HandleInput</code> , as variáveis <code>horizontalInput</code> e <code>verticalInput</code> <code>HandleInput</code> valores dos eixos de entrada horizontal e vertical.  Graças a isso, o jogador pode controlar o personagem usando as teclas <em>W</em> , <em>A</em> , <em>S</em> e <em>D.</em> </li><li>  No <code>PhysicsUpdate</code> fazemos uma chamada <code>Move</code> , passando as variáveis <code>horizontalInput</code> e <code>verticalInput</code> multiplicadas pelas velocidades correspondentes.  Na <code>speed</code> variável <code>speed</code> a velocidade do movimento é armazenada e, na <code>rotationSpeed</code> , a velocidade angular. </li></ul><br>  Agora abra o <em>Standing.cs</em> e preste atenção ao fato de ele herdar do <code>Grounded</code> .  Isso aconteceu porque, como dissemos acima, <em>ficar em pé</em> é um subestado da <em>Grounded</em> .  Existem diferentes maneiras de implementar esse relacionamento, mas neste tutorial usamos herança. <br><br>  Adicione os seguintes métodos de <code>override</code> e salve o script: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); speed = character.MovementSpeed; rotationSpeed = character.RotationSpeed; crouch = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; jump = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); crouch = Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Fire3"</span></span>); jump = Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Jump"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (crouch) { stateMachine.ChangeState(character.ducking); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jump) { stateMachine.ChangeState(character.jumping); } }</code> </pre> <br><ul><li>  Em <code>Enter</code> configuramos as variáveis ​​herdadas do <code>Grounded</code> .  Aplique o <code>MovementSpeed</code> e <code>RotationSpeed</code> personagem para <code>speed</code> e <code>rotationSpeed</code> .  Então eles se relacionam, respectivamente, com a velocidade <i>normal</i> de movimento e a velocidade angular destinada à essência do personagem. <br><br>  Além disso, as variáveis ​​para armazenar entradas de <code>crouch</code> e <code>jump</code> são redefinidas para false. </li><li>  Dentro do <code>HandleInput</code> , as variáveis ​​de <code>crouch</code> e <code>jump</code> armazenam a entrada do jogador para agachamentos e saltos.  Se na cena principal o jogador pressionar a <em>tecla Shift, o</em> agachamento será definido como verdadeiro.  Da mesma forma, um jogador pode usar a tecla <em>Espaço</em> para <code>jump</code> . </li><li>  No <code>LogicUpdate</code> verificamos as variáveis ​​de <code>crouch</code> e <code>jump</code> do tipo <code>bool</code> .  Se <code>crouch</code> for true, o <code>movementSM.CurrentState</code> muda para <code>character.ducking</code> .  Se o <code>jump</code> for verdadeiro, o estado mudará para <code>character.jumping</code> . </li></ul><br>  Salve e monte o projeto e clique em <em>Play</em> .  Você pode se mover pela cena usando as teclas <em>W</em> , <em>A</em> , <em>S</em> e <em>D.</em>  Se você tentar pressionar <em>Shift</em> ou <em>Espaço</em> , ocorrerá um comportamento inesperado, porque os estados correspondentes ainda não foram implementados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/89a/564/45089a5640a8d492b20ac5948e0fdf69.gif"></div><br>  Tente mover-se sob os objetos da tabela.  Você verá que, devido à altura do colisor do personagem, isso não é possível.  Para que o personagem faça isso, você precisa adicionar um comportamento de agachamento. <br><br><h3>  Subimos debaixo da mesa </h3><br>  Abra o script <em>Ducking.cs</em> .  Observe que <code>Ducking</code> também herda da classe <code>Grounded</code> pelos mesmos motivos que <code>Standing</code> .  Adicione os seguintes métodos de <code>override</code> e salve o script: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); character.SetAnimationBool(character.crouchParam, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); speed = character.CrouchSpeed; rotationSpeed = character.CrouchRotationSpeed; character.ColliderSize = character.CrouchColliderHeight; belowCeiling = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Exit(); character.SetAnimationBool(character.crouchParam, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); character.ColliderSize = character.NormalColliderHeight; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); crouchHeld = Input.GetButton(<span class="hljs-string"><span class="hljs-string">"Fire3"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(crouchHeld || belowCeiling)) { stateMachine.ChangeState(character.standing); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); belowCeiling = character.CheckCollisionOverlap(character.transform.position + Vector3.up * character.NormalColliderHeight); }</code> </pre> <br><ul><li>  Dentro de <code>Enter</code> parâmetro que causa a alternância da animação de agachamento é definido como agachado, o que ativa a animação de agachamento.  As propriedades <code>character.CrouchSpeed</code> e <code>character.CrouchRotationSpeed</code> recebem os valores de <code>speed</code> e <code>rotation</code> , que retornam o movimento e a velocidade angular do personagem ao se <i>mover em um agachamento</i> . <br><br>  Em seguida, <code>character.CrouchColliderHeight</code> define o tamanho do colisor do personagem, que retorna a altura desejada do colisor ao se agachar.  No final, o <code>belowCeiling</code> redefinido para falso. </li><li>  Dentro de <code>Exit</code> o parâmetro de animação de agachamento é definido como falso.  Isso desativa a animação de agachamento.  Em seguida, a altura normal do colisor é definida, retornada por <code>character.NormalColliderHeight</code> . </li><li>  Dentro de <code>HandleInput</code> variável <code>crouchHeld</code> define o valor de entrada do player.  Na cena <em>principal</em> , segurar <em>Shift</em> define <code>crouchHeld</code> como true. </li><li>  Dentro de <code>PhysicsUpdate</code> variável <code>belowCeiling</code> recebe um valor passando um ponto no formato <code>Vector3</code> com a cabeça do objeto de jogo do personagem para o método <code>CheckCollisionOverlap</code> .  Se houver uma colisão perto deste ponto, isso significa que o personagem está sob algum tipo de teto. </li><li>  Internamente, o <code>LogicUpdate</code> verifica se <code>crouchHeld</code> ou <code>belowCeiling</code> é verdadeiro.  Se nenhum deles for verdadeiro, o <code>movementSM.CurrentState</code> alterado para <code>character.standing</code> . </li></ul><br>  Crie o projeto e clique em <em>Play</em> .  Agora você pode se mover pela cena.  Se você pressionar <em>Shift</em> , o personagem se sentará e você poderá se mover no agachamento. <br><br>  Você também pode subir sob a plataforma.  Se você liberar <em>Shift</em> enquanto estiver sob as plataformas, o personagem ainda estará agachado até que ele deixe seu abrigo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee4/dce/657/ee4dce657ae6be49244106652a168a3a.gif"></div><br><h3>  Suba! </h3><br>  Abra <em>Jumping.cs</em> .  Você verá um método chamado <code>Jump</code> .  Não se preocupe com como isso funciona;  basta entender que é usado para que o personagem possa pular, levando em consideração a física e a animação. <br><br>  Agora adicione os métodos de <code>override</code> comuns e salve o script <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); SoundManager.Instance.PlaySound(SoundManager.Instance.jumpSounds); grounded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Jump(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grounded) { character.TriggerAnimation(landParam); SoundManager.Instance.PlaySound(SoundManager.Instance.landing); stateMachine.ChangeState(character.standing); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); grounded = character.CheckCollisionOverlap(character.transform.position); }</code> </pre> <br><ul><li>  Dentro de <code>Enter</code> <code>SoundManager</code> reproduz o som do salto.  <code>grounded</code> redefinido para seu valor padrão.  No final, <code>Jump</code> é chamado. </li><li>  Dentro do <code>PhysicsUpdate</code> ponto <code>PhysicsUpdate</code> ao lado das pernas do personagem é enviado para o <code>CheckCollisionOverlap</code> , o que significa que, quando o personagem estiver no chão, o <code>grounded</code> será definido como verdadeiro. </li><li>  No <code>LogicUpdate</code> , se o <code>grounded</code> for verdadeiro, chamamos <code>TriggerAnimation</code> para ativar a animação de touchdown, o som do touchdown é reproduzido e o <code>movementSM.CurrentState</code> muda para <code>character.standing</code> . </li></ul><br>  Portanto, concluímos a implementação completa do deslocamento do FSM usando <em>o modelo "State"</em> .  Crie o projeto e execute-o.  Pressione <em>espaço</em> para fazer o personagem pular. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/e16/05d/ebde1605dc739588529c51509e19c0a8.gif"></div><br><h2>  Para onde ir a seguir? </h2><br>  Os <a href="">materiais do projeto</a> têm um projeto preliminar e um projeto finalizado. <br><br>  Apesar de sua utilidade, as máquinas de estado têm limitações.  Máquinas de estado simultâneas e máquinas de autômato de empilhamento podem lidar com algumas dessas limitações.  Você pode ler sobre eles no livro de Robert Nystrom <a href="https://gameprogrammingpatterns.com/state.html" rel="noopener"><em>Game Programming Patterns</em></a> . <br><br>  Além disso, o tópico pode ser explorado mais profundamente, explorando as <a href="https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)" rel="noopener"><em>árvores de comportamento</em></a> usadas para criar entidades mais complexas no jogo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484176/">https://habr.com/ru/post/pt484176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484164/index.html">A história dos livros e o futuro das bibliotecas</a></li>
<li><a href="../pt484166/index.html">VVVVVV ??? VVVVVV !!! :)</a></li>
<li><a href="../pt484168/index.html">Escrevemos nossa estratégia de rolagem virtual a partir do Angular CDK</a></li>
<li><a href="../pt484172/index.html">Integração contínua no Unity: como reduzir o tempo de montagem e economizar recursos + linha de pagamento como presente</a></li>
<li><a href="../pt484174/index.html">Beber em castelo em condições "extremas" ou como participamos do show "DOZOR"</a></li>
<li><a href="../pt484178/index.html">Switch Ethernet inteligente para o planeta Terra</a></li>
<li><a href="../pt484180/index.html">PBX virtual Rostelecom: o que e como pode ser feito através da API</a></li>
<li><a href="../pt484182/index.html">Xenobots: nanorobôs vivos de células de sapo</a></li>
<li><a href="../pt484186/index.html">LDAP - "autenticação" é um antipadrão</a></li>
<li><a href="../pt484188/index.html">Padrões de Design de Banco de Dados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>