<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍💻 📋 👩🏽‍💼 Beiwagen für eine Code-Aufteilung 🤼 😁 👨‍👨‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Code-Aufteilung. Code-Aufteilung ist überall. Aber warum? Nur weil es heutzutage zu viel Javascript gibt und nicht alle zum gleichen Zeitpunkt verwend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beiwagen für eine Code-Aufteilung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450942/"><p><img src="https://habrastorage.org/webt/ts/bi/e4/tsbie49wsfunvcztrdwhlnik6ge.jpeg"></p><br><p>  Code-Aufteilung.  Code-Aufteilung ist überall.  Aber warum?  Nur weil es heutzutage <strong>zu viel Javascript</strong> gibt und nicht alle zum gleichen Zeitpunkt verwendet werden. </p><br><p>  JS ist eine sehr <em>schwere</em> Sache.  Nicht für Ihr iPhone Xs oder Ihren brandneuen i9-Laptop, sondern für Millionen (wahrscheinlich Milliarden) <em>langsamer</em> Gerätebesitzer.  Oder zumindest für Ihre Uhren. </p><br><p>  Also - JS ist schlecht, aber was würde passieren, wenn wir es <strong>einfach deaktivieren</strong> - das Problem wäre weg ... für einige Sites und "mit Sites" für die reaktionsbasierten.  Aber trotzdem - es gibt Websites, die ohne JS funktionieren könnten ... und es gibt etwas, das wir daraus lernen sollten ... </p><a name="habracut"></a><br><h1 id="code-splitting">  Code-Aufteilung </h1><br><p>  Heute haben wir zwei Wege, zwei Wege, um es besser zu machen oder um es nicht schlechter zu machen: </p><br><h2 id="1-write-less-code">  1. Schreiben Sie weniger Code </h2><br><p> Das ist das Beste, was du tun kannst.  Mit <code>React Hooks</code> Sie zwar etwas weniger Code <code>Svelte</code> , und mit Lösungen wie <code>Svelte</code> Sie nur weniger Code als <em>gewöhnlich</em> generieren. <code>Svelte</code> ist jedoch nicht so einfach. </p><br><p>  Es geht nicht nur um den Code, sondern auch um die <em>Funktionalität</em> - um den Code "kompakt" zu halten, muss er "kompakt" bleiben.  Es gibt keine Möglichkeit, das Anwendungspaket klein zu halten, wenn es so viele Dinge tut (und in 20 Sprachen ausgeliefert wurde). </p><br><p>  Es gibt Möglichkeiten, <em>Kurz- und</em> Soundcode zu schreiben, und es gibt Möglichkeiten, die entgegengesetzte Implementierung zu schreiben - <em>das blutige Unternehmen</em> .  Und beide sind echt. </p><br><p><img src="https://habrastorage.org/webt/dz/fc/kn/dzfcknugbqrpbxturkjjae2v2se.jpeg"></p><br><p>  Aber das Hauptproblem - der Code selbst.  Eine einfache Reaktionsanwendung könnte leicht "empfohlene" 250 KB umgehen.  Und Sie könnten einen Monat damit verbringen, es zu optimieren und zu verkleinern.  "Kleine" Optimierungen sind gut dokumentiert und sehr nützlich - holen Sie sich einfach einen <code>bundle-analyzer</code> mit <code>size-limit</code> und machen Sie sich wieder fit. <br>  Es gibt viele Bibliotheken, die um jedes Byte kämpfen und versuchen, Sie an Ihre Grenzen zu bringen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">predigen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speichern</a> , um nur einige zu nennen. </p><br><p>  Unsere Anwendung ist jedoch etwas jenseits von 200 KB.  Es ist näher an <strong>100 MB</strong> .  Das Entfernen von Kilobyte macht keinen Sinn.  Selbst das Entfernen von Megabyte macht keinen Sinn. </p><br><blockquote>  Nach einiger Zeit ist es unmöglich, Ihre Anwendung klein zu halten.  Es wird mit der Zeit größer werden. </blockquote><br><h2 id="2-ship-less-code">  2. Versenden Sie weniger Code </h2><br><p>  Alternativ kann der <code>code split</code> .  Mit anderen Worten - <strong>kapitulieren</strong> .  Nehmen Sie Ihr 100-MB-Bundle und machen Sie daraus 20 5-MB-Bundles.  Ehrlich gesagt - das ist die einzig mögliche Möglichkeit, mit Ihrer Anwendung umzugehen, wenn sie groß wird - erstellen Sie daraus ein Paket kleinerer Apps. </p><br><p>  Eines sollten Sie jedoch im Moment wissen: Unabhängig von der gewählten Option handelt es sich um ein Implementierungsdetail, während wir nach etwas Zuverlässigerem suchen. </p><br><h1 id="the-truth-about-code-splitting">  Die Wahrheit über das Aufteilen von Code </h1><br><p>  Die Wahrheit über das Aufteilen von Code ist, dass es Natur ist, <strong>ZEITTRENNUNG</strong> .  Sie <em>teilen</em> Ihren Code nicht nur auf, sondern teilen ihn so auf, dass Sie zu einem bestimmten Zeitpunkt so wenig wie möglich verwenden. </p><br><p>  Versenden Sie nur nicht den Code, den Sie gerade nicht benötigen.  Werde es los. </p><br><p><img src="https://habrastorage.org/webt/py/eg/mi/pyegmilj0w2cshkxcj8nwqxhpg0.jpeg"></p><br><p>  Einfach zu sagen, schwer zu tun.  Ich habe ein paar schwere, aber nicht ausreichend geteilte Anwendungen, bei denen jede Seite wie 50% von allem geladen wird.  Manchmal <code>code splitting</code> zur <code>code separation</code> , ich meine - Sie können den Code in die verschiedenen Blöcke verschieben, aber trotzdem alles verwenden.  Erinnern Sie sich daran, dass <em>"</em> Versenden Sie <em>einfach nicht den Code, den Sie gerade nicht benötigen"</em> - ich 50% des Codes benötigte, und das war das eigentliche Problem. </p><br><blockquote>  Manchmal reicht es nicht aus, hier und da nur <code>import</code> hinzuzufügen.  Bis es keine Zeittrennung ist, sondern nur Raumtrennung - es spielt überhaupt keine Rolle. </blockquote><p>  Es gibt drei gängige Methoden zum Codieren: </p><br><ol><li>  Nur dynamischer <code>import</code> .  Heutzutage kaum noch alleine benutzt.  Es geht mehr um Probleme bei der Verfolgung eines <em>Zustands</em> . </li><li>  <code>Lazy</code> Component, wenn Sie das Rendern und Laden einer React Component verschieben können.  Wahrscheinlich 90% der "React Code Splitting" in diesen Tagen. </li><li>  <em>Lazy</em> <code>Library</code> , die eigentlich <code>.1</code> , aber Sie erhalten einen Bibliothekscode über React Render Requisiten.  Implementiert in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reaktionsimportierten</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ladbaren Komponenten</a> .  Sehr nützlich, aber nicht bekannt. </li></ol><br><h2 id="component-level-code-splitting">  Code-Aufteilung auf Komponentenebene </h2><br><p>  Dieser ist der beliebteste.  Als Code-Aufteilung pro Route oder Code-Aufteilung pro Komponente.  Es ist nicht so einfach, dies zu tun und dadurch gute <em>Wahrnehmungsergebnisse zu</em> erzielen.  Es ist der Tod durch <code>Flash of Loading Content</code> . </p><br><p>  Die guten Techniken sind: </p><br><ul><li>  Laden Sie <code>js chunk</code> und <code>data</code> für eine Route parallel. </li><li>  Verwenden Sie ein <code>skeleton</code> , um etwas Ähnliches wie die Seite vor dem Laden der Seite anzuzeigen (z. B. Facebook). </li><li>  <code>prefetch</code> Chunks <code>prefetch</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abrufen, können Sie</a> für eine bessere Vorhersage sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rate-js</a> verwenden. </li><li>  Verwenden Sie einige Verzögerungen, Ladeindikatoren, <code>animations</code> und <code>Suspense</code> (in der Zukunft), um Übergänge zu mildern. </li></ul><br><p>  Und das ist alles über <em>Wahrnehmungsleistung</em> . </p><br><p><img src="https://habrastorage.org/webt/yk/4o/s1/yk4os1fia5xv28cfdsoccss6nr0.png"></p><br><blockquote>  Bild von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.angularindepth.com/">verbessertem UX mit Ghost Elements</a> </blockquote><br><h1 id="that-doesnt-sound-good">  Das hört sich nicht gut an </h1><br><p>  Wissen Sie, ich könnte mich als Experte für Code-Splitting bezeichnen - aber ich habe meine eigenen Fehler. </p><br><p>  Manchmal konnte ich die Bündelgröße nicht reduzieren.  Manchmal konnte ich die resultierende Leistung nicht verbessern, solange <code>the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> *.  Es heißt <strong>Ladewellen</strong> . </p><br><ul><li>  ohne SSR oder Pre-Rendering.  Die richtige SSR verändert derzeit das Spiel. </li></ul><br><p><img src="https://habrastorage.org/webt/fl/kn/hn/flknhn-kd8_aad9ro7g6fisrpqy.jpeg"></p><br><p>  Letzte Woche habe ich zwei Fehler: </p><br><ul><li>  Ich habe in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Bibliotheksvergleich verloren</a> , solange meine Bibliothek besser war, aber VIEL größer als eine andere.  Ich habe es nicht geschafft, <strong>"1. weniger Code zu schreiben"</strong> . </li><li>  Optimieren Sie eine kleine Site, die meine Frau in React erstellt hat.  Es wurde eine routenbasierte Komponententeilung verwendet, aber die <code>header</code> und <code>footer</code> wurden im <code>footer</code> beibehalten, um Übergänge "akzeptabler" zu machen.  Nur ein paar Dinge, die <strong>eng</strong> miteinander verbunden sind, stiegen bis zu 320 KB (vor gzip) in die Höhe.  Es gab nichts Wichtiges und nichts, was ich wirklich entfernen konnte.  <strong>Ein Tod durch tausend Schnitte</strong> .  Ich konnte nicht <strong>weniger Code versenden</strong> . </li></ul><br><blockquote>  React-Dom war 20%, Core-js war 10%, React-Router, jsLingui, React-Powerplug ... 20% des eigenen Codes ... Wir sind bereits fertig. </blockquote><p><img src="https://habrastorage.org/webt/ec/zx/xo/eczxxohgulg4yvyjdeyxvzwi3g0.png"></p><br><h2 id="the-solution">  Die Lösung </h2><br><p>  Ich habe angefangen darüber nachzudenken, wie ich mein Problem lösen kann und warum <em>gängige Lösungen</em> für meinen Anwendungsfall nicht richtig funktionieren. </p><br><blockquote>  Was habe ich gemacht  Ich habe alle wichtigen Speicherorte aufgelistet, ohne die die Anwendung überhaupt nicht funktionieren würde, und versucht zu verstehen, warum ich den Rest habe. </blockquote><p>  Es war eine Überraschung.  Aber mein Problem war in CSS.  Im Vanille-CSS-Übergang. </p><br><p>  Hier ist der Code </p><br><ul><li>  Eine Steuervariable - <code>componentControl</code> - würde schließlich auf etwas gesetzt, das <code>DisplayData</code> anzeigen sollte. </li><li>  Sobald der Wert festgelegt ist, werden <code>className</code> sichtbar, ändern den <code>className</code> und lösen so einen ausgefallenen Übergang aus.  Gleichzeitig wird <code>FocusLock</code> aktiv und macht <code>FocusLock</code> zu einem <strong>Modal</strong> . <br><pre> <code class="javascript hljs">&lt;FocusLock enabled={componentControl.value} <span class="hljs-comment"><span class="hljs-comment">// ^ it's "disabled". When it's disabled - it's dead. &gt; {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} // ^ it's does not exists. Also dead &lt;DisplayData data={componentControl.value} visible={componentControl.value !== null} // ^ would change a className basing on visible state /&gt; // ^ that is just not visible, but NOT dead &lt;/FocusLock&gt;</span></span></code> </pre> </li></ul><br><p>  Ich würde dieses Stück gerne als Ganzes codieren, aber das konnte ich aus zwei Gründen nicht tun: </p><br><ol><li>  Die Informationen sollten bei Bedarf sofort und unverzüglich sichtbar sein.  Eine Geschäftsanforderung. </li><li>  Die Information "Chrome" sollte vorher vorhanden sein, um den Übergang der Eigenschaft zu handhaben. </li></ol><br><p>  Dieses Problem könnte teilweise mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSSTransitionGroup</a> oder einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überholung</a> gelöst werden.  Aber, wissen Sie, das Korrigieren <em>eines Codes und das</em> Hinzufügen eines <em>anderen Codes</em> klingt seltsam, selbst wenn es tatsächlich <em>ausreicht</em> .  Ich meine, das Hinzufügen von mehr Code könnte helfen, noch mehr Code zu entfernen.  Aber ... aber ... </p><br><blockquote>  Es sollte einen besseren Weg geben! </blockquote><p>  TL; DR - hier gibt es zwei wichtige Punkte: </p><br><ul><li>  <code>DisplayData</code> muss <strong>gemountet</strong> werden und ist zuvor im DOM vorhanden. </li><li>  <code>FocusLock</code> sollte auch vorher vorhanden sein, um keine erneute Bereitstellung von DisplayData zu bewirken, aber sein <strong>Gehirn wird</strong> am Anfang <strong>nicht benötigt</strong> . </li></ul><br><hr><br><p>  Also lasst uns unser mentales Modell ändern </p><br><h1 id="batman-and-robin">  Batman und Robin </h1><br><p>  Nehmen wir an, unser Code ist Batman und Robin.  Batman kann mit den meisten Bösen umgehen, aber wenn er nicht kann, kommt sein Kumpel Robin zur Rettung. </p><br><blockquote>  Wieder einmal würde Batman in die Schlacht ziehen, Robin wird später eintreffen. </blockquote><p>  Das ist Batman: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+&lt;FocusLock - enabled={componentControl.value} +&gt; - {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} + &lt;DisplayData + data={componentControl.value} + visible={componentControl.value !== null} + /&gt; +&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Dies ist sein Kumpel, Robin :: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-&lt;FocusLock + enabled={componentControl.value} -&gt; + {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} - &lt;DisplayData - data={componentControl.value} - visible={componentControl.value !== null} - /&gt; -&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Batman und Robin könnten ein <em>TEAM bilden</em> , aber sie sind tatsächlich zwei verschiedene Personen. </p><br><p>  Und vergessen Sie nicht - wir sprechen immer noch über <strong>Code-Splitting</strong> .  Und wo ist der Sidekick in Bezug auf die Code-Aufteilung?  Wo ist Robin? </p><br><p><img src="https://habrastorage.org/webt/m3/3a/fu/m33afuxsi_rirx3uwjusiprzj94.jpeg"></p><br><blockquote>  in einem Beiwagen.  Robin wartet in einem <strong>Beiwagenstück</strong> . </blockquote><br><h1 id="sidecar">  Beiwagen </h1><br><ul><li>  <code>Batman</code> hier ist alles visuelle Zeug, das Ihr Kunde so schnell wie möglich sehen muss.  Idealerweise sofort. </li><li>  <code>Robin</code> hier alles Logik und ausgefallene interaktive Funktionen, die eine Sekunde später verfügbar sein können, aber nicht am Anfang. </li></ul><br><p>  Es wäre besser, dies eine <strong>vertikale Code-Aufteilung</strong> zu nennen <strong>,</strong> bei der Code-Zweige parallel existieren, im Gegensatz zu einer üblichen <strong>horizontalen Code-Aufteilung,</strong> bei der Code-Zweige <em>geschnitten werden</em> . </p><br><p>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einigen Ländern</a> war dieses Trio als <code>replace reducer</code> oder als andere Methode zur <code>replace reducer</code> Redux-Logik und der Nebenwirkungen bekannt. </p><br><p>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einigen anderen Ländern</a> wird es als <code>"3 Phased" code splitting</code> . </p><br><blockquote>  Es ist nur eine weitere Trennung von Bedenken, die nur für Fälle gilt, in denen Sie das Laden eines Teils einer Komponente verschieben können, nicht jedoch eines anderen Teils. </blockquote><p><img src="https://habrastorage.org/webt/sw/fq/if/swfqifrldpp0n6o7qcfr6osdunk.jpeg" alt="Phase 3"></p><br><blockquote>  Bild vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen des neuen facebook.com mit React, GraphQL und Relay</a> , wobei <code>importForInteractions</code> oder <code>importAfter</code> <strong>das <code>sidecar</code></strong> . </blockquote><p>  Und es gibt eine <strong>interessante</strong> Beobachtung: Während <code>Batman</code> für einen Kunden wertvoller ist, ist er immer in Form, solange es etwas ist, das der Kunde <em>sieht</em> ... Während <code>Robin</code> , wissen Sie, ein bisschen <em>übergewichtig</em> ist und viel mehr Bytes benötigt leben. </p><br><p>  Infolgedessen - Batman allein ist für einen Kunden sehr erträglich - bietet er mehr Wert zu geringeren Kosten.  Du bist mein Held Bat! </p><br><h2 id="what-could-be-moved-to-a-sidecar">  Was könnte zu einem Beiwagen bewegt werden: </h2><br><ul><li>  Mehrheit von <code>useEffect</code> , <code>componentDidMount</code> und Freunden. </li><li>  wie alle <em>Modal-</em> Effekte.  Dh <code>focus</code> und <code>scroll</code> .  Sie können zuerst ein Modal anzeigen und <strong>erst dann</strong> Modal <em>modal machen</em> , dh die Aufmerksamkeit des Kunden "sperren". </li><li>  Formulare  Verschieben Sie alle Logik und Validierungen in einen Beiwagen und blockieren Sie die Formularübermittlung, bis diese Logik geladen ist.  Der Kunde könnte das Formular ausfüllen, ohne zu wissen, dass es sich nur um <code>Batman</code> . </li><li>  Einige Animationen.  Eine ganze <code>react-spring</code> in meinem Fall. </li><li>  Einige visuelle Sachen.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierte Bildlaufleisten</a> , die eine Sekunde später möglicherweise ausgefallene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bildlaufleisten</a> anzeigen. </li></ul><br><p>  Vergessen Sie auch nicht - Jeder Code, der in einen Beiwagen ausgelagert wird, entlädt auch Dinge wie Core-Js Poly- und Ponyfills, die vom entfernten Code verwendet werden. </p><br><p>  Das Aufteilen von Code kann intelligenter sein als heute in unseren Apps.  Wir müssen erkennen, dass es zwei Arten von <em>Code gibt</em> , die aufgeteilt werden müssen: 1) visuelle Aspekte 2) interaktive Aspekte.  Letzteres kann einige Momente später kommen.  <code>Sidecar</code> können die beiden Aufgaben nahtlos aufgeteilt werden, sodass die <em>Wahrnehmung entsteht, dass alles schneller geladen wird</em> .  Und es wird. </p><br><h2 id="the-oldest-way-to-code-split">  Der älteste Weg, um Code zu teilen </h2><br><p>  Obwohl es immer noch nicht ganz klar ist, wann und was ein <code>sidecar</code> ist, werde ich eine einfache Erklärung geben: </p><br><blockquote>  <code>Sidecar</code> ist <strong>ALLE IHRE SCRIPTS</strong> .  Beiwagen ist die Art und Weise, wie wir vor all dem Frontend-Zeug, das wir heute haben, <em>Codesplit machen</em> . </blockquote><p>  Ich spreche von Server Side Rendering ( <strong>SSR</strong> ) oder einfach nur <strong>HTML</strong> , wir alle waren erst gestern daran gewöhnt.  <code>Sidecar</code> macht die Dinge so einfach wie früher, als Seiten, die HTML und Logik enthielten, getrennt in einbettbaren externen Skripten gelebt wurden (Trennung von Bedenken). </p><br><p>  Wir hatten HTML <strong>plus</strong> CSS <strong>plus</strong> einige Skripte inline <strong>plus</strong> den Rest der Skripte, die in eine <code>.js</code> Datei extrahiert wurden. </p><br><p>  <code>HTML</code> + <code>CSS</code> + <code>inlined-js</code> waren <code>Batman</code> , während externe Skripte <code>Robin</code> waren und die Site ohne Robin und ehrlich gesagt teilweise ohne Batman funktionieren konnte (er wird den Kampf mit beiden Beinen fortsetzen (Inline-Skripte) gebrochen).  Das war erst gestern und viele "nicht moderne und coole" Seiten sind heute gleich. </p><br><hr><br><p>  Wenn Ihre Anwendung SSR unterstützt, versuchen Sie <strong>, js</strong> zu <strong>deaktivieren,</strong> damit es ohne SSR funktioniert.  Dann wäre klar, was in einen Beiwagen gebracht werden könnte. <br>  Wenn Ihre Anwendung nur ein clientseitiges SPA ist, stellen Sie sich vor, wie es funktionieren würde, wenn SSR vorhanden wäre. </p><br><blockquote>  Zum Beispiel - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">theurge.com</a> , geschrieben in React, ist voll funktionsfähig, <strong>ohne dass js aktiviert ist</strong> . </blockquote><p>  Es gibt viele Dinge, die Sie in einen Beiwagen auslagern können.  Zum Beispiel: </p><br><ul><li>  Kommentare.  Sie können Code versenden, <code>display</code> Kommentare <code>display</code> , aber nicht <code>answer</code> , solange möglicherweise mehr Code (einschließlich WYSIWYG-Editor) erforderlich ist, der anfangs nicht erforderlich ist.  Es ist besser, ein <em>Kommentarfeld</em> zu verzögern oder das Laden von Code hinter der Animation zu verbergen, als eine ganze Seite zu verzögern. </li><li>  Videoplayer.  Versende "Video" ohne "Steuerelemente".  Laden Sie sie eine Sekunde später, damit der Kunde versucht, mit ihm zu interagieren. </li><li>  Bildergalerie, wie <code>slick</code> .  Es ist keine große Sache, es zu <strong>zeichnen</strong> , aber viel schwieriger zu animieren und zu verwalten.  Es ist klar, was in einen Beiwagen gebracht werden könnte. </li></ul><br><blockquote>  Denken Sie nur daran, was für Ihre Anwendung wichtig ist und was nicht ganz ... </blockquote><br><h1 id="implementation-details">  Implementierungsdetails </h1><br><h2 id="di-component-code-splitting">  (DI) Aufteilung des Komponentencodes </h2><br><p>  Die einfachste Form des <code>sidecar</code> ist einfach zu implementieren. Verschieben Sie einfach alles in eine Unterkomponente. Sie können den Code auf "alte" Weise aufteilen.  Es ist fast eine Trennung zwischen <em>Smart-</em> und Dumb-Komponenten, aber dieses Mal setzt Smart keine Dumb-Komponenten fort - es ist das Gegenteil. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SmartComponent = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./SmartComponent'</span></span>)); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DumbComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;SmartComponent ref={this} /&gt; // &lt;-- move smart one inside &lt;TheActualMarkup /&gt; // &lt;-- the "real" stuff is here &lt;/React.Fragment&gt; } }</code> </pre> <br><p>  Dazu muss auch der <em>Initialisierungscode</em> in einen dummen Code verschoben werden. Sie können jedoch weiterhin den <em>schwersten</em> Teil eines Codes in Code aufteilen. </p><br><blockquote>  Können Sie jetzt ein <code>parallel</code> oder <code>vertical</code> Code-Aufteilungsmuster sehen? </blockquote><br><h2 id="usesidecar">  useSidecar </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das</a> hier bereits erwähnte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen des neuen facebook.com mit React, GraphQL und Relay</a> hatte ein Konzept von <code>loadAfter</code> oder <code>importForInteractivity</code> , das dem Sidecar-Konzept ziemlich ähnlich ist. </p><br><p>  Gleichzeitig würde ich nicht empfehlen, so etwas wie <code>useSidecar</code> zu verwenden, solange Sie absichtlich versuchen, <code>hooks</code> Inneren zu verwenden, aber das Aufteilen von Code in dieser Form würde gegen die Hook- <em>Regel verstoßen</em> . </p><br><p>  Bitte bevorzugen Sie eine deklarativere Komponente.  Möglicherweise verwenden Sie <code>hooks</code> in der <code>SideCar</code> Komponente. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Controller = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Controller'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DumbComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = useState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Controller componentRef={ref} state={state} /&gt; &lt;TheRealStuff ref={ref} state={state[0]} /&gt; &lt;/&gt; ) }</code> </pre> <br><h2 id="prefetching">  Prefetching </h2><br><p>  Vergessen Sie nicht - Sie können Ladeprioritätshinweise verwenden, um den <code>sidecar</code> vorzuladen oder vorzuholen und den Versand transparenter und unsichtbarer zu machen. </p><br><p>  Wichtige Dinge - das Vorabrufen von Skripten würde es über das <strong>Netzwerk</strong> laden, aber nicht ausführen (und CPU ausgeben), es sei denn, es ist tatsächlich erforderlich. </p><br><h2 id="ssr">  SSR </h2><br><p>  Im Gegensatz zur <em>normalen</em> Codeaufteilung ist für SSR keine spezielle Aktion erforderlich.  <code>Sidecar</code> möglicherweise nicht Teil des SSR-Prozesses und werden vor dem <code>hydration</code> nicht benötigt.  Es könnte "von Natur aus" verschoben werden. </p><br><p>  Verwenden Sie also <code>React.lazy</code> (idealerweise etwas <strong>ohne</strong> <code>Suspense</code> , Sie benötigen hier keine Failback-Indikatoren (Laden)) oder eine andere Bibliothek mit, aber besser ohne SSR-Unterstützung, <em>um</em> Seitenwagen-Chunks während des SSR-Prozesses zu <em>überspringen</em> . </p><br><h1 id="the-bad-parts">  Die schlechten Teile </h1><br><p>  Aber es gibt ein paar schlechte Teile dieser Idee </p><br><h2 id="batman-is-not-a-production-name">  Batman ist kein Produktionsname </h2><br><p>  Während <code>Batman</code> / <code>Robin</code> ein gutes Konzept sein könnte und der <code>sidecar</code> perfekt zur Technologie selbst <code>maincar</code> gibt es keinen "guten" Namen für den <code>maincar</code> .  Es gibt kein <code>maincar</code> , und offensichtlich dürfen <code>Batman</code> , <code>Lonely Wolf</code> , <code>Solitude</code> , <code>Driver</code> und <code>Solo</code> nicht verwendet werden, um ein Nicht-Beiwagen-Teil zu benennen. </p><br><p>  Facebook hat <code>display</code> und <code>interactivity</code> , und das könnte die beste Option für uns alle sein. </p><br><blockquote>  Wenn Sie einen guten Namen für mich haben - lassen Sie es in den Kommentaren </blockquote><br><h2 id="tree-shaking">  Baum zittern </h2><br><p>  Es geht mehr um die Trennung von Bedenken aus Sicht der <em>Bündler</em> .  Stellen wir uns vor, Sie haben <code>Batman</code> und <code>Robin</code> .  Und <code>stuff.js</code> </p><br><ul><li> <code>stuff.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./batman.js`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./robin.js`</span></span></code> </pre> </li></ul><br><p>  Anschließend können Sie versuchen, <em>Komponentenkomponentencode</em> aufzuteilen, um einen Beiwagen zu implementieren </p><br><ul><li><p> <code>main.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {batman} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./stuff.js'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Robin = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./sidecar.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Robin</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // sidecar </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Batman</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // main content </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br></li><li><p> <code>sidecar.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// and sidecar.js... that's another chunk as long as we `import` it import {robin} from './stuff.js' .....</span></span></code> </pre> <br></li></ul><br><p>  Kurz gesagt - der obige Code würde funktionieren, erledigt aber nicht "den Job". </p><br><ul><li>  Wenn Sie nur <code>batman</code> von <code>stuff.js</code> , würde das Schütteln von <code>stuff.js</code> nur das behalten. </li><li>  Wenn Sie nur <code>robin</code> von <code>stuff.js</code> - Baumschütteln würde nur es behalten. </li><li>  Wenn Sie jedoch beide verwenden, auch in unterschiedlichen <code>stuff.js</code> , werden beide beim <strong>ersten</strong> Auftreten von <code>stuff.js</code> , dh dem <code>stuff.js</code> , <strong>gebündelt</strong> . </li></ul><br><blockquote>  Das Schütteln von Bäumen ist nicht Code-Splitting-freundlich.  Sie müssen Bedenken nach Dateien trennen. </blockquote><br><h2 id="un-import">  Import aufheben </h2><br><p>  Eine andere Sache, die von allen vergessen wird, sind die Kosten für Javascript.  In der jQuery-Ära, der Ära der <code>jsonp</code> Nutzdaten, war es durchaus üblich, das Skript (mit <code>json</code> Nutzdaten) zu laden, die Nutzdaten <code>jsonp</code> und das Skript zu <strong>entfernen</strong> . </p><br><blockquote>  Heutzutage <code>import</code> wir alle <code>import</code> und sie werden für immer importiert, auch wenn sie nicht mehr benötigt werden. </blockquote><p>  Wie ich bereits sagte - es gibt zu viel JS, und früher oder später werden Sie bei <em>kontinuierlicher Navigation</em> alles laden.  Wir sollten einen Weg finden, den Import zu entfernen, keinen Block mehr zu benötigen, alle internen Caches zu löschen und Speicher freizugeben, um das Web zuverlässiger zu machen und Anwendungen nicht mit Ausnahme von Speichermangel zu zerstören. </p><br><p>  Wahrscheinlich ist die Möglichkeit zum Aufheben <code>un-import</code> (Webpack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">könnte dies tun</a> ) einer der Gründe, warum wir bei der <em>komponentenbasierten</em> API bleiben sollten, solange wir die Möglichkeit haben, das Aufheben der Bereitstellung zu handhaben. </p><br><p>  Bisher haben ESM-Modulstandards nichts mit solchen Dingen zu tun - weder mit der Cache-Steuerung noch mit dem Umkehren der Importaktion. </p><br><h2 id="creating-a-sidecar-enabled-library">  Erstellen einer Sidecar-fähigen Bibliothek </h2><br><p>  Bis heute gibt es nur einen Weg, eine <code>sidecar</code> fähige Bibliothek zu erstellen: </p><br><ul><li>  Teilen Sie Ihre Komponente in Teile </li><li>  Stellen Sie einen <code>main</code> und einen <code>connected</code> Teil (um die API nicht zu beschädigen) über den <code>index</code> </li><li>  Legen Sie einen <code>sidecar</code> über einen separaten Einstiegspunkt frei. </li><li>  Im Zielcode - Importieren Sie das <code>main</code> und das <code>sidecar</code> - Baumschütteln sollte ein <code>connected</code> Teil schneiden. </li></ul><br><p>  Dieses Mal sollte das Baumschütteln richtig funktionieren, und das einzige Problem ist, wie man den <code>main</code> benennt. </p><br><ul><li> <code>main.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Main = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{sidecar, ...props}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {sidecar} .... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><ul><li> <code>connected.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sidecar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Main</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sidecar</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Sidecar</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">} {...props} /&gt; );</span></span></code> </pre> <br><ul><li> <code>index.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Connected'</span></span>;</code> </pre> <br><ul><li> <code>sidecar.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>;</code> </pre> <br><p>  Kurz gesagt, die Änderung könnte durch einen kleinen Vergleich dargestellt werden </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//your app BEFORE import {Connected} from 'library'; // // ------------------------- //your app AFTER, compare this core to `connected.js` import {Main} from 'library'; const Sidecar = React.lazy(import( () =&gt; import('library/sidecar'))); // ^ all the difference ^ export SideConnected = props =&gt; ( &lt;Main sidecar={&lt;Sidecar /&gt;} {...props} /&gt; ); // ^ you will load only Main, Sidecar will arrive later.</span></span></code> </pre> <br><p>  Theoretisch könnte ein <code>dynamic import</code> innerhalb von node_modules verwendet werden, um den <em>Assemblierungsprozess</em> transparenter zu machen. </p><br><blockquote>  Wie auch immer - es ist nichts weiter als ein <code>children</code> / <code>slot</code> Muster, das in React so häufig vorkommt. </blockquote><br><h1 id="the-future">  Die Zukunft </h1><br><p>  <code>Facebook</code> bewiesen, dass die Idee richtig ist.  Wenn Sie das Video noch nicht gesehen haben, machen Sie es jetzt.  Ich habe gerade die gleiche Idee aus einem etwas anderen Blickwinkel erklärt (und eine Woche vor der F8-Konferenz angefangen, diesen Artikel zu schreiben). </p><br><p>  Im Moment müssen einige Codeänderungen auf Ihre Codebasis angewendet werden.  Es erfordert eine explizitere Trennung der Bedenken, um sie tatsächlich zu trennen, und die Codeaufteilung erfolgt nicht horizontal, sondern vertikal, wodurch <em>weniger</em> Code für eine <em>größere</em> Benutzererfahrung ausgeliefert wird. </p><br><p>  <code>Sidecar</code> ist wahrscheinlich die einzige Möglichkeit, mit Ausnahme der SSR der alten Schule, mit BIG-Codebasen umzugehen.  Letzte Chance, eine minimale Menge an Code zu versenden, wenn Sie viel davon haben. </p><br><blockquote>  Es könnte eine BIG-Anwendung kleiner und eine SMALL-Anwendung noch kleiner machen. </blockquote><p>  Vor 10 Jahren war die mittlere Website in 300 ms "fertig" und einige Millisekunden später <em>wirklich</em> fertig.  Heute sind Sekunden und sogar mehr als 10 Sekunden die gebräuchlichen Zahlen.  Was für eine Schande. </p><br><p>  Machen wir eine Pause und überlegen, wie wir das Problem lösen und UX wieder großartig machen können ... </p><br><p><img src="https://habrastorage.org/webt/8_/5u/7e/8_5u7ehdn7nkcjiaqfv1-rzadfa.jpeg"></p><br><h1 id="overall">  Insgesamt </h1><br><ul><li>  Das Aufteilen von Komponentencode ist ein äußerst leistungsfähiges Tool, mit dem Sie etwas <em>vollständig</em> aufteilen können. Es ist jedoch mit Kosten verbunden. Möglicherweise wird für eine Weile nur eine leere Seite oder ein <em>Skelett</em> angezeigt.  Das ist eine horizontale Trennung. </li><li>  Die Aufteilung des Bibliothekscodes könnte hilfreich sein, wenn die Aufteilung der Komponenten dies nicht tun würde.  Das ist eine horizontale Trennung. </li><li>  Code, der in einen Beiwagen abgeladen wird, vervollständigt das Bild und ermöglicht Ihnen möglicherweise eine weitaus bessere Benutzererfahrung.  Würde aber auch einen gewissen technischen Aufwand erfordern.  Das ist eine vertikale Trennung. </li></ul><br><p>  <strong>Lassen Sie uns ein Gespräch darüber führen</strong> . </p><br><h2 id="stop-so-what-about-the-problems-you-tried-to-solve">  Hör auf!  Was ist also mit den Problemen, die Sie zu lösen versucht haben? </h2><br><p>  Nun, das war nur der erste Teil.  <strong>Wir sind jetzt im Endspiel</strong> , es würde noch einige Wochen dauern, bis der zweite Teil dieses Vorschlags aufgeschrieben ist.  In der Zwischenzeit ... steigen Sie in den Beiwagen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450942/">https://habr.com/ru/post/de450942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450926/index.html">3D-Spiel auf three.js, nw.js.</a></li>
<li><a href="../de450928/index.html">Wie Rechenzentren Urlaub sparen</a></li>
<li><a href="../de450930/index.html">Wie wir # bigdataX5 entwickeln und wer in Big Data benötigt wird</a></li>
<li><a href="../de450938/index.html">Linux Install Fest 05.19 in Nischni Nowgorod 18. Mai 2019</a></li>
<li><a href="../de450940/index.html">Vivaldi 2.5 - Attraktiver Makrokosmos</a></li>
<li><a href="../de450946/index.html">Festplatten-Handy auf LPC810</a></li>
<li><a href="../de450948/index.html">MU-MIMO: einer der Implementierungsalgorithmen</a></li>
<li><a href="../de450950/index.html">Dart Streams Grundlagen</a></li>
<li><a href="../de450952/index.html">Mittlerer Index und Antibank</a></li>
<li><a href="../de450954/index.html">Wie wir gelernt haben, Java in Docker auszunutzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>