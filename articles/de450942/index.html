<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüíª üìã üë©üèΩ‚Äçüíº Beiwagen f√ºr eine Code-Aufteilung ü§º üòÅ üë®‚Äçüë®‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Code-Aufteilung. Code-Aufteilung ist √ºberall. Aber warum? Nur weil es heutzutage zu viel Javascript gibt und nicht alle zum gleichen Zeitpunkt verwend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beiwagen f√ºr eine Code-Aufteilung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450942/"><p><img src="https://habrastorage.org/webt/ts/bi/e4/tsbie49wsfunvcztrdwhlnik6ge.jpeg"></p><br><p>  Code-Aufteilung.  Code-Aufteilung ist √ºberall.  Aber warum?  Nur weil es heutzutage <strong>zu viel Javascript</strong> gibt und nicht alle zum gleichen Zeitpunkt verwendet werden. </p><br><p>  JS ist eine sehr <em>schwere</em> Sache.  Nicht f√ºr Ihr iPhone Xs oder Ihren brandneuen i9-Laptop, sondern f√ºr Millionen (wahrscheinlich Milliarden) <em>langsamer</em> Ger√§tebesitzer.  Oder zumindest f√ºr Ihre Uhren. </p><br><p>  Also - JS ist schlecht, aber was w√ºrde passieren, wenn wir es <strong>einfach deaktivieren</strong> - das Problem w√§re weg ... f√ºr einige Sites und "mit Sites" f√ºr die reaktionsbasierten.  Aber trotzdem - es gibt Websites, die ohne JS funktionieren k√∂nnten ... und es gibt etwas, das wir daraus lernen sollten ... </p><a name="habracut"></a><br><h1 id="code-splitting">  Code-Aufteilung </h1><br><p>  Heute haben wir zwei Wege, zwei Wege, um es besser zu machen oder um es nicht schlechter zu machen: </p><br><h2 id="1-write-less-code">  1. Schreiben Sie weniger Code </h2><br><p> Das ist das Beste, was du tun kannst.  Mit <code>React Hooks</code> Sie zwar etwas weniger Code <code>Svelte</code> , und mit L√∂sungen wie <code>Svelte</code> Sie nur weniger Code als <em>gew√∂hnlich</em> generieren. <code>Svelte</code> ist jedoch nicht so einfach. </p><br><p>  Es geht nicht nur um den Code, sondern auch um die <em>Funktionalit√§t</em> - um den Code "kompakt" zu halten, muss er "kompakt" bleiben.  Es gibt keine M√∂glichkeit, das Anwendungspaket klein zu halten, wenn es so viele Dinge tut (und in 20 Sprachen ausgeliefert wurde). </p><br><p>  Es gibt M√∂glichkeiten, <em>Kurz- und</em> Soundcode zu schreiben, und es gibt M√∂glichkeiten, die entgegengesetzte Implementierung zu schreiben - <em>das blutige Unternehmen</em> .  Und beide sind echt. </p><br><p><img src="https://habrastorage.org/webt/dz/fc/kn/dzfcknugbqrpbxturkjjae2v2se.jpeg"></p><br><p>  Aber das Hauptproblem - der Code selbst.  Eine einfache Reaktionsanwendung k√∂nnte leicht "empfohlene" 250 KB umgehen.  Und Sie k√∂nnten einen Monat damit verbringen, es zu optimieren und zu verkleinern.  "Kleine" Optimierungen sind gut dokumentiert und sehr n√ºtzlich - holen Sie sich einfach einen <code>bundle-analyzer</code> mit <code>size-limit</code> und machen Sie sich wieder fit. <br>  Es gibt viele Bibliotheken, die um jedes Byte k√§mpfen und versuchen, Sie an Ihre Grenzen zu bringen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">predigen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speichern</a> , um nur einige zu nennen. </p><br><p>  Unsere Anwendung ist jedoch etwas jenseits von 200 KB.  Es ist n√§her an <strong>100 MB</strong> .  Das Entfernen von Kilobyte macht keinen Sinn.  Selbst das Entfernen von Megabyte macht keinen Sinn. </p><br><blockquote>  Nach einiger Zeit ist es unm√∂glich, Ihre Anwendung klein zu halten.  Es wird mit der Zeit gr√∂√üer werden. </blockquote><br><h2 id="2-ship-less-code">  2. Versenden Sie weniger Code </h2><br><p>  Alternativ kann der <code>code split</code> .  Mit anderen Worten - <strong>kapitulieren</strong> .  Nehmen Sie Ihr 100-MB-Bundle und machen Sie daraus 20 5-MB-Bundles.  Ehrlich gesagt - das ist die einzig m√∂gliche M√∂glichkeit, mit Ihrer Anwendung umzugehen, wenn sie gro√ü wird - erstellen Sie daraus ein Paket kleinerer Apps. </p><br><p>  Eines sollten Sie jedoch im Moment wissen: Unabh√§ngig von der gew√§hlten Option handelt es sich um ein Implementierungsdetail, w√§hrend wir nach etwas Zuverl√§ssigerem suchen. </p><br><h1 id="the-truth-about-code-splitting">  Die Wahrheit √ºber das Aufteilen von Code </h1><br><p>  Die Wahrheit √ºber das Aufteilen von Code ist, dass es Natur ist, <strong>ZEITTRENNUNG</strong> .  Sie <em>teilen</em> Ihren Code nicht nur auf, sondern teilen ihn so auf, dass Sie zu einem bestimmten Zeitpunkt so wenig wie m√∂glich verwenden. </p><br><p>  Versenden Sie nur nicht den Code, den Sie gerade nicht ben√∂tigen.  Werde es los. </p><br><p><img src="https://habrastorage.org/webt/py/eg/mi/pyegmilj0w2cshkxcj8nwqxhpg0.jpeg"></p><br><p>  Einfach zu sagen, schwer zu tun.  Ich habe ein paar schwere, aber nicht ausreichend geteilte Anwendungen, bei denen jede Seite wie 50% von allem geladen wird.  Manchmal <code>code splitting</code> zur <code>code separation</code> , ich meine - Sie k√∂nnen den Code in die verschiedenen Bl√∂cke verschieben, aber trotzdem alles verwenden.  Erinnern Sie sich daran, dass <em>"</em> Versenden Sie <em>einfach nicht den Code, den Sie gerade nicht ben√∂tigen"</em> - ich 50% des Codes ben√∂tigte, und das war das eigentliche Problem. </p><br><blockquote>  Manchmal reicht es nicht aus, hier und da nur <code>import</code> hinzuzuf√ºgen.  Bis es keine Zeittrennung ist, sondern nur Raumtrennung - es spielt √ºberhaupt keine Rolle. </blockquote><p>  Es gibt drei g√§ngige Methoden zum Codieren: </p><br><ol><li>  Nur dynamischer <code>import</code> .  Heutzutage kaum noch alleine benutzt.  Es geht mehr um Probleme bei der Verfolgung eines <em>Zustands</em> . </li><li>  <code>Lazy</code> Component, wenn Sie das Rendern und Laden einer React Component verschieben k√∂nnen.  Wahrscheinlich 90% der "React Code Splitting" in diesen Tagen. </li><li>  <em>Lazy</em> <code>Library</code> , die eigentlich <code>.1</code> , aber Sie erhalten einen Bibliothekscode √ºber React Render Requisiten.  Implementiert in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reaktionsimportierten</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ladbaren Komponenten</a> .  Sehr n√ºtzlich, aber nicht bekannt. </li></ol><br><h2 id="component-level-code-splitting">  Code-Aufteilung auf Komponentenebene </h2><br><p>  Dieser ist der beliebteste.  Als Code-Aufteilung pro Route oder Code-Aufteilung pro Komponente.  Es ist nicht so einfach, dies zu tun und dadurch gute <em>Wahrnehmungsergebnisse zu</em> erzielen.  Es ist der Tod durch <code>Flash of Loading Content</code> . </p><br><p>  Die guten Techniken sind: </p><br><ul><li>  Laden Sie <code>js chunk</code> und <code>data</code> f√ºr eine Route parallel. </li><li>  Verwenden Sie ein <code>skeleton</code> , um etwas √Ñhnliches wie die Seite vor dem Laden der Seite anzuzeigen (z. B. Facebook). </li><li>  <code>prefetch</code> Chunks <code>prefetch</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abrufen, k√∂nnen Sie</a> f√ºr eine bessere Vorhersage sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rate-js</a> verwenden. </li><li>  Verwenden Sie einige Verz√∂gerungen, Ladeindikatoren, <code>animations</code> und <code>Suspense</code> (in der Zukunft), um √úberg√§nge zu mildern. </li></ul><br><p>  Und das ist alles √ºber <em>Wahrnehmungsleistung</em> . </p><br><p><img src="https://habrastorage.org/webt/yk/4o/s1/yk4os1fia5xv28cfdsoccss6nr0.png"></p><br><blockquote>  Bild von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.angularindepth.com/">verbessertem UX mit Ghost Elements</a> </blockquote><br><h1 id="that-doesnt-sound-good">  Das h√∂rt sich nicht gut an </h1><br><p>  Wissen Sie, ich k√∂nnte mich als Experte f√ºr Code-Splitting bezeichnen - aber ich habe meine eigenen Fehler. </p><br><p>  Manchmal konnte ich die B√ºndelgr√∂√üe nicht reduzieren.  Manchmal konnte ich die resultierende Leistung nicht verbessern, solange <code>the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> *.  Es hei√üt <strong>Ladewellen</strong> . </p><br><ul><li>  ohne SSR oder Pre-Rendering.  Die richtige SSR ver√§ndert derzeit das Spiel. </li></ul><br><p><img src="https://habrastorage.org/webt/fl/kn/hn/flknhn-kd8_aad9ro7g6fisrpqy.jpeg"></p><br><p>  Letzte Woche habe ich zwei Fehler: </p><br><ul><li>  Ich habe in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Bibliotheksvergleich verloren</a> , solange meine Bibliothek besser war, aber VIEL gr√∂√üer als eine andere.  Ich habe es nicht geschafft, <strong>"1. weniger Code zu schreiben"</strong> . </li><li>  Optimieren Sie eine kleine Site, die meine Frau in React erstellt hat.  Es wurde eine routenbasierte Komponententeilung verwendet, aber die <code>header</code> und <code>footer</code> wurden im <code>footer</code> beibehalten, um √úberg√§nge "akzeptabler" zu machen.  Nur ein paar Dinge, die <strong>eng</strong> miteinander verbunden sind, stiegen bis zu 320 KB (vor gzip) in die H√∂he.  Es gab nichts Wichtiges und nichts, was ich wirklich entfernen konnte.  <strong>Ein Tod durch tausend Schnitte</strong> .  Ich konnte nicht <strong>weniger Code versenden</strong> . </li></ul><br><blockquote>  React-Dom war 20%, Core-js war 10%, React-Router, jsLingui, React-Powerplug ... 20% des eigenen Codes ... Wir sind bereits fertig. </blockquote><p><img src="https://habrastorage.org/webt/ec/zx/xo/eczxxohgulg4yvyjdeyxvzwi3g0.png"></p><br><h2 id="the-solution">  Die L√∂sung </h2><br><p>  Ich habe angefangen dar√ºber nachzudenken, wie ich mein Problem l√∂sen kann und warum <em>g√§ngige L√∂sungen</em> f√ºr meinen Anwendungsfall nicht richtig funktionieren. </p><br><blockquote>  Was habe ich gemacht  Ich habe alle wichtigen Speicherorte aufgelistet, ohne die die Anwendung √ºberhaupt nicht funktionieren w√ºrde, und versucht zu verstehen, warum ich den Rest habe. </blockquote><p>  Es war eine √úberraschung.  Aber mein Problem war in CSS.  Im Vanille-CSS-√úbergang. </p><br><p>  Hier ist der Code </p><br><ul><li>  Eine Steuervariable - <code>componentControl</code> - w√ºrde schlie√ülich auf etwas gesetzt, das <code>DisplayData</code> anzeigen sollte. </li><li>  Sobald der Wert festgelegt ist, werden <code>className</code> sichtbar, √§ndern den <code>className</code> und l√∂sen so einen ausgefallenen √úbergang aus.  Gleichzeitig wird <code>FocusLock</code> aktiv und macht <code>FocusLock</code> zu einem <strong>Modal</strong> . <br><pre> <code class="javascript hljs">&lt;FocusLock enabled={componentControl.value} <span class="hljs-comment"><span class="hljs-comment">// ^ it's "disabled". When it's disabled - it's dead. &gt; {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} // ^ it's does not exists. Also dead &lt;DisplayData data={componentControl.value} visible={componentControl.value !== null} // ^ would change a className basing on visible state /&gt; // ^ that is just not visible, but NOT dead &lt;/FocusLock&gt;</span></span></code> </pre> </li></ul><br><p>  Ich w√ºrde dieses St√ºck gerne als Ganzes codieren, aber das konnte ich aus zwei Gr√ºnden nicht tun: </p><br><ol><li>  Die Informationen sollten bei Bedarf sofort und unverz√ºglich sichtbar sein.  Eine Gesch√§ftsanforderung. </li><li>  Die Information "Chrome" sollte vorher vorhanden sein, um den √úbergang der Eigenschaft zu handhaben. </li></ol><br><p>  Dieses Problem k√∂nnte teilweise mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSSTransitionGroup</a> oder einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberholung</a> gel√∂st werden.  Aber, wissen Sie, das Korrigieren <em>eines Codes und das</em> Hinzuf√ºgen eines <em>anderen Codes</em> klingt seltsam, selbst wenn es tats√§chlich <em>ausreicht</em> .  Ich meine, das Hinzuf√ºgen von mehr Code k√∂nnte helfen, noch mehr Code zu entfernen.  Aber ... aber ... </p><br><blockquote>  Es sollte einen besseren Weg geben! </blockquote><p>  TL; DR - hier gibt es zwei wichtige Punkte: </p><br><ul><li>  <code>DisplayData</code> muss <strong>gemountet</strong> werden und ist zuvor im DOM vorhanden. </li><li>  <code>FocusLock</code> sollte auch vorher vorhanden sein, um keine erneute Bereitstellung von DisplayData zu bewirken, aber sein <strong>Gehirn wird</strong> am Anfang <strong>nicht ben√∂tigt</strong> . </li></ul><br><hr><br><p>  Also lasst uns unser mentales Modell √§ndern </p><br><h1 id="batman-and-robin">  Batman und Robin </h1><br><p>  Nehmen wir an, unser Code ist Batman und Robin.  Batman kann mit den meisten B√∂sen umgehen, aber wenn er nicht kann, kommt sein Kumpel Robin zur Rettung. </p><br><blockquote>  Wieder einmal w√ºrde Batman in die Schlacht ziehen, Robin wird sp√§ter eintreffen. </blockquote><p>  Das ist Batman: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+&lt;FocusLock - enabled={componentControl.value} +&gt; - {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} + &lt;DisplayData + data={componentControl.value} + visible={componentControl.value !== null} + /&gt; +&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Dies ist sein Kumpel, Robin :: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-&lt;FocusLock + enabled={componentControl.value} -&gt; + {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} - &lt;DisplayData - data={componentControl.value} - visible={componentControl.value !== null} - /&gt; -&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Batman und Robin k√∂nnten ein <em>TEAM bilden</em> , aber sie sind tats√§chlich zwei verschiedene Personen. </p><br><p>  Und vergessen Sie nicht - wir sprechen immer noch √ºber <strong>Code-Splitting</strong> .  Und wo ist der Sidekick in Bezug auf die Code-Aufteilung?  Wo ist Robin? </p><br><p><img src="https://habrastorage.org/webt/m3/3a/fu/m33afuxsi_rirx3uwjusiprzj94.jpeg"></p><br><blockquote>  in einem Beiwagen.  Robin wartet in einem <strong>Beiwagenst√ºck</strong> . </blockquote><br><h1 id="sidecar">  Beiwagen </h1><br><ul><li>  <code>Batman</code> hier ist alles visuelle Zeug, das Ihr Kunde so schnell wie m√∂glich sehen muss.  Idealerweise sofort. </li><li>  <code>Robin</code> hier alles Logik und ausgefallene interaktive Funktionen, die eine Sekunde sp√§ter verf√ºgbar sein k√∂nnen, aber nicht am Anfang. </li></ul><br><p>  Es w√§re besser, dies eine <strong>vertikale Code-Aufteilung</strong> zu nennen <strong>,</strong> bei der Code-Zweige parallel existieren, im Gegensatz zu einer √ºblichen <strong>horizontalen Code-Aufteilung,</strong> bei der Code-Zweige <em>geschnitten werden</em> . </p><br><p>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einigen L√§ndern</a> war dieses Trio als <code>replace reducer</code> oder als andere Methode zur <code>replace reducer</code> Redux-Logik und der Nebenwirkungen bekannt. </p><br><p>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einigen anderen L√§ndern</a> wird es als <code>"3 Phased" code splitting</code> . </p><br><blockquote>  Es ist nur eine weitere Trennung von Bedenken, die nur f√ºr F√§lle gilt, in denen Sie das Laden eines Teils einer Komponente verschieben k√∂nnen, nicht jedoch eines anderen Teils. </blockquote><p><img src="https://habrastorage.org/webt/sw/fq/if/swfqifrldpp0n6o7qcfr6osdunk.jpeg" alt="Phase 3"></p><br><blockquote>  Bild vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen des neuen facebook.com mit React, GraphQL und Relay</a> , wobei <code>importForInteractions</code> oder <code>importAfter</code> <strong>das <code>sidecar</code></strong> . </blockquote><p>  Und es gibt eine <strong>interessante</strong> Beobachtung: W√§hrend <code>Batman</code> f√ºr einen Kunden wertvoller ist, ist er immer in Form, solange es etwas ist, das der Kunde <em>sieht</em> ... W√§hrend <code>Robin</code> , wissen Sie, ein bisschen <em>√ºbergewichtig</em> ist und viel mehr Bytes ben√∂tigt leben. </p><br><p>  Infolgedessen - Batman allein ist f√ºr einen Kunden sehr ertr√§glich - bietet er mehr Wert zu geringeren Kosten.  Du bist mein Held Bat! </p><br><h2 id="what-could-be-moved-to-a-sidecar">  Was k√∂nnte zu einem Beiwagen bewegt werden: </h2><br><ul><li>  Mehrheit von <code>useEffect</code> , <code>componentDidMount</code> und Freunden. </li><li>  wie alle <em>Modal-</em> Effekte.  Dh <code>focus</code> und <code>scroll</code> .  Sie k√∂nnen zuerst ein Modal anzeigen und <strong>erst dann</strong> Modal <em>modal machen</em> , dh die Aufmerksamkeit des Kunden "sperren". </li><li>  Formulare  Verschieben Sie alle Logik und Validierungen in einen Beiwagen und blockieren Sie die Formular√ºbermittlung, bis diese Logik geladen ist.  Der Kunde k√∂nnte das Formular ausf√ºllen, ohne zu wissen, dass es sich nur um <code>Batman</code> . </li><li>  Einige Animationen.  Eine ganze <code>react-spring</code> in meinem Fall. </li><li>  Einige visuelle Sachen.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierte Bildlaufleisten</a> , die eine Sekunde sp√§ter m√∂glicherweise ausgefallene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bildlaufleisten</a> anzeigen. </li></ul><br><p>  Vergessen Sie auch nicht - Jeder Code, der in einen Beiwagen ausgelagert wird, entl√§dt auch Dinge wie Core-Js Poly- und Ponyfills, die vom entfernten Code verwendet werden. </p><br><p>  Das Aufteilen von Code kann intelligenter sein als heute in unseren Apps.  Wir m√ºssen erkennen, dass es zwei Arten von <em>Code gibt</em> , die aufgeteilt werden m√ºssen: 1) visuelle Aspekte 2) interaktive Aspekte.  Letzteres kann einige Momente sp√§ter kommen.  <code>Sidecar</code> k√∂nnen die beiden Aufgaben nahtlos aufgeteilt werden, sodass die <em>Wahrnehmung entsteht, dass alles schneller geladen wird</em> .  Und es wird. </p><br><h2 id="the-oldest-way-to-code-split">  Der √§lteste Weg, um Code zu teilen </h2><br><p>  Obwohl es immer noch nicht ganz klar ist, wann und was ein <code>sidecar</code> ist, werde ich eine einfache Erkl√§rung geben: </p><br><blockquote>  <code>Sidecar</code> ist <strong>ALLE IHRE SCRIPTS</strong> .  Beiwagen ist die Art und Weise, wie wir vor all dem Frontend-Zeug, das wir heute haben, <em>Codesplit machen</em> . </blockquote><p>  Ich spreche von Server Side Rendering ( <strong>SSR</strong> ) oder einfach nur <strong>HTML</strong> , wir alle waren erst gestern daran gew√∂hnt.  <code>Sidecar</code> macht die Dinge so einfach wie fr√ºher, als Seiten, die HTML und Logik enthielten, getrennt in einbettbaren externen Skripten gelebt wurden (Trennung von Bedenken). </p><br><p>  Wir hatten HTML <strong>plus</strong> CSS <strong>plus</strong> einige Skripte inline <strong>plus</strong> den Rest der Skripte, die in eine <code>.js</code> Datei extrahiert wurden. </p><br><p>  <code>HTML</code> + <code>CSS</code> + <code>inlined-js</code> waren <code>Batman</code> , w√§hrend externe Skripte <code>Robin</code> waren und die Site ohne Robin und ehrlich gesagt teilweise ohne Batman funktionieren konnte (er wird den Kampf mit beiden Beinen fortsetzen (Inline-Skripte) gebrochen).  Das war erst gestern und viele "nicht moderne und coole" Seiten sind heute gleich. </p><br><hr><br><p>  Wenn Ihre Anwendung SSR unterst√ºtzt, versuchen Sie <strong>, js</strong> zu <strong>deaktivieren,</strong> damit es ohne SSR funktioniert.  Dann w√§re klar, was in einen Beiwagen gebracht werden k√∂nnte. <br>  Wenn Ihre Anwendung nur ein clientseitiges SPA ist, stellen Sie sich vor, wie es funktionieren w√ºrde, wenn SSR vorhanden w√§re. </p><br><blockquote>  Zum Beispiel - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">theurge.com</a> , geschrieben in React, ist voll funktionsf√§hig, <strong>ohne dass js aktiviert ist</strong> . </blockquote><p>  Es gibt viele Dinge, die Sie in einen Beiwagen auslagern k√∂nnen.  Zum Beispiel: </p><br><ul><li>  Kommentare.  Sie k√∂nnen Code versenden, <code>display</code> Kommentare <code>display</code> , aber nicht <code>answer</code> , solange m√∂glicherweise mehr Code (einschlie√ülich WYSIWYG-Editor) erforderlich ist, der anfangs nicht erforderlich ist.  Es ist besser, ein <em>Kommentarfeld</em> zu verz√∂gern oder das Laden von Code hinter der Animation zu verbergen, als eine ganze Seite zu verz√∂gern. </li><li>  Videoplayer.  Versende "Video" ohne "Steuerelemente".  Laden Sie sie eine Sekunde sp√§ter, damit der Kunde versucht, mit ihm zu interagieren. </li><li>  Bildergalerie, wie <code>slick</code> .  Es ist keine gro√üe Sache, es zu <strong>zeichnen</strong> , aber viel schwieriger zu animieren und zu verwalten.  Es ist klar, was in einen Beiwagen gebracht werden k√∂nnte. </li></ul><br><blockquote>  Denken Sie nur daran, was f√ºr Ihre Anwendung wichtig ist und was nicht ganz ... </blockquote><br><h1 id="implementation-details">  Implementierungsdetails </h1><br><h2 id="di-component-code-splitting">  (DI) Aufteilung des Komponentencodes </h2><br><p>  Die einfachste Form des <code>sidecar</code> ist einfach zu implementieren. Verschieben Sie einfach alles in eine Unterkomponente. Sie k√∂nnen den Code auf "alte" Weise aufteilen.  Es ist fast eine Trennung zwischen <em>Smart-</em> und Dumb-Komponenten, aber dieses Mal setzt Smart keine Dumb-Komponenten fort - es ist das Gegenteil. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SmartComponent = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./SmartComponent'</span></span>)); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DumbComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;SmartComponent ref={this} /&gt; // &lt;-- move smart one inside &lt;TheActualMarkup /&gt; // &lt;-- the "real" stuff is here &lt;/React.Fragment&gt; } }</code> </pre> <br><p>  Dazu muss auch der <em>Initialisierungscode</em> in einen dummen Code verschoben werden. Sie k√∂nnen jedoch weiterhin den <em>schwersten</em> Teil eines Codes in Code aufteilen. </p><br><blockquote>  K√∂nnen Sie jetzt ein <code>parallel</code> oder <code>vertical</code> Code-Aufteilungsmuster sehen? </blockquote><br><h2 id="usesidecar">  useSidecar </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das</a> hier bereits erw√§hnte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen des neuen facebook.com mit React, GraphQL und Relay</a> hatte ein Konzept von <code>loadAfter</code> oder <code>importForInteractivity</code> , das dem Sidecar-Konzept ziemlich √§hnlich ist. </p><br><p>  Gleichzeitig w√ºrde ich nicht empfehlen, so etwas wie <code>useSidecar</code> zu verwenden, solange Sie absichtlich versuchen, <code>hooks</code> Inneren zu verwenden, aber das Aufteilen von Code in dieser Form w√ºrde gegen die Hook- <em>Regel versto√üen</em> . </p><br><p>  Bitte bevorzugen Sie eine deklarativere Komponente.  M√∂glicherweise verwenden Sie <code>hooks</code> in der <code>SideCar</code> Komponente. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Controller = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Controller'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DumbComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = useState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Controller componentRef={ref} state={state} /&gt; &lt;TheRealStuff ref={ref} state={state[0]} /&gt; &lt;/&gt; ) }</code> </pre> <br><h2 id="prefetching">  Prefetching </h2><br><p>  Vergessen Sie nicht - Sie k√∂nnen Ladepriorit√§tshinweise verwenden, um den <code>sidecar</code> vorzuladen oder vorzuholen und den Versand transparenter und unsichtbarer zu machen. </p><br><p>  Wichtige Dinge - das Vorabrufen von Skripten w√ºrde es √ºber das <strong>Netzwerk</strong> laden, aber nicht ausf√ºhren (und CPU ausgeben), es sei denn, es ist tats√§chlich erforderlich. </p><br><h2 id="ssr">  SSR </h2><br><p>  Im Gegensatz zur <em>normalen</em> Codeaufteilung ist f√ºr SSR keine spezielle Aktion erforderlich.  <code>Sidecar</code> m√∂glicherweise nicht Teil des SSR-Prozesses und werden vor dem <code>hydration</code> nicht ben√∂tigt.  Es k√∂nnte "von Natur aus" verschoben werden. </p><br><p>  Verwenden Sie also <code>React.lazy</code> (idealerweise etwas <strong>ohne</strong> <code>Suspense</code> , Sie ben√∂tigen hier keine Failback-Indikatoren (Laden)) oder eine andere Bibliothek mit, aber besser ohne SSR-Unterst√ºtzung, <em>um</em> Seitenwagen-Chunks w√§hrend des SSR-Prozesses zu <em>√ºberspringen</em> . </p><br><h1 id="the-bad-parts">  Die schlechten Teile </h1><br><p>  Aber es gibt ein paar schlechte Teile dieser Idee </p><br><h2 id="batman-is-not-a-production-name">  Batman ist kein Produktionsname </h2><br><p>  W√§hrend <code>Batman</code> / <code>Robin</code> ein gutes Konzept sein k√∂nnte und der <code>sidecar</code> perfekt zur Technologie selbst <code>maincar</code> gibt es keinen "guten" Namen f√ºr den <code>maincar</code> .  Es gibt kein <code>maincar</code> , und offensichtlich d√ºrfen <code>Batman</code> , <code>Lonely Wolf</code> , <code>Solitude</code> , <code>Driver</code> und <code>Solo</code> nicht verwendet werden, um ein Nicht-Beiwagen-Teil zu benennen. </p><br><p>  Facebook hat <code>display</code> und <code>interactivity</code> , und das k√∂nnte die beste Option f√ºr uns alle sein. </p><br><blockquote>  Wenn Sie einen guten Namen f√ºr mich haben - lassen Sie es in den Kommentaren </blockquote><br><h2 id="tree-shaking">  Baum zittern </h2><br><p>  Es geht mehr um die Trennung von Bedenken aus Sicht der <em>B√ºndler</em> .  Stellen wir uns vor, Sie haben <code>Batman</code> und <code>Robin</code> .  Und <code>stuff.js</code> </p><br><ul><li> <code>stuff.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./batman.js`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./robin.js`</span></span></code> </pre> </li></ul><br><p>  Anschlie√üend k√∂nnen Sie versuchen, <em>Komponentenkomponentencode</em> aufzuteilen, um einen Beiwagen zu implementieren </p><br><ul><li><p> <code>main.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {batman} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./stuff.js'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Robin = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./sidecar.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Robin</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // sidecar </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Batman</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // main content </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br></li><li><p> <code>sidecar.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// and sidecar.js... that's another chunk as long as we `import` it import {robin} from './stuff.js' .....</span></span></code> </pre> <br></li></ul><br><p>  Kurz gesagt - der obige Code w√ºrde funktionieren, erledigt aber nicht "den Job". </p><br><ul><li>  Wenn Sie nur <code>batman</code> von <code>stuff.js</code> , w√ºrde das Sch√ºtteln von <code>stuff.js</code> nur das behalten. </li><li>  Wenn Sie nur <code>robin</code> von <code>stuff.js</code> - Baumsch√ºtteln w√ºrde nur es behalten. </li><li>  Wenn Sie jedoch beide verwenden, auch in unterschiedlichen <code>stuff.js</code> , werden beide beim <strong>ersten</strong> Auftreten von <code>stuff.js</code> , dh dem <code>stuff.js</code> , <strong>geb√ºndelt</strong> . </li></ul><br><blockquote>  Das Sch√ºtteln von B√§umen ist nicht Code-Splitting-freundlich.  Sie m√ºssen Bedenken nach Dateien trennen. </blockquote><br><h2 id="un-import">  Import aufheben </h2><br><p>  Eine andere Sache, die von allen vergessen wird, sind die Kosten f√ºr Javascript.  In der jQuery-√Ñra, der √Ñra der <code>jsonp</code> Nutzdaten, war es durchaus √ºblich, das Skript (mit <code>json</code> Nutzdaten) zu laden, die Nutzdaten <code>jsonp</code> und das Skript zu <strong>entfernen</strong> . </p><br><blockquote>  Heutzutage <code>import</code> wir alle <code>import</code> und sie werden f√ºr immer importiert, auch wenn sie nicht mehr ben√∂tigt werden. </blockquote><p>  Wie ich bereits sagte - es gibt zu viel JS, und fr√ºher oder sp√§ter werden Sie bei <em>kontinuierlicher Navigation</em> alles laden.  Wir sollten einen Weg finden, den Import zu entfernen, keinen Block mehr zu ben√∂tigen, alle internen Caches zu l√∂schen und Speicher freizugeben, um das Web zuverl√§ssiger zu machen und Anwendungen nicht mit Ausnahme von Speichermangel zu zerst√∂ren. </p><br><p>  Wahrscheinlich ist die M√∂glichkeit zum Aufheben <code>un-import</code> (Webpack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnte dies tun</a> ) einer der Gr√ºnde, warum wir bei der <em>komponentenbasierten</em> API bleiben sollten, solange wir die M√∂glichkeit haben, das Aufheben der Bereitstellung zu handhaben. </p><br><p>  Bisher haben ESM-Modulstandards nichts mit solchen Dingen zu tun - weder mit der Cache-Steuerung noch mit dem Umkehren der Importaktion. </p><br><h2 id="creating-a-sidecar-enabled-library">  Erstellen einer Sidecar-f√§higen Bibliothek </h2><br><p>  Bis heute gibt es nur einen Weg, eine <code>sidecar</code> f√§hige Bibliothek zu erstellen: </p><br><ul><li>  Teilen Sie Ihre Komponente in Teile </li><li>  Stellen Sie einen <code>main</code> und einen <code>connected</code> Teil (um die API nicht zu besch√§digen) √ºber den <code>index</code> </li><li>  Legen Sie einen <code>sidecar</code> √ºber einen separaten Einstiegspunkt frei. </li><li>  Im Zielcode - Importieren Sie das <code>main</code> und das <code>sidecar</code> - Baumsch√ºtteln sollte ein <code>connected</code> Teil schneiden. </li></ul><br><p>  Dieses Mal sollte das Baumsch√ºtteln richtig funktionieren, und das einzige Problem ist, wie man den <code>main</code> benennt. </p><br><ul><li> <code>main.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Main = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{sidecar, ...props}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {sidecar} .... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><ul><li> <code>connected.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sidecar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Main</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sidecar</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Sidecar</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">} {...props} /&gt; );</span></span></code> </pre> <br><ul><li> <code>index.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Connected'</span></span>;</code> </pre> <br><ul><li> <code>sidecar.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>;</code> </pre> <br><p>  Kurz gesagt, die √Ñnderung k√∂nnte durch einen kleinen Vergleich dargestellt werden </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//your app BEFORE import {Connected} from 'library'; // // ------------------------- //your app AFTER, compare this core to `connected.js` import {Main} from 'library'; const Sidecar = React.lazy(import( () =&gt; import('library/sidecar'))); // ^ all the difference ^ export SideConnected = props =&gt; ( &lt;Main sidecar={&lt;Sidecar /&gt;} {...props} /&gt; ); // ^ you will load only Main, Sidecar will arrive later.</span></span></code> </pre> <br><p>  Theoretisch k√∂nnte ein <code>dynamic import</code> innerhalb von node_modules verwendet werden, um den <em>Assemblierungsprozess</em> transparenter zu machen. </p><br><blockquote>  Wie auch immer - es ist nichts weiter als ein <code>children</code> / <code>slot</code> Muster, das in React so h√§ufig vorkommt. </blockquote><br><h1 id="the-future">  Die Zukunft </h1><br><p>  <code>Facebook</code> bewiesen, dass die Idee richtig ist.  Wenn Sie das Video noch nicht gesehen haben, machen Sie es jetzt.  Ich habe gerade die gleiche Idee aus einem etwas anderen Blickwinkel erkl√§rt (und eine Woche vor der F8-Konferenz angefangen, diesen Artikel zu schreiben). </p><br><p>  Im Moment m√ºssen einige Code√§nderungen auf Ihre Codebasis angewendet werden.  Es erfordert eine explizitere Trennung der Bedenken, um sie tats√§chlich zu trennen, und die Codeaufteilung erfolgt nicht horizontal, sondern vertikal, wodurch <em>weniger</em> Code f√ºr eine <em>gr√∂√üere</em> Benutzererfahrung ausgeliefert wird. </p><br><p>  <code>Sidecar</code> ist wahrscheinlich die einzige M√∂glichkeit, mit Ausnahme der SSR der alten Schule, mit BIG-Codebasen umzugehen.  Letzte Chance, eine minimale Menge an Code zu versenden, wenn Sie viel davon haben. </p><br><blockquote>  Es k√∂nnte eine BIG-Anwendung kleiner und eine SMALL-Anwendung noch kleiner machen. </blockquote><p>  Vor 10 Jahren war die mittlere Website in 300 ms "fertig" und einige Millisekunden sp√§ter <em>wirklich</em> fertig.  Heute sind Sekunden und sogar mehr als 10 Sekunden die gebr√§uchlichen Zahlen.  Was f√ºr eine Schande. </p><br><p>  Machen wir eine Pause und √ºberlegen, wie wir das Problem l√∂sen und UX wieder gro√üartig machen k√∂nnen ... </p><br><p><img src="https://habrastorage.org/webt/8_/5u/7e/8_5u7ehdn7nkcjiaqfv1-rzadfa.jpeg"></p><br><h1 id="overall">  Insgesamt </h1><br><ul><li>  Das Aufteilen von Komponentencode ist ein √§u√üerst leistungsf√§higes Tool, mit dem Sie etwas <em>vollst√§ndig</em> aufteilen k√∂nnen. Es ist jedoch mit Kosten verbunden. M√∂glicherweise wird f√ºr eine Weile nur eine leere Seite oder ein <em>Skelett</em> angezeigt.  Das ist eine horizontale Trennung. </li><li>  Die Aufteilung des Bibliothekscodes k√∂nnte hilfreich sein, wenn die Aufteilung der Komponenten dies nicht tun w√ºrde.  Das ist eine horizontale Trennung. </li><li>  Code, der in einen Beiwagen abgeladen wird, vervollst√§ndigt das Bild und erm√∂glicht Ihnen m√∂glicherweise eine weitaus bessere Benutzererfahrung.  W√ºrde aber auch einen gewissen technischen Aufwand erfordern.  Das ist eine vertikale Trennung. </li></ul><br><p>  <strong>Lassen Sie uns ein Gespr√§ch dar√ºber f√ºhren</strong> . </p><br><h2 id="stop-so-what-about-the-problems-you-tried-to-solve">  H√∂r auf!  Was ist also mit den Problemen, die Sie zu l√∂sen versucht haben? </h2><br><p>  Nun, das war nur der erste Teil.  <strong>Wir sind jetzt im Endspiel</strong> , es w√ºrde noch einige Wochen dauern, bis der zweite Teil dieses Vorschlags aufgeschrieben ist.  In der Zwischenzeit ... steigen Sie in den Beiwagen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450942/">https://habr.com/ru/post/de450942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450926/index.html">3D-Spiel auf three.js, nw.js.</a></li>
<li><a href="../de450928/index.html">Wie Rechenzentren Urlaub sparen</a></li>
<li><a href="../de450930/index.html">Wie wir # bigdataX5 entwickeln und wer in Big Data ben√∂tigt wird</a></li>
<li><a href="../de450938/index.html">Linux Install Fest 05.19 in Nischni Nowgorod 18. Mai 2019</a></li>
<li><a href="../de450940/index.html">Vivaldi 2.5 - Attraktiver Makrokosmos</a></li>
<li><a href="../de450946/index.html">Festplatten-Handy auf LPC810</a></li>
<li><a href="../de450948/index.html">MU-MIMO: einer der Implementierungsalgorithmen</a></li>
<li><a href="../de450950/index.html">Dart Streams Grundlagen</a></li>
<li><a href="../de450952/index.html">Mittlerer Index und Antibank</a></li>
<li><a href="../de450954/index.html">Wie wir gelernt haben, Java in Docker auszunutzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>