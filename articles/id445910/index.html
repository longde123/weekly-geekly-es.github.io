<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëá üèîÔ∏è üîä Bagaimana kami berteman dengan EF 6 MSSQL dan PostgresSQL üî≤ üïã üéûÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekali waktu ada proyek di EF 6 dengan MSSQL DBMS. Dan ada kebutuhan untuk menambahkan kemampuan untuk bekerja dengan PostgreSQL. Kami tidak mengharap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami berteman dengan EF 6 MSSQL dan PostgresSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/crosstech/blog/445910/"><img src="https://habrastorage.org/webt/_a/jr/dp/_ajrdpk_rrdrsqmckt71xkfceve.jpeg" alt="gambar"><br><br>  Sekali waktu ada proyek di EF 6 dengan MSSQL DBMS.  Dan ada kebutuhan untuk menambahkan kemampuan untuk bekerja dengan PostgreSQL.  Kami tidak mengharapkan masalah di sini, karena ada banyak artikel tentang topik ini, dan di forum Anda dapat menemukan diskusi tentang masalah yang sama.  Namun, pada kenyataannya, tidak semuanya ternyata sangat sederhana, dan dalam artikel ini kita akan berbicara tentang pengalaman ini, tentang masalah yang kami temui selama integrasi penyedia baru, dan tentang solusi yang kami pilih. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Kami memiliki produk kotak, dan memiliki struktur yang sudah mapan.  Awalnya, itu dikonfigurasi untuk bekerja dengan satu DBMS - MSSQL.  Proyek ini memiliki lapisan akses data dengan implementasi EF 6 (pendekatan Code First).  Kami bekerja dengan migrasi melalui Migrasi EF 6.  Migrasi dibuat secara manual.  Instalasi awal basis data terjadi dari aplikasi konsol dengan inisialisasi konteks pada string koneksi, diteruskan sebagai argumen: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"No arguments in command line"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Initializing dbcontext via </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{connectionString}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = MyDbContext(connectionString)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Database created"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Console.WriteLine(e.Message); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br>  Pada saat yang sama, infrastruktur EF dan domain domain dijelaskan dalam proyek lain, yang terhubung ke aplikasi konsol sebagai perpustakaan.  Konstruktor konteks dalam proyek infrastruktur terlihat seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyDbContext</span></span> : <span class="hljs-title"><span class="hljs-title">IdentityDbContext</span></span>&lt;<span class="hljs-title"><span class="hljs-title">User</span></span>, <span class="hljs-title"><span class="hljs-title">Role</span></span>, <span class="hljs-title"><span class="hljs-title">Key</span></span>, <span class="hljs-title"><span class="hljs-title">UserLogin</span></span>, <span class="hljs-title"><span class="hljs-title">UserRole</span></span>, <span class="hljs-title"><span class="hljs-title">UserClaim</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IUnitOfWork</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDbContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connectionString</span></span></span><span class="hljs-function">)</span></span> { Database.SetInitializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbInitializer()); Database.Initialize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre><br><h3>  Peluncuran pertama </h3><br>  Hal pertama yang kami lakukan adalah menghubungkan dua paket ke proyek melalui nuget: Npgsql dan EntityFramework6.Npgsql. <br><br>  Kami juga mendaftarkan pengaturan untuk Postgres di App.config dari aplikasi konsol kami. <br><br>  Bagian entityFramework menetapkan pabrik postgres default sebagai pabrik koneksi: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entityFramework</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--&lt;defaultConnectionFactory type="System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework" /&gt;--&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defaultConnectionFactory</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlConnectionFactory, EntityFramework6.Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">providers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariantName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Data.SqlClient"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariantName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlServices, EntityFramework6.Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">providers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entityFramework</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Di bagian DbProviderFactories, pabrik penyedia baru terdaftar: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.data</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DbProviderFactories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">add</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql Data Provider"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariant</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">support</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"FF"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">description</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".Net Framework Data Provider for Postgresql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlFactory, Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DbProviderFactories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.data</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Dan segera, mereka mencoba menginisialisasi database dengan menentukan alamat server Postgres dan kredensial admin server dalam string koneksi.  Hasilnya adalah baris berikut: <br><blockquote>  ‚ÄúServer = localhost;  DataBase = TestPostgresDB;  Keamanan Terpadu = salah;  User Id = postgres;  kata sandi = pa $$ w0rd ‚Äù </blockquote>  Seperti yang diharapkan, berkat mode Migrasi EF manual, inisialisasi tidak lulus, dan terjadi kesalahan yang tidak cocok dengan gambar database model saat ini.  Untuk mengatasi penciptaan migrasi utama dengan penyedia baru dan menguji inisialisasi database pada Postgres, kami sedikit menyesuaikan konfigurasi infrastruktur kami. <br><br>  Pertama, kami mengaktifkan "migrasi otomatis" - opsi yang berguna jika satu pengembang membuat perubahan pada model domain dan infrastruktur EF di tim: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Configuration</span></span> : <span class="hljs-title"><span class="hljs-title">DbMigrationsConfiguration</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; } }</code> </pre><br>  Kedua, kami menetapkan penyedia baru dalam metode yang didefinisikan ulang InitializeDatabase dari kelas yang diwarisi CreateDatabaseIfNotExists, tempat kami memulai migrasi: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbInitializer</span></span> : <span class="hljs-title"><span class="hljs-title">CreateDatabaseIfNotExists</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeDatabase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyDbContext context</span></span></span><span class="hljs-function">)</span></span> { DbMigrator dbMigrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMigrator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Configuration { <span class="hljs-comment"><span class="hljs-comment">//TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, "System.Data.SqlClient") TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, "Npgsql") }); // There some code for run migrations } }</span></span></code> </pre><br>  Selanjutnya, kami meluncurkan aplikasi konsol kami lagi dengan string koneksi yang sama sebagai argumen.  Kali ini, inisialisasi konteks berjalan tanpa kesalahan, dan model domain kami dengan aman masuk ke dalam database Postgres baru.  Label "__MigrationHistory" muncul di database baru, di mana ada satu catatan migrasi pertama yang dibuat secara otomatis. <br><br>  Untuk meringkas: kami dapat menghubungkan penyedia baru ke proyek yang ada tanpa masalah, tetapi pada saat yang sama mengubah pengaturan mekanisme migrasi. <br><br><h3>  Aktifkan mode migrasi manual </h3><br>  Seperti disebutkan di atas, ketika mode migrasi otomatis aktif, Anda menghilangkan tim pengembangan paralel Anda di domain dan area akses data.  Bagi kami, opsi ini tidak dapat diterima.  Oleh karena itu, kami perlu menyiapkan mode migrasi manual dalam proyek. <br><br>  Pertama, kami mengembalikan bidang AutomaticMigrationsEnabled ke false.  Maka itu perlu untuk berurusan dengan penciptaan migrasi baru.  Kami memahami bahwa migrasi untuk DBMS yang berbeda, setidaknya, harus disimpan dalam folder proyek yang berbeda.  Oleh karena itu, kami memutuskan untuk membuat folder baru untuk migrasi Postgres dalam proyek infrastruktur yang disebut PostgresMigrations (folder dengan migrasi MsSql, untuk kejelasan, kami menamainya MsSqlMigrations), dan menyalin file konfigurasi migrasi MsSql ke sana.  Pada saat yang sama, kami tidak menyalin semua migrasi MsSql yang ada ke PostgresSql.  Pertama, karena semuanya berisi snapshot dari konfigurasi untuk penyedia MsSql dan, oleh karena itu, kami tidak akan dapat menggunakannya pada DBMS baru.  Kedua, sejarah perubahan tidak penting untuk DBMS baru, dan kita bisa bertahan dengan snapshot terbaru dari keadaan model domain. <br><br>  Kami pikir semuanya siap untuk pembentukan migrasi pertama ke Postgres.  Database yang dibuat selama inisialisasi konteks dengan mode migrasi otomatis dihidupkan telah dihapus.  Dan, dipandu oleh fakta bahwa untuk migrasi pertama Anda perlu membuat database fisik berdasarkan keadaan model domain saat ini, kami dengan senang hati mencetak perintah Update-Database di Package Manager Console, yang hanya menentukan parameter string koneksi.  Akibatnya, kami mendapatkan kesalahan terkait dengan koneksi ke DBMS. <br><br>  Selain mempelajari prinsip kerja perintah Update-Database, kami melakukan hal berikut: <br><br><ul><li>  menambahkan kode berikut ke pengaturan konfigurasi migrasi: <br><br>  untuk MsSql: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; MigrationsDirectory = <span class="hljs-string"><span class="hljs-string">@"MsSqlMigrations"</span></span>; }</code> </pre><br>  untuk Postgres: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; MigrationsDirectory = <span class="hljs-string"><span class="hljs-string">@"PostgresMigrations"</span></span>; }</code> </pre></li><li>  menunjukkan parameter yang diperlukan dari perintah Update-Database lewat nama penyedia </li><li>  menambahkan parameter yang menunjukkan proyek yang berisi deskripsi infrastruktur ef, dan folder dengan konfigurasi migrasi penyedia baru </li></ul><br>  Sebagai hasilnya, kami mendapat perintah ini: <br><blockquote>  Update-Database -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.PostgresMigrations.Configuration -ConnectionString "Server = localhost;  DataBase = TestPostgresDB;  Keamanan Terpadu = salah;  User Id = postgres;  password = pa $$ w0rd "-ConnectionProviderName" Npgsql " </blockquote>  Setelah menjalankan perintah ini, kami dapat menjalankan perintah Add-Migration dengan parameter yang serupa, menamai migrasi pertama InitialCreate: <br><blockquote>  Add-Migration -Nama "InitialCreate" -ProjectName "CrossTech.DSS.Infrastructure" -ConfigurationTypeName CrossTech.DSS.Infrastructure.PostgresMigrations.Configuration -ConnectionString "Server = localhost;  DataBase = TestPostgresDB;  Keamanan Terpadu = salah;  User Id = postgres;  password = pa $$ w0rd "-ConnectionProviderName" Npgsql " </blockquote>  File baru telah muncul di folder PostgresMigrations: 2017010120705068_InitialCreate.cs <br><br>  Kemudian kami menghapus database yang dibuat setelah menjalankan perintah Update-Database dan meluncurkan aplikasi konsol kami dengan string koneksi yang ditunjukkan di atas sebagai argumen.  Jadi kami sudah mendapatkan basis data berdasarkan migrasi yang dibuat secara manual. <br><br>  Untuk meringkas: kami dapat, dengan sedikit usaha, untuk menambahkan migrasi pertama untuk penyedia Postgres dan menginisialisasi konteks melalui aplikasi konsol, mendapatkan database baru, di mana perubahan dari migrasi manual pertama kami datang. <br><br><h3>  Beralih di antara penyedia </h3><br>  Kami masih memiliki satu pertanyaan terbuka: bagaimana cara mengonfigurasi inisialisasi konteks sehingga memungkinkan untuk mengakses DBMS tertentu dalam runtime? <br><br>  Tugasnya adalah bahwa pada tahap inisialisasi konteks dimungkinkan untuk memilih satu atau beberapa database target dari penyedia yang diinginkan.  Sebagai hasil dari upaya berulang-ulang untuk mengkonfigurasi switch ini, kami datang dengan solusi yang terlihat seperti ini. <br><br>  Dalam aplikasi konsol proyek di app.config (dan jika Anda tidak menggunakan app.config, maka machine.config), kami menambahkan string koneksi baru dengan penyedia dan nama koneksi, dan dalam konstruktor konteks kami ‚Äúmenjatuhkan‚Äù nama koneksi alih-alih string koneksi.  Pada saat yang sama, kami menghubungkan string koneksi itu sendiri ke konteks melalui singleton dari instance DbConfiguration.  Kami melewati instance dari kelas yang diwarisi dari DbConfiguration sebagai parameter. <br><br>  Kelas DbConfiguration bawaan yang dihasilkan: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbConfig</span></span> : <span class="hljs-title"><span class="hljs-title">DbConfiguration</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DbConfig</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> provideName</span></span></span><span class="hljs-function">)</span></span> { ConfigurationManager.ConnectionStrings.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConnectionStringSettings(connectionName, connectionString, provideName)); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"PostgresDbConnection"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NpgsqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderServices(provideName, NpgsqlServices.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderFactory(provideName, NpgsqlFactory.Instance); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MsSqlDbConnection"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderServices(provideName, SqlProviderServices.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderFactory(provideName, SqlClientFactory.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br>  Dan inisialisasi konteks itu sendiri sekarang terlihat seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> provideName = args[<span class="hljs-number"><span class="hljs-number">2</span></span>]; DbConfiguration.SetConfiguration(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbConfig(connectionName, connectionString, provideName)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = MyDbContext(connectionName)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Database created"</span></span>); }</code> </pre><br>  Dan yang mengikuti dengan hati-hati, dia mungkin memperhatikan bahwa kita harus membuat satu lagi perubahan dalam kode.  Ini adalah definisi dari database target selama inisialisasi database, yang terjadi dalam metode InitializeDatabase yang dijelaskan sebelumnya. <br><br>  Kami menambahkan sakelar sederhana untuk menentukan konfigurasi migrasi penyedia tertentu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbInitializer</span></span> : <span class="hljs-title"><span class="hljs-title">CreateDatabaseIfNotExists</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _connectionName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DbInitializer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionName</span></span></span><span class="hljs-function">)</span></span> { _connectionName = connectionName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeDatabase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyDbContext context</span></span></span><span class="hljs-function">)</span></span> { DbMigrationsConfiguration&lt;MyDbContext&gt; config; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"PostgresDbConnection"</span></span>: config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostgresMigrations.Configuration(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MsSqlDbConnection"</span></span>: config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MsSqlMigrations.Configuration(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: config = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (config == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; config.TargetDatabase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbConnectionInfo(_connectionName); DbMigrator dbMigrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMigrator(config); <span class="hljs-comment"><span class="hljs-comment">// There some code for run migrations } }</span></span></code> </pre><br>  Dan konstruktor konteks itu sendiri mulai terlihat seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDbContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionNameParam</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connectionString</span></span></span><span class="hljs-function">)</span></span> { Database.SetInitializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbInitializer(connectionName = connectionNameParam)); Database.Initialize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br>  Selanjutnya, kami meluncurkan aplikasi konsol dan menentukan parameter aplikasi MsSql sebagai penyedia DBMS.  Kami menetapkan argumen untuk aplikasi sebagai berikut: <blockquote>  "MsSqlDbConnection" "Server = localhost \ SQLEXPRESS;  Database = TestMsSqlDB;  ID Pengguna = sa;  password = pa $$ w0rd "" System.Data.SqlClient " </blockquote><br>  Database MsSql dibuat tanpa kesalahan. <br><br>  Kemudian kami tentukan argumen aplikasi: <br><blockquote>  "PostgresDbConnection" "Server = localhost;  DataBase = TestPostgresDB;  Keamanan Terpadu = salah;  User Id = postgres;  kata sandi = pa $$ w0rd "" Npgsql " </blockquote>  Basis data Postgres juga dibuat tanpa kesalahan. <br><br>  Jadi, satu lagi subtotal - agar EF dapat menginisialisasi konteks basis data untuk penyedia tertentu, dalam runtime yang Anda butuhkan: <br><br><ul><li>  ‚ÄúTunjukkan‚Äù mekanisme migrasi ke penyedia ini </li><li>  mengkonfigurasi string koneksi DBMS sebelum inisialisasi konteks </li></ul><br><h3>  Kami bekerja dengan migrasi dua DBMS dalam satu tim </h3><br>  Seperti yang kita lihat, bagian yang paling menarik dimulai setelah kemunculan perubahan baru di domain.  Anda perlu membuat migrasi untuk dua DBMS dengan mempertimbangkan penyedia tertentu. <br><br>  Jadi, untuk MSSQL Server, Anda perlu menjalankan perintah berurutan (untuk Postgres, perintah yang dijelaskan di atas, saat membuat migrasi pertama): <br><br><ul><li>  memperbarui basis data sesuai dengan snapshot terakhir <br><blockquote>  Update-Database -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.MsSqlMigrations.Configuration -ConnectionString "Server = localhost;  DataBase = TestMsSqlDB;  Keamanan Terpadu = salah;  ID Pengguna = sa;  password = pa $$ w0rd "-ConnectionProviderName" System.Data.SqlClient " </blockquote></li><li>  menambahkan migrasi baru <br><blockquote>  Add-Migration -Name "SomeMigrationName" -ProjectName "Project.Infrastructure" -ConfigurationTypeName Project.Infrastructure.MsSqlMigrations.Configuration -ConnectionString "Server = localhost;  DataBase = TestMsSqlDB;  Keamanan Terpadu = salah;  ID Pengguna = sa;  password = pa $$ w0rd "-ConnectionProviderName" System.Data.SqlClient " </blockquote></li></ul><br>  Ketika pengembang membuat perubahan pada domain secara paralel, kami mendapatkan beberapa konflik saat menggabungkan perubahan ini dalam sistem kontrol versi (untuk kesederhanaan kami akan memanggil git).  Ini disebabkan oleh kenyataan bahwa migrasi ke EF berjalan berurutan satu demi satu.  Dan jika satu pengembang membuat migrasi, maka pengembang lain tidak akan berhasil menambahkan migrasi secara berurutan.  Setiap migrasi selanjutnya menyimpan informasi tentang yang sebelumnya.  Dengan demikian, perlu memperbarui snapshot model yang disebut dalam migrasi ke yang dibuat terakhir. <br><br>  Pada saat yang sama, menyelesaikan konflik pada migrasi EF di tim turun ke memprioritaskan pentingnya perubahan dari pengembang tertentu.  Dan yang perubahannya lebih tinggi dalam prioritas, mereka harus menjadi yang pertama mengisinya dalam git, dan pengembang lainnya sesuai dengan hierarki yang disepakati perlu melakukan hal berikut: <br><br><ol><li>  hapus migrasi lokal yang dibuat </li><li>  tarik perubahan dari repositori ke diri Anda sendiri, di mana kolega lain dengan prioritas tinggi telah menuangkan migrasi mereka </li><li>  buat migrasi lokal dan unggah perubahan yang dihasilkan kembali ke git </li></ol><br>  Sejauh yang kita kenal dengan mekanisme migrasi EF, kita dapat menilai bahwa pendekatan pengembangan tim yang dijelaskan adalah satu-satunya saat ini.  Kami tidak menganggap solusi ini ideal, tetapi memiliki hak untuk hidup.  Dan pertanyaan untuk menemukan alternatif bagi mekanisme Migrasi EF telah menjadi hal yang mendesak bagi kami. <br><br><h3>  Kesimpulannya </h3><br>  Bekerja dengan beberapa DBMS menggunakan EF6 bersamaan dengan Migrasi EF adalah nyata, tetapi dalam versi ini orang-orang dari Microsoft tidak memperhitungkan kemungkinan kerja paralel dari tim menggunakan sistem kontrol versi. <br><br>  Ada banyak alternatif solusi Migrasi EF di pasaran (baik berbayar maupun gratis): DbUp, RoundhousE, ThinkingHome.Migrator, FluentMigrator, dll.  Dan dilihat dari ulasannya, mereka lebih mirip pengembang daripada Migrasi EF. <br><br>  Untungnya, kami sekarang memiliki kesempatan untuk melakukan semacam peningkatan dalam proyek kami.  Dan dalam waktu dekat kami akan beralih ke EF Core.  Kami mempertimbangkan pro dan kontra dari mekanisme Migrasi Inti EF dan sampai pada kesimpulan bahwa akan lebih mudah bagi kami untuk bekerja dengan solusi pihak ketiga, yaitu Fluent Migrator. <br><br>  Kami harap Anda tertarik dengan pengalaman kami.  Siap menerima komentar dan menjawab pertanyaan, Selamat Datang! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445910/">https://habr.com/ru/post/id445910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445898/index.html">Tentang ide baru, pandangan sempit dan dari mulut ke mulut</a></li>
<li><a href="../id445900/index.html">Cara menahan peningkatan beban sistem: bicarakan persiapan skala besar untuk Black Friday</a></li>
<li><a href="../id445904/index.html">Jenis infinitas dan batang otak</a></li>
<li><a href="../id445906/index.html">Jangan makan aspirin</a></li>
<li><a href="../id445908/index.html">Golang dan evolusi interaksi basis data</a></li>
<li><a href="../id445912/index.html">Hai, Habr, kami adalah Advantech</a></li>
<li><a href="../id445914/index.html">Apakah Docker mainan atau tidak? Atau benarkah demikian?</a></li>
<li><a href="../id445918/index.html">20 tahun RollerCoaster Tycoon: wawancara dengan pencipta game</a></li>
<li><a href="../id445920/index.html">Langsung: cara mengekang pengembangan iOS di tim besar</a></li>
<li><a href="../id445922/index.html">Mengapa menonton siaran online jika Anda dapat membaca Habr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>