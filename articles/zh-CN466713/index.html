<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏽 🚋 🤛🏼 1C中是否可能不遵守外部组件的技术？ 或如何祝贺使用1C的同事？ 👨🏽‍🎨 🍷 🐑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这里有个主意是要以某种新颖的方式祝贺我们的总会计师，例如，借助她最喜欢的1C程序？ 但是如何？ 

 经过一番思考，该想法开始用于背景祝贺，即在1C77-1C82上常规配置的客户区域中的背景图像，或在1C82托管窗体以及在所有情况下对于1C83的外部窗口中的背景图像。 如图所示，在其上显示所需的消息...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>1C中是否可能不遵守外部组件的技术？ 或如何祝贺使用1C的同事？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466713/"> 这里有个主意是要以某种新颖的方式祝贺我们的总会计师，例如，借助她最喜欢的1C程序？ 但是如何？ <br><br> 经过一番思考，该想法开始用于背景祝贺，即在1C77-1C82上常规配置的客户区域中的背景图像，或在1C82托管窗体以及在所有情况下对于1C83的外部窗口中的背景图像。 如图所示，在其上显示所需的消息并提供指向祝贺视频的链接。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a77/0bd/055/a770bd055ca43fdb5ad8d6f1f124253b.jpg" alt="祝贺1C"><br><a name="habracut"></a><br><h2> 第一部分-结果 </h2><br> 显然，这个想法并不新鲜。 因此，在2011年， <b><i>Aleksey Fedorov又名ALF</i></b>提出了基于<b>FormEx.dll</b>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类似解决方案</a> 。 早在2008年就提出了有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何实现这一目标</a>的问题。 <br><br> 一次，我们还使用此组件将背景图像加载到1C77中。 但是，下载大的bmp文件（以及其他不能使用的文件）的速度很慢（因此，使用了铺有瓷砖的小图片），因此希望编写自己的外部组件（VK），它将仅下载必要的图像，仅此而已，除非还有什么可以作为实验的试验场。 <br><br> 编写了这样的组件（也仅用于bmp文件，必要时使用平铺）。 在那里使用了<b>WinAPI LoadImage（）</b>函数。 该dll与FormEx.dll没有冲突，它很简单，足够快并且可以使用很长时间。 <br><br> 所有这些都很棒，但是现在是扩展其功能的时候了，这里需要一种不同的方法。 <br><br> 在本文中，我们不会解决创建多媒体文件的问题。 这不是我们的专长。 我们只限于为1C编程外部组件的一些细微差别。 <br><br><h3>  1C77 </h3><br> 由于1C平台的版本可能不同，因此可以有多种解决方案。 在我们的案例中，这些是1C77上的配置（图1）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b4/611/4ad/8b46114ad1ae83e57667cc4bb84aae7e.jpg" alt="图1. 1C77上的测试配置中的祝贺图片"><br> 图  1.祝贺您在1C77上的测试配置中的图像。 <br><br> 此处的视频虽然是自己的，但其创作思想是从<b><i>安娜·希亚诺娃（Anna Shiyanova）那里</i></b>获得的<b><i>，昵称为“特例”</i></b> 。 这个女孩有才华，可以被模仿，但是很难完全重复这种风格。 在这种情况下，我只想要至少一些创造力。 <br><br> 如果其中一位同事已经厌倦了看着别人的祝贺，那么他们可以用“ <b>Alt + I</b> ”重载图片（图2-3）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/01a/8c1/200/01a8c120008b72dd648b7c8697298d65.jpg" alt="图2.在“文件/选择背景”菜单中或通过“ Alt + I”选择另一个背景图像"><br> 图  2.在“文件/选择背景”菜单中或通过“ Alt + I”选择其他背景图像。 <br><br> 并且同时查看有关“ <b>Alt + L</b> ”所使用的模块的信息（图3）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/499/499/f23/499499f23ec33734bd6a5068f5d493b8.jpg" alt="图3.重载的背景图片以及有关程序的信息（“帮助/关于LionExt32.dll模块”或“ Alt + L”）"><br> 图  3.重载背景图像以及有关程序的信息（“帮助/关于LionExt32.dll模块”或“ Alt + L”）。 <br><br><h3>  1C82常规形式 </h3><br> 自然，大多数现在都面向G8（1C8x）。 但是，只有在8.2版及更低版本中的普通格式下，才可以在1C中使用背景图像，并且，如果您不使用任何以“桌面”模式开始的处理，这将完全覆盖我们的背景（图4）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/390/123/bfd/390123bfd2ef88bfbc108dbe44c70835.jpg" alt="图4.普通表格1C82中测试配置中的祝贺图片"><br> 图  4.在常规配置1C82上的测试配置中显示祝贺图像。 <br><br> 请注意，链接到图。  4表示不是我们的视频。 显示它们只是为了测试。 <br><br> 在普通形式中，1C82不再提供标准的菜单访问方式，因为它不是系统性的（如“七个”而是“拥有的”）（尽管可以创建系统，但是为什么我们需要两个主菜单？）。 但是，可以使用热键。 同样，在我们的组件中，“ Alt + I”将调用一个对话框，如图2所示，并加载另一个背景（图5）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3f/535/deb/c3f535deb522e2ae7ad8937ce31b1188.jpg" alt="图5.以“厚” 1C82形式重载背景图像"><br> 图  5.以“厚” 1C82格式重载背景图像。 <br><br> 同样，您可以通过按“ Alt + L”键来获取有关模块的信息，如图2所示。  3。 <br><br><h3>  1C82托管表格 </h3><br> 对于1C82中的托管表单，您仍然可以在第七个嵌套级别中找到所需的窗口，例如“ <b>V8FormElement</b> ”并在其上进行绘制，但是以某种方式，它并不有趣。 <br><br> 对我们来说，从这些考虑中可以得出结论，创建一个带有祝贺消息的外部窗口（图6）比处理每个个案要容易得多。 通过“ <b>Esc</b> ”，“ <b>Ctrl + F4</b> ”，“ <b>Alt + F4</b> ”或单击“ <b>叉号</b> ”，可以更精确地关闭窗口本身。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/790/cd9/79d/790cd979df8a4d97ff5488c50fa4bd6c.jpg" alt="图6.托管表单1C82上的测试配置中的祝贺图像"><br> 图  6.托管表单1C82上测试配置中的祝贺图像。 <br><br> 此外，最小化的窗口（图7）可以再次扩大。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/1a7/c7f/66c1a7c7f725404604318cdcde3a9915.jpg" alt="图7.托管表单1C82上的外部窗口的最小化图像"><br> 图  7.托管表单1C82上的外部窗口的最小化图像。 <br><br> 外窗的尺寸和相对位置可以更改，此处一切都与往常一样（请参见图6和图10中的外窗放大图）。 请注意，仅当外部窗口处于活动状态时，热键才起作用。 <br><br><h3>  1C83常规形式 </h3><br> 在1C83中，根本没有更多的子窗口，这些子窗口可以用作dll中1C版本的标准。 此外，“厚”表单是框架窗口（图8），托管表单是无框架的（图9）。 也就是说，所有不是框架的东西都可以重绘。 框架也可以重绘，但只能作为系统元素。 <br><div class="scrollable-table"><table><tbody><tr><th><img src="https://habrastorage.org/getpro/habr/post_images/f9c/35e/0da/f9c35e0da01025306525d14f700d22a4.jpg" alt="图8.框架窗口以“厚”形式1C83"></th><th><img src="https://habrastorage.org/getpro/habr/post_images/962/5f9/e7c/9625f9e7c28fed4c9226ee73d8126ed8.jpg" alt="图9.托管形式1C83的无框窗口"></th></tr><tr><th> 图  8.以“厚”形式的框架窗口1C83。 </th><th> 图  9.受控形式1C83的无框窗口。 </th></tr></tbody></table></div> 在这里，我们使用动态库创建了一个测试窗口，并将其从属于1C主窗口。 在图中可以看出行为上的差异。 <br><br><h3>  1C83托管表格 </h3><br> 在1C83的情况下，就像在托管表格1C82中一样，我们不是在背景下而是在一个单独的窗口中（图11中显示了其原型）来表示祝贺。  8-9。 结果，所需的组件（ <b>LionExt32.dll</b>或<b>LionExt64.dll</b> ）将给出以下结果（图10-12）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/104/cf1/f10/104cf1f10c6ae652d24edea7082c7e6c.jpg" alt="图10.常规表格1C83的外部窗口中的背景图像"><br> 图  10.常规表格1C83的外部窗口中的背景图像。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56a/03f/fc7/56a03ffc7fe1f2bfee6358ecb81af9fa.jpg" alt="图11.托管表单1C83，发行版14，64位版本的外部窗口中的背景图像"><br> 图  11.受管表格1C83，版本14，64位版本的外部窗口中的背景图像。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/05e/12f/71c/05e12f71ccfb9212b96bc3db92630869.jpg" alt="图12.托管表单1C83，版本15，64位版本的外部窗口中的背景图像"><br> 图  12.托管表单1C83，版本15，64位版本的外部窗口中的背景图像。 <br><br><h3> 初步发现 </h3><br> 该组件实际上已在实践中使用（图1），总会计师感到满意，一切都进行得非常好。 一路走来，事实证明，用户喜欢选择自己的背景图片，在这种情况下，需要处理“七个”图片。 对于G8，我们的组件已适应将来的储备，但应将其视为演示版本。 <br><br> 这里的兴趣在于<b><i>该组件不需要符合从1C创建外部组件的技术</i></b> 。 也许会出现其他想法来扩展其功能。 例如，对于完全受支持的配置，您不想在没有特殊需要的情况下更改1C代码。 在这种情况下，可以选择将任意dll外部加载到地址空间1C中。 但这是另一篇文章的主题。 <br><br> 在技​​术创新中，使用了锁来通过1C平台卸载我们的组件（因为它不符合VK格式）。 另外，由于Windows操作系统阻止为从属窗口创建此类菜单，因此另一个技巧使得可以将<b>本地菜单</b>分配给子窗口。 因此，您在任何地方都不会在同一<b>MDI</b> （多文档界面）中看到本地菜单。 他被命令面板，工具栏和上下文菜单取代。 还有一些时间来更新窗口。 有时会发生<b>UpdateWindow（）</b>和<b>InvalidateRect（）</b>都无法正常工作的情况。 但是在这种情况下，有几个功能是成功的： <br><br><pre><code class="cpp hljs">ShowWindow(hWnd, SW_HIDE); ShowWindow(hWnd, SW_SHOW);</code> </pre> <br> 还应注意，我们的组件可能与其他组件发生冲突，例如与1C77的FormEx.dll冲突。 在这种情况下，它需要最后加载。 <br><br> 顺便提一下，请注意，如果您在1C-8.3.14及更高版本中创建配置，则不会以任何常规方式加载组件。 但是，如果数据库是在1C的早期版本中创建的，并且在最新版本中打开，则加载我们的VK不会有问题。 这再次暗示需要创建一个外部引导程序。 <br><br> 该项目使用<b>WinAPI GDI +</b>子系统。 使用它，您可以显示各种格式的图片： <b>bmp，jpg，gif，png，tif</b>等。 组件以相同的顺序尝试从当前配置的本地<b>Pics</b>目录中加载第一个可用的<b>Main。*</b>文件。 如果找不到这些文件，则使用来自组件资源的简单背景图像。 在图。 图13显示了版本15的64位1C83的通常形式的背景图像。进行更改后，s语的外部窗口已放大，并且<b>Main1.png</b>文件中的另一张图像（已平铺）已添加到其背景中。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71c/80a/48a/71c80a48a18236e495a1d62b0f316e11.jpg" alt="图13.常规格式64位1C83版本15的默认墙纸"><br> 图  13.版本64的64位1C83常规格式的默认背景图像。此外，还添加了Main1.png文件中另一张图像的图像，该图像放置为“平铺”。 <br><br> 在不同的位模式下，组件的操作没有区别。 <br><br> 还应注意，我们的组件将主1C窗口及其MDI客户端（如果有）子类化。 显然，这最后一次加载时（在1C77中）与FormEx.dll发生冲突。 <br><br><h2> 第二部分-技术 </h2><br> 该项目本身可以在以下链接中找到： <br><br><ul><li>  <a href="">在1C77上测试配置</a> </li><li>  <a href="">1C82上的测试配置</a> </li><li>  <a href="">1C83上的测试配置</a> </li><li>  <a href="">在MS VS C ++上的项目</a>  <a href="">13</a> </li></ul><br> 如果在配置文件中将字符串“ <b>v120</b> ”替换为“ <b>v100</b> ”，将“ <b>ToolsVersion =“ 12.0”</b> ” <b>替换为“ ToolsVersion =“ 4.0”</b> ，则可以轻松地将<b>C ++</b>项目用于版本<b>10</b> 。 <br><br>  <b>1C</b>的<b>32</b>位和<b>64</b>位版本的代码相同，并且可以同时进行编译。 <br><br> 版本1C77在外部组件中由非零的GetMenu <b>（）</b>函数<b>handle决定</b> ，而版本1C83在主窗口中不存在子窗口，而主窗口中的子窗口由<b>GetForegroundWindow（）</b>函数确定。 <br><br><h3> 关于为1C创建外部组件的技术 </h3><br> 在1C公司的ITS光盘上以及在Internet上，可以轻松地找到有关使用不同的编程语言创建VC和相应模板的信息。 但是，在1C77时代，这些模式满足了“不仅每个人”。 <br><br> 如果您查看一些广泛使用的组件，尤其是1C77，将发现他们的作者经常使用特殊的编程方法来扩展其设计的功能。 <br><br> 最早的此类外部组件之一可能是<b><i>“针对1C的RAINBOW ADDIN 2000：企业7.7”</i></b> 。 也许最重要的是，尽管遵循VK格式，但比官方VK技术所允许的对“七个”肠子的渗透更深。 这是由于收到的，很可能是非标准的方法，其他广为人知的项目中使用的1C77库文件的标头（* .h文件）而实现的。 <br><br> 确实，如果诸如<b>LoadExternalComponent（）</b>和<b>ConnectExternalComponent（）</b>这样的1C函数允许您将<b>外部dll</b>嵌入到自己的地址空间中（首先，满足VK技术格式），那么为什么用户程序不屈从于诱惑并尝试访问隐藏在其中的其他它们，目标平台的程序和其他对象？  <b>Rainbow.dll</b>组件已成功演示了此方法。 <br><br> 后来，组件1C版本7.7的其他作者采用了类似的机制。 特别值得注意的是“七个” <b>1C ++。Dll</b>的组件及其<b>FormEx.dll的特例</b> 。 <br><br> 但是，用于1C77外部组件设计的非平凡方法并没有就此结束。 显然，有人应该说：“为什么我们需要铁匠？ 我们不需要铁匠！” 在这里，“铁匠”是指MicroSoft的COM技术，在某种意义上，其后是“七个”的VK技术。 不，嗯，真的，如果直接下载VK，为什么需要注册中心？ 这对于可以与Internet一起使用的Web浏览器可能是有意义的，但是对于本地操作，使用注册表显然是多余的。 至少，这不应该是先决条件。 此外，要编辑注册表，您需要管理权限。 <br><br> 请注意，1C非常喜欢这项技术（至少在将1C移植到Linux之前）。 我们对待她很酷。  COM使用ActiveX组件很方便，这很自然，因为ActiveX组件最初是为Internet开发的。 <br><br> 但是，在最新版本中，1C添加了使用本<b>机API</b>技术的功能，从而消除了对注册表的需求。 原则上，这是我们需要的，除了该技术不适用于“七个”之外，并且对于某些人来说仍然有用。 <br><br> 但是，当您不想为VK使用一堆样板代码时，有时会出现相对简单的任务，建议仅从外部组件一侧使用1C。 举例来说，在我们的示例中，在客户区域或必要时在单独的窗口中显示祝贺图像，配置1C。 <br><br> 换句话说，如果我们不打算在1C和VK之间直接交换数据，那么我们将为1C的外部组件的更简单，更通用的版本感到满意。 由于缺少样板代码，因此此处可以简化。 <br><br><h3> 为1C创建VK的替代技术 </h3><br> 由于用于1C的VK是<b>COM服务器的</b>一种特殊情况（在<b>Native API</b>技术之前），因此有些VK开发人员说：“ COM-不！”  <b><i>亚历山大·奥雷夫科夫</i></b> （ <b><i>Alexander Orefkov</i></b> ）在这个方向上的活动特别引人注目。 它的组件“ <b>1sqlite.dll</b> ”，“ <b>TurboMD.dll</b> ”以及其他可能的组件不使用“完全”一词中的COM。  <b>Yoksel</b>组件（“ <b>SpreadSheet.dll</b> ”）也沿此路径开发。 <br><br> 但是，如何从1C77加载VK加载程序呢？ 毕竟，他们甚至没有尝试在此模仿某种COM。 确实，如果我们试图将由<b>MS VC ++</b>向导生成的一些标准dll直截了当地滑入<b>LoadExternalComponent（）</b>函数，那么我们将感到无聊。 <br><br> 在“七个”中，我们收到如下消息： <blockquote> 从&lt;完整路径\组件名称&gt; .dll组件创建对象时发生错误（缺少CLSID） </blockquote><br> 在“厚” 32位客户端中的“八”消息将类似。 相同的dll将引起类似的咒骂（图15）： <blockquote> 调用上下文方法时出错（加载外部组件）：加载外部组件时出错 </blockquote><br> 那么，提到的库如何解决这个问题呢？ 通过研究Orefkov和Yoksel程序的文本，我们最终得出结论，资源文件（* .rc或* .rc2）中的以下“ <b>魔术线</b> ”是“怪罪”： <br><br><pre> <code class="plaintext hljs">STRINGTABLE DISCARDABLE BEGIN 100 "\0sd" // 1sqlite.dll 100 "\0tmd" // TurboMD.dll 100 "\0f" // SpreadSheet.dll END</code> </pre> <br> 即 毫无疑问，在程序资源中，有一行带有标识符<b>100</b>和一些字符串值，其第一个字符为零。 您可以尝试使用此类字符串的变体，但是字符串“ <b>\ 0L</b> ”对我来说很好。 因此，我们创建一个资源文件并编写如下代码： <br><br><pre> <code class="plaintext hljs">STRINGTABLE DISCARDABLE BEGIN 100 "\0L" //    1     ! END</code> </pre> <br> 我们将此文件连接到由MS C ++向导生成的最简单的dll项目，添加代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DllMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(dwReason) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_ATTACH: MessageBox(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">",  DllMain()!"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, MB_OK); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_THREAD_ATTACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_THREAD_DETACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_DETACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// switch(dwReason) return TRUE; } // DllMain()</span></span></code> </pre> <br> 并观察（图14）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/715/a71/7f7/715a717f7ee778dd219e79e5fbd43e97.jpg" alt="图14.在1C82中使用最简单的“ VK”"><br> 图  14.在1C82中使用最简单的“ VK”。 <br><br> 在资源文件中没有“魔术线”的情况下，我们的dll在显示MessageBox之后立即以1C的诅咒卸载（图15）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a98/cec/432/a98cec4326033180917940aa248dbc96.jpg" alt="图15.在1C82中加载常规dll时出错"><br> 图  15.在1C82中加载常规dll时出错。 <br><br> 也就是说，这些线路确实对外部1C组件的加载器产生了神奇的影响。 <br><br> 似乎第一条“魔术线”是由<b><i>Alexei Fedorov（ALF）</i></b>在他的旧文章中描述的，但是不再有指向它的链接，并且作者没有看到它的重新出版。 此外， <b><i>亚历山大·奥雷夫科夫</i></b> （ <b><i>Alexander Orefkov）</i></b>最<b><i>频繁地</i></b>使用它们，显然，从他的投稿中，作者是<b><i>约克瑟尔</i></b> 。 因此，我们将讨论<b><i>Fedorov-Orefkov</i></b>的<b><i>“魔术”线</i></b> 。 它们的含义是通过功能<b>LoadExternalComponent（）</b>阻止非标准（从1C角度来看）dll文件的<b>卸载</b> 。 而且，如我们所见，该技术不仅适用于1C77，而且适用于“厚” 1C82形式。 <br><br> 但是，在托管形式1C82和所有版本的1C83中，此功能已被完全破坏（另一个加载程序也已出现<b>-ConnectExternalComponent（）</b> ）。 <br><br> 因此，在1C的现代版本中，您需要寻找Fedorov-Orefkov的“魔术”线的其他简单替代方法。 <br><br> 这样的替代方案很容易提供。 重点很简单。 如果尝试使用指定的协议（例如，请求组件的版本）访问1C加载器时引发异常，则1C加载器将卸载该组件。 自然，我们没有这种类型的东西，它是卸载自定义dll的基础。 但是，如果仍在某处使用此VK，则系统可以忽略操作系统对1C卸载此动态库的要求。 代替删除本身，系统仅减少所需模块的使用计数器。 并且物理删除不早于此计数器被重置。 因此，我们的任务是人为地增加此计数器。 <br><br> 为此，您可以在<b>DLL_THREAD_ATTACH</b>部分再次调用我们的dll函数WinAPI <b>LoadLibrary（）</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DllMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(dwReason) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_ATTACH: { WCHAR szDllName[_MAX_PATH] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//     dll GetModuleFileName(hModule, szDllName, _MAX_PATH); //MessageBox(NULL, szDllName, L"Info", MB_OK); //    dll (     183), //      DLL_PROCESS_ATTACH HMODULE hDll = LoadLibrary(szDllName); break; } // case DLL_PROCESS_ATTACH case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } // switch(dwReason) return TRUE; } // DllMain()</span></span></code> </pre> <br> 仅此而已！ 问题已解决。 调用相同的动态库将使它的使用计数器增加1，而卸载（具有对<b>DLL_THREAD_DETACH</b>部分的初步访问权）将减少1。 我们总共有<b>2-1 = 1&gt; 0</b> ，因此，操作系统将不会卸载我们的dll。 而且，重要的是，不会发生<b>DLL_PROCESS_ATTACH</b>部分的重新初始化。 <br><br> 顺便说一下，从中可以看到1C如何处理其最新版本中的类似技巧（显然，它已经在1C-8.3.14及更高版本中创建的配置中做到了这一点）。 它可以将<b>LoadLibraryEx（）</b>函数与阻止初始化段<b>DLL_PROCESS_ATTACH</b>的执行的参数一起使用，此后立即调用必要的导出函数。 而且，的确，如果您查看Native API的VK示例代码，则可以看到不需要调用初始化代码，因为初始化代码必须以VK格式为空。 <br><br> 对于使用COM技术的示例，很明显在那里需要执行初始化部分<b>DLL_PROCESS_ATTACH</b> ，因此，在不太新的1C版本中，更确切地说，在1C-8.3.13及更低版本中进行的配置中，1C加载程序适合我们： <br><br><pre> <code class="plaintext hljs">(, , .COM);</code> </pre> <br> 在这里可以删除最后一个参数，因为默认情况下它是隐含的。 同时，它们可以在任何更高版本中正常打开。 在版本1C83中，以前的引导加载程序<b>LoadExternalComponent（组件地址）</b>不再适合我们（分别，Fedorov-Orefkov的“魔术线”在此处不起作用）。 <br><br> 如前所述，在一般情况下，可以使用外部引导程序解决问题。 或者，很自然地在某种程度上观察1C外部组件的技术。 <br><br> 还应注意，我们在文件版本为1C的文件中使用不同的位深度进行了实验。 要下载我们的组件，您可能需要在配置中将“ <b>同步呼叫使用模式</b> ”属性设置为“ <b>使用</b> ”。 <br><br> 还应该理解，使用这种技术需要您自担风险，请事先对测试配置或工作副本进行实验，以避免在主程序中出现潜在问题。 <br><br><h3> 从09/11/2019更新 </h3><br> 原来，我徒劳地担心：“在版本1C-8.3.14及更高版本中，不再使用“完全”一词来执行外部组件中的初始化部分。” <br><br> 事实证明，仅需要处理<b>ConnectExternalComponent（）</b>函数中的返回消息。 此外，无论我们指定哪种类型的组件： <b>COM</b>或<b>Native API</b> 。 <br><br> 因此，您可以在1C的所有当前可用版本中创建配置，我们的组件应该在任何地方都可以正常工作，并且创建外部引导加载程序将是相关的，除非您不想更改配置，这种情况将得到完全支持。 <br><br> 在这方面，虽然1C82和1C83的测试配置之间的区别不再是根本的区别，但它们的测试配置中的代码略有更改。 <br><br> 同时，我们指出1C公司可以轻松地阻止任何VK中初始化代码的执行，至少对于诸如<b>Native API之</b>类的外部组件而言，显然仍然有效，因为从它们的模板来看，这是没有必要的。 到目前为止，对于VK类型的<b>COM仍存在</b>这种需求，但是有什么阻止它摆脱的呢？ 同时，让我们看看他们是否会考虑此信息？ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN466713/">https://habr.com/ru/post/zh-CN466713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN466699/index.html">驯服信任协议-使用InterSystems IRIS进行OAuth身份验证</a></li>
<li><a href="../zh-CN466701/index.html">让我们加密服务近30％的域名</a></li>
<li><a href="../zh-CN466705/index.html">Vivaldi Beta for Android-真实浏览器</a></li>
<li><a href="../zh-CN466709/index.html">开发单片类Unix操作系统-C库（2）</a></li>
<li><a href="../zh-CN466711/index.html">漏洞DaOffice允许从社交网络中删除任何用户</a></li>
<li><a href="../zh-CN466719/index.html">超轻速度分析：理论与实践。 第一部分</a></li>
<li><a href="../zh-CN466721/index.html">[Ekaterinburg，公告] java.ural.Meetup @ 3-第三个Java mitap的公告+来自java.ural.Meetup @ 2的视频报告</a></li>
<li><a href="../zh-CN466723/index.html">Apple Text Broadcast-2019年9月10日</a></li>
<li><a href="../zh-CN466725/index.html">匕首2是基础（第1部分）</a></li>
<li><a href="../zh-CN466727/index.html">延迟升级：PostgreSQL 12如何提高性能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>