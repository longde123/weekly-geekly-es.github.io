<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé≠ üëßüèº üéà Desmistifica√ß√£o dos princ√≠pios da computa√ß√£o qu√¢ntica üë©üèø‚Äç‚úàÔ∏è üíè üåø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Acho que posso dizer com seguran√ßa que ningu√©m entende a mec√¢nica qu√¢ntica", Richard Feynman 

 O t√≥pico da computa√ß√£o qu√¢ntica sempre atraiu escrito...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desmistifica√ß√£o dos princ√≠pios da computa√ß√£o qu√¢ntica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476444/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/7de/0de/1cc7de0de64ab4691f4d12f2b54a51ab.png" width="400"></div><br>  "Acho que posso dizer com seguran√ßa que ningu√©m entende a mec√¢nica qu√¢ntica", Richard Feynman <br><br>  O t√≥pico da computa√ß√£o qu√¢ntica sempre atraiu escritores e jornalistas t√©cnicos.  Seu potencial computacional e complexidade lhe davam uma esp√©cie de aur√©ola m√≠stica.  Com frequ√™ncia, artigos tem√°ticos e infogr√°ficos descrevem detalhadamente todos os tipos de perspectivas para esse setor, enquanto mal tocam nas quest√µes de sua aplica√ß√£o pr√°tica: isso pode enganar um leitor n√£o muito cuidadoso. <br><a name="habracut"></a><br>  Em artigos cient√≠ficos populares, descri√ß√µes de sistemas qu√¢nticos s√£o omitidas e declara√ß√µes como: <br><br>  <i>Um bit regular pode ser igual a "1" ou "0", mas um qubit pode ser simultaneamente igual a "1" e "0".</i> <br><br>  Se voc√™ tiver muita sorte (do qual n√£o tenho certeza), eles lhe dir√£o que: <br><br>  <i>O qubit est√° em uma superposi√ß√£o entre "1" e "0".</i> <br><br>  Nenhuma dessas explica√ß√µes parece plaus√≠vel, porque estamos tentando formular um fen√¥meno da mec√¢nica qu√¢ntica usando ferramentas de linguagem criadas em um mundo muito tradicional.  Para explicar claramente os princ√≠pios da computa√ß√£o qu√¢ntica, √© necess√°rio usar outra linguagem - matem√°tica. <br><br>  Neste guia, falarei sobre as ferramentas matem√°ticas necess√°rias para modelar e entender os sistemas de computa√ß√£o qu√¢ntica e como ilustrar e aplicar a l√≥gica da computa√ß√£o qu√¢ntica.  Al√©m disso, darei um exemplo de algoritmo qu√¢ntico e direi qual √© a sua vantagem sobre um computador tradicional. <br><br>  Farei o poss√≠vel para falar sobre tudo isso em uma linguagem compreens√≠vel, mas ainda espero que os leitores deste artigo tenham id√©ias b√°sicas sobre √°lgebra linear e l√≥gica digital (√°lgebra linear √© descrita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , l√≥gica digital √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ). <br><br>  Para come√ßar, vamos examinar os princ√≠pios da l√≥gica digital.  Baseia-se no uso de circuitos el√©tricos para c√°lculos.  Para tornar nossa descri√ß√£o mais abstrata, simplificamos o estado do fio para "1" ou "0", o que corresponder√° aos estados "ligado" ou "desligado".  Tendo constru√≠do os transistores em uma determinada sequ√™ncia, criaremos os chamados elementos l√≥gicos que pegam um ou mais valores dos sinais de entrada e os convertem em um sinal de sa√≠da com base em certas regras da l√≥gica booleana. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/872/e40/4ec872e405490899e02ed8c8c9923055.png"></div><br><h2>  Elementos l√≥gicos comuns e tabelas de estado </h2><br>  Com base nas cadeias desses elementos b√°sicos, √© poss√≠vel criar elementos mais complexos e, com base nas cadeias de elementos mais complexos, podemos confiar na obten√ß√£o de um an√°logo do processador central com um alto grau de abstra√ß√£o. <br><br>  Como mencionei anteriormente, precisamos de uma maneira de mapear matematicamente a l√≥gica digital.  Primeiro, vamos apresentar a l√≥gica matem√°tica tradicional.  Usando √°lgebra linear, os bits cl√°ssicos com os valores "1" e "0" podem ser representados como dois vetores de coluna: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9c/434/3df/c9c4343df6118928be1a7bca294bbf9b.png" width="200"></div><br>  onde os n√∫meros √† esquerda s√£o a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nota√ß√£o do</a> vetor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dirac</a> .  Ao representar nossos bits dessa maneira, podemos modelar opera√ß√µes l√≥gicas em bits usando transforma√ß√µes de vetor.  Observe: apesar de, ao usar dois bits em elementos l√≥gicos, voc√™ pode executar muitas opera√ß√µes (‚ÄúAND‚Äù (AND), ‚ÄúNot‚Äù (NOT), ‚ÄúExcluir Or‚Äù (XOR) etc.) ao usar uma bits √© poss√≠vel realizar apenas quatro opera√ß√µes: convers√£o de identidade, nega√ß√£o, c√°lculo da constante "0" e c√°lculo da constante "1".  Durante a convers√£o id√™ntica, o bit permanece inalterado, quando negado, o valor do bit √© revertido (de "0" para "1" ou de "1" para "0"), e o c√°lculo da constante "1" ou "0" define o bit para "1" ou "0", independentemente do seu valor anterior. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/8bd/c76/7a88bdc760e2f03ffd3da0030335445c.png" width="400"></div><br><div class="scrollable-table"><table><tbody><tr><td>  Identidade <br></td><td>  Transforma√ß√£o de identidade <br></td></tr><tr><td>  Nega√ß√£o <br></td><td>  Nega√ß√£o <br></td></tr><tr><td>  Constante-0 <br></td><td>  C√°lculo da constante "0" <br></td></tr><tr><td>  Constante-1 <br></td><td>  C√°lculo da constante "1" <br></td></tr></tbody></table></div><br>  Com base em nossa nova representa√ß√£o de um bit, √© bastante f√°cil executar opera√ß√µes no bit correspondente usando a transforma√ß√£o de vetor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/6f4/92d/a3f6f492dc62d70852f3be02a1323a69.png" width="400"></div><br><br>  Antes de prosseguir, vejamos o conceito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">computa√ß√£o revers√≠vel</a> , o que implica apenas que, para garantir a reversibilidade de uma opera√ß√£o ou elemento l√≥gico, √© necess√°rio determinar uma lista de valores de sinal de entrada com base nos sinais de sa√≠da e nos nomes das opera√ß√µes utilizadas.  Assim, podemos concluir que a transforma√ß√£o e nega√ß√£o da identidade s√£o revers√≠veis, mas a opera√ß√£o de calcular as constantes ‚Äú1‚Äù e ‚Äú0‚Äù n√£o √©.  Devido √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">unitariedade da</a> mec√¢nica qu√¢ntica, os computadores qu√¢nticos usam opera√ß√µes exclusivamente revers√≠veis, e √© por isso que vamos nos concentrar neles.  Em seguida, converteremos os elementos irrevers√≠veis em revers√≠veis para garantir que eles possam ser usados ‚Äã‚Äãpor um computador qu√¢ntico. <br><br>  Usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">produto tensorial de</a> bits individuais, muitos bits podem ser representados: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/07e/a5f/21c07ea5f6329faf6214fcff5fbbcc5e.png" width="400"></div><br>  Agora que temos quase todos os conceitos matem√°ticos necess√°rios, passaremos para o nosso primeiro elemento da l√≥gica qu√¢ntica.  Este √© o operador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CNOT</a> , ou o ‚ÄúN√ÉO‚Äù (N√ÉO) controlado, que √© de grande import√¢ncia na computa√ß√£o revers√≠vel e qu√¢ntica.  O elemento CNOT √© aplicado a dois bits e retorna dois bits.  O primeiro bit √© atribu√≠do como "controle" e o segundo - "controle".  Se o bit de controle estiver definido como "1", o bit de controle altera seu valor;  se o bit de controle estiver definido como "0", o bit de controle n√£o ser√° alterado. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/55a/f27/f2e55af2760a72e7389a1ce0777cc216.png"></div><br>  Este operador pode ser representado como o seguinte vetor de transforma√ß√£o: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/c12/c0a/c18c12c0a3d170ae5d6cc02726f9e24a.png"></div><br>  Para demonstrar tudo o que j√° lidamos, mostrarei como usar o elemento CNOT em rela√ß√£o a muitos bits: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdb/1f0/ef0/bdb1f0ef078a62a045af5a3432ff5eaa.png"></div><br>  Resumimos o que j√° foi dito: no primeiro exemplo, decompomos | 10‚ü© em partes de seu produto tensorial e usamos a matriz CNOT para obter um novo estado correspondente do produto;  ent√£o o fatoramos para | 11‚ü© de acordo com a tabela de valores CNOT fornecidos anteriormente. <br><br>  Ent√£o, lembramos de todas as regras matem√°ticas que nos ajudar√£o a lidar com c√°lculos tradicionais e bits comuns e, finalmente, podemos avan√ßar para a computa√ß√£o qu√¢ntica e qubits modernos. <br><br>  Se voc√™ leu esse lugar, tenho boas not√≠cias para voc√™: os qubits podem ser facilmente expressos matematicamente.  Em geral, se o bit cl√°ssico (cbit) pode ser definido como | 1‚ü© ou | 0‚ü©, o qubit est√° simplesmente em superposi√ß√£o e pode ser igual a | 0‚ü© e | 1‚ü© antes da medi√ß√£o.  Ap√≥s a medi√ß√£o, ele cai em | 0‚ü© ou | 1‚ü©.  Em outras palavras, um qubit pode ser representado como uma combina√ß√£o linear de | 0‚ü© e | 1‚ü© de acordo com a f√≥rmula abaixo: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/ec8/e2e/fd7ec8e2e1b3dd8167d584664a4bfa90.png" width="200"></div><br>  onde <i>a‚ÇÄ</i> e <i>a‚ÇÅ</i> representam, respectivamente, as amplitudes | 0‚ü© e | 1‚ü©.  Elas podem ser consideradas como ‚Äúprobabilidades qu√¢nticas‚Äù, que representam a probabilidade de um qubit colapsar em qualquer um dos estados ap√≥s a sua medi√ß√£o, pois na mec√¢nica qu√¢ntica um objeto em superposi√ß√£o entra em colapso em um dos estados ap√≥s a fixa√ß√£o.  Expanda esta express√£o e obtenha o seguinte: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/3ae/a51/c803aea51e4c1afa3d1fb2120f02333b.png" width="200"></div><br>  Para simplificar minha explica√ß√£o, usarei essa mesma no√ß√£o neste artigo. <br><br>  Para esse qubit, a chance de colapso ap√≥s a medi√ß√£o √© |  <i>a</i> ‚ÇÄ | ¬≤, e a chance de colapsar em <i>um</i> ‚ÇÅ √© igual a |  <i>a</i> ‚ÇÅ | ¬≤.  Por exemplo, para o seguinte qubit: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/d62/80d/b1ad6280d3eb193391b69bcd43fa28c7.png" width="200"></div><br>  a chance de colapso em "1" √© | 1 / ‚àö2 | ¬≤ ou ¬Ω, ou seja, 50/50. <br><br>  Como no sistema cl√°ssico todas as probabilidades na soma devem fornecer unidade (para uma distribui√ß√£o de probabilidades completa), podemos concluir que os quadrados dos valores absolutos das amplitudes | 0‚ü© e | 1‚ü© devem totalizar um.  Com base nessas informa√ß√µes, podemos compor a seguinte equa√ß√£o: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74e/96b/6aa/74e96b6aa455eaab9c77562b3286648b.png"></div><br>  Se voc√™ est√° familiarizado com a trigonometria, notar√° que esta equa√ß√£o corresponde ao teorema de Pit√°goras (a¬≤ + b¬≤ = c¬≤), ou seja, podemos representar graficamente os poss√≠veis estados do qubit na forma de pontos no c√≠rculo unit√°rio, a saber: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/666/ef3/792666ef38e24cb8ce453e802f2fac6e.png" width="400"></div><br>  Operadores e elementos l√≥gicos s√£o aplicados a qubits, bem como no caso de bits cl√°ssicos - baseados na transforma√ß√£o de matrizes.  Todos os operadores de matriz revers√≠vel que lembramos at√© o momento, em particular o CNOT, podem ser usados ‚Äã‚Äãpara trabalhar com qubits.  Esses operadores de matriz tornam poss√≠vel usar cada uma das amplitudes de um qubit sem medi-lo e recolh√™-lo.  Deixe-me dar um exemplo de como usar o operador de nega√ß√£o para qubit: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/8f9/17b/fa48f917b87b850ee63c2d85abc95a83.png"></div><br>  Antes de continuarmos, lembro que as amplitudes <i>a</i> e <i>a</i> s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√∫meros complexos</a> , de modo que o estado qubit pode ser exibido com mais precis√£o em uma esfera unit√°ria tridimensional, tamb√©m conhecida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esfera de Bloch</a> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12c/e7e/1b4/12ce7e1b4211732a27bcf4b9b45d1be4.png" width="400"></div><br>  No entanto, para simplificar a explica√ß√£o, aqui nos restringimos a n√∫meros reais. <br><br>  Parece que chegou a hora de discutir alguns elementos l√≥gicos que fazem sentido exclusivamente no contexto da computa√ß√£o qu√¢ntica. <br><br>  Um dos operadores mais importantes √© o "elemento Hadamard": leva um pouco no estado "0" ou "1" e o coloca na superposi√ß√£o correspondente, com 50% de chance de reduzi-lo a "1" ou "0" ap√≥s a medi√ß√£o. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/3c7/11c/5873c711c538223c223588bb2767b080.png" width="400"></div><br>  Observe que h√° um n√∫mero negativo no lado inferior direito do operador Hadamard.  Isso se deve ao fato de o resultado do uso do operador depender do valor do sinal de entrada: - | 1‚ü© ou | 0‚ü© e, portanto, o c√°lculo √© revers√≠vel. <br><br>  Outro ponto importante relacionado ao elemento Hadamard √© sua reversibilidade, ou seja, ele pode pegar um qubit na superposi√ß√£o correspondente e convert√™-lo em | 0‚ü© ou | 1‚ü©. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/8e1/e67/8038e1e6747112de2a6f516e42932c5d.png" width="400"></div><br>  Isso √© muito importante porque nos permite transformar a partir de um estado qu√¢ntico sem determinar o estado do qubit - e, consequentemente, sem recolh√™-lo.  Assim, podemos estruturar a computa√ß√£o qu√¢ntica com base em um princ√≠pio determin√≠stico e n√£o probabil√≠stico. <br><br>  Operadores qu√¢nticos contendo n√∫meros exclusivamente reais s√£o o oposto, portanto, podemos apresentar o resultado da aplica√ß√£o do operador a um qubit como uma transforma√ß√£o dentro do c√≠rculo unit√°rio na forma de uma m√°quina de estado: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/505/c91/b24/505c91b2434b2d73e8738fbd31545718.png" width="400"></div><br>  Assim, o qubit, cujo estado √© mostrado no diagrama acima, ap√≥s a aplica√ß√£o da opera√ß√£o Hadamard √© convertido no estado indicado pela seta correspondente.  Da mesma forma, podemos construir outra m√°quina de estado que ilustrar√° a transforma√ß√£o de um qubit usando o operador de nega√ß√£o, como mostrado acima (tamb√©m conhecido como operador de nega√ß√£o de Pauli ou invers√£o de bits), como mostrado abaixo: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/854/3d9/b1b/8543d9b1bf8a155b7a8945d814edfc00.png" width="400"></div><br>  Para executar opera√ß√µes mais complexas com nosso qubit, voc√™ pode usar uma cadeia de muitos operadores ou aplicar elementos v√°rias vezes.  Um exemplo de transforma√ß√£o em s√©rie com base na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">representa√ß√£o de uma cadeia qu√¢ntica √©</a> o seguinte: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/ef3/1cb/134ef31cb001fc1c9ff3c3854d32838b.png"></div><br>  Ou seja, se come√ßamos com o bit | 0‚ü©, aplicamos o inverso do bit e, em seguida, a opera√ß√£o Hadamard, outra invers√£o de bits e, novamente, a opera√ß√£o Hadamard, ap√≥s a qual a invers√£o final do bit, obtemos o vetor no lado direito da corrente.  Sobrepondo v√°rias m√°quinas de estado umas sobre as outras, podemos come√ßar com | 0‚ü© e rastrear as setas coloridas correspondentes a cada uma das transforma√ß√µes para entender como tudo isso funciona. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br>  Desde que chegamos at√© aqui, √© hora de considerar um dos tipos de algoritmos qu√¢nticos, ou seja, o algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Deutsch-Joji</a> , e mostrar sua vantagem sobre um computador cl√°ssico.  Vale ressaltar que o algoritmo Deutsch-Yogi √© completamente determin√≠stico, ou seja, retorna a resposta correta em 100% dos casos (ao contr√°rio de muitos outros algoritmos qu√¢nticos baseados na determina√ß√£o probabil√≠stica de qubits). <br><br>  Vamos imaginar que voc√™ tenha uma caixa preta que cont√©m uma fun√ß√£o / operador em um bit (lembre-se - ao usar um bit, apenas quatro opera√ß√µes s√£o poss√≠veis: transformar identicamente, negar, calcular a constante "0" e calcular a constante "1").  Que fun√ß√£o √© executada em uma caixa?  Voc√™ n√£o sabe qual, no entanto, pode classificar quantas variantes dos valores de entrada desejar e avaliar os resultados da sa√≠da. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5e/f24/938/c5ef249384466b29fb07ea99b2c1b000.png"></div><br>  Quantos sinais de entrada e sa√≠da ter√£o que ser direcionados pela caixa preta para descobrir qual fun√ß√£o √© usada?  Pense nisso por um segundo. <br><br>  No caso de um computador cl√°ssico, voc√™ precisar√° fazer 2 consultas para determinar a fun√ß√£o usada.  Por exemplo, se quando voc√™ digita "1" obtemos "0" na sa√≠da, fica claro que a fun√ß√£o para calcular a constante "0" ou a fun√ß√£o de nega√ß√£o √© usada, ap√≥s o qual voc√™ ter√° que alterar o valor do sinal de entrada para "0" e ver o que acontece na sa√≠da. <br><br>  No caso de um computador qu√¢ntico, voc√™ tamb√©m precisar√° de duas consultas, pois ainda precisar√° de dois valores de sa√≠da diferentes para determinar a fun√ß√£o exata que se aplica ao valor de entrada.  No entanto, se reformularmos um pouco a quest√£o, verifica-se que os computadores qu√¢nticos ainda t√™m uma s√©ria vantagem: se voc√™ quisesse descobrir se a fun√ß√£o usada √© constante ou vari√°vel, a superioridade estaria do lado dos computadores qu√¢nticos. <br><br>  A fun√ß√£o usada na caixa √© uma vari√°vel, se valores diferentes do sinal de entrada fornecerem resultados diferentes na sa√≠da (por exemplo, convers√£o e invers√£o id√™nticas de um bit), e se o valor da sa√≠da n√£o for alterado independentemente do valor de entrada, a fun√ß√£o ser√° constante (por exemplo, calculando a constante ‚Äú1‚Äù ou o c√°lculo da constante ‚Äú0‚Äù). <br><br>  Usando o algoritmo qu√¢ntico, √© poss√≠vel determinar se uma fun√ß√£o em uma caixa preta √© constante ou vari√°vel com base em apenas uma solicita√ß√£o.  Por√©m, antes de examinarmos detalhadamente como fazer isso, precisamos encontrar uma maneira que permita estruturar cada uma dessas fun√ß√µes em um computador qu√¢ntico.  Como qualquer operador qu√¢ntico deve ser invert√≠vel, encontramos imediatamente um problema: as fun√ß√µes para calcular as constantes ‚Äú1‚Äù e ‚Äú0‚Äù n√£o s√£o. <br><br>  Na computa√ß√£o qu√¢ntica, a seguinte solu√ß√£o √© frequentemente usada: um qubit de sa√≠da adicional √© adicionado, que retorna qualquer valor do sinal de entrada recebido pela fun√ß√£o. <br><div class="scrollable-table"><table><tbody><tr><td>  Para: <br></td><td>  Depois: <br></td></tr><tr><td><img src="https://habrastorage.org/webt/xi/kq/k3/xikqk3njz-k-xetlo8efjhjsggk.png"><br></td><td><img src="https://habrastorage.org/webt/lj/rq/f9/ljrqf955o6xtubsf9mrrvridfko.png"><br></td></tr></tbody></table></div>  Assim, podemos determinar os valores de entrada apenas com base no valor obtido na sa√≠da, e a fun√ß√£o se torna invert√≠vel.  A estrutura dos circuitos qu√¢nticos cria a necessidade de um bit de entrada adicional.  Para o desenvolvimento dos operadores correspondentes, assumimos que o qubit de entrada adicional esteja definido como | 0‚ü©. <br><br>  Aplicando a mesma representa√ß√£o da cadeia qu√¢ntica que usamos anteriormente, veremos como cada um dos quatro elementos (transforma√ß√£o de identidade, nega√ß√£o, c√°lculo da constante "0" e c√°lculo da constante "1") pode ser implementado usando operadores qu√¢nticos. <br><br>  Por exemplo, desta maneira voc√™ pode implementar a fun√ß√£o de calcular a constante "0": <br><br>  <b>C√°lculo da constante "0":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/395/b09/e52/395b09e5258ce87f8f9a873d573853c2.png"></div><br>  Aqui n√£o precisamos de operadores.  O primeiro qubit de entrada (que assumimos igual a | 0‚ü©) ‚Äã‚Äãretorna com o mesmo valor, e o segundo valor de entrada retorna automaticamente - como de costume. <br><br>  Com a fun√ß√£o de calcular a constante "1", a situa√ß√£o √© um pouco diferente: <br><br>  <b>C√°lculo da constante "1":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/82d/51e/fbe82d51e97a2c5cc8d7b4d5446555c8.png"></div><br>  Como aceitamos que o primeiro qubit de entrada seja sempre definido como | 0‚ü©, como resultado da aplica√ß√£o do operador de invers√£o de bits, ele sempre fornecer√° um na sa√≠da.  E, como sempre, o segundo qubit fornece seu pr√≥prio valor na sa√≠da. <br><br>  Quando o operador de transforma√ß√£o de identidade √© exibido, a tarefa come√ßa a se tornar mais complicada.  Veja como faz√™-lo: <br><br>  <b>Transforma√ß√£o de identidade:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bc/a2c/0c9/3bca2c0c97de2080ae979084924569a6.png"></div><br>  O s√≠mbolo usado aqui denota o elemento CNOT: a linha superior indica o bit de controle e a linha inferior indica o bit de controle.  Deixe-me lembr√°-lo de que, ao usar o operador CNOT, o valor do bit de controle muda se o bit de controle for | 1‚ü©, mas permanecer√° inalterado se o bit de controle for | 0‚ü©.  Como assumimos que o valor da linha superior √© sempre igual a | 0‚ü©, seu valor √© sempre atribu√≠do √† linha inferior. <br><br>  Da mesma forma, agimos com o operador de nega√ß√£o: <br><br>  <b>Nega√ß√£o:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e0/9ea/05e/3e09ea05eb3aa4509360adb50250a57d.png" width="400"></div><br>  Simplesmente invertemos o bit no final da linha de sa√≠da. <br><br>  Agora que descobrimos a apresenta√ß√£o preliminar, vejamos as vantagens espec√≠ficas de um computador qu√¢ntico em rela√ß√£o a um computador tradicional quando se trata de determinar a const√¢ncia ou a variabilidade de uma fun√ß√£o oculta em uma caixa preta usando apenas uma consulta. <br><br>  Para resolver esse problema usando a computa√ß√£o qu√¢ntica em uma √∫nica solicita√ß√£o, √© necess√°rio converter os qubits de entrada em uma superposi√ß√£o antes de serem transferidos para a fun√ß√£o, conforme mostrado abaixo: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e76/ed6/9ca/e76ed69ca877e88a0cc269a5a3a27770.png"></div><br>  O elemento Hadamard √© reaplicado ao resultado do uso da fun√ß√£o para derivar qubits da superposi√ß√£o e tornar o algoritmo determin√≠stico.  Iniciamos o sistema no estado | 00‚ü© e, pelas raz√µes que irei falar agora, obtemos o resultado | 11‚ü© se a fun√ß√£o usada for constante.  Se a fun√ß√£o dentro da caixa preta for vari√°vel, depois de medir o sistema retornar√° o resultado | 01‚ü©. <br><br>  Para lidar com o restante do artigo, passemos √† ilustra√ß√£o que mostrei anteriormente: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br>  Usando o operador de invers√£o de bits e aplicando o elemento Hadamard a ambos os valores de entrada iguais a | 0‚ü©, garantiremos sua tradu√ß√£o na mesma superposi√ß√£o | 0 | e | 1‚ü©, a saber: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a0/f37/764/6a0f37764e197dc76be36173f72b2f7a.png" width="400"></div><br>  Usando o exemplo de transfer√™ncia desse valor de uma fun√ß√£o para uma caixa preta, √© f√°cil demonstrar que ambas as fun√ß√µes de um valor constante fornecem | 11‚ü© √† sa√≠da. <br><br>  <b>C√°lculo da constante "0":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/675/2ca/9596752cadbc0194e1883322fed9ba2d.png" width="400"></div><br> ,  ,     ¬´1¬ª     |11‚ü©,  : <br><br> <b>  ¬´1¬ª:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/628/2d3/bd76282d39512c75f15d30cbc18ade2a.png" width="400"></div><br>  :       |1‚ü©,  -1¬≤ = 1. <br><br>      ,             |01‚ü© (    ),     . <br><br> <b> :</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/771/51d/245/77151d245aa16fa8f8832ef4a4026576.png" width="400"></div><br>  CNOT   ,        ,                   CNOT    : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/c25/1ee/d11c251ee0068742d7004e5fe2fe0fe8.png"></div><br>             |01‚ü©,       : <br><br> <b>:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/9a3/120/29b9a31201cd3ce106480ba82f40970e.png" width="400"></div><br>  ,     ,       ,    . <br><br><h2>   ? </h2><br>    .     .    ,    , ,           ,   ,            . <br><br>            ‚Äî , ,       ,      -     (,       !).        ‚Äî ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ,    |0‚ü©  |1‚ü©          . <br><br>           , <i></i>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">¬´   ¬ª (An Introduction to Quantum Algorithms)</a>  :     ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476444/">https://habr.com/ru/post/pt476444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476428/index.html">Nginx VTS Stats, Mockify - API mock, compara√ß√£o Wiremock e Mockify</a></li>
<li><a href="../pt476430/index.html">Como criar o portf√≥lio t√©cnico perfeito</a></li>
<li><a href="../pt476434/index.html">Escrevemos drivers USB para dispositivos abandonados</a></li>
<li><a href="../pt476436/index.html">Relat√≥rios da primeira reuni√£o na R√∫ssia de desenvolvedores de rob√¥s no sistema operacional do rob√¥</a></li>
<li><a href="../pt476442/index.html">D√™ algum espa√ßo ou um microcontrolador como um medidor de frequ√™ncia</a></li>
<li><a href="../pt476446/index.html">Jira Plugins: alguns exemplos da inven√ß√£o bem sucedida da bicicleta</a></li>
<li><a href="../pt476448/index.html">Explora√ß√£o do shader de areia do jogo Journey</a></li>
<li><a href="../pt476450/index.html">Vis√£o geral do cPanel - um console baseado na Web para gerenciar sites e hospedagem</a></li>
<li><a href="../pt476452/index.html">Armazenamento de valor-chave ou como nossos aplicativos se tornaram mais convenientes</a></li>
<li><a href="../pt476454/index.html">O 5G est√° chegando: quais empresas garantir√£o a introdu√ß√£o de novas tecnologias em 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>