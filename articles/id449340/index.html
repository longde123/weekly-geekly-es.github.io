<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐷 🧔🏼 😔 Blok oracle berdasarkan oracle acak berdasarkan tanda tangan digital 🧚🏾 🐷 👼🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari ide hingga implementasi: kami memodifikasi skema tanda tangan digital yang ada pada kurva elips sehingga deterministik, dan kami memberikan pada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blok oracle berdasarkan oracle acak berdasarkan tanda tangan digital</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449340/"><p>  Dari ide hingga implementasi: kami memodifikasi skema tanda tangan digital yang ada pada kurva elips sehingga deterministik, dan kami memberikan pada dasarnya fungsi untuk mendapatkan nomor pseudorandom yang diverifikasi dalam blockchain. </p><br><p><img src="https://habrastorage.org/webt/iv/4j/ma/iv4jma5bmyktw3qm25amedvm17w.png"></p><a name="habracut"></a><br><h1 id="ideya">  Ide </h1><br><p>  Pada musim gugur 2018, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontrak pintar pertama diaktifkan di</a> blockchain Waves, segera muncul pertanyaan tentang kemungkinan mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nomor pseudorandom</a> yang dapat Anda percayai. </p><br><p>  Memecahkan masalah ini, saya akhirnya sampai pada kesimpulan: setiap blockchain adalah sel, tidak mungkin untuk mendapatkan sumber entropi tepercaya dalam sistem tertutup. </p><br><p> Tapi saya masih menyukai satu ide: jika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oracle acak</a> akan membuat tanda tangan data pengguna sebagai algoritma deterministik, maka pengguna akan selalu dapat memverifikasi tanda tangan tersebut dengan kunci publik, dan akan memastikan bahwa nilai yang diterima unik.  Sang oracle, dengan segala keinginannya, tidak memiliki kekuatan untuk mengubah apa pun, algoritma menghasilkan hasil yang jelas.  Bahkan, pengguna menangkap hasilnya, tetapi tidak mengetahuinya sampai oracle menerbitkannya.  Ternyata Anda tidak bisa mempercayai oracle sama sekali, tetapi periksa hasil kerjanya.  Kemudian, dalam kasus verifikasi yang berhasil, tanda tangan tersebut dapat dianggap sebagai sumber entropi untuk nomor pseudo-acak. </p><br><p>  Platform blockchain Waves menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema</a> tanda tangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EdDSA,</a> varian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ed25519</a> .  Dalam skema ini, tanda tangan terdiri dari nilai-nilai R dan S, di mana R tergantung pada nilai acak, dan S dihitung berdasarkan pesan yang ditandatangani, kunci pribadi dan nomor acak yang sama dengan R. Ternyata tidak ada ketergantungan satu-ke-satu untuk hal yang sama. Pesan khusus memiliki banyak tanda tangan yang valid. </p><br><p>  Jelas, dalam bentuknya yang murni, tanda tangan semacam itu tidak dapat digunakan sebagai sumber angka pseudorandom, karena tidak deterministik dan, oleh karena itu, dapat dengan mudah dikenakan manipulasi oleh oracle. </p><br><p>  Tapi, ternyata, menentukan itu sebenarnya mungkin. </p><br><p>  Saya memiliki harapan tinggi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi acak teruji (VRF)</a> , tetapi setelah mempelajari materi, saya harus menolak opsi ini.  Meskipun VRF menawarkan versi tanda tangan dan bukti yang deterministik, algoritme memiliki tempat aneh yang membuka lubang hitam untuk memanipulasi oracle (ini adalah pernyataan yang tidak benar, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembaruan</a> ).  Yaitu, ketika menghitung nilai k ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 5.1</a> ), kunci pribadi digunakan, yang tetap tidak diketahui pengguna, maka pengguna tidak dapat memverifikasi kebenaran perhitungan k, maka oracle dapat menggunakan nilai k apa saja yang ia butuhkan dan pada saat yang sama memelihara database korespondensi k dan data yang ditandatangani sehingga selalu dapat menghitung ulang hasil yang benar dari sudut pandang VRF.  Anda akan melihat undian berbasis VRF tanpa mengungkapkan kunci pribadi, Anda dapat memikirkannya: tunjukkan kebutuhan atau buka kunci tersebut, atau kecualikan dari perhitungan k, maka kunci pribadi akan secara otomatis membuka sendiri ketika tanda tangan pertama muncul.  Secara umum, seperti yang telah disebutkan, skema aneh untuk oracle acak. </p><br><p>  Dengan sedikit pemikiran dan meminta dukungan analis lokal, alur kerja VECRO lahir. </p><br><p>  VECRO adalah singkatan untuk Verifiable Elliptic Curve Random Oracle, yang dalam bahasa Rusia berarti peramalan acak yang diperiksa pada kurva eliptik. </p><br><p>  Semuanya ternyata cukup sederhana, untuk mencapai determinisme, perlu untuk memperbaiki nilai R sebelum munculnya pesan yang ditandatangani.  Jika R diperbaiki dan merupakan bagian dari pesan yang ditandatangani, yang juga menjamin bahwa R tetap dalam pesan yang ditandatangani itu sendiri, nilai S ditentukan secara unik oleh pesan pengguna dan, oleh karena itu, dapat digunakan sebagai sumber untuk nomor pseudorandom. </p><br><p>  Dalam skema seperti itu, tidak masalah bagaimana R diperbaiki, tetap berada dalam tanggung jawab oracle.  Penting bahwa S ditentukan secara unik oleh pengguna, tetapi nilainya tidak diketahui sampai oracle menerbitkannya.  Semuanya seperti yang kita inginkan! </p><br><p>  Berbicara tentang R tetap, perhatikan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">R digunakan kembali</a> ketika menandatangani berbagai pesan secara unik mengungkapkan kunci pribadi dalam skema EdDSA.  Untuk pemilik oracle, menjadi sangat penting untuk mengecualikan kemungkinan menggunakan kembali R untuk menandatangani pesan pengguna yang berbeda.  Artinya, selama manipulasi atau konspirasi oracle akan selalu mengambil risiko kehilangan kunci pribadinya. </p><br><p>  Secara total, oracle harus menyediakan dua fungsi kepada pengguna: inisialisasi, yang memperbaiki nilai R, dan tanda tangan, yang mengembalikan nilai S. Selain itu, pasangan R, S adalah tanda tangan reguler terverifikasi dari pesan pengguna yang berisi nilai tetap R dan data pengguna yang berubah-ubah. </p><br><p>  Dapat dikatakan bahwa skema ini untuk blockchain tidak lebih dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema pengungkapan komitmen yang</a> normal.  Sebenarnya, ya, itu dia.  Namun ada beberapa nuansa.  Pertama, oracle selalu bekerja dengan kunci yang sama di semua operasi, misalnya, mudah digunakan dalam kontrak.  Kedua, ada risiko kehilangan kunci privat oleh oracle karena perilaku yang tidak benar, misalnya, oracle memungkinkan Anda untuk membuat sampel hasilnya, maka cukup hanya melakukan dua tes untuk mengetahui kunci privat dan mendapatkan akses penuh ke dompet.  Ketiga, tanda tangan yang secara asli diverifikasi di blockchain, yang merupakan sumber keacakan, indah. </p><br><p>  Selama setengah tahun, ide implementasi ada di kepala saya, sampai akhirnya ada motivasi dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hibah dari Waves Labs</a> .  Dengan hibah besar, tanggung jawab besar datang, yang berarti proyek itu akan terjadi! </p><br><h1 id="realizaciya">  Implementasi </h1><br><p>  Jadi, dalam proyek ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VECRO diimplementasikan</a> pada blockchain Waves dalam mode permintaan-respons menggunakan transaksi transfer antara pengguna dan oracle.  Pada saat yang sama, skrip diinstal pada akun oracle yang memantau operasi secara ketat sesuai dengan logika yang dijelaskan di atas.  Transaksi Oracle diverifikasi untuk memulihkan seluruh rantai interaksi pengguna.  Keempat transaksi berpartisipasi dalam verifikasi nilai akhir, kontrak pintar menggantinya ke utas verifikasi ketat, langkah demi langkah memeriksa semua nilai dan tidak meninggalkan ruang untuk manipulasi. </p><br><p>  Sekali lagi, ditunda dan diperjelas.  Oracle tidak hanya bekerja sesuai dengan skema yang diusulkan.  Pekerjaannya sepenuhnya dikendalikan di tingkat blockchain oleh <a href="">kontrak pintar yang</a> dibangun dengan <a href="">ketat</a> .  Langkah ke kiri, dan transaksi tidak akan berfungsi.  Jadi, jika transaksi jatuh ke blockchain, pengguna bahkan tidak perlu memeriksa apa pun, ratusan node jaringan sudah memeriksa semuanya untuknya. </p><br><p>  Saat ini, satu VECRO sedang berjalan di jaringan Gelombang utama (Anda dapat menjalankan sendiri, itu tidak sulit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat</a> saja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh konfigurasi</a> ).  Kode saat ini bekerja di PHP (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WavesKit</a> , yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya bicarakan sebelumnya</a> ). </p><br><p>  Untuk menggunakan layanan oracle Anda harus: </p><br><ul><li>  Perbaiki R; <br><ul><li>  Kirim minimum 0,005 Gelombang ke oracle alias init @ vecr; </li><li>  Dapatkan kode-R di bidang lampiran dalam transfer token 1 R-vecr dari oracle ke pengguna; </li></ul></li><li>  Dapatkan tanda tangan <br><ul><li>  Kirim minimal 0,005 Gelombang ke oracle alias random @ vecr, dan SELALU menentukan kode-R yang diterima sebelumnya dan data pengguna tambahan di bidang lampiran; </li><li>  Dapatkan kode-S di bidang lampiran dalam transfer token 1 S-vecr dari oracle ke pengguna; </li></ul></li><li>  Gunakan kode-S sebagai sumber angka pseudo-acak. </li></ul><br><p>  Nuansa implementasi saat ini: </p><br><ul><li>  Gelombang yang dikirim ke oracle digunakan sebagai komisi untuk transaksi terbalik kepada pengguna, hingga maksimal 1 Gelombang; </li><li>  R-code adalah gabungan byte dari karakter 'R' dan nilai 32 byte dari R dalam pengkodean base58; </li><li>  R-code dalam lampiran harus menjadi yang pertama, data pengguna datang setelah R-code; </li><li>  S-code adalah gabungan byte dari karakter 'S' dan 32-byte dari nilai S dalam pengkodean base58; </li><li>  S adalah hasil dari pembagian modulo; oleh karena itu, S tidak dapat digunakan sebagai angka pseudo-acak 256-bit penuh (angka ini dapat dianggap sebagai maksimum nomor pseudo-acak 252-bit); </li><li>  Pilihan paling sederhana adalah dengan menggunakan hash dari S-code sebagai nomor pseudo-acak. </li></ul><br><p>  Contoh mendapatkan S-code: </p><br><ul><li>  Inisialisasi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://wavesexplorer.com/tx/8gc8jwM7JrPNehoDs7NVyos7BsufYktvkwVW1B6FAY6</a> </li><li>  Mendapatkan R-kode: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://wavesexplorer.com/tx/9eB25SbzEwvHEbm8pcKj7MGDrYv1u3Fxpj696FkJ96hd</a> </li><li>  Minta hasil tanda tangan R-code dan data pengguna “acak”: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://wavesexplorer.com/tx/6faoFJobEsugDFYmYmfsbtQYABmckNuE2kevaLh7ifzz</a> </li><li>  Mendapatkan S-kode: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://wavesexplorer.com/tx/C5VrFLQcprbA1KXAToaNvMP4Kg2rq43NkwWuADAA7wXX</a> </li></ul><br><p>  Dari sudut pandang teknis, oracle benar-benar siap untuk digunakan, Anda dapat menggunakannya dengan aman.  Dari sudut pandang penggunaan oleh pengguna biasa, antarmuka grafis yang nyaman tidak cukup, ini harus menunggu. </p><br><p>  Saya akan dengan senang hati menjawab pertanyaan dan menerima komentar, terima kasih. </p><br><h3 id="update-ot-8-maya-2019">  Pembaruan 8 Mei 2019 </h3><br><p>  Salah tentang VRF.  Ya, memang, tanda tangan ECVRF tidak dapat digunakan sebagai sumber nomor pseudo-acak, tetapi tidak digunakan untuk tujuan ini.  Dibutuhkan tanda tangan untuk membangun bukti keunikan nilai Gamma ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 5.3</a> , langkah 6).  Tetapi nilai Gamma yang diverifikasi menggunakan tanda tangan sudah berpartisipasi sebagai sumber nomor pseudo-acak ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 5.2</a> , langkah 5).  Terima kasih kepada Oleg Taraskin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Crittografo yang</a> telah menunjukkan poin ini, saya mengakui kesalahan saya.  ECVRF memiliki hak untuk hidup. </p><br><p>  Sayangnya, masih belum ada peluang untuk menggunakan ECVRF di tingkat blockchain Waves, karena kurangnya alat matematika yang diperlukan dalam kontrak pintar. </p><br><p>  Ketika fungsi atau dukungan RSA ini tersedia, Anda dapat menulis oracle baru.  Adapun skema VECRO, dalam hal apa pun, ia menempati ceruknya sendiri dan memungkinkan Anda untuk bekerja tanpa fungsionalitas tambahan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449340/">https://habr.com/ru/post/id449340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449326/index.html">WebRTC dan pengawasan video: bagaimana kami mengalahkan keterlambatan video dari kamera</a></li>
<li><a href="../id449330/index.html">Modul optik WDM CFP2-ACO / CFP2-DCO yang koheren (100G / 200G) dan aplikasinya dalam sistem DWDM</a></li>
<li><a href="../id449334/index.html">Bagaimana terjemahan teknis berubah menjadi mini detektif</a></li>
<li><a href="../id449336/index.html">Perawatan HIV dari pengobatan pertama hingga saat ini</a></li>
<li><a href="../id449338/index.html">Julia. Layanan Web</a></li>
<li><a href="../id449342/index.html">Peramalan acak berdasarkan tanda tangan digital blockchain</a></li>
<li><a href="../id449344/index.html">Kodim - pizza</a></li>
<li><a href="../id449346/index.html">MODX Digest # 4 (8 - 22 April 2019)</a></li>
<li><a href="../id449348/index.html">Buildroot - bagian 2. Membuat konfigurasi papan Anda; penerapan skrip eksternal tree, rootfs-overlay, post-build</a></li>
<li><a href="../id449350/index.html">Keybase dan TOFU sejati</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>