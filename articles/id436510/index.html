<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✉️ 🚯 ⤴️ Data inti secara detail 👩 😑 🐏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya mulai mengerjakan proyek besar menggunakan Core Data. Yang biasa terjadi adalah orang-orang di proyek berubah, pengalaman hilang, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Data inti secara detail</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436510/"> Baru-baru ini, saya mulai mengerjakan proyek besar menggunakan Core Data.  Yang biasa terjadi adalah orang-orang di proyek berubah, pengalaman hilang, dan nuansa dilupakan.  Tidak mungkin untuk memperdalam semua orang ke dalam studi kerangka kerja tertentu - setiap orang memiliki masalah kerja mereka sendiri.  Oleh karena itu, saya menyiapkan presentasi singkat, dari poin-poin yang saya anggap penting atau tidak cukup dibahas dalam tutorial.  Saya berbagi dengan semua orang dan berharap ini akan membantu menulis kode yang efektif dan tidak membuat kesalahan.  Diasumsikan bahwa Anda sudah sedikit dalam subjek. <br><br>  Saya akan mulai dengan dangkal. <br><br>  Data Inti adalah kerangka kerja yang mengelola dan menyimpan data dalam suatu aplikasi.  Anda dapat mempertimbangkan Core Data sebagai pembungkus penyimpanan relasional fisik yang mewakili data dalam bentuk objek, sedangkan Core Data itu sendiri bukan database. <br><br><h2>  Objek Data Inti </h2><br><img src="https://habrastorage.org/webt/aq/ka/bk/aqkabk_js9w9knvyat6xp_u4u5a.png" alt="gambar"><br><a name="habracut"></a><br>  Untuk membuat penyimpanan, aplikasi menggunakan kelas <b>NSPersistentStoreCoordinator</b> atau <b>NSPersistentContainer</b> .  NSPersistentStoreCoordinator menciptakan penyimpanan dari tipe yang ditentukan berdasarkan model, Anda dapat menentukan lokasi dan opsi tambahan.  NSPersistentContainer dapat digunakan dengan iOS10, memberikan kemampuan untuk membuat dengan jumlah kode minimum. <br><br>  Ini berfungsi sebagai berikut: jika database ada di jalur yang ditentukan, koordinator memeriksa versinya dan, jika perlu, melakukan migrasi.  Jika database tidak ada, maka itu dibuat berdasarkan pada model NSManagedObjectModel.  Agar semua ini berfungsi dengan benar, sebelum membuat perubahan pada model, buat versi baru dalam Xcode melalui menu Editor -&gt; Add Model Version.  Jika Anda mendapatkan jalurnya, Anda dapat menemukan dan membuka basis di emulator. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh dengan NSPersistentStoreCoordinator</b> <div class="spoiler_text"><pre><code class="objectivec hljs">var persistentCoordinator: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span> = { let modelURL = Bundle.main.url(forResource: <span class="hljs-string"><span class="hljs-string">"Test"</span></span>, withExtension: <span class="hljs-string"><span class="hljs-string">"momd"</span></span>) let managedObjectModel = <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectModel</span></span>(contentsOf: modelURL!) let persistentCoordinator = <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span>(managedObjectModel: managedObjectModel!) let documentsPath = <span class="hljs-built_in"><span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span></span>(.documentDirectory, .userDomainMask, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] let storeURL = URL(fileURLWithPath: documentsPath.appending(<span class="hljs-string"><span class="hljs-string">"/Test.sqlite"</span></span>)) print(<span class="hljs-string"><span class="hljs-string">"storeUrl = \(storeURL)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { try persistentCoordinator.addPersistentStore(ofType: <span class="hljs-built_in"><span class="hljs-built_in">NSSQLiteStoreType</span></span>, configurationName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, at: storeURL, options: [<span class="hljs-built_in"><span class="hljs-built_in">NSSQLitePragmasOption</span></span>: [<span class="hljs-string"><span class="hljs-string">"journal_mode"</span></span>:<span class="hljs-string"><span class="hljs-string">"MEMORY"</span></span>]]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> persistentCoordinator } catch { abort() } } ()</code> </pre> <br></div></div><div class="spoiler">  <b class="spoiler_title">Contoh NSPersistentContainer</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">var persistentContainer: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentContainer</span></span> = { let container = <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentContainer</span></span>(name: <span class="hljs-string"><span class="hljs-string">"CoreDataTest"</span></span>) container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(<span class="hljs-string"><span class="hljs-string">"storeDescription = \(storeDescription)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let error = error as <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>? { fatalError(<span class="hljs-string"><span class="hljs-string">"Unresolved error \(error), \(error.userInfo)"</span></span>) } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container } ()</code> </pre><br></div></div><br>  Data Inti menggunakan 4 jenis penyimpanan: <br><br>  - SQLite <br>  - biner <br>  - dalam memori <br>  - XML ​​(hanya Mac OS) <br><br>  Jika, misalnya, untuk alasan keamanan, Anda tidak ingin menyimpan data dalam bentuk file, tetapi pada saat yang sama ingin menggunakan caching selama sesi dan data dalam bentuk objek, penyimpanan tipe "Dalam Memori" cukup cocok.  Sebenarnya, tidak dilarang memiliki beberapa jenis penyimpanan dalam satu aplikasi. <br><br>  Saya ingin mengatakan beberapa kata tentang objek <b>NSManagedObjectContext</b> .  Secara umum, Apple memberikan kata-kata yang sangat kabur untuk NSManagedObjectContext - sebuah lingkungan untuk bekerja dengan objek Data Inti.  Semua ini karena keinginan untuk memisahkan diri dari asosiasi dengan basis data relasional, dan untuk menyajikan Data Inti sebagai alat yang mudah digunakan yang tidak memerlukan pemahaman tentang kunci, transaksi, dan atribut Bazdan lainnya.  Tetapi dalam bahasa basis data relasional, NSManagedObjectContext dapat, dalam arti tertentu, disebut manajer transaksi.  Anda mungkin memperhatikan bahwa ia memiliki metode simpan dan kembalikan, meskipun kemungkinan besar Anda hanya menggunakan yang pertama. <br><br>  Kesalahpahaman fakta sederhana ini mengarah pada penggunaan model konteks tunggal, bahkan dalam situasi di mana itu tidak cukup.  Misalnya, Anda mengedit dokumen besar, dan pada saat yang sama Anda harus mengunduh beberapa direktori.  Pada titik apa Anda menelepon save?  Jika kami bekerja dengan database relasional, maka tidak akan ada pertanyaan, karena setiap operasi akan dilakukan dalam transaksi sendiri.  Core Data juga memiliki cara yang sangat mudah untuk menyelesaikan masalah ini - ini adalah cabang dari konteks anak.  Namun sayangnya, untuk beberapa alasan ini jarang digunakan.  Di sini ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> bagus tentang topik ini. <br><br><h2>  Warisan </h2><br>  Untuk beberapa alasan saya tidak mengerti, ada sejumlah besar manual dan contoh di mana warisan untuk Entity / NSManagedObject (tabel) tidak digunakan dengan cara apa pun.  Sementara itu, ini adalah alat yang sangat nyaman.  Jika Anda tidak menggunakan warisan, maka Anda dapat menetapkan nilai ke atribut (bidang) hanya melalui mekanisme KVC, yang tidak memeriksa nama dan tipe atribut, dan ini dapat dengan mudah menyebabkan kesalahan runtime. <br><br>  Redefinisi kelas untuk NSManagedObject dilakukan dalam desainer Data Inti: <br><br><img src="https://habrastorage.org/webt/ce/52/_p/ce52_pz39mzguhyiotm5rvhh00k.png" alt="gambar"><br><br><h2>  Warisan dan pembuatan kode </h2><br>  Setelah menentukan nama kelas untuk Entity, Anda bisa menggunakan pembuatan kode dan mendapatkan kelas dengan kode siap pakai: <br><br><img src="https://habrastorage.org/webt/al/dn/7a/aldn7aozwsnv-l7sjv8vau4iwmi.png" alt="gambar"><br><br><img src="https://habrastorage.org/webt/kj/ra/kh/kjrakhjgijvth5obsls22g6vtjk.png" alt="gambar"><br><br>  Jika Anda ingin melihat kode yang dibuat secara otomatis, tetapi tidak ingin menambahkan file ke proyek, Anda dapat menggunakan cara lain: setel opsi "Codegen" untuk Entity.  Dalam hal ini, kode harus dicari di ../ DerivedData / ... <br><br><img src="https://habrastorage.org/webt/zg/vw/9e/zgvw9e3sulaf6g7qici-uitdsei.png" alt="gambar"><br><br>  Gunakan pembuatan kode untuk membuat kelas, kesalahan ketik pada nama variabel dapat menyebabkan kesalahan runtime. <br><br>  Berikut ini beberapa kode seperti ini: <br><br><pre> <code class="objectivec hljs">@objc public <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Company: <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> {    @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var inn: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var name: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var uid: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var employee: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>? }</code> </pre><br>  Secara cepat, @NSManaged memiliki arti yang sama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">dinamis</a> dalam Objective C. <br>  Core Data sendiri menangani penerimaan data (memiliki pengakses internal) untuk atribut kelasnya.  Jika Anda memiliki bidang transit, maka Anda perlu menambahkan fungsi untuk menghitungnya. <br><br>  Kelas yang diwarisi dari NSManagedObject (tabel) tidak memiliki konstruktor "reguler" sebelum IOS10, tidak seperti kelas lainnya.  Untuk membuat objek dengan tipe Company, perlu untuk menulis konstruksi yang agak canggung menggunakan NSEntityDescription.  Sekarang ada metode inisialisasi yang lebih nyaman melalui konteks (NSManagedObjectContext).  Kode di bawah.  Perhatikan keuntungan pewarisan saat menetapkan atribut di atas mekanisme KVC: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 -    NSEntityDescription,    KVO let company1 = NSEntityDescription.insertNewObject(forEntityName: "Company", into: moc) company1.setValue("077456789111", forKey: "inn") company1.setValue(" ", forKey: "name") // 2 -    NSEntityDescription,     let company2 = NSEntityDescription.insertNewObject(forEntityName: "Company", into: moc) as! Company company2.inn = "077456789222" company2.name = " " // 3 -     (IOS10+),     let company3 = Company(context: moc) company3.inn = "077456789222" company3.name = " "</span></span></code> </pre><br><h2>  Namespace untuk NSManagedObject </h2><br>  Hal lain yang layak disebut adalah namespace. <br><br><img src="https://habrastorage.org/webt/fk/a7/wl/fka7wlfqlf4cvi1ezcqst4kiiyi.png" alt="gambar"><br><br>  Anda tidak akan mengalami kesulitan jika Anda mengerjakan ObjectiveC atau Swift.  Biasanya, bidang ini diisi dengan benar secara default.  Tetapi dalam proyek campuran, mungkin mengejutkan Anda bahwa untuk kelas cepat dan ObjectiveC Anda perlu meletakkan opsi yang berbeda.  Di Swift, "Modul" harus diisi.  Jika bidang ini tidak selesai, awalan dengan nama proyek akan ditambahkan ke nama kelas, yang akan menyebabkan kesalahan runtime.  Di Objetive C, biarkan "Module" kosong, jika tidak NSManagedObject tidak akan ditemukan ketika mengaksesnya melalui nama kelas. <br><br><h2>  Tautan antar objek </h2><br>  Pada prinsipnya, topik hubungan dibahas dengan baik, tetapi saya ingin fokus pada cara menambahkan entitas anak ke orang tua.  Oleh karena itu, pertama, pengingat cepat tentang mekanisme untuk membuat tautan.  Pertimbangkan contoh tradisional, perusahaan adalah karyawan, hubungan satu-ke-banyak: <br><br><ul><li>  Buat koneksi di setiap sisi (tabel) </li><li>  Setelah itu, bidang Invers menjadi tersedia, itu harus diisi di setiap tabel. </li></ul><br><img src="https://habrastorage.org/webt/_m/fx/si/_mfxsi_lcnxt8t3zlhh0vbrbsus.png" alt="gambar"><br><br><img src="https://habrastorage.org/webt/kb/uo/my/kbuomy1etksutabvijrvxlztiyy.png" alt="gambar"><br><br>  Apple bersikeras menentukan hubungan terbalik.  Pada saat yang sama, inversi tidak memperkuat koherensi, tetapi membantu Core Data melacak perubahan di kedua sisi koneksi, penting untuk caching dan memperbarui informasi. <br><br>  Penting juga bahwa aturan penghapusan ditentukan dengan benar.  Aturan penghapusan adalah tindakan yang akan dilakukan dengan objek ini ketika objek induk dihapus. <br><br><ul><li>  Cascade - penghapusan semua objek anak, ketika orang tua dihapus. </li><li>  Tolak - larangan menghapus orang tua jika ada anak </li><li>  Nullify - membatalkan referensi orang tua </li><li>  Tidak ada tindakan - tidak ada tindakan yang ditentukan, itu akan memberikan peringatan saat kompilasi </li></ul><br>  Dalam contoh ini, ketika sebuah perusahaan dihapus, semua karyawan akan dihapus (kaskade).  Ketika Anda menghapus seorang karyawan, tautan ke dia di perusahaan akan diatur ulang (pra layar) <br><br><h2>  Cara menambahkan entitas anak ke induk </h2><br>  <b>1)</b> Metode pertama adalah menambahkan melalui NSSet.  Misalnya, tambahkan 2 karyawan ke perusahaan: <br><br><pre> <code class="objectivec hljs">let set = <span class="hljs-built_in"><span class="hljs-built_in">NSMutableSet</span></span>();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let employee1 = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee1.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee1.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> set.add(employee1) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let emploee2 = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee2.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee2.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> set.add(employee2) }    company.employee = set</code> </pre><br>  Metode ini nyaman untuk menginisialisasi objek atau mengisi database.  Ada sedikit nuansa.  Jika perusahaan sudah memiliki karyawan, dan Anda menetapkan satu set baru, maka mantan karyawan akan mengatur ulang tautan ke perusahaan, tetapi mereka tidak akan dihapus.  Atau, Anda bisa mendapatkan daftar karyawan dan bekerja dengan set ini. <br><br><pre> <code class="objectivec hljs">let set = company.mutableSetValue(forKey: <span class="hljs-string"><span class="hljs-string">"employee"</span></span>)</code> </pre> <br>  <b>2)</b> Menambahkan objek anak melalui id induk <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let employee = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee.company = company }</code> </pre><br>  Metode kedua nyaman ketika menambahkan atau mengedit objek anak di <br>  bentuk terpisah. <br><br>  <b>3)</b> Menambahkan objek anak melalui metode yang dibuat secara otomatis <br><br><pre> <code class="objectivec hljs">extension Company {    @objc(addEmployeeObject:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func addEmployee(_ value: Employee)    @objc(removeEmployeeObject:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func removeFromEmployee(_ value: Employee)    @objc(addEmployee:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func addEmployee(_ values: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>)    @objc(removeEmployee:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func removeFromEmployee(_ values: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>) }</code> </pre><br>  Demi kelengkapan, berguna untuk mengetahui tentang metode ini, tetapi entah bagaimana itu tidak berguna bagi saya, dan saya menghapus kode tambahan agar tidak mengacaukan proyek. <br><br><h2>  Pertanyaan Klausa Anak </h2><br>  Di Core Data, Anda tidak dapat membuat kueri sembarang antara data apa pun, seperti yang dapat kami lakukan dalam SQL.  Namun di antara objek dependen, mudah dilacak menggunakan predikat standar.  Di bawah ini adalah contoh dari kueri yang memilih semua perusahaan di mana ada seorang karyawan dengan nama yang ditentukan: <br><br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func getCompanyWithEmployee(name: String) -&gt; [Company] { let request = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequestResult</span></span>&gt;(entityName: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.className()) request.predicate = <span class="hljs-built_in"><span class="hljs-built_in">NSPredicate</span></span>(format: <span class="hljs-string"><span class="hljs-string">"ANY employee.firstName = %@"</span></span>, name) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let result = try moc.fetch(request) as? [Company] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } } catch { } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [Company]() }</code> </pre><br>  Metode panggilan dalam kode akan terlihat seperti ini: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    let companies = Company.getCompanyWithEmployee(name: "")</span></span></code> </pre><br>  Jangan gunakan bidang transit dalam kueri, nilainya tidak ditentukan pada saat kueri dieksekusi.  Tidak ada kesalahan akan terjadi, tetapi hasilnya akan salah. <br><br><h2>  Mengatur atribut (bidang) </h2><br>  Anda mungkin memperhatikan bahwa atribut Entity memiliki beberapa opsi. <br>  Dengan opsional, semuanya jelas dari namanya. <br><br>  Opsi untuk menggunakan tipe skalar muncul di swif.  Objective-C tidak menggunakan tipe skalar untuk atribut, karena mereka tidak boleh nol.  Mencoba untuk menetapkan nilai skalar ke atribut melalui KVC akan menyebabkan kesalahan runtime.  Ini memperjelas mengapa tipe atribut dalam Core Data tidak memiliki korespondensi yang ketat dengan jenis bahasa.  Dalam cepat, dan dalam proyek campuran, atribut tipe skalar dapat digunakan. <br><br>  Atribut transit adalah bidang terhitung yang <b>tidak</b> disimpan dalam database.  Mereka dapat digunakan untuk enkripsi.  Atribut-atribut ini menerima nilai melalui accessor yang diganti, atau melalui menetapkan primitif sesuai kebutuhan (misalnya, akan ditimpa Hemat dan awakeFromFetch). <br><br><h2>  Aksesor Atribut: </h2><br>  Jika Anda tidak perlu menggunakan bidang terhitung, misalnya, untuk melakukan enkripsi atau sesuatu yang lain, maka Anda tidak perlu memikirkan apa itu aksesori atribut.  Sementara itu, operasi untuk mendapatkan dan menetapkan nilai ke atribut bukan "atom".  Untuk memahami apa yang saya maksud, lihat kode di bawah ini: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  let name = company.name //  company.willAccessValue(forKey: "name") let name = company.primitiveValue(forKey: "name") company.didAccessValue(forKey: "name") //  company.name = " " //  company.willChangeValue(forKey: "name") company.setPrimitiveValue(" ", forKey: "name") company.didChangeValue(forKey: "name")</span></span></code> </pre><br>  Gunakan primitif dalam peristiwa NSManagedObject alih-alih tugas yang biasa untuk menghindari perulangan.  Contoh: <br><br><pre> <code class="objectivec hljs">override func willSave() {   let nameP = encrypt(field: primitiveValue(forKey: <span class="hljs-string"><span class="hljs-string">"name"</span></span>), password: password)   setPrimitiveValue(nameP, forKey: <span class="hljs-string"><span class="hljs-string">"nameC"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.willSave() }  override func awakeFromFetch() {   let nameP = decrypt(field: primitiveValue(forKey: <span class="hljs-string"><span class="hljs-string">"nameC"</span></span>), password: password)   setPrimitiveValue(nameP, forKey: <span class="hljs-string"><span class="hljs-string">"name"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.awakeFromFetch() }</code> </pre><br>  Jika tiba-tiba suatu saat Anda harus mengacaukan fungsi awakeFromFetch menjadi sebuah proyek, maka Anda akan terkejut bahwa itu berfungsi sangat aneh, tetapi sebenarnya itu tidak dipanggil sama sekali ketika Anda menjalankan permintaan.  Ini disebabkan oleh fakta bahwa Core Data memiliki mekanisme caching yang sangat cerdas, dan jika seleksi sudah ada dalam memori (misalnya, karena Anda baru saja mengisi tabel ini), maka metode ini tidak akan dipanggil.  Namun, percobaan saya menunjukkan bahwa dalam hal nilai yang dihitung, Anda dapat dengan aman mengandalkan penggunaan awakeFromFetch, seperti yang dikatakan oleh dokumentasi Apple.  Jika untuk pengujian dan pengembangan Anda perlu memaksa awakeFromFetch, tambahkan managedObjectContext.refreshAllObjects () sebelum permintaan. <br><br>  Itu saja. <br><br>  Terima kasih kepada semua orang yang membaca sampai akhir. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436510/">https://habr.com/ru/post/id436510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436500/index.html">Bagaimana kerangka Rise of the Tomb Raider ditampilkan</a></li>
<li><a href="../id436502/index.html">Pampers Berlangganan atau Cara Menjual Lebih Banyak ke Pelanggan yang Sama</a></li>
<li><a href="../id436504/index.html">Sistem dalam Paket, atau Penutup Paket Apa Yang Ada Dalam Chip?</a></li>
<li><a href="../id436506/index.html">Cara membuat AI-rasis tanpa banyak usaha</a></li>
<li><a href="../id436508/index.html">Investasi $ 10 juta dan pujian Wozniak - menciptakan komputer pendidikan untuk anak-anak</a></li>
<li><a href="../id436512/index.html">Bagaimana kami menemukan rilis bermasalah dengan Graphite dan Moira. Rasakan Yandex.Money</a></li>
<li><a href="../id436514/index.html">Membuat cerita untuk Instagram dari PHP</a></li>
<li><a href="../id436518/index.html">Haiku β1 - buat / b / OS hebat lagi</a></li>
<li><a href="../id436520/index.html">Jangan menggunakan layanan verifikasi online ketika membocorkan data pribadi</a></li>
<li><a href="../id436522/index.html">Bertentangan dengan instruksi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>