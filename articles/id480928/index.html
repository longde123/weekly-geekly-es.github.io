<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¢ üßóüèΩ ‚è¨ Apache Hadoop Code Quality: uji VS produksi üëãüèº üï≥Ô∏è üöº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk mendapatkan kode produksi berkualitas tinggi, tidak cukup hanya dengan memberikan cakupan pengujian maksimum. Tidak diragukan lagi, untuk mencap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Hadoop Code Quality: uji VS produksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480928/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Gambar 1"></div><br>  Untuk mendapatkan kode produksi berkualitas tinggi, tidak cukup hanya dengan memberikan cakupan pengujian maksimum.  Tidak diragukan lagi, untuk mencapai hasil yang tinggi, kode proyek utama dan tes harus bekerja dalam tandem kohesif yang sempurna.  Karena itu, Anda perlu memperhatikan tes sebanyak kode utama.  Menulis tes yang baik adalah kunci untuk mendapatkan regresi dalam produksi.  Untuk menunjukkan pentingnya fakta bahwa bug dalam pengujian tidak lebih buruk daripada dalam produksi, kami akan mempertimbangkan analisis peringatan berikutnya dari penganalisa statis PVS-Studio.  Target: Apache Hadoop. <br><a name="habracut"></a><br><h2>  Tentang proyek </h2><br>  Mereka yang pernah tertarik dengan Big Data mungkin pernah mendengar atau bekerja dengan proyek seperti <a href="https://hadoop.apache.org/">Apache Hadoop</a> .  Singkatnya, Hadoop adalah kerangka kerja yang dapat digunakan sebagai dasar untuk membangun dan bekerja dengan sistem Big Data. <br><br>  Hadoop terdiri dari empat modul utama, yang masing-masing melakukan tugas khusus yang diperlukan untuk sistem analisis data besar: <br><br><ul><li>  Hadoop biasa </li><li>  Kurangi peta </li><li>  Sistem File Terdistribusi Hadoop (Sistem File Terdistribusi Hadoop) </li><li>  Benang </li></ul><br>  Namun, ada banyak bahan untuk membiasakan diri dengan itu di Internet. <br><br><h2>  Tentang Verifikasi </h2><br>  Seperti yang ditunjukkan dalam <a href="https://www.viva64.com/ru/m/0044/">dokumentasi</a> , PVS-Studio dapat diintegrasikan ke dalam proyek dengan berbagai cara: <br><br><ul><li>  menggunakan plugin maven; </li><li>  menggunakan plugin gradle; </li><li>  Menggunakan IntellJ IDEA </li><li>  menggunakan analisa secara langsung. </li></ul><br>  Hadoop dibangun berdasarkan sistem pembangunan pakar, sehingga tidak ada kesulitan dengan verifikasi. <br><br>  Setelah mengintegrasikan skrip dari dokumentasi dan sedikit menyesuaikan salah satu pom.xml (ada modul dalam dependensi yang tidak ada), analisis berjalan! <br><br>  Setelah analisis, memilih peringatan yang paling menarik, saya perhatikan bahwa saya memiliki jumlah peringatan yang sama baik dalam kode produksi dan tes.  Biasanya, saya tidak mempertimbangkan pemicu analisa yang jatuh pada tes.  Tapi, membaginya, saya tidak bisa melewatkan peringatan dari kategori 'tes' melewati perhatian saya.  "Kenapa tidak?" Saya pikir, karena bug dalam tes juga memiliki konsekuensi.  Mereka dapat menyebabkan pengujian yang salah atau sebagian, atau bahkan omong kosong (hanya untuk pertunjukan, sehingga mereka selalu hijau). <br><br>  Jadi, setelah mengumpulkan peringatan yang paling menarik, membaginya dengan kode (produksi, pengujian) dan empat modul Hadoop utama, saya membawa kepada Anda sebuah analisis operasi penganalisa. <br><br><h2>  Kode produksi </h2><br><h3>  Hadoop biasa </h3><br>  <a href="https://www.viva64.com/ru/w/v6033/">V6033</a> Item dengan kunci yang sama 'KDC_BIND_ADDRESS' telah ditambahkan.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  Nilai yang ditambahkan dua kali ke <i>HashSet</i> adalah cacat umum saat memeriksa proyek.  Bahkan, penambahan kedua akan diabaikan.  Nah, jika duplikasi ini adalah kecelakaan yang tidak masuk akal.  Tetapi bagaimana jika itu benar-benar berarti menambah nilai lain? <br><br><h3>  Kurangi peta </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'localFiles' harus digunakan daripada 'localArchives'.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Diagnostik V6072 terkadang menghasilkan temuan yang sangat menarik.  Inti dari diagnostik adalah mencari jenis fragmen kode yang sama yang diperoleh dengan menyalin dan menempel satu atau dua variabel, tetapi pada saat yang sama beberapa variabel ‚Äúdiremehkan‚Äù. <br><br>  Kode di atas menunjukkan ini.  Di blok pertama, tindakan dilakukan dengan variabel <i>localArchives</i> , di blok berikutnya dari tipe yang sama, dengan <i>localFiles</i> .  Dan jika Anda dengan hati-hati mempelajari kode ini, dan jangan membahasnya dengan cepat, seperti yang sering terjadi dengan ulasan kode, maka perhatikan tempat di mana Anda lupa mengganti variabel <i>localArchives</i> . <br><br>  Pengawasan seperti itu dapat mengarah pada skenario berikut: <br><br><ul><li>  Misalkan kita memiliki <i>localArchives</i> (size = 4) dan <i>localFiles</i> (size = 2); </li><li>  Saat membuat array <i>localFiles.toArray (String baru [localArchives.size ()]))</i> , kita mendapatkan 2 elemen terakhir menjadi <i>null</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Setelah itu, <i>org.apache.hadoop.util.StringUtils.arrayToString</i> akan mengembalikan representasi string array kami di mana nama file terakhir akan direpresentasikan sebagai "null" ("pathToFile1, pathToFile2, null, null" <i>)</i> ; </li><li>  Semua ini akan diteruskan, dan siapa yang tahu pemeriksaan apa yang ada untuk kasus-kasus seperti itu =). </li></ul><br>  Ekspresi <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> 'children.size ()&gt; 0' selalu benar.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  Karena fakta bahwa memeriksa jumlah elemen pada 0 dilakukan secara terpisah, pemeriksaan lebih lanjut <i>children.size ()&gt; 0</i> akan selalu memberikan true. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/ru/w/v6001/">V6001</a> Ada sub-ekspresi identik 'this.bucketSize' di sebelah kiri dan di sebelah kanan operator '%'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Cacat ini terletak pada fakta bahwa variabel dibagi menjadi dirinya sendiri.  Akibatnya, pemeriksaan untuk multiplisitas akan selalu berlalu, dan, jika ada data input yang salah ( <i>windowLenMs</i> , <i>numBuckets</i> ), pengecualian tidak akan dibuang. <br><br><h3>  Benang </h3><br>  <a href="https://www.viva64.com/ru/w/v6067/">V6067</a> Dua atau lebih cabang kasus melakukan tindakan yang sama.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  Dalam dua cabang <i>kasus</i> , fragmen kode yang sama.  Ini terjadi setiap saat!  Dalam jumlah kasus yang dominan, ini bukan kesalahan nyata, tetapi hanya kesempatan untuk berpikir tentang <i>beralih</i> refactoring.  Tetapi tidak untuk kasus yang dimaksud.  Dalam cuplikan kode berulang, nilai variabel <i>preemptedVcoreSeconds ditetapkan</i> .  Jika Anda memperhatikan nama semua variabel dan konstanta, Anda bisa sampai pada kesimpulan bahwa dalam kasus <i>metric.getId () == APP_MEM_PREEMPT_METRICS</i> , nilai variabel <i>preemptedMemorySeconds</i> harus ditetapkan, bukan <i>preemptedVcoreSeconds</i> .  Dalam hal ini, <i>preemptedMemorySeconds</i> akan selalu tetap 0 setelah mengeksekusi pernyataan 'switch', dan nilai <i>preemptedVcoreSeconds</i> mungkin salah. <br><br>  <a href="https://www.viva64.com/ru/w/v6046/">V6046</a> Format salah.  Jumlah item format yang berbeda diharapkan.  Argumen tidak digunakan: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  <i>PlanQueueName</i> variabel yang tidak digunakan saat login.  Di sini, mereka terlalu banyak menyalin, atau tidak mengubah string format.  Namun demikian, saya cenderung kepada orang tua yang baik dan, kadang-kadang membawa kerugian, salin-tempel. <br><br><h2>  Kode uji </h2><br><h3>  Hadoop biasa </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'allSecretsB' harus digunakan alih-alih 'allSecretsA'.  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Dan lagi V6072.  Watch out for the variabel <i>allSecretsA</i> dan <i>allSecretsB</i> . <br><br>  <a href="https://www.viva64.com/ru/w/v6043/">V6043</a> Pertimbangkan untuk memeriksa operator 'untuk'.  Nilai awal dan akhir dari iterator adalah sama.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  Tes yang selalu hijau?  =).  Tubuh loop, yang merupakan bagian dari tes, tidak pernah dieksekusi.  Ini disebabkan oleh fakta bahwa nilai awal dan akhir dari pencocokan pencocokan dalam pernyataan <i>for</i> .  Akibatnya, kondisi yang <i>saya mulai akan</i> segera memberi kita salah, yang akan mengarah pada perilaku ini.  Saya berlari melalui file dengan tes dan sampai pada kesimpulan bahwa itu diperlukan untuk menulis dalam kondisi loop <i>i &lt;(start + n)</i> . <br><br><h3>  Kurangi peta </h3><br>  a href = " <a href="https://www.viva64.com/ru/w/v6007/">www.viva64.com/en/w/v6007</a> "&gt; Ekspresi V6007 'byteAm &lt;0' selalu salah.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  Kondisi <i>byteAm &lt;0</i> selalu salah.  Untuk memahami, mari kita naikkan kode di atas.  Jika eksekusi pengujian mencapai operasi <i>byteAm - = headerLen</i> , maka ini berarti bahwa akan ada <i>byteAm&gt; = headerLen</i> .  Dari sini, setelah melakukan pengurangan, nilai <i>byteAm</i> tidak akan pernah negatif.  Yang harus dibuktikan. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'normalFile' harus digunakan daripada 'normalDir'.  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Jangan percaya, dan lagi V6072!  Cukup ikuti <i>variabel normalDir</i> dan <i>normalFile</i> <br><br>  <a href="https://www.viva64.com/ru/w/v6027/">V6027</a> Variabel diinisialisasi melalui panggilan ke fungsi yang sama.  Mungkin salah atau kode tidak dioptimalkan.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  Dalam fragmen ini, variabel <i>tertinggiPriorityLowRedundancyReplicatedBlocksStr</i> dan <i>tertinggiPriorityLowRedundancyECBlocksStr</i> diinisialisasi dengan nilai yang sama.  Seringkali seharusnya demikian, tetapi tidak dalam situasi ini.  Nama-nama variabel di sini panjang dan mirip satu sama lain, jadi saya tidak terkejut bahwa tidak ada modifikasi yang sesuai dengan copy-paste.  Untuk memperbaiki situasi, saat menginisialisasi variabel <i>tertinggiPriorityLowRedundancyECBlocksStr,</i> Anda harus menggunakan parameter input <i>tertinggiPriorityLowRedundancyECBlocks</i> .  Selain itu, kemungkinan besar, Anda masih perlu memperbaiki string format. <br><br>  <a href="https://www.viva64.com/ru/w/v6019/">V6019</a> Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  Analisator bersumpah bahwa mengubah penghitung <i>i ++</i> di loop tidak dapat dicapai.  Ini berarti bahwa dalam loop <i>for (int i = 0; i &lt;slowwriters.length; i ++) {....}</i> tidak lebih dari satu iterasi yang akan dilakukan.  Mari kita cari tahu alasannya.  Jadi, dalam iterasi pertama, kami mengaitkan aliran dengan file yang sesuai dengan <i>slowwriters [0]</i> untuk dibaca lebih lanjut.  Melalui <i>for</i> loop <i>(int j = 0, x ;; j ++), kita</i> membaca isi file dengan byte, di mana: <br><br><ul><li>  jika kita membaca sesuatu yang memadai, maka melalui <i>assertEquals kita</i> membandingkan byte baca dengan nilai saat ini dari counter <i>j</i> (dalam kasus verifikasi yang gagal, kita keluar dari tes dengan gagal) </li><li>  jika file lulus tes dan kami mencapai akhir file (baca -1), maka kami keluar dari metode. </li></ul><br>  Oleh karena itu, apa pun yang terjadi ketika memeriksa <i>slowwriter [0]</i> , itu tidak akan sampai pada verifikasi elemen-elemen berikut.  Kemungkinan besar, <i>break</i> harus digunakan alih-alih <i>kembali</i> . <br><br><h3>  Benang </h3><br>  <a href="https://www.viva64.com/ru/w/v6019/">V6019</a> Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  Dalam situasi ini, stacktrace tidak akan pernah dicetak jika pengecualian terjadi, karena metode <i>Assert.fail</i> akan mengganggu pengujian.  Jika ada cukup banyak pesan bahwa pengecualian ditangkap, maka agar tidak bingung, cetakan stacktrace perlu dihapus.  Jika perlu mencetak, maka Anda hanya perlu menukarnya. <br><br>  Ada banyak tempat seperti itu: <ul><li>  V6019 Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestResourceTrackerService.java (928) </li><li>  V6019 Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestResourceTrackerService.java (737) </li><li>  V6019 Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'publicCache' harus digunakan daripada 'usercache'.  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Dan akhirnya, sekali lagi V6072 =).  Variabel untuk membiasakan diri Anda dengan cuplikan yang mencurigakan: <i>usercache</i> dan <i>publicCache</i> . <br><br><h2>  Kesimpulan </h2><br>  Selama pengembangan, ratusan ribu baris kode ditulis.  Jika kode produksi berusaha menjaga kebersihan dari bug, cacat, dan kekurangan (pengembang menguji kode sendiri, melakukan tinjauan kode, dan banyak lagi), maka pengujian jelas lebih rendah dari ini.  Cacat dalam tes diam-diam bisa bersembunyi di balik "centang hijau".  Dan seperti yang Anda pahami dari analisis peringatan hari ini, tes yang berhasil lulus masih jauh dari tes yang dijamin. <br><br>  Ketika memeriksa basis kode Apache Hadoop, analisis statis menunjukkan kebutuhannya tidak hanya untuk kode yang masuk ke produksi, tetapi juga untuk tes yang juga memainkan peran penting dalam pengembangan. <br><br>  Jadi jika Anda peduli dengan kualitas kode dan basis pengujian Anda, maka saya sarankan Anda melihat analisis statis.  Dan pelamar pertama untuk tes saya mengusulkan untuk mencoba <a href="https://www.viva64.com/ru/pvs-studio-download/">PVS-Studio</a> . <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/480918/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Maxim Stefanov.  <a href="https://habr.com/en/company/pvs-studio/blog/480918/">Kualitas Kode Apache Hadoop: Produksi VS Tes</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480928/">https://habr.com/ru/post/id480928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480918/index.html">Kualitas Kode Apache Hadoop: Produksi VS Tes</a></li>
<li><a href="../id480920/index.html">Uji sakelar TP-Link dengan PoE jarak jauh. Dan sedikit tentang peningkatan model lama</a></li>
<li><a href="../id480922/index.html">Evgeny Usvitsky: "Semua orang di dunia tahu di mana mendapatkan geodata secara bebas - hanya di OSM"</a></li>
<li><a href="../id480924/index.html">Bagaimana dan mengapa pembuat remake MediEvil mendesain ulang bos sekte permainan</a></li>
<li><a href="../id480926/index.html">Teori Probabilitas untuk Rendering yang Akurat Secara Fisik</a></li>
<li><a href="../id480930/index.html">Ketikkan semuanya</a></li>
<li><a href="../id480936/index.html">IntelliJ IDEA konversi cepat UPPER_CASE ke camelCase</a></li>
<li><a href="../id480938/index.html">Cryptocurrency melalui mata para hakim Rusia</a></li>
<li><a href="../id480940/index.html">Jalankan uji UI lintas-browser dengan Mentimun dan Selenoid di Gitlab CI dengan laporan Allure</a></li>
<li><a href="../id480944/index.html">5 Tren Teratas dalam Pemasaran Email pada tahun 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>