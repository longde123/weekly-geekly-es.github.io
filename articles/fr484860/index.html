<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöò üßíüèº üë©üèº‚Äç‚öïÔ∏è Nom de l'impl√©mentation et nom du r√©sultat üêú üßë‚Äçü§ù‚Äçüßë üöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je voulais √©crire ce billet en juillet, mais je ne pouvais pas, oh ironie , d√©cider comment l'appeler. Les bons termes ne me sont venus √† l'esprit qu'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nom de l'impl√©mentation et nom du r√©sultat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484860/"><p><img src="https://habrastorage.org/webt/sw/9a/fb/sw9afbxo38dofpspvffb0c_jrq4.jpeg"></p><br><p>  Je voulais √©crire ce billet en juillet, mais je ne pouvais pas, <em>oh ironie</em> , d√©cider comment l'appeler.  Les bons termes ne me sont venus √† l'esprit qu'apr√®s <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">la conf√©rence de Kate Gregory √† CppCon</a> , et maintenant je peux enfin vous dire comment appeler les fonctions. </p><br><p> Bien s√ªr, il y a des noms qui ne portent pas du tout d'informations, comme <code>int f(int x)</code> .  Ils n'ont pas non plus besoin d'√™tre utilis√©s, mais ce n'est pas √† propos d'eux.  Il arrive parfois qu'il semble que les informations contenues dans le titre soient compl√®tes, mais cela ne pr√©sente aucun avantage. </p><a name="habracut"></a><br><h2 id="primer-1-stdlog2p1">  Exemple 1: std :: log2p1 () </h2><br><p>  En C ++ 20, plusieurs nouvelles fonctions pour les op√©rations sur les bits ont √©t√© ajout√©es √† l'en-t√™te, entre autres <code>std::log2p1</code> .  Cela ressemble √† ceci: <br><br><br></p><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log2p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::log2(x)); }</code> </pre><br><p>  Autrement dit, pour tout nombre naturel, la fonction renvoie son logarithme binaire plus 1, et pour 0, elle renvoie 0. Et ce n'est pas une t√¢che d'√©cole pour l'op√©rateur if / else, c'est vraiment une chose utile - le nombre minimum de bits dans lequel cette valeur va tenir.  Le deviner par le nom de la fonction est presque impossible. </p><br><h2 id="primer-2-stdbless">  Exemple 2: std :: bless () </h2><br><p>  <em>Maintenant, ce ne sera plus le nom</em> </p><br><p>  Une petite digression: en C ++, l'arithm√©tique des pointeurs ne fonctionne qu'avec des pointeurs vers des √©l√©ments de tableau.  Ce qui, en principe, est logique: dans le cas g√©n√©ral, l'ensemble des objets voisins est inconnu et ¬´tout peut arriver en dix octets √† droite de la variable <code>i</code> ¬ª.  Il s'agit d'un comportement sans ambigu√Øt√© vague. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> obj = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = &amp;obj; ++ptr; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p>  Mais une telle restriction d√©clare une √©norme quantit√© de comportement ind√©fini de code existant.  Par exemple, voici une impl√©mentation simplifi√©e de <code>std::vector&lt;T&gt;::reserve()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      auto new_memory = (T*) ::operator new(n * sizeof(T)); //    ‚Ä¶ //   auto size = this-&gt;size(); begin_ = new_memory; //   end_ = new_memory + size; //     end_capacity_ = new_memory + n; //    }</span></span></code> </pre> <br><p>  Nous avons allou√© de la m√©moire, d√©plac√© tous les objets et essayons maintenant de nous assurer que les pointeurs indiquent o√π aller.  Voici que les trois derni√®res lignes ne sont pas d√©finies, car elles contiennent des op√©rations arithm√©tiques sur des pointeurs en dehors du tableau! </p><br><p>  Bien s√ªr, ce n'est pas le programmeur qui est √† bl√¢mer.  Le probl√®me vient du standard C ++ lui-m√™me, qui d√©clare que ce morceau de code √©videmment raisonnable est un comportement non d√©fini.  Par cons√©quent, <a href="https://wg21.link/p0593">P0593</a> sugg√®re de corriger la norme en ajoutant certaines fonctions (comme <code>::operator new</code> et <code>std::malloc</code> ) la possibilit√© de cr√©er des tableaux selon les besoins.  Tous les pointeurs cr√©√©s par eux deviendront magiquement des pointeurs vers des tableaux, et des op√©rations arithm√©tiques peuvent √™tre effectu√©es avec eux. </p><br><p>  <em>Toujours pas sur les noms, attendez une seconde.</em> </p><br><p>  Mais parfois, des op√©rations sur les pointeurs sont n√©cessaires lorsque vous travaillez avec de la m√©moire qu'une de ces fonctions n'a pas allou√©e.  Par exemple, la fonction <code>deallocate()</code> fonctionne essentiellement avec la m√©moire morte, dans laquelle il n'y a aucun objet du tout, mais doit toujours additionner le pointeur et la taille de la zone.  Pour ce cas, P0593 offrait la fonction <code>std::bless(void* ptr, std::size_t n)</code> (il y avait une autre fonction l√†-bas, qui est aussi appel√©e <code>bless</code> , mais ce n'est pas tout).  Il n'a aucun effet sur un ordinateur physique r√©el, mais il cr√©e des objets pour une machine abstraite qui permettraient d'utiliser l'arithm√©tique des pointeurs. </p><br><p>  Le nom <code>std::bless</code> √©tait temporaire. </p><br><p>  <em>Donc, le nom.</em> </p><br><p>  A Cologne, LEWG a √©t√© charg√© de trouver un nom pour cette fonction.  Les options <code>implicitly_create_objects()</code> et <code>implicitly_create_objects_as_needed()</code> ont √©t√© propos√©es, car c'est ce que fait la fonction. </p><br><p>  Je n'ai pas aim√© ces options. </p><br><h2 id="primer-3-stdpartial_sort_copy">  Exemple 3: std :: partial_sort_copy () </h2><br><p>  <em>Exemple tir√© de <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">la pr√©sentation</a> de <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">Kate</a></em> </p><br><p>  Il existe une fonction <code>std::sort</code> , qui trie les √©l√©ments du conteneur: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(vec.begin(), vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, 4, 5}</span></span></code> </pre> <br><p>  Il y a aussi <code>std::partial_sort</code> , qui trie seulement une partie des √©l√©ments: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort(vec.begin(), vec.begin() + <span class="hljs-number"><span class="hljs-number">3</span></span>, vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, ?, ?} ( ...4,5,  ...5,4)</span></span></code> </pre> <br><p>  Et il y a toujours <code>std::partial_sort_copy</code> , qui trie √©galement une partie des √©l√©ments, mais en m√™me temps l'ancien conteneur ne change pas, mais transf√®re les valeurs au nouveau: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; out; out.resize(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort_copy(vec.begin(), vec.end(), out.begin(), out.end()); <span class="hljs-comment"><span class="hljs-comment">// out == {1, 2, 3}</span></span></code> </pre> <br><p>  Kate pr√©tend que <code>std::partial_sort_copy</code> est un nom moyen, et je suis d'accord avec elle. </p><br><h2 id="nazvanie-implementacii-i-nazvanie-rezultata">  Nom de l'impl√©mentation et nom du r√©sultat </h2><br><p>  Aucun des noms r√©pertori√©s n'est, √† proprement parler, <em>incorrect</em> : ils d√©crivent tous parfaitement ce que fait la fonction.  <code>std::log2p1()</code> compte vraiment le logarithme binaire et en ajoute un;  <code>implicitly_create_objects()</code> cr√©e implicitement des objets et <code>std::partial_sort_copy()</code> trie partiellement le conteneur et copie le r√©sultat.  Cependant, je n'aime pas tous ces noms, car ils sont <em>inutiles</em> . </p><br><p>  Aucun programmeur ne s'assoit et ne pense: ¬´J'aimerais pouvoir prendre le logarithme binaire et en ajouter un¬ª.  Il a besoin de savoir combien de bits la valeur donn√©e conviendra et il cherche sans succ√®s sur les docks quelque chose comme <code>bit_width</code> .  Au moment o√π il atteint l'utilisateur de la biblioth√®que, qu'est-ce que le logarithme binaire a √† voir avec cela, il a d√©j√† √©crit son impl√©mentation (et a probablement manqu√© la v√©rification de z√©ro).  M√™me si <code>std::log2p1</code> s'est av√©r√© √™tre un miracle dans le code, le prochain √† voir ce code devrait √† nouveau comprendre ce qu'il est et pourquoi il est n√©cessaire.  <code>bit_width(max_value)</code> n'aurait pas un tel probl√®me. </p><br><p>  De m√™me, personne n'a besoin de ¬´cr√©er implicitement des objets¬ª ou de ¬´trier partiellement la copie du vecteur¬ª - ils doivent r√©utiliser la m√©moire ou obtenir les 5 plus grandes valeurs dans l'ordre d√©croissant.  Quelque chose comme <code>recycle_storage()</code> (qui a √©galement √©t√© sugg√©r√© comme nom <code>std::bless</code> ) et <code>top_n_sorted()</code> serait beaucoup plus clair. </p><br><p>  Kate utilise le terme <em>nom d'impl√©mentation</em> pour <code>std::partial_sort_copy()</code> , mais il convient √©galement √† deux autres fonctions.  L'impl√©mentation de leur nom est vraiment parfaitement d√©crite.  C'est juste que l'utilisateur a besoin du nom du r√©sultat - ce qu'il obtient en appelant la fonction.  Pour sa structure interne, il s'en fiche, il veut juste conna√Ætre la taille en bits ou r√©utiliser la m√©moire. </p><br><p>  <strong>Nommer une fonction en fonction de sa sp√©cification signifie cr√©er √† l'improviste un malentendu entre le d√©veloppeur de la biblioth√®que et son utilisateur.</strong>  <strong>Vous devez toujours vous rappeler quand et comment la fonction sera utilis√©e.</strong> </p><br><p>  Cela semble ringard, oui.  Mais √† en juger par <code>std::log2p1()</code> , cela est loin d'√™tre √©vident pour tout le monde.  De plus, parfois ce n‚Äôest pas si simple. </p><br><h2 id="primer-4-stdpopcount">  Exemple 4: std :: popcount () </h2><br><p>  <code>std::popcount()</code> , comme <code>std::log2p1()</code> , en C ++ 20, il est propos√© d'ajouter √† <code>&lt;bit&gt;</code> .  Et cela, bien s√ªr, est un nom monstrueusement mauvais.  Si vous ne savez pas ce que fait cette fonction, il est impossible de le deviner.  Non seulement l'abr√©viation est d√©routante (il y a pop dans le nom, mais pop / push n'a rien √† voir avec cela) - d√©chiffrer le nombre de personnes (compter la population? Le nombre de populations?) N'aide pas non plus. </p><br><p>  D'un autre c√¥t√©, <code>std::popcount()</code> id√©al pour cette fonction car il appelle l'instruction d'assemblage popcount.  Ce n'est pas seulement le <em>nom de l'</em> impl√©mentation - c'est sa description compl√®te. </p><br><p>  Cependant, dans ce cas, l'√©cart entre les d√©veloppeurs de langues et les programmeurs n'est pas si grand.  Une instruction qui compte le nombre d'unit√©s dans un mot binaire est appel√©e un popcount des ann√©es soixante.  Pour une personne qui sait quoi que ce soit sur les op√©rations de bits, un tel nom est absolument √©vident. </p><br><p>  <em>Soit dit en passant, une bonne question: pensez-vous aux noms qui conviennent aux d√©butants, ou les laissez-vous familiers avec les anciens?</em> </p><br><h2 id="heppi-end">  Happy End? </h2><br><p>  <a href="https://wg21.link/P1956">P1956</a> sugg√®re de renommer <code>std::log2p1()</code> en <code>std::bit_width()</code> .  Cette proposition est susceptible d'√™tre accept√©e en C ++ 20.  <code>std::ceil2</code> et <code>std::floor2</code> seront √©galement renomm√©s respectivement std :: bit_ceil () et std :: bit_floor ().  Leurs anciens noms n'√©taient √©galement pas tr√®s, mais pour d'autres raisons. </p><br><p>  LEWG √† Cologne n'a s√©lectionn√© ni <code>implicitly_create_objects[_as_needed]</code> ni <code>recycle_storage</code> comme nom pour <code>std::bless</code> .  Ils ont d√©cid√© de ne pas du tout inclure cette fonction dans la norme.  Le m√™me effet peut √™tre obtenu en cr√©ant explicitement un tableau d'octets, donc, disent-ils, la fonction n'est pas n√©cessaire.  Je n'aime pas cela car appeler <code>std::recycle_storage()</code> serait plus lisible.  Un autre <code>std::bless()</code> existe toujours, mais est maintenant appel√© <code>start_lifetime_as</code> .  J'aime √ßa.  Il devrait aller en C ++ 23. </p><br><p>  Bien s√ªr, <code>std::partial_sort_copy()</code> ne <code>std::partial_sort_copy()</code> plus renomm√© - sous ce nom, il est entr√© dans la norme en 1998. Mais au moins <code>std::log2p1</code> corrig√©, et ce n'est pas mal. </p><br><p>  Pour trouver les noms des fonctions, vous devez penser √† qui les utilisera et √† ce qu'il attend d'eux.  Comme l'a dit Kate, la <strong>d√©nomination n√©cessite de l'empathie</strong> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484860/">https://habr.com/ru/post/fr484860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484836/index.html">Calcul de la rentabilit√© du tarif vert en 2020, Ukraine</a></li>
<li><a href="../fr484838/index.html">13 exemples de configuration de r√®gles dans Google Ads [instruction]</a></li>
<li><a href="../fr484840/index.html">Retour GOTO</a></li>
<li><a href="../fr484846/index.html">Ma relation avec l'open source</a></li>
<li><a href="../fr484854/index.html">Ex√©cutez le jeu en C # sur MS-DOS</a></li>
<li><a href="../fr484862/index.html">Migration d'AngularJS vers Angular7 via une application hybride</a></li>
<li><a href="../fr484866/index.html">Utilisation d'Astra Linux sur un ordinateur embarqu√© ARM</a></li>
<li><a href="../fr484868/index.html">Comment mesurer l'am√©lioration de l'√©quipe? 2e partie</a></li>
<li><a href="../fr484870/index.html">Comment les Anglais ont chang√© Ilona Mask depuis 20 ans</a></li>
<li><a href="../fr484874/index.html">"Votre sp√©cialiste informatique est cass√©, apportez-en un nouveau": comment construire une carri√®re en informatique et ne pas devenir fou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>