<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏾 🧜🏽 💃🏻 Pós e pré-processamento de CSS 🤛🏻 🎤 👨🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá leitor. No seu caminho para aprender layouts, você aprendeu CSS e deseja seguir em frente? Então para você sob gato. Cuidado, muito código. 

 Nes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pós e pré-processamento de CSS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434098/">  Olá leitor.  No seu caminho para aprender layouts, você aprendeu CSS e deseja seguir em frente?  Então para você sob gato.  Cuidado, muito código. <a name="habracut"></a><br><br>  Neste artigo, revisarei pré-processadores e pós-processadores. <br><br>  Não entrarei em detalhes sobre CSS, o que implica que você já o conhece.  Vou nomear classes na notação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BEM</a> .  Além disso, não vou me aprofundar na instalação e configuração de tudo o que escrevo, mas mesmo assim deixarei links que você pode seguir e aprender como fazê-lo. <br><br>  Vamos começar com os pré-processadores. <br><br><h2>  Pré-processadores </h2><br>  O que é um pré-processador fora de contexto com CSS?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vicki</a> sabe a resposta. <br><br>  O que é um pré-processador no contexto do CSS?  No nosso caso, o pré-processador é um programa que recebe o código escrito na linguagem do pré-processador para entrada e, na saída, obtemos CSS que podemos fornecer ao nosso navegador. <br><br>  Quais são os pré-processadores?  Existem vários representantes, por exemplo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sass</a> (.sass, .scss), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Less</a> (.less) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Stylys</a> (.stylus). <br>  Também entre os pré-processadores, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PostCSS</a> (ou melhor, seu analisador SugarSS e o plugin PreCSS) podem ser destacados separadamente.  Olhando para o futuro, direi que sim, o PostCSS não é apenas um pós-processador. <br><br>  Vou fazer uma revisão no exemplo do Sass.  Mais precisamente, em sua nova sintaxe - SCSS, pois está mais próxima do CSS do que a antiga sintaxe.  Vamos começar com os recursos adicionados pelos pré-processadores que não estão em CSS e terminar com os problemas que estão sendo resolvidos. <br><br><h3>  As possibilidades </h3><br><h4>  Variáveis </h4><br><pre><code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#fff</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: $color; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: $color; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; }</code> </pre> <br>  É difícil superestimar a utilidade das variáveis.  Agora você pode dar nomes significativos às cores ($ tomato: rgb (255,99,71)), calcular valores não através de constantes, mas através de variáveis ​​(height: $ body_height - $ footer_height) e muito mais.  Muitos podem argumentar que existem variáveis ​​no CSS.  Mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Can I Use</a> diz que não há suporte para o IE (e por razões óbvias, isso não é esperado). <br><br><h4>  Aninhamento </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">40%</span></span>; &amp;__button { // &amp; -    (   &amp; = .chat-area) <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: inline-block; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>:<span class="hljs-number"><span class="hljs-number">36px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">40%</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area__button</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: inline-block; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>:<span class="hljs-number"><span class="hljs-number">36px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  No começo do artigo, me referi ao BEM.  Neste exemplo, o elemento com a classe da área de bate-papo é um bloco.  Caso haja uma necessidade súbita de renomeá-lo, agora será possível fazê-lo em um só lugar, e isso se tornará uma rotina se várias dezenas de seletores forem digitados em um arquivo que contenha o nome do bloco.  Também quero observar que esse é um tipo de proteção contra erros de digitação, porque o nome do bloco é escrito uma vez. <br><br><h4>  Mixins </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">mixin</span></span> border-radius($radius) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">-webkit-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-moz-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ms-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { @include border-radius(10px); } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-webkit-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-moz-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-ms-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre><br>  Mixins são um dos tópicos mais difíceis de entender.  Grosso modo, um mixin é uma função que recebe argumentos e aplica regras que dependem desses argumentos para um determinado seletor.  Neste exemplo, a mixin de raio da borda foi aplicada ao seletor .box <br><br><h4>  Funções adicionais </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#202020</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">h1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">h2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">lighten</span></span>($color, 40%); } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">h1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">h2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#868686</span></span>; }</code> </pre><br>  Basicamente, novos recursos facilitam o trabalho com cores.  Por exemplo, a função clarear - ilumina a cor pelo número especificado de porcentagem (o oposto é a função escurecer). <br><br><h3>  Problemas resolvidos </h3><br><h4>  Modularidade </h4><br>  O problema com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">importação</a> padrão é que ele cria uma solicitação adicional para o servidor, o que é uma operação cara.  Seria bom se a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">importação</a> inserisse imediatamente todo o texto da importação no arquivo de origem, certo? <br><br>  De uma forma ou de outra, não havia pré-processadores antes e o problema tinha que ser resolvido de alguma forma.  Por exemplo, você pode escrever todo o código em um arquivo. <br><br><div class="spoiler">  <b class="spoiler_title">Como é isso?</b> <div class="spoiler_text"><pre> <code class="css hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Como realmente se parece</b> <div class="spoiler_text"><pre> <code class="css hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  -  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span></code> </pre><br></div></div><br></div></div><br>  No entanto, temos pré-processadores e eles resolverão esse problema para nós.  O pré-processador substitui a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">importação</a> padrão e agora, em vez de solicitar o servidor, insere a importação no arquivo de origem, da maneira que eu queria. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"selector1"</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"selector2"</span></span>; //<span class="hljs-selector-tag"><span class="hljs-selector-tag">selector1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">selector2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; }</code> </pre><br>  Observe que os arquivos de origem foram convertidos em um.  Uma solicitação ao servidor para estática - uma resposta. <br><br><h4>  Herança </h4><br>  &lt;sarcasm&gt; Temos classes, mas nenhuma herança, como? &lt;/sarcasm&gt;.  Agora é possível selecionar os chamados "seletores de modelo" e expandi-los com outros seletores. <br><br><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">equal-heights</span></span> { //   <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; } %<span class="hljs-selector-tag"><span class="hljs-selector-tag">message</span></span> { //   <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span> { @extend %message; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { @extend %message; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } // <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span>, <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  A beleza dos seletores de modelo é que eles não se encaixam nos estilos gerados.  O equalizador do modelo% equal-heights não estava envolvido no código e não deixou rastros no CSS.  A mensagem do seletor% foi refletida na forma de regras para os seletores que a expandiram.  Você pode herdar de seletores comuns, mas é preferível usar seletores de modelo para que não haja excesso de lixo. <br><br><h4>  Formatação </h4><br>  Depois que o código é gravado, ele precisa ser formatado (compactado para produção).  Você pode fazer isso com a ajuda de colecionadores como o webpack ou através de ferramentas padrão. <br><br>  Existem 4 tipos de formatação no Sass. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">expanded</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">nested</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">compact</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">compressed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:gold;<span class="hljs-attribute"><span class="hljs-attribute">display</span></span>:block}<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:red}</code> </pre><br>  expandido - Mais semelhante ao código escrito por humanos. <br>  aninhado - Aproximado ao formato da sintaxe antiga.  A legibilidade não está perdida, mas é uma questão de hollywood. <br>  compacto - ainda mantém a legibilidade, mas com dificuldade.  Útil para determinar o número de seletores em um projeto a olho nu. <br>  compactado - formato já completamente ilegível.  Todos os caracteres que podem ser excluídos são excluídos.  Adequado para alimentar o navegador. <br><br><h3>  Postscript </h3><br>  Não entendi alguns dos recursos adicionados por Sass.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">loops</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recursos de operadores aritméticos</a> .  Vou deixá-los para você se familiarizar. <br><br><h2>  Pós-processadores </h2><br>  Depois de lidar com os pré-processadores, passamos para os pós-processadores. <br><br>  No contexto de Css, o pós-processador é essencialmente o mesmo que o pré-processador, mas a entrada no pós-processador não recebe código escrito no idioma do pré-processador, mas também css.  Ou seja, o pós-processador é um programa na entrada do qual css é fornecido e a saída é css.  Não está muito claro por que isso é necessário. <br><br>  Vou explicar um exemplo concreto da operação do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PostCSS</a> - o único representante dos pós-processadores no contexto do css. <br><br>  O PostCSS pronto para uso não faz nada com CSS.  Ele simplesmente retorna o arquivo que foi fornecido na entrada.  As alterações começam quando os plug-ins são conectados ao PostCSS. <br><br>  Todo o ciclo do PostCSS pode ser descrito da seguinte maneira: <br><br><ul><li>  O arquivo de origem é fornecido à entrada PostCSS e analisado. </li><li>  O plug-in 1 faz alguma coisa </li><li>  ... </li><li>  Plugin n faz alguma coisa </li><li>  O resultado é convertido em uma sequência e gravado no arquivo de saída. </li></ul><br>  Considere os principais plugins existentes no ecossistema PostCSS <br><br><h3>  Plugins </h3><br><h4>  Autoprefixer </h4><br>  Este plugin é tão popular que muitas pessoas pensam que usam esse plugin, mas não usam PostCSS.  Eles estão errados. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -webkit-box; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -webkit-flex; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -moz-box; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -ms-flexbox; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O autoprefixer</a> adiciona prefixos de navegador às suas regras.  Um dos plugins mais importantes que iniciaram a história do PostCSS sem nada substituível.  Você pode até dizer que faz sentido colocar o PostCss apenas por causa deste plugin. <br><br><h2>  Ambiente predefinido </h2><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">custom</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> --med (width &lt;= <span class="hljs-number"><span class="hljs-number">50rem</span></span>); @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (--med) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">color-mod</span></span>(black alpha(54%)); } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (max-width: <span class="hljs-number"><span class="hljs-number">50rem</span></span>) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgba</span></span>(0, 0, 0, 0.54); } }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O PostCSS Preset Env</a> adiciona recursos que são discutidos apenas nos rascunhos dos desenvolvedores de CSS.  Neste exemplo, a diretiva @ custom-media foi implementada, bem como a função color-mod.  Comece a usar o CSS do futuro hoje! <br><br><h4>  Módulos CSS </h4><br>  Todos esses BEMs não são para você, mas ainda há um problema com conflitos de nome de classe?  Então o PostCSS oferece uma solução diferente. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.name</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gray; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.Logo__name__SVK0g</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gray; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Módulos CSS</a> alteram os nomes das classes de acordo com um determinado padrão (tudo é personalizável).  Agora não sabemos antecipadamente o nome da classe, porque é determinado dinamicamente.  Como agora classificar elementos se não os conhecemos com antecedência?  Combinando PostCSS, Webpack e ES6, posso oferecer esta solução: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./style.css'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  import styles from './style.css'; // </span></span></code> </pre><br>  Agora, não estamos apenas importando um arquivo com estilos (por exemplo, no arquivo React do componente) e substituindo os valores que conhecíamos antes, mas importando um objeto.  As chaves deste objeto serão os seletores originais e os valores serão convertidos.  Ou seja, neste exemplo, styles ['name'] = 'Logo__name__SVK0g'. <br><br><h4>  Curto </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">size</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.canvas</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#abccfc</span></span> <span class="hljs-number"><span class="hljs-number">#212231</span></span>; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.canvas</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#abccfc</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: <span class="hljs-number"><span class="hljs-number">#212231</span></span>; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O PostCSS Short</a> adiciona várias entradas reduzidas para várias regras.  O código está ficando mais curto e, portanto, há menos espaço para erros.  Além disso, aumenta a legibilidade. <br><br><h4>  Reinicialização automática </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">all</span></span>: initial; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A Redefinição Automática do PostCSS</a> nos permite não criar um arquivo separado com uma redefinição de todos os estilos.  O plug-in cria um seletor grande para todos os seletores, onde ele coloca as regras, redefinindo todos os estilos.  Por padrão, apenas a regra all é criada com o valor inicial.  Isso é útil em combinação com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postcss-initial</a> , que por sua vez transforma essa regra em um conjunto de regras para 4 telas.  No entanto, tudo pode ser configurado e redefinido, por exemplo, assim: <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre><br>  Lembre-se, no início do artigo, eu disse que o PostCSS não é apenas um pós-processador? <br><br><h3>  PostCSS - pré-processador? </h3><br>  Considere um analisador e um plug-in, após o qual você mudará sua opinião atual sobre o PostCSS. <br><br><h4>  Sugararss </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sss</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">white</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> &gt; <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white } <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> &gt; <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O SugarSS</a> é um analisador (não um plugin!), Que é baseado em <u>recuo</u> , e não em chaves, como padrão.  Possui uma extensão separada ".sss".  O código escrito usando SugarSS é semelhante em estilo à sintaxe antiga do Sass, mas sem loções como variáveis, mixins, herança etc. <br><br>  Você adivinhou o que o próximo plugin adicionará? <br><br><h4>  Precss </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span> //  <span class="hljs-selector-tag"><span class="hljs-selector-tag">SugarSS</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { .child { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: $color } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O PreCSS</a> apenas adiciona os recursos dos pré-processadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descritos</a> na primeira metade do artigo. <br><br>  E por que o PostCSS não é um pré-processador agora? <br><br><h3>  Stylelint </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Muito</a> já foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrito</a> sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Stylelint</a> .  Ele entrou nessa revisão porque usa o PostCSS como um analisador de linhas de arquivos CSS.  Suponha que tenhamos esse arquivo. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>(1, 1, 1) } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>(0, 0, 0) }</code> </pre><br>  Aqui está sua saída para o arquivo atual: <br><br><pre> <code class="plaintext hljs"> 2:21 Expected a trailing semicolon declaration-block-trailing-semicolon 6:21 Expected a trailing semicolon declaration-block-trailing-semicolon 7:1 Unexpected missing end-of-source newline no-missing-end-of-source-newline</code> </pre><br>  A utilidade dessa ferramenta é bastante difícil de superestimar. <br><br><h2>  Conclusões </h2><br>  Os pré-processadores adicionam muitas novas funcionalidades que não estão no CSS.  Depois de experimentar, você dificilmente retornará ao CSS comum. <br><br>  O PostCSS está muito mais próximo do CSS original do que os pré-processadores, mas, no entanto, com certos plugins conectados, ele pode ter a mesma funcionalidade (e até sintaxe semelhante).  Os tipógrafos iniciantes podem escrever sem nem pensar que os layouts não estão em CSS puro.  Alguns plugins (por exemplo, Autoprefixer) não possuem análogos no mundo do pré-processador. <br><br>  Ninguém se incomoda em usar pré-processadores e PostCSS em conjunto.  A opção é muito boa para projetos que já usam pré-processadores e têm um local de moradia. <br><br>  Para novos projetos, eu recomendaria usar apenas PostCSS.  Os designers de layout são usados ​​para pré-processar a sintaxe?  Instale o plug-in PreCSS e o analisador SugarSS.  Precisa de compatibilidade entre navegadores?  Instale o plug-in Autoprefixer.  A compatibilidade entre navegadores não é mais necessária (por exemplo, seu projeto foi envolto em elétron e tornou-se desktop)?  Basta desinstalar o Autoprefixer!  Com o PostCSS, você pode, assim como o construtor, criar exatamente o que seu projeto precisa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434098/">https://habr.com/ru/post/pt434098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434086/index.html">Implantação Incorporada do Windows e Linux</a></li>
<li><a href="../pt434088/index.html">Como ajudar funcionários remotos a evitar a solidão e o cansaço</a></li>
<li><a href="../pt434090/index.html">Introduzindo um transistor a vácuo: um dispositivo fabricado a partir do vácuo</a></li>
<li><a href="../pt434092/index.html">As pessoas que salvaram 1968</a></li>
<li><a href="../pt434096/index.html">Heisenbug 2018 Moscou: uma visão da multidão</a></li>
<li><a href="../pt434100/index.html">Visão geral das impressoras 3D Anet A6 e Anet A8</a></li>
<li><a href="../pt434102/index.html">Animação bonita e informativa: casos de movimento circular e vibrações</a></li>
<li><a href="../pt434104/index.html">Terra VHF ou desmistificação de antenas de quadrado duplo / triplo</a></li>
<li><a href="../pt434106/index.html">Confie nos SDKs para celular</a></li>
<li><a href="../pt434110/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 344 (17 a 23 de dezembro de 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>