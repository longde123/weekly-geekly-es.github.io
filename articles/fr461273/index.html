<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏽 ⬇️ 💎 Approche gourmande et machines à sous. Analyse des tâches de la piste ML du championnat de programmation 🧝🏽 🆑 🎀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons à publier des analyses des tâches qui ont été proposées lors du récent championnat. Viennent ensuite les tâches issues du cycle de qua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Approche gourmande et machines à sous. Analyse des tâches de la piste ML du championnat de programmation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/461273/"><img src="https://habrastorage.org/webt/sd/i7/yd/sdi7ydyv5yabtpudjamnnmm2dge.jpeg"><br><br>  Nous continuons à publier des analyses des tâches qui ont été proposées lors du récent championnat.  Viennent ensuite les tâches issues du cycle de qualification pour les spécialistes de l'apprentissage automatique.  Il s'agit de la troisième piste sur quatre (backend, frontend, ML, analytics).  Les participants devaient créer un modèle pour corriger les fautes de frappe dans les textes, proposer une stratégie pour jouer sur les machines à sous, évoquer un système de recommandations de contenu et composer plusieurs autres programmes. <br><br><a name="habracut"></a><h2>  A. Typos </h2><br><h4>  Condition </h4><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Toutes les langues</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  Limite de temps </td><td>  1 s </td><td>  5 s </td><td>  5 s </td></tr><tr><td>  Limite de mémoire </td><td>  64 Mo </td><td>  256 Mo </td><td>  256 Mo </td></tr><tr><td>  Entrer </td><td colspan="3">  entrée standard ou input.txt </td></tr><tr><td>  Conclusion </td><td colspan="3">  sortie standard ou output.txt </td></tr></tbody></table></div>  (épigraphe) (d'un forum) <br>  - Qui a composé ce non-sens? <br>  - Astrophysiciens.  Ce sont aussi des gens. <br>  - Vous avez fait 10 erreurs dans le mot «journalistes». <br><br>  De nombreux utilisateurs font des fautes de frappe, certaines à cause de la frappe des touches et d'autres à cause de leur analphabétisme.  Nous voulons vérifier si l'utilisateur pourrait réellement avoir à l'esprit un autre mot que celui qu'il a tapé. <br><br>  Plus formellement, supposons que le modèle d'erreur suivant se produise: l'utilisateur commence par un mot qu'il veut écrire, puis y fait ensuite un certain nombre d'erreurs.  Chaque erreur est une substitution d'une sous-chaîne du mot pour une autre sous-chaîne.  Une erreur correspond au remplacement d'une seule position (c'est-à-dire que si l'utilisateur veut faire une seule erreur par la règle "abc" → "cba", alors à partir de la chaîne "abcabc" il peut obtenir soit "cbaabc" ou "abccba").  Après chaque erreur, le processus se répète.  La même règle peut être utilisée plusieurs fois à différentes étapes (par exemple, dans l'exemple ci-dessus, «cbacba» peut être obtenu en deux étapes). <br><br>  Il est nécessaire de déterminer le nombre minimum d'erreurs qu'un utilisateur pourrait commettre s'il avait en tête un mot donné et en écrivait un autre. <br><br><div class="spoiler">  <b class="spoiler_title">Formats d'E / S et exemple</b> <div class="spoiler_text"><h4>  Format d'entrée </h4><br>  La première ligne contient le mot que, selon notre hypothèse, l'utilisateur avait en tête (il est composé de lettres de l'alphabet latin en minuscules, la longueur ne dépasse pas 20). <br><br>  La deuxième ligne contient le mot qu'il a effectivement écrit (il se compose également de lettres de l'alphabet latin en minuscules, la longueur ne dépasse pas 20). <br><br>  La troisième ligne contient un seul nombre N (N &lt;50) - le nombre de remplacements qui décrivent diverses erreurs. <br><br>  Les N lignes suivantes contiennent des remplacements possibles au format &amp; lt séquence de lettres "correcte" &amp; gt &lt;space&gt; &lt;séquence de lettres "erronée"&gt;.  Les séquences ne comportent pas plus de 6 caractères. <br><br><h4>  Format de sortie </h4><br>  Il est nécessaire d'imprimer un numéro - le nombre minimum d'erreurs que l'utilisateur pourrait commettre.  Si ce nombre dépasse 4 ou s'il est impossible d'en obtenir un autre à partir d'un mot, imprimez -1. <br><br><h4>  Exemple </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrer</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td><code>mlax <br> drum <br> 50 <br> lr <br> mlax gtwt <br> md <br> mlax ujoc <br> ml pq <br> mf <br> ml bf <br> mlax aruq <br> mlax nqdd <br> mlax fglm <br> mlax bfit <br> mlax mziq <br> mla hlb <br> au <br> mlax vmpa <br> mw <br> aw <br> ax ok <br> mla kqf <br> me <br> xx <br> ml if <br> ml gk <br> le <br> mla xrh <br> mj <br> ac <br> ab <br> mq <br> ax fr <br> ml sb <br> mlax gxxx <br> xm <br> mlax hczx <br> lq <br> la sv <br> lg <br> ax eh <br> lax mjh <br> la ec <br> la pv <br> ml iq <br> aq <br> lax jrs <br> la qn <br> lax bjo <br> lo <br> az <br> ln <br> ac</code> </td> <td> <code>4</code> </td> </tr></tbody></table></div></div></div><br><h4>  Solution </h4><br>  Essayons de générer à partir de l'orthographe correcte tous les mots possibles avec pas plus de 4 erreurs.  Dans le pire des cas, il peut y avoir O ((L﹒N) <sup>4</sup> ).  Dans les limites du problème, il s'agit d'un nombre assez important, vous devez donc comprendre comment réduire la complexité.  Au lieu de cela, vous pouvez utiliser l'algorithme de rencontre au milieu: générer des mots avec pas plus de 2 erreurs, ainsi que des mots à partir desquels vous pouvez obtenir un mot écrit par l'utilisateur avec pas plus de 2 erreurs.  Notez que la taille de chacun de ces ensembles ne dépassera pas 10 <sup>6</sup> .  Si le nombre d'erreurs commises par l'utilisateur ne dépasse pas 4, ces ensembles se recouperont.  De même, nous pouvons vérifier que le nombre d'erreurs ne dépasse pas 3, 2 et 1. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FromTo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> to; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; applyRule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; word, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FromTo &amp;fromTo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> from = word.find(fromTo.from, pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos, {}}; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to = from + fromTo.from.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cpy = word; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { cpy[i] = fromTo.to[i - from]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {from, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cpy)}; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inverseRules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt; &amp;rules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; rule: rules) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(rule.from, rule.to); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordOrig, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordMissprinted, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt;&amp; replaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mapping; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; mappingInverse; mapping.emplace(wordOrig, <span class="hljs-number"><span class="hljs-number">0</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, wordOrig); mapping.emplace(wordMissprinted, <span class="hljs-number"><span class="hljs-number">1</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">1</span></span>, wordMissprinted); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; edges; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buildGraph = [&amp;edges, &amp;mapping, &amp;mappingInverse](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startId, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;FromTo&gt;&amp; replaces, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dir) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer0; mappingLayer0 = {startId}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: mappingLayer0) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; word = mappingInverse.at(v); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; fromTo: replaces) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> from = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [tmp, wordCpy] = applyRule(word, fromTo, from); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmp == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } from = tmp + <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = mapping.size(); mapping.emplace(wordCpy, w); w = mapping.at(wordCpy); mappingInverse.emplace(w, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(wordCpy)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dir) { edges[v].emplace(w); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { edges[w].emplace(v); } mappingLayer1.emplace(w); } } } } mappingLayer0 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mappingLayer1); } }; buildGraph(<span class="hljs-number"><span class="hljs-number">0</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); inverseRules(replaces); buildGraph(<span class="hljs-number"><span class="hljs-number">1</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; q; q.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; mask(mapping.size(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> level{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (q.size()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [w, level] = q.front(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[w]) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } mask[w] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mappingInverse.at(w) == wordMissprinted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: edges[w]) { q.emplace(v, level + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><h2>  Bandit armé de plusieurs armes </h2><br><h4>  Condition </h4><div class="scrollable-table"><table><tbody><tr><td>  Limite de temps </td><td>  2 s </td></tr><tr><td>  Limite de mémoire </td><td>  64 Mo </td></tr><tr><td>  Entrer </td><td>  entrée standard </td></tr><tr><td>  Conclusion </td><td>  sortie standard </td></tr></tbody></table></div>  Il s'agit d'une tâche interactive. <br><br>  Vous ne savez pas comment cela s'est passé, mais vous vous êtes retrouvé dans une salle avec des machines à sous avec un sac entier de jetons.  Malheureusement, au box-office, ils refusent d'accepter les jetons et vous avez décidé de tenter votre chance.  Il y a beaucoup de machines à sous dans la salle que vous pouvez jouer.  Pour un jeu avec une machine à sous, vous utilisez un jeton.  En cas de victoire, la machine vous donne un dollar, en cas de perte - rien.  Chaque machine a une probabilité fixe de gagner (que vous ne connaissez pas), mais elle est différente pour différentes machines.  Après avoir étudié le site Web du fabricant de ces machines, vous avez découvert que la probabilité de gagner pour chaque machine est sélectionnée au hasard au stade de la fabrication à partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">distribution bêta</a> avec certains paramètres. <br><br>  Vous souhaitez maximiser vos gains attendus. <br><br><div class="spoiler">  <b class="spoiler_title">Formats d'E / S et exemple</b> <div class="spoiler_text"><h4>  Format d'entrée </h4><br>  Une exécution peut consister en plusieurs tests. <br><br>  Chaque test commence par le fait que votre programme sur la ligne contient deux entiers séparés par un espace: le nombre N est le nombre de jetons dans votre sac, et M est le nombre de machines dans le hall (N ≤ 10 <sup>4</sup> , M ≤ min (N, 100) )  La ligne suivante contient deux nombres réels α et β (1 ≤ α, β ≤ 10) - les paramètres de la distribution bêta de la probabilité de gagner. <br><br>  Le protocole de communication avec le système de contrôle est le suivant: vous faites exactement N requêtes.  Pour chaque demande, imprimez sur une ligne séparée le numéro de la machine que vous jouerez (de 1 à M inclus).  En réponse, sur une ligne séparée, il y aura soit «0» soit «1», ce qui signifie respectivement une défaite et une victoire dans un jeu avec la machine à sous demandée. <br><br>  Après le dernier test, au lieu des nombres N et M, il y aura deux zéros. <br><br><h4>  Format de sortie </h4><br>  La tâche sera considérée comme terminée si votre décision n'est pas bien pire que la décision du jury.  Si votre décision est nettement pire que la décision du jury, vous recevrez le verdict «mauvaise réponse». <br><br>  Il est garanti que si votre décision n'est pas pire que la décision du jury, alors la probabilité de recevoir le verdict «mauvaise réponse» ne dépasse pas <sup>10-6</sup> . <br><br><h4>  Remarques </h4><br>  Exemple d'interaction: <br><br><pre> <code class="cpp hljs">____________________  <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>     <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> ____________________ ____________________   <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </div></div><br><h4>  Solution </h4><br>  Ce problème est bien connu, il pourrait être résolu de différentes manières.  La décision principale du jury a mis en œuvre la stratégie d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">échantillonnage de Thompson</a> , mais comme le nombre d'étapes était connu au début du programme, il existe des stratégies plus optimales (par exemple, UCB1).  De plus, on pourrait même s'en sortir avec la stratégie epsilon-greedy: avec une certaine probabilité ε jouer une machine aléatoire et avec une probabilité (1 - ε) jouer une machine avec les meilleures statistiques de victoire. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SolverFromStdIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.regrets = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.total_win = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.moves = [] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThompsonSampling</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SolverFromStdIn)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, bandits_total, init_a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, init_b=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" init_a (int): initial value of a in Beta(a, b). init_b (int): initial value of b in Beta(a, b). """</span></span> SolverFromStdIn.__init__(self) self.n = bandits_total self.alpha = init_a self.beta = init_b self._as = [init_a] * self.n <span class="hljs-comment"><span class="hljs-comment"># [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self._bs = [init_b] * self.n # [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self.last_move = -1 random.seed(int(time.time())) def move(self): samples = [random.betavariate(self._as[x], self._bs[x]) for x in range(self.n)] self.last_move = max(range(self.n), key=lambda x: samples[x]) self.moves.append(self.last_move) return self.last_move def set_reward(self, reward): i = self.last_move r = reward self._as[i] += r self._bs[i] += (1 - r) return i, r while True: n, m = map(int, sys.stdin.readline().split()) if n == 0 and m == 0: break alpha, beta = map(float, sys.stdin.readline().split()) solver = ThompsonSampling(m) for _ in range(n): print &gt;&gt; sys.stdout, solver.move() + 1 sys.stdout.flush() reward = int(sys.stdin.readline()) solver.set_reward(reward)</span></span></code> </pre> <br><h2>  C. Alignement des peines </h2><br><h4>  Condition </h4><div class="scrollable-table"><table><tbody><tr><td>  Limite de temps </td><td>  2 s </td></tr><tr><td>  Limite de mémoire </td><td>  64 Mo </td></tr><tr><td>  Entrer </td><td>  entrée standard ou input.txt </td></tr><tr><td>  Conclusion </td><td>  sortie standard ou output.txt </td></tr></tbody></table></div>  L'une des tâches les plus importantes pour former un bon modèle de traduction automatique est un bon cas de phrases parallèles.  En règle générale, la source des offres parallèles est constituée de documents parallèles.  Il s'avère que souvent pour construire un certain corpus de phrases parallèles, il n'est pas nécessaire de connaître autre chose que leur longueur.  En particulier, vous remarquerez peut-être que plus la phrase est longue dans la langue source, plus elle sera traduite longtemps.  Une certaine difficulté réside dans le fait que pendant la traduction, le nombre de phrases dans le texte peut changer: parfois deux phrases adjacentes dans la traduction peuvent être combinées en une seule, ou vice versa - une phrase peut être divisée en deux.  Dans certains cas rares, des phrases peuvent être entièrement omises dans une traduction, ou une traduction peut apparaître dans une traduction qui n'était pas dans l'original. <br><br>  Plus formellement, supposons que le modèle génératif suivant pour les enceintes parallèles soit vrai.  À chaque étape, nous effectuons l'une des opérations suivantes: <br><br>  <b>1. <i>Arrêtez</i></b> <br><br>  Avec la probabilité p <sub>h, la</sub> génération des coques se termine. <br><br>  <b>2. [1-0] <i>Ignorer les offres</i></b> <br><br>  Avec la probabilité p <sub>d, nous</sub> attribuons une phrase au texte original.  Nous n'attribuons rien à la traduction.  La longueur de la phrase dans la langue d'origine L ≥ 1 est choisie dans la distribution discrète: <br><br><img src="https://habrastorage.org/webt/bm/pe/t_/bmpet_y_ksvwgbohazpgctekbks.png" width="350">  . <br><br>  Ici <i>μ <sub>s</sub></i> , <i>σ <sub>s</sub></i> sont les paramètres de distribution, et <i>α <sub>s</sub></i> est le coefficient de normalisation choisi pour que <img src="https://habrastorage.org/webt/fm/ae/ns/fmaensnvy1nauvywiluibhryr6s.png" width="100">  . <br><br>  <b>3. [0-1] <i>Insérer une proposition</i></b> <br><br>  Avec la probabilité p <sub>i nous</sub> attribuons une phrase à la traduction.  Nous n'attribuons rien à l'original.  La longueur d'une phrase dans une langue de traduction L ≥ 1 est choisie dans une distribution discrète: <br><br><img src="https://habrastorage.org/webt/yl/yn/kr/ylynkr3cs_t7dpedebtzqj3uryk.png" width="350">  . <br><br>  Ici <i>μ <sub>t</sub></i> , <i>σ <sub>t</sub></i> sont les paramètres de distribution, et <i>α <sub>t</sub></i> est le coefficient de normalisation choisi pour que <img src="https://habrastorage.org/webt/bq/-k/p3/bq-kp37k-c-k5fpq9jrz4r8rkvy.png" width="100">  . <br><br>  <b>4. <i>Traduction</i></b> <br><br>  Avec la probabilité (1 - p <sub>d</sub> - p <sub>i</sub> - p <sub>h</sub> ) on prend la longueur de la phrase dans la langue d'origine L <sub>s</sub> ≥ 1 de la distribution p <sub>s</sub> (avec arrondi).  Ensuite, nous générons la longueur de la phrase dans la langue de traduction L <sub>t</sub> ≥ 1 à partir de la distribution discrète conditionnelle: <br><br><img src="https://habrastorage.org/webt/ae/b6/mx/aeb6mx4cols1jplbs-di9emhxf8.png" width="500">  . <br><br>  Ici, <i>α <sub>st</sub></i> est le coefficient de normalisation, et les paramètres restants sont décrits dans les paragraphes précédents. <br><br>  La prochaine étape est une autre: <br><br>  1. [2-1] Avec la probabilité p <sub>divisé s, la</sub> phrase générée dans la langue d'origine se divise en deux phrases non vides, de sorte que le nombre total de mots <b><i>augmente exactement d'un</i></b> .  La probabilité qu'une phrase de longueur L <sub>s se</sub> décompose en parties de longueur L <sub>1</sub> et L <sub>2</sub> (c'est-à-dire L <sub>1</sub> + L <sub>2</sub> = L <sub>s</sub> + 1) est proportionnelle à P <sub>s</sub> (L <sub>1</sub> ) ⋅ P <sub>s</sub> (L <sub>2</sub> ). <br><br>  2. [1-2] Avec la probabilité p <sub>divisée t, la</sub> phrase générée dans la langue cible se divise en deux phrases non vides, de sorte que le nombre total de mots augmente d'exactement une.  La probabilité qu'une phrase de longueur L <sub>t se</sub> désagrège en parties de longueur L1 et L2 (c'est-à-dire L <sub>1</sub> + L <sub>2</sub> = L <sub>t</sub> + 1) est proportionnelle à P <sub>t</sub> (L <sub>1</sub> ) ⋅ P <sub>t</sub> (L <sub>2</sub> ). <br><br>  3. 3. [1-1] Avec une probabilité de (1 - p <sub>split s</sub> - p <sub>split t</sub> ), aucune des deux phrases générées ne se désintègre. <br><br><div class="spoiler">  <b class="spoiler_title">Formats d'E / S, exemples et notes</b> <div class="spoiler_text"><h4>  Format d'entrée </h4><br>  La première ligne du fichier contient les paramètres de distribution: p <sub>h</sub> , p <sub>d</sub> , p <sub>i</sub> , p <sub>split s</sub> , p <sub>split t</sub> , μ <sub>s</sub> , σ <sub>s</sub> , μ <sub>t</sub> , σ <sub>t</sub> .  0,1 ≤ σ <sub>s</sub> &lt;σ <sub>t</sub> ≤ 3. 0 ≤ μ <sub>s</sub> , μ <sub>t</sub> ≤ 5. <br><br>  La ligne suivante contient les nombres N <sub>s</sub> et N <sub>t</sub> - le nombre de phrases dans le cas dans la langue d'origine et dans la langue cible, respectivement (1 ≤ N <sub>s</sub> , N <sub>t</sub> ≤ 1000). <br><br>  La ligne suivante contient N <sub>s</sub> entiers - la longueur des phrases dans la langue d'origine.  La ligne suivante contient N <sub>t</sub> entiers - la longueur des phrases dans la langue cible. <br><br>  La ligne suivante contient deux nombres: j et k (1 ≤ j ≤ N <sub>s</sub> , 1 ≤ k ≤ N <sub>t</sub> ). <br><br><h4>  Format de sortie </h4><br>  Il est nécessaire de dériver la probabilité que les phrases d'indices j et k dans les textes, respectivement, soient parallèles (c'est-à-dire qu'elles sont générées à une étape de l'algorithme et qu'aucune d'entre elles n'est le résultat de la décroissance). <br><br>  Votre réponse sera acceptée si l'erreur absolue ne dépasse pas 10 <sup>–4</sup> . <br><br><h4>  Exemple 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrer</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>0.05 0.08 0.07 0.15 0.1 1 0.3 3 0.5 <br> 1 1 <br> 4 <br> 20 <br> 1 1</code> </td> <td> <code>0.975037457809</code> </td> </tr></tbody></table></div><h4>  Exemple 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrer</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>0.1 0.2 0.3 0.25 0.3 1 0.3 3 0.5 <br> 2 1 <br> 3 4 <br> 20 <br> 2 1</code> </td> <td> <code>0.247705779810</code> </td> </tr></tbody></table></div><h4>  Exemple 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrer</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>0.2 0.2 0.2 0.3 0.3 3 0.3 1 1 <br> 5 3 <br> 16 35 24 19 23 <br> 5 6 7 <br> 2 1</code> </td> <td> <code>0.200961101684</code> </td> </tr></tbody></table></div><h4>  Remarques </h4><br>  Dans le premier exemple, la séquence initiale de nombres peut être obtenue de trois manières: <br><br>  • D'abord, avec la probabilité p <sub>d</sub> ajouter une phrase au texte original, puis avec la probabilité p <sub>i</sub> ajouter une phrase à la traduction, puis avec la probabilité p <sub>h</sub> terminer la génération. <br><br>  La probabilité de cet événement est P <sub>1</sub> = p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>h</sub> . <br><br>  • D'abord, avec la probabilité p <sub>d</sub> ajouter une phrase au texte original, puis avec la probabilité p <sub>i</sub> ajouter une phrase à la traduction, puis avec la probabilité p <sub>h</sub> terminer la génération. <br><br>  La probabilité de cet événement est égale à P <sub>2</sub> = p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>h</sub> . <br><br>  • Avec probabilité (1 - p <sub>h</sub> - p <sub>d</sub> - p <sub>i</sub> ) générer deux phrases, puis avec probabilité (1 - p <sub>split s</sub> - p <sub>split t</sub> ) tout laisser tel quel (c'est-à-dire, ne pas diviser l'original ou la traduction en deux phrases ) et après cela avec une probabilité p <sub>h</sub> terminer la génération. <br><br>  La probabilité de cet événement est <br><img src="https://habrastorage.org/webt/xw/ka/ys/xwkayskmtg4g3tkt9pb3n-ieyoa.png" width="550">  . <br><br>  Par conséquent, la réponse est calculée comme suit: <img src="https://habrastorage.org/webt/zm/tw/xk/zmtwxkdjhhctfrcbiqsc0tur6g0.png" width="100">  . </div></div><br><h4>  Solution </h4><br>  La tâche est un cas particulier d'alignement utilisant des modèles de Markov cachés (alignement HMM).  L'idée principale est que vous pouvez calculer la probabilité de générer une paire spécifique de documents en utilisant ce modèle et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme de transfert</a> : dans ce cas, l'état est une paire de préfixes de document.  Par conséquent, la probabilité requise d'alignement d'une paire spécifique de phrases parallèles peut être calculée par l'algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avant-arrière</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; #include &lt;vector&gt; double p_h, p_d, p_i, p_tr, p_ss, p_st, mu_s, sigma_s, mu_t, sigma_t; double lognorm_cdf(double x, double mu, double sigma) { if (x &lt; 1e-9) return 0.0; double res = std::log(x) - mu; res /= std::sqrt(2.0) * sigma; res = 0.5 * (1 + std::erf(res)); return res; } double length_probability(int l, double mu, double sigma) { return lognorm_cdf(l, mu, sigma) - lognorm_cdf(l - 1, mu, sigma); } double translation_probability(int ls, int lt) { double res = length_probability(ls, mu_s, sigma_s); double mu = mu_t - mu_s + std::log(ls); double sigma = std::sqrt(sigma_t * sigma_t - sigma_s * sigma_s); res *= length_probability(lt, mu, sigma); return res; } double split_probability(int l1, int l2, double mu, double sigma) { int l_sum = l1 + l2; double total_prob = 0.0; for (int i = 1; i &lt; l_sum; ++i) { total_prob += length_probability(i, mu, sigma) * length_probability(l_sum - i, mu, sigma); } return length_probability(l1, mu, sigma) * length_probability(l2, mu, sigma) / total_prob; } double log_prob10(int ls) { return std::log(p_d * length_probability(ls, mu_s, sigma_s)); } double log_prob01(int lt) { return std::log(p_i * length_probability(lt, mu_t, sigma_t)); } double log_prob11(int ls, int lt) { return std::log(p_tr * (1 - p_ss - p_st) * translation_probability(ls, lt)); } double log_prob21(int ls1, int ls2, int lt) { return std::log(p_tr * p_ss * split_probability(ls1, ls2, mu_s, sigma_s) * translation_probability(ls1 + ls2 - 1, lt)); } double log_prob12(int ls, int lt1, int lt2) { return std::log(p_tr * p_st * split_probability(lt1, lt2, mu_t, sigma_t) * translation_probability(ls, lt1 + lt2 - 1)); } double logsum(double v1, double v2) { double res = std::max(v1, v2); v1 -= res; v2 -= res; v1 = std::min(v1, v2); if (v1 &lt; -30) { return res; } return res + std::log(std::exp(v1) + 1.0); } double loginc(double* to, double from) { *to = logsum(*to, from); } constexpr double INF = 1e25; int main(void) { using std::cin; using std::cout; cin &gt;&gt; p_h &gt;&gt; p_d &gt;&gt; p_i &gt;&gt; p_ss &gt;&gt; p_st &gt;&gt; mu_s &gt;&gt; sigma_s &gt;&gt; mu_t &gt;&gt; sigma_t; p_tr = 1.0 - p_h - p_d - p_i; int Ns, Nt; cin &gt;&gt; Ns &gt;&gt; Nt; using std::vector; vector&lt;int&gt; ls(Ns), lt(Nt); for (int i = 0; i &lt; Ns; ++i) cin &gt;&gt; ls[i]; for (int i = 0; i &lt; Nt; ++i) cin &gt;&gt; lt[i]; vector&lt; vector&lt; double&gt; &gt; fwd(Ns + 1, vector&lt;double&gt;(Nt + 1, -INF)), bwd = fwd; fwd[0][0] = 0; bwd[Ns][Nt] = 0; for (int i = 0; i &lt;= Ns; ++i) { for (int j = 0; j &lt;= Nt; ++j) { if (i &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j] + log_prob10(ls[i - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j] + log_prob10(ls[Ns - i])); } if (j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i][j - 1] + log_prob01(lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i][Nt - j + 1] + log_prob01(lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 1] + log_prob11(ls[i - 1], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 1] + log_prob11(ls[Ns - i], lt[Nt - j])); } if (i &gt;= 2 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 2][j - 1] + log_prob21(ls[i - 1], ls[i - 2], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 2][Nt - j + 1] + log_prob21(ls[Ns - i], ls[Ns - i + 1], lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 2) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 2] + log_prob12(ls[i - 1], lt[j - 1], lt[j - 2])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 2] + log_prob12(ls[Ns - i], lt[Nt - j], lt[Nt - j + 1])); } } } int j, k; cin &gt;&gt; j &gt;&gt; k; double rlog = fwd[j - 1][k - 1] + bwd[j][k] + log_prob11(ls[j - 1], lt[k - 1]) - bwd[0][0]; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12) &lt;&lt; std::exp(rlog) &lt;&lt; std::endl; }</span></span></span></span></code> </pre> </div></div><br><h2>  D. Bande de recommandations </h2><br><h4>  Condition </h4><div class="scrollable-table"><table><tbody><tr><td>  Limite de temps </td><td>  2 s </td></tr><tr><td>  Limite de mémoire </td><td>  64 Mo </td></tr><tr><td>  Entrer </td><td>  entrée standard ou input.txt </td></tr><tr><td>  Conclusion </td><td>  sortie standard ou output.txt </td></tr></tbody></table></div>  Considérez un flux de recommandations pour le contenu hétérogène.  Il mélange des objets de différents types (photos, vidéos, actualités, etc.).  Ces objets sont généralement classés par pertinence pour l'utilisateur: plus l'objet est pertinent (intéressant) pour l'utilisateur, plus il se trouve en haut de la liste des recommandations.  Cependant, avec un tel classement, des situations surviennent souvent dans lesquelles plusieurs objets du même type apparaissent dans la liste des recommandations.  Cela aggrave considérablement la variété externe de nos recommandations et les utilisateurs n'aiment donc pas.  Il est nécessaire de mettre en œuvre un algorithme qui, selon la liste des recommandations, constituera une nouvelle liste qui sera exempte de ce problème et sera la plus pertinente. <br><br>  Soit une liste initiale de recommandations donnée a = [a <sub>0</sub> , a <sub>1</sub> , ..., a <sub>n - 1</sub> ] de longueur n&gt; 0. Un objet avec le nombre i a le type avec le nombre b <sub>i</sub> ∈ {0, ..., m - 1}.  De plus, un objet sous le numéro i a une pertinence r (a <sub>i</sub> ) = 2 <sub>−i</sub> .  Considérons la liste obtenue à partir de l'initial en choisissant un sous-ensemble d'objets et en les réarrangeant: x = [a <sub>i <sub>0</sub></sub> , a <sub>i <sub>1</sub></sub> , ..., a <sub>i <sub>k - 1</sub></sub> ] de longueur k (0 ≤ k ≤ n).  Une liste est dite admissible si deux objets consécutifs ne coïncident pas en type, c'est-à-dire b <sub>i <sub>j</sub></sub> ≠ b <sub>i <sub>j + 1</sub></sub> pour tout j = 0, ..., k - 2.  La pertinence de la liste est calculée par la formule <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.112ex" height="3.503ex" viewBox="0 -987.6 7367.6 1508.3" role="img" focusable="false" style="vertical-align: -1.209ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-6D" x="0" y="0"></use><g transform="translate(878,403)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMAIN-2212" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMAIN-31" x="1300" y="0"></use></g><g transform="translate(878,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-6A" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMAIN-3D" x="412" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMAIN-30" x="1191" y="0"></use></g></g><g transform="translate(3543,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMAIN-2212" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-6A" x="778" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-72" x="4986" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMAIN-28" x="5437" y="0"></use><g transform="translate(5827,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-61" x="0" y="0"></use><g transform="translate(529,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMATHI-6A" x="488" y="-213"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhqkzuPsRJWEmxZYVryrkT2Oc4u6A#MJMAIN-29" x="6978" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mo>−</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ sum_ {j = 0} ^ {k-1} 2 _ {- j} r (a_ {i_j}) </script>  .  Vous devez trouver la liste de pertinence maximale parmi toutes les valides. <br><br><div class="spoiler">  <b class="spoiler_title">Formats d'E / S et exemples</b> <div class="spoiler_text"><h4>  Format d'entrée </h4><br>  Sur la première ligne, les nombres n et m s'écrivent avec un espace (1 ≤ n ≤ 100000, 1 ≤ m ≤ n).  Les n lignes suivantes contiennent les nombres b <sub>i</sub> pour i = 0, ..., n - 1 (0 ≤ b <sub>i</sub> ≤ m - 1). <br><br><h4>  Format de sortie </h4><br>  Notez, avec un espace, le nombre d'objets dans la liste finale: i <sub>0</sub> , i <sub>1</sub> , ..., i <sub>k - 1</sub> . <br><br><h4>  Exemple 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrer</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>1 1 <br> 0</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Exemple 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrer</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>2 2 <br> 1 <br> 1</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Exemple 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrer</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>10 2 <br> 1 <br> 1 <br> 1 <br> 0 <br> 0 <br> 1 <br> 0 <br> 1 <br> 1 <br> 1</code> </td> <td> <code>0 3 1 4 2 6 5</code> </td> </tr></tbody></table></div></div></div><br><h4>  Solution </h4><br>  À l'aide de calculs mathématiques simples, on peut montrer que le problème peut être résolu par une approche «gourmande», c'est-à-dire que dans la liste optimale de recommandations, chaque élément a l'objet le plus pertinent de tous qui sont valides au même début de la liste.  La mise en œuvre de cette approche est simple: nous prenons des objets dans une rangée et les ajoutons à la réponse, si possible.  Lorsqu'un objet invalide est rencontré (dont le type coïncide avec le type du précédent), nous le mettons de côté dans une file d'attente séparée, à partir de laquelle nous l'insérons dans la réponse dès que possible.  Notez qu'à chaque instant, tous les objets de cette file d'attente auront un type correspondant.  À la fin, plusieurs objets peuvent rester dans la file d'attente, ils ne seront plus inclus dans la réponse. <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; blend(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; types) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; repeated; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.empty() || types[result.back()] != types[i]) { result.push_back(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!repeated.empty() &amp;&amp; types[repeated.front()] != types[result.back()]) { result.push_back(repeated.front()); repeated.pop(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { repeated.push(i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2>  D. Clusterisation des séquences de caractères </h2><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Toutes les langues</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  Limite de temps </td><td>  1 s </td><td>  6 s </td><td>  6 s </td></tr><tr><td>  Limite de mémoire </td><td>  64 Mo </td><td>  64 Mo </td><td>  64 Mo </td></tr><tr><td>  Entrer </td><td colspan="3">  entrée standard ou input.txt </td></tr><tr><td>  Conclusion </td><td colspan="3">  sortie standard ou output.txt </td></tr></tbody></table></div>  Il y a un alphabet fini A = {a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>K - 1</sub> , a <sub>K</sub> = S}, a <sub>i</sub> ∈ {a, b, ..., z}, S est la fin de la ligne. <br><br>  Considérez la méthode suivante pour générer des chaînes aléatoires sur l'alphabet A: <br><br>  1. Le premier caractère x <sub>1</sub> est une variable aléatoire de distribution P (x <sub>1</sub> = a <sub>i</sub> ) = q <sub>i</sub> (on sait que q <sub>K</sub> = 0). <br>  2. Chaque caractère suivant est généré sur la base du précédent conformément à la distribution conditionnelle P (x <sub>i</sub> = a <sub>j</sub> || x <sub>i - 1</sub> = a <sub>l</sub> ) = p <sub>jl</sub> . <br>  3. Si x <sub>i</sub> = S, la génération s'arrête et le résultat est x <sub>1</sub> x <sub>2</sub> ... x <sub>i - 1</sub> . <br><br>  L'ensemble des lignes générées à partir d'un mélange de deux modèles décrits avec des paramètres différents est donné.  Il est nécessaire que chaque ligne donne l'index de la chaîne à partir de laquelle elle a été générée. <br><br><div class="spoiler">  <b class="spoiler_title">Formats d'E / S, exemple et notes</b> <div class="spoiler_text"><h4>  Format d'entrée </h4><br>  La première ligne contient deux nombres 1000 ≤ N ≤ 2000 et 3 ≤ K ≤ 27 - le nombre de lignes et la taille de l'alphabet, respectivement. <br><br>  La deuxième ligne contient une ligne composée de K - 1 lettres minuscules différentes de l 'alphabet latin, indiquant les premiers K - 1 éléments de l' alphabet. <br><br>  Chacune des N lignes suivantes est générée selon l'algorithme décrit dans la condition. <br><br><h4>  Format de sortie </h4><br>  N lignes, la i-ème ligne contient le numéro de cluster (0/1) pour la séquence sur la i + 1-ème ligne du fichier d'entrée.  La coïncidence avec la vraie réponse doit être d'au moins 80%. <br><br><h4>  Exemple </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Entrer</b> </td><td>  <b>Conclusion</b> </td></tr><tr><td> <code>100 3 <br> a <br> a <br> aa <br> a <br> aaa <br> a <br> aaaaaa <br> aa <br> a <br> a <br> a <br> aaa <br> a <br> a <br> aaa <br> aa <br> aaaa <br> aaa <br> a <br> aaaaa <br> aa <br> a <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaaa <br> aaa <br> a <br> aa <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaa <br> aaa <br> a <br> a <br> bbb <br> bb <br> bb <br> bbbbbbb <br> bb <br> bbb <br> b <br> bbbbbbb <br> bbbb <br> bbb <br> bb <br> bbb <br> bb <br> bb <br> bbb <br> bbbbbb <br> bbb <br> b <br> bbbbbb <br> b <br> bbbbb <br> b <br> b <br> bb <br> b <br> bb <br> bb <br> b <br> b <br> b <br> b <br> bb <br> bb <br> bb <br> b <br> b <br> b <br> bb <br> b <br> bbb <br> bb <br> b <br> bbbbbb <br> b <br> bb <br> bb <br> bb <br> b <br> bb <br> bbb</code> </td> <td> <code>0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1</code> </td> </tr></tbody></table></div><h4>  Remarques </h4><br>  Note au test de la condition: en elle les 50 premières lignes sont générées à partir de la distribution <br>  P (x <sub>i</sub> = a | x <sub>i - 1</sub> = a) = 0,5, P (x <sub>i</sub> = S | x <sub>i - 1</sub> = a) = 0,5, P (x <sub>1</sub> = a) = 1;  deuxième 50 - de la distribution <br>  P (x <sub>i</sub> = b | x <sub>i - 1</sub> = b) = 0,5, P (x <sub>i</sub> = S | x <sub>i - 1</sub> = b) = 0,5, P (x <sub>1</sub> = b) = 1. </div></div><br><h4>  Solution </h4><br>  Le problème est résolu en utilisant l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">algorithme EM</a> : on suppose que l'échantillon présenté est généré à partir d'un mélange de deux chaînes de Markov dont les paramètres sont restaurés au cours des itérations.  Une restriction de 80% des bonnes réponses est faite afin que l'exactitude de la solution ne soit pas affectée par les exemples qui ont une forte probabilité dans les deux chaînes.  Par conséquent, lorsqu'ils sont correctement restaurés, ces exemples peuvent être affectés à une chaîne incorrecte en termes de réponse générée. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math EPS = <span class="hljs-number"><span class="hljs-number">1e-9</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>] * size <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, cols)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [empty_row(cols) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(rows)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row)</span></span></span><span class="hljs-function">:</span></span> row_sum = sum(row) + EPS <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x / row_sum <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mtx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [normalized_row(r) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mtx] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alphabet, string_samples)</span></span></span><span class="hljs-function">:</span></span> n_tokens = len(alphabet) n_samples = len(string_samples) samples = [tuple([alphabet.index(token) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s] + [n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>, n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string_samples] probs = [random.random() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n_samples)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>): old_probs = [x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> probs] <span class="hljs-comment"><span class="hljs-comment"># probs fixed p0, A = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) q0, B = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) for prob, sample in zip(probs, samples): p0[sample[0]] += prob q0[sample[0]] += 1 - prob for t1, t2 in zip(sample[:-1], sample[1:]): A[t1][t2] += prob B[t1][t2] += 1 - prob A, p0 = normalized_matrix(A), normalized_row(p0) B, q0 = normalized_matrix(B), normalized_row(q0) trans_log_diff = [ [math.log(b + EPS) - math.log(a + EPS) for b, a in zip(B_r, A_r)] for B_r, A_r in zip(B, A) ] # A, p0, B, q0 fixed probs = empty_row(n_samples) for i, sample in enumerate(samples): value = math.log(q0[sample[0]] + EPS) - math.log(p0[sample[0]] + EPS) for t1, t2 in zip(sample[:-1], sample[1:]): value += trans_log_diff[t1][t2] probs[i] = 1.0 / (1.0 + math.exp(value)) if max(abs(x - y) for x, y in zip(probs, old_probs)) &lt; 1e-9: break return [int(x &gt; 0.5) for x in probs] def main(): N, K = list(map(int, input().split())) string_samples = [] alphabet = list(input().strip()) + [''] for _ in range(N): string_samples.append(input().rstrip()) result = restore_params(alphabet, string_samples) for r in result: print(r) if __name__ == '__main__': main()</span></span></code> </pre> <br><hr><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461273/">https://habr.com/ru/post/fr461273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461261/index.html">Liste de contrôle des webinaires RRC utiles sur les produits RRC</a></li>
<li><a href="../fr461265/index.html">À propos de l'abus de l'utilisation du système d'exploitation dans les projets de microcontrôleurs</a></li>
<li><a href="../fr461267/index.html">Nouvelles technologies Intel pour le conditionnement des puces</a></li>
<li><a href="../fr461269/index.html">La solution de travail avec pwnable.kr 08 est leg et 10 est shellshock. Assembleur ARM. Vulnérabilité Bash</a></li>
<li><a href="../fr461271/index.html">Comment promouvoir une application mobile en 2019: 4 façons pratiques + outils utiles</a></li>
<li><a href="../fr461277/index.html">Présentation de l'outil gratuit SQLIndexManager</a></li>
<li><a href="../fr461279/index.html">Comment créer un microservice simple sur Golang et gRPC et le conteneuriser à l'aide de Docker</a></li>
<li><a href="../fr461281/index.html">Procédure pas à pas pour configurer un serveur DNS BIND dans un environnement chroot pour Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../fr461283/index.html">Architecture logicielle et conception de systèmes: guide général et ressources</a></li>
<li><a href="../fr461285/index.html">5 algorithmes d'échantillonnage principaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>