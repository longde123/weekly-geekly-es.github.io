<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôªÔ∏è ü§∏üèΩ ‚úäüèΩ Un poco de diccionarios internos en CPython (y PyPy) üöñ üçà üö¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La estructura interna de los diccionarios en Python no se limita solo al dep√≥sito y al hashing privado. Este es un mundo incre√≠ble de claves compartid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un poco de diccionarios internos en CPython (y PyPy)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432996/">  La estructura interna de los diccionarios en Python no se limita solo al dep√≥sito y al hashing privado.  Este es un mundo incre√≠ble de claves compartidas, almacenamiento en cach√© de hash, DKIX_DUMMY y comparaciones r√°pidas, que se pueden hacer a√∫n m√°s r√°pido (a costa de un error con una probabilidad aproximada de 2 ^ -64). <br><br>  Si no conoce la cantidad de elementos en el diccionario que acaba de crear, cu√°nta memoria se gasta para cada elemento, por qu√© ahora (CPython 3.6 en adelante) el diccionario se implementa en dos matrices y c√≥mo se relaciona con el mantenimiento del orden de inserci√≥n, o simplemente no vio la presentaci√≥n de Raymond Hettinger "Modern Python Diccionarios Una confluencia de una docena de grandes ideas ".  Entonces bienvenido. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p33CVV29OG8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Sin embargo, las personas que est√°n familiarizadas con la conferencia tambi√©n pueden encontrar algunos detalles e informaci√≥n nueva, y para los reci√©n llegados que no est√°n familiarizados con el cubo y el hash cerrado, el art√≠culo tambi√©n ser√° interesante. <br><a name="habracut"></a><br>  Los diccionarios en CPython est√°n en todas partes, las clases, las variables globales, los par√°metros de kwargs se basan en ellos, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">int√©rprete crea miles de diccionarios</a> , incluso si usted mismo no agreg√≥ ning√∫n par√©ntesis a su secuencia de comandos.  Pero para resolver muchos problemas aplicados, tambi√©n se utilizan diccionarios, no es sorprendente que su implementaci√≥n contin√∫e mejorando y que cada vez m√°s se conviertan en diferentes trucos. <br><br><h2>  Implementaci√≥n b√°sica de diccionarios (a trav√©s de Hashmap) </h2><br>  Si est√° familiarizado con el trabajo del Hashmap est√°ndar y el hashing privado, puede pasar al siguiente cap√≠tulo. <br><br>  La idea subyacente en los diccionarios es simple: si tenemos una matriz en la que se almacenan objetos del mismo tama√±o, entonces f√°cilmente tenemos acceso al objeto deseado, conociendo el √≠ndice. <br><br><img src="https://habrastorage.org/webt/wq/m3/nk/wqm3nkortrkb_eyjwlorn4ahreq.png"><br><br>  Simplemente agregamos un √≠ndice multiplicado por el tama√±o del objeto al desplazamiento de la matriz, y obtenemos la direcci√≥n del objeto deseado. <br><br>  Pero, ¬øqu√© sucede si queremos organizar una b√∫squeda no por un √≠ndice entero, sino por una variable de otro tipo, por ejemplo, para encontrar usuarios en su direcci√≥n de correo? <br><br>  En el caso de una matriz simple, tendremos que revisar los correos electr√≥nicos de todos los usuarios de la matriz y compararlos con la b√∫squeda, este enfoque se llama b√∫squeda lineal y, obviamente, es mucho m√°s lento que acceder al objeto por √≠ndice. <br><br>  La b√∫squeda lineal puede acelerarse significativamente si limitamos el tama√±o del √°rea en la que desea buscar.  Esto generalmente se logra tomando el resto del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">hash</a> .  El campo que se busca es la clave. <br><br><img src="https://habrastorage.org/webt/hn/1l/f4/hn1lf445vm6bnorbgvx7n5mbfos.png"><br><br>  Como resultado, se realiza una b√∫squeda lineal no en todo el conjunto grande, sino a lo largo de su parte. <br><br>  Pero, ¬øy si ya hay un elemento all√≠?  Esto podr√≠a suceder muy bien, ya que nadie garantiz√≥ que los residuos de dividir el hash fueran √∫nicos (como el hash mismo).  En este caso, el objeto se colocar√° en el siguiente √≠ndice; si est√° ocupado, cambiar√° por otro √≠ndice y as√≠ sucesivamente hasta que encuentre uno libre.  Al recuperar un elemento, se ver√°n todas las claves con el mismo hash. <br><br><img src="https://habrastorage.org/webt/8a/0d/uj/8a0dujuj4hduhrbihtpomacvg0i.png"><br><br>  Este tipo de hashing se llama privado.  Si hay pocas celdas libres en el diccionario, entonces dicha b√∫squeda amenaza con degenerar en una lineal, por lo que perderemos todas las ganancias, para las cuales se cre√≥ el diccionario, para evitar esto, el int√©rprete mantiene el conjunto lleno 1/2 - 2/3.  Si no hay suficientes celdas libres, se crea una nueva matriz dos veces m√°s grande que la anterior, y los elementos de la antigua se transfieren a la nueva a la vez. <br><br>  ¬øQu√© hacer si el art√≠culo ha sido eliminado?  En este caso, se forma una celda vac√≠a en la matriz y el algoritmo de b√∫squeda por clave no puede distinguir, esta celda est√° vac√≠a porque un elemento con dicho hash no estaba en el diccionario o porque se elimin√≥.  Para evitar la p√©rdida de datos durante la eliminaci√≥n, la celda est√° marcada con un indicador especial (DKIX_DUMMY).  Si se encuentra este indicador durante una b√∫squeda de elementos, la b√∫squeda contin√∫a, la celda se considera ocupada, si se inserta, la celda se sobrescribir√°. <br><br><h2>  Caracter√≠sticas de implementaci√≥n en Python </h2><br>  Cada elemento del diccionario debe contener un enlace al objeto y la clave de destino.  La clave debe almacenarse para el procesamiento de colisi√≥n, el objeto, por razones obvias.  Dado que tanto la clave como el objeto pueden ser de cualquier tipo y tama√±o, no podemos almacenarlos directamente en la estructura, se encuentran en la memoria din√°mica y los enlaces a ellos se almacenan en la estructura del elemento de la lista.  Es decir, el tama√±o de un elemento debe ser igual al tama√±o m√≠nimo de dos punteros (16 bytes en sistemas de 64 bits).  Sin embargo, el int√©rprete tambi√©n almacena el hash, esto se hace para no volver a calcularlo con cada aumento en el tama√±o del diccionario.  En lugar de calcular el hash de cada clave de una manera nueva y tomar el resto de la divisi√≥n por el n√∫mero de cubos, el int√©rprete simplemente lee el valor ya guardado.  Pero, ¬øqu√© pasa si se cambia el objeto clave?  En este caso, el hash debe recalcularse y el valor almacenado ser√° incorrecto.  Tal situaci√≥n es imposible, ya que los tipos mutables no pueden ser claves de diccionario. <br><br>  La estructura del elemento del diccionario se define de la siguiente manera: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_hash_t me_hash; <span class="hljs-comment"><span class="hljs-comment">//  PyObject *me_key; //    PyObject *me_value; //     } PyDictKeyEntry;</span></span></code> </pre> <br>  El tama√±o m√≠nimo del diccionario es declarado por la constante PyDict_MINSIZE, que es 8. Los desarrolladores decidieron que este es el tama√±o √≥ptimo para evitar el desperdicio innecesario de memoria para almacenar valores vac√≠os y tiempo para la expansi√≥n din√°mica de la matriz.  Por lo tanto, al crear un diccionario (hasta la versi√≥n 3.6), necesitaba un m√≠nimo de 8 elementos en el diccionario * 24 bytes en la estructura = 192 bytes (esto no tiene en cuenta el resto de los campos: el costo de la variable del diccionario en s√≠, el contador del n√∫mero de elementos, etc.) <br><br>  Los diccionarios tambi√©n se utilizan para implementar campos de clase personalizados.  Python le permite cambiar din√°micamente el n√∫mero de atributos, esta din√°mica no requiere costos adicionales, ya que agregar / eliminar un atributo es esencialmente equivalente a la operaci√≥n correspondiente en el diccionario.  Sin embargo, una minor√≠a de programas usa esta funcionalidad; la mayor√≠a est√°n limitados a campos declarados en __init__.  Pero cada objeto debe almacenar su propio diccionario, con sus claves y hashes, a pesar de que coinciden con otros objetos.  Una mejora l√≥gica aqu√≠ es el almacenamiento de claves compartidas en un solo lugar, que es exactamente lo que se implement√≥ en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">PEP 412 - Diccionario de intercambio de claves</a> .  La capacidad de cambiar din√°micamente el diccionario no desapareci√≥: si se cambia el orden o el n√∫mero de claves, el diccionario se convierte de las claves de divisi√≥n a la normal. <br><br>  Para evitar colisiones, la "carga" m√°xima del diccionario es 2/3 del tama√±o actual de la matriz. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)</span></span></code> </pre> <br>  Por lo tanto, la primera extensi√≥n ocurrir√° cuando se agregue el sexto elemento. <br><br>  La matriz resulta bastante descargada, durante la operaci√≥n del programa, de la mitad a un tercio de las celdas permanecen vac√≠as, lo que conduce a un mayor consumo de memoria.  Para evitar esta limitaci√≥n y, si es posible, almacenar solo los datos necesarios, se agreg√≥ un nuevo <s>nivel de abstracci√≥n de</s> matriz. <br><br>  En lugar de almacenar una matriz dispersa, por ejemplo: <br><br><pre> <code class="python hljs"> d = {<span class="hljs-string"><span class="hljs-string">'timmy'</span></span>: <span class="hljs-string"><span class="hljs-string">'red'</span></span>, <span class="hljs-string"><span class="hljs-string">'barry'</span></span>: <span class="hljs-string"><span class="hljs-string">'green'</span></span>, <span class="hljs-string"><span class="hljs-string">'guido'</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>} <span class="hljs-comment"><span class="hljs-comment"># -&gt; entries = [['--', '--', '--'], [-8522787127447073495, 'barry', 'green'], ['--', '--', '--'], ['--', '--', '--'], ['--', '--', '--'], [-9092791511155847987, 'timmy', 'red'], ['--', '--', '--'], [-6480567542315338377, 'guido', 'blue']]</span></span></code> </pre><br>  A partir de la versi√≥n 3.6, los diccionarios se organizan de la siguiente manera: <br><br><pre> <code class="python hljs"> indices = [<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] entries = [[<span class="hljs-number"><span class="hljs-number">-9092791511155847987</span></span>, <span class="hljs-string"><span class="hljs-string">'timmy'</span></span>, <span class="hljs-string"><span class="hljs-string">'red'</span></span>], [<span class="hljs-number"><span class="hljs-number">-8522787127447073495</span></span>, <span class="hljs-string"><span class="hljs-string">'barry'</span></span>, <span class="hljs-string"><span class="hljs-string">'green'</span></span>], [<span class="hljs-number"><span class="hljs-number">-6480567542315338377</span></span>, <span class="hljs-string"><span class="hljs-string">'guido'</span></span>, <span class="hljs-string"><span class="hljs-string">'blue'</span></span>]]</code> </pre><br>  Es decir  solo se almacenan aquellos registros que son realmente necesarios, se sacan de la tabla hash en una matriz separada y solo los √≠ndices de los registros correspondientes se almacenan en la tabla hash.  Si inicialmente la matriz tom√≥ 192 bytes, ahora es solo 80 (3 * 24 bytes para cada registro + 8 bytes para los √≠ndices).  Compresi√≥n alcanzada al 58%. [2] <br><br>  El tama√±o de un elemento en los √≠ndices tambi√©n cambia din√°micamente, inicialmente es igual a un byte, es decir, toda la matriz se puede colocar en un registro, cuando el √≠ndice comienza a caber en 8 bits, luego los elementos se expanden a 16, luego a 32 bits.  Hay constantes especiales DKIX_EMPTY y DKIX_DUMMY para elementos vac√≠os y eliminados, respectivamente, la expansi√≥n del √≠ndice a 16 bytes se produce cuando hay m√°s de 127 elementos en el diccionario. <br><br>  Se agregan nuevos objetos a las entradas, es decir, cuando se expande el diccionario, no es necesario moverlos, solo necesita aumentar el tama√±o de los √≠ndices y sobrecargarlo con √≠ndices. <br><br>  Al iterar sobre un diccionario, la matriz de √≠ndices no es necesaria, los elementos se devuelven secuencialmente desde las entradas, porque  Cada vez que se agregan elementos al final de las entradas, el diccionario guarda autom√°ticamente el orden de aparici√≥n de los elementos.  Por lo tanto, adem√°s de reducir la memoria necesaria para almacenar el diccionario, recibimos una expansi√≥n din√°mica m√°s r√°pida y la preservaci√≥n del orden de las teclas.  Reducir la memoria es bueno en s√≠ mismo, pero al mismo tiempo puede aumentar el rendimiento, ya que permite que ingresen m√°s registros en la memoria cach√© del procesador. <br><br>  A los desarrolladores de CPython les gust√≥ tanto esta implementaci√≥n que ahora se requieren diccionarios para mantener el orden de inserci√≥n por especificaci√≥n.  Si antes se determin√≥ el orden de los diccionarios, es decir  estaba estrictamente definido por un hash y no se modific√≥ de principio a inicio, luego se agreg√≥ un poco de aleatoriedad para que las claves fueran diferentes cada vez, ahora se requieren las teclas del diccionario para preservar el orden.  No est√° claro cu√°nto fue necesario y qu√© hacer si aparece una implementaci√≥n a√∫n m√°s efectiva del diccionario pero no conserva el orden de inserci√≥n. <br><br>  Sin embargo, hubo solicitudes para implementar un mecanismo para preservar la declaraci√≥n de atributos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">clases</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">kwargs</a> , y esta implementaci√≥n le permite cerrar estos problemas sin mecanismos especiales. <br><br>  As√≠ es como se ve en el <a href="" rel="nofollow">c√≥digo CPython</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dictkeysobject</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t dk_refcnt; <span class="hljs-comment"><span class="hljs-comment">/* Size of the hash table (dk_indices). It must be a power of 2. */</span></span> Py_ssize_t dk_size; <span class="hljs-comment"><span class="hljs-comment">/* Function to lookup in the hash table (dk_indices): - lookdict(): general-purpose, and may return DKIX_ERROR if (and only if) a comparison raises an exception. - lookdict_unicode(): specialized to Unicode string keys, comparison of which can never raise an exception; that function can never return DKIX_ERROR. - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further specialized for Unicode string keys that cannot be the &lt;dummy&gt; value. - lookdict_split(): Version of lookdict() for split tables. */</span></span> dict_lookup_func dk_lookup; <span class="hljs-comment"><span class="hljs-comment">/* Number of usable entries in dk_entries. */</span></span> Py_ssize_t dk_usable; <span class="hljs-comment"><span class="hljs-comment">/* Number of used entries in dk_entries. */</span></span> Py_ssize_t dk_nentries; <span class="hljs-comment"><span class="hljs-comment">/* Actual hash table of dk_size entries. It holds indices in dk_entries, or DKIX_EMPTY(-1) or DKIX_DUMMY(-2). Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size). The size in bytes of an indice depends on dk_size: - 1 byte if dk_size &lt;= 0xff (char*) - 2 bytes if dk_size &lt;= 0xffff (int16_t*) - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*) - 8 bytes otherwise (int64_t*) Dynamically sized, SIZEOF_VOID_P is minimum. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> dk_indices[]; <span class="hljs-comment"><span class="hljs-comment">/* char is required to avoid strict aliasing. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* "PyDictKeyEntry dk_entries[dk_usable];" array follows: see the DK_ENTRIES() macro */</span></span> };</code> </pre><br>  Pero la iteraci√≥n es m√°s complicada de lo que inicialmente podr√≠a pensar, hay mecanismos de verificaci√≥n adicionales de que el diccionario no se cambi√≥ durante la iteraci√≥n, uno de ellos es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">versi√≥n de</a> 64 bits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">del diccionario</a> que almacena cada diccionario. <br><br>  Finalmente, consideramos el mecanismo para resolver colisiones.  La cuesti√≥n es que, en Python, los valores hash son f√°cilmente predecibles: <br><br><pre> <code class="python hljs"> &gt;&gt;&gt;[hash(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>)] [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  Y dado que al crear un diccionario a partir de estos hashes, se toma el resto de la divisi√≥n, luego, de hecho, determinan a qu√© dep√≥sito ir√° el registro, solo los √∫ltimos bits de la clave (si es un n√∫mero entero).  Puede imaginar una situaci√≥n en la que muchos objetos "quieren" entrar en cubos vecinos, en cuyo caso tendr√° que mirar muchos objetos que est√°n fuera de lugar al buscar.  Para reducir el n√∫mero de colisiones y aumentar el n√∫mero de bits que determinan a qu√© dep√≥sito ir√° el registro, se implement√≥ el siguiente mecanismo: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   i = i + 1 % n //   : #define PERTURB_SHIFT 5 perturb &gt;&gt;= PERTURB_SHIFT; j = (5*j) + 1 + perturb; //   j % n    </span></span></code> </pre><br>  perturb es una variable entera inicializada por un hash.  Cabe se√±alar que en el caso de una gran cantidad de colisiones, se restablece a cero y la f√≥rmula calcula el siguiente √≠ndice: <br><br><pre> <code class="cpp hljs"> j = (<span class="hljs-number"><span class="hljs-number">5</span></span> * j + <span class="hljs-number"><span class="hljs-number">1</span></span>) % n</code> </pre><br>  Al extraer un elemento del diccionario, se realiza la misma b√∫squeda: se calcula el √≠ndice de la ranura en la que debe ubicarse el elemento, si la ranura est√° vac√≠a, se lanza la excepci√≥n "valor no encontrado".  Si hay un valor en esta ranura, debe verificar que su clave coincida con la que est√° buscando, esto puede no ser posible si se produce una colisi√≥n.  Sin embargo, la clave puede ser casi cualquier objeto, incluido uno para el que la operaci√≥n de comparaci√≥n lleva un tiempo considerable.  Para evitar una larga operaci√≥n de comparaci√≥n, se utilizan varios trucos en Python: <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#   (   ,  C) def eq(key, entity): if id(key) == id(entity): return True if hash(key) != hash(entity): return False return key == entity</span></span></code> </pre><br>  primero, se comparan los punteros, si el puntero clave del objeto deseado es igual al puntero del objeto que se est√° buscando, es decir, apuntan a la misma √°rea de memoria, entonces la comparaci√≥n devuelve inmediatamente verdadero.  Pero eso no es todo.  Como sabe, los objetos iguales deben tener hashes iguales, lo que significa que los objetos con hashes diferentes no son iguales.  Despu√©s de verificar los punteros, se verifican los hashes; si no son iguales, se devolver√° falso.  Y solo si los hashes son iguales, se llamar√° a una comparaci√≥n honesta. <br><br>  ¬øCu√°l es la probabilidad de tal resultado?  Aproximadamente 2 ^ -64, por supuesto, debido a la f√°cil previsibilidad del valor hash, puede elegir f√°cilmente ese ejemplo, pero en realidad, esta verificaci√≥n a menudo no llega a cu√°nto.  Raymond Hettinger ensambl√≥ el int√©rprete cambiando la √∫ltima operaci√≥n de comparaci√≥n con un simple retorno verdadero.  Es decir  el int√©rprete consideraba iguales los objetos si sus hashes son iguales.  Luego estableci√≥ pruebas automatizadas de muchos proyectos populares en este int√©rprete, que finalizaron con √©xito.  Puede parecer extra√±o considerar que los objetos con hashes iguales sean iguales, no para verificar adicionalmente su contenido, y depender √∫nicamente del hash, pero lo hace regularmente cuando usa los protocolos git o torrent.  Consideran que los archivos (bloques de archivos) son iguales si sus hashes son iguales, lo que bien puede conducir a errores, pero sus creadores (y todos nosotros) esperamos que valga la pena se√±alar, sin raz√≥n, que la probabilidad de una colisi√≥n es extremadamente peque√±a. <br><br>  Ahora finalmente deber√≠as entender la estructura del diccionario, que se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyObject_HEAD <span class="hljs-comment"><span class="hljs-comment">/* Number of items in the dictionary */</span></span> Py_ssize_t ma_used; <span class="hljs-comment"><span class="hljs-comment">/* Dictionary version: globally unique, value change each time the dictionary is modified */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ma_version_tag; PyDictKeysObject *ma_keys; <span class="hljs-comment"><span class="hljs-comment">/* If ma_values is NULL, the table is "combined": keys and values are stored in ma_keys. If ma_values is not NULL, the table is splitted: keys are stored in ma_keys and values are stored in ma_values */</span></span> PyObject **ma_values; } PyDictObject;</code> </pre><br><h2>  Cambios futuros </h2><br>  En el cap√≠tulo anterior, consideramos lo que ya se ha implementado y puede ser utilizado por todos en su trabajo, pero las mejoras, por supuesto, no se limitan a: los planes para la versi√≥n 3.8 incluyen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">soporte para diccionarios invertidos</a> .  De hecho, nada impide en lugar de iterar desde el principio de una serie de elementos y aumentar los √≠ndices, comenzando desde el final y disminuyendo los √≠ndices. <br><br><h2>  Materiales adicionales </h2><br>  Para una inmersi√≥n m√°s profunda en el tema, se recomienda familiarizarse con los siguientes materiales: <br><br><ol><li>  Registro del informe al comienzo del art√≠culo. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Propuesta para una nueva implementaci√≥n de diccionarios</a> </li><li>  <a href="" rel="nofollow">C√≥digo fuente del diccionario en CPython</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432996/">https://habr.com/ru/post/es432996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432986/index.html">C vs Go bucles y matem√°tica simple</a></li>
<li><a href="../es432988/index.html">Octavo webmaster. Vive en Habr√©</a></li>
<li><a href="../es432990/index.html">Edison L√°mpara de madera activada por voz. Precio de emisi√≥n $ 5</a></li>
<li><a href="../es432992/index.html">Se puso los auriculares y muri√≥: lidiamos con la extra√±a muerte de un ni√±o en Rimbau.</a></li>
<li><a href="../es432994/index.html">Vivaldi 2.2 - Conversi√≥n de cantidad a calidad</a></li>
<li><a href="../es432998/index.html">Cuento de navidad</a></li>
<li><a href="../es433000/index.html">Compilando Kotlin: JetBrains VS ANTLR VS JavaCC</a></li>
<li><a href="../es433002/index.html">Vamos t√∫ mismo ... o las reglas de comunicaci√≥n en un equipo</a></li>
<li><a href="../es433004/index.html">Una estrategia s√≥lida de migraci√≥n a la nube para 2019: 7 consejos</a></li>
<li><a href="../es433008/index.html">Los dispositivos USB son una amenaza "repentina"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>