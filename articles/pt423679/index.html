<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥ üîπ üôÖ Uma tarefa com um arranha-c√©u e ovos - n√£o a lixeira de Newton? üöê ü§¶üèº ‚ñ™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na verdade, ele √© o mais. Mas as primeiras coisas primeiro. 

 Declara√ß√£o do problema 
 Domino python, resolvo tudo no Codewars. Encontro uma tarefa b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uma tarefa com um arranha-c√©u e ovos - n√£o a lixeira de Newton?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423679/">  Na verdade, ele √© o mais.  Mas as primeiras coisas primeiro. <br><br><h3>  Declara√ß√£o do problema </h3><br>  Domino python, resolvo tudo no Codewars.  Encontro uma tarefa bem conhecida sobre arranha-c√©us e ovos.  A √∫nica diferen√ßa √© que os dados de origem n√£o s√£o 100 andares e 2 ovos, mas um pouco mais. <br>  Dado: N ovos, M tenta jog√°-los, arranha-c√©us sem fim. <br><br>  Definir: o piso m√°ximo a partir do qual voc√™ pode jogar um ovo sem quebrar.  Os ovos s√£o esf√©ricos no v√°cuo e, se um deles n√£o quebrar, caindo, por exemplo, do 99¬∫ andar, os outros tamb√©m suportar√£o uma queda de todos os andares com menos de um cent√©simo. <br><br>  0 &lt;= N, M &lt;= 20.000. <br>  O tempo de execu√ß√£o de duas dezenas de testes √© de 12 segundos. <br><a name="habracut"></a><br><h3>  Procure uma solu√ß√£o </h3><br>  Precisamos escrever uma fun√ß√£o height (n, m), que retornar√° o n√∫mero do piso para o dado n, m.  Como ele ser√° mencionado com muita frequ√™ncia, e toda vez que voc√™ escrever pregui√ßa em ‚Äúaltura‚Äù, em todos os lugares, exceto no c√≥digo, eu o designarei como f (n, m). <br><br>  Vamos come√ßar com zeros.  Obviamente, se n√£o houver ovos ou tentativas de jog√°-los, nada poder√° ser determinado e a resposta ser√° zero.  <b>f (0, m) = 0, f (n, 0) = 0.</b> <br><br>  Suponha que exista um ovo e dez tentativas. Voc√™ pode arriscar tudo e jog√°-lo imediatamente a partir do cent√©simo andar, mas, em caso de falha, n√£o poder√° determinar mais nada, por isso √© mais l√≥gico come√ßar no primeiro andar e subir um andar ap√≥s cada lan√ßamento, at√© que a tentativa ou o ovo termine.  O m√°ximo que voc√™ pode obter se o ovo n√£o falhar √© o n√∫mero 10 do andar. <b>F (1, m) = m</b> <br><br>  Pegue o segundo ovo, tente novamente 10. Agora, ent√£o voc√™ pode se arriscar com um cent√©simo?  Se quebrar, haver√° mais uma e 9 tentativas, pelo menos 9 andares poder√£o passar.  Ent√£o talvez voc√™ precise arriscar n√£o a partir do cent√©simo, mas a partir do d√©cimo?  √â l√≥gico.  Ent√£o, se for bem-sucedido, restar√£o 2 ovos e 9 tentativas.  Por analogia, agora voc√™ precisa subir mais 9 andares.  Com uma s√©rie de sucessos - outros 8, 7, 6, 5, 4, 3, 2 e 1. No total, estamos no 55¬∫ andar com dois ovos inteiros e sem tentar.  A resposta √© a soma dos primeiros M membros da progress√£o aritm√©tica com o primeiro membro 1 e a etapa 1. <b>f (2, m) = (m * m + m) / 2</b> .  Tamb√©m est√° claro que em cada etapa a fun√ß√£o f (1, m) foi chamada, mas isso ainda n√£o √© preciso. <br><br>  Continue com tr√™s ovos e dez tentativas.  No caso de um primeiro arremesso malsucedido, os pisos cobertos por 2 ovos e 9 tentativas ser√£o cobertos por baixo, o que significa que o primeiro arremesso deve ser feito do ch√£o f (2, 9) + 1. Ent√£o, se for bem-sucedido, temos 3 ovos e 9 tentativas .  E para a segunda tentativa, voc√™ precisa subir mais f (2.8) + 1 andares.  E assim por diante, at√© 3 ovos e 3 tentativas permanecerem nas m√£os.  E ent√£o √© hora de se distrair considerando casos com N = M, quando h√° tantos √≥vulos quanto tentativas. <br><br><div class="spoiler">  <b class="spoiler_title">E, ao mesmo tempo, quando h√° mais ovos.</b> <div class="spoiler_text">  Mas aqui tudo √© √≥bvio - os ovos al√©m daqueles que quebram n√£o ser√£o √∫teis para n√≥s, mesmo que todo arremesso n√£o tenha √™xito.  <b>f (n, m) = f (m, m) se n&gt; m</b> .  E, no total, 3 ovos, 3 arremessos.  Se o primeiro ovo quebrar, voc√™ poder√° marcar f (2, 2) pisos na parte inferior e, se n√£o quebrar, f (3,2) pisos na parte superior, ou seja, o mesmo f (2, 2).  Total f (3, 3) = 2 * f (2, 2) + 1 = 7. E f (4, 4), por analogia, consistir√° em dois f (3, 3) e um, e ser√° 15. Todos assemelha-se √†s pot√™ncias de dois e escrevemos: <b>f (m, m) = 2 ^ m - 1</b> . <br><br>  Parece uma pesquisa bin√°ria no mundo f√≠sico: come√ßamos do n√∫mero 2 ^ (m-1); em caso de sucesso, subimos 2 ^ (m-2), e, em caso de falha, diminu√≠mos tanto; at√© que as tentativas acabem.  No nosso caso, aumentamos o tempo todo. <br></div></div><br>  Vamos voltar para f (3, 10).  De fato, em cada etapa, ela se resume √† soma f (2, m-1) - o n√∫mero de andares que pode ser determinado em caso de falha, unidades ef (3, m-1) - o n√∫mero de andares que pode ser determinado em caso de sucesso.  E fica claro que, a partir do aumento do n√∫mero de ovos e tentativas, √© improv√°vel que algo mude.  <b>f (n, m) = f (n - 1, m - 1) + 1 + f (n, m - 1)</b> .  E essa √© uma f√≥rmula universal que pode ser implementada em c√≥digo. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lru_cache @lru_cache() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n,m)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n==<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> m==<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (m**<span class="hljs-number"><span class="hljs-number">2</span></span>+m)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n&gt;=m: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>**n<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height(n<span class="hljs-number"><span class="hljs-number">-1</span></span>,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>+height(n,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br>  Obviamente, eu pisei anteriormente em fun√ß√µes recursivas n√£o-memoizantes e descobri que f (10, 40) leva quase 40 segundos com o n√∫mero de chamadas para si - 97806983. Mas a memoiza√ß√£o tamb√©m salva apenas nos intervalos iniciais.  Se f (200.400) for executado em 0,8 segundos, f (200, 500) j√° estar√° em 31 segundos.  √â engra√ßado que, ao medir o tempo de execu√ß√£o usando% timeit, o resultado √© muito menor que o real.  Obviamente, a primeira execu√ß√£o da fun√ß√£o leva a maior parte do tempo, enquanto o restante simplesmente usa os resultados de sua memoriza√ß√£o.  Mentiras, mentiras descaradas e estat√≠sticas. <br><br><h3>  N√£o √© necess√°ria recurs√£o, procuramos mais </h3><br>  Assim, nos testes, por exemplo, aparece f (9477, 10000), mas meu pat√©tico f (200, 500) n√£o se encaixa mais no momento certo.  Portanto, existe outra solu√ß√£o, sem recurs√£o, continuaremos sua busca.  Eu completei o c√≥digo contando chamadas de fun√ß√£o com determinados par√¢metros para ver o que ele acabou se decompondo.  Por 10 tentativas, foram obtidos os seguintes resultados: <br><br>  f (3,10) = 7+ 1 * f (2,9) + 1 * f (2,8) + 1 * f (2,7) + 1 * f (2,6) + 1 * f (2) , 5) + 1 * f (2,4) + 1 * f (2,3) + 1 * f (3,3) <br>  f (4,10) = 27+ 1 * f (2,8) + 2 * f (2,7) + 3 * f (2,6) + 4 * f (2,5) + 5 * f (2) , 4) + 6 * f (2,3) + 6 * f (3,3) + 1 * f (4,4) <br>  f (5,10) = 55+ 1 * f (2,7) + 3 * f (2,6) + 6 * f (2,5) + 10 * f (2,4) + 15 * f (2) , 3) + 15 * f (3,3) + 5 * f (4,4) + 1 * f (5,5) <br>  f (6,10) = 69+ 1 * f (2,6) + 4 * f (2,5) + 10 * f (2,4) + 20 * f (2,3) + 20 * f (3) , 3) + 10 * f (4,4) + 4 * f (5,5) + 1 * f (6,6) <br>  f (7,10) = 55+ 1 * f (2,5) + 5 * f (2,4) + 15 * f (2,3) + 15 * f (3,3) + 10 * f (4 , 4) + 6 * f (5,5) + 3 * f (6,6) + 1 * f (7,7) <br>  f (8,10) = 27+ 1 * f (2,4) + 6 * f (2,3) + 6 * f (3,3) + 5 * f (4,4) + 4 * f (5 , 5) + 3 * f (6,6) + 2 * f (7,7) + 1 * f (8,8) <br>  f (9,10) = 7+ 1 * f (2,3) + 1 * f (3,3) + 1 * f (4,4) + 1 * f (5,5) + 1 * f (6 , 6) + 1 * f (7,7) + 1 * f (8,8) + 1 * f (9,9) <br><br>  Alguma regularidade √© vis√≠vel: <br><br><img src="https://habrastorage.org/webt/tz/vf/gv/tzvfgvzzjnvtp4oqmb3sbgyhehk.png"><br><br>  Esses coeficientes s√£o teoricamente calculados.  Cada azul √© a soma do topo e da esquerda.  E os violetas s√£o os mesmos azuis, apenas na ordem inversa.  Voc√™ pode calcular, mas isso √© novamente uma recurs√£o e fiquei decepcionado.  Muito provavelmente, muitos (√© uma pena que n√£o sou eu) j√° tenham aprendido esses n√∫meros, mas por enquanto vou manter a intriga, seguindo minha pr√≥pria solu√ß√£o.  Eu decidi cuspir neles e ir para o outro lado. <br><br>  Ele abriu o exel, construiu uma placa com os resultados da fun√ß√£o e come√ßou a procurar padr√µes.  C3 = SE (C $ 2&gt; $ B3; 2 ^ $ B3-1; C2 + B2 + 1), em que $ 2 √© a linha com o n√∫mero de ovos (1-13), $ B √© a coluna com o n√∫mero de tentativas (1-20), C3 - c√©lula na interse√ß√£o de dois √≥vulos e uma tentativa. <br><br><img src="https://habrastorage.org/webt/da/u4/uz/dau4uz9wluuwrll54ugfiol02uq.png"><br><br>  A diagonal cinza √© N = M, e aqui √© claramente vis√≠vel que √† direita (para N&gt; M) nada muda.  Isso pode ser visto - mas n√£o pode ser de outra maneira, porque esses s√£o todos os resultados do trabalho da f√≥rmula, no qual √© dado que cada c√©lula √© igual √† soma da parte superior, superior esquerda e uma.  Mas alguma f√≥rmula universal em que voc√™ pode substituir N e M e obter o n√∫mero do andar n√£o foi encontrada.  Spoiler: n√£o existe.  Mas ent√£o, √© t√£o simples criar essa tabela no Excel, talvez seja poss√≠vel gerar o mesmo python e arrastar respostas dele? <br><br><h3>  Numpy voc√™ n√£o </h3><br>  Lembro que existe o NumPy, que foi projetado apenas para trabalhar com matrizes multidimensionais, por que n√£o tentar?  Para come√ßar, precisamos de uma matriz unidimensional de zeros de tamanho N + 1 e de uma matriz unidimensional de unidades de tamanho N. Pegue a primeira matriz de zero ao pen√∫ltimo elemento, adicione-a elementwise com a primeira matriz do primeiro elemento ao √∫ltimo e com uma matriz de unidades.  Para a matriz resultante, adicione zero ao in√≠cio.  Repita M vezes.  O n√∫mero do elemento N da matriz resultante ser√° a resposta.  Os tr√™s primeiros passos s√£o assim: <br><br><img src="https://habrastorage.org/webt/4w/hf/ki/4whfkie9lt2lkiyywknshrit0h4.png"><br><br>  O NumPy funciona t√£o r√°pido que n√£o salvei a tabela inteira - toda vez que leio a linha necess√°ria novamente.  Uma coisa - o resultado de trabalhar em grandes n√∫meros estava errado.  Classes mais altas s√£o como aquelas, enquanto as mais baixas n√£o s√£o.  √â assim que os erros aritm√©ticos dos n√∫meros de ponto flutuante acumulados a partir de m√∫ltiplas adi√ß√µes se parecem.  N√£o importa - voc√™ pode alterar o tipo da matriz para int.  N√£o, problema - verificou-se que, por uma quest√£o de velocidade, o NumPy funciona apenas com seus tipos de dados, e seu int, diferentemente do Python int, n√£o pode ter mais que 2 ^ 64-1, ap√≥s o qual transborda silenciosamente e continua com -2 ^ 64.  E eu realmente espero n√∫meros com menos de tr√™s mil caracteres.  Mas funciona muito r√°pido, f (9477, 10000) corre 233 ms, acaba sendo uma esp√©cie de absurdo na sa√≠da.  Eu nem vou dar o c√≥digo, j√° que isso.  Vou tentar fazer o mesmo um python limpo. <br><br><h3>  Iterado, iterado, mas n√£o iterado </h3><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y+<span class="hljs-number"><span class="hljs-number">1</span></span>, arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[n]</code> </pre> <br>  44 segundos para calcular f (9477, 10000) √© um pouco demais.  Mas com certeza.  O que pode ser otimizado?  Primeiro, n√£o h√° necessidade de considerar tudo √† direita da diagonal M, M.  O segundo - considerar a √∫ltima matriz como um todo, por uma c√©lula.  Para isso, as duas √∫ltimas duas c√©lulas da anterior ser√£o ajustadas.  Para calcular f (10, 20), apenas essas c√©lulas cinzas ser√£o suficientes: <br><br><img src="https://habrastorage.org/webt/zc/zm/zg/zczmzgfzspyvo2zenqsk4p9y1jo.png"><br><br>  E assim parece no c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; n <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i &lt; mn: <span class="hljs-comment"><span class="hljs-comment">#    m,m arr = [0] + list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr += [arr[-1]] i+=1 arr.pop(-1) while i &lt; n or i &lt; mn: #        arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr = arr + [arr[-1]+1] if n &gt; len(arr) else [0] + arr i+=1 while i &lt; m: # ,     -  arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) i+=1 return arr[0]</span></span></code> </pre> <br>  E o que voc√™ acha?  f (9477, 10000) em 2 segundos!  Mas essa entrada √© muito boa, o comprimento da matriz em qualquer est√°gio n√£o passar√° de 533 elementos (10000-9477).  Vamos verificar f (5477, 10000) - 11 segundos.  Tamb√©m √© bom, mas apenas em compara√ß√£o com 44 segundos - vinte testes com esse tempo n√£o ser√£o aprovados. <br><br>  N√£o √© isso.  Mas como existe uma tarefa, existe uma solu√ß√£o e a pesquisa continua.  Comecei a olhar para a tabela do Excel novamente.  A c√©lula √† esquerda de (m, m) √© sempre uma a menos.  E a c√©lula √† esquerda dela n√£o est√° mais l√°, em cada linha a diferen√ßa se torna maior.  A c√©lula abaixo (m, m) √© sempre duas vezes maior.  E a c√©lula abaixo dela n√£o √© mais duas vezes, mas √© um pouco menor, mas para cada coluna de maneira diferente, quanto mais longe, maior.  E tamb√©m os n√∫meros em uma linha no in√≠cio crescem rapidamente e depois no meio lentamente.  Deixe-me criar uma tabela de diferen√ßas entre c√©lulas vizinhas, talvez que padr√£o apare√ßa l√°? <br><br><h3>  Mais quente </h3><br><img src="https://habrastorage.org/webt/6b/vn/we/6bvnwew8keybhtyzxprylcwir6i.png"><br><br>  Bah, n√∫meros familiares!  Ou seja, a soma N desses n√∫meros na linha n√∫mero M √© esta a resposta?  √â verdade que cont√°-los √© quase o mesmo que eu j√° fiz, √© improv√°vel que isso acelere bastante o trabalho.  Mas voc√™ tem que tentar: <br><br><div class="spoiler">  <b class="spoiler_title">f (9477, 10000): 17 segundos</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y, arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:], arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>])) + [<span class="hljs-number"><span class="hljs-number">1</span></span>] m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:n+<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ou 8, se voc√™ contar apenas metade do tri√¢ngulo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(arr) &lt; n+<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">#    ,  n &lt;  arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr += [arr[-1]] m-=2 while m &gt; 1: arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) m-=1 if len(arr) &lt; n+1: arr += arr[::-1][1:] #  n   ,   return sum(arr[1:n+1])</span></span></code> </pre><br></div></div><br>  Para n√£o dizer que uma solu√ß√£o mais ideal.  Funciona mais r√°pido em alguns dados, mais lento em alguns.  N√≥s devemos ir mais fundo.  O que √© esse tri√¢ngulo com n√∫meros que apareceram na solu√ß√£o duas vezes?  √â uma pena admitir, mas esqueci com seguran√ßa a matem√°tica superior, onde o tri√¢ngulo deve ter figurado, ent√£o tive que pesquisar no Google. <br><br><h3>  Bingo! </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tri√¢ngulo de Pascal</a> , como √© chamado oficialmente.  Tabela de coeficiente binomial infinito.  Portanto, a resposta para o problema com N ovos e M joga √© a soma dos primeiros coeficientes de N na expans√£o do bin√¥mio de Newton do M-grau, exceto o zero. <br><br>  Um coeficiente binomial arbitr√°rio pode ser calculado atrav√©s dos fatoriais do n√∫mero da linha e do n√∫mero do coeficiente na linha: bk = m! / (N! * (Mn!)).  Mas a melhor parte √© que voc√™ pode calcular seq√ºencialmente os n√∫meros na string, sabendo seu n√∫mero e coeficiente zero (sempre um): bk [n] = bk [n-1] * (m - n + 1) / n.  A cada etapa, o numerador diminui em um e o denominador aumenta.  E a solu√ß√£o final concisa √© assim: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> h, bk = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#      for i in range(1, n + 1): bk = bk * m // ih += bk m-=1 return h</span></span></code> </pre><br>  33 ms  para o c√°lculo de f (9477, 10000)!  Essa solu√ß√£o tamb√©m pode ser otimizada, embora nos intervalos fornecidos e funcione bem.  Se n estiver na segunda metade do tri√¢ngulo, podemos invert√™-lo para mn, calcular a soma dos primeiros n coeficientes e subtra√≠-lo de 2 ^ m-2.  Se n estiver pr√≥ximo do meio e m for √≠mpar, os c√°lculos tamb√©m poder√£o ser reduzidos: a soma da primeira metade da linha ser√° 2 ^ (m-1) -1, o √∫ltimo coeficiente da primeira metade pode ser calculado por meio de fatoriais, seu n√∫mero √© (m-1) / 2 e, em seguida, continue adicionando coeficientes se n estiver na metade direita do tri√¢ngulo ou subtraindo se estiver √† esquerda.  Se m for par, n√£o ser√° poss√≠vel contar a metade da linha, mas voc√™ poder√° encontrar a soma dos primeiros coeficientes m / 2 + 1 calculando a m√©dia por meio de fatoriais e adicionando metade a 2 ^ (m-1) -1.  Nos dados de entrada na regi√£o de 10 ^ 6, isso reduz notavelmente o tempo de execu√ß√£o. <br><br>  Ap√≥s uma decis√£o bem-sucedida, comecei a procurar a pesquisa de outra pessoa sobre esse assunto, mas encontrei o mesmo nas entrevistas, com apenas dois √≥vulos, e isso n√£o √© esporte.  A Internet ficar√° incompleta sem a minha decis√£o, decidi, e aqui est√°. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423679/">https://habr.com/ru/post/pt423679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423651/index.html">Convidamos a todos para o hackathon SmartMail Hack: Sobre Bem-vindo</a></li>
<li><a href="../pt423653/index.html">PsRealVehicle ou plug-in de f√≠sica de tanque de c√≥digo aberto no Armored Warfare: Assault</a></li>
<li><a href="../pt423655/index.html">Gen√©ricos + primavera: que a for√ßa esteja com voc√™</a></li>
<li><a href="../pt423657/index.html">N√£o respeito o encapsulamento ou uso um tipo diferente de tabela de m√©todo para chamar rapidamente m√©todos privados</a></li>
<li><a href="../pt423677/index.html">Pilotos a jato: Frankie West</a></li>
<li><a href="../pt423683/index.html">Baseado no senso comum: desenvolvendo DevOps do zero</a></li>
<li><a href="../pt423685/index.html">Simultaneidade do PostgreSQL: n√£o esf√©rica, n√£o √© cavalo, n√£o est√° no v√°cuo</a></li>
<li><a href="../pt423687/index.html">HyperX Pulsefire FPS Pro - mais r√°pido, mais baixo, mais acess√≠vel</a></li>
<li><a href="../pt423689/index.html">RTOS MAX - gr√°tis? Planejamos abrir uma licen√ßa para uso comercial gratuito</a></li>
<li><a href="../pt423693/index.html">Outra maneira de usar o Webpack 4 e a separa√ß√£o de c√≥digo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>