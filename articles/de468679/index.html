<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíí üë©üèø‚ÄçüöÄ üöº Das ABC der Sicherheit in Kubernetes: Authentifizierung, Autorisierung, Pr√ºfung üë©üèº‚Äç‚öñÔ∏è üßòüèø üë®üèø‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fr√ºher oder sp√§ter wirft der Betrieb eines Systems die Frage nach der Sicherheit auf: Gew√§hrleistung der Authentifizierung, Trennung von Rechten, Pr√ºf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das ABC der Sicherheit in Kubernetes: Authentifizierung, Autorisierung, Pr√ºfung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/468679/"><img src="https://habrastorage.org/webt/ao/pp/ke/aoppkeeufk5-tv1rmtmtw9oce7a.png"><br><br>  Fr√ºher oder sp√§ter wirft der Betrieb eines Systems die Frage nach der Sicherheit auf: Gew√§hrleistung der Authentifizierung, Trennung von Rechten, Pr√ºfung und anderer Aufgaben.  F√ºr Kubernetes wurden bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele L√∂sungen entwickelt,</a> mit denen auch in sehr anspruchsvollen Umgebungen Standards eingehalten werden k√∂nnen. Das gleiche Material ist grundlegenden Sicherheitsaspekten gewidmet, die im Rahmen der integrierten Mechanismen von K8 implementiert werden.  Zuallererst ist es n√ºtzlich f√ºr diejenigen, die anfangen, sich mit Kubernetes vertraut zu machen, als Ausgangspunkt f√ºr das Studium von Sicherheitsfragen. <a name="habracut"></a><br><br><h2>  Authentifizierung </h2><br>  Kubernetes hat zwei Arten von Benutzern: <br><br><ul><li>  <i>Dienstkonten</i> - Konten, die von der Kubernetes-API verwaltet werden; </li><li>  <i>Benutzer</i> - ‚Äûnormale‚Äú Benutzer, die von externen, unabh√§ngigen Diensten kontrolliert werden. </li></ul><br>  Der Hauptunterschied zwischen diesen Typen besteht darin, dass f√ºr Dienstkonten in der Kubernetes-API spezielle Objekte (sie werden als <code>ServiceAccounts</code> ) vorhanden sind, die an den Namespace und den Satz von Berechtigungsdaten gebunden sind, die im Cluster in Objekten vom Typ Secrets gespeichert sind.  Solche Benutzer (Dienstkonten) dienen haupts√§chlich zum Verwalten von Zugriffsrechten auf die Kubernetes-API-Prozesse, die in einem Kubernetes-Cluster ausgef√ºhrt werden. <br><br>  Normale Benutzer haben keine Eintr√§ge in der Kubernetes-API: Sie m√ºssen von externen Mechanismen verwaltet werden.  Sie sind f√ºr Personen oder Prozesse gedacht, die au√üerhalb des Clusters leben. <br><br>  Jede Anforderung an die API ist entweder an das Dienstkonto oder an den Benutzer gebunden oder wird als anonym betrachtet. <br><br>  Zu den Benutzerauthentifizierungsdaten geh√∂ren: <br><br><ul><li>  <i>Benutzername</i> - Benutzername (Gro√ü- und Kleinschreibung <i>beachten</i> !); </li><li>  <i>UID</i> ist eine maschinenlesbare Benutzeridentifikationszeichenfolge, die ‚Äûkonsistenter und eindeutiger als der Benutzername‚Äú ist. </li><li>  <i>Gruppen</i> - eine Liste von Gruppen, zu denen der Benutzer geh√∂rt; </li><li>  <i>Extra</i> - zus√§tzliche Felder, die vom Autorisierungsmechanismus verwendet werden k√∂nnen. </li></ul><br>  Kubernetes kann eine Vielzahl von Authentifizierungsmechanismen verwenden: X509-Zertifikate, Inhaber-Token, Authentifizierungs-Proxys, HTTP Basic Auth.  Mit diesen Mechanismen kann eine Vielzahl von Autorisierungsschemata implementiert werden: von einer statischen Datei mit Kennw√∂rtern bis zu OpenID OAuth2. <br><br>  Dar√ºber hinaus sind mehrere Autorisierungsschemata gleichzeitig zul√§ssig.  Standardm√§√üig verwendet der Cluster: <br><br><ul><li>  Dienstkontotoken - f√ºr Dienstkonten; </li><li>  X509 - f√ºr Benutzer. </li></ul><br>  Die Frage zur Verwaltung von ServiceAccounts geht √ºber den Rahmen dieses Artikels hinaus. Ich empfehle jedoch, auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentationsseite</a> mehr √ºber dieses Problem zu erfahren.  Wir werden das Problem der Arbeit von X509-Zertifikaten genauer betrachten. <br><br><h3>  Zertifikate f√ºr Benutzer (X.509) </h3><br>  Die klassische Art, mit Zertifikaten zu arbeiten, umfasst: <br><br><ul><li>  Schl√ºsselgenerierung: <br><br><pre> <code class="bash hljs">mkdir -p ~/mynewuser/.certs/ openssl genrsa -out ~/.certs/mynewuser.key 2048</code> </pre> </li><li>  Generierung von Zertifikatsanforderungen: <br><br><pre> <code class="bash hljs">openssl req -new -key ~/.certs/mynewuser.key -out ~/.certs/mynewuser.csr -subj <span class="hljs-string"><span class="hljs-string">"/CN=mynewuser/O=company"</span></span></code> </pre> </li><li>  Verarbeiten der Zertifikatanforderung mithilfe von Kubernetes-Cluster-CA-Schl√ºsseln und Abrufen eines Benutzerzertifikats (um ein Zertifikat zu erhalten, m√ºssen Sie ein Konto verwenden, das Zugriff auf den Kubernetes-Clusterzertifikat-Berechtigungsschl√ºssel hat, der sich standardm√§√üig in <code>/etc/kubernetes/pki/ca.key</code> ): <br><br><pre> <code class="bash hljs">openssl x509 -req -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ~/.certs/mynewuser.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out ~/.certs/mynewuser.crt -days 500</code> </pre> </li><li>  Erstellen einer Konfigurationsdatei: <br><ul><li>  Clusterbeschreibung (geben Sie die Adresse und den Speicherort der CA-Zertifikatdatei der jeweiligen Clusterinstallation an): <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-cluster kubernetes --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.100.200:6443</code> </pre> </li><li>  oder - wenn <b>nicht die</b> empfohlene Option - Sie k√∂nnen das Stammzertifikat weglassen (dann pr√ºft kubectl nicht die Richtigkeit des API-Server-Clusters): <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-cluster kubernetes --insecure-skip-tls-verify=<span class="hljs-literal"><span class="hljs-literal">true</span></span> --server=https://192.168.100.200:6443</code> </pre> </li><li>  Hinzuf√ºgen eines Benutzers zur Konfigurationsdatei: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-credentials mynewuser --client-certificate=.certs/mynewuser.crt --client-key=.certs/mynewuser.key</code> </pre> </li><li>  Kontext hinzuf√ºgen: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-context mynewuser-context --cluster=kubernetes --namespace=target-namespace --user=mynewuser</code> </pre> </li><li>  Standardkontextzuweisung: <br><br><pre> <code class="bash hljs">kubectl config use-context mynewuser-context</code> </pre> </li></ul></li></ul><br>  Nach den obigen Manipulationen wird eine Konfiguration des Formulars in der <code>.kube/config</code> Datei erstellt: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: - cluster: certificate-authority: /etc/kubernetes/pki/ca.crt server: https://192.168.100.200:6443 name: kubernetes contexts: - context: cluster: kubernetes namespace: target-namespace user: mynewuser name: mynewuser-context current-context: mynewuser-context kind: Config preferences: {} users: - name: mynewuser user: client-certificate: /home/mynewuser/.certs/mynewuser.crt client-key: /home/mynewuser/.certs/mynewuser.key</code> </pre> <br>  Um die √úbertragung der Konfiguration zwischen Konten und Servern zu erleichtern, ist es hilfreich, die Werte der folgenden Schl√ºssel zu bearbeiten: <br><br><ul><li> <code>certificate-authority</code> </li> <li> <code>client-certificate</code> </li> <li> <code>client-key</code> </li> </ul><br>  Dazu k√∂nnen Sie die darin angegebenen Dateien mit base64 codieren und in der Konfiguration registrieren, indem <code>-data</code> dem Namen der Schl√ºssel das Suffix <code>-data</code> hinzuf√ºgen, d. H.  Abrufen von <code>certificate-authority-data</code> usw. <br><br><h3>  Zertifikate mit kubeadm </h3><br>  Mit der Ver√∂ffentlichung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.15 ist die</a> Arbeit mit Zertifikaten dank der Alpha-Version der Unterst√ºtzung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstprogramm kubeadm</a> viel einfacher geworden.  So k√∂nnte beispielsweise die Generierung einer Konfigurationsdatei mit Benutzerschl√ºsseln jetzt aussehen: <br><br><pre> <code class="bash hljs">kubeadm alpha kubeconfig user --client-name=mynewuser --apiserver-advertise-address 192.168.100.200</code> </pre> <br>  <i><b>Hinweis</b> : Die erforderliche <i>Anzeigenadresse</i> kann standardm√§√üig in der API-Server-Konfiguration unter <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> angezeigt werden.</i> <br><br>  Die resultierende Konfiguration wird an stdout ausgegeben.  Es muss in <code>~/.kube/config</code> Benutzerkontos oder in der in der Umgebungsvariablen <code>KUBECONFIG</code> angegebenen Datei <code>KUBECONFIG</code> . <br><br><h3>  Tiefer graben </h3><br>  F√ºr diejenigen, die die beschriebenen Probleme gr√ºndlich verstehen m√∂chten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen separaten Artikel</a> √ºber die Arbeit mit Zertifikaten in der offiziellen Kubernetes-Dokumentation; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein guter Artikel von Bitnami</a> , der sich aus praktischer Sicht mit der Frage der Zertifikate befasst. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine</a> Authentifizierungsdokumentation in Kubernetes. </li></ul><br><h2>  Login </h2><br>  Ein authentifiziertes Konto hat standardm√§√üig keine Berechtigung, in einem Cluster zu agieren.  Kubernetes verf√ºgt √ºber einen Autorisierungsmechanismus zum Erteilen von Berechtigungen. <br><br>  Vor Version 1.6 verwendete Kubernetes einen Authentifizierungstyp namens <b>ABAC</b> (Attribute-based Access Control).  Details dazu finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> .  Dieser Ansatz wird derzeit als Legacy angesehen, Sie k√∂nnen ihn jedoch gleichzeitig mit anderen Autorisierungsarten verwenden. <br><br>  Die eigentliche (und flexiblere) Art der Aufteilung der Clusterzugriffsrechte wird als <b>RBAC</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Role-based Access Control</a> ) bezeichnet.  Es wurde seit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.8</a> f√ºr stabil erkl√§rt.  RBAC implementiert ein Rechte-Modell, das alles verbietet, was nicht ausdr√ºcklich erlaubt ist. <br>  <b>Um RBAC zu aktivieren</b> , m√ºssen Sie den Kubernetes-API-Server mit der Option <code>--authorization-mode=RBAC</code> .  Die Parameter werden im Manifest mit der API-Server-Konfiguration festgelegt, die sich standardm√§√üig im Pfad <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> im <code>command</code> .  RBAC ist jedoch bereits standardm√§√üig aktiviert, sodass Sie sich dar√ºber wahrscheinlich keine Gedanken machen sollten: Sie k√∂nnen dies anhand des Werts des <code>authorization-mode</code> √ºberpr√ºfen (in der bereits erw√§hnten <code>kube-apiserver.yaml</code> ).  √úbrigens kann es unter seinen Werten andere Arten von Berechtigungen geben ( <code>node</code> , <code>webhook</code> , <code>always allow</code> ), aber wir werden sie au√üerhalb des Bereichs des Materials <code>webhook</code> . <br><br>  √úbrigens haben wir bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> mit einer ziemlich detaillierten Geschichte √ºber die Prinzipien und Merkmale der Arbeit mit RBAC ver√∂ffentlicht, daher beschr√§nke ich mich weiter auf eine kurze Auflistung der Grundlagen und Beispiele. <br><br>  Die folgenden API-Entit√§ten werden verwendet, um den Zugriff auf Kubernetes √ºber RBAC zu steuern: <br><br><ul><li>  <code>Role</code> und <code>ClusterRole</code> sind Rollen, die Berechtigungen beschreiben: </li><li>  <code>Role</code> k√∂nnen Sie Rechte in einem Namespace beschreiben. </li><li>  <code>ClusterRole</code> - innerhalb des Clusters, einschlie√ülich <code>ClusterRole</code> Objekte wie Knoten, Nicht-Ressourcen-URLs (d. H. Nicht in Bezug auf Kubernetes-Ressourcen - z. B. <code>/version</code> , <code>/logs</code> , <code>/api*</code> ); </li><li>  <code>RoleBinding</code> und <code>ClusterRoleBinding</code> - dient zum Binden von <code>Role</code> und <code>ClusterRole</code> an einen Benutzer, eine Benutzergruppe oder ein ServiceAccount. </li></ul><br>  Entities Role und RoleBinding sind durch den Namespace begrenzt, d. H.  muss sich im selben Namespace befinden.  RoleBinding kann sich jedoch auf ClusterRole beziehen, mit dem Sie eine Reihe von Standardberechtigungen erstellen und den Zugriff damit steuern k√∂nnen. <br><br>  Rollen beschreiben Rechte mithilfe von Regels√§tzen, die Folgendes enthalten: <br><br><ul><li>  API-Gruppen - siehe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentation</a> f√ºr apiGroups und die Ausgabe von <code>kubectl api-resources</code> ; </li><li>  Ressourcen ( <i>Ressourcen</i> : <code>pod</code> , <code>namespace</code> , <code>deployment</code> usw.); </li><li>  Verben ( <i>Verben</i> : <code>set</code> , <code>update</code> usw.). </li><li>  Ressourcennamen ( <code>resourceNames</code> ) - f√ºr den Fall, dass Sie Zugriff auf eine bestimmte Ressource und nicht auf alle Ressourcen dieses Typs gew√§hren m√ºssen. </li></ul><br>  Eine ausf√ºhrlichere Beschreibung der Autorisierung in Kubernetes finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentationsseite</a> .  Stattdessen (oder besser gesagt zus√§tzlich) werde ich Beispiele geben, die seine Arbeit veranschaulichen. <br><br><h3>  Beispiele f√ºr RBAC-Entit√§ten </h3><br>  Eine einfache <code>Role</code> , mit der Sie die Liste und den Status von Pods abrufen und im <code>target-namespace</code> √ºberwachen k√∂nnen: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: target-namespace name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "watch", "list"]</code> </pre> <br>  Ein Beispiel f√ºr <code>ClusterRole</code> , mit dem Sie eine Liste und den Status von Pods <code>ClusterRole</code> und im gesamten Cluster √ºberwachen k√∂nnen: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: #  "namespace" ,   ClusterRole    name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "watch", "list"]</code> </pre> <br>  Beispiel f√ºr eine <code>RoleBinding</code> , mit der der Benutzer <code>mynewuser</code> Pods im <code>my-namespace</code> "lesen" kann: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-pods namespace: target-namespace subjects: - kind: User name: mynewuser #     ! apiGroup: rbac.authorization.k8s.io roleRef: kind: Role #    ‚ÄúRole‚Äù  ‚ÄúClusterRole‚Äù name: pod-reader #  Role,      namespace, #   ClusterRole,   #    apiGroup: rbac.authorization.k8s.io</code> </pre> <br><h2>  Ereignispr√ºfung </h2><br>  Schematisch kann die Architektur von Kubernetes wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/617/793/499/6177934998b4bf1c5c8816c75beaef3f.png" alt="Bild"><br><br>  Die Schl√ºsselkomponente von Kubernetes, die f√ºr die Verarbeitung von Anfragen verantwortlich ist, ist der <b>API-Server</b> .  Alle Vorg√§nge im Cluster werden durchlaufen.  Weitere Informationen zu diesen internen Mechanismen finden Sie im Artikel ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was passiert in Kubernetes, wenn der Kubectl-Lauf gestartet wird?</a>  ". <br><br>  Die Systempr√ºfung ist eine interessante Funktion in Kubernetes, die standardm√§√üig deaktiviert ist.  Sie k√∂nnen alle Aufrufe an die Kubernetes-API protokollieren.  Wie Sie leicht erraten k√∂nnen, werden √ºber diese API alle Aktionen ausgef√ºhrt, die sich auf die √úberwachung und √Ñnderung des Status des Clusters beziehen.  Eine gute Beschreibung der Funktionen finden Sie (wie √ºblich) in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen</a> K8- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Als n√§chstes werde ich versuchen, das Thema in einer einfacheren Sprache darzustellen. <br><br>  <b>Um die √úberwachung zu erm√∂glichen</b> , m√ºssen drei erforderliche Parameter an den Container im API-Server √ºbergeben werden. Weitere Informationen hierzu finden Sie weiter unten: <br><br><ul><li> <code>--audit-policy-file=/etc/kubernetes/policies/audit-policy.yaml</code> </li> <li> <code>--audit-log-path=/var/log/kube-audit/audit.log</code> </li> <li> <code>--audit-log-format=json</code> </li> </ul><br>  Zus√§tzlich zu diesen drei erforderlichen Parametern gibt es viele zus√§tzliche Einstellungen f√ºr die √úberwachung: von der Protokollrotation bis zu Webhook-Beschreibungen.  Beispiel f√ºr Protokollrotationsparameter: <br><br><ul><li> <code>--audit-log-maxbackup=10</code> </li> <li> <code>--audit-log-maxsize=100</code> </li> <li> <code>--audit-log-maxage=7</code> </li> </ul><br>  Wir werden jedoch nicht n√§her darauf eingehen - alle Details finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zu kube-apiserver</a> . <br><br>  Wie bereits erw√§hnt, werden alle Parameter im Manifest mit der API-Server-Konfiguration (standardm√§√üig <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> ) im <code>command</code> .  Kehren wir zu den 3 erforderlichen Parametern zur√ºck und analysieren sie: <br><br><ol><li>  <code>audit-policy-file</code> - Pfad zur YAML-Datei mit der Beschreibung der √úberwachungsrichtlinie.  Wir werden zu seinem Inhalt zur√ºckkehren, aber im Moment stelle ich fest, dass die Datei f√ºr den API-Server-Prozess zum Lesen zug√§nglich sein sollte.  Daher muss es im Container bereitgestellt werden, f√ºr den Sie den folgenden Abschnitten der Konfiguration den folgenden Code hinzuf√ºgen k√∂nnen: <br><br><pre> <code class="plaintext hljs"> volumeMounts: - mountPath: /etc/kubernetes/policies name: policies readOnly: true volumes: - hostPath: path: /etc/kubernetes/policies type: DirectoryOrCreate name: policies</code> </pre> </li><li>  <code>audit-log-path</code> - Pfad zur Protokolldatei.  Der Pfad sollte auch f√ºr den API-Server-Prozess zug√§nglich sein. Daher beschreiben wir in √§hnlicher Weise seine Bereitstellung: <br><br><pre> <code class="plaintext hljs"> volumeMounts: - mountPath: /var/log/kube-audit name: logs readOnly: false volumes: - hostPath: path: /var/log/kube-audit type: DirectoryOrCreate name: logs</code> </pre> </li><li>  <code>audit-log-format</code> - Format des √úberwachungsprotokolls.  Standardm√§√üig ist dies <code>json</code> , aber das √§ltere Textformat ist auch verf√ºgbar. </li></ol><br><h3>  Pr√ºfungsrichtlinien </h3><br>  Nun zur genannten Datei mit der Beschreibung der Protokollierungsrichtlinie.  Das erste Konzept der √úberwachungsrichtlinie ist die <code>level</code> , die <b>Ebene der Protokollierung</b> .  Sie sind wie folgt: <br><br><ul><li>  <code>None</code> - nicht protokollieren; </li><li>  <code>Metadata</code> - Protokollanforderungsmetadaten: Benutzer, Anforderungszeit, Zielressource (Pod, Namespace usw.), Aktionstyp (Verb) usw.; </li><li>  <code>Request</code> - Metadaten und <code>Request</code> protokollieren; </li><li>  <code>RequestResponse</code> - <code>RequestResponse</code> Metadaten, Anfragetext und Antworttext. </li></ul><br>  Die letzten beiden Ebenen ( <code>Request</code> und <code>RequestResponse</code> ) protokollieren keine Anforderungen, die nicht auf Ressourcen zugegriffen haben (Aufrufe von sogenannten Nicht-Ressourcen-URLs). <br><br>  Au√üerdem durchlaufen alle Anfragen <b>mehrere Phasen</b> : <br><br><ul><li>  <code>RequestReceived</code> - die Phase, in der die Anforderung vom Handler empfangen wird und noch nicht weiter entlang der Handlerkette √ºbertragen wurde. </li><li>  <code>ResponseStarted</code> - Antwortheader gesendet, jedoch vor dem Senden des Antwortk√∂rpers.  Generiert f√ºr lange Abfragen (z. B. <code>watch</code> ); </li><li>  <code>ResponseComplete</code> - Antworttext gesendet, weitere Informationen werden nicht gesendet. </li><li>  <code>Panic</code> - Ereignisse werden generiert, wenn ein Notfall erkannt wird. </li></ul><br>  Sie k√∂nnen <code>omitStages</code> , um beliebige Phasen zu √ºberspringen. <br><br>  In der Richtliniendatei k√∂nnen wir mehrere Abschnitte mit unterschiedlichen Protokollierungsstufen beschreiben.  Es gilt die erste √úbereinstimmungsregel in der Richtlinienbeschreibung. <br><br>  Der Kubelet-Daemon √ºberwacht die Manifest√§nderung mit der API-Server-Konfiguration und startet den Container mit dem API-Server neu, falls eine solche erkannt wird.  Es gibt jedoch ein wichtiges Detail: <b>Sie ignorieren √Ñnderungen an der Richtliniendatei</b> .  Nachdem Sie √Ñnderungen an der Richtliniendatei vorgenommen haben, m√ºssen Sie den API-Server manuell neu starten.  Da der API-Server als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">statischer Pod ausgef√ºhrt wird</a> , wird er vom Befehl <code>kubectl delete</code> nicht neu <code>kubectl delete</code> .  Sie m√ºssen <code>docker stop</code> manuell auf Kube-Mastern <code>docker stop</code> auf denen die √úberwachungsrichtlinie ge√§ndert wurde: <br><br><pre> <code class="bash hljs">docker stop $(docker ps | grep k8s_kube-apiserver | awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span>)</code> </pre> <br>  Wenn Sie die <b>√úberwachung</b> aktivieren, ist es wichtig zu <b>beachten,</b> dass <b>kube-apiserver eine h√∂here Last hat</b> .  Insbesondere steigt der Speicherverbrauch zum Speichern des Kontextes von Anforderungen.  Die Protokollierung beginnt erst nach dem Senden des Antwortheaders.  Die Auslastung h√§ngt auch von der Konfiguration der √úberwachungsrichtlinie ab. <br><br><h3>  Richtlinienbeispiele </h3><br>  Lassen Sie uns die Struktur von Richtliniendateien anhand von Beispielen analysieren. <br><br>  Hier ist eine einfache <code>policy</code> , um alles auf <code>Metadata</code> zu protokollieren: <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1 kind: Policy rules: - level: Metadata</code> </pre> <br>  Sie k√∂nnen eine Liste von Benutzern ( <code>Users</code> und <code>ServiceAccounts</code> ) und Benutzergruppen in der Richtlinie angeben.  Auf diese Weise ignorieren wir beispielsweise Systembenutzer, protokollieren jedoch alles andere auf <code>Request</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1 kind: Policy rules: - level: None userGroups: - "system:serviceaccounts" - "system:nodes" users: - "system:anonymous" - "system:apiserver" - "system:kube-controller-manager" - "system:kube-scheduler" - level: Request</code> </pre> <br>  Es ist auch m√∂glich, das Ziel zu beschreiben: <br><br><ul><li>  <code>namespaces</code> </li><li>  Verben ( <i>Verben</i> : <code>get</code> , <code>update</code> , <code>delete</code> und andere); </li><li>  Ressourcen ( <i>Ressourcen</i> , n√§mlich: <code>pod</code> , <code>configmaps</code> usw.) und Ressourcengruppen ( <code>apiGroups</code> ). </li></ul><br>  <b>Beachten Sie!</b>  Ressourcen und Ressourcengruppen (API-Gruppen, d. H. ApiGroups) sowie deren im Cluster installierte Versionen k√∂nnen mit den folgenden Befehlen abgerufen werden: <br><br><pre> <code class="bash hljs">kubectl api-resources kubectl api-versions</code> </pre> <br>  Die folgende Pr√ºfungsrichtlinie dient als Demonstration der Best Practices in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alibaba Cloud-Dokumentation</a> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1beta1 kind: Policy #    RequestReceived omitStages: - "RequestReceived" rules: #   ,     : - level: None users: ["system:kube-proxy"] verbs: ["watch"] resources: - group: "" #  api group   ,    #   Kubernetes,  ‚Äúcore‚Äù resources: ["endpoints", "services"] - level: None users: ["system:unsecured"] namespaces: ["kube-system"] verbs: ["get"] resources: - group: "" # core resources: ["configmaps"] - level: None users: ["kubelet"] verbs: ["get"] resources: - group: "" # core resources: ["nodes"] - level: None userGroups: ["system:nodes"] verbs: ["get"] resources: - group: "" # core resources: ["nodes"] - level: None users: - system:kube-controller-manager - system:kube-scheduler - system:serviceaccount:kube-system:endpoint-controller verbs: ["get", "update"] namespaces: ["kube-system"] resources: - group: "" # core resources: ["endpoints"] - level: None users: ["system:apiserver"] verbs: ["get"] resources: - group: "" # core resources: ["namespaces"] #     read-only URLs: - level: None nonResourceURLs: - /healthz* - /version - /swagger* #   ,     ‚Äú‚Äù: - level: None resources: - group: "" # core resources: ["events"] #   Secret, ConfigMap  TokenReview    , #         - level: Metadata resources: - group: "" # core resources: ["secrets", "configmaps"] - group: authentication.k8s.io resources: ["tokenreviews"] #   get, list  watch   ;    - level: Request verbs: ["get", "list", "watch"] resources: - group: "" # core - group: "admissionregistration.k8s.io" - group: "apps" - group: "authentication.k8s.io" - group: "authorization.k8s.io" - group: "autoscaling" - group: "batch" - group: "certificates.k8s.io" - group: "extensions" - group: "networking.k8s.io" - group: "policy" - group: "rbac.authorization.k8s.io" - group: "settings.k8s.io" - group: "storage.k8s.io" #        API - level: RequestResponse resources: - group: "" # core - group: "admissionregistration.k8s.io" - group: "apps" - group: "authentication.k8s.io" - group: "authorization.k8s.io" - group: "autoscaling" - group: "batch" - group: "certificates.k8s.io" - group: "extensions" - group: "networking.k8s.io" - group: "policy" - group: "rbac.authorization.k8s.io" - group: "settings.k8s.io" - group: "storage.k8s.io" #         - level: Metadata</code> </pre> <br><br>  Ein weiteres gutes Beispiel f√ºr eine Pr√ºfungsrichtlinie ist das <a href="">in GCE verwendete Profil</a> . <br><br>  F√ºr eine schnelle Reaktion auf <b>√úberwachungsereignisse kann ein Webhook beschrieben werden</b> .  Dieses Problem wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> offengelegt. Ich werde es au√üerhalb des Geltungsbereichs dieses Artikels belassen. <br><br><h2>  Zusammenfassung </h2><br>  Der Artikel bietet einen √úberblick √ºber grundlegende Sicherheitsmechanismen in Kubernetes-Clustern, mit denen Sie personalisierte Benutzerkonten erstellen, deren Rechte freigeben und deren Aktionen aufzeichnen k√∂nnen.  Ich hoffe, es ist n√ºtzlich f√ºr diejenigen, die in der Theorie oder bereits in der Praxis mit solchen Fragen konfrontiert sind.  Ich empfehle Ihnen auch, sich die Liste anderer Materialien zum Thema Sicherheit in Kubernetes anzusehen, die in der "PS" aufgef√ºhrt ist. Vielleicht finden Sie unter ihnen die erforderlichen Details zu Themen, die f√ºr Sie relevant sind. <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">33+ Kubernetes-Sicherheitstools</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung in die Kubernetes-Netzwerkrichtlinien f√ºr Sicherheitsexperten</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC bei Kubernetes verstehen</a> "; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9 Best Security Practices bei Kubernetes</a> ‚Äú; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11 M√∂glichkeiten, (nicht) ein Opfer von Kubernetes Hacking zu werden</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468679/">https://habr.com/ru/post/de468679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468657/index.html">T√§nze mit Unterst√ºtzung: Arten und Formen der Unterst√ºtzung. Unterst√ºtzungssysteme, die im Kampf arbeiten</a></li>
<li><a href="../de468663/index.html">End2 End Approach in automatischen Spracherkennungsaufgaben</a></li>
<li><a href="../de468665/index.html">Aber ist es Zeit, einen Bew√§sserungsapparat zu kaufen?</a></li>
<li><a href="../de468673/index.html">Workshop "Gew√§hrleistung der Sicherheit personenbezogener Daten" - 3. Oktober, St. Petersburg</a></li>
<li><a href="../de468677/index.html">Die Ank√ºndigung des Smartphones Xiaomi Mi Mix Alpha</a></li>
<li><a href="../de468683/index.html">Theorie und Praxis der Standardisierung von Docker-Diensten</a></li>
<li><a href="../de468687/index.html">Wir analysieren die neuen Initiativen der Zentralbank zur Regulierung des Aktienmarktes: 3 Investorengruppen, Einschr√§nkungen f√ºr Anf√§nger</a></li>
<li><a href="../de468689/index.html">Registrierung Ihres IT-Gesch√§fts in Singapur: Was soll ich tun?</a></li>
<li><a href="../de468691/index.html">Gef√§hrliche Treiber von Drittanbietern auf Ihrem System oder LOLDrivers</a></li>
<li><a href="../de468693/index.html">Wie Automatisierung Walmart-Mitarbeiter zerst√∂rt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>