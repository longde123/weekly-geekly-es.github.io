<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💒 👩🏿‍🚀 🚼 Das ABC der Sicherheit in Kubernetes: Authentifizierung, Autorisierung, Prüfung 👩🏼‍⚖️ 🧘🏿 👨🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Früher oder später wirft der Betrieb eines Systems die Frage nach der Sicherheit auf: Gewährleistung der Authentifizierung, Trennung von Rechten, Prüf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das ABC der Sicherheit in Kubernetes: Authentifizierung, Autorisierung, Prüfung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/468679/"><img src="https://habrastorage.org/webt/ao/pp/ke/aoppkeeufk5-tv1rmtmtw9oce7a.png"><br><br>  Früher oder später wirft der Betrieb eines Systems die Frage nach der Sicherheit auf: Gewährleistung der Authentifizierung, Trennung von Rechten, Prüfung und anderer Aufgaben.  Für Kubernetes wurden bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele Lösungen entwickelt,</a> mit denen auch in sehr anspruchsvollen Umgebungen Standards eingehalten werden können. Das gleiche Material ist grundlegenden Sicherheitsaspekten gewidmet, die im Rahmen der integrierten Mechanismen von K8 implementiert werden.  Zuallererst ist es nützlich für diejenigen, die anfangen, sich mit Kubernetes vertraut zu machen, als Ausgangspunkt für das Studium von Sicherheitsfragen. <a name="habracut"></a><br><br><h2>  Authentifizierung </h2><br>  Kubernetes hat zwei Arten von Benutzern: <br><br><ul><li>  <i>Dienstkonten</i> - Konten, die von der Kubernetes-API verwaltet werden; </li><li>  <i>Benutzer</i> - „normale“ Benutzer, die von externen, unabhängigen Diensten kontrolliert werden. </li></ul><br>  Der Hauptunterschied zwischen diesen Typen besteht darin, dass für Dienstkonten in der Kubernetes-API spezielle Objekte (sie werden als <code>ServiceAccounts</code> ) vorhanden sind, die an den Namespace und den Satz von Berechtigungsdaten gebunden sind, die im Cluster in Objekten vom Typ Secrets gespeichert sind.  Solche Benutzer (Dienstkonten) dienen hauptsächlich zum Verwalten von Zugriffsrechten auf die Kubernetes-API-Prozesse, die in einem Kubernetes-Cluster ausgeführt werden. <br><br>  Normale Benutzer haben keine Einträge in der Kubernetes-API: Sie müssen von externen Mechanismen verwaltet werden.  Sie sind für Personen oder Prozesse gedacht, die außerhalb des Clusters leben. <br><br>  Jede Anforderung an die API ist entweder an das Dienstkonto oder an den Benutzer gebunden oder wird als anonym betrachtet. <br><br>  Zu den Benutzerauthentifizierungsdaten gehören: <br><br><ul><li>  <i>Benutzername</i> - Benutzername (Groß- und Kleinschreibung <i>beachten</i> !); </li><li>  <i>UID</i> ist eine maschinenlesbare Benutzeridentifikationszeichenfolge, die „konsistenter und eindeutiger als der Benutzername“ ist. </li><li>  <i>Gruppen</i> - eine Liste von Gruppen, zu denen der Benutzer gehört; </li><li>  <i>Extra</i> - zusätzliche Felder, die vom Autorisierungsmechanismus verwendet werden können. </li></ul><br>  Kubernetes kann eine Vielzahl von Authentifizierungsmechanismen verwenden: X509-Zertifikate, Inhaber-Token, Authentifizierungs-Proxys, HTTP Basic Auth.  Mit diesen Mechanismen kann eine Vielzahl von Autorisierungsschemata implementiert werden: von einer statischen Datei mit Kennwörtern bis zu OpenID OAuth2. <br><br>  Darüber hinaus sind mehrere Autorisierungsschemata gleichzeitig zulässig.  Standardmäßig verwendet der Cluster: <br><br><ul><li>  Dienstkontotoken - für Dienstkonten; </li><li>  X509 - für Benutzer. </li></ul><br>  Die Frage zur Verwaltung von ServiceAccounts geht über den Rahmen dieses Artikels hinaus. Ich empfehle jedoch, auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentationsseite</a> mehr über dieses Problem zu erfahren.  Wir werden das Problem der Arbeit von X509-Zertifikaten genauer betrachten. <br><br><h3>  Zertifikate für Benutzer (X.509) </h3><br>  Die klassische Art, mit Zertifikaten zu arbeiten, umfasst: <br><br><ul><li>  Schlüsselgenerierung: <br><br><pre> <code class="bash hljs">mkdir -p ~/mynewuser/.certs/ openssl genrsa -out ~/.certs/mynewuser.key 2048</code> </pre> </li><li>  Generierung von Zertifikatsanforderungen: <br><br><pre> <code class="bash hljs">openssl req -new -key ~/.certs/mynewuser.key -out ~/.certs/mynewuser.csr -subj <span class="hljs-string"><span class="hljs-string">"/CN=mynewuser/O=company"</span></span></code> </pre> </li><li>  Verarbeiten der Zertifikatanforderung mithilfe von Kubernetes-Cluster-CA-Schlüsseln und Abrufen eines Benutzerzertifikats (um ein Zertifikat zu erhalten, müssen Sie ein Konto verwenden, das Zugriff auf den Kubernetes-Clusterzertifikat-Berechtigungsschlüssel hat, der sich standardmäßig in <code>/etc/kubernetes/pki/ca.key</code> ): <br><br><pre> <code class="bash hljs">openssl x509 -req -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ~/.certs/mynewuser.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out ~/.certs/mynewuser.crt -days 500</code> </pre> </li><li>  Erstellen einer Konfigurationsdatei: <br><ul><li>  Clusterbeschreibung (geben Sie die Adresse und den Speicherort der CA-Zertifikatdatei der jeweiligen Clusterinstallation an): <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-cluster kubernetes --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.100.200:6443</code> </pre> </li><li>  oder - wenn <b>nicht die</b> empfohlene Option - Sie können das Stammzertifikat weglassen (dann prüft kubectl nicht die Richtigkeit des API-Server-Clusters): <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-cluster kubernetes --insecure-skip-tls-verify=<span class="hljs-literal"><span class="hljs-literal">true</span></span> --server=https://192.168.100.200:6443</code> </pre> </li><li>  Hinzufügen eines Benutzers zur Konfigurationsdatei: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-credentials mynewuser --client-certificate=.certs/mynewuser.crt --client-key=.certs/mynewuser.key</code> </pre> </li><li>  Kontext hinzufügen: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-context mynewuser-context --cluster=kubernetes --namespace=target-namespace --user=mynewuser</code> </pre> </li><li>  Standardkontextzuweisung: <br><br><pre> <code class="bash hljs">kubectl config use-context mynewuser-context</code> </pre> </li></ul></li></ul><br>  Nach den obigen Manipulationen wird eine Konfiguration des Formulars in der <code>.kube/config</code> Datei erstellt: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: - cluster: certificate-authority: /etc/kubernetes/pki/ca.crt server: https://192.168.100.200:6443 name: kubernetes contexts: - context: cluster: kubernetes namespace: target-namespace user: mynewuser name: mynewuser-context current-context: mynewuser-context kind: Config preferences: {} users: - name: mynewuser user: client-certificate: /home/mynewuser/.certs/mynewuser.crt client-key: /home/mynewuser/.certs/mynewuser.key</code> </pre> <br>  Um die Übertragung der Konfiguration zwischen Konten und Servern zu erleichtern, ist es hilfreich, die Werte der folgenden Schlüssel zu bearbeiten: <br><br><ul><li> <code>certificate-authority</code> </li> <li> <code>client-certificate</code> </li> <li> <code>client-key</code> </li> </ul><br>  Dazu können Sie die darin angegebenen Dateien mit base64 codieren und in der Konfiguration registrieren, indem <code>-data</code> dem Namen der Schlüssel das Suffix <code>-data</code> hinzufügen, d. H.  Abrufen von <code>certificate-authority-data</code> usw. <br><br><h3>  Zertifikate mit kubeadm </h3><br>  Mit der Veröffentlichung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.15 ist die</a> Arbeit mit Zertifikaten dank der Alpha-Version der Unterstützung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstprogramm kubeadm</a> viel einfacher geworden.  So könnte beispielsweise die Generierung einer Konfigurationsdatei mit Benutzerschlüsseln jetzt aussehen: <br><br><pre> <code class="bash hljs">kubeadm alpha kubeconfig user --client-name=mynewuser --apiserver-advertise-address 192.168.100.200</code> </pre> <br>  <i><b>Hinweis</b> : Die erforderliche <i>Anzeigenadresse</i> kann standardmäßig in der API-Server-Konfiguration unter <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> angezeigt werden.</i> <br><br>  Die resultierende Konfiguration wird an stdout ausgegeben.  Es muss in <code>~/.kube/config</code> Benutzerkontos oder in der in der Umgebungsvariablen <code>KUBECONFIG</code> angegebenen Datei <code>KUBECONFIG</code> . <br><br><h3>  Tiefer graben </h3><br>  Für diejenigen, die die beschriebenen Probleme gründlich verstehen möchten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen separaten Artikel</a> über die Arbeit mit Zertifikaten in der offiziellen Kubernetes-Dokumentation; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein guter Artikel von Bitnami</a> , der sich aus praktischer Sicht mit der Frage der Zertifikate befasst. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine</a> Authentifizierungsdokumentation in Kubernetes. </li></ul><br><h2>  Login </h2><br>  Ein authentifiziertes Konto hat standardmäßig keine Berechtigung, in einem Cluster zu agieren.  Kubernetes verfügt über einen Autorisierungsmechanismus zum Erteilen von Berechtigungen. <br><br>  Vor Version 1.6 verwendete Kubernetes einen Authentifizierungstyp namens <b>ABAC</b> (Attribute-based Access Control).  Details dazu finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> .  Dieser Ansatz wird derzeit als Legacy angesehen, Sie können ihn jedoch gleichzeitig mit anderen Autorisierungsarten verwenden. <br><br>  Die eigentliche (und flexiblere) Art der Aufteilung der Clusterzugriffsrechte wird als <b>RBAC</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Role-based Access Control</a> ) bezeichnet.  Es wurde seit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.8</a> für stabil erklärt.  RBAC implementiert ein Rechte-Modell, das alles verbietet, was nicht ausdrücklich erlaubt ist. <br>  <b>Um RBAC zu aktivieren</b> , müssen Sie den Kubernetes-API-Server mit der Option <code>--authorization-mode=RBAC</code> .  Die Parameter werden im Manifest mit der API-Server-Konfiguration festgelegt, die sich standardmäßig im Pfad <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> im <code>command</code> .  RBAC ist jedoch bereits standardmäßig aktiviert, sodass Sie sich darüber wahrscheinlich keine Gedanken machen sollten: Sie können dies anhand des Werts des <code>authorization-mode</code> überprüfen (in der bereits erwähnten <code>kube-apiserver.yaml</code> ).  Übrigens kann es unter seinen Werten andere Arten von Berechtigungen geben ( <code>node</code> , <code>webhook</code> , <code>always allow</code> ), aber wir werden sie außerhalb des Bereichs des Materials <code>webhook</code> . <br><br>  Übrigens haben wir bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> mit einer ziemlich detaillierten Geschichte über die Prinzipien und Merkmale der Arbeit mit RBAC veröffentlicht, daher beschränke ich mich weiter auf eine kurze Auflistung der Grundlagen und Beispiele. <br><br>  Die folgenden API-Entitäten werden verwendet, um den Zugriff auf Kubernetes über RBAC zu steuern: <br><br><ul><li>  <code>Role</code> und <code>ClusterRole</code> sind Rollen, die Berechtigungen beschreiben: </li><li>  <code>Role</code> können Sie Rechte in einem Namespace beschreiben. </li><li>  <code>ClusterRole</code> - innerhalb des Clusters, einschließlich <code>ClusterRole</code> Objekte wie Knoten, Nicht-Ressourcen-URLs (d. H. Nicht in Bezug auf Kubernetes-Ressourcen - z. B. <code>/version</code> , <code>/logs</code> , <code>/api*</code> ); </li><li>  <code>RoleBinding</code> und <code>ClusterRoleBinding</code> - dient zum Binden von <code>Role</code> und <code>ClusterRole</code> an einen Benutzer, eine Benutzergruppe oder ein ServiceAccount. </li></ul><br>  Entities Role und RoleBinding sind durch den Namespace begrenzt, d. H.  muss sich im selben Namespace befinden.  RoleBinding kann sich jedoch auf ClusterRole beziehen, mit dem Sie eine Reihe von Standardberechtigungen erstellen und den Zugriff damit steuern können. <br><br>  Rollen beschreiben Rechte mithilfe von Regelsätzen, die Folgendes enthalten: <br><br><ul><li>  API-Gruppen - siehe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentation</a> für apiGroups und die Ausgabe von <code>kubectl api-resources</code> ; </li><li>  Ressourcen ( <i>Ressourcen</i> : <code>pod</code> , <code>namespace</code> , <code>deployment</code> usw.); </li><li>  Verben ( <i>Verben</i> : <code>set</code> , <code>update</code> usw.). </li><li>  Ressourcennamen ( <code>resourceNames</code> ) - für den Fall, dass Sie Zugriff auf eine bestimmte Ressource und nicht auf alle Ressourcen dieses Typs gewähren müssen. </li></ul><br>  Eine ausführlichere Beschreibung der Autorisierung in Kubernetes finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentationsseite</a> .  Stattdessen (oder besser gesagt zusätzlich) werde ich Beispiele geben, die seine Arbeit veranschaulichen. <br><br><h3>  Beispiele für RBAC-Entitäten </h3><br>  Eine einfache <code>Role</code> , mit der Sie die Liste und den Status von Pods abrufen und im <code>target-namespace</code> überwachen können: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: target-namespace name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "watch", "list"]</code> </pre> <br>  Ein Beispiel für <code>ClusterRole</code> , mit dem Sie eine Liste und den Status von Pods <code>ClusterRole</code> und im gesamten Cluster überwachen können: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: #  "namespace" ,   ClusterRole    name: pod-reader rules: - apiGroups: [""] resources: ["pods"] verbs: ["get", "watch", "list"]</code> </pre> <br>  Beispiel für eine <code>RoleBinding</code> , mit der der Benutzer <code>mynewuser</code> Pods im <code>my-namespace</code> "lesen" kann: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-pods namespace: target-namespace subjects: - kind: User name: mynewuser #     ! apiGroup: rbac.authorization.k8s.io roleRef: kind: Role #    “Role”  “ClusterRole” name: pod-reader #  Role,      namespace, #   ClusterRole,   #    apiGroup: rbac.authorization.k8s.io</code> </pre> <br><h2>  Ereignisprüfung </h2><br>  Schematisch kann die Architektur von Kubernetes wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/617/793/499/6177934998b4bf1c5c8816c75beaef3f.png" alt="Bild"><br><br>  Die Schlüsselkomponente von Kubernetes, die für die Verarbeitung von Anfragen verantwortlich ist, ist der <b>API-Server</b> .  Alle Vorgänge im Cluster werden durchlaufen.  Weitere Informationen zu diesen internen Mechanismen finden Sie im Artikel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was passiert in Kubernetes, wenn der Kubectl-Lauf gestartet wird?</a>  ". <br><br>  Die Systemprüfung ist eine interessante Funktion in Kubernetes, die standardmäßig deaktiviert ist.  Sie können alle Aufrufe an die Kubernetes-API protokollieren.  Wie Sie leicht erraten können, werden über diese API alle Aktionen ausgeführt, die sich auf die Überwachung und Änderung des Status des Clusters beziehen.  Eine gute Beschreibung der Funktionen finden Sie (wie üblich) in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen</a> K8- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Als nächstes werde ich versuchen, das Thema in einer einfacheren Sprache darzustellen. <br><br>  <b>Um die Überwachung zu ermöglichen</b> , müssen drei erforderliche Parameter an den Container im API-Server übergeben werden. Weitere Informationen hierzu finden Sie weiter unten: <br><br><ul><li> <code>--audit-policy-file=/etc/kubernetes/policies/audit-policy.yaml</code> </li> <li> <code>--audit-log-path=/var/log/kube-audit/audit.log</code> </li> <li> <code>--audit-log-format=json</code> </li> </ul><br>  Zusätzlich zu diesen drei erforderlichen Parametern gibt es viele zusätzliche Einstellungen für die Überwachung: von der Protokollrotation bis zu Webhook-Beschreibungen.  Beispiel für Protokollrotationsparameter: <br><br><ul><li> <code>--audit-log-maxbackup=10</code> </li> <li> <code>--audit-log-maxsize=100</code> </li> <li> <code>--audit-log-maxage=7</code> </li> </ul><br>  Wir werden jedoch nicht näher darauf eingehen - alle Details finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zu kube-apiserver</a> . <br><br>  Wie bereits erwähnt, werden alle Parameter im Manifest mit der API-Server-Konfiguration (standardmäßig <code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> ) im <code>command</code> .  Kehren wir zu den 3 erforderlichen Parametern zurück und analysieren sie: <br><br><ol><li>  <code>audit-policy-file</code> - Pfad zur YAML-Datei mit der Beschreibung der Überwachungsrichtlinie.  Wir werden zu seinem Inhalt zurückkehren, aber im Moment stelle ich fest, dass die Datei für den API-Server-Prozess zum Lesen zugänglich sein sollte.  Daher muss es im Container bereitgestellt werden, für den Sie den folgenden Abschnitten der Konfiguration den folgenden Code hinzufügen können: <br><br><pre> <code class="plaintext hljs"> volumeMounts: - mountPath: /etc/kubernetes/policies name: policies readOnly: true volumes: - hostPath: path: /etc/kubernetes/policies type: DirectoryOrCreate name: policies</code> </pre> </li><li>  <code>audit-log-path</code> - Pfad zur Protokolldatei.  Der Pfad sollte auch für den API-Server-Prozess zugänglich sein. Daher beschreiben wir in ähnlicher Weise seine Bereitstellung: <br><br><pre> <code class="plaintext hljs"> volumeMounts: - mountPath: /var/log/kube-audit name: logs readOnly: false volumes: - hostPath: path: /var/log/kube-audit type: DirectoryOrCreate name: logs</code> </pre> </li><li>  <code>audit-log-format</code> - Format des Überwachungsprotokolls.  Standardmäßig ist dies <code>json</code> , aber das ältere Textformat ist auch verfügbar. </li></ol><br><h3>  Prüfungsrichtlinien </h3><br>  Nun zur genannten Datei mit der Beschreibung der Protokollierungsrichtlinie.  Das erste Konzept der Überwachungsrichtlinie ist die <code>level</code> , die <b>Ebene der Protokollierung</b> .  Sie sind wie folgt: <br><br><ul><li>  <code>None</code> - nicht protokollieren; </li><li>  <code>Metadata</code> - Protokollanforderungsmetadaten: Benutzer, Anforderungszeit, Zielressource (Pod, Namespace usw.), Aktionstyp (Verb) usw.; </li><li>  <code>Request</code> - Metadaten und <code>Request</code> protokollieren; </li><li>  <code>RequestResponse</code> - <code>RequestResponse</code> Metadaten, Anfragetext und Antworttext. </li></ul><br>  Die letzten beiden Ebenen ( <code>Request</code> und <code>RequestResponse</code> ) protokollieren keine Anforderungen, die nicht auf Ressourcen zugegriffen haben (Aufrufe von sogenannten Nicht-Ressourcen-URLs). <br><br>  Außerdem durchlaufen alle Anfragen <b>mehrere Phasen</b> : <br><br><ul><li>  <code>RequestReceived</code> - die Phase, in der die Anforderung vom Handler empfangen wird und noch nicht weiter entlang der Handlerkette übertragen wurde. </li><li>  <code>ResponseStarted</code> - Antwortheader gesendet, jedoch vor dem Senden des Antwortkörpers.  Generiert für lange Abfragen (z. B. <code>watch</code> ); </li><li>  <code>ResponseComplete</code> - Antworttext gesendet, weitere Informationen werden nicht gesendet. </li><li>  <code>Panic</code> - Ereignisse werden generiert, wenn ein Notfall erkannt wird. </li></ul><br>  Sie können <code>omitStages</code> , um beliebige Phasen zu überspringen. <br><br>  In der Richtliniendatei können wir mehrere Abschnitte mit unterschiedlichen Protokollierungsstufen beschreiben.  Es gilt die erste Übereinstimmungsregel in der Richtlinienbeschreibung. <br><br>  Der Kubelet-Daemon überwacht die Manifeständerung mit der API-Server-Konfiguration und startet den Container mit dem API-Server neu, falls eine solche erkannt wird.  Es gibt jedoch ein wichtiges Detail: <b>Sie ignorieren Änderungen an der Richtliniendatei</b> .  Nachdem Sie Änderungen an der Richtliniendatei vorgenommen haben, müssen Sie den API-Server manuell neu starten.  Da der API-Server als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">statischer Pod ausgeführt wird</a> , wird er vom Befehl <code>kubectl delete</code> nicht neu <code>kubectl delete</code> .  Sie müssen <code>docker stop</code> manuell auf Kube-Mastern <code>docker stop</code> auf denen die Überwachungsrichtlinie geändert wurde: <br><br><pre> <code class="bash hljs">docker stop $(docker ps | grep k8s_kube-apiserver | awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span>)</code> </pre> <br>  Wenn Sie die <b>Überwachung</b> aktivieren, ist es wichtig zu <b>beachten,</b> dass <b>kube-apiserver eine höhere Last hat</b> .  Insbesondere steigt der Speicherverbrauch zum Speichern des Kontextes von Anforderungen.  Die Protokollierung beginnt erst nach dem Senden des Antwortheaders.  Die Auslastung hängt auch von der Konfiguration der Überwachungsrichtlinie ab. <br><br><h3>  Richtlinienbeispiele </h3><br>  Lassen Sie uns die Struktur von Richtliniendateien anhand von Beispielen analysieren. <br><br>  Hier ist eine einfache <code>policy</code> , um alles auf <code>Metadata</code> zu protokollieren: <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1 kind: Policy rules: - level: Metadata</code> </pre> <br>  Sie können eine Liste von Benutzern ( <code>Users</code> und <code>ServiceAccounts</code> ) und Benutzergruppen in der Richtlinie angeben.  Auf diese Weise ignorieren wir beispielsweise Systembenutzer, protokollieren jedoch alles andere auf <code>Request</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1 kind: Policy rules: - level: None userGroups: - "system:serviceaccounts" - "system:nodes" users: - "system:anonymous" - "system:apiserver" - "system:kube-controller-manager" - "system:kube-scheduler" - level: Request</code> </pre> <br>  Es ist auch möglich, das Ziel zu beschreiben: <br><br><ul><li>  <code>namespaces</code> </li><li>  Verben ( <i>Verben</i> : <code>get</code> , <code>update</code> , <code>delete</code> und andere); </li><li>  Ressourcen ( <i>Ressourcen</i> , nämlich: <code>pod</code> , <code>configmaps</code> usw.) und Ressourcengruppen ( <code>apiGroups</code> ). </li></ul><br>  <b>Beachten Sie!</b>  Ressourcen und Ressourcengruppen (API-Gruppen, d. H. ApiGroups) sowie deren im Cluster installierte Versionen können mit den folgenden Befehlen abgerufen werden: <br><br><pre> <code class="bash hljs">kubectl api-resources kubectl api-versions</code> </pre> <br>  Die folgende Prüfungsrichtlinie dient als Demonstration der Best Practices in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alibaba Cloud-Dokumentation</a> : <br><br><pre> <code class="plaintext hljs">apiVersion: audit.k8s.io/v1beta1 kind: Policy #    RequestReceived omitStages: - "RequestReceived" rules: #   ,     : - level: None users: ["system:kube-proxy"] verbs: ["watch"] resources: - group: "" #  api group   ,    #   Kubernetes,  “core” resources: ["endpoints", "services"] - level: None users: ["system:unsecured"] namespaces: ["kube-system"] verbs: ["get"] resources: - group: "" # core resources: ["configmaps"] - level: None users: ["kubelet"] verbs: ["get"] resources: - group: "" # core resources: ["nodes"] - level: None userGroups: ["system:nodes"] verbs: ["get"] resources: - group: "" # core resources: ["nodes"] - level: None users: - system:kube-controller-manager - system:kube-scheduler - system:serviceaccount:kube-system:endpoint-controller verbs: ["get", "update"] namespaces: ["kube-system"] resources: - group: "" # core resources: ["endpoints"] - level: None users: ["system:apiserver"] verbs: ["get"] resources: - group: "" # core resources: ["namespaces"] #     read-only URLs: - level: None nonResourceURLs: - /healthz* - /version - /swagger* #   ,     “”: - level: None resources: - group: "" # core resources: ["events"] #   Secret, ConfigMap  TokenReview    , #         - level: Metadata resources: - group: "" # core resources: ["secrets", "configmaps"] - group: authentication.k8s.io resources: ["tokenreviews"] #   get, list  watch   ;    - level: Request verbs: ["get", "list", "watch"] resources: - group: "" # core - group: "admissionregistration.k8s.io" - group: "apps" - group: "authentication.k8s.io" - group: "authorization.k8s.io" - group: "autoscaling" - group: "batch" - group: "certificates.k8s.io" - group: "extensions" - group: "networking.k8s.io" - group: "policy" - group: "rbac.authorization.k8s.io" - group: "settings.k8s.io" - group: "storage.k8s.io" #        API - level: RequestResponse resources: - group: "" # core - group: "admissionregistration.k8s.io" - group: "apps" - group: "authentication.k8s.io" - group: "authorization.k8s.io" - group: "autoscaling" - group: "batch" - group: "certificates.k8s.io" - group: "extensions" - group: "networking.k8s.io" - group: "policy" - group: "rbac.authorization.k8s.io" - group: "settings.k8s.io" - group: "storage.k8s.io" #         - level: Metadata</code> </pre> <br><br>  Ein weiteres gutes Beispiel für eine Prüfungsrichtlinie ist das <a href="">in GCE verwendete Profil</a> . <br><br>  Für eine schnelle Reaktion auf <b>Überwachungsereignisse kann ein Webhook beschrieben werden</b> .  Dieses Problem wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> offengelegt. Ich werde es außerhalb des Geltungsbereichs dieses Artikels belassen. <br><br><h2>  Zusammenfassung </h2><br>  Der Artikel bietet einen Überblick über grundlegende Sicherheitsmechanismen in Kubernetes-Clustern, mit denen Sie personalisierte Benutzerkonten erstellen, deren Rechte freigeben und deren Aktionen aufzeichnen können.  Ich hoffe, es ist nützlich für diejenigen, die in der Theorie oder bereits in der Praxis mit solchen Fragen konfrontiert sind.  Ich empfehle Ihnen auch, sich die Liste anderer Materialien zum Thema Sicherheit in Kubernetes anzusehen, die in der "PS" aufgeführt ist. Vielleicht finden Sie unter ihnen die erforderlichen Details zu Themen, die für Sie relevant sind. <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">33+ Kubernetes-Sicherheitstools</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung in die Kubernetes-Netzwerkrichtlinien für Sicherheitsexperten</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC bei Kubernetes verstehen</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9 Best Security Practices bei Kubernetes</a> “; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11 Möglichkeiten, (nicht) ein Opfer von Kubernetes Hacking zu werden</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468679/">https://habr.com/ru/post/de468679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468657/index.html">Tänze mit Unterstützung: Arten und Formen der Unterstützung. Unterstützungssysteme, die im Kampf arbeiten</a></li>
<li><a href="../de468663/index.html">End2 End Approach in automatischen Spracherkennungsaufgaben</a></li>
<li><a href="../de468665/index.html">Aber ist es Zeit, einen Bewässerungsapparat zu kaufen?</a></li>
<li><a href="../de468673/index.html">Workshop "Gewährleistung der Sicherheit personenbezogener Daten" - 3. Oktober, St. Petersburg</a></li>
<li><a href="../de468677/index.html">Die Ankündigung des Smartphones Xiaomi Mi Mix Alpha</a></li>
<li><a href="../de468683/index.html">Theorie und Praxis der Standardisierung von Docker-Diensten</a></li>
<li><a href="../de468687/index.html">Wir analysieren die neuen Initiativen der Zentralbank zur Regulierung des Aktienmarktes: 3 Investorengruppen, Einschränkungen für Anfänger</a></li>
<li><a href="../de468689/index.html">Registrierung Ihres IT-Geschäfts in Singapur: Was soll ich tun?</a></li>
<li><a href="../de468691/index.html">Gefährliche Treiber von Drittanbietern auf Ihrem System oder LOLDrivers</a></li>
<li><a href="../de468693/index.html">Wie Automatisierung Walmart-Mitarbeiter zerstört</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>