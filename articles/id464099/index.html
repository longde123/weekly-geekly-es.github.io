<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€ğŸ’» â– ğŸ›’ Analisis Bahasa VKScript: JavaScript, kan? ğŸ“ ğŸ¦“ ğŸ‘©ğŸ¼â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 



 VKScript bukan JavaScript. Semantik bahasa ini pada dasarnya berbeda dari semantik JavaScript. Lihat kesimpulannya . 
 Apa itu VKScript? 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis Bahasa VKScript: JavaScript, kan?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464099/"><h1>  TL; DR </h1><br><hr><br><p>  VKScript <b>bukan</b> JavaScript.  Semantik bahasa ini pada dasarnya berbeda dari semantik JavaScript.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesimpulannya</a> . </p><br><a name="habracut"></a><h1>  Apa itu VKScript? </h1><br><hr><br><p> <b>VKScript</b> adalah bahasa pemrograman scripting JavaScript-seperti yang digunakan dalam VKontakte <code>execute</code> metode API, yang memungkinkan pelanggan mengunduh persis informasi yang mereka butuhkan.  Intinya, VKScript adalah analog GraphQL yang digunakan oleh Facebook untuk tujuan yang sama. </p><br><p>  Bandingkan GraphQL dan VKScript: </p><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  GraphQL </th><th>  VKScript </th></tr><tr><td>  Implementasi </td><td>  Banyak implementasi open-source dalam berbagai bahasa pemrograman </td><td>  Satu-satunya implementasi dalam VK API </td></tr><tr><td>  Berdasarkan </td><td>  Bahasa baru </td><td>  Javascript </td></tr><tr><td>  Kemungkinan </td><td>  Permintaan data, pemfilteran terbatas;  argumen kueri tidak dapat menggunakan hasil dari kueri sebelumnya </td><td>  Setiap post-processing data berdasarkan kebijaksanaan klien;  Permintaan API disajikan dalam bentuk metode dan dapat menggunakan data apa pun dari permintaan sebelumnya </td></tr></tbody></table></div><br><p>  Deskripsi VKScript dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman metode dalam dokumentasi API VK</a> (satu-satunya dokumentasi bahasa resmi): </p><br><blockquote><div class="scrollable-table"><table><tbody><tr><th>  kode </th><td>  kode algoritma dalam <b>VKScript</b> - format yang mirip dengan <b>JavaScript</b> atau <b>ActionScript</b> <i>(diasumsikan kompatibel dengan <b>ECMAScript</b> )</i> .  Algoritme harus diakhiri dengan perintah <b>return% expression%</b> .  Operator harus dipisahkan dengan titik koma. <br>  tali </td></tr></tbody></table></div><br><p>  Yang berikut ini didukung: </p><br><ul><li>  operasi aritmatika </li><li>  operasi logis </li><li>  pembuatan array dan daftar ([X, Y]) </li><li>  <b>parseInt</b> dan <b>parseDouble</b> </li><li>  penggabungan (+) </li><li>  <b>jika</b> membangun </li><li>  filter array dengan parameter (@.) </li><li>  Panggilan metode <b>API</b> , parameter <b>panjang</b> </li><li>  loop menggunakan pernyataan <b>while</b> </li><li>  Metode Javascript: <b>slice</b> , <b>push</b> , <b>pop</b> , <b>shift</b> , <b>unshift</b> , <b>splice</b> , <b>substr</b> , <b>split</b> </li><li>  <b>hapus</b> operator </li><li>  tugas untuk elemen array, misalnya: row.user.action = "test"; </li><li>  cari dalam array atau string - <b>indexOf</b> , misalnya: â€œ123â€ .indexOf (2) = 1, [1, 2, 3] .indexOf (3) = 2. Mengembalikan -1 jika elemen tidak ditemukan. </li></ul><br><p>  Pembuatan fungsi saat ini tidak didukung. </p><br></blockquote><br><p>  Dokumentasi yang dikutip menyatakan bahwa "Kompatibilitas ECMAScript direncanakan."  Tapi benarkah begitu?  Mari kita coba mencari tahu bagaimana bahasa ini bekerja dari dalam. </p><br><br><h1>  Isi </h1><br><hr><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin virtual VKScript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semantik objek VKScript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ol><br><a name="vm"></a><h1>  Mesin virtual VKScript </h1><br><hr><br><p>  Bagaimana suatu program dapat dianalisis dengan tidak adanya salinan lokal?  Itu benar - kirim permintaan ke titik akhir publik dan analisis jawabannya.  Mari kita coba, misalnya, untuk mengeksekusi kode berikut: </p><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Kami mendapatkan <code>Runtime error occurred during code invocation: Too many operations</code> .  Ini menunjukkan bahwa dalam implementasi bahasa ada batasan pada jumlah tindakan yang dilakukan.  Mari kita coba atur nilai batas yang tepat: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><ul><li>  <code>Runtime error occurred during code invocation: Too many operations</code> . </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><ul><li>  <code>{"response": null}</code> - Kode berhasil dijalankan. </li></ul><br><p>  Dengan demikian, batas jumlah operasi adalah sekitar 1000 siklus "idle".  Tetapi, pada saat yang sama, jelas bahwa siklus seperti itu kemungkinan besar bukan operasi "kesatuan".  Mari kita coba menemukan operasi yang tidak dibagi oleh kompiler menjadi beberapa yang lebih kecil. </p><br><p>  Kandidat yang paling jelas untuk peran operasi semacam itu adalah apa yang disebut pernyataan kosong ( <code>;</code> ).  Namun, setelah menambahkan kode dengan <code>i &lt; 999</code> 50 karakter <code>;</code>  , batasnya tidak terlampaui.  Ini berarti bahwa pernyataan kosong dilemparkan oleh kompiler dan tidak membuang operasi, atau satu iterasi dari loop membutuhkan lebih dari 50 operasi (yang, kemungkinan besar, tidak demikian). </p><br><p>  Hal berikutnya yang terlintas dalam pikiran setelah <code>;</code>  - perhitungan beberapa ungkapan sederhana (misalnya, seperti ini: <code>1;</code> ).  Mari kita coba menambahkan beberapa ekspresi ini ke kode kita: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    1; //       "Too many operations"</span></span></code> </pre> <br><p>  Jadi, 2 operasi <code>1;</code>  menghabiskan lebih banyak operasi dari 50 operasi <code>;</code>  .  Ini mengkonfirmasi hipotesis bahwa pernyataan kosong tidak menyia-nyiakan instruksi. </p><br><p>  Mari kita coba untuk mengurangi jumlah iterasi siklus dan tambahkan <code>1;</code> tambahan <code>1;</code>  .  Sangat mudah untuk memperhatikan bahwa untuk setiap iterasi ada 5 tambahan <code>1;</code>  oleh karena itu, satu iterasi siklus menghabiskan operasi 5 kali lebih banyak daripada satu operasi <code>1;</code>  . </p><br><p>  Tetapi apakah ada operasi yang lebih sederhana?  Sebagai contoh, menambahkan operator unary <code>~</code> tidak memerlukan perhitungan ekspresi tambahan, dan operasi itu sendiri dilakukan pada prosesor.  Adalah logis untuk mengasumsikan bahwa menambahkan operasi ini ke ekspresi meningkatkan jumlah total operasi sebesar 1. </p><br><p>  Tambahkan operator ini ke kode kami: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; ~<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  Dan ya, kita dapat menambahkan satu operator seperti itu, dan satu lagi ekspresi <code>1;</code>  - tidak lagi.  Oleh karena itu, <code>1;</code>  benar-benar bukan operator kesatuan. </p><br><p>  Mirip dengan operator <code>1;</code>  , kita akan mengurangi jumlah iterasi dari loop dan menambahkan <code>~</code> operator.  Satu iterasi ternyata setara dengan 10 operasi kesatuan <code>~</code> , oleh karena itu, ekspresi <code>1;</code>  menghabiskan 2 operasi. </p><br><p>  Perhatikan bahwa batasnya adalah sekitar 1000 iterasi, yaitu sekitar 10.000 operasi tunggal.  Kami berasumsi bahwa batasnya persis 10.000 operasi. </p><br><br><h2>  Mengukur jumlah operasi dalam kode </h2><br><hr><br><p>  Perhatikan bahwa sekarang kita dapat mengukur jumlah operasi dalam kode apa pun.  Untuk melakukan ini, tambahkan kode ini setelah loop dan tambahkan / hapus iterasi, <code>~</code> operator, atau seluruh baris terakhir, sampai kesalahan <code>Too many operations</code> hilang. </p><br><p>  Beberapa hasil pengukuran: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Kode </th><th>  Jumlah operasi </th></tr><tr><td> <code>1;</code> </td> <td>  2 </td></tr><tr><td> <code>~1;</code> </td> <td>  3 </td></tr><tr><td> <code>1+1;</code> </td> <td>  4 </td></tr><tr><td> <code>1+1+1;</code> </td> <td>  6 </td></tr><tr><td> <code>(true?1:1);</code> </td> <td>  5 </td></tr><tr><td> <code>(false?1:1);</code> </td> <td>  4 </td></tr><tr><td> <code>if(0)1;</code> </td> <td>  2 </td></tr><tr><td> <code>if(1)1;</code> </td> <td>  4 </td></tr><tr><td> <code>if(0)1;else 1;</code> </td> <td>  4 </td></tr><tr><td> <code>if(1)1;else 1;</code> </td> <td>  5 </td></tr><tr><td> <code>while(0);</code> </td> <td>  2 </td></tr><tr><td> <code>i=1;</code> </td> <td>  3 </td></tr><tr><td> <code>i=i+1;</code> </td> <td>  5 </td></tr><tr><td> <code>var j = 1;</code> </td> <td>  1 </td></tr><tr><td> <code>var j = 0;while(j &lt; 1)j=j+1;</code> </td> <td>  15 </td></tr></tbody></table></div><br><br><h2>  Menentukan jenis mesin virtual </h2><br><hr><br><p>  Pertama, Anda perlu memahami cara kerja juru bahasa VKScript.  Ada dua opsi yang lebih atau kurang masuk akal: </p><br><ul><li>  Interpreter secara rekursif melintasi pohon sintaks dan melakukan operasi pada setiap node. </li><li>  Kompiler menerjemahkan pohon sintaks ke dalam urutan instruksi yang dijalankan oleh penerjemah. </li></ul><br><p>  Sangat mudah untuk memahami bahwa VKScript menggunakan opsi kedua.  Pertimbangkan ungkapannya <code>(true?1:1);</code>  (5 operasi) dan <code>(false?1:1);</code>  (4 operasi).  Dalam hal eksekusi instruksi berurutan, operasi tambahan dijelaskan oleh transisi yang "mem-bypass" pilihan yang salah, dan dalam kasus pemintas AST rekursif, kedua opsi setara untuk penerjemah.  Efek serupa juga terlihat pada if / else dengan kondisi berbeda. </p><br><p>  Perlu juga memperhatikan pasangan <code>i = 1;</code>  (3 operasi) dan <code>var j = 1;</code>  (1 operasi).  Membuat biaya variabel baru hanya 1 operasi, dan menetapkan untuk yang sudah ada biaya 3?  Fakta bahwa membuat operasi biaya variabel 1 (dan, kemungkinan besar, ini adalah operasi pemuatan konstan), mengatakan dua hal: </p><br><ul><li>  Saat membuat variabel baru, tidak ada alokasi memori eksplisit untuk variabel. </li><li>  Saat membuat variabel baru, nilai tidak dimuat ke dalam sel memori.  Ini berarti bahwa ruang untuk variabel baru dialokasikan di mana nilai ekspresi dihitung, dan setelah itu memori ini dianggap dialokasikan.  Ini menunjukkan penggunaan mesin stack. </li></ul><br><p>  Menggunakan tumpukan juga menjelaskan bahwa ekspresi <code>var j = 1;</code>  berjalan lebih cepat dari ekspresi <code>1;</code>  : ekspresi terakhir menghabiskan instruksi tambahan untuk menghapus nilai yang dihitung dari tumpukan. </p><br><br><h2>  Menentukan nilai batas yang tepat </h2><br><p>  Perhatikan bahwa siklus <code>var j=0;while(j &lt; 1)j=j+1;</code>  (15 operasi) adalah salinan kecil dari siklus yang digunakan untuk pengukuran: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Kode </th><th>  Jumlah operasi </th></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </td><td>  15 </td></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </td><td>  15 + 998 * 10 = 9995 </td></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; ~<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  (batas) </td><td>  9998 </td></tr></tbody></table></div><br><p>  Hentikan apa?  Apakah ada batasan 9998 instruksi?  Kami jelas kehilangan sesuatu ... </p><br><p>  Perhatikan bahwa kode <code>return 1;</code> adalah <code>return 1;</code>  dilakukan sesuai dengan pengukuran untuk 0 instruksi.  Ini mudah dijelaskan: kompiler menambahkan <code>return null;</code> implisit di akhir kode <code>return null;</code>  , dan ketika menambahkan pengembaliannya gagal.  Dengan asumsi bahwa batasnya adalah 10.000, kami menyimpulkan bahwa operasi <code>return null;</code>  mengambil 2 instruksi (mungkin ini sesuatu seperti <code>push null; return;</code> ). </p><br><br><h2>  Blok Kode Bersarang </h2><br><hr><br><p>  Mari kita lakukan beberapa pengukuran lagi: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Kode </th><th>  Jumlah operasi </th></tr><tr><td> <code>{};</code> </td> <td>  0 </td></tr><tr><td> <code>{var j = 1;};</code> </td> <td>  2 </td></tr><tr><td> <code>{var j = 1, k = 2;};</code> </td> <td>  3 </td></tr><tr><td> <code>{var j = 1; var k = 2;};</code> </td> <td>  3 </td></tr><tr><td> <code>var j = 1; var j = 1;</code> </td> <td>  4 </td></tr><tr><td> <code>{var j = 1;}; var j = 1;</code> </td> <td>  3 </td></tr></tbody></table></div><br><p>  Mari kita perhatikan fakta-fakta berikut: </p><br><ul><li>  Menambahkan variabel ke blok membutuhkan satu operasi ekstra. </li><li>  Ketika "mendeklarasikan variabel lagi" deklarasi kedua memenuhi sebagai tugas normal. </li><li>  Tetapi pada saat yang sama, variabel di dalam blok tidak terlihat dari luar (lihat contoh terakhir). </li></ul><br><p>  Sangat mudah untuk memahami bahwa operasi tambahan dihabiskan untuk menghapus variabel lokal yang dinyatakan dalam blok dari stack.  Dengan demikian, ketika tidak ada variabel lokal, tidak ada yang perlu dihapus. </p><br><br><h1>  Objek, Metode, Panggilan API </h1><br><hr><br><div class="scrollable-table"><table><tbody><tr><th>  Kode </th><th>  Jumlah operasi </th></tr><tr><td> <code>"";</code> </td> <td>  2 </td></tr><tr><td> <code>"abcdef";</code> </td> <td>  2 </td></tr><tr><td> <code>{};</code> </td> <td>  2 </td></tr><tr><td> <code>[];</code> </td> <td>  2 </td></tr><tr><td> <code>[1, 2, 3];</code> </td> <td>  5 </td></tr><tr><td> <code>{a: 1, b: 2, c: 3};</code> </td> <td>  5 </td></tr><tr><td> <code>API.users.isAppUser(1);</code> </td> <td>  3 </td></tr><tr><td> <code>"".substr(0, 0);</code> </td> <td>  6 </td></tr><tr><td> <code>var j={};jx=1;</code> </td> <td>  6 </td></tr><tr><td> <code>var j={x:1};delete jx;</code> </td> <td>  6 </td></tr></tbody></table></div><br><p>  Mari kita menganalisis hasilnya.  Anda mungkin memperhatikan bahwa membuat string dan objek / array kosong membutuhkan 2 operasi, seperti halnya memuat angka.  Saat membuat array atau objek yang tidak kosong, operasi yang dihabiskan untuk memuat elemen array / objek ditambahkan.  Ini menunjukkan bahwa secara langsung membuat objek terjadi dalam satu operasi.  Pada saat yang sama, tidak ada waktu yang terbuang untuk mengunduh nama properti, oleh karena itu, mengunduhnya adalah bagian dari operasi pembuatan objek. </p><br><p>  Dengan pemanggilan metode API, semuanya juga sangat umum - memuat unit, memanggil metode, <code>pop</code> hasilnya (Anda dapat melihat bahwa nama metode diproses secara keseluruhan, dan bukan sebagai mengambil properti).  Tetapi tiga contoh terakhir terlihat menarik. </p><br><ul><li> <code>"".substr(0, 0);</code>  - Memuat string, memuat nol, memuat nol, hasil <code>pop</code> .  Karena suatu alasan, ada 2 instruksi untuk memanggil metode (untuk beberapa alasan, lihat di bawah). </li><li> <code>var j={};jx=1;</code>  - membuat objek, memuat objek, memuat unit, unit <code>pop</code> setelah penugasan.  Sekali lagi, ada 2 instruksi untuk penugasan. </li><li> <code>var j={x:1};delete jx;</code>  - Memuat unit, membuat objek, memuat objek, menghapus.  Ada 3 instruksi per operasi penghapusan. </li></ul><br><br><a name="semantics"></a><br><h1>  Semantik objek VKScript </h1><br><h2>  Angka-angka </h2><br><hr><br><p>  Kembali ke pertanyaan awal: apakah VKScript adalah subset dari JavaScript atau bahasa lain?  Mari kita lakukan tes sederhana: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000000</span></span> + <span class="hljs-number"><span class="hljs-number">2000000000</span></span>;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-number"><span class="hljs-number">-1294967296</span></span>};</code> </pre> <br><p>  Seperti yang dapat kita lihat, penambahan bilangan bulat menyebabkan overflow, meskipun fakta bahwa JavaScript tidak memiliki bilangan bulat seperti itu.  Juga mudah untuk memverifikasi bahwa membagi dengan 0 menyebabkan kesalahan, dan tidak mengembalikan <code>Infinity</code> . </p><br><br><h2>  Benda-benda </h2><br><hr><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {};</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: []}</code> </pre> <br><p>  Hentikan apa?  Kami mengembalikan <i>objek</i> dan mendapatkan <i>array</i> ?  Ya, benar.  Dalam VKScript, array dan objek diwakili oleh tipe yang sama, khususnya, objek kosong dan array kosong adalah satu dan sama.  Dalam hal ini, properti <code>length</code> objek bekerja dan mengembalikan jumlah properti. </p><br><p>  Sangat menarik untuk melihat bagaimana metode daftar berperilaku jika Anda memanggilnya pada suatu objek? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Metode <code>pop</code> mengembalikan properti yang terakhir dinyatakan, yang, bagaimanapun, adalah logis.  Ubah urutan properti: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">b</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Rupanya, objek dalam VKScript mengingat urutan properti yang ditugaskan.  Mari kita coba gunakan properti numerik: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">'0'</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Sekarang mari kita lihat bagaimana push bekerja: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>:<span class="hljs-string"><span class="hljs-string">'c'</span></span>}; a.push(<span class="hljs-string"><span class="hljs-string">'d'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"3"</span></span>: <span class="hljs-string"><span class="hljs-string">"d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>};</code> </pre> <br><p>  Seperti yang Anda lihat, metode push mengurutkan tombol angka dan menambahkan nilai baru setelah tombol angka terakhir.  "Lubang" tidak diisi dalam kasus ini. </p><br><p>  Sekarang coba gabungkan dua metode ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>:<span class="hljs-string"><span class="hljs-string">'c'</span></span>}; a.push(a.pop()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"3"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>};</code> </pre> <br><p>  Seperti yang kita lihat, elemen belum dihapus dari array.  Namun, jika kita menempatkan <code>push</code> dan <code>pop</code> di baris yang berbeda, bug akan hilang.  Kita harus masuk lebih dalam! </p><br><br><h2>  Penyimpanan Objek </h2><br><hr><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = x; xy = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: []}</code> </pre> <br><p>  Ternyata, objek dalam VKScript disimpan dengan nilai, tidak seperti JavaScript.  Sekarang kita melihat perilaku aneh dari string <code>a.push(a.pop());</code>  - rupanya, nilai lama array disimpan di stack, dari tempat kemudian diambil. </p><br><p>  Namun, bagaimana data disimpan dalam objek jika metode memodifikasinya?  Rupanya, instruksi "ekstra" saat memanggil metode ini dirancang khusus untuk menulis perubahan kembali ke objek. </p><br><br><h2>  Metode Array </h2><br><hr><br><div class="scrollable-table"><table><tbody><tr><th>  Metode </th><th>  Aksi </th></tr><tr><td> <code>push</code> </td> <td><ul><li>  urutkan kunci numerik berdasarkan nilai </li><li>  ambil kunci angka maksimum, tambahkan satu </li><li>  tulis argumen ke array </li><li>  tambahkan kunci non-numerik ke akhir array </li></ul></td></tr><tr><td> <code>pop</code> </td> <td>  Hapus elemen terakhir dari array (tidak harus dengan kunci numerik) dan kembali. </td></tr><tr><td>  sisanya </td><td><ul><li>  mengurutkan kunci numerik berdasarkan nilai, menghapus "lubang" dalam array </li><li>  melakukan operasi javascript yang sesuai </li><li>  tambahkan kunci non-numerik ke akhir array </li></ul><br><p>  Saat menggunakan metode slice, perubahan tidak disimpan </p><br></td></tr></tbody></table></div><br><a name="summary"></a><h1>  Kesimpulan </h1><br><hr><br><p>  VKScript bukan JavaScript.  Tidak seperti JavaScript, objek di dalamnya disimpan oleh nilai, bukan oleh referensi, dan memiliki semantik yang sama sekali berbeda.  Namun, ketika menggunakan VKScript untuk tujuan yang dimaksudkan, perbedaannya tidak terlihat. </p><br><br><h1>  Semantik PS operator </h1><br><hr><br><p>  Komentar yang disebutkan menggabungkan objek melalui <code>+</code> .  Dalam hal ini, saya memutuskan untuk menambahkan informasi tentang pekerjaan operator. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Operator </th><th>  Tindakan </th></tr><tr><td>  + </td><td><ul><li>  Jika kedua argumen adalah objek, buat salinan objek pertama dan tambahkan kunci dari argumen kedua (dengan penggantian). </li><li>  Jika kedua argumen adalah angka, tambahkan sebagai angka. </li><li>  Jika tidak, kedua operan dilemparkan ke string dan ditambahkan sebagai string. </li></ul></td></tr><tr><td>  Operator aritmatika lainnya </td><td>  Kedua operan dilemparkan ke nomor, dan operasi yang sesuai dilakukan.  Untuk operasi bit, operan juga ditambahkan ke <code>int</code> . </td></tr><tr><td>  Operator pembanding </td><td>  Jika dua string atau dua angka dibandingkan, mereka dibandingkan secara langsung.  Jika string dan angka dibandingkan, dan string adalah notasi yang benar untuk nomor tersebut, string tersebut dilemparkan ke angka.  Jika tidak, <code>Comparing values of different or unsupported types</code> kesalahan dikembalikan. </td></tr><tr><td>  Cast ke string </td><td>  Angka dan string diberikan seperti dalam JavaScript.  Objek terdaftar sebagai daftar nilai yang dipisahkan koma dalam urutan tombol.  <code>false</code> dan <code>null</code> dilemparkan sebagai <code>""</code> , <code>true</code> dilemparkan sebagai <code>"1"</code> . </td></tr><tr><td>  Diputar ke </td><td>  Jika argumennya adalah string yang merupakan notasi angka yang valid, nomor tersebut dikembalikan.  Kalau tidak, kesalahan <code>Numeric arguments expected</code> dikembalikan. </td></tr></tbody></table></div><br><p>  Untuk operasi dengan angka (kecuali untuk bit), jika operan <code>int</code> dan <code>double</code> , <code>int</code> <code>double</code> ke <code>double</code> .  Jika kedua operan <code>int</code> , operasi dilakukan pada bilangan bulat 32-bit yang telah ditandatangani (dengan overflow). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464099/">https://habr.com/ru/post/id464099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464089/index.html">Mengotomatiskan permintaan HTTP dalam konteks Spring</a></li>
<li><a href="../id464091/index.html">Intisari materi menarik untuk pengembang ponsel # 311 (pada 12 - 18 Agustus)</a></li>
<li><a href="../id464093/index.html">Barang digital: apa yang harus dilakukan jika pelanggan datang untuk melakukan pembelian dalam setahun?</a></li>
<li><a href="../id464095/index.html">Getters and Setters di Dart and Flutter</a></li>
<li><a href="../id464097/index.html">Evolusi kecerdasan: mengapa robot membutuhkan emosi</a></li>
<li><a href="../id464103/index.html">OpenUNB konsep standar IoT nasional: tinjauan kritis</a></li>
<li><a href="../id464105/index.html">Server Commento Asli dengan Docker Compose</a></li>
<li><a href="../id464107/index.html">Acara digital di Moskow dari 19 hingga 25 Agustus</a></li>
<li><a href="../id464109/index.html">Ruang Parasut Supersonik</a></li>
<li><a href="../id464111/index.html">Natas Web. Passage dari platform KKP bertujuan untuk mengeksploitasi kerentanan Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>