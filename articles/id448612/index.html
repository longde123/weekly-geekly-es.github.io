<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóØÔ∏è üëù üçÇ Apa yang dibekukan pada pembekuan fitur 2019. Bagian I. JSONPath ‚ÜòÔ∏è üôçüèæ ü§∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah panitia 2019-03 , pembekuan fitur terjadi. Kami memiliki kolom yang hampir tradisional di sini: kami sudah menulis tentang pembekuan tahun lal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang dibekukan pada pembekuan fitur 2019. Bagian I. JSONPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448612/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/kw/ra/ylkwraooftas8s1ft0ik4pgn5tc.jpeg"></div><br>  Setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>panitia 2019-03</b></a> , pembekuan fitur terjadi.  Kami memiliki kolom yang hampir tradisional di sini: kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah menulis</a> tentang pembekuan tahun lalu.  Sekarang, hasil 2019: yang mana dari yang baru akan dimasukkan dalam PostgreSQL 12. Dalam bagian tinjauan JSONPath ini, contoh dan fragmen dari laporan "Postgres 12 in Etudes", yang dibaca Oleg Bartunov di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saint Highload ++</a> di St. Petersburg pada 9 April tahun ini, digunakan. <br><a name="habracut"></a><br><h2>  Jsonpath </h2><br>  Semua yang terkait dengan JSON (B) relevan, diminati di dunia, di Rusia, dan ini adalah salah satu bidang pengembangan terpenting di Postgres Professional.  Jenis jsonb, fungsi dan operator untuk bekerja dengan JSON / JSONB muncul dalam versi PostgreSQL 9.4, mereka dibuat oleh tim yang dipimpin oleh Oleg Bartunov. <br><br>  Standar SQL / 2016 menyediakan untuk bekerja dengan JSON: JSONPath disebutkan di sana - satu set alat pengalamatan data di dalam JSON;  JSONTABLE - cara mengubah JSON ke tabel biasa;  Keluarga besar fungsi dan operator.  Terlepas dari kenyataan bahwa JSON di Postgres telah didukung sejak lama, pada 2017 Oleg Bartunov dan rekan-rekannya mulai berupaya mendukung standar tersebut.  Mematuhi standar selalu baik.  Dari semua yang dijelaskan dalam standar, hanya satu tetapi tambalan yang paling penting adalah JSONPath di versi 12, jadi kita akan membicarakannya terlebih dahulu. <br><br>  Di zaman kuno, orang menggunakan JSON, menyimpannya di bidang teks.  Di 9.3, tipe data khusus untuk JSON muncul, tetapi fungsionalitas yang terkait dengannya tidak kaya, dan permintaan dengan tipe ini bekerja lambat karena waktu yang dihabiskan untuk mem-parsing representasi teks JSON.  Ini menghentikan banyak pengguna Postgres potensial yang lebih suka database NoSQL.  Produktivitas Postgres meningkat pada 9,4 ketika, berkat O. Bartunov, A. Korotkov dan F. Sigaev, Postgres memperkenalkan versi biner JSON - tipe jsonb. <br>  jsonb tidak perlu diurai setiap saat, jadi bekerja dengannya jauh lebih cepat.  Dari fungsi dan operator baru yang muncul pada saat yang sama, beberapa hanya bekerja dengan tipe biner yang baru, seperti operator penting dari kejadian <b>@&gt;</b> , yang memeriksa apakah elemen atau array termasuk dalam JSONB yang diberikan: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, 3]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  memberikan TRUE, karena array di sisi kanan memasuki array di sebelah kiri.  Tapi <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, [1, 3]]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  akan memberikan FALSE, karena tingkat sarang berbeda, ia harus ditetapkan secara eksplisit.  Apakah operator keberadaan diperkenalkan untuk tipe jsonb <b>?</b>  (tanda tanya) yang memeriksa apakah string adalah kunci objek atau elemen array di tingkat atas nilai JSONB, serta dua operator serupa lainnya (perincian di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Mereka didukung oleh indeks GIN dengan dua kelas operator GIN.  Operator <b>-&gt;</b> (panah) memungkinkan Anda untuk "menavigasi" melalui JSONB, ia mengembalikan nilai dengan kunci atau, jika itu adalah array, dengan indeks.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> operator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lagi</a> untuk bergerak.  Tetapi tidak ada cara untuk mengatur filter yang bekerja serupa dengan DIMANA.  Itu adalah terobosan: terima kasih kepada jsonb, Postgres mulai tumbuh dalam popularitas sebagai RDBMS dengan fitur NoSQL. <br><br>  Pada tahun 2014, A. Korotkov, O. Bartunov dan F. Sigaev mengembangkan ekstensi jsquery, yang dimasukkan sebagai hasil dalam Postgres Pro Standard 9.5 (dan kemudian versi Standard and Enterprise).  Ini menyediakan fitur tambahan yang sangat luas untuk bekerja dengan json (b).  Ekstensi ini mendefinisikan bahasa permintaan untuk mengekstraksi data dari json (b) dan indeks untuk mempercepat permintaan ini.  Fungsionalitas ini diperlukan oleh pengguna, mereka tidak siap untuk menunggu standar dan dimasukkannya fitur baru dalam versi vanilla.  Nilai praktisnya juga dibuktikan dengan fakta bahwa pengembangan itu disponsori oleh Wargaming.net.  Ekstensi mengimplementasikan tipe khusus - jsquery. <br><br>  Kueri dalam bahasa ini ringkas dan terlihat, misalnya, seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'{"apt":[{"no": 1, "rooms":2}, {"no": 2, "rooms":3}, {"no": 3, "rooms":2}]}'</span></span>::jsonb @@ <span class="hljs-string"><span class="hljs-string">'apt.#.rooms=3'</span></span>::jsquery;</code> </pre> <br>  Kami bertanya di sini apakah ada "tiga rubel" di gedung apartemen.  Tipe jsquery harus ditentukan karena operator @@ sekarang juga dalam tipe jsonb.  Deskripsi ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , dan presentasi dengan banyak contoh ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Total: Postgres sudah memiliki segalanya untuk bekerja dengan JSON, dan kemudian muncul standar SQL: 2016.  Ternyata semantiknya tidak begitu berbeda dengan semantik kita dalam ekstensi jsquery.  Ada kemungkinan bahwa penulis standar bahkan melirik jsquery, menciptakan JSONPath.  Tim kami harus menerapkan sedikit berbeda dari apa yang sudah kami miliki dan, tentu saja, banyak hal baru juga. <br><br>  Lebih dari setahun yang lalu, pada commitfest bulan Maret, buah dari upaya pemrograman kami ditawarkan kepada komunitas dalam bentuk 3 tambalan besar dengan dukungan untuk standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SQL: 2016</a> : <br><br>  SQL / JSON: JSONPath; <br>  SQL / JSON: fungsi; <br>  SQL / JSON: JSON_TABLE. <br><br>  Tetapi untuk mengembangkan tambalan bukan keseluruhan bisnis, mempromosikannya juga tidak mudah, terutama jika tambalan itu besar dan memengaruhi banyak modul.  Banyak iterasi revisi revisi diperlukan, tambalan harus dipromosikan, seperti halnya perusahaan komersial, menginvestasikan banyak sumber daya (jam kerja).  Kepala arsitek Postgres Professional, Alexander Korotkov, mengambilnya sendiri (karena dia sekarang memiliki status committer) dan mengamankan adopsi patch JSONPath - yang utama dalam rangkaian patch ini.  Yang kedua dan ketiga sekarang dalam status Tinjauan Kebutuhan.  JSONPath yang terfokus memungkinkan Anda untuk bekerja dengan struktur JSON (B) dan cukup fleksibel untuk menyoroti bagian-bagiannya.  Dari 15 poin yang ditentukan dalam standar, 14 diimplementasikan, dan ini lebih dari pada Oracle, MySQL dan MS SQL. <br><br>  Notasi JSONPath berbeda dari pernyataan Postgres untuk bekerja dengan notasi JSON dan JSQuery.  Hirarki ditunjukkan oleh titik-titik: <br><br>  $ .abc (dalam notasi postgres 11, saya harus menulis 'a' -&gt; 'b' -&gt; 'c'); <br>  $ - konteks elemen saat ini - pada kenyataannya, ekspresi dengan $ mendefinisikan wilayah json (b) yang akan diproses, termasuk yang ada di filter, sisanya tidak tersedia untuk pekerjaan; <br>  @ - konteks saat ini dalam ekspresi filter - iterates atas jalur yang tersedia dalam ekspresi dengan $; <br>  [*] - sebuah array; <br>  * - wildcard, dalam ekspresi dengan $ atau @ berarti nilai segmen path apa pun, tetapi memperhitungkan hierarki; <br>  ** - sebagai bagian dari ekspresi dengan $ atau @ dapat berarti setiap nilai segmen path tanpa memperhitungkan hierarki - akan lebih mudah untuk menggunakannya jika Anda tidak mengetahui tingkat elemen yang bersarang; <br>  operator "?"  memungkinkan Anda mengatur filter yang mirip dengan WHERE: <br>  $ .abc?  (@ .x&gt; 10); <br>  $ .abcxtype (), juga size (), double (), ceiling (), floor (), abs (), datetime (), keyvalue () adalah metode. <br>  Kueri dengan fungsi jsonb_path_query (tentang fungsi di bawah) mungkin terlihat seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; 3)'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [4, 5] (1 row)</span></span></code> </pre> <br>  Meskipun tambalan khusus dengan fungsi tidak dilakukan, tambalan JSONPath sudah memiliki fungsi utama untuk bekerja dengan JSON (B): <br><br><br><pre> <code class="sql hljs">jsonb_path_exists('{"a": 1}', '$.a')  true (  "?") jsonb_path_exists('{"a": 1}', '$.b')  false jsonb_path_match('{"a": 1}', '$.a == 1')  true (  "@&gt;") jsonb_path_match('{"a": 1}', '$.a &gt;= 2')  false jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3, 4, 5 jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  0  jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  [3, 4, 5] jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  [] jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3 jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  NULL</code> </pre> <br>  Perhatikan bahwa persamaan dalam ekspresi JSONPath adalah satu "=", sedangkan di jsquery itu ganda: "==". <br><br>  Untuk ilustrasi yang lebih elegan, kami akan menghasilkan JSONB dalam satu pelat kolom rumah: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> house(js jsonb); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'{ "address": { "city":"Moscow", "street": "Ulyanova, 7A" }, "lift": false, "floor": [ { "level": 1, "apt": [ {"no": 1, "area": 40, "rooms": 1}, {"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2} ] }, { "level": 2, "apt": [ {"no": 4, "area": 100, "rooms": 3}, {"no": 5, "area": 60, "rooms": 2} ] } ] }'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/u6/ob/nb/u6obnbokethtz5gatlcbdtvhjyi.png"><br>  <i>Gambar. 1 Perumahan pohon JSON dengan apartemen daun yang dialokasikan.</i> <br><br>  Ini adalah JSON yang aneh: ia memiliki hierarki yang membingungkan, tetapi diambil dari kehidupan, dan dalam kehidupan sering diperlukan untuk bekerja dengan apa yang ada, dan bukan dengan apa yang seharusnya.  Berbekal kemampuan versi baru, kami akan menemukan apartemen di lantai 1 dan 2, tetapi bukan yang pertama dalam daftar apartemen lantai (di pohon yang disorot dengan warna hijau): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(js, <span class="hljs-string"><span class="hljs-string">'$.floor[0, 1].apt[1 to last]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; <span class="hljs-comment"><span class="hljs-comment">--------------------- [{"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2}, {"no": 5, "area": 60, "rooms": 2}]</span></span></code> </pre><br>  Di PostgreSQL 11, Anda harus menanyakan ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_agg(apt) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> apt-&gt;generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, jsonb_array_length(apt) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> js-&gt;<span class="hljs-string"><span class="hljs-string">'floor'</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])-&gt;<span class="hljs-string"><span class="hljs-string">'apt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house ) apts(apt) ) apts(apt);</code> </pre> <br>  Sekarang pertanyaan yang sangat sederhana: apakah ada baris yang berisi (di mana saja) nilai "Moskow"?  Sangat sederhana: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_exists(js, <span class="hljs-string"><span class="hljs-string">'$.** ? (@ == "Moscow")'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house;</code> </pre> <br>  Di versi 11, Anda harus menulis skrip besar: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RECURSIVE</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(kv.value, e.value) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_each ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) kv <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_array_elements ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'array'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) e <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> kv.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> e.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'"Moscow"'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/1k/uv/go/1kuvgo4f2bnjj_aylnvej76gltc.png"><br>  <i>2 Pohon Perumahan JSON, Moskow ditemukan!</i> <br><br>  Kami mencari apartemen apa pun di lantai apa pun dengan luas 40 hingga 90 meter persegi: <br><br><pre> <code class="plaintext hljs">select jsonb_path_query(js, '$.floor[*].apt[*] ? (@.area &gt; 40 &amp;&amp; @.area &lt; 90)') FROM house; jsonb_path_query ----------------------------------- {"no": 2, "area": 80, "rooms": 3} {"no": 3, "area": 50, "rooms": 2} {"no": 5, "area": 60, "rooms": 2} (3 rows)</code> </pre><br>  Kami mencari apartemen dengan kamar setelah tanggal 3, menggunakan jason perumahan kami: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 4 5 (2 rows)</span></span></code> </pre> <br>  Dan inilah cara jsonb_path_query_first bekerja: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_first(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query_first <span class="hljs-comment"><span class="hljs-comment">------------------------ 4 (1 row)</span></span></code> </pre> <br>  Kami melihat bahwa hanya nilai pertama yang dipilih yang memenuhi kondisi filter. <br><br>  Operator Boolean JSONPath untuk JSONB @@ disebut operator yang cocok.  Itu menghitung predikat JSONPath dengan memanggil fungsi jsonb_path_match_opr. <br><br>  Operator boolean lain adalah @?  - ini adalah tes keberadaan, menjawab pertanyaan apakah ekspresi JSONPath akan mengembalikan objek SQL / JSON, ia memanggil fungsi jsonb_path_exists_opr: <br><br><pre> <code class="sql hljs"> '[1,2,3]' @@ '$[*] == 3'  true;  '[1,2,3]' @? '$[*] @? (@ == 3)' -  true</code> </pre> <br>  Hasil yang sama dapat dicapai dengan menggunakan berbagai operator: <br><br><pre> <code class="sql hljs">js @? '$.a'  js @@ 'exists($.a)' js @@ '$.a == 1'  js @? '$ ? ($.a == 1)'</code> </pre> <br>  Keindahan operator JSONPath Boolean adalah bahwa mereka didukung, dipercepat oleh indeks GIN.  jsonb_ops dan jsonb_path_ops adalah kelas operator yang sesuai.  Pada contoh, kita menonaktifkan SEQSCAN, karena kita memiliki mikrotabel, pada tabel besar pengoptimal itu sendiri akan memilih Indeks Bitmap: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ENABLE_SEQSCAN <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gin (js); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (COSTS <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> js @? <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.rooms == 3)'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on house Recheck Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) -&gt; Bitmap Index Scan on house_js_idx Index Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) (4 rows)</span></span></code> </pre> <br>  Semua fungsi formulir jsonb_path_xxx () memiliki tanda tangan yang sama: <br><br><pre> <code class="sql hljs">jsonb_path_xxx( js jsonb, jsp jsonpath, vars jsonb DEFAULT '{}', silent boolean DEFAULT false )</code> </pre> <br>  vars adalah objek JSONB untuk meneruskan variabel JSONPath: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; $x)'</span></span>, vars =&gt; <span class="hljs-string"><span class="hljs-string">'{"x": 2}'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [3, 4, 5]</span></span></code> </pre> <br>  Sulit dilakukan tanpa vars ketika kita membuat gabungan yang melibatkan bidang jenis jsonb di salah satu tabel.  Katakanlah kita membuat aplikasi yang mencari apartemen yang cocok untuk karyawan di rumah itu yang telah menuliskan persyaratan mereka untuk area minimum dalam kuesioner: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> demands(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">position</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">demand</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> demands <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">85</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.area &gt;= $min)'</span></span>, vars =&gt; jsonb_build_object(<span class="hljs-string"><span class="hljs-string">'min'</span></span>, demands.demand)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house, demands <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----+----------------------------------- jsonb_path_query | {"no": 2, "area": 80, "rooms": 3} -[ RECORD 2 ]----+----------------------------------- jsonb_path_query | {"no": 3, "area": 50, "rooms": 2} -[ RECORD 3 ]----+----------------------------------- jsonb_path_query | {"no": 4, "area": 100, "rooms": 3} -[ RECORD 4 ]----+----------------------------------- jsonb_path_query | {"no": 5, "area": 60, "rooms": 2}</span></span></code> </pre> <br>  Lucky Pasha dapat memilih dari 4 apartemen.  Namun ada baiknya mengubah 1 huruf dalam permintaan - dari "P" ke "C", dan tidak akan ada pilihan!  Hanya 1 apartemen yang akan melakukannya. <br><br><br>  Satu lagi kata kunci tetap: silent adalah flag yang menekan penanganan kesalahan, mereka berada di hati nurani programmer. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>); ERROR: SQL/JSON member not found DETAIL: jsonpath member accessor can only be applied to an object</code> </pre> <br>  Kesalahannya.  Tapi ini tidak akan menjadi kesalahan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>, silent =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ (0 rows)</span></span></code> </pre> <br>  Ngomong-ngomong, tentang kesalahan: sesuai dengan standar, kesalahan aritmatika dalam ekspresi tidak memberikan pesan kesalahan, mereka berada di hati nurani programmer: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[1,0,2]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (1/ @ &gt;= 1)'</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 1 (1 row)</span></span></code> </pre> <br>  Saat menghitung ekspresi dalam filter, nilai array dicari, di antaranya ada 0, tapi membaginya dengan 0 tidak menghasilkan kesalahan. <br><br>  Fungsi akan bekerja secara berbeda tergantung pada mode yang dipilih: Strict atau Lax (dalam terjemahan "non-strict" atau bahkan "longgar", dipilih secara default).  Misalkan kita mencari kunci dalam mode Lax di JSON, di mana jelas tidak: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- f (1 row)</span></span></code> </pre> <br>  Sekarang dalam mode Ketat: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- (null) (1 row)</span></span></code> </pre> <br>  Artinya, di mana dalam mode liberal kami menerima FALSE, dengan ketat kami mendapat NULL. <br><br>  Dalam mode Lax, array dengan hierarki kompleks [1,2, [3,4,5]] selalu diperluas ke [1,2,3,4,5]: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $[*] ? (@ == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  Dalam mode Ketat, angka "5" tidak akan ditemukan, karena tidak ada di bagian bawah hierarki.  Untuk menemukannya, Anda harus memodifikasi kueri, mengganti "@" dengan "@ [*]": <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $[*] ? (@[*] == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  Dalam PostgreSQL 12, JSONPath adalah tipe data.  Standar tidak mengatakan apa-apa tentang perlunya tipe baru, itu adalah properti implementasi.  Dengan tipe baru, kami mendapatkan pekerjaan penuh dengan jsonpath dengan bantuan operator dan indeks mempercepat pekerjaan mereka, yang sudah ada untuk JSONB.  Jika tidak, JSONPath harus diintegrasikan di tingkat kode pelaksana dan pengoptimal. <br><br>  Anda dapat membaca tentang sintaks SQL / JSON, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Posting blog Oleg Bartunov adalah tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesesuaian SQL / JSON standar-2016</a> untuk PostgreSQL, Oracle, SQL Server dan MySQL. <br><br>  Berikut ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi</a> tentang SQL / JSON. <br><br>  Dan di sini adalah <a href="">pengantar</a> untuk SQL / JSON. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448612/">https://habr.com/ru/post/id448612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448602/index.html">Apakah pemantauan mati? - Pemantauan hidup panjang</a></li>
<li><a href="../id448604/index.html">Game Boy di C #</a></li>
<li><a href="../id448606/index.html">Sidorin: KnowledgeConf adalah tentang bagaimana mempertahankan pengetahuan dengan durasi kerja rata-rata di satu tempat dalam 2-3 tahun</a></li>
<li><a href="../id448608/index.html">Bagaimana cara mengambil langkah pertama dalam robotika?</a></li>
<li><a href="../id448610/index.html">DIY: Bagaimana Kami Membuat Jadwal Langsung untuk Codefest X</a></li>
<li><a href="../id448618/index.html">Algoritma Douglas-Pecker</a></li>
<li><a href="../id448622/index.html">PHP GR8: Akankah JIT Meningkatkan Kinerja PHP 8</a></li>
<li><a href="../id448624/index.html">Lihat datanya? Tidak. Jadi saya tidak melihat, tetapi mereka. Kami menghancurkan data pada drive SSD, dan bahkan mengembalikan kecepatan</a></li>
<li><a href="../id448626/index.html">DDoS untuk membantu: bagaimana kita melakukan tes stres dan stres</a></li>
<li><a href="../id448628/index.html">Estetika dan teknologi teknis Soviet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>