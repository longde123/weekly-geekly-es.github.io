<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí∞ üëÜ ‚ôøÔ∏è Interceptando fun√ß√µes no kernel do Linux usando o ftrace üë©üèº üÜë üë¶üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um projeto relacionado √† seguran√ßa dos sistemas Linux, precis√°vamos interceptar chamadas para fun√ß√µes importantes dentro do kernel (como abrir arqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interceptando fun√ß√µes no kernel do Linux usando o ftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413241/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/xy/k-/zy/xyk-zye1hkr1vaw41hvsxup3brc.png" alt="Pinguim Ninja, En3l" align="right" width="40%"></a>  Em um projeto relacionado √† seguran√ßa dos sistemas Linux, precis√°vamos interceptar chamadas para fun√ß√µes importantes dentro do kernel (como abrir arquivos e processos em execu√ß√£o) para fornecer a capacidade de monitorar a atividade no sistema e bloquear preventivamente a atividade de processos suspeitos. <br><br>  Durante o processo de desenvolvimento, conseguimos inventar uma abordagem muito boa, que nos permite interceptar convenientemente qualquer fun√ß√£o no kernel por nome e executar nosso c√≥digo em torno de suas chamadas.  O interceptador pode ser instalado a partir de um m√≥dulo GPL carreg√°vel, sem reconstruir o kernel.  A abordagem suporta os kernels vers√£o 3.19+ para a arquitetura x86_64. <br><a name="habracut"></a><br>  <font color="gray">(Imagem do pinguim logo acima: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">¬© En3l com DeviantArt</a> .)</font> <br><br><h2>  Abordagens conhecidas </h2><br><h3>  API de seguran√ßa do Linux </h3><br>  O mais correto seria usar a <em>API de seguran√ßa</em> do <em>Linux</em> - uma interface especial criada especificamente para esses fins.  Em locais cr√≠ticos do c√≥digo do kernel, localizam-se chamadas para fun√ß√µes de seguran√ßa, que, por sua vez, retornam chamadas definidas pelo m√≥dulo de seguran√ßa.  O m√≥dulo de seguran√ßa pode examinar o contexto de uma opera√ß√£o e tomar uma decis√£o sobre se √© permitido ou negado. <br><br>  Infelizmente, a API de seguran√ßa do Linux tem algumas limita√ß√µes importantes: <br><br><ul><li>  m√≥dulos de seguran√ßa n√£o podem ser carregados dinamicamente, fazem parte do kernel e exigem reconstru√ß√£o </li><li>  pode haver apenas um m√≥dulo de seguran√ßa no sistema (com algumas exce√ß√µes) </li></ul><br>  Se a posi√ß√£o dos desenvolvedores do kernel for amb√≠gua em rela√ß√£o √† multiplicidade de m√≥dulos, a proibi√ß√£o de carregamento din√¢mico √© fundamental: o m√≥dulo de seguran√ßa deve fazer parte do kernel para garantir a seguran√ßa constantemente, a partir do momento do carregamento. <br><br>  Portanto, para usar a API de seguran√ßa, voc√™ deve fornecer seu pr√≥prio conjunto de kernel, al√©m de integrar o m√≥dulo complementar ao SELinux ou AppArmor, que s√£o usados ‚Äã‚Äãpor distribui√ß√µes populares.  O cliente n√£o quis assinar essas obriga√ß√µes, portanto essa rota foi fechada. <br><br>  Por esses motivos, a API de seguran√ßa n√£o nos convinha, caso contr√°rio, seria uma op√ß√£o ideal. <br><br><h3>  Modifica√ß√£o da tabela de chamadas do sistema </h3><br>  O monitoramento era necess√°rio principalmente para a√ß√µes executadas pelos aplicativos do usu√°rio, para que, em princ√≠pio, pudesse ser implementado no n√≠vel das chamadas do sistema.  Como voc√™ sabe, o Linux armazena todos os manipuladores de chamadas do sistema na tabela <code>sys_call_table</code> .  A substitui√ß√£o de valores nesta tabela leva a uma mudan√ßa no comportamento de todo o sistema.  Assim, mantendo os valores antigos do manipulador e substituindo o nosso pr√≥prio manipulador na tabela, podemos interceptar qualquer chamada do sistema. <br><br>  Essa abordagem tem algumas vantagens: <br><br><ul><li>  <strong>Controle total sobre todas as chamadas do sistema</strong> - a √∫nica interface para o kernel para aplicativos do usu√°rio.  Ao us√°-lo, podemos ter certeza de que n√£o perderemos nenhuma a√ß√£o importante executada pelo processo do usu√°rio. <br></li><li>  <strong>Sobrecarga m√≠nima.</strong>  H√° um investimento de capital √∫nico ao atualizar a tabela de chamadas do sistema.  Al√©m da carga √∫til inevit√°vel do monitoramento, a √∫nica despesa √© uma chamada de fun√ß√£o extra (para chamar o manipulador de chamadas do sistema original). <br></li><li>  <strong>Requisitos m√≠nimos de kernel.</strong>  Se desejado, essa abordagem n√£o requer op√ß√µes de configura√ß√£o adicionais no kernel; portanto, em teoria, ela suporta a maior variedade poss√≠vel de sistemas. <br></li></ul><br>  No entanto, ele tamb√©m sofre de algumas falhas: <br><br><ul><li>  <strong>A complexidade t√©cnica da implementa√ß√£o.</strong>  Por si s√≥, substituir ponteiros em uma tabela n√£o √© dif√≠cil.  Por√©m, tarefas relacionadas exigem solu√ß√µes n√£o √≥bvias e uma certa qualifica√ß√£o: <br><ul><li>  tabela de chamadas do sistema de pesquisa </li><li>  desvio de prote√ß√£o de modifica√ß√£o de tabela </li><li>  substitui√ß√£o at√¥mica e segura </li></ul><br>  Tudo isso √© interessante, mas exige um tempo valioso de desenvolvimento, primeiro para implementa√ß√£o e, depois, para suporte e compreens√£o. <br></li><li>  <strong>Incapacidade de interceptar alguns manipuladores.</strong>  Nos kernels anteriores √† vers√£o 4.16, o tratamento de chamadas do sistema para a arquitetura x86_64 continha v√°rias otimiza√ß√µes.  Alguns deles exigiram que o manipulador de chamadas do sistema fosse um adaptador especial implementado no assembler.  Consequentemente, esses manipuladores √†s vezes s√£o dif√≠ceis, e √†s vezes imposs√≠veis de substituir pelos seus, escritos em C.  Al√©m disso, diferentes otimiza√ß√µes s√£o usadas em diferentes vers√µes do kernel, o que aumenta as dificuldades t√©cnicas do mealheiro. <br></li><li>  <strong>Somente chamadas do sistema s√£o interceptadas.</strong>  Essa abordagem permite substituir os manipuladores de chamadas do sistema, o que limita os pontos de entrada apenas a eles.  Todas as verifica√ß√µes adicionais s√£o realizadas no in√≠cio ou no final, e temos apenas os argumentos da chamada do sistema e seu valor de retorno.  √Äs vezes, isso leva √† necessidade de duplicar verifica√ß√µes sobre a adequa√ß√£o de argumentos e verifica√ß√µes de acesso.  √Äs vezes, isso gera sobrecarga desnecess√°ria quando voc√™ precisa copiar a mem√≥ria do processo do usu√°rio duas vezes: se o argumento √© passado por um ponteiro, primeiro precisamos copi√°-lo, ent√£o o manipulador original copiar√° o argumento novamente por si mesmo.  Al√©m disso, em alguns casos, as chamadas do sistema fornecem uma granularidade muito baixa de eventos que precisam ser filtrados adicionalmente pelo ru√≠do. <br></li></ul><br>  Inicialmente, escolhemos e implementamos com √™xito essa abordagem, buscando os benef√≠cios do suporte ao maior n√∫mero de sistemas.  No entanto, naquela √©poca ainda n√£o conhec√≠amos os recursos do x86_64 e as restri√ß√µes nas chamadas interceptadas.  Mais tarde, tornou-se cr√≠tico para n√≥s suportar chamadas de sistema relacionadas ao in√≠cio de novos processos - clone () e execve () - que s√£o apenas especiais.  Foi isso que nos levou √† busca de novas op√ß√µes. <br><br><h3>  Usando kprobes </h3><br>  Uma das op√ß√µes consideradas foi o uso do <em>kprobes</em> : uma API especializada projetada principalmente para depurar e rastrear o kernel.  Essa interface permite que voc√™ defina pr√© e p√≥s-processadores para <em>qualquer instru√ß√£o</em> no kernel, bem como manipuladores de entrada e retorno para a fun√ß√£o.  Os manipuladores t√™m acesso aos registros e podem alter√°-los.  Assim, poder√≠amos obter o monitoramento e a capacidade de influenciar o curso adicional do trabalho. <br><br>  Benef√≠cios do uso do kprobes para interceptar: <br><br><ul><li>  <strong>API madura.</strong>  Kprobes existem e melhoram desde tempos imemoriais (2002).  Eles t√™m uma interface bem documentada, a maioria das armadilhas j√° foram encontradas, seu trabalho foi otimizado o m√°ximo poss√≠vel e assim por diante.  Em geral, toda uma montanha de vantagens em rela√ß√£o √†s bicicletas experimentais feitas por si. <br></li><li>  <strong>Intercepta√ß√£o de qualquer lugar no n√∫cleo.</strong>  Os Kprobes s√£o implementados usando pontos de interrup√ß√£o (instru√ß√µes int3) incorporados no c√≥digo execut√°vel do kernel.  Isso permite que voc√™ instale o kprobes literalmente em qualquer lugar de qualquer fun√ß√£o, se conhecido.  Da mesma forma, o kretprobes √© implementado atrav√©s da falsifica√ß√£o do endere√ßo de retorno na pilha e permite que voc√™ intercepte o retorno de qualquer fun√ß√£o (com exce√ß√£o das que, em princ√≠pio, n√£o retornam o controle). <br></li></ul><br>  Desvantagens dos kprobes: <br><br><ul><li>  <strong>Dificuldade t√©cnica.</strong>  O Kprobes √© apenas uma maneira de definir um ponto de interrup√ß√£o em qualquer lugar do kernel.  Para obter os argumentos de uma fun√ß√£o ou os valores das vari√°veis ‚Äã‚Äãlocais, √© necess√°rio saber em quais registros ou onde est√£o localizados na pilha e extra√≠-los independentemente a partir da√≠.  Para bloquear uma chamada de fun√ß√£o, voc√™ deve modificar manualmente o estado do processo para que o processador pense que j√° retornou o controle da fun√ß√£o. <br></li><li>  <strong>Jprobes est√£o obsoletos.</strong>  O Jprobes √© um complemento para o kprobes que permite interceptar convenientemente chamadas de fun√ß√£o.  Ele extrair√° independentemente os argumentos da fun√ß√£o dos registradores ou da pilha e chamar√° o manipulador, que deve ter a mesma assinatura da fun√ß√£o conectada.  O problema √© que os jprobes s√£o preteridos e cortados dos kernels modernos. <br></li><li>  <strong>Sobrecarga n√£o trivial.</strong>  Os pontos de interrup√ß√£o s√£o caros, mas √∫nicos.  Os pontos de interrup√ß√£o n√£o afetam outras fun√ß√µes, mas seu processamento √© relativamente caro.  Felizmente, a otimiza√ß√£o de salto √© implementada para a arquitetura x86_64, o que reduz significativamente o custo dos kprobes, mas ainda permanece mais do que, por exemplo, ao modificar a tabela de chamadas do sistema. <br></li><li>  <strong>Limita√ß√µes de kretprobes.</strong>  Os Kretprobes s√£o implementados falsificando o endere√ßo de retorno na pilha.  Assim, eles precisam armazenar o endere√ßo original em algum lugar para retornar ap√≥s o processamento do kretprobe.  Os endere√ßos s√£o armazenados em um buffer de tamanho fixo.  Em caso de estouro, quando muitas chamadas simult√¢neas da fun√ß√£o interceptada s√£o executadas no sistema, o kretprobes pular√° as opera√ß√µes. <br></li><li>  <strong>Extrus√£o desativada.</strong>  Como o kprobes √© baseado em registros de processadores de interrup√ß√µes e malabarismos, para sincroniza√ß√£o todos os manipuladores s√£o executados com a preemp√ß√£o desativada.  Isso imp√µe certas restri√ß√µes aos manipuladores: voc√™ n√£o pode esperar neles - aloque muita mem√≥ria, fa√ßa E / S, durma em timers e sem√°foros e outras coisas conhecidas. <br></li></ul><br>  No processo de pesquisa do t√≥pico, nossos olhos se <strong>voltaram para a</strong> estrutura <strong>ftrace</strong> , que pode substituir os jprobes.  Como se viu, funciona melhor para nossas necessidades de intercepta√ß√£o de chamada de fun√ß√£o.  No entanto, se voc√™ precisar rastrear instru√ß√µes espec√≠ficas nas fun√ß√µes, o kprobes n√£o deve ser descontado. <br><br><h3>  Emenda </h3><br>  Por uma quest√£o de completude, tamb√©m vale a pena descrever o m√©todo cl√°ssico de interceptar fun√ß√µes, que consiste em substituir as instru√ß√µes no in√≠cio da fun√ß√£o por uma transi√ß√£o incondicional que leva ao nosso manipulador.  As instru√ß√µes originais s√£o transferidas para outro local e executadas antes de retornar √† fun√ß√£o interceptada.  Com a ajuda de duas transi√ß√µes, incorporamos (unimos) nosso c√≥digo adicional √† fun√ß√£o, portanto, essa abordagem √© chamada de <em>emenda</em> . <br><br>  √â assim que a otimiza√ß√£o de salto para kprobes √© implementada.  Usando emendas, voc√™ pode obter os mesmos resultados, mas sem custos adicionais para os kprobes e com controle completo da situa√ß√£o. <br><br>  Os benef√≠cios da emenda s√£o √≥bvios: <br><br><ul><li>  <strong>Requisitos m√≠nimos de kernel.</strong>  A emenda n√£o requer nenhuma op√ß√£o especial no kernel e funciona no in√≠cio de qualquer fun√ß√£o.  Voc√™ s√≥ precisa saber o endere√ßo dela. <br></li><li>  <strong>Sobrecarga m√≠nima.</strong>  Duas transi√ß√µes incondicionais - essas s√£o todas as a√ß√µes que o c√≥digo interceptado precisa executar para transferir o controle para o manipulador e vice-versa.  Tais transi√ß√µes s√£o perfeitamente previstas pelo processador e s√£o muito baratas. <br></li></ul><br>  No entanto, a principal desvantagem dessa abordagem obscurece seriamente a imagem: <br><br><ul><li>  <strong>Dificuldade t√©cnica.</strong>  Ela rola.  Voc√™ n√£o pode simplesmente pegar e reescrever o c√≥digo da m√°quina.  Aqui est√° uma lista curta e incompleta de tarefas a serem resolvidas: <br><ul><li>  sincroniza√ß√£o da instala√ß√£o e remo√ß√£o da intercepta√ß√£o (e se a fun√ß√£o for chamada diretamente no processo de substitui√ß√£o de suas instru√ß√µes?) </li><li>  desvio de prote√ß√£o na modifica√ß√£o de regi√µes de mem√≥ria com um c√≥digo </li><li>  Invalida√ß√£o do cache da CPU ap√≥s a substitui√ß√£o das instru√ß√µes </li><li>  desmontar instru√ß√µes substitu√≠veis para copi√°-las inteiras </li><li>  verifica√ß√£o da aus√™ncia de transi√ß√µes dentro da pe√ßa substitu√≠da </li><li>  verifique a capacidade de mover a pe√ßa substitu√≠da para outro local </li></ul><br>  Sim, voc√™ pode espionar kprobes e usar a estrutura intranuclear do livepatch, mas a solu√ß√£o final ainda √© bastante complicada.  √â assustador imaginar quantos problemas de sono haver√° em cada nova implementa√ß√£o. <br></li></ul><br>  Em geral, se voc√™ √© capaz de chamar esse dem√¥nio, subordinado apenas aos iniciados, e est√° pronto para suport√°-lo em seu c√≥digo, o splicing √© uma abordagem totalmente funcional para interceptar chamadas de fun√ß√£o.  Tive uma atitude negativa ao escrever bicicletas; portanto, essa op√ß√£o permaneceu um backup para n√≥s, caso n√£o houvesse progresso algum com solu√ß√µes prontas mais f√°ceis. <br><br><h2>  Nova abordagem com ftrace </h2><br>  <strong>O Ftrace</strong> √© uma estrutura de rastreamento de kernel no n√≠vel da fun√ß√£o.  Foi desenvolvido desde 2008 e possui uma interface fant√°stica para programas de usu√°rios.  O Ftrace permite rastrear a frequ√™ncia e a dura√ß√£o das chamadas de fun√ß√µes, exibir gr√°ficos de chamadas, filtrar fun√ß√µes de interesse por modelo e assim por diante.  Voc√™ pode come√ßar a ler sobre os recursos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do</a> ftrace a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">partir daqui</a> e seguir os links e a documenta√ß√£o oficial. <br><br>  Ele implementa o ftrace com base nas teclas do compilador <code>-pg</code> e <code>-mfentry</code> , que inserem a chamada na fun√ß√£o de rastreamento especial mcount () ou __fentry __ () no in√≠cio de cada fun√ß√£o.  Normalmente, nos programas do usu√°rio, esse recurso do compilador √© usado pelos criadores de perfil para rastrear chamadas para todas as fun√ß√µes.  O kernel usa essas fun√ß√µes para implementar a estrutura ftrace. <br><br>  √â claro que chamar ftrace de <em>cada</em> fun√ß√£o n√£o √© barato; portanto, a otimiza√ß√£o est√° dispon√≠vel para arquiteturas populares: <em>ftrace din√¢mico</em> .  A conclus√£o √© que o kernel conhece a localiza√ß√£o de todas as chamadas para mcount () ou __fentry __ () e, nos est√°gios iniciais do carregamento, substitui o c√≥digo da m√°quina por <strong>nop</strong> - uma instru√ß√£o especial que n√£o faz nada.  Quando o rastreamento √© inclu√≠do nas fun√ß√µes necess√°rias, as chamadas ftrace s√£o adicionadas novamente.  Portanto, se o ftrace n√£o for usado, seu impacto no sistema ser√° m√≠nimo. <br><br><h3>  Descri√ß√£o das fun√ß√µes necess√°rias </h3><br>  Cada fun√ß√£o interceptada pode ser descrita pela seguinte estrutura: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * struct ftrace_hook -    * * @name:    * * @function:  -,     *   * * @original:   ,     *  ,    * * @address:   ,    * * @ops:   ftrace,  , *      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *function; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *original; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  O usu√°rio precisa preencher apenas os tr√™s primeiros campos: nome, fun√ß√£o e original.  Os campos restantes s√£o considerados um detalhe de implementa√ß√£o.  A descri√ß√£o de todas as fun√ß√µes interceptadas pode ser montada em uma matriz e as macros podem ser usadas para aumentar a compacta√ß√£o do c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOOK(_name, _function, _original) \ { \ .name = (_name), \ .function = (_function), \ .original = (_original), \ } static struct ftrace_hook hooked_functions[] = { HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_clone"</span></span></span><span class="hljs-meta">, fh_sys_clone, &amp;real_sys_clone), HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_execve"</span></span></span><span class="hljs-meta">, fh_sys_execve, &amp;real_sys_execve), };</span></span></code> </pre><br>  Wrappers sobre fun√ß√µes interceptadas s√£o os seguintes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *        execve(). *     .      *  :       , *    ABI (  "asmlinkage"). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*real_sys_execve)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *      .   ‚Äî  *   .      *  .      ,  *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Como voc√™ pode ver, fun√ß√µes interceptadas com um m√≠nimo de c√≥digo extra.  A √∫nica coisa que requer aten√ß√£o cuidadosa s√£o as assinaturas de fun√ß√£o.  Eles devem corresponder um a um.  Sem isso, obviamente, os argumentos ser√£o passados ‚Äã‚Äãincorretamente e tudo ficar√° ladeira abaixo.  Para interceptar chamadas do sistema, isso √© menos importante, porque seus manipuladores s√£o muito est√°veis ‚Äã‚Äãe, por efici√™ncia, recebem argumentos na mesma ordem que o sistema chama a si pr√≥prio.  No entanto, se voc√™ planeja interceptar outras fun√ß√µes, lembre-se de que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o h√° interfaces est√°veis ‚Äã‚Äãdentro do kernel</a> . <br><br><h3>  Inicializa√ß√£o Ftrace </h3><br>  Primeiro, precisamos encontrar e salvar o endere√ßo da fun√ß√£o que iremos interceptar.  O Ftrace permite rastrear fun√ß√µes pelo nome, mas ainda precisamos saber o endere√ßo da fun√ß√£o original para cham√°-la. <br><br>  Voc√™ pode obter o endere√ßo usando <em>kallsyms</em> - uma lista de todos os caracteres no kernel.  Esta lista inclui <em>todos os</em> caracteres, n√£o apenas exportados para os m√≥dulos.  Obter o endere√ßo da fun√ß√£o viciada √© algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_hook_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ hook-&gt;address = kallsyms_lookup_name(hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hook-&gt;address) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unresolved symbol: %s\n"</span></span>, hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOENT; } *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) hook-&gt;original) = hook-&gt;address; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Em seguida, voc√™ precisa inicializar a estrutura <code>ftrace_ops</code> .  √â obrigat√≥rio <br>  o campo √© apenas <em>func</em> , indicando um retorno de chamada, mas tamb√©m precisamos <br>  defina algumas sinaliza√ß√µes importantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = resolve_hook_address(hook); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; hook-&gt;ops.func = fh_ftrace_thunk; hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_IPMODIFY; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  <em>fh_ftrace_thunk</em> () √© o nosso retorno de chamada que o ftrace chamar√° ao rastrear uma fun√ß√£o.  Sobre ele mais tarde.  As bandeiras que definimos ser√£o necess√°rias para concluir a intercepta√ß√£o.  Eles instruem o ftrace a salvar e restaurar os registros do processador, cujo conte√∫do podemos alterar no retorno de chamada. <br><br>  Agora estamos prontos para ativar a intercepta√ß√£o.  Para fazer isso, primeiro voc√™ deve habilitar o ftrace para a fun√ß√£o de interesse usando ftrace_set_filter_ip () e, em seguida, permitir que o ftrace chame nosso retorno de chamada usando register_ftrace_function (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } err = register_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"register_ftrace_function() failed: %d\n"</span></span>, err); <span class="hljs-comment"><span class="hljs-comment">/*    ftrace   . */</span></span> ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  A intercepta√ß√£o √© desativada da mesma forma, apenas na ordem inversa: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_remove_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = unregister_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unregister_ftrace_function() failed: %d\n"</span></span>, err); } err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); } }</code> </pre><br>  Ap√≥s a chamada para unregister_ftrace_function (), a aus√™ncia de ativa√ß√µes do retorno de chamada instalado no sistema (e com ele nossos wrappers) √© garantida.  Portanto, podemos, por exemplo, descarregar calmamente o m√≥dulo interceptador, sem medo de que em algum lugar do sistema nossas fun√ß√µes ainda estejam sendo executadas (porque, se desaparecerem, o processador ficar√° chateado). <br><br><h3>  Executando um gancho de fun√ß√£o </h3><br>  Como a intercepta√ß√£o √© realmente realizada?  Muito simples  O Ftrace permite alterar o estado dos registros ap√≥s a sa√≠da de um retorno de chamada.  Alterando o registro% rip - um ponteiro para a pr√≥xima instru√ß√£o execut√°vel - alteramos as instru√ß√µes que o processador executa - ou seja, podemos for√ß√°-lo a executar uma transi√ß√£o incondicional da fun√ß√£o atual para a nossa.  Assim, assumimos o controle. <br><br>  O retorno de chamada para ftrace √© o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br>  Usando a macro container_of (), obtemos o endere√ßo da nossa <code>struct ftrace_hook</code> no endere√ßo da <code>struct ftrace_hook</code> incorporada nela, ap√≥s o que substitu√≠mos o valor do registro% rip na <code>struct pt_regs</code> pelo endere√ßo do nosso manipulador.  S√≥ isso.  Para arquiteturas diferentes de x86_64, esse registro pode ser chamado de maneira diferente (como IP ou PC), mas a ideia √© em princ√≠pio aplic√°vel a elas. <br><br>  Observe o <strong>qualificador notrace</strong> adicionado ao retorno de chamada.  Eles podem sinalizar recursos que n√£o podem ser rastreados usando o ftrace.  Por exemplo, √© assim que as fun√ß√µes do ftrace em si envolvidas no processo de rastreamento s√£o marcadas.  Isso ajuda a impedir que o sistema congele em um loop infinito ao rastrear todas as fun√ß√µes no kernel (o ftrace pode fazer isso). <br><br>  O retorno de chamada ftback normalmente chama com a extrus√£o desativada (como kprobes).  Pode haver exce√ß√µes, mas voc√™ n√£o deve confiar nelas.  No nosso caso, no entanto, essa restri√ß√£o n√£o √© importante; portanto, apenas substitu√≠mos oito bytes na estrutura. <br><br>  A fun√ß√£o de wrapper, chamada posteriormente, ser√° executada no mesmo contexto que a fun√ß√£o original.  Portanto, voc√™ pode fazer o que √© permitido fazer na fun√ß√£o interceptada.  Por exemplo, se voc√™ interceptar um manipulador de interrup√ß√µes, ainda n√£o conseguir√° dormir em um inv√≥lucro. <br><br><h3>  Prote√ß√£o de chamadas recursivas </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe um problema no c√≥digo acima: quando nosso inv√≥lucro chama a fun√ß√£o original, ele entra novamente no ftrace, que novamente chama nosso retorno de chamada, que transfere novamente o controle para o inv√≥lucro. Essa recurs√£o infinita precisa ser interrompida de alguma forma. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais elegante que nos ocorreu √© usar </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um dos argumentos do retorno de chamada ftrace, que cont√©m o endere√ßo de retorno para a fun√ß√£o que chamou a fun√ß√£o rastreada. Normalmente esse argumento √© usado para construir um gr√°fico de chamadas de fun√ß√£o. Podemos us√°-lo para distinguir a primeira chamada da fun√ß√£o interceptada da repetida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, ao chamar novamente</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve apontar para dentro do nosso inv√≥lucro, enquanto estiver no primeiro lugar - em outro lugar do kernel. </font><font style="vertical-align: inherit;">O controle deve ser transferido apenas quando a fun√ß√£o √© chamada pela primeira vez, todos os outros devem ter permiss√£o para executar a fun√ß√£o original. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verifica√ß√£o de entrada pode ser realizada com muita efici√™ncia, comparando o endere√ßo com as bordas do m√≥dulo atual (que cont√©m todas as nossas fun√ß√µes). </font><font style="vertical-align: inherit;">Isso funciona muito bem se no m√≥dulo apenas o wrapper chama a fun√ß√£o interceptada. </font><font style="vertical-align: inherit;">Caso contr√°rio, voc√™ precisar√° ser mais seletivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No total, o retorno de chamada ftrace correto √© o seguinte:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!within_module(parent_ip, THIS_MODULE)) regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caracter√≠sticas / vantagens distintas dessa abordagem: </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixa sobrecarga. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apenas algumas subtra√ß√µes e compara√ß√µes. </font><font style="vertical-align: inherit;">Sem spinlocks, passes de lista e assim por diante.</font></font><br></li><li> <strong>   .</strong>         .       ,         . <br></li><li> <strong>   .</strong>     <em>kretprobes</em>         ,     (      ).           ,       . <br></li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vejamos um exemplo: voc√™ digitou o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando ls</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no terminal </font><font style="vertical-align: inherit;">para ver uma lista de arquivos no diret√≥rio atual. O shell (digamos Bash) usa um par tradicional de fun√ß√µes </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () + </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () da biblioteca padr√£o C </font><font style="vertical-align: inherit;">para iniciar um novo processo </font><font style="vertical-align: inherit;">. Internamente, essas fun√ß√µes s√£o implementadas pelas chamadas de sistema </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone ()</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve (),</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> respectivamente. Suponha que interceptemos a chamada do sistema execve () para controlar o in√≠cio de novos processos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em forma gr√°fica, a intercepta√ß√£o da fun√ß√£o manipuladora se parece com a seguinte: </font></font><br><br><img alt="diagrama de sequ√™ncia de intercepta√ß√£o" src="https://habrastorage.org/webt/ok/mm/4x/okmm4xnova8g2nfmx7y60oocuju.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui vemos como o processo do usu√°rio ( </font></font><font color="#66B2FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">azul</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) faz uma chamada do sistema para o kernel ( </font></font><font color="#EA6B66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vermelho</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), onde a estrutura ftrace ( </font></font><font color="#A680B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">roxa</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) chama fun√ß√µes do nosso m√≥dulo ( </font></font><font color="#97D077"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verde</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processo do usu√°rio executa SYSCALL. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando esta instru√ß√£o, o modo do kernel √© transferido e o controle √© transferido para o manipulador de chamadas de n√≠vel inferior do sistema - </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry_SYSCALL_64</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><font style="vertical-align: inherit;">Ele √© respons√°vel por todas as chamadas de sistema de programas de 64 bits em kernels de 64 bits.</font></font><br></li><li> <strong>    .</strong>     , <a href="">  </a> ,      <em>do_syscall_64</em> (), <a href="">  </a> .            <code>sys_call_table</code>          ‚Äî       <em>sys_execve</em> (). <br></li><li> <strong> ftrace.</strong>         <em>__fentry__</em> (),    ftrace.  ,    ,       <em>nop</em> ,      sys_execve()   . <br></li><li> <strong>Ftrace   .</strong>    ftrace     ,   .         ,    %rip,       . <br></li><li> <strong>  .</strong>     <code>parent_ip</code> ,   do_syscall_64() ‚Äî        sys_execve() ‚Äî     ,   <em> %rip</em>   <code>pt_regs</code> . <br></li><li> <strong>Ftrace  .</strong>   FTRACE_SAVE_REGS, ftrace      <code>pt_regs</code>   .    ftrace     .     %rip ‚Äî      ‚Äî          . <br></li><li> <strong>  -.</strong> -     sys_execve()   .       <em>fh_sys_execve</em> ().           ,                do_syscall_64(). <br></li><li> <strong>   .</strong>          .  fh_sys_execve()        (  )       .        .        ‚Äî sys_execve()  ,   <em>real_sys_execve</em> ,      . <br></li><li> <strong>  .</strong>      sys_execve(),     ftrace     . ,       -‚Ä¶ <br></li><li> <strong>   .</strong>       sys_execve()    fh_sys_execve(),     do_syscall_64().         sys_execve()   .     : ftrace    sys_execve() . <br></li><li> <strong>  .</strong>       sys_execve()      fh_sys_execve().        .   ,    execve()  ,   ,     ,  . . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ger√™ncia retorna ao n√∫cleo. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, fh_sys_execve () termina e o controle passa para do_syscall_64 (), que assume que a chamada do sistema foi conclu√≠da como de costume. </font><font style="vertical-align: inherit;">O n√∫cleo continua seus neg√≥cios nucleares.</font></font><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O gerenciamento retorna ao processo do usu√°rio. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, o kernel executa a instru√ß√£o IRET (ou SYSRET, mas para execve () √© sempre IRET), configurando registros para o novo processo do usu√°rio e colocando o processador central no modo de execu√ß√£o do c√≥digo do usu√°rio. </font><font style="vertical-align: inherit;">A chamada do sistema (e iniciando um novo processo) est√° conclu√≠da.</font></font><br></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vantagens e desvantagens </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, temos uma maneira muito conveniente de interceptar quaisquer fun√ß√µes no kernel, que possui as seguintes vantagens: </font></font><br><br><ul><li> <strong> API   .</strong>        .       ,     ,      .   ‚Äî   -,    . <br></li><li> <strong>    .</strong>            .   -     ,     ,  ,  - .      (    ),    . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A intercepta√ß√£o √© compat√≠vel com o rastreamento. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, esse m√©todo n√£o entra em conflito com o ftrace, portanto voc√™ ainda pode obter indicadores de desempenho muito √∫teis do kernel. </font><font style="vertical-align: inherit;">O uso de kprobes ou splicing pode interferir nos mecanismos ftrace.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quais s√£o as desvantagens desta solu√ß√£o? </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requisitos de configura√ß√£o do kernel. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para executar com √™xito ganchos de fun√ß√£o usando o ftrace, o kernel deve fornecer v√°rios recursos:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lista de caracteres de kallsyms para procurar fun√ß√µes por nome </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estrutura ftrace em geral para rastreamento </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> op√ß√µes de intercepta√ß√£o cr√≠tica do ftrace </font></font></li></ul><br>                . ,  ,   ,        ,           . ,     -  ,       . <br></li><li> <strong>   ftrace</strong> ,   kprobes (  ftrace    ),   ,   ,  . , <em> ftrace</em> ‚Äî      ,    ¬´¬ª  ftrace   . <br></li><li> <strong>  .</strong>    ,      . ,         ,  ftrace    . ,         ,       . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamada dupla ftrace. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A abordagem de an√°lise de ponteiro descrita acima </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resulta em uma chamada ftrace novamente para fun√ß√µes conectadas. </font><font style="vertical-align: inherit;">Isso adiciona um pouco de sobrecarga e pode derrubar outros tra√ßos que receber√£o o dobro de chamadas. </font><font style="vertical-align: inherit;">Essa desvantagem pode ser evitada aplicando um pouco de magia negra: a chamada ftrace est√° localizada no in√≠cio da fun√ß√£o; portanto, se o endere√ßo da fun√ß√£o original for movido para a frente em 5 bytes (o comprimento da instru√ß√£o de chamada), voc√™ poder√° pular atrav√©s do ftrace.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere algumas das desvantagens em mais detalhes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Requisitos de configura√ß√£o do kernel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para iniciantes, o kernel deve suportar ftrace e kallsyms. </font><font style="vertical-align: inherit;">Para fazer isso, as seguintes op√ß√µes devem estar ativadas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_FTRACE </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_KALLSYMS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, o ftrace deve suportar a modifica√ß√£o din√¢mica do registro. </font><font style="vertical-align: inherit;">A op√ß√£o √© respons√°vel por isso.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_DYNAMIC_FTRACE_WITH_REGS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, o kernel usado deve ser baseado na </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers√£o 3.19 ou superior</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ter acesso ao sinalizador FTRACE_OPS_FL_IPMODIFY. </font><font style="vertical-align: inherit;">Vers√µes anteriores do kernel tamb√©m podem substituir o% rip register, mas a partir da 3.19 isso deve ser feito somente ap√≥s a configura√ß√£o desse sinalizador. </font><font style="vertical-align: inherit;">A presen√ßa de um sinalizador para kernels antigos levar√° a um erro de compila√ß√£o, e sua aus√™ncia para novos levar√° a uma intercepta√ß√£o inativa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, para executar a intercepta√ß√£o, a localiza√ß√£o da chamada ftrace dentro da fun√ß√£o √© cr√≠tica: a chamada deve estar localizada no in√≠cio, antes do pr√≥logo da fun√ß√£o (onde o espa√ßo √© alocado para vari√°veis ‚Äã‚Äãlocais e um quadro de pilha √© formado). </font><font style="vertical-align: inherit;">Esse recurso de arquitetura √© levado em considera√ß√£o pela op√ß√£o</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_HAVE_FENTRY </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A arquitetura x86_64 suporta essa op√ß√£o, mas o i386 n√£o. </font><font style="vertical-align: inherit;">Devido √†s limita√ß√µes da arquitetura i386, o compilador n√£o pode inserir uma chamada ftrace antes do pr√≥logo da fun√ß√£o; portanto, quando o ftrace √© chamado, a pilha de fun√ß√µes j√° est√° modificada. </font><font style="vertical-align: inherit;">Nesse caso, para interceptar, n√£o basta alterar o valor do registro% eip - voc√™ tamb√©m deve reverter todas as a√ß√µes executadas no pr√≥logo que diferem de fun√ß√£o para fun√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por esse motivo, a intercepta√ß√£o ftrace n√£o suporta a arquitetura de 32 bits x86. </font><font style="vertical-align: inherit;">Em princ√≠pio, poderia ser implementado usando certas magias negras (gerando e executando um ‚Äúantipr√≥logo‚Äù), mas a simplicidade t√©cnica da solu√ß√£o sofrer√°, o que √© uma das vantagens do uso do ftrace.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Surpresas n√£o √≥bvias </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante o teste, deparamos com um </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recurso</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interessante </font><font style="vertical-align: inherit;">: em algumas distribui√ß√µes, as fun√ß√µes de conex√£o causavam uma falha no sistema. Naturalmente, isso aconteceu apenas em sistemas diferentes daqueles usados ‚Äã‚Äãpelos desenvolvedores. O problema tamb√©m n√£o se reproduziu no prot√≥tipo original de intercepta√ß√£o, com nenhuma distribui√ß√£o e vers√£o do kernel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A depura√ß√£o mostrou que o travamento ocorre dentro da fun√ß√£o interceptada. Por alguma raz√£o m√≠stica, quando a fun√ß√£o original foi chamada dentro do retorno de chamada ftrace, o endere√ßo </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuou sendo especificado no c√≥digo do kernel, em vez do c√≥digo da fun√ß√£o do wrapper. Por isso, surgiu um loop sem fim, j√° que o ftrace chamava nosso inv√≥lucro repetidas vezes sem executar nenhuma a√ß√£o √∫til.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felizmente, t√≠nhamos c√≥digo de trabalho e c√≥digo quebrado √† nossa disposi√ß√£o, portanto, encontrar as diferen√ßas era apenas uma quest√£o de tempo. </font><font style="vertical-align: inherit;">Depois de unificar o c√≥digo e jogar fora tudo o que √© desnecess√°rio, as diferen√ßas entre as vers√µes foram localizadas em uma fun√ß√£o de wrapper. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta op√ß√£o funcionou:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mas este - desligou o sistema: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como √© que o n√≠vel de registro afeta o comportamento? Um estudo cuidadoso do c√≥digo de m√°quina das duas fun√ß√µes rapidamente esclareceu a situa√ß√£o e causou a mesma sensa√ß√£o de culpa do compilador. Geralmente ele est√° na lista de suspeitos em algum lugar perto dos raios c√≥smicos, mas n√£o desta vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O fato √© que as chamadas para pr_devel () s√£o expandidas para o vazio. Esta vers√£o da macro printk √© usada para registro durante o desenvolvimento. Essas entradas de log n√£o s√£o interessantes durante a opera√ß√£o; portanto, elas s√£o cortadas automaticamente do c√≥digo se a macro DEBUG n√£o for declarada. Depois disso, a fun√ß√£o do compilador se transforma assim:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> real_sys_execve(filename, argv, envp); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E aqui a otimiza√ß√£o entra em cena. </font><font style="vertical-align: inherit;">Neste caso, ele trabalhou chamados </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamadas cauda de otimiza√ß√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cauda chamada de otimiza√ß√£o). </font><font style="vertical-align: inherit;">Ele permite que o compilador substitua uma chamada de fun√ß√£o honesta por um salto direto em seu corpo se uma fun√ß√£o chamar outra e retornar imediatamente seu valor. </font><font style="vertical-align: inherit;">No c√≥digo de m√°quina, uma chamada honesta √© assim:</font></font><br><br><pre> <code class="hljs xml">0000000000000000 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve</span></span></span><span class="hljs-tag">&gt;</span></span>: 0: e8 00 00 00 00 callq 5 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve+0x5</span></span></span><span class="hljs-tag">&gt;</span></span> 5: ff 15 00 00 00 00 callq *0x0(%rip) b: f3 c3 repz retq</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e n√£o trabalhando - assim: </font></font><br><br><pre> <code class="hljs perl"><span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;fh_sys_execve&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: e8 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> callq <span class="hljs-number"><span class="hljs-number">5</span></span> &lt;fh_sys_execve+<span class="hljs-number"><span class="hljs-number">0x5</span></span>&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>b <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> mov <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rip),%rax c: ff e<span class="hljs-number"><span class="hljs-number">0</span></span> jmpq *%rax</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira instru√ß√£o CALL √© a mesma chamada __fentry __ () inserida pelo compilador no in√≠cio de todas as fun√ß√µes. Por√©m, no c√≥digo normal, voc√™ pode ver a chamada para real_sys_execve (pelo ponteiro na mem√≥ria) atrav√©s da instru√ß√£o CALL e retornar de fh_sys_execve () usando a instru√ß√£o RET. O c√≥digo quebrado vai diretamente para a fun√ß√£o real_sys_execve () usando o JMP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A otimiza√ß√£o de chamadas finais permite economizar um pouco de tempo na forma√ß√£o de um quadro de pilha "sem sentido", que inclui o endere√ßo de retorno armazenado na pilha pela instru√ß√£o CALL. No entanto, para n√≥s, a corre√ß√£o do endere√ßo de retorno desempenha um papel cr√≠tico - n√≥s o usamos </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para tomar uma decis√£o sobre intercepta√ß√£o. Ap√≥s a otimiza√ß√£o, a fun√ß√£o fh_sys_execve () n√£o salva mais o novo endere√ßo de retorno na pilha, permanece o antigo - apontando para o kernel. Portanto,</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continua a apontar para dentro do n√∫cleo, o que leva √† forma√ß√£o de um loop infinito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso tamb√©m explica por que o problema s√≥ foi reproduzido em algumas distribui√ß√µes. Ao compilar m√≥dulos, distribui√ß√µes diferentes usam conjuntos diferentes de sinalizadores de compila√ß√£o. Nas distribui√ß√µes em dificuldades, a otimiza√ß√£o da chamada de cauda foi ativada por padr√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A solu√ß√£o para o problema foi desativar a otimiza√ß√£o da chamada de cauda para todo o arquivo com fun√ß√µes de wrapper:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> GCC optimize(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"-fno-optimize-sibling-calls"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que mais posso dizer ... √â divertido desenvolver c√≥digo de baixo n√≠vel para o kernel do Linux. </font><font style="vertical-align: inherit;">Espero que esta publica√ß√£o poupe a algu√©m um pouco de agonia, o que usar para escrever o seu melhor antiv√≠rus no mundo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ quiser experimentar a intercepta√ß√£o, o c√≥digo completo do m√≥dulo do kernel pode ser encontrado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413241/">https://habr.com/ru/post/pt413241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413231/index.html">Introdu√ß√£o aos contratos inteligentes</a></li>
<li><a href="../pt413233/index.html">O servi√ßo uLogin envia dados de formul√°rios (correio, telefone) para um site de terceiros e fica em sil√™ncio quanto a isso</a></li>
<li><a href="../pt413235/index.html">Apostando em melhores previs√µes: nova matem√°tica das previs√µes meteorol√≥gicas</a></li>
<li><a href="../pt413237/index.html">O Facebook nega enviar aos fabricantes de dispositivos os mesmos dados que o desenvolvedor Alexander Kogan</a></li>
<li><a href="../pt413239/index.html">Como tornar um smartphone um pouco mais burro</a></li>
<li><a href="../pt413243/index.html">School of Data: como combinar matem√°tica e neg√≥cios</a></li>
<li><a href="../pt413245/index.html">No equipamento Dolby Atmos - apenas som "nativo". Dolby pro√≠be upmixing n√£o nativo</a></li>
<li><a href="../pt413247/index.html">Por que monitorar sistemas de armazenamento?</a></li>
<li><a href="../pt413249/index.html">Escrevendo um m√≥dulo do kernel Linux: I2C</a></li>
<li><a href="../pt413251/index.html">Rea√ß√£o em cadeia da polimerase e Vladivostok</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>