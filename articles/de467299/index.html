<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüåæ üöÇ ü§Ωüèª Konzepte: Vereinfachung der Implementierung von STD Utility-Klassen üßê üé¶ ‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Konzepte, die in C ++ 20 erscheinen, sind ein langes und viel diskutiertes Thema. Trotz des im Laufe der Jahre angesammelten Material√ºberschusses (ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konzepte: Vereinfachung der Implementierung von STD Utility-Klassen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/467299/"><p><img src="https://habrastorage.org/webt/et/c4/ir/etc4ir2odcs1wv10o5jcu0yneng.jpeg"></p><br><p>  Konzepte, die in C ++ 20 erscheinen, sind ein langes und viel diskutiertes Thema.  Trotz des im Laufe der Jahre angesammelten Material√ºberschusses (einschlie√ülich der Reden von Weltklasse-Experten) herrscht unter angewandten Programmierern (die nicht t√§glich mit dem Standard einschlafen) immer noch Verwirrung dar√ºber, was C ++ 20-Konzepte sind und sind Wir brauchen, wenn enable_if im Laufe der Jahre √ºberpr√ºft wird.  Teilweise liegt der Fehler darin, wie sich die Konzepte √ºber ~ 15 Jahre entwickelt haben (Concepts Full + Concept Map -&gt; Concepts Lite), und teilweise darin, dass sich herausstellte, dass sich die Konzepte von √§hnlichen Tools in anderen Sprachen unterscheiden (Java / C # generische Grenzen, Rust-Merkmale,. ..). </p><br><p>  Unter dem Schnitt - Video und Transkript eines Berichts von Andrey Davydov vom ReSharper C ++ - Team der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Russia 2019-</a> Konferenz.  Andrey gab einen kurzen √úberblick √ºber die konzeptbezogenen Innovationen von C ++ 20, woraufhin er die Implementierung einiger Klassen und Funktionen von STL untersuchte und C ++ 17- und C ++ 20-L√∂sungen verglich.  Weiter ist die Geschichte in seinem Namen. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vYzjV0xSqJE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Sprechen Sie √ºber Konzepte.  Dies ist ein ziemlich komplexes und umfangreiches Thema. Als ich mich auf den Bericht vorbereitete, hatte ich einige Schwierigkeiten.  Ich beschloss, mich der Erfahrung eines der besten Redner der C ++ - Community <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrei Alexandrescu</a> zuzuwenden. </p><br><p>  Im November 2018 fragte Andrei bei der Er√∂ffnung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meetings C ++</a> das Publikum, was das n√§chste gro√üe Feature von C ++ sein w√ºrde: </p><br><ul><li>  Konzepte </li><li>  Metaklassen </li><li>  oder Selbstbeobachtung? </li></ul><br><p>  Beginnen wir mit dieser Frage.  Denken Sie, dass das n√§chste gro√üe Feature in C ++ Konzepte sein werden? </p><br><p>  Konzepte sind laut Alexandrescu langweilig.  Dies ist die langweilige Sache, die ich Ihnen vorschlage.  Au√üerdem kann ich immer noch nicht genauso interessant und brandaktuell √ºber Metaklassen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herb Sutter</a> oder √ºber Selbstbeobachtung wie Alexandrescu sprechen. </p><br><p>  Was meinen wir, wenn wir √ºber Konzepte in C ++ 20 sprechen?  Diese Funktion wurde seit mindestens 2003 diskutiert und hat sich in dieser Zeit stark weiterentwickelt.  Mal sehen, welche neuen konzeptbezogenen Funktionen in C ++ 20 erschienen sind. </p><br><p> Eine neue Entit√§t namens "Konzepte" wird durch das Schl√ºsselwort <code>concept</code> definiert.  Dies ist ein Pr√§dikat f√ºr Vorlagenparameter.  Es sieht ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept NoThrowDefaultConstructible = noexept(T{}); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> From, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> To&gt; concept Assignable = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_assignable_v&lt;From, To&gt;</code> </pre> <br><p>  Ich habe nicht nur den Ausdruck "f√ºr Vorlagenparameter" und nicht "f√ºr Typen" verwendet, da Konzepte f√ºr nicht standardm√§√üige Vorlagenparameter definiert werden k√∂nnen.  Wenn Sie √ºberhaupt nichts zu tun haben, k√∂nnen Sie ein Konzept f√ºr eine Zahl definieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I&gt; concept Even = I % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Es ist jedoch sinnvoller, typische und atypische Vorlagenparameter zu mischen.  Wir nennen einen Typ klein, wenn seine Gr√∂√üe und Ausrichtung die angegebenen Grenzwerte nicht √ºberschreitet: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> MaxSize, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> MaxAlign&gt; concept Small = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) &lt;= MaxSize &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T) &lt;= MaxAlign;</code> </pre> <br><p>  Wahrscheinlich ist noch nicht klar, warum wir eine neue Entit√§t in der Sprache <code>constexpr bool</code> m√ºssen und warum das Konzept nicht nur eine <code>constexpr bool</code> Variable ist. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  `concept`    ? #define concept constexpr bool</span></span></code> </pre> <br><h1 id="kak-ispolzuyutsya-koncepty">  Wie werden Konzepte verwendet? </h1><br><p>  Lassen Sie uns zum Verst√§ndnis sehen, wie Konzepte verwendet werden. </p><br><p>  Erstens k√∂nnen sie genau wie <code>constexpr bool</code> Variablen √ºberall dort verwendet werden, wo Sie zur Kompilierungszeit einen booleschen Ausdruck ben√∂tigen.  Zum Beispiel innerhalb von <code>static_assert</code> oder innerhalb von <code>noexcept</code> <br>  Spezifikationen: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// bool expression evaluated in compile-time static_assert(Assignable&lt;float, int&gt;); template&lt;typename T&gt; void test() noexcept(NothrowDefaultConstructible&lt;T&gt;) { T t; ... }</span></span></code> </pre> <br><p>  Zweitens k√∂nnen beim Definieren von Vorlagenparametern anstelle der Schl√ºsselw√∂rter <code>typename</code> oder <code>class</code> Konzepte verwendet werden.  Definieren Sie eine einfache <code>optional</code> Klasse, in der einfach ein Paar des <code>initialized</code> Booleschen Flags und der Werte gespeichert wird.  Nat√ºrlich gilt eine solche <code>optional</code> nur f√ºr triviale Typen.  Daher schreiben wir hier <code>Trivial</code> , und wenn wir versuchen, aus etwas Nicht-Trivialem, beispielsweise aus <code>std::string</code> , zu instanziieren, tritt ein Kompilierungsfehler auf: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  type-parameter-key (class, typename) template&lt;Trivial T&gt; class simple_optional { T value; bool initialized = false; ... };</span></span></code> </pre> <br><p>  Konzepte k√∂nnen teilweise angewendet werden.  Zum Beispiel implementieren wir unsere Klasse <code>any</code> mit kleiner Pufferoptimierung.  Definieren Sie die <code>SB</code> Struktur (kleiner Puffer) mit einer festen <code>Size</code> und <code>Alignment</code> . Wir speichern die Vereinigung von <code>SB</code> und den Zeiger auf dem Heap.  Und jetzt, wenn ein kleiner Typ in den Konstruktor kommt, k√∂nnen wir ihn einfach in <code>SB</code> .  Um festzustellen, dass ein Typ klein ist, schreiben wir, dass er dem Konzept von <code>Small</code> .  Das <code>Small</code> Konzept bestand aus drei Vorlagenparametern: Wir haben zwei definiert und eine Funktion aus einem Vorlagenparameter erhalten: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   class any { struct SB { static constexpr size_t Size = ...; static constexpr size_t Alignment = ...; aligned_storage_t&lt;Size, Alignment&gt; storage; }; union { SB sb; void* handle; }; template&lt;Small&lt;SB::Size, SB::Alignment&gt; T&gt; any(T const &amp; t) : sb(...) ... };</span></span></code> </pre> <br><p>  Es gibt eine k√ºrzere Aufzeichnung.  Wir schreiben den Namen des Template-Parameters, m√∂glicherweise mit einigen Argumenten, vor <code>auto</code> .  Das vorherige Beispiel wird folgenderma√üen umgeschrieben: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Terse syntax (  auto) class any { struct SB { static constexpr size_t Size = ...; static constexpr size_t Alignment = ...; aligned_storage_t&lt;Size, Alignment&gt; storage; }; union { SB sb; void* handle; }; any(Small&lt;SB::Size, SB::Alignment&gt; auto const &amp; t) : sb(...) ... };</span></span></code> </pre> <br><p>  Wahrscheinlich k√∂nnen Sie jetzt an jedem Ort, an dem wir <code>auto</code> schreiben, den Namen des Konzepts davor schreiben. </p><br><p>  Definieren Sie die Funktion <code>get_handle</code> , die ein <code>handle</code> f√ºr das Objekt zur√ºckgibt. <br>  Wir gehen davon aus, dass kleine Objekte selbst <code>handle</code> werden und bei gro√üen Objekten ein Zeiger auf sie <code>handle</code> .  Da wir zwei Zweige haben, <code>if constexpr</code> Ausdr√ºcke unterschiedlichen Typs bezeichnen, ist es f√ºr uns zweckm√§√üig, den Typ dieser Funktion nicht explizit anzugeben, sondern den Compiler <code>if constexpr</code> , ihn auszugeben.  Wenn wir dort einfach <code>auto</code> , verlieren wir die Information, dass der angegebene Wert klein ist und den Zeiger nicht √ºberschreitet: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Terse syntax (  auto) template&lt;typename T&gt; concept LEPtr = Small&lt;T, sizeof(void *), alignof(void *)&gt;; template&lt;typename T&gt; auto get_handle(T&amp; object) { if constexpr (LEPtr&lt;T&gt;) return object; else return &amp;object; }</span></span></code> </pre> <br><p>  In C ++ 20 kann davor geschrieben werden, dass es nicht nur <code>auto</code> , sondern auch <code>auto</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Terse syntax (  auto) template&lt;typename T&gt; concept LEPtr = Small&lt;T, sizeof(void *), alignof(void *)&gt;; template&lt;typename T&gt; LEPtr auto get_handle(T &amp;object) { if constexpr (LEPtr&lt;T&gt;) return object; else return &amp;object; }</span></span></code> </pre> <br><h1 id="requires-expression">  Ben√∂tigt Ausdruck </h1><br><p>  Ben√∂tigt Ausdruck ist eine ganze Familie von expression'ov, alle sind vom Typ <code>bool</code> und werden in Kompilierungszeit berechnet.  Sie werden verwendet, um Anweisungen zu Ausdr√ºcken und Typen zu testen.  Ben√∂tigt Ausdruck ist sehr n√ºtzlich f√ºr die Definition von Konzepten. </p><br><p>  <code>Constructible</code> Beispiel.  Diejenigen, die in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Bericht waren,</a> haben ihn bereits gesehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; concept Constructible = requires(Args... args) { T{args...} };</code> </pre> <br><p>  Und ein Beispiel mit <code>Comparable</code> .  Angenommen, Typ <code>T</code> ist <code>Comparable</code> wenn zwei Objekte vom Typ <code>T</code> mit dem Operator "less" verglichen werden k√∂nnen und das Ergebnis in <code>bool</code> konvertiert wird.  Dieser Pfeil und der Typ danach bedeuten, dass der <code>bool</code> in <code>bool</code> konvertiert wird und nicht, dass er gleich <code>bool</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept Comparable = requires(T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; a, T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; b) { {a &lt; b} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>; };</code> </pre> <br><p>  Was wir untersucht haben, reicht bereits aus, um ein vollwertiges Beispiel f√ºr die Verwendung von Konzepten zu zeigen. </p><br><p>  Wir haben bereits ein <code>Comparable</code> Konzept. Definieren wir Konzepte f√ºr Iteratoren.  <code>RandomAccessIterator</code> , <code>RandomAccessIterator</code> ist ein <code>BidirectionalIterator</code> und einige andere Eigenschaften.  Damit definieren wir das Konzept von <code>Sortable</code> .  <code>Range</code> wird als <code>Sortable</code> wenn sein <code>RandomAccess</code> Iterator und seine Elemente verglichen werden k√∂nnen.  Und jetzt k√∂nnen wir eine <code>sort</code> schreiben, die nicht nur das, sondern auch den <code>Sortable Range</code> akzeptiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// concepts,    ++20 template&lt;typename Iterator&gt; concept RandomAccessIterator = BidirectionalIterator&lt;Iterator&gt; &amp;&amp; ...; template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;Sortable Range&gt; void sort(Range &amp;) {...}</span></span></code> </pre> <br><p>  Wenn wir nun versuchen, diese Funktion von etwas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufzurufen</a> , das das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortable-</a> Konzept nicht erf√ºllt, erhalten wir vom Compiler einen guten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SFINAE-freundlichen</a> Fehler mit einer klaren Meldung.  Versuchen wir, eine <code>std::list</code> 'oder Vektor von Elementen zu instanziieren, die nicht vergleichbar sind: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//concepts,    ++20,  struct X {}; void test() { vector&lt;int&gt; vi; sort(vi); // OK list &lt;int&gt; li; sort(li); // Fail, list&lt;int&gt;::iterator is not random access vector&lt; X &gt; vx; sort(vx); // Fail, X is not Comparable }</span></span></code> </pre> <br><p>  Haben Sie bereits ein √§hnliches Beispiel f√ºr die Verwendung von Konzepten oder etwas sehr √Ñhnliches gesehen?  Ich habe das schon mehrmals gesehen.  Ehrlich gesagt hat es mich √ºberhaupt nicht √ºberzeugt.  M√ºssen wir so viele neue Entit√§ten in der Sprache umz√§unen, wenn wir dies in C ++ 17 bekommen k√∂nnen? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//concepts,    ++17 #define concept constexpr bool template&lt;typename T&gt; concept Comparable = is_convertible_v&lt; decltype(declval&lt;T const &amp;&gt;() &lt; declval&lt;T const &amp;&gt;()), bool &gt;; template&lt;typename Iterator&gt; concept RandomAccessIterator = BidirectionalIterator&lt;Iterator&gt; &amp;&amp; ...; template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;typename Range, typename = enable_if_t&lt;Sortable&lt;Range&gt;&gt;&gt; void sort(Range &amp;) { ... }</span></span></code> </pre> <br><p>  Ich habe das Keyword- <code>concept</code> Makro eingegeben und <code>Comparable</code> auf diese Weise neu geschrieben.  Es ist etwas h√§sslicher geworden, und dies deutet darauf hin, dass Ausdruck wirklich eine n√ºtzliche und bequeme Sache ist.  Also haben wir das Konzept von <code>enable_if</code> definiert und mit <code>enable_if</code> angegeben, dass die <code>enable_if</code> den <code>Sortable Range</code> akzeptiert. </p><br><p>  Sie k√∂nnten denken, dass diese Methode aufgrund von Kompilierungsfehlermeldungen viel verliert, aber tats√§chlich ist dies eine Frage der Qualit√§t der Compiler-Implementierung.  Nehmen wir an, Clang hat <code>enable_if</code> Aufhebens um dieses Thema gemacht und insbesondere darauf <code>enable_if</code> Sie das erste Argument haben, wenn Sie <code>enable_if</code> <br>  Wenn <code>false</code> berechnet wird, wird dieser Fehler angezeigt, sodass eine solche Anforderung nicht erf√ºllt wurde. </p><br><p>  Das obige Beispiel scheint durch Konzepte geschrieben zu sein.  Ich habe eine Hypothese: Dieses Beispiel ist nicht schl√ºssig, weil es nicht das Hauptmerkmal von Konzepten verwendet - erfordert Klausel. </p><br><h1 id="requires-clause">  Ben√∂tigt Klausel </h1><br><p>  Die Requires-Klausel h√§ngt von fast jeder Vorlagendeklaration oder einer Nicht-Vorlagenfunktion ab.  Syntaktisch sieht dies wie das Schl√ºsselwort require aus, gefolgt von einem booleschen Ausdruck.  Dies ist erforderlich, um den Kandidaten f√ºr die Vorlagenspezialisierung oder -√ºberladung herauszufiltern, dh es funktioniert genauso wie SFINAE, nur korrekt und nicht durch Hacks: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// requires-clause template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;Sortable Range&gt; void sort(Range &amp;) { ... }</span></span></code> </pre> <br><p>  Wo in unserem sortierten Beispiel k√∂nnen wir die require-Klausel verwenden?  Anstelle einer kurzen Syntax zum Anwenden von Konzepten schreiben wir Folgendes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Range&gt; requires Sortable&lt;Range&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range &amp;)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Es scheint, dass der Code nur schlechter und gr√∂√üer wurde.  Aber jetzt k√∂nnen wir das <code>Sortable</code> Konzept loswerden.  Aus meiner Sicht ist dies eine Verbesserung, da das <code>Sortable</code> Konzept <code>Sortable</code> tautologisch ist: Wir nennen <code>Sortable</code> alles, was an die <code>sort</code> kann.  Dies hat keine physikalische Bedeutung.  Wir schreiben den Code folgenderma√üen um: </p><br><pre> <code class="plaintext hljs">//template&lt;typename R&gt; concept Sortable // = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;typename Range&gt; requires RandomAccessIterator&lt;Iterator&lt;Range&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;Range&gt;&gt;; void sort(Range &amp;) { ... }</code> </pre> <br><h1 id="itogovyy-spisok-concept-related-fich">  Zusammenfassende Liste der konzeptbezogenen Funktionen </h1><br><p>  Die Liste der konzeptbezogenen Innovationen in C ++ 20 sieht folgenderma√üen aus.  Die Elemente in dieser Liste werden sortiert, indem der Nutzen der Funktion aus meiner subjektiven Sicht erh√∂ht wird: </p><br><ul><li>  Neues Entit√§tskonzept.  Es scheint mir, dass es m√∂glich w√§re, auf die <code>concept</code> indem <code>constexpr bool</code> Variablen mit zus√§tzlicher Semantik ausgestattet werden. </li><li>  Spezielle Syntax zum Anwenden von Konzepten.  Nat√ºrlich ist es angenehm, aber dies ist nur die Syntax.  Wenn C ++ - Programmierer Angst vor schlechter Syntax h√§tten, w√§ren sie vor langer Zeit aus Angst gestorben. </li><li>  Ben√∂tigt Ausdruck ist wirklich eine coole Sache, und es ist nicht nur n√ºtzlich, um Konzepte zu definieren. </li><li>  Die Requires-Klausel ist der gr√∂√üte Wert von Konzepten. Sie erm√∂glicht es Ihnen, SFINAE und andere legend√§re Schrecken von C ++ - Vorlagen zu vergessen. </li></ul><br><h1 id="podrobnee-o-requires-expression">  Mehr dazu erfordert Ausdruck </h1><br><p>  Bevor wir uns mit der Erforderlichkeitsklausel befassen, m√ºssen einige Worte zum Ausdruck erforderlich sein. </p><br><p>  Erstens k√∂nnen sie nicht nur zum Definieren von Konzepten verwendet werden.  Der Microsoft-Compiler hat seit jeher die Erweiterung <code>__if_exists</code> - <code>__if_not_exists</code> .  Es erm√∂glicht der Kompilierungszeit, das Vorhandensein eines Namens zu √ºberpr√ºfen und abh√§ngig davon die Kompilierung eines Codeblocks zu aktivieren oder zu deaktivieren.  Und in der Codebasis, mit der ich vor einigen Jahren gearbeitet habe, war es so etwas.  Es gibt eine Funktion <code>f()</code> , sie nimmt einen Punkt des Vorlagentyps und nimmt die H√∂he von diesem Punkt.  Es kann durch einen dreidimensionalen oder zweidimensionalen Punkt instanziiert werden.  F√ºr dreidimensional betrachten wir die <code>z</code> Koordinate als H√∂he, f√ºr zweidimensional wenden wir uns einem speziellen Oberfl√§chensensor zu.  Es sieht so aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Point&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h; __if_exists(Point::z) { h = pz; } __if_not_exists(Point::z) { h = sensor.get_height(p); } }</code> </pre> <br><p>  In C ++ 20 k√∂nnen wir dies umschreiben, ohne Compiler-Erweiterungen mit Standardcode zu verwenden.  Es scheint mir, dass es nicht schlimmer ist: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Point&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requires { Point::z; })</span></span></span><span class="hljs-function"> h </span></span>= pz; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> h = sensor.get_height(p); }</code> </pre> <br><p>  Der zweite Punkt ist, dass Sie wachsam sein m√ºssen, wenn die Syntax Ausdruck erfordert. <br>  Sie sind ziemlich m√§chtig, und diese Kraft wird durch die Einf√ºhrung vieler neuer syntaktischer Konstruktionen erreicht.  Sie k√∂nnen zumindest zuerst verwirrt sein. </p><br><p>  Definieren wir ein <code>Sizable</code> Konzept, das √ºberpr√ºft, ob ein Container eine konstante Methodengr√∂√üe <code>size</code> , die <code>size_t</code> zur√ºckgibt.  Wir erwarten nat√ºrlich, dass der <code>vector&lt;int&gt;</code> <code>Sizable</code> , aber dieser <code>static_assert</code> .  Verstehst du, warum wir einen Fehler haben?  Warum wird dieser Code nicht kompiliert? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; concept Sizable = requires(Container <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; c) { c.size() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-comment"><span class="hljs-comment">// Fail</span></span></code> </pre> <br><p>  Lassen Sie mich Ihnen den Code zeigen, der kompiliert wird.  Eine solche <code>X</code> Klasse erf√ºllt das <code>Sizable</code> Konzept.  Jetzt verstehen Sie, was wir ein Problem haben? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-function"><span class="hljs-function">Inner* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;X&gt;); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>  Lassen Sie mich die Code-Hervorhebung korrigieren.  Links ist der Code farbig, wie ich m√∂chte.  Tats√§chlich sollte es aber wie rechts gemalt sein: </p><br><p><img src="https://habrastorage.org/webt/mu/ht/l2/muhtl2zbr7nbutf7an8or2qjhse.jpeg"></p><br><p>  Sehen Sie, die Farbe von <code>size_t</code> , die hinter dem Pfeil steht, hat sich ge√§ndert?  Ich wollte, dass es ein Typ ist, aber es ist nur das Feld, auf das wir zugreifen.  Alles, was wir haben, erfordert Ausdruck, ist ein gro√üer Ausdruck, und wir √ºberpr√ºfen seine Richtigkeit.  Ja, f√ºr Typ <code>X</code> ist dies ein g√ºltiger Ausdruck, f√ºr <code>vector&lt;int&gt;</code> nein.  Um das zu erreichen, was wir wollten, m√ºssen wir den Ausdruck in geschweiften Klammern verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; concept Sizable = requires(Container <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; c) { {c.size()} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-comment"><span class="hljs-comment">// OK struct X { struct Inner { int size_t; }; Inner* size() const; }; static_assert(Sizable&lt;X&gt;); // Fail</span></span></code> </pre> <br><p>  Dies ist jedoch nur ein lustiges Beispiel.  Im Allgemeinen m√ºssen Sie nur vorsichtig sein. </p><br><h1 id="primery-ispolzovaniya-konceptov">  Beispiele f√ºr die Verwendung von Konzepten </h1><br><h2 id="realizaciya-klassa-pair">  Implementierung von Paarklassen </h2><br><p>  Weiterhin werde ich einige STL-Fragmente demonstrieren, die in C ++ 17 implementiert werden k√∂nnen, aber ziemlich umst√§ndlich sind. <br>  Und dann werden wir sehen, wie wir in C ++ 20 die Implementierung verbessern k√∂nnen. </p><br><p>  Beginnen wir mit der <code>pair</code> . <br>  Dies ist eine sehr alte Klasse, sie befindet sich immer noch in C ++ 98. <br>  Es enth√§lt also keine komplizierte Logik <br>  Ich m√∂chte, dass seine Definition ungef√§hr so ‚Äã‚Äãaussieht. <br>  Aus meiner Sicht sollte es ungef√§hr so ‚Äã‚Äãenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; ... };</code> </pre> <br><p>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cppreference</a> haben <code>pair</code> Designer jedoch nur 8 Teile. <br>  Wenn Sie sich beispielsweise die tats√§chliche Implementierung in der Microsoft STL ansehen, gibt es bis zu 15 Konstruktoren der <code>pair</code> .  Wir werden uns diese ganze Kraft nicht ansehen und uns auf den Standardkonstruktor beschr√§nken. </p><br><p>  Es scheint, dass es etwas kompliziertes ist?  Zun√§chst verstehen wir, warum es ben√∂tigt wird.  Wir wollen, wenn eines der Argumente der <code>pair</code> von einem trivialen Typ war, sagen wir <code>int</code> , dann wurde es nach dem <code>pair</code> Paarklasse auf Null initialisiert und blieb nicht uninitialisiert.  Dazu m√∂chten wir einen Konstruktor schreiben, der die Wertinitialisierung f√ºr die Felder <code>f</code> (first) und <code>s</code> (second) aufruft. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; pair() : f() , s() {} };</code> </pre> <br><p>  Wenn wir versuchen, ein <code>pair</code> aus etwas zu instanziieren, das keinen Standardkonstruktor hat, beispielsweise aus einer solchen Klasse <code></code> , erhalten wir leider sofort einen Kompilierungsfehler.  Das gew√ºnschte Verhalten ist, dass, wenn Sie versuchen, ein <code>pair</code> erstellen, der Standard ein Kompilierungsfehler ist. Wenn wir jedoch die Werte von <code>f</code> und <code>s</code> explizit √ºbergeben, funktioniert alles: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> A(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); }; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, A&gt; a2; <span class="hljs-comment"><span class="hljs-comment">// must fail pair&lt;int, A&gt; a1; { 1, 2 }; // must be OK</span></span></code> </pre> <br><p>  Machen Sie dazu den Standardkonstruktor zu einer Vorlage und beschr√§nken Sie ihn auf SFINAE. <br>  Die erste Idee, die mir in den Sinn kommt, ist, dass wir schreiben, dass dieser Konstruktor nur zul√§ssig ist, wenn <code>f</code> und <code>s</code> <code>is_default_constructable</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;F&gt;, <span class="hljs-comment"><span class="hljs-comment">// not dependent is_default_constructible&lt;S&gt; &gt;&gt;&gt; pair() : f(), s() {} };</span></span></code> </pre> <br><p>  Dies funktioniert nicht, da die Argumente <code>enable_if_t</code> nur von den Vorlagenparametern der Klasse abh√§ngen.  Das hei√üt, nach der Ersetzung der Klasse werden sie unabh√§ngig und k√∂nnen sofort berechnet werden.  Wenn wir jedoch <code>false</code> , erhalten wir erneut einen harten Compilerfehler. </p><br><p>  Um dies zu √ºberwinden, f√ºgen wir diesem Konstruktor weitere Vorlagenparameter hinzu und lassen die Bedingung <code>enable_if_t</code> von diesen Vorlagenparametern abh√§ngen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = S, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt; &gt;&gt;&gt; pair() : f(), s() {} };</code> </pre> <br><p>  Die Situation ist ziemlich lustig.  Tatsache ist, dass die Vorlagenparameter <code>T</code> und <code>U</code> vom Benutzer nicht explizit festgelegt werden k√∂nnen.  In C ++ gibt es keine Syntax zum expliziten Festlegen der Vorlagenparameter des Konstruktors. Sie k√∂nnen vom Compiler nicht ausgegeben werden, da sie nirgendwo angezeigt werden k√∂nnen.  Sie k√∂nnen nur vom Standardwert stammen.  Das hei√üt, dieser Code unterscheidet sich effektiv nicht vom Code im vorherigen Beispiel.  Aus Sicht des Compilers ist dies jedoch g√ºltig, jedoch nicht im vorherigen Beispiel. </p><br><p>  Wir haben unser erstes Problem gel√∂st, aber wir stehen vor einem zweiten, etwas subtileren.  Angenommen, wir haben Klasse <code>B</code> mit einem expliziten Standardkonstruktor und m√∂chten implizit das <code>pair&lt;int, B&gt;</code> konstruieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {};</code> </pre> <br><p>  Wir k√∂nnen es schaffen, aber standardm√§√üig sollte es nicht funktionieren.  Standardm√§√üig sollte ein Paar implizit nur standardm√§√üig erstellt werden, wenn beide Elemente implizit standardm√§√üig erstellt werden. </p><br><p>  Frage: M√ºssen wir den Konstruktor des expliziten Paares schreiben oder nicht?  In C ++ 17 haben wir eine Solomon-L√∂sung: Schreiben wir sowohl solche als auch solche. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = S, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt;, is_implicity_default_constructible&lt;T&gt;, is_implicity_default_constructible&lt;U&gt; &gt;&gt;&gt; pair() : f(), s() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;...&gt; <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> pair() : f(), s() {} };</code> </pre> <br><p>  Jetzt haben wir zwei Standardkonstruktoren: </p><br><ul><li>  Wir werden einen von ihnen gem√§√ü SFINAE f√ºr den Fall abschneiden, dass die Elemente implizit standardm√§√üig konstruierbar sind. </li><li>  und die zweite f√ºr den umgekehrten Fall. </li></ul><br><p>  √úbrigens kenne ich eine solche L√∂sung, um das Typmerkmal <code>is_implicitly_default_constructible</code> in C ++ 17 zu implementieren, aber ich kenne die L√∂sung ohne SFINAE nicht: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> is_implicity_default_constructible = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(test&lt;T&gt;({}, <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br><p>  Wenn wir jetzt versuchen, das <code>pair &lt;int, B&gt;</code> implizit zu konstruieren, erhalten wir einen Kompilierungsfehler, wie wir wollten: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;..., <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjuction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt;, is_implicity_default_constructible&lt;T&gt;, is_implicity_default_constructible&lt;U&gt; &gt;&gt;&gt; ... pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {}; ... candidate <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> ignored: requirement <span class="hljs-string"><span class="hljs-string">'conjunction_v&lt; is_default_constructible&lt;int&gt;, is_default_constructible&lt;B&gt;, is_implicity_default_constructible&lt;int&gt;, is_implicity_default_constructible&lt;B&gt; &gt;'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied [with T=<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, U=B]</code> </pre> <br><p>  In verschiedenen Compilern ist dieser Fehler unterschiedlich verst√§ndlich.  In diesem Fall sagt der Microsoft-Compiler beispielsweise: "Es war nicht m√∂glich, ein Paar <code>&lt;int, B&gt;</code> aus leeren geschweiften Klammern zu erstellen."  GCC und Clang werden noch hinzuf√ºgen: ‚ÄûWir haben so und so einen Konstruktor ausprobiert, keiner von ihnen ist aufgetaucht‚Äú, und sie werden jeweils einen Grund angeben. </p><br><p>  Welche Designer haben wir hier?  Es gibt Konstruktoren, die vom Compiler zum Kopieren und Verschieben generiert wurden, einige wurden von uns geschrieben.  Beim Kopieren und Verschieben ist alles einfach: Sie erwarten einen Parameter, wir √ºbergeben Null.  F√ºr unseren Konstruktor ist der Grund, dass die Substitution eine Diskette ist. </p><br><p>  GCC sagt: "Substitution fehlgeschlagen, versucht, den <code>enable_if&lt;false&gt;</code> in <code>enable_if&lt;false&gt;</code> - konnte <code>enable_if&lt;false&gt;</code> nicht gefunden werden." </p><br><p>  Clang betrachtet diese Situation als Sonderfall.  Daher zeigt er diesen Fehler sehr cool.  Wenn wir bei der Auswertung von <code>enable_if</code> ersten Arguments <code>false</code> , schreibt er, dass die spezifische Anforderung nicht erf√ºllt ist. </p><br><p>  Gleichzeitig haben wir selbst unser Leben verdorben, indem wir die umst√§ndliche Bedingung <code>enable_if</code> .  Wir sehen, dass es sich als <code>false</code> , aber wir sehen noch nicht warum. </p><br><p>  Dies kann √ºberwunden werden, wenn wir <code>enable_if</code> in vier <code>enable_if</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;..., <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_default_constructible&lt;T&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_default_constructible&lt;U&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_implicity_default_constructible&lt;T&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_implicity_default_constructible&lt;U&gt;::value&gt;&gt; &gt; ...</code> </pre> <br><p>  Wenn wir nun versuchen, implizit ein Paar zu konstruieren, erhalten wir eine hervorragende Nachricht, dass dieser und jener Kandidat nicht geeignet ist, weil das <code>is_implicitly_default_constructable</code> nicht erf√ºllt ist: </p><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {}; <span class="hljs-comment"><span class="hljs-comment">// candidate template ignored: requirement 'is_implicity_default_constructible&lt;B&gt;::value' was not satisfied with...</span></span></code> </pre> <br><p>  Es mag sogar f√ºr eine Sekunde scheinen: Warum brauchen wir ein Konzept, wenn wir einen so coolen Compiler haben? <br>  Wir erinnern uns jedoch daran, dass standardm√§√üig zwei Vorlagenfunktionen zum Implementieren des Konstruktors verwendet werden und jede Vorlage sechs Vorlagenparameter enth√§lt.  F√ºr eine Sprache, die behauptet, m√§chtig zu sein, ist dies eine Pleite. </p><br><p>  Wie hilft uns C ++ 20?  Entfernen Sie zun√§chst die Muster, indem Sie diese mit der require-Klausel umschreiben.  Was wir zuvor in <code>enable_if</code> , schreiben wir jetzt in das Argument der <code>enable_if</code> Klausel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; pair() requires DefaultConstructible&lt;F&gt; &amp;&amp; DefaultConstructible&lt;S&gt; &amp;&amp; ImplicitlyDefaultConstructible&lt;F&gt; &amp;&amp; ImplicitlyDefaultConstructible&lt;S&gt; : f(), s() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... }</span></span>;</code> </pre> <br><p>  Das Konzept von <code>ImplicitlyDefaultConstructible</code> kann mit einem so netten Ausdruck implementiert werden, in dem fast nur Klammern unterschiedlicher Form verwendet werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept ImplicitlyDefaultConstructible = requires { [] (T) {} ({}); };</code> </pre> <br><p>   <code>T</code>  <code>ImplicitlyDefaultConstructible</code> ,  ,     <code>T</code>      .  ,   ,      SFINAE. </p><br><p>    C++20:   (conditional) <code>explicit</code> (    <code>noexcept</code> ).     <code>explicit</code>  .          ,     <code>explicit</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span>(!ImplicityDefaultConstructible&lt;F&gt; || !ImplicityDefaultConstructible&lt;S&gt;) pair() requires DefaultConstructible&lt;F&gt; &amp;&amp; DefaultConstructible&lt;S&gt; : f(), s() {} };</code> </pre> <br><p>      ,   .      ,    <code>DefaultConstructible</code> ,   <code>explicit</code> ,       <code>explicit</code> . </p><br><h2 id="realizaciya-klassa-optional-v-c17">   Optional  C++17 </h2><br><p>       <code>Optional</code> .       ,     . </p><br><p>      .    ?   ,     C++    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Option&lt;T&gt; { None, Some(t) }</code> </pre> <br><p>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Optional</span></span></span><span class="hljs-class">&lt;T&gt; {</span></span> final T value; Optional() {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = null; } Optional(T value) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } }</code> </pre> <br><p>       C++:   <code>null</code> ,    value-? </p><br><p>    C++ .    <code>initialized</code>  <code>storage</code> ,      ,   .         <code>T</code> ,     <code>optional</code>   <code>T</code>   ,  C++ memory model. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> initialized; <span class="hljs-keyword"><span class="hljs-keyword">aligned_storage_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt; storage; ...</code> </pre> <br><p>    ,   .  :    <code>optional</code> ,   <code>optional</code>  .     : </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-function"><span class="hljs-function">T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T &amp;&gt;(storage); } <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;&gt;(storage); } <span class="hljs-function"><span class="hljs-function">T &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> move(get()); } optional() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : initialized(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) {} optional(T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; value) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;) : initialized(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) T(value); } ~optional() : <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowDestructible&lt;T&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) get().~T(); } };</code> </pre><br><p>  <code>optional</code> '   .    <code>optional</code> ,   <code>optional</code>  ,   ,   <code>optional</code>      .     ,        copy  move . </p><br><p>   .   :     assignment .   ,   .      .  copy constructor.   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> initialized; <span class="hljs-keyword"><span class="hljs-keyword">aligned_storage_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt; storage; ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;) : initialized(other.initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) T(other.get()); } optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...) {...} };</code> </pre> <br><p>  move assignment.    ,    : </p><br><ul><li>   <code>optional</code> ' ,    . </li><li>     ,   . </li><li>    ,   ‚Äî ,   ,  . </li></ul><br><p>      <code>T</code>  : move constructor, move assignment  : </p><br><pre> <code class="cpp hljs">optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { get() = move(other.get()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; other.initilized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(&amp;other.storage) T(move(get())); get().~T(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { initialized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; other.initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(&amp;storage) T(move(get())); other.get().~T(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br><p>         <code>noexcept</code> : </p><br><pre> <code class="cpp hljs">optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowAssignable&lt;T&gt; &amp;&amp; NothrowMoveConstructible&lt;T&gt; &amp;&amp; NothrowDestructible&lt;T&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { get() = move(other.get()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; other.initialized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;other.storage) T(move(get())); get().~T(); } } ... }</code> </pre> <br><p>  <code>optional</code>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;); optional(optional &amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowMoveConstructible&lt;T&gt;); optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...); optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...); };</code> </pre> <br><p>        ,        <code>pair</code> : <br>      <code>Optional</code>  -,        (, deleted),   compilation error. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class">&lt;unique_ptr&lt;int&gt;&gt;;</span></span> <span class="hljs-comment"><span class="hljs-comment">// compilation error</span></span></code> </pre> <br><p>    ,  <code>optional</code>  <code>unique_ptr</code>    , <br>  copy constructor  copy assignment   deleted.           ,    ,     SFINAE. <br>      copy  move   assignment ,       ‚Äî     .   - ,     copy ,      . </p><br><p>   ‚Äî  .        copy      : deleted operation , , operation: </p><br><ul><li> <code>deleted_copy_construct</code>    <code>delete</code> ,   ‚Äî <code>default</code> ; </li><li> <code>copy_construct</code>   ,   <code>copy_construct</code>     . </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deleted_copy_construct</span></span></span><span class="hljs-class"> :</span></span> Base { deleted_copy_construct(deleted_copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; deleted_copy_construct(deleted_copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; deleted_copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(deleted_copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; deleted_copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(deleted_copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy_construct</span></span></span><span class="hljs-class"> :</span></span> Base { copy_construct(copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(Base::construct(other))) { Base::construct(other); } copy_construct(copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br><p>   <code>select_copy_construct</code> ,     ,   <code>CopyConstrictuble</code>  ,    <code>copy_construct</code> ,  <code>deleted_copy_construct</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt; copy_construct&lt;Base&gt; deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p> ,    <code>optional</code> ,   <code>optional_base</code> , copy     <code>construct</code>   ,   <code>optional</code>   <br> <code>select_copy_construct&lt;T, optional_base&lt;T&gt;&gt;</code> .       copy : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional_base</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowCopyConstructible&lt;T&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((initialized = other.initialized)) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) t(other.get()); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_copy_construct&lt;T, optional_base&lt;T&gt;&gt; { ... };</code> </pre> <br><p>      . , ,    <code>copy_construct</code>    ,  <code>move_construct</code>       <code>copy_construct</code> , <code>copy_assign</code> , ,  <code>move_construct</code> ,        , ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class">&lt;T, conditional_t&lt;MoveConstructible&lt;T&gt;, move_construct&lt;Base&gt; &gt; &gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_assign</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_construct</span></span></span><span class="hljs-class">&lt;T, conditional_t&lt;CopyAssignable&lt;T&gt; &amp;&amp; CopyConstructible&lt;T&gt;, copy_assign&lt;Base&gt; delete_copy_assign&lt;Base&gt; &gt; &gt;;</span></span></code> </pre> <br><p> , <code>move_assign</code>  <code>copy_assign</code> , <code>optional_base</code>   ,    assignment   <code>construct</code>  <code>assign</code> ,  <code>optional</code>   <code>select_move_assign&lt;T, optional_base&lt;T&gt;&gt;</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_assign</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_assign</span></span></span><span class="hljs-class">&lt;T, ...&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional_base</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowCopyConstructible&lt;T&gt;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base &amp;&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowMoveConstructible&lt;T&gt;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">optional_base&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base &amp;&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">optional_base&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_move_assign&lt;T, optional_base&lt;T&gt;&gt; { ... };</code> </pre> <br><p> ,      : <br> <code>optional&lt;unique_ptr&gt;</code>   <code>deleted_copy_construct</code> ,   <br> <code>move_construct</code>   .  ! </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; : deleted_copy_construct&lt;...&gt; : move_construct&lt;...&gt; : deleted_copy_assign&lt;...&gt; : move_assign&lt;...&gt; : optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;</code> </pre> <br><p>       :  <code>optional</code>   <code>TriviallyCopyable</code>    <code>TriviallyCopyable</code> . </p><br><p>   <code>TriviallyCopyable</code> ?  ,  <code>T</code>  <code>TriviallyCopyable</code> ,    <br>    <code>memcpy</code> .    ,          . </p><br><p>  ,            , ,  .    <code>resize</code>  <code>vector</code> <code>TriviallyCopyable</code> ,              <code>memcpy</code> ,       ,   .  ,  ,    . </p><br><p>      <code>TriviallyCopyable</code> , ,     <code>static_assert</code> ',    copy-move     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_move_assign&lt;T, optional_base&lt;T&gt;&gt; {...}; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyable&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyConstructible&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyMoveConstructible&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyAssignable &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyMoveAssignable &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyDestructible &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;);</code> </pre> <br><p>      <code>static_assert</code> ' .  ,   ,      .   <code>optional</code> ‚Äî  <code>aligned_storage</code> ,  ,  ,   ,  <code>TriviallyCopyable</code> . </p><br><p>    ,          .       ,     <code>TriviallyCopyable</code> . </p><br><p>  ,      .     <code>select_copy_construct</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt;, copy_construct&lt;Base&gt; deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p>  <code>CopyContructible</code>    <code>copy_construct</code> ,      <code>if</code>  compile-time:   <code>CopyContructible</code>  <code>TriviallyCopyContructible</code> ,     <code>Base</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt;, conditional_t&lt;TriviallyCopyConstructible&lt;T&gt;, Base, copy_construct&lt;Base&gt; &gt;, deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p> ,     copy .        ,    <code>select_destruct</code>  .    <code>int</code>   ,  -     - ,    . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_destruct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;TriviallyDenstructible&lt;T&gt;, Base, destruct&lt;Base&gt; &gt; &gt;;</span></span></code> </pre> <br><p>  ,     ,    .  , ,  : </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; : deleted_copy_construct&lt;...&gt; : move_construct&lt;...&gt; : deleted_copy_assign&lt;...&gt; : move_assign&lt;...&gt; : destruct&lt;optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; : optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;</code> </pre> <br><p>  ,  C++17   <code>optional</code>      7;      :    <code>operation</code> , <code>deleted_operation</code>   <code>select_operation</code> ;   <code>construct</code>  <code>assign</code>   .  ,    . </p><br><p>     -   .      .        :   deleted. </p><br><p>  ,       <code>noexcept</code> . <br>  ,   ,   ,    <code>trivial</code> , <code>noexcept</code>         .   ,   ,    <code>trivial</code>  <code>noexcept</code> ,   <code>noexcept</code> ,    <code>deleted</code> .           .        ,     ,    . </p><br><p>          type trait,  ,        . , , copy :  <code>deleted</code>  ,  <code>nothrow</code>  ,    ? </p><br><p>   ,            - special member, ,    ,    ,     : </p><br><ul><li>   ,    <code>deleted</code> ,   <code>= delete</code>      <code>deleted_copy_construct</code> ; </li><li>      ,     <code>copy_construct</code> ,   c  noexcept ; </li><li> ,   ,     ,  . </li></ul><br><p>              . </p><br><h2 id="realizaciya-klassa-optional-v-c20">   optional  C++20 </h2><br><p>   C++20   <code>optional</code>   copy ? <br>   : </p><br><ul><li>   <code>T</code>  <code>CopyConstructible</code> ,     <code>deleted</code> ; </li><li>   <code>TriviallyCopyConstructible</code> ,   ; </li><li>        <code>noexcept</code> . </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) requires(!CopyConstructible&lt;T&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// #1 optional(optional const &amp;) requires(TriviallyCopyConstructible&lt;T&gt;) = default; // #2 optional(optional const &amp;) noexcept(NothrowCopyConstructible&lt;T&gt;) {...} // #3 ... ~optional() requires(TriviallyDestructible&lt;T&gt;) = default; ~optional() noexcept(NothroeDestructible&lt;T&gt;) {...} };</span></span></code> </pre> <br><p>  ,   . -,     ,      <code>T</code>  requires clause      <code>false</code> .    <code>requires(false)</code> ,   ,      overload resolution.     ,        <code>requires(true)</code> ,             . <br>         ,    . </p><br><p>   requires clause    <code>= delete</code> : </p><br><ul><li>   <code>= delete</code>   overload resolution,     ,     ,     deleted . </li><li>   <code>requires(false)</code>     overload resolution. </li></ul><br><p>   ,     copy ,  ,    requires clause.       . </p><br><p>  ,      . !    C++    ,   ?  , , .        ,   ,    ,     .   ,   ,     ,      , ,   <code>optional</code> . </p><br><p> ,       ,  GCC   internal compiler error,  Clang    .   ,   .     ,  . </p><br><p>  ,   ,       <code>optional</code>  C++20.  ,   ,   C++17. </p><br><h1 id="alternativa-aligned_storage-i-aligned_union">  aligned_storage  aligned_union </h1><br><p>   :   <code>aligned_storage</code>         <code>reinterpret_cast</code> ,  <code>reinterpret_cast</code>    constexpr . ,  compile-time  <code>optional</code>   ,         compile-time.    STL   <code>aligned_storage</code>   <code>optional</code>    <code>aligned_union</code>   <code>variant</code> . ,  ,     STL  Boost    <code>optional</code>  <code>variant</code> .     <code>variant</code> ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all_types_are_trivially_destructible, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>...&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> _Variant_storage = _Variant_storage_&lt; conjunction_v&lt;is_trivially_destructible&lt;_Types&gt;...&gt;, _Types... &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _First, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Rest&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">&lt;true, _First, _Rest...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;First&gt; _Head; _Variant_storage&lt;_Rest...&gt; _Tail; }; };</code> </pre> <br><p>      <code>variant</code> .    <code>_Variant_storage_</code> ,  , -, ,    <code>variant</code> ,  -,    .  ,    <code>trivially_destructible</code> ?     type alias,       .      <code>_Variant_storage_</code>  ,    <code>true</code>    <code>false</code> . ,   <code>true</code> ,  .      <code>trivially_destructible</code> ,     union     <code>Variant</code> '  . </p><br><p>  ,  ,   ,  ,    .     type alias  <code>_Variant_storage</code> .      : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> = conjunction_v&lt;is_trivially_destructible&lt;_Types&gt;...&gt; &gt; class _Variant_storage_;</code> </pre> <br><p>        .        ,   variadic template    . ,        ,            ,          <code>_Types</code> .   C++17  ,   . </p><br><p>  C++20        , <br>     ,       <br> requires clause.        C++20    requires clause: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _First, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Rest&gt; requires(TriviallyDestructible&lt;_First&gt; &amp;&amp; ... &amp;&amp; TriviallyDestuctible&lt;_Rest&gt;) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">&lt;_First, _Rest...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;_First&gt; _Head; _Variant_storage_&lt;_Rest...&gt; _Tail }; };</code> </pre> <br><p>    <code>_Variant_storage_</code> ,     <code>TriviallyDestructible</code> .  ,       requires clause   ,   ,       . </p><br><h1 id="ispolzovanie-requires-clause-dlya-template-type-alias">  requires clause  template type alias </h1><br><p> ,     requires clause   template type alias.      C++20  -  <code>enable_if</code> ,         : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> condition, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; requires condition <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span> = T;</code> </pre> <br><h1 id="kod-kotoryy-ne-podderzhit-ni-odin-kompilyator"> ,       </h1><br><p>  ,         .       : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Equivalent, but functionally not equivalent template&lt;typename T&gt; enable_if_t&lt;(sizeof(T) &lt; 239)&gt; f(); template&lt;typename T&gt; enable_if_t&lt;(sizeof(T) &gt; 239)&gt; f(); // Not equivalent template&lt;typename T&gt; requires(sizeof(T) &lt; 239) void f(); template&lt;typename T&gt; requires(sizeof(T) &gt; 239) void f();</span></span></code> </pre> <br><p>       ,     <code>enable_if</code>      .    ?     <code>f()</code> :   <code>enable_if</code> ,      ,  239, , ,  ,  239.       ,     : </p><br><ul><li>   ,      ,     template type alias',      ¬´void f(); void f(); </li><li>   ,    SFINAE, ,      ,     . </li></ul><br><p> ,     <code>enable_if</code> ,      ,          <code>size &lt; 239</code> ,      <code>size &gt; 239</code> .      ,            .      ,      <code>f()</code>   .       requires clause.    ‚Äî   ,      . </p><br><blockquote>        ‚Äî  ,      .      C++ Russia 2019 Piter,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´:   core language¬ª</a> .     , , :   reachable entity      visible,     ADL,   entities  internal linkage    .   ,    C++ Russia       (JetBrains)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´  ++20 ‚Äî   ?¬ª</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467299/">https://habr.com/ru/post/de467299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467281/index.html">Portr√§t eines Datenwissenschaftlers in Russland. Nur Fakten</a></li>
<li><a href="../de467283/index.html">Wie Sie Ihrer Gro√ümutter den Unterschied zwischen SQL und NoSQL erkl√§ren k√∂nnen</a></li>
<li><a href="../de467289/index.html">Entwicklung eines monolithischen Unix-√§hnlichen Betriebssystems - GDT & IDT (5)</a></li>
<li><a href="../de467291/index.html">iOS f√ºr Kreativit√§t: Zeichnen</a></li>
<li><a href="../de467295/index.html">Die lang erwartete View Binding in Android</a></li>
<li><a href="../de467301/index.html">Wie KI in Hitman funktioniert (2016)</a></li>
<li><a href="../de467303/index.html">Die Geschichte des j√ºngsten PSB-Programmierers: Der Hackathon wurde zur T√ºr zur Bank</a></li>
<li><a href="../de467305/index.html">Wenn die Stadt schlau ist: das Erlebnis von Megacities</a></li>
<li><a href="../de467313/index.html">Kreuzreplikation zwischen PostgreSQL und MySQL</a></li>
<li><a href="../de467317/index.html">Wie SoftBank die Welt verschluckte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>