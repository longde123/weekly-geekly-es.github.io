<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏾 🚁 😸 Bypass ILV mengunci dengan DNSTap dan BGP ⬜️ 👍 👨🏻‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Subjeknya cukup keluar dari gambar, saya tahu. Misalnya, ada artikel yang bagus, tetapi hanya bagian IP dari daftar blokir yang dipertimbangkan di san...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bypass ILV mengunci dengan DNSTap dan BGP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467547/"><p><img src="https://habrastorage.org/webt/zg/if/qq/zgifqqqqol7bai9dlh3_e-3cgn8.png"></p><br><p>  Subjeknya cukup keluar dari gambar, saya tahu.  Misalnya, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> bagus, tetapi hanya bagian IP dari daftar blokir yang dipertimbangkan di sana.  Kami juga akan menambahkan domain. </p><br><p>  Karena fakta bahwa pengadilan dan ILV memblokir semuanya dengan benar dan kiri, dan penyedia berusaha keras untuk tidak jatuh di bawah denda yang dikeluarkan oleh "Revizorro" - kerugian terkait dari kunci cukup besar.  Ya, dan di antara situs yang "diblokir" secara legal ada banyak yang bermanfaat (halo, rutracker) </p><br><p>  Saya tinggal di luar yurisdiksi ILV, tetapi orang tua, kerabat, dan teman saya tetap di rumah.  Jadi diputuskan untuk membuat cara untuk memotong kunci yang mudah bagi mereka yang jauh dari IT, lebih disukai tanpa partisipasi mereka. </p><br><p>  Dalam artikel ini, saya tidak akan menjelaskan hal-hal dasar jaringan dalam langkah-langkah, tetapi menjelaskan prinsip-prinsip umum tentang bagaimana skema ini dapat diimplementasikan.  Jadi pengetahuan tentang bagaimana jaringan bekerja secara umum dan di Linux pada khususnya adalah harus dimiliki. </p><a name="habracut"></a><br><h1 id="tipy-blokirovok">  Jenis kunci </h1><br><p>  Pertama, mari menyegarkan apa yang diblokir. </p><br><p>  Ada beberapa jenis kunci dalam paged XML dari ILV: </p><br><ul><li>  IP </li><li>  Domain </li><li>  URL </li></ul><br><p>  Untuk kesederhanaan, kami akan menguranginya menjadi dua: IP dan domain, dan kami hanya akan menarik domain keluar dari pemblokiran URL (lebih tepatnya, kami telah melakukan ini). </p><br><p>  Orang-orang baik dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Roskomsvoboda telah</a> menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API</a> luar biasa yang melaluinya kita dapat memperoleh apa yang kita butuhkan: </p><br><ul><li>  IP: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://api.reserve-rbl.ru/api/v2/ips/json</a> </li><li>  Domain: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://api.reserve-rbl.ru/api/v2/domains/json</a> </li></ul><br><h1 id="dostup-k-zablokirovannym-saytam">  Akses situs yang diblokir </h1><br><p>  Untuk melakukan ini, kita memerlukan beberapa VPS asing kecil, lebih disukai dengan lalu lintas tanpa batas - ada banyak 3-5 dolar.  Anda perlu membawanya di dekat luar negeri agar ping tidak terlalu besar, tetapi sekali lagi memperhitungkan bahwa Internet dan geografi tidak selalu bersamaan.  Dan karena tidak ada SLA untuk 5 dolar, lebih baik mengambil 2+ buah dari penyedia yang berbeda untuk toleransi kesalahan. </p><br><p>  Selanjutnya, kita perlu mengkonfigurasi tunnel terenkripsi dari router klien ke VPS.  Saya menggunakan Wireguard sebagai yang tercepat dan termudah untuk dikonfigurasikan sejak itu  Saya juga memiliki router klien yang berbasis Linux ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">APU2</a> atau sesuatu di OpenWRT).  Dalam beberapa Mikrotik / Cisco, Anda dapat menggunakan protokol yang tersedia pada mereka seperti OpenVPN dan GRE-over-IPSEC. </p><br><h1 id="identifikaciya-i-perenapravlenie-interesuyuschego-traffika">  Identifikasi dan pengalihan lalu lintas kepentingan </h1><br><p>  Anda tentu saja dapat sepenuhnya membungkus semua lalu lintas Internet melalui luar negeri.  Tetapi, kemungkinan besar, kecepatan bekerja dengan konten lokal akan sangat menderita karenanya.  Plus, persyaratan bandwidth pada VPS akan jauh lebih tinggi. </p><br><p>  Karena itu, kita perlu mengalokasikan lalu lintas ke situs yang diblokir dan mengirimnya ke terowongan secara selektif.  Bahkan jika beberapa bagian dari lalu lintas "ekstra" tiba di sana, itu masih jauh lebih baik daripada mengendarai semuanya melalui terowongan. </p><br><p>  Untuk mengelola lalu lintas, kami akan menggunakan protokol BGP dan mengumumkan rute ke jaringan yang diperlukan dari VPS kami ke klien.  Sebagai daemon BGP, mari kita ambil BIRD, sebagai salah satu yang paling fungsional dan nyaman. </p><br><h3 id="ip">  IP </h3><br><p>  Dengan pemblokiran IP, semuanya jelas: kami baru saja mengumumkan semua IP yang diblokir dengan VPS.  Masalahnya adalah bahwa ada sekitar 600 ribu subnet dalam daftar yang diberikan oleh API, dan sebagian besar adalah / 32 host.  Sejumlah rute seperti itu bisa membingungkan bagi router klien yang lemah. </p><br><p>  Oleh karena itu, diputuskan untuk meringkas ke jaringan / 24 ketika memproses daftar jika ada 2 atau lebih host di dalamnya.  Dengan demikian, jumlah rute dikurangi menjadi ~ 100 ribu.  Script untuk ini akan menjadi yang berikutnya. </p><br><h3 id="domeny">  Domain </h3><br><p>  Ini lebih rumit dan ada beberapa cara.  Misalnya, Anda dapat meletakkan Squid transparan pada setiap router klien dan melakukan intersepsi HTTP dan mengintip dalam jabat tangan TLS untuk mendapatkan URL yang diminta dalam kasus pertama dan domain dari SNI di yang kedua. </p><br><p>  Tetapi karena semua TLS1.3 + eSNI bermodel baru, analisis HTTPS menjadi semakin tidak nyata setiap hari.  Dan infrastruktur di sisi klien menjadi lebih rumit - Anda harus menggunakan setidaknya OpenWRT. </p><br><p>  Oleh karena itu, saya memutuskan untuk mengambil jalur mencegat tanggapan terhadap permintaan DNS.  Di sini, juga, DNS-over-TLS / HTTPS mulai melonjak di atas kepala kami, tetapi kami dapat (untuk saat ini) mengontrol bagian ini pada klien - baik menonaktifkannya atau menggunakan server kami sendiri untuk DoT / DoH. </p><br><h4 id="kak-perehvatyvat-dns">  Bagaimana cara mencegat DNS? </h4><br><p>  Mungkin juga ada beberapa pendekatan. </p><br><ul><li>  Intersepsi lalu lintas DNS melalui PCAP atau NFLOG <br>  Kedua metode intersepsi ini diimplementasikan dalam utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sidmat</a> .  Tapi itu belum didukung untuk waktu yang lama dan fungsinya sangat primitif, jadi Anda harus tetap menulis yang mengikat. </li><li>  Analisis log server DNS <br>  Sayangnya, rekursi yang saya tahu tidak tahu cara mencatat jawaban, tetapi hanya permintaan.  Pada prinsipnya, ini logis, karena tidak seperti permintaan, jawaban memiliki struktur yang kompleks dan sulit untuk menuliskannya dalam bentuk teks. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DNSTap</a> <br>  Untungnya, banyak dari mereka sudah mendukung DNSTap untuk keperluan ini. </li></ul><br><h4 id="chto-takoe-dnstap">  Apa itu DNSTap? </h4><br><p><img src="https://habrastorage.org/webt/gc/4g/qs/gc4gqsppif5ypkbf06ok0oihll4.png"></p><br><p>  Ini adalah protokol client-server berdasarkan Protokol Buffer dan Frame Stream untuk mentransfer dari server DNS ke kolektor pertanyaan dan respons DNS terstruktur.  Bahkan, server DNS mentransmisikan metadata dari permintaan dan tanggapan (jenis pesan, IP klien / server, dan sebagainya) ditambah pesan DNS lengkap dalam bentuk (biner) di mana ia bekerja bersama mereka melalui jaringan. </p><br><p>  Penting untuk dipahami bahwa dalam paradigma DNSTap, server DNS bertindak sebagai klien, dan kolektor sebagai server.  Artinya, server DNS terhubung ke kolektor, dan bukan sebaliknya. </p><br><p>  Hari ini DNSTap didukung di semua server DNS populer.  Tetapi, misalnya, BIND dalam banyak distribusi (seperti Ubuntu LTS) sering dibangun untuk beberapa alasan tanpa dukungannya.  Jadi kita tidak akan repot membangun kembali, tetapi mengambil recursor yang lebih ringan dan cepat - Tidak terikat. </p><br><h4 id="chem-lovit-dnstap">  Bagaimana cara menangkap DNSTap? </h4><br><p>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sejumlah</a> utilitas CLI untuk bekerja dengan aliran acara DNSTap, tetapi mereka tidak berfungsi dengan baik untuk tugas kita.  Jadi saya memutuskan untuk menciptakan sepeda sendiri yang akan melakukan apa pun yang diperlukan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>dnstap-bgp</strong></a> </p><br><p>  Algoritma Operasi: </p><br><ul><li>  Saat diluncurkan, ia memuat daftar domain dari file teks, membalikkannya (habr.com -&gt; com.habr), tidak termasuk garis terputus, duplikat, dan subdomain (mis. Jika habr.com dan www.habr.com ada dalam daftar - itu akan dimuat hanya yang pertama) dan buat pohon awalan untuk pencarian cepat pada daftar ini </li><li>  Bertindak sebagai server DNSTap, menunggu koneksi dari server DNS.  Pada prinsipnya, ia mendukung soket UNIX dan TCP, tetapi server DNS yang saya tahu hanya dapat menggunakan soket UNIX </li><li>  Paket DNSTap yang masuk dideserialisasi terlebih dahulu ke dalam struktur Protobuf, dan kemudian pesan DNS biner yang terletak di salah satu bidang Protobuf diurai ke tingkat catatan DNS RR </li><li>  Memeriksa apakah host yang diminta (atau domain induknya) ada dalam daftar yang dimuat, jika tidak, responsnya diabaikan </li><li>  Hanya A / AAAA / CNAME RR yang dipilih dari respons dan alamat IPv4 / IPv6 yang sesuai ditarik darinya </li><li>  Alamat IP di-cache dengan TTL khusus dan diiklankan ke semua rekan BGP yang dikonfigurasi </li><li>  Setelah menerima tanggapan yang menunjukkan IP yang sudah di-cache - TTL-nya diperbarui </li><li>  Setelah TTL berakhir, catatan dihapus dari cache dan dari pengumuman BGP </li></ul><br><p>  Fungsionalitas tambahan: </p><br><ul><li>  Membaca ulang daftar domain oleh SIGHUP </li><li>  Menyinkronkan cache dengan <strong>instance dnstap-bgp lainnya</strong> melalui HTTP / JSON </li><li>  Duplikasi cache pada disk (dalam database BoltDB) untuk mengembalikan kontennya setelah restart </li><li>  Dukungan untuk beralih ke namespace jaringan yang berbeda (mengapa ini akan dijelaskan di bawah) </li><li>  Dukungan IPv6 </li></ul><br><p>  Keterbatasan: </p><br><ul><li>  Domain IDN belum didukung </li><li>  Beberapa Pengaturan BGP </li></ul><br><p>  Saya telah menyusun paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RPM dan DEB</a> untuk kemudahan instalasi.  Harus bekerja pada semua OS yang relatif baru dengan systemd, as  mereka tidak memiliki ketergantungan. </p><br><h1 id="shema">  Skema </h1><br><p>  Jadi, mari kita mulai merakit semua komponen bersama-sama.  Akibatnya, kita harus mendapatkan sesuatu seperti topologi jaringan ini: <br><img src="https://habrastorage.org/webt/cm/ks/uo/cmksuol_njfgyjznmlf3oj6u94m.png"></p><br><p>  Logika kerja, saya pikir, jelas dari diagram: </p><br><ul><li>  Klien memiliki server kami yang dikonfigurasi sebagai DNS, dan permintaan DNS juga harus melalui VPN.  Ini diperlukan agar penyedia tidak dapat menggunakan intersepsi DNS untuk memblokir. </li><li>  Ketika situs dibuka, klien mengirim permintaan DNS dari formulir "apa yang dimiliki IP.org?" </li><li>  <strong>Tidak terikat</strong> menyelesaikan xxx.org (atau mengambilnya dari cache) dan mengirimkan respons ke klien "xxx.org memiliki IP ini dan itu", menduplikasinya secara paralel melalui DNSTap </li><li>  <strong>dnstap-bgp</strong> mengumumkan alamat-alamat ini dalam <strong>BIRD</strong> oleh BGP jika domainnya ada dalam daftar diblokir </li><li> <strong>BIRD</strong> mengumumkan rute ke IP-IP ini dengan router <code>next-hop self</code> </li><li>  Paket selanjutnya dari klien ke IP ini melewati terowongan </li></ul><br><p>  Di server, untuk rute ke situs yang diblokir, saya memiliki tabel terpisah di dalam BIRD dan tidak bersinggungan dengan OS. </p><br><p>  Ada kekurangan dalam skema ini: paket SYN pertama dari klien kemungkinan besar akan memiliki waktu untuk pergi melalui penyedia domestik karena  rute tidak diumumkan secara instan.  Dan di sini opsi dimungkinkan tergantung pada bagaimana penyedia membuat kunci.  Jika dia hanya menjatuhkan lalu lintas, maka tidak ada masalah.  Dan jika dia mengalihkannya ke beberapa DPI, maka (secara teoritis) efek khusus mungkin terjadi. </p><br><p>  Mukjizat juga mungkin terjadi dengan klien yang tidak mengamati DNS TTL, yang dapat menyebabkan klien menggunakan beberapa entri usang dari cache busuk mereka alih-alih meminta Tidak terikat. </p><br><p>  Dalam praktiknya, baik yang pertama maupun yang kedua tidak menimbulkan masalah bagi saya, tetapi jarak tempuh Anda mungkin bervariasi. </p><br><h2 id="nastroyka-servera">  Pengaturan server </h2><br><p>  Untuk kemudahan bergulir, saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peran untuk Ansible</a> .  Ia dapat mengonfigurasi server dan klien berbasis Linux (dirancang untuk distribusi berbasis deb).  Semua pengaturan cukup jelas dan diatur di <em>inventory.yml</em> .  Peran ini dipotong dari buku pedoman besar saya, jadi mungkin mengandung kesalahan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tarik permintaan,</a> selamat datang :) </p><br><p>  Mari kita lihat komponen utama. </p><br><h3 id="bgp">  BGP </h3><br><p>  Saat meluncurkan dua daemon BGP pada host yang sama, muncul masalah mendasar: BIRD tidak ingin meningkatkan peering BGP dengan localhost (atau dengan antarmuka lokal apa pun).  Dari kata sama sekali.  Googling dan membaca milis tidak membantu, mereka mengklaim itu adalah desain.  Mungkin ada beberapa cara, tetapi saya tidak menemukannya. </p><br><p>  Anda dapat mencoba daemon BGP lain, tapi saya suka BIRD dan digunakan di mana-mana dengan saya, saya tidak ingin menghasilkan entitas. </p><br><p>  Oleh karena itu, saya menyembunyikan dnstap-bgp di dalam namespace jaringan, yang terhubung ke root melalui antarmuka veth: itu seperti pipa yang ujungnya menonjol di namespace yang berbeda.  Pada masing-masing ujung ini kita menggantung alamat IP p2p pribadi yang tidak pergi ke luar host, sehingga mereka bisa berupa apa saja.  Ini adalah mekanisme yang sama yang digunakan untuk mengakses proses di dalam Docker <em>tercinta</em> dan wadah lainnya. </p><br><p>  Untuk ini, <a href="">skrip</a> ditulis dan dalam dnstap-bgp fungsionalitas yang dijelaskan di atas untuk menyeret diri oleh rambut ke namespace lain ditambahkan.  Karena itu, ini harus dijalankan sebagai root atau dikembalikan ke biner CAP_SYS_ADMIN melalui perintah setcap. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh skrip untuk membuat namespace</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash NS="dtap" IP="/sbin/ip" IPNS="$IP netns exec $NS $IP" IF_R="veth-$NS-r" IF_NS="veth-$NS-ns" IP_R="192.168.149.1" IP_NS="192.168.149.2" /bin/systemctl stop dnstap-bgp || true $IP netns del $NS &gt; /dev/null 2&gt;&amp;1 $IP netns add $NS $IP link add $IF_R type veth peer name $IF_NS $IP link set $IF_NS netns $NS $IP addr add $IP_R remote $IP_NS dev $IF_R $IP link set $IF_R up $IPNS addr add $IP_NS remote $IP_R dev $IF_NS $IPNS link set $IF_NS up /bin/systemctl start dnstap-bgp</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">dnstap-bgp.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">namespace = "dtap" domains = "/var/cache/rkn_domains.txt" ttl = "168h" [dnstap] listen = "/tmp/dnstap.sock" perm = "0666" [bgp] as = 65000 routerid = "192.168.149.2" peers = [ "192.168.149.1", ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">bird.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">router id 192.168.1.1; table rkn; # Clients protocol bgp bgp_client1 { table rkn; local as 65000; neighbor 192.168.1.2 as 65000; direct; bfd on; next hop self; graceful restart; graceful restart time 60; export all; import none; } # DNSTap-BGP protocol bgp bgp_dnstap { table rkn; local as 65000; neighbor 192.168.149.2 as 65000; direct; passive on; rr client; import all; export none; } # Static routes list protocol static static_rkn { table rkn; include "rkn_routes.list"; import all; export none; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">rkn_routes.list</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">route 3.226.79.85/32 via "ens3"; route 18.236.189.0/24 via "ens3"; route 3.224.21.0/24 via "ens3"; ...</code> </pre> </div></div><br><h3 id="dns">  DNS </h3><br><p>  Secara default, di Ubuntu, biner Unbound dijepit oleh profil AppArmor, yang mencegahnya terhubung ke soket DNSTap di sana.  Anda dapat menghapus profil ini atau menonaktifkannya: </p><br><pre> <code class="plaintext hljs"># cd /etc/apparmor.d/disable &amp;&amp; ln -s ../usr.sbin.unbound . # apparmor_parser -R /etc/apparmor.d/usr.sbin.unbound</code> </pre> <br><p>  Ini mungkin harus ditambahkan ke buku pedoman.  Sangat ideal, tentu saja, untuk memperbaiki profil dan mengeluarkan hak yang diperlukan, tetapi saya terlalu malas. </p><br><div class="spoiler">  <b class="spoiler_title">unbound.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">server: chroot: "" port: 53 interface: 0.0.0.0 root-hints: "/var/lib/unbound/named.root" auto-trust-anchor-file: "/var/lib/unbound/root.key" access-control: 192.168.0.0/16 allow remote-control: control-enable: yes control-use-cert: no dnstap: dnstap-enable: yes dnstap-socket-path: "/tmp/dnstap.sock" dnstap-send-identity: no dnstap-send-version: no dnstap-log-client-response-messages: yes</code> </pre> </div></div><br><h3 id="skachivanie-i-obrabotka-spiskov">  Mengunduh dan memproses daftar </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skrip untuk mengunduh dan memproses daftar alamat IP</a> <br>  Ia mengunduh daftar, merangkum sebelum awalan <em>pfx</em> .  Dalam <em>dont_add</em> dan <em>dont_summarize,</em> Anda dapat memberitahu IP dan jaringan untuk melewati atau tidak merangkum.  Saya membutuhkannya karena  subnet VPS saya ada di daftar blokir :) </p><br><p>  Yang lucu adalah bahwa RosKomSvoboda API memblokir permintaan dengan agen pengguna Python default.  Sepertinya naskah kiddy mengerti.  Karena itu, kami mengubahnya ke Firelis. </p><br><p>  Sejauh ini, ini hanya berfungsi dengan IPv4 karena  IPv6 kecil, tetapi akan mudah diperbaiki.  Kecuali jika perlu menggunakan juga bird6. </p><br><div class="spoiler">  <b class="spoiler_title">rkn.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 import json, urllib.request, ipaddress as ipa url = 'https://api.reserve-rbl.ru/api/v2/ips/json' pfx = '24' dont_summarize = { # ipa.IPv4Network('1.1.1.0/24'), } dont_add = { # ipa.IPv4Address('1.1.1.1'), } req = urllib.request.Request( url, data=None, headers={ 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.47 Safari/537.36' } ) f = urllib.request.urlopen(req) ips = json.loads(f.read().decode('utf-8')) prefix32 = ipa.IPv4Address('255.255.255.255') r = {} for i in ips: ip = ipa.ip_network(i) if not isinstance(ip, ipa.IPv4Network): continue addr = ip.network_address if addr in dont_add: continue m = ip.netmask if m != prefix32: r[m] = [addr, 1] continue sn = ipa.IPv4Network(str(addr) + '/' + pfx, strict=False) if sn in dont_summarize: tgt = addr else: tgt = sn if not sn in r: r[tgt] = [addr, 1] else: r[tgt][1] += 1 o = [] for n, v in r.items(): if v[1] == 1: o.append(str(v[0]) + '/32') else: o.append(n) for k in o: print(k)</span></span></code> </pre> </div></div><br><p>  <a href="">Skrip untuk diperbarui</a> <br>  Itu dimulai pada mahkota saya sekali sehari, mungkin perlu menariknya setiap 4 jam, karena  ini, menurut saya, adalah periode pembaruan yang ILV butuhkan dari penyedia.  Selain itu, ada beberapa kunci lain yang sangat mendesak agar mereka dapat terbang lebih cepat. </p><br><p>  Apakah yang berikut ini: </p><br><ul><li>  Jalankan skrip pertama dan <code>rkn_routes.list</code> daftar rute ( <code>rkn_routes.list</code> ) untuk BIRD </li><li>  Reload BIRD </li><li>  Memperbarui dan membersihkan daftar domain untuk dnstap-bgp </li><li>  Pindahkan dnstap-bgp </li></ul><br><div class="spoiler">  <b class="spoiler_title">rkn_update.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash ROUTES="/etc/bird/rkn_routes.list" DOMAINS="/var/cache/rkn_domains.txt" # Get &amp; summarize routes /opt/rkn.py | sed 's/\(.*\)/route \1 via "ens3";/' &gt; $ROUTES.new if [ $? -ne 0 ]; then rm -f $ROUTES.new echo "Unable to download RKN routes" exit 1 fi if [ -e $ROUTES ]; then mv $ROUTES $ROUTES.old fi mv $ROUTES.new $ROUTES /bin/systemctl try-reload-or-restart bird # Get domains curl -s https://api.reserve-rbl.ru/api/v2/domains/json -o - | jq -r '.[]' | sed 's/^\*\.//' | sort | uniq &gt; $DOMAINS.new if [ $? -ne 0 ]; then rm -f $DOMAINS.new echo "Unable to download RKN domains" exit 1 fi if [ -e $DOMAINS ]; then mv $DOMAINS $DOMAINS.old fi mv $DOMAINS.new $DOMAINS /bin/systemctl try-reload-or-restart dnstap-bgp</span></span></code> </pre> </div></div><br><p>  Itu ditulis tanpa banyak pemikiran, jadi jika Anda melihat apa yang dapat diperbaiki, lakukanlah. </p><br><h2 id="nastroyka-klienta">  Pengaturan klien </h2><br><p>  Di sini saya akan memberikan contoh untuk router Linux, tetapi dalam kasus Mikrotik / Cisco ini harus lebih sederhana. </p><br><p>  Pertama, konfigurasikan BIRD: </p><br><div class="spoiler">  <b class="spoiler_title">bird.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">router id 192.168.1.2; table rkn; protocol device { scan time 10; }; # Servers protocol bgp bgp_server1 { table rkn; local as 65000; neighbor 192.168.1.1 as 65000; direct; bfd on; next hop self; graceful restart; graceful restart time 60; rr client; export none; import all; } protocol kernel { table rkn; kernel table 222; scan time 10; export all; import none; }</code> </pre> </div></div><br><p>  Dengan demikian, kami akan menyinkronkan rute yang diterima dari BGP dengan nomor tabel rute kernel 222. </p><br><p>  Setelah itu, cukup meminta kernel untuk melihat plat ini sebelum melihat default: </p><br><pre> <code class="plaintext hljs"># ip rule add from all pref 256 lookup 222 # ip rule 0: from all lookup local 256: from all lookup 222 32766: from all lookup main 32767: from all lookup default</code> </pre> <br><p>  Yang tersisa adalah mengkonfigurasi DHCP pada router untuk mendistribusikan alamat IP tunnel server sebagai DNS dan skema siap. </p><br><h1 id="nedostatki">  Kekurangan </h1><br><p>  Dengan algoritma saat ini untuk membuat dan memproses daftar domain, <code>youtube.com</code> dan CDN-nya termasuk di dalamnya. </p><br><p>  Dan ini mengarah pada fakta bahwa semua video akan melalui VPN, yang dapat menyumbat seluruh saluran.  Mungkin ada baiknya menyusun daftar domain pengecualian populer yang diblokir di ILV untuk saat ini.  Dan lewati saat parsing. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Metode yang dijelaskan ini memungkinkan Anda untuk mem-bypass hampir semua kunci yang saat ini diterapkan oleh penyedia. </p><br><p>  Pada prinsipnya, <em>dnstap-bgp</em> dapat digunakan untuk tujuan lain di mana diperlukan tingkat kontrol lalu lintas tertentu berdasarkan nama domain.  Perlu diingat bahwa saat ini seribu situs dapat bertahan di alamat IP yang sama (untuk beberapa Cloudflare, misalnya), sehingga metode ini memiliki akurasi yang agak rendah. </p><br><p>  Tetapi untuk kebutuhan melewati kunci, ini sudah cukup. </p><br><p>  Tambahan, suntingan, pull-quest dipersilahkan! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467547/">https://habr.com/ru/post/id467547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467531/index.html">Mesin keadaan reaktif</a></li>
<li><a href="../id467533/index.html">Mendengarkan suara bising informasi: musik dan video yang seharusnya tidak ditemukan oleh siapa pun</a></li>
<li><a href="../id467539/index.html">Forum CA / B Memilih Penghapusan Sertifikat SSL menjadi 397 Hari</a></li>
<li><a href="../id467543/index.html">Ssh-chat, bagian 2</a></li>
<li><a href="../id467545/index.html">ShIoTiny: jam tanpa pegas atau waktu nyata dan cara bekerja dengannya</a></li>
<li><a href="../id467549/index.html">SpaceX berencana untuk menggunakan jaringan Internet satelit lebih awal dari yang direncanakan</a></li>
<li><a href="../id467551/index.html">Frontend Weekly Digest (9 - 15 September 2019)</a></li>
<li><a href="../id467555/index.html">Seberapa baik Anda mengenal CSS? (+ uji mini)</a></li>
<li><a href="../id467557/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 380 (8-15 September, 2019)</a></li>
<li><a href="../id467559/index.html">Acara digital di Moskow dari 16 September hingga 22 September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>