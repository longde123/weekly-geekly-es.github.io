<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😑 🐖 👩‍👩‍👧 Curso MIT "Segurança de sistemas de computadores". Palestra 10: Execução Simbólica, Parte 1 🆚 🤰 🧖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Palestra 10: Execução Simbólica, Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425557/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: “Separação de Privilégios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 5: “De onde vêm os sistemas de segurança?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  Palestra 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 7: “Sandbox do Cliente Nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 8: “Modelo de Segurança de Rede” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 9: “Segurança de aplicativos da Web” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 10: “Execução Simbólica” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Bom dia a todos, sou Armando Solar-Lesam e hoje darei uma palestra sobre performance simbólica.  Quem dentre os presentes aqui está familiarizado com esse termo ou já ouviu falar disso antes?  Eu só quero ter uma idéia do nosso público.  Então, vamos começar.  Larguei meu laptop várias vezes, por isso leva muito tempo para carregar. <br><br><img src="https://habrastorage.org/webt/t1/d0/ik/t1d0ikzwlt1dcgcg-1ifxfv-z3w.jpeg"><br><br>  A execução simbólica é a força de trabalho da análise moderna de programas.  Esse é um dos métodos que surgiu da pesquisa e começou a ser usado em muitas aplicações.  Por exemplo, hoje na Microsoft existe um sistema chamado SAGE, que funciona com muitos softwares importantes da Microsoft, variando de Power Point e terminando com o próprio Windows, para realmente encontrar problemas e vulnerabilidades de segurança. <br><br>  Existem muitos projetos acadêmicos que tiveram um grande impacto no mundo real, como detectar erros importantes no software de código aberto usando execução simbólica.  E a beleza da execução simbólica como técnica é que, em comparação com o teste, oferece a oportunidade de imaginar como o seu programa se comportará com um conjunto potencialmente interminável de possíveis dados de entrada.  Isso nos permite investigar matrizes de dados de entrada, o que seria completamente impraticável e impraticável para investigar, digamos, por testes aleatórios, mesmo se houver um número muito grande de testadores.  Por outro lado, comparado aos métodos mais tradicionais de análise estática, possui a seguinte vantagem.  Ao investigar um problema, a execução simbólica pode criar entrada e rastreamento, um caminho de execução que pode ser executado em um programa real e executar este programa com base nessa entrada.  E depois disso, podemos identificar o bug real e começar a corrigi-lo usando mecanismos de depuração tradicionais.  E isso é especialmente valioso quando você está em um ambiente de desenvolvimento industrial em que provavelmente não tem tempo para resolver todos os pequenos problemas do seu código. <br><br>  Por exemplo, você realmente deseja distinguir entre problemas reais e falsos positivos.  Como isso funciona? <br><br>  Para entender realmente como isso funciona, é útil começar com a execução normal.  Se pensarmos na execução simbólica como uma generalização da execução tradicional e simples, faz sentido saber como ela se parece.  Portanto, vou usar este programa muito simples como ilustração para muitas coisas sobre as quais falaremos hoje. <br><br><img src="https://habrastorage.org/webt/1-/rv/gy/1-rvgymnpffellnl2jnb55j790i.jpeg"><br><br>  Aqui temos um trecho de um código muito simples de várias ramificações e a afirmação de que, se, sob alguma condição, o valor t &lt;x, essa é uma afirmação falsa.  Queremos descobrir se essa afirmação pode ser levantada.  Isso é possível?  Existe alguma entrada que fará com que esta declaração falhe? <br><br>  Uma das coisas que posso fazer é verificar a execução deste programa usando valores específicos de dados de entrada como exemplo.  Suponha que usemos entradas para as quais X = 4 e Y = 4. O valor de T é zero, conforme anunciado no início do programa. <br><br>  Portanto, antes de chegarmos à execução normal, vamos descobrir qual é o ponto importante aqui.  Precisamos ter uma ideia do estado do programa, certo?  Quer estejamos executando normalmente ou simbolicamente, precisamos ter uma maneira de caracterizar o estado do programa.  Nesse caso, é um programa tão simples que não usa a pilha, não usa a pilha e não há chamadas de função aqui. <br><br>  Assim, o estado pode ser totalmente caracterizado por essas três variáveis, além de saber onde estou no programa.  Portanto, se eu iniciar a execução de 4, 4 e 0 e chegar ao final do ramo, verificarei a expressão: 4 é maior que 4?  Obviamente não. <br>  Agora vou executar o programa em T = Y, ou seja, T não é mais 0, mas tem um valor de 4. Esse é o estado atual do meu programa e agora posso avaliar esse ramo. <br><br><img src="https://habrastorage.org/webt/xw/j1/pb/xwj1pbkpvyvv3vc_b3urir5ob-g.jpeg"><br><br>  É verdade que T &lt;X?  Não.  Evitamos a bala, a declaração falsa não funcionou.  Não houve problemas nesta execução privada. <br><br>  Mas isso não nos diz nada sobre qualquer outra execução.  Sabemos que com os valores X = 4 e Y = 4, o programa não falhará.  Mas isso não nos diz nada sobre o que acontecerá se os valores de entrada forem 2 e 1. <br><br><img src="https://habrastorage.org/webt/8w/lv/vf/8wlvvfh7n43vvl2jaajhjd2opcy.jpeg"><br><br>  Com esses valores de entrada, a execução será diferente.  Desta vez, vemos que T = X e, após executar esta linha, T assumirá um valor igual a 2. Há algum problema nessa execução?  Haverá um erro de afirmação com essa entrada? <br><br>  Bem, vamos ver.  Portanto, se T é 2 e X é 2, T não é menor que X. Parece que novamente esquivamos a bala.  Certo?  Portanto, aqui temos dois valores de entrada específicos nos quais o programa funciona sem erros.  Mas, na verdade, ele não nos diz nada sobre outros valores de entrada. <br><br>  Portanto, a ideia da execução simbólica é que queremos ir além da execução de um programa com um conjunto de dados de entrada.  Queremos poder realmente falar sobre o comportamento do programa ao usar um conjunto de dados muito grande, em alguns casos, um número infinito de possíveis valores de entrada.  A idéia principal disso é a seguinte. <br><br><img src="https://habrastorage.org/webt/wn/k5/fs/wnk5fs-evom1hqqeh8vnpppxezk.jpeg"><br><br>  Para um programa como esse, seu estado é determinado pelo valor dessas três variáveis ​​diferentes: X, Y e T, e sabendo onde estou no momento no programa.  Mas agora, em vez dos valores específicos para X e Y, terei um valor simbólico, apenas uma variável.  Uma variável que me permite nomear esse valor, que o usuário usa como entrada.  Isso significa que o estado do meu programa não é mais caracterizado por corresponder nomes de variáveis ​​a valores específicos.  Agora, este é um mapeamento de nomes de variáveis ​​para esses valores simbólicos. <br><br>  O valor simbólico pode ser considerado como uma fórmula.  Nesse caso, a fórmula para X é igual a X e a fórmula para Y é simplesmente Y, e para T é realmente igual a 0. Sabemos que, para cada valor de entrada, não importa o que você faça.  O valor de T após a primeira instrução será 0. <br><br>  É aí que fica interessante agora.  Chegamos a esse ramo, que diz que se X for maior que Y, iremos em uma direção.  Se X for menor ou igual a Y, iremos na outra direção. <br><br>  Sabemos alguma coisa sobre X e Y?  O que sabemos sobre eles?  Pelo menos sabemos o tipo deles, sabemos que eles variam de min int a max int, mas é tudo o que sabemos sobre eles.  Acontece que as informações que sabemos sobre eles não são suficientes para dizer em que direção esse ramo pode seguir.  Ela pode ir em qualquer direção <br>  Há muitas coisas que podemos fazer, mas o que podemos fazer no momento?  Tente adivinhar. <br><br><img src="https://habrastorage.org/webt/eu/a9/c-/eua9c-jo64thlkjghlaj3e9x6rs.jpeg"><br><br>  <b>Público:</b> podemos acompanhar a execução do programa nos dois ramos. <br><br>  <b>Professor:</b> sim, podemos acompanhar o progresso nos dois ramos.  Jogue uma moeda e, dependendo de como ela cai, escolha uma ou outra ramificação. <br><br>  Então, se queremos seguir os dois ramos, devemos primeiro seguir um e depois o outro, certo?  Suponha que comecemos com este ramo - T = X.  Sabemos que, se chegarmos a esse lugar, T terá o mesmo significado que X. Não sabemos qual é esse valor, mas temos um nome para ele - esse é o script X. <br><br><img src="https://habrastorage.org/webt/2l/zy/mx/2lzymxorfsurzuz_bjon1hr4kdi.jpeg"><br><br>  Se tomarmos o ramo oposto, o que acontecerá?  O valor de T será igual a outra coisa, certo?  Neste ramo, o valor de T será o valor simbólico de Y. <br><br><img src="https://habrastorage.org/webt/q9/e6/fw/q9e6fwx1kg2llxhp3ci7rfzvwym.jpeg"><br><br>  Então, o que esse valor T significa quando chegamos a esse ponto do programa?  Talvez seja X, talvez seja Y. Não sabemos exatamente qual é esse valor, mas por que não damos um nome a ele?  Chame de t <sub>0</sub> .  E o que sabemos sobre t <sub>0</sub> ?  Em que casos t <sub>0</sub> será igual a X? <br><br>  Essencialmente, sabemos que se X é maior que Y, então a variável é igual a X, e se X é menor que ou igual a Y, então a variável é igual a Y. Portanto, temos um valor que definimos, vamos chamá-lo de t <sub>0</sub> , e ele possui esses propriedades lógicas. <br><br><img src="https://habrastorage.org/webt/6l/ux/93/6lux93kqkmnz63fjddelibxu3ma.jpeg"><br><br>  Portanto, neste ponto do programa, temos um nome para o valor de T, este é t <sub>0</sub> .  O que fizemos aqui?  Pegamos os dois ramos da instrução if e calculamos o valor simbólico, vendo sob quais condições um ramo do programa seria executado e sob o qual o outro. <br>  Agora chega ao ponto de perguntarmos se T pode ser menor que X. Agora, o valor de T é t <sub>0</sub> , e queremos saber se é possível que t <sub>0</sub> seja menor que X?  Lembre-se do primeiro ramo que examinamos - fizemos uma pergunta sobre X e Y e não sabíamos nada sobre eles, exceto que eram do tipo int. <br><br>  Mas, com t <sub>0</sub> , sabemos muito sobre isso.  Sabemos que, em alguns casos, será igual a X e, em alguns casos, será igual a Y. Portanto, agora ele nos fornece um conjunto de equações que podemos resolver.  Então, podemos dizer se é possível que t <sub>0 seja</sub> menor que X, sabendo que t <sub>0</sub> satisfaz todas essas condições?  Assim, podemos expressar isso como uma restrição, mostrando se é possível que t <sub>0</sub> seja menor que X. E se X é maior que Y, então t <sub>0</sub> é igual a X e se X é menor ou igual a Y, isso significa que t <sub>0</sub> = Y. <br><br><img src="https://habrastorage.org/webt/kw/go/1p/kwgo1pvhy86moreg7j9vnwlybsi.jpeg"><br><br>  Então, temos uma equação.  Se houver uma solução, se for possível encontrar o valor de t <sub>0</sub> , o valor de X e o valor de Y que satisfazem essa equação, então reconhecemos esses valores e, quando os inserimos no programa, quando executado, ele percorre esse ramo se t &lt;x e " irá explodir ”quando cair em afirmar falso. <br><br>  Então, o que fizemos aqui?  Executamos o programa, mas, em vez de mapear nomes de variáveis ​​para valores específicos, atribuímos valores simbólicos a esses nomes de variáveis.  De fato, eles deram outros nomes de variáveis.  E, nesse caso, nossos outros nomes de variáveis ​​são o script X, o script Y, t <sub>0</sub> e, além disso, temos um conjunto de equações que mostram como esses valores estão relacionados.  Temos uma equação que nos diz como t <sub>0</sub> está relacionado a X e Y neste caso. <br><br>  A solução desta equação nos permite responder à pergunta se esse ramo pode ser executado ou não.  Dê uma olhada na equação - é possível pegar esse ramo ou não?  Parece que não, porque estamos procurando casos em que t <sub>0 é</sub> menor que X, mas se na primeira condição t <sub>0</sub> = X, a expressão t <sub>0</sub> &lt;X não será verdadeira. <br><br>  Portanto, isso significa que, quando X&gt; Y, isso não pode acontecer, porque t <sub>0</sub> = X e não pode ser igual ou menor que X ao mesmo tempo. <br><br>  Mas o que acontece se t <sub>0</sub> = Y?  T <sub>0</sub> pode ser menor que X neste caso? <br><br>  Não, definitivamente não pode, porque sabemos que X &lt;Y. Portanto, se t <sub>0</sub> é menor que X, também será menor que Y. Mas sabemos que, neste caso, t <sub>0</sub> = Y. E, portanto, novamente , essa condição não pode ser satisfeita.  Portanto, aqui temos uma equação que não tem solução, e não importa quais valores você inclua nessa equação. <br><br>  Você não pode resolvê-lo, e isso nos diz que, independentemente das entradas X e Y que passamos para o programa, ele não será desativado se t &lt;x. <br><br>  Agora observe que, ao criar esse argumento aqui, eu basicamente sugeri sua intuição sobre números inteiros, sobre números matemáticos.  Na prática, sabemos que as entradas da máquina não se comportam exatamente como as entradas matemáticas.  Há casos em que as leis aplicadas aos tipos de dados inteiros matemáticos não são aplicáveis ​​às entradas programáticas. <br><br>  Portanto, devemos ter muito cuidado ao resolver essas equações, porque devemos lembrar que esses não são os números inteiros sobre os quais fomos informados no ensino fundamental.  Esses são os números inteiros de 32 bits usados ​​pela máquina.  E há muitos casos de erros que ocorreram porque os programadores pensaram em seu código em termos de números matemáticos, sem perceber que existem coisas como estouros que podem causar comportamento diferente do programa para entrada matemática. <br><br>  Outra coisa que descrevi aqui é um argumento puramente intuitivo.  Vou guiá-lo pelo processo, mostrando como fazê-lo manualmente, mas isso não é de forma alguma um algoritmo.  A beleza dessa idéia de execução simbólica, no entanto, é que ela pode ser codificada em um algoritmo.  E você pode resolvê-lo mecanicamente, o que permite fazer isso não apenas para um programa de 10 linhas, mas para milhões de programas.  Isso nos permite usar o mesmo raciocínio intuitivo que usamos neste caso e falar sobre o que acontece quando executamos este programa com diferentes valores de entrada.  E essas considerações podem ser dimensionadas e estendidas para programas muito grandes. <br><br><img src="https://habrastorage.org/webt/b0/of/jr/b0ofjrqh-vesxglsfrxpikk8yb0.jpeg"><br><br>  <b>Público:</b> e se o programa não suportar a entrada de um determinado tipo de variável? <br><br>  <b>Professor:</b> esta é uma pergunta muito boa!  Suponha que tenhamos o mesmo programa, mas, em vez de t = x, teremos t = (x-1).  Então, intuitivamente, podemos imaginar que agora esse programa pode "explodir", certo? <br><br><img src="https://habrastorage.org/webt/_k/sk/9v/_ksk9vik_mk_xno9mkjqkvoli3k.jpeg"><br><br>  Porque quando o programa segue esse caminho, t realmente será menor que x.  O que acontecerá com esse programa?  Como será nosso estado simbólico?  Qual será t <sub>0</sub> quando x for maior que y?  Corrigimos as linhas em nossas equações de acordo com outro valor quando t = (x-1).  Agora o programa pode falhar, e você vai ao desenvolvedor e diz a ele: “ei, essa função pode explodir quando x for maior que y”! <br><br>  O desenvolvedor analisa isso e diz: “Ah, esqueci de lhe dizer - na verdade, essa função nunca será chamada com parâmetros, onde x é maior que y.  "Acabei de escrever por alguns motivos históricos, então não se preocupe, eu não me lembraria se você não tivesse me contado." <br><br>  Suponha que tenhamos uma suposição de que x será menor ou igual a y. <br><br><img src="https://habrastorage.org/webt/il/iu/un/iliuunmfbjyqdw1dxw7ugemm0go.jpeg"><br><br>  Esta é uma pré-condição ou acordo para nossa função.  A função promete fazer algo, mas apenas se o valor satisfizer essa suposição.  Mas se não for satisfeita, a função diz: "Eu não ligo para o que acontece.  Eu prometo que não haverá erro apenas se essa suposição for cumprida. " <br><br>  Então, como codificamos essa restrição quando resolvemos as equações?  Essencialmente, temos um conjunto de restrições que nos dizem se esse ramo é viável.  Além das limitações, devemos também garantir que a pré-condição ou suposição seja atendida. <br><br>  A questão é: posso encontrar xey que atendam a todas essas restrições e, ao mesmo tempo, possuam as propriedades necessárias?  Você pode ver que essa restrição X ≤ Y representa a diferença entre o caso em que essa restrição é atendida e o caso em que não é atendida. <br><br>  Essa é uma questão muito importante ao trabalhar com análise, especialmente quando você deseja fazer isso simultaneamente no nível das funções individuais.  É aconselhável saber o que o programador tinha em mente ao escrever esta função.  Como se você não tem idéia sobre essas suposições, pode pensar que há alguma entrada de que o programa falhará. <br><br>  Como fazer isso de maneira mecânica?  Existem dois aspectos para esse problema.  Aspecto número um - como você realmente criou essas fórmulas? <br><br>  Nesse caso, é intuitivamente claro como chegamos a essas fórmulas, simplesmente as compusemos manualmente.  Mas como criar essas fórmulas mecanicamente? <br><br>  E o segundo aspecto - como você resolve essas fórmulas depois de tê-las?  É possível realmente resolver essas fórmulas que descrevem se o seu programa falha ou não? <br>  Vamos começar com a segunda pergunta.  Podemos reduzir nosso problema com essas fórmulas, que incluem raciocínio inteiro e vetores de bits.  Ao criar programas, você cuida de matrizes, funções e, como resultado, obtém fórmulas gigantes.  É possível resolvê-los mecanicamente? <br><br><img src="https://habrastorage.org/webt/fb/wg/mp/fbwgmprqfh03wmz73pz3s5cfrv0.jpeg"><br><br>  As muitas tecnologias sobre as quais estamos falando hoje são ferramentas práticas relacionadas aos tremendos avanços no desenvolvimento de solucionadores de questões lógicas.  Em particular, existe uma classe muito importante de solucionadores, chamada SMT, ou o "solucionador de solvabilidade de teorias modulares".  O solucionador SMT é a solvabilidade das fórmulas lógicas, levando em consideração as teorias subjacentes a elas. <br><br>  Muitas pessoas afirmam que esse nome não é particularmente bom, mas foi corrigido como o mais usado. <br><br>  O SMT-solver é um algoritmo devido ao qual essa fórmula lógica na saída fornecerá uma das duas opções: ela satisfaz sua finalidade ou não.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo caso significa que nesta fórmula é impossível usar os valores das variáveis ​​que atendem aos requisitos das restrições definidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na prática, isso parece um pouco assustador e um pouco mágico. </font><font style="vertical-align: inherit;">A maioria dos problemas que o SMT deve resolver são problemas completos de NP, ou seja, tarefas com a resposta "sim" ou "não". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ter um sistema que se baseie na solução de problemas completos de NP como seu principal componente? </font><font style="vertical-align: inherit;">Ou precisamos de outra coisa que funcione na prática? </font><font style="vertical-align: inherit;">O fato é que muitos solucionadores de SMT também têm uma terceira resposta possível: "Eu não sei".</font></font><br><br><img src="https://habrastorage.org/webt/wp/se/q9/wpseq9oqvluas4nkjsstzagwpva.jpeg"><br><br>         , ,        ,    ,   : «  ».      ,           ,        . <br><br> 27:30  <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> MIT «  ».  10: « »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A versão completa do curso está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD de 1Gbps até dezembro de graça</b> quando pagar por um período de seis meses, você pode fazer o pedido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425557/">https://habr.com/ru/post/pt425557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425547/index.html">Qt: desenho baseado em gráficos vetoriais</a></li>
<li><a href="../pt425549/index.html">Estoques da Supermicro quebram em meio a investigação sobre implantação de chip espião chinês</a></li>
<li><a href="../pt425551/index.html">Quem deve receber dinheiro com a venda de uma obra de arte criada pela AI?</a></li>
<li><a href="../pt425553/index.html">O que o conde de Monte Cristo pode nos dizer sobre segurança cibernética</a></li>
<li><a href="../pt425555/index.html">Charles Nutter sobre idiomas dinâmicos na JVM em jug.msk.ru</a></li>
<li><a href="../pt425559/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 10: Execução Simbólica, Parte 3</a></li>
<li><a href="../pt425561/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 10: Execução Simbólica, Parte 2</a></li>
<li><a href="../pt425563/index.html">A Califórnia proíbe a venda de dispositivos IoT com ou sem senhas simples</a></li>
<li><a href="../pt425565/index.html">Matemática rápida de ponto fixo para aplicativos financeiros em Java</a></li>
<li><a href="../pt425569/index.html">Teste funcional do PWB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>