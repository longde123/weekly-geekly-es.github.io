<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è¨ üî∂ üö∂üèΩ Como criamos o PHP 7 duas vezes mais r√°pido que o PHP 5. Parte 1: otimizando estruturas de dados üåî üé∂ ü§ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em dezembro de 2015 , o PHP 7.0 foi lan√ßado. As empresas que mudaram para o "sete" observaram que a produtividade aumentou e a carga no servidor dimin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como criamos o PHP 7 duas vezes mais r√°pido que o PHP 5. Parte 1: otimizando estruturas de dados</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/444508/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Em dezembro de 2015</a> , o PHP 7.0 foi lan√ßado.  As empresas que mudaram para o "sete" observaram que a produtividade aumentou e a carga no servidor diminuiu.  Os primeiros a passar para os sete foram Vebia e Etsy, e temos o Badoo, Avito e OLX.  Para o Badoo, a mudan√ßa para os sete custa US $ 1 milh√£o em economia de servidor.  Gra√ßas ao PHP 7 no OLX, a carga m√©dia do servidor diminuiu 3 vezes, aumentando a efici√™ncia e a economia de recursos. <br><br>  <strong>Dmitry Stogov,</strong> da Zend Technologies, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">falou</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++</a> , o que aumentou a produtividade.  Na decodifica√ß√£o: sobre a estrutura interna do PHP, sobre as id√©ias no cora√ß√£o da vers√£o 7.0, sobre mudan√ßas nas estruturas de dados e algoritmos b√°sicos que determinaram o sucesso. <br><br>  <em>Isen√ß√£o de responsabilidade: em mar√ßo de 2019,</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>80% dos sites s√£o</em></a> <em>executados em PHP e</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>70% deles s√£o</em></a> <em>executados em</em> <em>PHP 5, embora</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>esta vers√£o n√£o seja suportada</em></a> <em>desde 1 de janeiro de 2019</em> <em>.</em>  <em>O relat√≥rio de 2016 de Dmitry sobre os princ√≠pios pelos quais houve um salto duplo na produtividade entre o PHP 5 e o 7 tamb√©m √© relevante em mar√ßo de 2019. Para metade dos sites, com certeza.</em> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/tHapNKpacSQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>Sobre o palestrante: Dmitry Stogov</strong> come√ßou a programar nos anos 80: ‚ÄúElectronics B3-34‚Äù, Basic, montador.  Em 2002, Dmitry se familiarizou com o PHP e logo come√ßou a trabalhar para melhor√°-lo: ele desenvolveu o Turck MMCache para PHP, liderou o projeto PHPNG e desempenhou um papel importante no trabalho no JIT para PHP.  Os √∫ltimos 14 anos de Engenheiro Principal na Zend Technologies. <br><br>  A Zend Technologies est√° desenvolvendo PHP e solu√ß√µes comerciais com base nele.  Em 1999, foi fundada pelos programadores israelenses Andy Gutmans e Zeev Suraski, que h√° dois anos criaram o PHP 3. Essas pessoas estavam na vanguarda do desenvolvimento do PHP e determinaram amplamente a apar√™ncia atual da linguagem e o sucesso da tecnologia. <br><br>  A Zend Technologies est√° desenvolvendo o n√∫cleo e os aplicativos PHP e, durante o trabalho, tive que escrever extens√µes, entrar em todos os subsistemas e at√© me envolver em projetos comerciais, √†s vezes nem um pouco relacionados ao PHP.  Mas o t√≥pico mais interessante para mim sempre foi o <strong>desempenho</strong> . <br><br>  Comecei a procurar maneiras de acelerar o PHP antes mesmo de ingressar no Zend, trabalhando em meu pr√≥prio projeto que competia com a empresa.  Durante o trabalho no projeto, entendi completamente a linguagem e percebi que, trabalhando n√£o com o projeto principal, voc√™ pode influenciar apenas certos aspectos da execu√ß√£o do script, e tudo o mais interessante e eficaz pode ser criado <strong>apenas no kernel</strong> .  Esse entendimento e coincid√™ncia me levaram ao Zend. <br><br><h2>  Uma pequena digress√£o na hist√≥ria do PHP </h2><br>  PHP n√£o √© apenas e <strong>n√£o apenas uma linguagem de programa√ß√£o</strong> .  PHP significa Personal Home Page - uma ferramenta para criar p√°ginas pessoais e sites din√¢micos.  A linguagem √© apenas uma de suas partes principais.  O PHP √© uma enorme biblioteca de fun√ß√µes, muitas extens√µes para trabalhar com outras bibliotecas de terceiros, por exemplo, para acessar o banco de dados ou analisadores XML, al√©m de um conjunto de m√≥dulos para comunica√ß√£o com v√°rios servidores da web. <br><br>  O programador dinamarqu√™s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rasmus Lerdorf</a> introduziu o PHP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em junho de 1995</a> .  Naquela √©poca, era apenas uma <strong>cole√ß√£o de scripts CGI escritos em Perl</strong> .  Em abril de 96, Rasmus introduziu o PHP / FI e, em junho, o PHP / FI 2.0 foi lan√ßado.  Posteriormente, esta vers√£o foi substancialmente reformulada por Andy Gutmans e Zeev Surasky, e no 98¬∫ lan√ßamento do PHP 3.0.  Em 2000, a linguagem chegou ao tipo que estamos acostumados a ver hoje em termos de linguagem e arquitetura interna - PHP 4, baseado no Zend Engine. <br><br>  Desde a vers√£o 4, o PHP evoluiu.  O ponto de virada foi o lan√ßamento do PHP 5 em 2004, quando o <strong>modelo de objeto foi completamente atualizado</strong> .  Foi ela quem abriu a era das estruturas PHP e elevou a quest√£o do desempenho a um novo n√≠vel.  Antecipando isso, imediatamente ap√≥s o lan√ßamento do 5.0, n√≥s do Zend pensamos em acelerar o PHP e come√ßamos a trabalhar para melhorar a produtividade. <br><br>  A vers√£o 7.1, lan√ßada em novembro de 2016 em testes sint√©ticos, <strong>√© 25 vezes mais r√°pida que a vers√£o de 2002</strong> .  De acordo com o gr√°fico das altera√ß√µes de desempenho em diferentes ramos, os principais avan√ßos s√£o vis√≠veis em 5.1 e 7.0. <br><br><img src="https://habrastorage.org/webt/ao/_s/mp/ao_smpopukfzjmclxqqu83xefvo.png"><br><br>  Na vers√£o 5.1, come√ßamos a trabalhar no desempenho, e tudo o que assumimos - acabou sendo, mas depois do 5.3 encontramos uma barreira, todas as tentativas de melhorar o int√©rprete n√£o deram em nada. <br><br>  No entanto, descobrimos onde cavar e obtivemos ainda mais do que o esperado - acelera√ß√£o de 2,5 vezes em compara√ß√£o com a vers√£o anterior 5.6 nos testes.  Mas o mais interessante √© que obtivemos a mesma acelera√ß√£o de 2,5 vezes em aplicativos reais inalterados.  Este √© um fen√¥meno, porque desenvolvemos o fator 2 anterior ao longo da vida dos cinco em dez anos. <br><br><img src="https://habrastorage.org/webt/ge/9j/n_/ge9jn_isn9hxm-gbrk0ahaexfms.png"><br><br>  O enorme salto em 5.1 nos testes sint√©ticos n√£o √© percept√≠vel em aplica√ß√µes reais.  O motivo √© que, com diferentes usos, o desempenho do PHP depende dos freios associados a diferentes subsistemas. <br><br>  <strong>A hist√≥ria do PHP 7 come√ßa com uma estagna√ß√£o de tr√™s anos</strong> que come√ßou em 2012 e terminou em 2015 com o lan√ßamento da s√©tima vers√£o.  Ent√£o percebemos que n√£o pod√≠amos mais aumentar a produtividade com pequenas melhorias de nosso int√©rprete e voltamos para o lado do JIT. <br><br><h2>  Vagando pelo JIT </h2><br>  Passamos quase dois anos no prot√≥tipo JIT para PHP-5.5.  Inicialmente, geramos um c√≥digo muito simples - uma sequ√™ncia de chamadas para manipuladores padr√£o, algo como um c√≥digo Fort costurado.  Em seguida, eles escreveram seu pr√≥prio <strong>Runtime Assembler</strong> , um c√≥digo separado para solu√ß√µes alternativas, mas perceberam que essas <strong>otimiza√ß√µes de baixo n√≠vel n√£o davam</strong> efeito <strong>pr√°tico</strong> nem nos testes. <br><br>  Ent√£o pensamos em derivar tipos de vari√°veis ‚Äã‚Äãusando m√©todos de an√°lise est√°tica.  Tendo percebido a conclus√£o, recebemos imediatamente a <strong>acelera√ß√£o em duas vezes nos testes.</strong>  Encorajados, eles tentaram escrever alocadores de registros globais, mas falharam.  Usamos uma representa√ß√£o de alto n√≠vel e era quase imposs√≠vel us√°-la para aloca√ß√£o de registros. <br><br>  Para evitar problemas de baixo n√≠vel, decidimos experimentar o LLVM e, um ano depois, obtivemos uma <strong>acelera√ß√£o de 10x para o bench.php</strong> , mas nada em aplicativos reais.  Al√©m disso, a compila√ß√£o de aplicativos reais agora levou minutos, por exemplo, a primeira <strong>solicita√ß√£o para o Wordpress levou 2 minutos e n√£o deu acelera√ß√£o.</strong>  Obviamente, isso era completamente inadequado para a pr√°tica real. <br><br><blockquote>  Um bom c√≥digo √© poss√≠vel com a previs√£o de tipo adequada, que funciona mal em aplicativos reais, e o uso de estruturas de dados PHP torna o c√≥digo gerado ineficiente. </blockquote><br><h3>  O que diminui a velocidade? </h3><br>  Repensamos as raz√µes das falhas e decidimos mais uma vez ver por que o PHP √© lento.  A imagem mostra o resultado da cria√ß√£o de perfil de v√°rios pedidos na p√°gina inicial do Wordpress. <br><br><img src="https://habrastorage.org/webt/3w/dh/7v/3wdh7vd40xumtwtyqgshsdan-a8.png"><br><br>  Menos de 30% √© gasto na interpreta√ß√£o de c√≥digo de c√≥digo, 20% √© a sobrecarga do gerenciador de mem√≥ria, 13% est√° trabalhando com tabelas de hash e 5% est√° trabalhando com express√µes regulares. <br><br>  Trabalhando no JIT, nos livramos apenas dos primeiros 30% e tudo o mais estava em peso morto.  Em quase todos os lugares, fomos for√ßados a usar estruturas de dados PHP padr√£o, o que implicava sobrecarga: aloca√ß√£o de mem√≥ria, contagem de refer√™ncia etc.  Esse entendimento levou √† conclus√£o de que √© necess√°rio substituir as principais estruturas de dados no PHP.  Com essa <strong>substitui√ß√£o da funda√ß√£o</strong> , o projeto <strong>PHPNG come√ßou.</strong> <br><br><h2>  Phpng  Nova gera√ß√£o </h2><br>  O projeto foi desenvolvido ap√≥s tentativas malsucedidas de criar JIT para PHP.  O objetivo principal √© <strong>alcan√ßar um novo n√≠vel de produtividade e estabelecer as bases para futuras melhorias</strong> . <br><br>  Prometemos a n√≥s mesmos por algum tempo n√£o usar mais testes sint√©ticos para medir o desempenho - geralmente s√£o pequenos programas de computa√ß√£o que usam uma quantidade limitada de dados que se encaixa completamente no cache do processador.  Aplica√ß√µes reais, ao contr√°rio, est√£o sujeitas aos freios associados √† mem√≥ria do subsistema, e uma √∫nica leitura da mem√≥ria pode custar 100 instru√ß√µes computacionais.  <strong>O projeto PHPNG √© uma refatora√ß√£o das principais estruturas de dados PHP para otimizar o acesso √† mem√≥ria</strong> .  Nenhuma inova√ß√£o, 100% compat√≠vel com PHP 5. <br><br>  Como mudar essas estruturas estava claro.  Mas o volume de mudan√ßas dependentes foi enorme, porque o <strong>n√∫cleo do PHP em</strong> si <strong>√© de 150.000 linhas</strong> e quase todo ter√ßo precisava ser alterado.  Adicione mais cem extens√µes inclu√≠das na distribui√ß√£o b√°sica, uma d√∫zia de m√≥dulos para diferentes servidores da Web e voc√™ perceber√° a grandeza do projeto. <br><br>  N√£o t√≠nhamos certeza de que terminar√≠amos o projeto.  Portanto, eles lan√ßaram o projeto em segredo e o abriram apenas quando os primeiros resultados otimistas apareceram.  Demorou duas semanas para <strong>compilar o kernel</strong> .  Duas semanas depois, o bench.php ganhou.  Passamos um m√™s e meio para garantir o trabalho do Wordpress.  Um m√™s depois, abrimos o projeto - era maio de 2014.  Naquela √©poca, tivemos uma <strong>acelera√ß√£o de 30% no Wordpress</strong> .  J√° parecia um grande evento. <br><br>  O PHPNG despertou imediatamente uma onda de interesse e, em agosto de 2014, foi <strong>adotado como base para o futuro do PHP 7</strong> .  J√° era outro projeto, com um conjunto diferente de objetivos, onde a produtividade era apenas um deles. <br><br><h2>  PHP 7.0 </h2><br>  A vers√£o n√∫mero 7 estava em d√∫vida.  A vers√£o anterior foi a quinta.  E o sexto foi desenvolvido h√° v√°rios anos e foi completamente dedicado ao suporte nativo a <strong>Unicode</strong> , mas as decis√µes malsucedidas tomadas nos est√°gios iniciais do desenvolvimento levaram √† complexidade excessiva do c√≥digo do kernel e de cada extens√£o.  No final, foi decidido congelar o projeto. <br><br>  Nessa √©poca, j√° havia sido acumulado muito material dedicado ao PHP 6: discursos em confer√™ncias, livros publicados.  Para n√£o confundir ningu√©m, chamamos o projeto PHP 7, pulando o PHP 6. Esta vers√£o foi muito mais sortuda - o PHP 7 foi lan√ßado em dezembro de 2015, quase conforme o planejado. <br><br>  Al√©m do desempenho, algumas inova√ß√µes h√° muito procuradas apareceram no PHP 7: <br><br><ul><li>  Capacidade de definir tipos escalares de par√¢metros e retornar valores. </li><li>  Exce√ß√µes em vez de erros - agora podemos captur√°-las e process√°-las. </li><li> Apareceu <code>Zero-cost assert()</code> , classes an√¥nimas, inconsist√™ncias de limpeza, novos operadores e fun√ß√µes (&lt;=&gt;, ??). </li></ul><br>  A inova√ß√£o √© boa, mas voltando √†s mudan√ßas internas.  Vamos falar sobre o caminho que o PHP 7 seguiu e para onde esse caminho pode nos levar. <br><br><h2>  zval </h2><br>  Essa √© a estrutura b√°sica de dados PHP.  √â usado para <strong>representar qualquer valor em PHP</strong> .  Como nossa linguagem √© digitada dinamicamente e o tipo de vari√°veis ‚Äã‚Äãpode ser alterado durante a execu√ß√£o do programa, precisamos armazenar um campo de tipo (tipo zend_uchar), que pode receber os valores IS_NULL, IS_BOOL, IS_LONG, IS_DOUBLE, IS_ARRAY, IS_OBJECT etc., e de fato o valor representado por union (value), onde um n√∫mero inteiro, n√∫mero real, string, matriz ou objeto pode ser armazenado. <br><br><h3>  zval no PHP 5 </h3><br>  A mem√≥ria para cada uma dessas estruturas foi alocada separadamente no Heap.  Al√©m do tipo e valor, o contador de refer√™ncias √† estrutura tamb√©m foi armazenado nela.  Portanto, a estrutura ocupou 24 bytes, sem contar a sobrecarga do gerenciador de mem√≥ria e o ponteiro para ele. <br><br>  A figura no canto superior direito mostra as estruturas de dados que foram criadas na mem√≥ria do PHP 5 para um script simples. <br><br><img src="https://habrastorage.org/webt/m8/km/ix/m8kmixgehjrhtxthe-gefmmi86i.png"><br><br>  Na pilha, a mem√≥ria foi alocada para 4 vari√°veis ‚Äã‚Äãrepresentadas por ponteiros.  Os pr√≥prios valores (zval) est√£o na pilha.  No nosso caso, esses s√£o apenas dois zval, cada um dos quais √© referenciado por duas vari√°veis ‚Äã‚Äãe, portanto, seus contadores de refer√™ncia s√£o definidos como 2. <br><br>  Para acessar um tipo ou valor escalar, voc√™ precisa de pelo menos duas leituras: primeiro leia o valor do ponteiro e, em seguida, o valor da estrutura.  Se voc√™ precisar ler n√£o um valor escalar, mas, por exemplo, parte de uma string ou matriz, precisar√° de pelo menos mais uma leitura. <br><br><h3>  zval no PHP 7 </h3><br>  Onde usamos ponteiros antes, nos sete come√ßamos a incorporar zval.  Afastamos a contagem de refer√™ncia para tipos escalares.  Os campos tipo e valor permaneceram sem altera√ß√µes significativas, mas foram adicionadas mais algumas bandeiras e um local reservado, sobre o qual falarei um pouco mais adiante. <br><br><img src="https://habrastorage.org/webt/tz/we/yn/tzweyn8n32_rntdwwjxhz-fbwc4.png"><br><br>  √Ä esquerda est√° o que parecia no PHP 5, e √† direita, no PHP 7. <br><br><img src="https://habrastorage.org/webt/5n/wl/4h/5nwl4hrqaqr2kb4pmenzvbtrnh4.png"><br><br>  Agora, o pr√≥prio zval est√° na pilha.  Para ler tipos e valores escalares, apenas uma instru√ß√£o de m√°quina √© suficiente.  Todos os valores s√£o agrupados em uma √°rea de mem√≥ria, o que significa que, ao trabalhar com vari√°veis ‚Äã‚Äãlocais, praticamente n√£o teremos perdas devido a falhas no cache do processador.  Mas o verdadeiro poder do novo desempenho √© inclu√≠do quando a c√≥pia √© necess√°ria. <br><br><h3>  Copiar registro </h3><br>  Na linha superior do script, outra tarefa foi adicionada. <br><br><img src="https://habrastorage.org/webt/kb/yr/ww/kbyrwwvzaeuqpt8quf1lyujztjo.png"><br><br>  No PHP5, alocamos mem√≥ria do heap para um novo zval, inicializamos seu int (2), alteramos o valor do ponteiro para a vari√°vel b e diminu√≠mos o contador de refer√™ncia do valor ao qual b havia se referido anteriormente. <br><br>  No PHP 7, n√≥s simplesmente <strong>inicializamos a vari√°vel b diretamente no lugar com algumas instru√ß√µes</strong> , enquanto no PHP 5 ele exigia centenas de instru√ß√µes.  Ent√£o o zval parece agora na mem√≥ria. <br><br><img src="https://habrastorage.org/webt/ax/ab/sa/axabsadvso8c49azoqvvks5jsfc.png"><br><br>  Estas s√£o duas palavras de 64 bits.  A primeira palavra √© <strong>significado:</strong> inteiro, real ou ponteiro.  Na segunda palavra, o <strong>tipo</strong> (diz como interpretar o significado), sinalizadores e um local reservado que ainda seria adicionado ao alinhar.  Mas n√£o desaparece, mas √© usado por diferentes subsistemas para armazenar valores indiretamente relacionados. <br><br>  <strong>Flags s√£o um conjunto de bits em</strong> que cada bit indica se o zval suporta um protocolo.  Por exemplo, se for <code>IS_TYPE_REFCOUNTED</code> , ao trabalhar com esse zval, o mecanismo deve cuidar do valor do contador de refer√™ncia.  Ao atribuir, aumente; ao sair do escopo, diminua; se o contador de refer√™ncia atingir zero, destrua a estrutura dependente. <br><br>  Dos tipos, comparados ao PHP 5, v√°rios novos apareceram. <br><br><ul><li>  <code>IS_UNDEF</code> - um marcador de uma vari√°vel n√£o inicializada. </li><li>  O √∫nico <code>IS_BOOL</code> substitu√≠do por <code>IS_FALSE</code> e <code>IS_FALSE</code> separados. </li><li>  Adicionado um tipo separado para links e mais alguns tipos m√°gicos. </li></ul><br>  Os tipos de <code>IS_UNDEF</code> a <code>IS_DOUBLE</code> s√£o escalares e n√£o requerem mem√≥ria adicional.  Para copi√°-las, basta copiar a primeira palavra de 64 bits da m√°quina com um valor e metade do segundo com um tipo e sinalizadores. <br><br><h3>  Recontado </h3><br>  Com outros tipos mais dif√≠ceis.  Todos eles s√£o representados por uma estrutura subordinada, e o zval simplesmente armazena uma refer√™ncia a essa estrutura.  Para cada tipo, essa estrutura √© diferente, mas em termos de POO, todos eles t√™m um ancestral ou estrutura abstrata comum zend_refcounted.  Ele determina o formato da primeira <strong>palavra de 64 bits</strong> , onde a contagem de refer√™ncia e outras informa√ß√µes para o coletor de lixo s√£o armazenadas. <br><br><img src="https://habrastorage.org/webt/vn/zm/yy/vnzmyywum831lpzipgxtenm_98s.png"><br><br>  Essa palavra pode ser considerada simplesmente como informa√ß√£o para o coletor de lixo, e estruturas para tipos espec√≠ficos adicionam seus campos ap√≥s essa primeira palavra. <br><br><h3>  Linhas </h3><br>  Nos sete da string, armazenamos o valor calculado da fun√ß√£o hash, seu comprimento e os pr√≥prios caracteres.  O tamanho dessa estrutura √© vari√°vel e depende do comprimento da sequ√™ncia.  A fun√ß√£o hash √© calculada para a sequ√™ncia uma vez, quando necess√°rio.  No PHP 5, foi recalculado a cada necessidade. <br><br><img src="https://habrastorage.org/webt/em/2t/ax/em2tax1wdnckpbzqxjh1tlqn37o.png"><br><br>  Agora, as strings se tornaram cont√°veis ‚Äã‚Äãpor refer√™ncia, e se no PHP 5 copi√°mos os pr√≥prios caracteres, agora √© suficiente aumentar a contagem de refer√™ncia para essa estrutura. <br><br>  Como no PHP 5, ainda temos o conceito de <strong>seq√º√™ncias imut√°veis ‚Äã‚Äãou internas</strong> .  Eles geralmente existem em uma inst√¢ncia, permanecem at√© o final da consulta e podem se comportar como valores escalares.  N√£o precisamos cuidar do contador de refer√™ncias a eles e, para copiar, basta copiar apenas o pr√≥prio zval com a ajuda de quatro instru√ß√µes da m√°quina. <br><br><h3>  Matrizes </h3><br>  As matrizes s√£o representadas por uma tabela de hash embutida e n√£o s√£o muito diferentes do PHP 5. A pr√≥pria tabela de hash mudou, mas mais sobre isso separadamente. <br><br><img src="https://habrastorage.org/webt/_u/kn/ls/_uknlsdbw247d7whq_-euez8zuw.png"><br><br>  Agora, as matrizes s√£o uma <strong>estrutura adaptativa</strong> que altera levemente sua estrutura e comportamento internos, dependendo dos dados armazenados.  Se armazenarmos apenas elementos com chaves num√©ricas fechadas, teremos acesso diretamente aos elementos por √≠ndice com uma velocidade compar√°vel √† velocidade de matrizes em C. <br><br>  √â assim que a tabela de hash se parece no PHP 5. <br><br><img src="https://habrastorage.org/webt/d6/c-/6r/d6c-6rvue6zlsyyhnscfyjtnjj4.png"><br><br>  Esta √© uma implementa√ß√£o cl√°ssica de tabela de hash com resolu√ß√£o de colis√£o usando listas lineares (mostradas no canto superior direito).  Cada item √© representado por um balde.  Todos os buckets s√£o vinculados por listas duplamente vinculadas para resolver colis√µes e vinculados por outra lista duplamente vinculada para iterar em ordem.  Os valores para cada zval s√£o alocados separadamente - no Bucket, apenas armazenamos um link para ele.  Al√©m disso, as chaves de sequ√™ncia podem ser alocadas separadamente. <br><br>  Assim, para cada tabela de hash, voc√™ precisa alocar muitos pequenos blocos de mem√≥ria e, para encontrar algo mais tarde, precisa executar os ponteiros.  Cada uma dessas transi√ß√µes pode causar perda de carga e um atraso de ~ 10-100 ciclos do processador. <br><br>  Foi o que aconteceu no PHP 7. <br><br><img src="https://habrastorage.org/webt/g_/mk/ax/g_mkaxt7a0ua8shao-rzketmjag.png"><br><br>  A estrutura l√≥gica permaneceu inalterada, apenas a f√≠sica mudou.  Agora, em uma tabela de hash, a mem√≥ria √© alocada com uma opera√ß√£o. <br><br>  Na figura, na parte inferior do ponteiro base, existem elementos e, na parte superior, h√° uma matriz de hash endere√ßada por uma fun√ß√£o de hash.  Para matrizes planas ou compactadas, quando armazenamos apenas elementos com √≠ndices num√©ricos, a parte superior n√£o √© alocada e endere√ßamos o bucket diretamente por n√∫mero. <br><br>  Para ignorar elementos, n√≥s os classificamos sequencialmente de cima para baixo ou de baixo para cima, o que os processadores modernos fazem na perfei√ß√£o.  Os valores s√£o incorporados nos buckets, mas o espa√ßo reservado neles √© usado apenas para resolver colis√µes.  Ele armazena o √≠ndice de outro Balde com o mesmo valor da fun√ß√£o de hash ou o final do marcador da lista. <br><br>  A mem√≥ria para os valores da string das chaves √© alocada separadamente, mas ainda √© a mesma zend_string.  Ao colar em uma matriz, basta aumentar o contador de refer√™ncia da string, embora antes tenhamos que copiar os caracteres diretamente e, ao pesquisar, agora possamos comparar n√£o os caracteres, mas os ponteiros para as pr√≥prias strings. <br><br><h3>  Matrizes imut√°veis </h3><br>  Anteriormente, t√≠nhamos seq√º√™ncias imut√°veis, mas agora matrizes imut√°veis ‚Äã‚Äãtamb√©m apareceram.  Como cadeias de caracteres, elas n√£o usam a contagem de refer√™ncia e n√£o s√£o destru√≠das at√© o final da solicita√ß√£o.  Este √© um script simples que cria uma matriz de um milh√£o de elementos e cada elemento √© a mesma matriz com um √∫nico elemento "ol√°". <br><br><img src="https://habrastorage.org/webt/uv/sm/lu/uvsmluqtfldezjnbbfdqvd83sr8.png"><br><br>  No PHP 5, a cada itera√ß√£o de loop, uma nova matriz vazia era criada, o "hello" era gravado nela e tudo isso era adicionado √† matriz resultante.  No PHP 7, em tempo de compila√ß√£o, <strong>criamos apenas um array imut√°vel</strong> que se comporta como um escalar e o adicionamos ao resultante.  No exemplo apresentado, isso nos permite obter uma redu√ß√£o de mais de 10 vezes no consumo de mem√≥ria e uma acelera√ß√£o de quase 10 vezes. <br><br>  Matrizes constantes de milh√µes de elementos em aplica√ß√µes reais, √© claro, nem sempre s√£o encontradas, mas as pequenas s√£o bastante comuns.  Em cada um deles voc√™ ter√° uma pequena, mas uma vit√≥ria. <br><br><h3>  Os objetos </h3><br>  Os links para todos os objetos no PHP 5 estavam em um reposit√≥rio separado, e no zval havia apenas identificador - um ID de objeto exclusivo. <br><br><img src="https://habrastorage.org/webt/in/lo/dq/inlodqhjne7lo12nslgcuqrckvy.png"><br><br>  Para chegar ao objeto, fizemos pelo menos tr√™s leituras.  Al√©m disso, a mem√≥ria para o valor de cada propriedade do objeto foi alocada separadamente, e precis√°vamos de pelo menos mais 2 leituras para l√™-lo. <br><br>  No PHP 7, fomos capazes de passar para o endere√ßamento direto. <br><br><img src="https://habrastorage.org/webt/zm/vp/vv/zmvpvvqlmybttr3zvze6gzglin4.png"><br><br>  O endere√ßo <code>zend_object</code> est√° acess√≠vel com uma √∫nica instru√ß√£o de m√°quina.  E as propriedades s√£o incorporadas e, para l√™-las, voc√™ precisa de apenas uma leitura adicional.  Eles tamb√©m s√£o agrupados, o que <strong>melhora a localiza√ß√£o dos dados</strong> e ajuda os processadores modernos a n√£o trope√ßar. <br><br>  Al√©m da propriedade predefinida, um link para a classe desse objeto tamb√©m √© armazenado aqui, alguns manipuladores - um an√°logo de tabelas de m√©todos virtuais e uma tabela de hash para propriedades que n√£o foram definidas.  No PHP, voc√™ pode adicionar propriedades a qualquer objeto que n√£o foi definido originalmente e, se v√°rias instru√ß√µes da m√°quina forem suficientes para acessar a propriedade predefinida, para propriedades n√£o predefinidas, ser√° necess√°rio usar uma tabela de hash, o que exigir√° dezenas de instru√ß√µes da m√°quina.  Claro, isso √© muito mais caro. <br><br><h3>  Refer√™ncia </h3><br>  Finalmente, tivemos que introduzir um <strong>tipo separado</strong> para representar links PHP. <br><br><img src="https://habrastorage.org/webt/yk/jj/ng/ykjjngfnlq8sefuvmwzjfxwjz7g.png"><br><br>  Este √© um tipo completamente transparente.  N√£o √© vis√≠vel para scripts PHP.  Os scripts veem outro zval incorporado √† estrutura zend_reference.  Entende-se que nos referimos a uma dessas estruturas de pelo menos dois locais, e o contador de refer√™ncia dessa estrutura √© sempre maior que 1. Assim que o contador cai para 1, o link se transforma em um valor escalar regular.  O zval incorporado no link √© copiado para o √∫ltimo zval que o referencia e a pr√≥pria estrutura √© exclu√≠da. <br><br>  Parece que trabalhar com refer√™ncia agora √© muito mais complicado do que com outros tipos (e isso √© verdade), mas na verdade no PHP 5 tivemos que fazer um trabalho de complexidade compar√°vel ao acessar qualquer valor (mesmo um n√∫mero inteiro primo).  Agora, estamos aplicando protocolos mais complexos a apenas um tipo e, portanto, aceleramos o trabalho com todos os outros, especialmente com valores escalares. <br><br><h3>  IS_FALSE e IS_TRUE </h3><br>  Eu j√° disse que o tipo √∫nico IS_BOOL foi dividido em IS_FALSE e IS_TRUE.  Essa id√©ia foi espionada na implementa√ß√£o do LuaJIT e foi criada para acelerar uma das opera√ß√µes mais comuns - a transi√ß√£o condicional. <br><br><img src="https://habrastorage.org/webt/fv/5j/-z/fv5j-zx0u_2kfmtmxjwce4uzetk.png"><br><br>  Se no PHP 5 foi necess√°rio ler o tipo, verificar booleano, ler o valor, descobrir se √© verdadeiro ou falso e fazer uma transi√ß√£o com base nisso, agora basta verificar o tipo e compar√°-lo com true: <br><br><ul><li>  se √© verdade, seguimos um ramo; </li><li>  se for menor que verdade, v√° para outro ramo; </li><li>  se for mais do que verdadeiro, v√° para o chamado caminho lento (caminho lento) e l√° verificamos de que tipo ele veio e o que fazer com ele: se for inteiro, devemos comparar seu valor com 0, se float - novamente com 0 ( mas real) etc. </li></ul><br><h2>  Conven√ß√£o de chamada </h2><br>  Uma altera√ß√£o na conven√ß√£o de chamada ou conven√ß√£o de chamada de fun√ß√£o √© uma otimiza√ß√£o importante que afeta n√£o apenas as estruturas de dados, mas tamb√©m os algoritmos subjacentes.  Na figura √† esquerda, h√° um pequeno script que consiste na fun√ß√£o foo () e em sua chamada.  Abaixo est√° o bytecode no qual este script foi compilado pelo PHP 5. <br><br><img src="https://habrastorage.org/webt/bn/fw/a4/bnfwa4e5ifjqs6rd6cp66uctega.png"><br><br>  Primeiro, eu vou lhe contar como funcionou no PHP 5. <br><br><h3>  Conven√ß√£o de Chamada no PHP 5 </h3><br>  A primeira instru√ß√£o <code>SEND_VAL</code> foi enviar o valor "3" para a fun√ß√£o foo.  Para fazer isso, ela foi for√ßada a alocar um novo zval na pilha, copiar o valor (3) l√° e escrever o valor do ponteiro nessa estrutura na pilha. <br><br><img src="https://habrastorage.org/webt/mt/vu/d3/mtvud3tb2ljaijnwecbmvnqepjs.png"><br><br>  Da mesma forma com a segunda instru√ß√£o.  <code>DO_FCALL</code> inicializou <code>CALL FRAME</code> , reservou um local para vari√°veis ‚Äã‚Äãlocais e tempor√°rias e transferiu o controle para a fun√ß√£o chamada. <br><br><img src="https://habrastorage.org/webt/rx/rw/qo/rxrwqogtbhgd0q9tsd7wnw2r4og.png"><br><br>  A primeira <code>RECV</code> verificou o primeiro argumento e inicializou o slot na pilha com a vari√°vel local correspondente ($ a).  Aqui fizemos sem copiar e simplesmente aumentamos o contador de refer√™ncia do par√¢metro correspondente (zval com um valor de 3).  Da mesma forma, a segunda <code>RECV</code> estabeleceu uma conex√£o entre a vari√°vel $ be o par√¢metro 5. <br><br><img src="https://habrastorage.org/webt/lw/c1/zw/lwc1zw26uby_oj54yjzu7yz-vus.png"><br><br>  Outras fun√ß√µes corporais.  A adi√ß√£o de 3 + 5 aconteceu - resultou em 8. Esta √© uma vari√°vel tempor√°ria e seu valor foi armazenado diretamente na pilha. <br><br><img src="https://habrastorage.org/webt/d0/xj/s5/d0xjs5j2c0i6qgioybezypay9k4.png"><br><br>  RETURN e retornamos da fun√ß√£o. <br><br><img src="https://habrastorage.org/webt/zd/cc/nb/zdccnbal1xuynwdcymbrwcf2fmq.png"><br><br>  Ao retornar, liberamos todas as vari√°veis ‚Äã‚Äãe argumentos que est√£o fora do escopo.  Para fazer isso, passamos por todo o zval referenciado por slots do quadro liberado e, para cada um, diminu√≠mos a contagem de refer√™ncia.  Se atingir 0, destrua a estrutura correspondente. <br><br>  Como voc√™ pode ver, mesmo uma opera√ß√£o simples como enviar uma constante para uma fun√ß√£o requer alocar nova mem√≥ria, copiar e aumentar o contador de refer√™ncia e, em seguida, diminuir e excluir duas vezes. <br><br><h3>  Conven√ß√£o de Chamada no PHP 7 </h3><br>  No PHP 7, esses problemas foram corrigidos - agora, na pilha, armazenamos n√£o os ponteiros zval, mas os pr√≥prios zval. <br><br><img src="https://habrastorage.org/webt/xc/ek/ls/xceklspoxwmga__zvpeat1a4plw.png"><br><br>  Tamb√©m introduzimos uma nova instru√ß√£o, <code>INIT_FCALL</code> , que agora √© respons√°vel por inicializar e alocar mem√≥ria sob <code>CALL FRAME</code> e reservar espa√ßo para argumentos e vari√°veis ‚Äã‚Äãtempor√°rias. <br><br><img src="https://habrastorage.org/webt/yi/gd/a5/yigda5wg7xswdcyadip7euboboa.png"><br><br>  <code>SEND_VAL 3</code> agora apenas copia o argumento para o primeiro espa√ßo ap√≥s o <code>CALL FRAME</code> .  Pr√≥ximo <code>SEND_VAL 5</code> para o segundo espa√ßo. <br><br><img src="https://habrastorage.org/webt/-0/es/8_/-0es8_skigjtyvja3vzzegwo-su.png"><br><br>  Ent√£o o mais interessante.  Parece que <code>DO_FCALL</code> deve passar o controle para a primeira instru√ß√£o da fun√ß√£o chamada.  Mas os argumentos j√° atingiram os slots reservados para os par√¢metros vari√°veis ‚Äã‚Äã$ a e $ b, e as instru√ß√µes <code>RECV</code> simplesmente n√£o fazem nada.  Portanto, voc√™ pode simplesmente ignor√°-los.  Enviamos dois par√¢metros, ent√£o pulamos duas instru√ß√µes.  Se eles mandassem tr√™s, teriam perdido tr√™s. <br><br><img src="https://habrastorage.org/webt/4z/vm/gj/4zvmgjldpmtfpgprtvqoks__-km.png"><br><br>  Ent√£o, vamos diretamente ao corpo da fun√ß√£o, fazemos acr√©scimos e retornamos. <br><br><img src="https://habrastorage.org/webt/zh/j1/yf/zhj1yfwxp5kf1s4xxlyoasy170i.png"><br><br>  Ao retornar, limpamos todas as vari√°veis ‚Äã‚Äãlocais, mas agora apenas para dois slots, e como temos escalares l√°, novamente n√£o precisamos fazer nada. <br><br><img src="https://habrastorage.org/webt/wy/dh/2p/wydh2pvz_hpawjivtoxx3hmxoqa.png"><br><br>  Minha hist√≥ria √© um pouco simplificada, n√£o leva em conta fun√ß√µes com um n√∫mero vari√°vel de argumentos e a necessidade de verifica√ß√£o de tipo e alguns outros pontos. <br><br>  <strong>A nova conven√ß√£o de chamadas quebrou um pouco a compatibilidade</strong> .  O PHP possui fun√ß√µes como <code>func_get_arg</code> e <code>func_get_args</code> .  Se antes eles retornavam o valor original do par√¢metro enviado, agora retornam o valor atual da vari√°vel local correspondente, porque simplesmente n√£o armazenamos os valores originais.  Assim como o C. debuggers <br><br><img src="https://habrastorage.org/webt/5r/n2/6j/5rn26j24gjyfolmeu07qgv1wmxu.png"><br><br>  Al√©m disso, a fun√ß√£o n√£o pode mais ter v√°rios par√¢metros com o mesmo nome.  N√£o havia sentido nisso antes, mas eu conheci esse c√≥digo PHP <code>foo($_, $_)</code> .  Como √© isso?  (Eu reconheci Prolog) <br><br><h2>  Novo gerenciador de mem√≥ria </h2><br>  Concluindo a otimiza√ß√£o das estruturas de dados e dos algoritmos b√°sicos, chamamos novamente a aten√ß√£o para todos os subsistemas de frenagem.  O gerenciador de mem√≥ria no PHP 5 ocupou <strong>quase 20% do tempo do processador</strong> no Wordpress. <br><br>  Depois que nos livramos de muitas aloca√ß√µes, seus custos indiretos se tornaram menores, mas ainda significativos - e n√£o porque ele estava fazendo um trabalho significativo, mas porque trope√ßou no cache.  Isso se deve ao fato de termos utilizado o algoritmo malloc cl√°ssico de Doug Lea, que envolvia a localiza√ß√£o adequada de mem√≥ria livre viajando atrav√©s de links e √°rvores, e todas essas viagens causavam inevitavelmente falhas no cache. <br><br>  Atualmente, existem novos algoritmos de gerenciamento de mem√≥ria que levam em considera√ß√£o os recursos dos processadores modernos.  Por exemplo: <strong>jemalloc</strong> e <strong>ptmalloc do Google</strong> .  Inicialmente, tentamos us√°-los inalterados, mas n√£o obtivemos uma vit√≥ria, pois a falta de funcionalidade espec√≠fica do PHP tornava mais caro liberar completamente a mem√≥ria no final da solicita√ß√£o.  Como resultado, abandonamos o dlmalloc e escrevemos algo pr√≥prio, combinando id√©ias do antigo gerenciador de mem√≥ria e jemalloc. <br><br>  <strong>Reduzimos a sobrecarga do Memory Manager para 5%</strong> , reduzimos a sobrecarga de mem√≥ria para obter informa√ß√µes de servi√ßo e melhoramos o uso do cache da CPU.  Os blocos de mem√≥ria adequados agora s√£o pesquisados ‚Äã‚Äãpor bitmaps, a mem√≥ria para blocos pequenos √© alocada em p√°ginas separadas e armazenada em cache ap√≥s a libera√ß√£o, adicionando fun√ß√µes especializadas para tamanhos de bloco usados ‚Äã‚Äãcom freq√º√™ncia. <br><br><h2>  Muitas pequenas melhorias </h2><br>  Falei apenas sobre as melhorias mais importantes, mas houve muito mais pequenas.  Eu posso mencionar alguns deles. <br><br><ul><li>  API r√°pida para analisar par√¢metros de fun√ß√µes internas e uma nova API para iterar no HashTable. </li><li>  Novas instru√ß√µes da VM: concatena√ß√£o de strings, especializa√ß√£o, super instru√ß√µes. </li><li>  Algumas fun√ß√µes internas foram transformadas em instru√ß√µes da VM: strlen, is_int. </li><li>  Usando registros da CPU para registros da VM: IP e FP. </li><li>  Otimiza√ß√£o da duplica√ß√£o e exclus√£o de matrizes. </li><li>  Usar a contagem de links em vez de copiar sempre que poss√≠vel. </li><li>  PCRE JIT. </li><li>  Otimiza√ß√£o de fun√ß√µes internas e serializa√ß√£o (). </li><li>  Tamanho de c√≥digo reduzido e dados processados. </li></ul><br>  Alguns eram muito simples, por exemplo, eram necess√°rias apenas tr√™s linhas de c√≥digo para habilitar o JIT em express√µes Perl regulares, e isso imediatamente trouxe acelera√ß√£o vis√≠vel (2-3%) para quase todos os aplicativos.  Outras otimiza√ß√µes abordaram alguns aspectos estreitos de certas fun√ß√µes do PHP e n√£o s√£o particularmente interessantes, embora a contribui√ß√£o total de todas essas pequenas melhorias seja bastante significativa. <br><br><h2>  O que voc√™ veio a </h2><br>  Esta √© a contribui√ß√£o de v√°rios subsistemas no WordPress / PHP 7.0. <br><br><img src="https://habrastorage.org/webt/7q/r4/d0/7qr4d08m8yhid4rngwh9-gffxbu.png"><br><br>  A contribui√ß√£o da m√°quina virtual aumentou para 50%. Memory Manager    5% ‚Äî         Memory Manager,        .         130 . ,    10 .  ,           Memory Manager           ,         . <br><br><img src="https://habrastorage.org/webt/kk/nq/5p/kknq5ppnd1ihr8wjw9xfv38boyy.png"><br>   : <br><br><ul><li>      2 . </li><li>   MM   17 . </li><li> -     4 . </li><li>    WordPress   3,5 . </li></ul><br>       2,5-  ,    .  ?   ,         ,        CPU time,   ‚Äî  ,    .  PHP     ,        . <br><br><h3>  PHP 7 </h3><br> WordPress 3.6      ‚Äî         .  - ,   PHP 7   mysql,     ,     . <br><br><img src="https://habrastorage.org/webt/bs/x9/pa/bsx9pa3fc3ccedmnajaj1h5dm0q.png"><br><br>   ,          PHPNG.     2/3 .     ,    . <br><br> ,       WordPress,      ,      ‚Äî  1,5  2- . <br><br><h3> PHP 7  HHVM </h3><br>              HHVM. <br><br><img src="https://habrastorage.org/webt/fs/vg/ot/fsvgotogozunvqed7dwflmmef1u.png"><br><br>      ‚Äî  .     .   Facebook   .   HHVM   . ,      ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/c_/pg/jv/c_pgjvoejr-q3o5sgvgtplxkbm0.png"><br><br>  PHP 7 ‚Äî    .    Vebia,  Etsy  Badoo. Highload-    ,       . <br><br>   PHP 7.0  Etsy  Badoo       -. Badoo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>    . <br><br><img src="https://habrastorage.org/webt/pn/rv/rj/pnrvrjrzp9re46lbmngnyddzu44.png"><br><br>  ,          2 ,    ‚Äî   7 . <br><br>         PHP 7.0.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,  PHP 7.1,        . <br><br><blockquote>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PHP Russia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>        <b>PHP 8</b> .         PHP,  ,    ,      ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>  1 .  , ,    ‚Äî   ,    ,     ,  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444508/">https://habr.com/ru/post/pt444508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444494/index.html">La Moto Volante (Lazareth LMV 496) - motocicleta transformadora voadora</a></li>
<li><a href="../pt444496/index.html">Novas ferramentas para detectar intercepta√ß√£o HTTPS</a></li>
<li><a href="../pt444500/index.html">29 de mar√ßo de Moscou - Hist√≥rias em back-end 3.0</a></li>
<li><a href="../pt444502/index.html">A criptografia qu√¢ntica √© realmente confi√°vel?</a></li>
<li><a href="../pt444504/index.html">Usando o diret√≥rio local do pacote no Python agora</a></li>
<li><a href="../pt444512/index.html">Criando uma aplica√ß√£o gr√°fica para resolver o problema do percurso do cavalo</a></li>
<li><a href="../pt444514/index.html">Webinar "Seguran√ßa do aprendizado de m√°quina: problemas naturais da intelig√™ncia artificial"</a></li>
<li><a href="../pt444516/index.html">Wolfenstein 3D: tra√ßado de raios com WebGL1</a></li>
<li><a href="../pt444518/index.html">Rumo a uma teoria fundamental da consci√™ncia</a></li>
<li><a href="../pt444520/index.html">2. Introdu√ß√£o ao Ponto de Verifica√ß√£o R80.20. Arquitetura da solu√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>