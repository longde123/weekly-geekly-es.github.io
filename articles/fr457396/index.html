<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò≤ üç§ ‚òòÔ∏è D√©verrouillage automatique du conteneur racine LUKS apr√®s un d√©marrage √† chaud ‚è¨ üòá üíÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi les gens chiffrent-ils g√©n√©ralement les lecteurs de leurs ordinateurs personnels et parfois leurs serveurs? Il est clair que personne n'a vol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©verrouillage automatique du conteneur racine LUKS apr√®s un d√©marrage √† chaud</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457396/"><p>  Pourquoi les gens chiffrent-ils g√©n√©ralement les lecteurs de leurs ordinateurs personnels et parfois leurs serveurs?  Il est clair que personne n'a vol√© les photos de leurs chats pr√©f√©r√©s sur le disque!  C'est juste de la malchance: un lecteur crypt√© vous oblige √† entrer une phrase cl√© √† partir du clavier √† chaque d√©marrage, et c'est long et ennuyeux.  Le supprimer pour qu'au moins parfois il ne soit pas n√©cessaire de le recruter.  Oui, afin que le sens du cryptage ne soit pas perdu. </p><br><div class="spoiler">  <b class="spoiler_title">Chat pour attirer l'attention</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="Chat"></p></div></div><br><p>  Eh bien, supprimez-le compl√®tement, cela ne fonctionnera pas.  Vous pouvez √† la place cr√©er un fichier cl√© sur une cl√© USB et cela fonctionnera √©galement.  Et sans cl√© USB (et sans deuxi√®me ordinateur sur le r√©seau) est-ce possible?  Si vous avez de la chance avec le BIOS, vous pouvez presque!  Sous la coupe sera un guide sur la fa√ßon de configurer le chiffrement du disque via LUKS avec les propri√©t√©s suivantes: </p><br><ol><li>  La phrase secr√®te ou le fichier de cl√© n'est stock√© nulle part sous forme ouverte (ou sous la forme √©quivalente √† open) lorsque l'ordinateur est √©teint. </li><li> La premi√®re fois que vous allumez votre ordinateur, vous devez saisir une phrase secr√®te. </li><li>  Lors des red√©marrages ult√©rieurs (avant l'arr√™t), une phrase secr√®te n'est pas requise. </li></ol><br><p>  Les instructions ont √©t√© test√©es sur CentOS 7.6, Ubuntu 19.04 et openSUSE Leap 15.1 sur des machines virtuelles et sur du mat√©riel r√©el (ordinateur de bureau, ordinateur portable et deux serveurs).  Ils devraient travailler sur d'autres distributions qui ont une version fonctionnelle de Dracut. </p><br><p>  Et oui, dans le bon sens, cela aurait d√ª se retrouver dans le hub ¬´administration du syst√®me anormal¬ª, mais il n'y a pas un tel hub. </p><a name="habracut"></a><br><p>  Je sugg√®re d'utiliser un emplacement s√©par√© dans le conteneur LUKS et d'y stocker la cl√© ... en RAM! </p><br><div class="spoiler">  <b class="spoiler_title">Quel genre de slot?</b> <div class="spoiler_text"><p> Le conteneur LUKS impl√©mente le chiffrement √† plusieurs niveaux.  Les donn√©es utiles sur le disque sont chiffr√©es avec un chiffrement sym√©trique, g√©n√©ralement <code>aes-xts-plain64</code> .  La cl√© de ce chiffrement sym√©trique (cl√© principale) est g√©n√©r√©e au stade de la cr√©ation du conteneur sous la forme d'une s√©quence al√©atoire d'octets.  La cl√© principale est stock√©e sous forme crypt√©e, dans le cas g√©n√©ral - en plusieurs exemplaires (emplacements).  Par d√©faut, un seul des huit emplacements est actif.  Chaque emplacement actif a une phrase cl√© distincte (ou un fichier de cl√©s distinct), avec lequel vous pouvez d√©crypter la cl√© principale.  Du point de vue de l'utilisateur, il s'av√®re que vous pouvez d√©verrouiller le lecteur √† l'aide de plusieurs phrases cl√©s (ou fichiers cl√©s) diff√©rentes.  Dans notre cas, en utilisant une phrase cl√© (slot 0) ou en utilisant un morceau de m√©moire utilis√© comme fichier cl√© (slot 6). </p></div></div><br><p>  Le BIOS sur la plupart des cartes m√®res ne nettoie pas la m√©moire lors du red√©marrage, ou vous pouvez le configurer pour ne pas nettoyer (exception connue: "Intel Corporation S1200SP / S1200SP, BIOS S1200SP.86B.03.01.0042.013020190050 01/30/2019").  Par cons√©quent, vous pouvez y stocker la cl√©.  Lorsque l'alimentation est coup√©e, le contenu de la RAM elle-m√™me est effac√© apr√®s un certain temps, avec une copie non prot√©g√©e de la cl√©. </p><br><p>  Alors allons-y. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk">  Premi√®re √©tape: installer le syst√®me sur un disque chiffr√© √† l'aide de LUKS </h3><br><p>  Dans ce cas, la partition de disque (par exemple, <code>/dev/sda1</code> ) mont√©e dans <code>/boot</code> doit rester non chiffr√©e, et l'autre partition sur laquelle tout le reste (par exemple, <code>/dev/sda2</code> ) doit √™tre chiffr√©e.  Le syst√®me de fichiers sur la partition chiffr√©e peut √™tre n'importe lequel, vous pouvez √©galement utiliser LVM pour que le syst√®me de fichiers racine, le volume de swap et tout le reste, sauf <code>/boot</code> dans le m√™me conteneur.  Cela correspond au partitionnement de disque par d√©faut dans CentOS 7 et Debian lors du choix de l'option de chiffrement.  SUSE fait tout diff√©remment (chiffre <code>/boot</code> ) et n√©cessite donc un partitionnement manuel du disque. </p><br><p>  Le r√©sultat devrait ressembler √† ceci: </p><br><pre> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ‚îú‚îÄsda1 8:1 0 1G 0 part /boot ‚îî‚îÄsda2 8:2 0 9G 0 part ‚îî‚îÄluks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ‚îú‚îÄcentos_centos--encrypt2-root 253:1 0 8G 0 lvm / ‚îî‚îÄcentos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p>  Dans le cas de l'utilisation d'UEFI, il y aura √©galement une partition syst√®me EFI. </p><br><blockquote>  Pour les utilisateurs Debian et Ubuntu: remplacez le paquet <code>initramfs-tools</code> par <code>dracut</code> . <br><pre> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  <code>initramfs-tools</code> impl√©mente une logique incorrecte dans notre cas, appliqu√©e aux sections chiffr√©es avec un fichier cl√©.  Ces sections sont soit compl√®tement ignor√©es, soit le contenu du fichier de cl√©s est copi√© sur initramfs (c'est-√†-dire, par cons√©quent, sur le disque) en clair, ce dont nous n'avons pas besoin. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki">  √âtape 2: cr√©er un fichier de cl√© qui sera utilis√© pour d√©verrouiller automatiquement le lecteur apr√®s un red√©marrage √† chaud </h3><br><p>  128 bits al√©atoires nous suffisent, soit  16 octets.  Le fichier sera stock√© sur un disque crypt√©, donc personne qui ne conna√Æt pas la cl√© de cryptage et n'a pas d'acc√®s root au syst√®me charg√© ne la lira pas. </p><br><pre> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p>  Il y a suffisamment de bits vraiment al√©atoires dans le fichier de cl√© pour que l'algorithme PBKDF lent, qui cr√©e une cl√© de chiffrement difficile √† choisir √† partir d'une phrase cl√© potentiellement faible, ne soit pas vraiment n√©cessaire.  Par cons√©quent, lorsque vous ajoutez une cl√©, vous pouvez r√©duire le nombre d'it√©rations: </p><br><pre> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p>  Comme vous pouvez le voir, le fichier de cl√© est stock√© sur un disque crypt√© et ne pose donc aucun risque de s√©curit√© si l'ordinateur est √©teint. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha">  √âtape 3: Allouer de l'espace dans la m√©moire physique pour stocker la cl√© </h3><br><p>  Linux poss√®de au moins trois pilotes diff√©rents qui vous permettent d'acc√©der √† la m√©moire physique √† une adresse connue.  Il s'agit de <code>linux/drivers/char/mem.c</code> , qui est √©galement responsable du p√©riph√©rique <code>/dev/mem</code> , ainsi que des modules <code>phram</code> (√©mule une puce MTD, donne le p√©riph√©rique <code>/dev/mtd0</code> ) et <code>nd_e820</code> (utilis√© lorsque vous travaillez avec NVDIMM, donne <code>/dev/pmem0</code> ).  Ils ont tous leurs caract√©ristiques d√©sagr√©ables: </p><br><ul><li>  <code>/dev/mem</code> pas accessible en √©criture lors de l'utilisation de Secure Boot si la distribution <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilise l'ensemble de correctifs LOCKDOWN</a> de Matthew Garrett (et cet ensemble de correctifs est requis si la distribution va prendre en charge Secure Boot avec un chargeur de d√©marrage sign√© par Microsoft); </li><li>  <code>phram</code> pas disponible sur CentOS et Fedora - le responsable n'a tout simplement pas activ√© l'option correspondante lors de la construction du noyau; </li><li>  <code>nd_e820</code> doit r√©server au moins 128 m√©gaoctets de m√©moire - c'est ainsi que fonctionne NVDIMM.  Mais c'est la seule option fonctionnant sur CentOS avec Secure Boot. </li></ul><br><p>  Puisqu'il n'y a pas d'option id√©ale, les trois sont consid√©r√©s ci-dessous. </p><br><blockquote>  Lors de l'utilisation de l'une des m√©thodes, un soin extr√™me est n√©cessaire afin de ne pas affecter accidentellement les p√©riph√©riques ou les plages de m√©moire autres que ce qui est n√©cessaire.  Cela est particuli√®rement vrai pour les ordinateurs qui ont d√©j√† des puces MTD ou des modules NVDIMM.  A savoir, <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> peut ne pas √™tre le p√©riph√©rique qui correspond √† la zone de m√©moire r√©serv√©e au stockage de la cl√©.  La num√©rotation des p√©riph√©riques existants, sur lesquels s'appuient les fichiers de configuration et les scripts, peut √©galement √™tre confondue.  Par cons√©quent, il est recommand√© de d√©sactiver temporairement tous les services qui d√©pendent des p√©riph√©riques existants <code>/dev/mtd*</code> et <code>/dev/pmem*</code> . </blockquote><p>  La m√©moire physique de Linux est <code>memmap</code> en passant l'option <code>memmap</code> au <code>memmap</code> .  Nous sommes int√©ress√©s par deux types de cette option: </p><br><ul><li>  <code>memmap=4K$0x10000000</code> r√©serves (c'est-√†-dire, marques r√©serv√©es pour que le noyau lui-m√™me n'utilise pas) 4 kilo-octets de m√©moire, en commen√ßant par l'adresse physique 0x10000000; </li><li>  <code>memmap=128M!0x10000000</code> marque 128 m√©gaoctets de m√©moire physique, en commen√ßant √† l'adresse 0x10000000, en tant que NVDIMM (√©videmment faux, mais cela fera l'affaire pour nous). </li></ul><br><p>  L'option c <code>$</code> peut √™tre utilis√©e avec <code>/dev/mem</code> et <code>phram</code> , l'option c <code>!</code>  - pour <code>nd_e820</code> .  Lors de l'utilisation de <code>$</code> adresse de d√©part de la m√©moire r√©serv√©e doit √™tre un multiple de <code>0x1000</code> (soit 4 kilo-octets), lors de l'utilisation <code>!</code>  - un multiple de <code>0x8000000</code> (soit 128 m√©gaoctets). </p><br><p>  Important: le signe dollar ( <code>$</code> ) dans les fichiers de configuration de GRUB est un caract√®re sp√©cial et doit √™tre √©chapp√©.  Et deux fois: une fois - lors de la g√©n√©ration de <code>grub.cfg</code> partir de <code>/etc/default/grub</code> , une deuxi√®me fois - lors de l'interpr√©tation du fichier de configuration r√©sultant √† l'√©tape de d√©marrage.  C'est-√†-dire  dans <code>/etc/default/grub</code> , la ligne suivante devrait finalement appara√Ætre: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p>  Sans double √©chappement du signe <code>$</code> , le syst√®me ne d√©marre tout simplement pas, car il pensera qu'il n'a que 4 kilo-octets de m√©moire.  Il n'y a pas de telles difficult√©s avec un point d'exclamation: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p>  La carte m√©moire physique (et il est n√©cessaire de savoir quelles adresses r√©server) est accessible √† l' <code>root</code> dans le pseudo- <code>/proc/iomem</code> : </p><br><pre> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p>  La RAM est marqu√©e "System RAM", il nous suffit de r√©server une de ses pages pour stocker la cl√©.  Deviner quelle partie de la m√©moire du BIOS ne touche pas au red√©marrage ne fonctionnera pas de mani√®re fiable √† l'avance.  Sauf s'il existe un autre ordinateur avec exactement la m√™me version du BIOS et la m√™me configuration de m√©moire sur laquelle ce manuel a d√©j√† √©t√© compl√©t√©.  Par cons√©quent, dans le cas g√©n√©ral, il faudra agir par essais et erreurs.  En r√®gle g√©n√©rale, lorsque le BIOS red√©marre, il modifie les donn√©es uniquement au d√©but et √† la fin de chaque plage de m√©moire.  Il suffit g√©n√©ralement de retirer 128 m√©gaoctets ( <code>0x8000000</code> ) des bords.  Pour les machines virtuelles KVM avec 1 Go de m√©moire ou plus, les options propos√©es ( <code>memmap=4K$0x10000000</code> et <code>memmap=128M!0x10000000</code> ) fonctionnent. </p><br><p>  Lorsque vous utilisez le module <code>phram</code> , <code>phram</code> besoin d'un autre param√®tre de ligne de commande du noyau, qui, en fait, indique au module quel morceau de m√©moire physique utiliser - le n√¥tre, r√©serv√©.  Le param√®tre est appel√© <code>phram.phram</code> et contient trois parties: le nom (arbitraire jusqu'√† 63 caract√®res, sera visible dans <code>sysfs</code> ), l'adresse de d√©part et la longueur.  L'adresse et la longueur de d√©part doivent √™tre les m√™mes que dans <code>memmap</code> , mais les suffixes <code>K</code> et <code>M</code> ne <code>M</code> pas pris en charge. </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p>  Apr√®s avoir √©dit√© <code>/etc/default/grub</code> vous devez r√©g√©n√©rer le fichier de configuration r√©el que GRUB lit au d√©marrage.  La commande correcte pour cela d√©pend de la distribution. </p><br><pre> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p>  Apr√®s avoir mis √† jour la configuration GRUB, l'ordinateur doit √™tre red√©marr√©, mais nous le ferons plus tard lorsque nous mettrons √† jour initramfs. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati">  Quatri√®me √©tape: configurer LUKS pour lire la cl√© de la m√©moire </h3><br><p>  <code>/etc/crypttab</code> param√®tres de chiffrement des <code>/etc/crypttab</code> sont stock√©s dans le <code>/etc/crypttab</code> .  Chaque ligne se compose de quatre champs: </p><br><ul><li>  l'appareil √† obtenir lors du d√©verrouillage, </li><li>  appareil crypt√© </li><li>  o√π obtenir le fichier cl√© ( <code>none</code> signifie entrer une phrase cl√© √† partir du clavier), </li><li>  champ facultatif pour les options. </li></ul><br><p>  Si le fichier de cl√©s existe mais ne convient pas, Dracut demande la phrase cl√©.  Ce qui, en fait, sera n√©cessaire au premier d√©marrage. </p><br><p>  Un exemple du <code>/etc/crypttab</code> d'une distribution fra√Æchement install√©e: </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p>  Le fichier cl√© dans notre cas sera un morceau de m√©moire physique.  C'est-√†-dire  <code>/dev/mem</code> , <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> , selon la technologie d'acc√®s √† la m√©moire s√©lectionn√©e.  Des options sont n√©cessaires pour indiquer quelle partie du fichier est la cl√©. </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p>  C'est juste que √ßa ne marchera pas comme √ßa. </p><br><p>  Le point est de savoir comment systemd d√©termine quand un appareil peut √™tre d√©verrouill√©.  √Ä savoir, il prend l'appareil de la troisi√®me colonne et attend que l'unit√© d'appareil correspondante devienne active.  Cela semble logique: cela n'a aucun sens d'essayer de d√©verrouiller le conteneur LUKS jusqu'√† ce qu'un p√©riph√©rique avec un fichier de cl√© apparaisse.  Mais l'unit√© de l'appareil n'est pas la m√™me que l'appareil lui-m√™me.  Par d√©faut, Systemd cr√©e des unit√©s de p√©riph√©rique uniquement pour les p√©riph√©riques du noyau li√©s aux sous-syst√®mes de p√©riph√©riques de bloc et aux interfaces r√©seau.  Les p√©riph√©riques <code>/dev/mem</code> et <code>/dev/mtd0</code> sont caract√®re par caract√®re, ils ne sont donc pas surveill√©s par d√©faut et ne seront jamais reconnus comme pr√™ts. </p><br><p>  Vous devrez dire √† systemd qu'il doit les suivre en cr√©ant des r√®gles udev dans le fichier <code>/etc/udev/rules.d/99-mem.rules</code> : </p><br><pre> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs">  Cinqui√®me √©tape: r√©g√©n√©rer les initramfs </h3><br><blockquote>  Je vous rappelle: cet article ne traite que des distributions utilisant Dracut.  Y compris ceux o√π il n'est pas utilis√© par d√©faut, mais est accessible et efficace. </blockquote><p>  Vous devez r√©g√©n√©rer initramfs pour y mettre √† jour le fichier <code>/etc/crypttab</code> .  Et aussi - pour y inclure des modules de noyau suppl√©mentaires et des r√®gles udev.  Sinon, le p√©riph√©rique <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> ne sera pas cr√©√©.  Le param√®tre de configuration Dracut <code>force_drivers</code> est responsable de l'activation et du chargement de modules de noyau suppl√©mentaires, et <code>install_items</code> est responsable des fichiers suppl√©mentaires.  Nous cr√©ons le fichier <code>/etc/dracut.conf.d/mem.conf</code> avec le contenu suivant (un espace apr√®s le guillemet d'ouverture est requis, c'est un s√©parateur): </p><br><pre> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p>  Initramfs de r√©g√©n√©ration en fait: </p><br><pre> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote>  Pour les utilisateurs Debian et Ubuntu, le mainteneur a mis un rake: le fichier r√©sultant est appel√© de mani√®re incorrecte.  Vous devez le renommer afin qu'il soit nomm√© de la m√™me mani√®re que celui prescrit dans la configuration GRUB: <br><pre> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  Lors de l'installation de nouveaux noyaux, la cr√©ation automatique d'initramfs via Dracut s'effectue correctement, le bug n'affecte que le lancement manuel de <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter">  √âtape six: red√©marrez votre ordinateur </h3><br><p>  Un red√©marrage est n√©cessaire pour que les modifications apport√©es √† la configuration GRUB et Dracut prennent effet. </p><br><pre> <code class="plaintext hljs"># reboot</code> </pre> <br><p>  √Ä ce stade, il n'y a pas de cl√© en m√©moire, vous devrez donc saisir une phrase secr√®te. </p><br><p>  Apr√®s le red√©marrage, vous devez v√©rifier si la sauvegarde de la m√©moire a fonctionn√© correctement.  Au minimum, dans le pseudo- <code>/proc/iomem</code> m√©moire requise doit √™tre marqu√©e comme "r√©serv√©e" (lors de l'utilisation de <code>/dev/mem</code> ou <code>phram</code> ) ou comme "M√©moire persistante (h√©rit√©e)". </p><br><p>  M√™me lorsque vous utilisez <code>phram</code> ou <code>nd_e820</code> vous devez vous assurer que le p√©riph√©rique <code>/dev/mtd0</code> ou <code>/dev/pmem0</code> fait vraiment r√©f√©rence √† la zone de m√©moire pr√©c√©demment r√©serv√©e, et non √† autre chose. </p><br><pre> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p>  Si ce n'est pas le cas, vous devez trouver lequel des p√©riph√©riques <code>/dev/mtd*</code> ou <code>/dev/pmem*</code> "le n√¥tre", puis corriger / etc / crypttab, r√©g√©n√©rer initramfs et rev√©rifier le r√©sultat apr√®s un autre red√©marrage. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat">  Septi√®me √©tape: configurer la copie du fichier cl√© dans la m√©moire </h3><br><p>  Le fichier cl√© sera copi√© en m√©moire avant de red√©marrer.  L'une des fa√ßons d'ex√©cuter une commande au stade de l'arr√™t du syst√®me consiste √† l'enregistrer dans la directive <code>ExecStop</code> du service systemd.  Pour que systemd comprenne qu'il ne s'agit pas d'un d√©mon et ne jure pas de l'absence de la directive <code>ExecStart</code> , vous devez sp√©cifier le type de service en tant que <code>oneshot</code> et sugg√©rer √©galement que le service est consid√©r√© comme en cours d'ex√©cution, m√™me si aucun processus de travail ne lui est associ√©.  Voici donc le fichier <code>/etc/systemd/system/savekey.service</code> .  Il est n√©cessaire de ne laisser qu'une des variantes donn√©es de la directive <code>ExecStop</code> . </p><br><pre> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p>  La construction avec <code>/bin/sh</code> n√©cessaire car <code>dd</code> ne comprend pas la notation hexad√©cimale. </p><br><p>  Nous activons le service, v√©rifions: </p><br><pre> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p>  Lors du red√©marrage suivant, vous n'avez pas besoin de saisir la phrase secr√®te √† partir du disque.  Et si n√©cessaire, cela signifie g√©n√©ralement que l'adresse de d√©but de la zone de m√©moire r√©serv√©e n'est pas s√©lectionn√©e correctement.  Vous pouvez corriger et r√©g√©n√©rer plusieurs fichiers et red√©marrer l'ordinateur deux fois. </p><br><p>  Lorsque vous utilisez <code>phram</code> ou <code>nd_e820</code> seule la configuration GRUB devra √™tre modifi√©e.  Lorsque vous utilisez <code>/dev/mem</code> adresse de d√©part est √©galement mentionn√©e dans <code>/etc/crypttab</code> (par cons√©quent, initramfs devra √™tre r√©g√©n√©r√©) et dans le service systemd. </p><br><p>  Mais ce n'est pas tout. </p><br><h3 id="voprosy-bezopasnosti">  Probl√®mes de s√©curit√© </h3><br><p>  Toute discussion sur les probl√®mes de s√©curit√© est bas√©e sur un mod√®le de menace.  C'est-√†-dire  sur les buts et les moyens de l'attaquant.  Je suis conscient que certains des exemples ci-dessous sont farfelus. </p><br><p>  Les situations avec un acc√®s physique √† un ordinateur √©teint ne sont pas diff√©rentes de celles sans stockage de cl√© configur√© en m√©moire.  Il existe les m√™mes types d'attaques visant √† obtenir des phrases cl√©s, y compris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Evil Maid</a> , et les m√™mes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctionnalit√©s de s√©curit√©</a> .  Nous ne nous arr√™tons pas √† eux, car il n'y a rien de nouveau. </p><br><p>  Les situations les plus int√©ressantes sont lorsque l'ordinateur est allum√©. </p><br><p>  <strong>Situation 1</strong> .  L'attaquant n'a pas d'acc√®s physique √† l'ordinateur, ne conna√Æt pas la phrase secr√®te, mais dispose d'un acc√®s root via ssh.  L'objectif est la cl√© pour d√©chiffrer le disque.  Par exemple, pour acc√©der aux anciennes sauvegardes secteur par secteur d'une image disque de machine virtuelle. </p><br><p>  En fait, la cl√© de la soucoupe se trouve dans le fichier <code>/root/key</code> .  La question est de savoir comment cela se rapporte √† ce qui s'est pass√© avant la mise en ≈ìuvre de cette instruction.  R√©ponse: pour luks1, la menace n'est pas nouvelle.  Il existe une commande <code>dmsetup table --target crypt --showkeys</code> qui affiche la cl√© principale, c'est-√†-dire  √©galement des donn√©es qui permettent d'acc√©der aux anciennes sauvegardes.  Pour luks2, la r√©duction de s√©curit√© dans ce sc√©nario a vraiment lieu: les cl√©s dm-crypt sont stock√©es dans le trousseau au niveau du noyau, et il est impossible de les regarder depuis l'espace utilisateur. </p><br><p>  <strong>Situation 2</strong> .  L'attaquant peut utiliser le clavier et regarder l'√©cran, mais n'est pas pr√™t √† ouvrir le bo√Ætier.  Par exemple, j'ai utilis√© le mot de passe divulgu√© d'IPMI ou intercept√© une session noVNC dans le cloud.  Il ne conna√Æt pas la phrase cl√©, il ne conna√Æt pas d'autre mot de passe non plus.  L'objectif est l'acc√®s root. </p><br><p>  Veuillez red√©marrer via <code>Ctrl-Alt-Del</code> , l'ajout de l'option de noyau <code>init=/bin/sh</code> via GRUB est fait.  La phrase secr√®te n'√©tait pas n√©cessaire, car la cl√© a √©t√© lue avec succ√®s dans la m√©moire.  Pour vous prot√©ger de cela, vous devez emp√™cher GRUB de charger ce qui n'est pas dans le menu.  Malheureusement, cette fonctionnalit√© est impl√©ment√©e diff√©remment dans diff√©rentes distributions. </p><br><p>  √Ä partir de la version 7.2, CentOS a la <code>grub2-setpassword</code> , qui prot√®ge r√©ellement GRUB avec un mot de passe.  D'autres distributions peuvent avoir leurs propres utilitaires pour la m√™me t√¢che.  Si ce n'est pas le cas, vous pouvez directement modifier les fichiers dans le r√©pertoire <code>grub.cfg</code> et r√©g√©n√©rer <code>grub.cfg</code> . </p><br><p>  Dans le fichier <code>/etc/grub.d/10_linux</code> , changez la variable CLASS, ajoutez l'option <code>--unrestricted</code> √† la fin, si elle n'√©tait pas l√†: </p><br><pre> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p>  Dans le fichier <code>/etc/grub.d/40_custom</code> , ajoutez les lignes sp√©cifiant le nom d'utilisateur et le mot de passe n√©cessaires pour modifier la ligne de commande du noyau: </p><br><pre> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p>  Ou, si une telle fonctionnalit√© doit √™tre d√©sactiv√©e, voici une ligne comme celle-ci: </p><br><pre> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p>  <strong>Situation 3</strong> .  L'attaquant a acc√®s √† l'ordinateur inclus, vous permettant de d√©marrer √† partir d'un m√©dia non fiable.  Il peut s'agir d'un acc√®s physique sans ouvrir le bo√Ætier ou d'un acc√®s via IPMI.  L'objectif est l'acc√®s root. </p><br><p>  Il peut charger son GRUB √† partir d'un lecteur flash USB ou d'un CD-ROM et ajouter <code>init=/bin/sh</code> √† vos param√®tres de noyau, comme dans l'exemple pr√©c√©dent.  En cons√©quence, le d√©marrage √† partir de tout support horrible doit √™tre interdit dans le BIOS.  Et prot√©gez √©galement les changements de param√®tres du BIOS avec un mot de passe. </p><br><p>  <strong>Situation 4</strong> .  L'attaquant a un acc√®s physique √† l'ordinateur inclus, y compris la possibilit√© d'ouvrir le bo√Ætier.  Le but est de trouver la cl√© ou d'obtenir un acc√®s root. </p><br><p>  En g√©n√©ral, c'est de toute fa√ßon une situation perdante.  L'attaque des modules de m√©moire en les refroidissant ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attaque de d√©marrage √† froid</a> ) n'a pas √©t√© annul√©e.  √âgalement th√©oriquement (ne pas cocher), vous pouvez profiter du fait que les disques SATA modernes prennent en charge la reconnexion √† chaud.  Lorsque l'ordinateur red√©marre, d√©connectez le disque, modifiez <code>grub.cfg</code> pour <code>init=/bin/sh</code> , reconnectez-vous, laissez le syst√®me red√©marrer.  Il s'av√®re (si je comprends bien) l'acc√®s root. </p><br><p>  √Ä peu pr√®s la m√™me chose peut √™tre faite par un employ√© peu scrupuleux d'un h√©bergement cloud en cr√©ant un instantan√© d'une machine virtuelle avec sa modification ult√©rieure. </p><br><h3 id="prochie-voprosy">  AUTRES QUESTIONS </h3><br><p>  <strong>Garder la cl√© en m√©moire lors d'un red√©marrage est une moquerie.</strong>  <strong>Utilisation apr√®s lib√©ration dans sa forme la plus pure.</strong>  <strong>Une solution plus propre consiste √† utiliser kexec et √† ajouter la cl√© aux initramfs g√©n√©r√©s dynamiquement.</strong>  <strong>Il prot√®ge √©galement contre le remplacement des param√®tres du noyau</strong> .  Oui, si kexec fonctionne.  Les distributions modernes ont rendu la configuration de kexec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trop compliqu√©e</a> . </p><br><p>  <strong>Dans les centres de donn√©es, et plus encore dans le cloud, l'alimentation ne dispara√Æt jamais.</strong>  <strong>Il s'av√®re que la phrase cl√© n'est plus n√©cessaire?</strong>  En effet, <em>si</em> vous en √™tes si s√ªr, vous pouvez le supprimer.  Il se r√©v√©lera √™tre un serveur qui fonctionne, la cl√© du disque dont personne ne sait¬π et ne sera donc pas distribu√©e, mais le syst√®me sur lequel il peut √™tre mis √† jour r√©guli√®rement.    ‚Äî        <code>sudo poweroff</code> . </p><br><p> ¬π    <code>/root/key</code> ‚Äî         ,        cron. </p><br><p> <strong>   ?  IPMI,       </strong> .    IPMI      Java.        . </p><br><p> <strong>   ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> SSH</a></strong> . !    .  ,      <code>sudo reboot</code> ,      ? </p><br><p>             ,         .     SSH       ,      .       ,      ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457396/">https://habr.com/ru/post/fr457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457380/index.html">OpenGL ultramoderne. 2e partie</a></li>
<li><a href="../fr457382/index.html">7 habitudes des programmeurs performants</a></li>
<li><a href="../fr457386/index.html">Pr√©sentation des interfaces virtuelles Linux: tunnels</a></li>
<li><a href="../fr457390/index.html">Madagascar - √Æle des contrastes</a></li>
<li><a href="../fr457392/index.html">√âconomies sur le d√©veloppement multiplateforme mobile: √©tude de cas Skyeng</a></li>
<li><a href="../fr457398/index.html">Mais je fais des conneries? Pourquoi les d√©veloppeurs se tournent vers gemba</a></li>
<li><a href="../fr457400/index.html">Le nombre de victimes de catastrophes nucl√©aires comme Tchernobyl est consid√©rablement exag√©r√© pour le drame</a></li>
<li><a href="../fr457402/index.html">Comment organiser le d√©veloppement et le support d'un blog sur WordPress au 2T19 et ne pas le corriger</a></li>
<li><a href="../fr457404/index.html">Nouvelles du monde OpenStreetMap n ¬∞ 465 (06/11/2019 - 06/16/2019)</a></li>
<li><a href="../fr457406/index.html">Combien gagnent les dipl√¥m√©s de diverses universit√©s russes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>