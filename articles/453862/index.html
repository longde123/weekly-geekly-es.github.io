<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåé üîñ ü•ó Por qu√© deber√≠as usar pathlib üíÉüèø üîõ ‚ôíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Del traductor: ¬°Hola, Habr! Te presento la traducci√≥n del art√≠culo Por qu√© deber√≠as usar pathlib y su continuaci√≥n. No, realmente, pathlib es genial ....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por qu√© deber√≠as usar pathlib</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453862/"><p>  <em>Del traductor: ¬°Hola, Habr!</em>  <em>Te presento la traducci√≥n del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Por qu√© deber√≠as usar pathlib</a> y su continuaci√≥n. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No, realmente, pathlib es genial</a> .</em>  <em>Ahora se est√° prestando mucha atenci√≥n a nuevas caracter√≠sticas de Python como asyncio, el operador = = y la escritura opcional.</em>  <em>Al mismo tiempo, el riesgo de un radar no es tan significativo (aunque :: llame a una innovaci√≥n seria que un idioma no resulta ser una innovaci√≥n seria), sino innovaciones muy √∫tiles en un idioma.</em>  <em>En particular, en un habr de art√≠culos dedicados a un tema, no encontr√© (a excepci√≥n de un p√°rrafo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ), por lo tanto, decid√≠ corregir la situaci√≥n.</em> </p><br><p> Cuando descubr√≠ el entonces nuevo m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pathlib</a> hace unos a√±os, decid√≠ desde el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fondo de</a> mi mente que era solo una versi√≥n un poco inc√≥moda orientada a objetos del m√≥dulo <code>os.path</code> .  Estaba equivocado  <code>pathlib</code> es realmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">maravilloso</a> ! </p><br><p>  En este art√≠culo intentar√© enamorarme de <code>pathlib</code> .  Espero que este art√≠culo te <strong><code>pathlib</code></strong> a <strong>usar <code>pathlib</code> en cualquier situaci√≥n relacionada con el trabajo con archivos en Python</strong> . </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>os.path</code> inc√≥modo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>os</code> sobrecargado</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>   glob</code></a> </li> <li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>pathlib</code> hace que las cosas simples sean a√∫n m√°s f√°ciles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los objetos de ruta hacen que su c√≥digo sea m√°s obvio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>    pathlib</code> ?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>    pathlib</code> ?</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Respuestas a las preguntas.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code> os.path</code> y <code>pathlib</code> para ser honesto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No tiene que preocuparse por normalizar los caminos.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code> ,     ,    pathlib</code> !</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬°Pero mi biblioteca favorita tiene Path mejor que el est√°ndar!</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>  pathlib.Path</code> y <code>str</code> no se mezclan, ¬øverdad?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>pathlib</code> demasiado lento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mejora de legibilidad</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>   pathlib.Path</code></a> </li> </ul></li></ul><br><h2 id="chast-1">  Parte 1 </h2><br><h3 id="ospath-neuklyuzh">  <code>os.path</code> inc√≥modo </h3><br><p>  El m√≥dulo <code>os.path</code> siempre <code>os.path</code> sido lo que usamos cuando se trataba de rutas de Python.  En principio, hay todo lo que necesita, pero a menudo no se ve muy elegante. </p><br><p>  ¬øDebo importarlo as√≠? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) TEMPLATES_DIR = os.path.join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  O asi? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Tal vez la funci√≥n de <code>join</code> tiene un nombre demasiado general, y deber√≠amos hacer algo como esto: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> joinpath BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = joinpath(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Para m√≠, todas las opciones anteriores no parecen demasiado convenientes.  Pasamos cadenas a funciones que devuelven cadenas que pasamos a las siguientes funciones que funcionan con cadenas.  Dio la casualidad de que todos contienen caminos, pero siguen siendo solo l√≠neas. </p><br><p>  El uso de cadenas para entrada y salida en funciones <code>os.path</code> muy inconveniente porque tiene que leer el c√≥digo de adentro hacia afuera.  Me gustar√≠a convertir estas llamadas de anidadas a secuenciales.  ¬°Esto es lo que <code>pathlib</code> te permite hacer! </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path BASE_DIR = Path(__file__).resolve().parent.parent TEMPLATES_DIR = BASE_DIR.joinpath(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  El m√≥dulo <code>os.path</code> requiere llamadas a funciones anidadas, pero <code>pathlib</code> <strong>nos permite crear cadenas de llamadas consecutivas a m√©todos y atributos de la clase <code>Path</code></strong> con un resultado equivalente. </p><br><p>  S√© lo que piensas: detente, estos objetos de <code>Path</code> no son los mismos que antes, ¬°ya no operamos en l√≠neas de ruta!  Volveremos a este tema m√°s tarde (pista: en casi cualquier situaci√≥n, estos dos enfoques son intercambiables). </p><br><h3 id="os-peregruzhen">  <code>os</code> sobrecargado </h3><br><p>  El cl√°sico m√≥dulo <code>os.path</code> dise√±ado para trabajar con rutas.  Pero despu√©s de que desee <em>hacer algo</em> con la ruta (por ejemplo, crear un directorio), deber√° acceder a otro m√≥dulo, a menudo <code>os</code> . </p><br><p>  <code>os</code> contiene un mont√≥n de utilidades para trabajar con archivos y directorios: <code>mkdir</code> , <code>getcwd</code> , <code>chmod</code> , <code>stat</code> , <code>remove</code> , <code>rename</code> , <code>rmdir</code> .  Tambi√©n <code>chdir</code> , <code>link</code> , <code>walk</code> , <code>listdir</code> , <code>makedirs</code> , <code>renames</code> , <code>removedirs</code> , <code>unlink</code> , <code>symlink</code> .  Y un mont√≥n de cosas que no est√°n relacionadas con los sistemas de archivos: <code>fork</code> , <code>getenv</code> , <code>putenv</code> , <code>getlogin</code> , <code>getlogin</code> , <code>system</code> , ... Algunas docenas de cosas m√°s que no mencionar√© aqu√≠. </p><br><p>  <strong>El m√≥dulo <code>os</code> est√° dise√±ado para una amplia gama de tareas;</strong>  <strong>Este es un cuadro con todo lo relacionado con el sistema operativo.</strong>  Hay muchas utilidades en el sistema <code>os</code> , pero no siempre es f√°cil de navegar: a menudo es necesario profundizar un poco en el m√≥dulo antes de encontrar lo que necesita. </p><br><p>  <code>pathlib</code> transfiere la mayor√≠a de las funciones del sistema de archivos a objetos <code>Path</code> . </p><br><p>  Aqu√≠ est√° el c√≥digo que crea el <code>src/__pypackages__</code> y cambia el nombre de nuestro archivo <code>.editorconfig</code> a <code>src/.editorconfig</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><p>  Aqu√≠ hay un c√≥digo similar usando <code>Path</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Tenga en cuenta que el segundo ejemplo de c√≥digo es mucho m√°s f√°cil de leer, porque est√° organizado de izquierda a derecha; todo esto es gracias a las cadenas de m√©todos. </p><br><h3 id="ne-zabyvayte-pro-glob">  No te olvides de <code>glob</code> </h3><br><p>  No solo <code>os</code> y <code>os.path</code> contienen m√©todos relacionados con el sistema de archivos.  Tambi√©n vale la pena mencionar sobre <code>glob</code> , que no se puede llamar in√∫til. </p><br><p>  Podemos usar la funci√≥n <code>glob.glob</code> para buscar archivos por un patr√≥n espec√≠fico: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob top_level_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'**/*.csv'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  El m√≥dulo <code>pathlib</code> tambi√©n proporciona m√©todos similares: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path top_level_csv_files = Path.cwd().glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>)</code> </pre> <br><p>  Despu√©s de cambiar al m√≥dulo <code>pathlib</code> , la <strong>necesidad del <code>glob</code> desaparece por completo</strong> : todo lo que necesita ya es una parte integral de los objetos <code>Path</code> </p><br><h3 id="pathlib-delaet-prostye-veschi-esche-prosche">  <code>pathlib</code> hace que las cosas simples sean a√∫n m√°s f√°ciles </h3><br><p>  <code>pathlib</code> simplifica muchas situaciones dif√≠ciles, pero tambi√©n <strong>hace que algunos fragmentos de c√≥digo sean a√∫n m√°s f√°ciles</strong> . </p><br><p>  ¬øQuieres leer todo el texto en uno o m√°s archivos? </p><br><p>  Puede abrir el archivo, leer el contenido y cerrar el archivo con el bloque <code>with</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob file_contents = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> glob(<span class="hljs-string"><span class="hljs-string">'**/*.py'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> python_file: file_contents.append(python_file.read())</code> </pre> <br><p>  O puede usar el m√©todo <code>read_text</code> en objetos <code>Path</code> y generar listas para obtener el mismo resultado en una expresi√≥n: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path file_contents = [ path.read_text() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.py'</span></span>) ]</code> </pre> <br><p>  Pero, ¬øqu√© pasa si necesita escribir en un archivo? </p><br><p>  Esto es lo que parece usar <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  O puede usar el m√©todo <code>write_text</code> : </p><br><pre> <code class="python hljs">Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).write_text(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Si por alguna raz√≥n necesita usar <code>open</code> , ya sea como administrador de contexto o para preferencias personales, <code>Path</code> ofrece el m√©todo <code>open</code> como alternativa: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> path.open(mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  O, comenzando con Python 3.6, puede pasar su <code>Path</code> directamente para <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><h3 id="obekty-path-delayut-vash-kod-ochevidnee">  Los objetos de ruta hacen que su c√≥digo sea m√°s obvio </h3><br><p>  ¬øQu√© indican las siguientes variables?  ¬øCu√°l es el significado de sus significados? </p><br><pre> <code class="python hljs">person = <span class="hljs-string"><span class="hljs-string">'{"name": "Trey Hunner", "location": "San Diego"}'</span></span> pycon_2019 = <span class="hljs-string"><span class="hljs-string">"2019-05-01"</span></span> home_directory = <span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span></code> </pre> <br><p>  Cada variable apunta a una l√≠nea.  Pero cada uno de ellos tiene diferentes significados: el primero es JSON, el segundo es la fecha y el tercero es la ruta del archivo. </p><br><p>  Esta representaci√≥n de objetos es un poco m√°s √∫til: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path person = {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Trey Hunner"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Diego"</span></span>} pycon_2019 = date(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) home_directory = Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)</code> </pre> <br><p>  Los objetos JSON se pueden deserializar en un diccionario, las fechas se pueden representar de forma nativa usando <code>datetime.date</code> y <strong>los objetos de ruta de archivo se pueden representar como <code>Path</code></strong> </p><br><p>  El uso de objetos <code>Path</code> hace que su c√≥digo sea m√°s expl√≠cito.  Si desea trabajar con fechas, use <code>date</code> .  Si desea trabajar con rutas de archivos, use <code>Path</code> . </p><br><p>  No soy un gran defensor de OOP.  Las clases agregan una capa adicional de abstracci√≥n, y las abstracciones a veces tienden a complicar el sistema en lugar de simplificarlo.  Al mismo tiempo, creo que <code>pathlib.Path</code> es una <strong>abstracci√≥n √∫til</strong> .  Bastante r√°pido, se convierte en una decisi√≥n aceptada. </p><br><p>  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PEP 519</a> , las <code>Path</code> convierten en est√°ndar para trabajar con rutas.  En el momento de Python 3.6, la mayor√≠a de los <code>os.path</code> <code>os</code> , <code>shutil</code> , <code>os.path</code> funcionan correctamente con estos objetos.  <strong>¬°Puede cambiar a <code>pathlib</code> , transparente para su base de c√≥digo!</strong> </p><br><h3 id="chego-ne-hvataet-v-pathlib">  ¬øQu√© falta en <code>pathlib</code> ? </h3><br><p>  Aunque <code>pathlib</code> genial, no es exhaustivo.  Definitivamente hay <strong>varias posibilidades que me gustar√≠a incluir en el m√≥dulo</strong> . </p><br><p>  Lo primero que viene a la mente es la falta de m√©todos de ruta equivalentes a <code>shutil</code> .  Aunque puede pasar <code>Path</code> como par√°metros <code>shutil</code> para copiar / eliminar / mover archivos y directorios, no puede llamarlos como m√©todos en objetos <code>Path</code> . </p><br><p>  Entonces, para copiar archivos, debe hacer algo como esto: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copyfile source = Path(<span class="hljs-string"><span class="hljs-string">'old_file.txt'</span></span>) destination = Path(<span class="hljs-string"><span class="hljs-string">'new_file.txt'</span></span>) copyfile(source, destination)</code> </pre> <br><p>  Tampoco existe un an√°logo del m√©todo <code>os.chdir</code> .  Esto significa que debe importarlo si necesita cambiar el directorio actual: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir parent = Path(<span class="hljs-string"><span class="hljs-string">'..'</span></span>) chdir(parent)</code> </pre> <br><p>  Tampoco hay equivalente a la funci√≥n <code>os.walk</code> .  Aunque puedes escribir tu propia funci√≥n en el esp√≠ritu de una <code>walk</code> sin mucha dificultad. </p><br><p>  Espero que alg√∫n d√≠a los objetos <code>pathlib.Path</code> contengan m√©todos para algunas de las operaciones mencionadas.  Pero incluso en este escenario, <strong>me resulta mucho m√°s f√°cil usar <code>pathlib</code> con algo m√°s que usar <code>os.path</code> y todo lo dem√°s</strong> . </p><br><h3 id="vsegda-li-nuzhno-ispolzovat-pathlib">  ¬øEs siempre necesario usar <code>pathlib</code> ? </h3><br><p>  Comenzando con Python 3.6, las <strong>Rutas funcionan en casi todas partes donde usas cadenas</strong> .  Por lo tanto, no veo ninguna raz√≥n <em>para no</em> usar <code>pathlib</code> si est√° utilizando Python 3.6 y superior. </p><br><p>  Si est√° utilizando una versi√≥n anterior de Python 3, en cualquier momento puede ajustar el objeto <code>Path</code> en una llamada de <code>str</code> para obtener una cadena si necesita regresar al pa√≠s de l√≠neas.  Esto no es demasiado elegante, pero funciona: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path chdir(Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   Python 3.6+ chdir(str(Path('/home/trey'))) #     </span></span></code> </pre> <br><h2 id="chast-2-otvety-na-voprosy">  Parte 2. Respuestas a las preguntas. </h2><br><p>  Despu√©s de que se public√≥ la primera parte, algunas personas tuvieron algunas preguntas.  Alguien dijo que <code>pathlib</code> <code>os.path</code> y <code>pathlib</code> deshonestamente.  Algunos dijeron que el uso de <code>os.path</code> tan arraigado en la comunidad de Python que cambiar a una nueva biblioteca llevar√° mucho tiempo.  Tambi√©n vi algunas preguntas sobre el rendimiento. </p><br><p>  En esta parte, me gustar√≠a comentar sobre estos temas.  Esto puede considerarse tanto <code>pathlib</code> protecci√≥n de <code>pathlib</code> como una peque√±a carta de amor a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PEP 519</a> . </p><br><h3 id="sravnenie-ospath-i-pathlib-po-chestnomu">  Compare <code>os.path</code> y <code>pathlib</code> para ser honesto </h3><br><p>  En la √∫ltima parte, compar√© los siguientes dos fragmentos de c√≥digo: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Esto puede parecer una comparaci√≥n injusta, porque el uso de <code>os.path.join</code> en el primer ejemplo garantiza que se usen los delimitadores correctos en todas las plataformas, lo que no hice en el segundo ejemplo.  De hecho, todo est√° en orden, porque <strong>Path normaliza autom√°ticamente los separadores de ruta</strong> </p><br><p>  Podemos probar esto al convertir el objeto <code>Path</code> en una cadena en Windows: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src\\__pypackages__'</span></span></code> </pre> <br><p>  No <code>joinpath</code> si usamos el m√©todo <code>joinpath</code> , el <code>'/'</code> en la l√≠nea de ruta, el operador <code>/</code> (otra buena caracter√≠stica de <code>Path</code> ) o si pasamos argumentos individuales al constructor de Path, obtenemos el mismo resultado: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>) / <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span> WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>).joinpath(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  El √∫ltimo ejemplo caus√≥ cierta confusi√≥n por parte de las personas que sugirieron que <code>pathlib</code> no <code>pathlib</code> lo suficientemente inteligente como para reemplazar <code>/</code> con <code>\</code> en la cadena de ruta.  Afortunadamente, ¬°todo est√° en orden! </p><br><p>  Con los objetos de <code>Path</code> , ya no necesita preocuparse por la direcci√≥n de las barras: defina todas sus rutas usando <code>/</code> , y el resultado ser√° predecible para cualquier plataforma. </p><br><h3 id="vy-ne-dolzhny-bespokoitsya-o-normalizacii-putey">  No tiene que preocuparse por normalizar los caminos. </h3><br><p>  Si est√° ejecutando en Linux o Mac, es muy f√°cil agregar accidentalmente errores al c√≥digo que afectan solo a los usuarios de Windows.  Si no supervisa de cerca el uso de <code>os.path.join</code> y \ u <code>os.path.normcase</code> para convertir barras inclinadas a las adecuadas para la plataforma actual, <strong>puede escribir c√≥digo que no funcione correctamente en Windows</strong> . </p><br><p>  Aqu√≠ hay un ejemplo de un error espec√≠fico de Windows: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Adem√°s, dicho c√≥digo funcionar√° correctamente en todas partes: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = Path(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Anteriormente, el programador era responsable de concatenar y normalizar rutas, al igual que en Python 2, el programador era responsable de decidir d√≥nde usar unicode en lugar de bytes.  Esta ya no es tu tarea: <code>Path</code> resuelve todos esos problemas por ti. </p><br><p>  No uso Windows, y no tengo una computadora con Windows.  Pero es muy probable que muchas personas que usar√°n mi c√≥digo usen Windows, y quiero que todo funcione correctamente para ellos. </p><br><p>  <strong>Si existe la posibilidad de que su c√≥digo se ejecute en Windows, deber√≠a considerar seriamente cambiar a <code>pathlib</code> .</strong> </p><br><p>  <strong>No se preocupe por la normalizaci√≥n</strong> : use <code>Path</code> todos modos cuando se trata de rutas de archivos. </p><br><h3 id="zvuchit-klassno-no-u-menya-storonnyaya-biblioteka-kotoraya-ne-ispolzuet-pathlib">  Suena genial, ¬°pero tengo una biblioteca de terceros que no usa <code>pathlib</code> ! </h3><br><p>  Tiene una base de c√≥digo grande que funciona con cadenas como rutas.  ¬øPor qu√© cambiar a <code>pathlib</code> si eso significa que todo debe reescribirse? </p><br><p>  Imaginemos que tiene la siguiente funci√≥n: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  La funci√≥n toma un directorio y crea un archivo <code>.editorconfig</code> , algo como esto: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path &gt;&gt;&gt; make_editorconfig(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Si reemplaza las l√≠neas con <code>Path</code> , todo funcionar√° tambi√©n: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Pero ... como? </p><br><p>  <code>os.path.join</code> acepta objetos <code>Path</code> (desde Python 3.6).  Lo mismo puede decirse de <code>os.makedirs</code> . <br>  De hecho, la funci√≥n <code>open</code> incorporada acepta <code>Path</code> , <code>shutil</code> acepta <code>Path</code> y todo en la biblioteca est√°ndar utilizada para aceptar cadenas ahora deber√≠a funcionar tanto con <code>Path</code> como con cadenas. </p><br><p>  Deber√≠amos agradecer a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PEP 519 por esto</a> , que proporcion√≥ la clase abstracta <code>os.PathLike</code> y anunci√≥ que todas las utilidades integradas para trabajar con rutas de archivos ahora deber√≠an funcionar tanto con cadenas como con <code>Path</code> . </p><br><h3 id="no-v-moey-lyubimoy-biblioteke-est-path-luchshe-standartnogo">  ¬°Pero mi biblioteca favorita tiene Path, mejor que el est√°ndar! </h3><br><p>  Es posible que ya est√© utilizando una biblioteca de terceros que proporciona su implementaci√≥n <code>Path</code> , que es diferente de la est√°ndar.  Quiz√°s te guste m√°s. </p><br><p>  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">django-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">environmental</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">path.py</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plumbum</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">visidata</a> contienen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cada uno</a> sus propios objetos <code>Path</code> .  Algunas de estas bibliotecas son m√°s antiguas que <code>pathlib</code> y decidieron heredar de <code>str</code> para poder <code>pathlib</code> a funciones que esperan cadenas como rutas.  Gracias a PEP 519, la integraci√≥n de bibliotecas de terceros en su c√≥digo ser√° m√°s f√°cil y sin la necesidad de herencia de <code>str</code> . </p><br><p>  Imaginemos que no desea utilizar <code>pathlib</code> , porque <code>Path</code> son objetos inmutables y realmente desea cambiar su estado.  Con PEP 519, puede crear su mejor versi√≥n mutable de <code>Path</code> .  Para hacer esto, simplemente implemente el m√©todo <code>__fspath__</code> </p><br><p>  Cualquier implementaci√≥n <code>Path</code> de <code>Path</code> ahora puede funcionar de forma nativa con funciones integradas de Python que esperan rutas de archivos.  <strong>Incluso si no le gusta <code>pathlib</code> , el hecho de su existencia es una gran ventaja para las bibliotecas de terceros con su propia <code>Path</code></strong> </p><br><h3 id="no-ved-pathlibpath-i-str-ne-smeshivayutsya-pravda">  Pero <code>pathlib.Path</code> y <code>str</code> no se mezclan, ¬øverdad? </h3><br><p>  Probablemente piense: esto es todo, por supuesto, genial, pero ¬øeste enfoque con a veces l√≠nea y a veces ruta agregar√° cierta complejidad a mi c√≥digo? </p><br><p>  La respuesta a esta pregunta es s√≠, hasta cierto punto.  Pero este problema tiene una soluci√≥n bastante simple. </p><br><p>  PEP 519 agreg√≥ algunas cosas m√°s adem√°s de <code>PathLike</code> : en primer lugar, es una forma de convertir cualquier <code>PathLike</code> en una cadena y, en segundo lugar, es una forma de convertir cualquier <code>PathLike</code> en una <code>Path</code> . </p><br><p>  Tomemos dos objetos: una cadena y <code>Path</code> (o lo que sea con el m√©todo <strong>fspath</strong> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path p1 = os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>) p2 = Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  La funci√≥n <code>os.fspath</code> normaliza ambos objetos y los convierte en cadenas: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fspath &gt;&gt;&gt; fspath(p1), fspath(p2) (<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>, <span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  En este caso, <code>Path</code> puede tomar ambos objetos en un constructor y convertirlos a <code>Path</code> : </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(p1), Path(p2) (PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>), PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))</code> </pre> <br><p>  Esto significa que puede convertir el resultado de <code>make_editorconfig</code> a <code>Path</code> si es necesario: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; Path(make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))) PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span>)</code> </pre> <br><p>  Aunque, por supuesto, la mejor soluci√≥n ser√≠a reescribir <code>make_editorconfig</code> usando <code>pathlib</code> . </p><br><h3 id="pathlib-slishkom-medlennyy">  <code>pathlib</code> demasiado lento </h3><br><p>  He visto varias veces sobre el rendimiento de <code>pathlib</code> .  Es cierto: <code>pathlib</code> puede ser lento.  Crear miles de objetos <code>Path</code> puede afectar significativamente el comportamiento del programa. </p><br><p>  Decid√≠ medir el rendimiento de <code>pathlib</code> y <code>os.path</code> en mi computadora usando dos programas diferentes que buscan todos los archivos <code>.py</code> en el directorio actual </p><br><p>  Aqu√≠ est√° la versi√≥n de <code>os.walk</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename.endswith(extension): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Y aqu√≠ est√° la versi√≥n con <code>Path.rglob</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">f'*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{extension}</span></span></span><span class="hljs-string">'</span></span>): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Probar el rendimiento de los programas que funcionan con el sistema de archivos es una tarea dif√≠cil, porque el tiempo de funcionamiento puede cambiar bastante.  Decid√≠ ejecutar cada script 10 veces y compar√© los mejores resultados para cada programa. </p><br><p>  Ambos programas encontraron archivos 97507 en el directorio en el que los ejecut√©.  El primero funcion√≥ en 1.914 segundos, el segundo termin√≥ en 3.430 segundos. </p><br><p>  Cuando configuro el par√°metro <code>extension=''</code> , estos programas encuentran aproximadamente 600,000 archivos, y la diferencia aumenta.  El primer programa funcion√≥ en 1.888 segundos, y el segundo en 7.485 segundos. </p><br><p>  Por lo tanto, <code>pathlib</code> es aproximadamente el <strong>doble de</strong> lento para los archivos con la extensi√≥n <code>.py</code> , y <strong>cuatro veces m√°s lento</strong> cuando se inicia en mi directorio de inicio.  La brecha relativa de rendimiento entre <code>pathlib</code> y <code>os</code> es amplia. </p><br><p>  En mi caso, esta velocidad no cambia mucho.  Busqu√© todos los archivos en mi directorio y perd√≠ 6 segundos.  Si tuviera la tarea de procesar 10 millones de archivos, probablemente lo reescribir√≠a.  Pero si bien no existe tal necesidad, puede esperar. </p><br><p>  Si tiene un c√≥digo caliente y <code>pathlib</code> obviamente afecta negativamente su funcionamiento, no hay nada de malo en reemplazarlo por una alternativa.  <strong>No debe optimizar el c√≥digo, que no es un cuello de botella</strong> , esto es una p√©rdida de tiempo adicional, que generalmente tambi√©n conduce a un c√≥digo poco legible, sin mucho agotamiento. </p><br><h3 id="uluchshenie-chitaemosti">  Mejora de legibilidad </h3><br><p>  Me gustar√≠a terminar esta corriente de pensamientos con algunos ejemplos de refactorizaci√≥n utilizando <code>pathlib</code> .  Tom√© un par de peque√±os ejemplos de c√≥digo que funciona con archivos y los hice funcionar con <code>pathlib</code> .  Dejar√© la mayor parte del c√≥digo sin comentarios en su corte; decida qu√© versi√≥n le gusta m√°s. </p><br><p>  Aqu√≠ est√° la funci√≥n <code>make_editorconfig</code> que vimos anteriormente: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  Y aqu√≠ est√° la versi√≥n reescrita en <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filepath."""</span></span> path = Path(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.exists(): path.parent.mkdir(exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, parent=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) path.touch() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br><p>  Aqu√≠ hay un programa de consola que toma una l√≠nea con un directorio e imprime el contenido de un archivo <code>.gitignore</code> , si existe: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] ignore_filename = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(ignore_filename): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(ignore_filename, mode=<span class="hljs-string"><span class="hljs-string">'rt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ignore_file: print(ignore_file.read(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Lo mismo con <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = Path(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ignore_path = directory / <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ignore_path.is_file(): print(ignore_path.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Aqu√≠ hay un programa que imprime todos los archivos duplicados en la carpeta y subcarpetas actuales: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(filepath): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.path.join(root, filename) file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> my_file: file_hash = md5(my_file.read()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre> <br><p>  Lo mismo con c <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path(filepath).rglob(<span class="hljs-string"><span class="hljs-string">'*'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.is_file(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> path file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(Path.cwd()): file_hash = md5(path.read_bytes()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br><p>  , , -,     .       <code>pathlib</code> . </p><br><h3 id="nachnite-ispolzovat-obekty-pathlibpath">    <code>pathlib.Path</code> </h3><br><p>  . </p><br><p>  <code>/</code>   <code>pathlib.Path</code>         .   ,    <strong>      </strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>path1 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>, <span class="hljs-string"><span class="hljs-string">'file'</span></span>) &gt;&gt;&gt; path2 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>) / <span class="hljs-string"><span class="hljs-string">'file'</span></span> &gt;&gt;&gt; path3 = Path(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path3 WindowsPath(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path1 == path2 == path3 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>   Python  (. <code>open</code> )   <code>Path</code> ,  ,  <strong>   <code>pathlib</code> ,        !</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> move <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rename_and_redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_filename, new_filename)</span></span></span><span class="hljs-function">:</span></span> move(old, new) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(old, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(<span class="hljs-string"><span class="hljs-string">f'This file has moved to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; old, new = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>), Path(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>) &gt;&gt;&gt; rename_and_redirect(old, new) &gt;&gt;&gt; old.read_text() <span class="hljs-string"><span class="hljs-string">'This file has moved to new.txt'</span></span></code> </pre> <br><p>      <code>pathlib</code> ,     ,    <code>PathLike</code> .  ,   <strong>      ,       ,   PEP 519</strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; my_path = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(my_path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: ... print(f.read()) ... This file has moved to new.txt</code> </pre> <br><p>   <code>pathlib</code>    ,      (  ,    ),    <strong>         ,   </strong> . </p><br><p>  , <code>pathlib</code>     .       Python     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path gitignore = Path(<span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gitignore.is_file(): print(gitignore.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>pathlib</code> ‚Äî .    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453862/">https://habr.com/ru/post/453862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453846/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI para junio de 2019</a></li>
<li><a href="../453848/index.html">AlphaFold: uso de IA para descubrimientos cient√≠ficos</a></li>
<li><a href="../453850/index.html">Sistema de cr√©dito social chino: ¬øes tan terrible el diablo?</a></li>
<li><a href="../453852/index.html">Microbiota Como cuidar las bacterias intestinales</a></li>
<li><a href="../453860/index.html">AMD present√≥ sus nuevos procesadores personalizados de 7 nm Ryzen de tercera generaci√≥n</a></li>
<li><a href="../453864/index.html">¬øUsar un mouse y un teclado en las consolas es hacer trampa?</a></li>
<li><a href="../453866/index.html">Solicitud API con React Hooks, HOC o Render Prop</a></li>
<li><a href="../453868/index.html">Mini interruptor t√°ctil con panel de vidrio en nRF52832</a></li>
<li><a href="../453870/index.html">Escribimos Reverse socks5 proxy en powershell. Parte 1</a></li>
<li><a href="../453872/index.html">Restaurar fotos usando redes neuronales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>