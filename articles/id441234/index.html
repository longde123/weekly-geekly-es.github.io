<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍⚕️ 🏕️ 🚚 Efek penyaringan SVG. Bagian 6. Membuat tekstur dengan feTurbulence 👩‍💻 ↩️ 👨🏽‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pelajari cara menggunakan filter feTurbulence SVG yang kuat, primitif untuk membuat tekstur dan efek distorsi sendiri. 





 Rangkaian artikel yang d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Efek penyaringan SVG. Bagian 6. Membuat tekstur dengan feTurbulence</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441234/"><p>  Pelajari cara menggunakan filter <strong>feTurbulence</strong> SVG yang kuat, <strong>primitif</strong> untuk membuat tekstur dan efek distorsi sendiri. </p><br><p><img src="https://habrastorage.org/webt/eq/sn/t8/eqsnt8noyajxh4ljl8xf8l1j8vw.png"></p><br><p>  Rangkaian artikel yang diusulkan, " <strong>Efek Penyaringan SVG,</strong> " oleh Sara Soueidan, pengembang antarmuka UI / UX lepas dan penulis banyak artikel teknis yang berbasis di Lebanon, berfokus pada karya filter SVG dan terdiri dari artikel berikut: </p><br><h1 id="effekty-filtracii-svg">  Efek Penyaringan SVG </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1. Filter SVG 101</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Garis besar teks dengan <strong>feMorphology</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3. Efek <strong>posterisasi gambar</strong> menggunakan <strong>feComponentTransfer</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4. Gambar dua warna dengan <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek penyaringan SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5. Mencocokkan teks dengan tekstur permukaan dengan <strong>feDisplacementMap</strong></a> </li><li>  Efek penyaringan SVG.  Bagian 6. Membuat tekstur dengan feTurbulence </li></ol><br><hr><a name="habracut"></a><br><p>  <strong>feTurbulence</strong> adalah salah satu primitif filter SVG paling kuat.  Spesifikasi mendefinisikan primitif ini sebagai berikut: </p><br><blockquote>  Filter primitif ini menciptakan gambar menggunakan fungsi turbulensi Perlin.  Ini memungkinkan sintesis tekstur buatan seperti awan atau marmer.  [...] <br>  Gambar yang dihasilkan akan mengisi seluruh subregion dari filter primitive untuk filter primitive ini. </blockquote><p>  Dengan kata lain, filter <strong>feTurbulence primitive</strong> menghasilkan dan menampilkan noise Perlin.  Jenis kebisingan ini berguna untuk mensimulasikan beberapa fenomena alam, seperti awan, api dan asap, dan menghasilkan tekstur kompleks seperti marmer atau granit.  Dan seperti <strong>feFlood</strong> , primitif <strong>feTurbulence</strong> mengisi area penyaringan dengan konten baru. </p><br><p>  Pada artikel ini, kita akan melihat bagaimana Anda dapat membuat noise menggunakan <strong>feTurbulence</strong> dan bagaimana noise ini dapat digunakan untuk mengubah gambar dan teks, seperti yang kami lakukan dengan tekstur <strong>feDisplacementMap</strong> pada artikel sebelumnya.  Kemudian kita melihat bagaimana noise yang dihasilkan dapat digunakan dalam kombinasi dengan efek pencahayaan SVG untuk menciptakan tekstur sederhana untuk kertas kasar. </p><br><p>  Tetapi pertama-tama, mari kita tinjau <strong>feTurbulence</strong> dan atribut-atributnya dan lihat bagaimana masing-masing dari mereka memengaruhi kebisingan yang dihasilkan. </p><br><h2 id="sozdanie-turbulentnosti-i-fraktalnogo-shuma-pri-pomoschi-feturbulence">  Menciptakan turbulensi dan fraktal noise dengan feTurbulence </h2><br><p>  Ketika saya berniat untuk menulis seri ini, saya memutuskan untuk menghindari sebanyak mungkin detail teknis kasar tentang filter primitif.  Inilah sebabnya kami tidak akan membahas detail teknis dari fungsi yang digunakan untuk menghasilkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>suara Perlin</strong></a> . </p><br><p>  Setelah membaca tentang fungsi yang mendasari generasi kebisingan, saya menemukan bahwa itu tidak membantu saya sama sekali ketika saya membuat primitif untuk percobaan.  Pada akhirnya, kami bekerja dengan generator derau acak.  Dengan demikian, dalam kebanyakan kasus, Anda akan menemukan bahwa membuat tekstur akan menjadi topik untuk eksperimen dan penyetelan sampai Anda mendapatkan hasil yang diinginkan.  Seiring waktu, akan menjadi sedikit lebih mudah untuk memprediksi bagaimana suatu tekstur akan terlihat. </p><br><p>  Saya menemukan bahwa bermain dengan <strong>feTurbulence</strong> primitif dan memvisualisasikan atributnya adalah cara terbaik untuk mengetahuinya dan membantu saya memahami apa yang dilakukan masing-masing atribut ini.  Jadi, kami menggunakan pendekatan visual untuk memahami <strong>feTurbulence</strong> dengan beberapa demo interaktif. </p><br><p>  <strong>FeTurbulence</strong> sekarang menghasilkan kebisingan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>fungsi turbulensi Perlin</strong></a> .  Ini memiliki 5 atribut utama yang mengontrol fungsi dan, karenanya, hasil visualnya: </p><br><ul><li>  <strong>jenis</strong> ; </li><li>  <strong>frekuensi dasar</strong> ; </li><li>  <strong>numOtak</strong> ; </li><li>  <strong>biji</strong> ; </li><li>  <strong>jahitan</strong> . </li></ul><br><p>  Kami akan memeriksa bagaimana masing-masing atribut ini mempengaruhi hasil visual tanpa masuk ke rincian teknis fungsi.  Anda akan menemukan bahwa dalam kebanyakan kasus Anda hanya perlu khawatir tentang tiga atribut ini: <strong>type</strong> , <strong>baseFrequency</strong> dan <strong>numOctave</strong> . </p><br><h3 id="basefrequency">  basisFrequency </h3><br><p>  Untuk menghasilkan noise, hanya atribut <strong>baseFrequency</strong> yang <strong>diperlukan</strong> .  <strong>baseFrequency</strong> mempengaruhi ukuran (atau skala) dan graininess dari noise yang dihasilkan. </p><br><p>  Efek frekuensi dasar paling baik dipahami ketika divisualisasikan dan dianimasikan.  Inilah sebabnya saya membuat demo berikutnya.  Dengan menggunakan penggeser, Anda dapat mengubah nilai frekuensi dasar yang digunakan dan melihat bagaimana pengaruhnya terhadap kebisingan yang dihasilkan secara real time.  Anda akan melihat bahwa ketika Anda menambah atau mengurangi nilai atribut <strong>baseFrequency,</strong> pola yang dihasilkan <strong>tetap solid, menjadi lebih kecil atau lebih besar,</strong> masing-masing, dan <strong>terlihat seperti diskalakan dan keluar dari sumber di sudut kiri atas</strong> . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/oJKObg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Menurunkan nilai <strong>baseFrequency</strong> , seperti 0,001, menghasilkan pola besar, sementara meningkatkan nilai, 0,5+, membuat pola yang lebih kecil.  Nilai mulai dari 0 (tanpa frekuensi == tanpa pola) dan lebih tinggi.  Nilai negatif tidak diperbolehkan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Seperti yang dicatat Michael Mullani</strong></a> , "Nilai mulai dari 0,02 hingga 0,2 adalah titik awal yang berguna untuk sebagian besar tekstur." </p><br><p>  Harap dicatat bahwa noise yang dihasilkan tidak memiliki warna latar belakang.  Ini berarti bahwa jika Anda menghapus warna latar belakang putih pada SVG, Anda dapat melihat latar belakang tubuh gelap melalui noise. </p><br><p>  Atribut <strong>baseFrequency</strong> juga mengambil dua nilai.  Jika Anda menentukan dua nilai, yang pertama akan digunakan untuk frekuensi dasar di sepanjang sumbu X, dan yang kedua akan sesuai dengan sumbu Y. Dengan memberikan dua nilai yang berbeda, Anda dapat menghasilkan noise vertikal atau horizontal, yang dapat digunakan untuk menerapkan beberapa efek fantastis, seperti yang akan kita lihat di bagian selanjutnya. </p><br><p>  <strong>Bermain-main</strong> dengan nilai-nilai <strong>baseFrequency</strong> dalam demo ini lagi dan perhatikan bagaimana itu berubah sepanjang sumbu X dan Y jika Anda memberikan nilai yang berbeda.  Demo dimulai dengan noise horizontal yang bagus.  Nilai <strong>x-baseFrequency</strong> dari 0,01 relatif kecil, yang membuat pola horizontal besar (saat ditarik).  Jika Anda mengurangi lebih jauh, misalnya, ke 0,001, Anda akan melihat bahwa pola horizontal akan menjadi lebih seperti garis.  Cobalah. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/yZBBzN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="type">  jenis </h3><br><p>  Seperti namanya, atribut <strong>type</strong> digunakan untuk menunjukkan tipe noise yang dihasilkan oleh <strong>feTurbulence</strong> primitive.  Ada dua jenis: </p><br><ul><li>  <strong>turbulensi</strong> , yang merupakan standar; </li><li>  <strong>fractalNoise</strong> . </li></ul><br><p>  <strong>fractalNoise</strong> menciptakan <strong>pola yang</strong> lebih kabur dan halus, ini adalah dasar yang baik untuk membuat tekstur gas seperti awan.  <strong>turbulensi</strong> menghasilkan lebih banyak garis yang mensimulasikan riak, dan karenanya cocok sebagai dasar untuk tekstur fluida. </p><br><p><img src="https://habrastorage.org/webt/qy/zw/3g/qyzw3gv0j-yz9g1q5ymzhuc7skm.png" alt="Bunyi turbulensi di sebelah kiri dan fraktal di sebelah kanan"><br>  Fig_1.  Kebisingan seperti turbulensi di sebelah kiri dan fraktal di sebelah kanan. </p><br><p>  Ubah nilai atribut <strong>type</strong> dalam demo berikut untuk melihat bagaimana perubahan pola yang dibuat: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/GzKeeg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="numoctaves">  numOtak </h3><br><p>  <strong>numOctave</strong> disingkat sebagai "angka oktaf" yang mewakili tingkat detail kebisingan. </p><br><p>  Dalam musik, satu oktaf adalah perbedaan nada antara dua not ketika satu memiliki frekuensi dua kali lipat dari yang lainnya.  Jadi, semakin tinggi oktafnya, semakin tinggi frekuensinya.  Dalam <strong>feTurbulence</strong> , semakin besar jumlah oktaf, semakin banyak detail yang dapat Anda lihat dalam kebisingan yang dihasilkannya.  Secara default, noise yang dihasilkan adalah satu oktaf, yang berarti bahwa nilai default untuk atribut <strong>numOctaves</strong> adalah 1. </p><br><p>  Seret penggeser di demo berikut untuk melihat efek peningkatan jumlah oktaf pada tekstur yang dihasilkan: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/YdmmBV" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Anda akan melihat bahwa mulai dengan <strong>numOctaves</strong> = "5" efek menambahkan oktaf menjadi hampir tidak terlihat. </p><br><h3 id="seed">  biji </h3><br><p>  Butir, sebagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>didefinisikan dalam spesifikasi</strong></a> , adalah "angka awal untuk generator angka acak semu".  Dengan kata lain, ia menyediakan seed yang berbeda untuk fungsi acak yang digunakan untuk menghasilkan noise acak kita. </p><br><p>  Secara visual, Anda akan melihat bahwa ini memengaruhi di mana dan bagaimana "garis riak" dihasilkan.  Ini juga lebih baik dipahami ketika Anda melihat bagaimana ini mempengaruhi kebisingan yang dihasilkan dalam dua persegi panjang yang berdekatan. </p><br><p>  Ketika nilai awal yang sama digunakan untuk dua persegi panjang yang berdekatan, fungsi yang digunakan untuk membuat kebisingan melalui dua persegi panjang adalah kontinu, dan ini akan tercermin secara visual oleh kontinuitas "garis riak" di sepanjang tepi dua persegi panjang ini. </p><br><p><img src="https://habrastorage.org/webt/f4/ns/yz/f4nsyz3yza-bxpo5gynia5vl188.png" alt="Kontinuitas fungsi yang menghasilkan noise acak dapat dilihat di tepi dua persegi panjang menggunakan nilai awal yang sama"><br>  Fig_2.  Kontinuitas fungsi yang menghasilkan noise acak dapat dilihat di tepi dua persegi panjang menggunakan nilai awal yang sama. </p><br><p>  Bermain-main dengan nilai atribut <strong>seed</strong> di demo berikutnya, lihat bagaimana hal itu memengaruhi noise yang dihasilkan, dan perhatikan bahwa noise tersebut kontinu di sepanjang tepi dua persegi panjang menggunakan nilai awal yang sama. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/XovQEv" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="stitchtiles">  jahitan </h3><br><p>  <strong>stitchTiles</strong> dapat digunakan untuk membuat efek jahitan di antara “ubin” kebisingan.  Efek dari atribut ini sangat mirip dengan efek dari biji, yang berarti bahwa itu paling jelas ketika Anda memiliki dua area yang berdekatan (atau "ubin") dari kebisingan. </p><br><p>  Seperti yang disebutkan dalam spesifikasi, kadang-kadang hasil bangkitan kebisingan akan menunjukkan jeda yang jelas di batas ubin.  Anda dapat memberi tahu browser untuk mencoba meratakan hasilnya sehingga kedua ubin terlihat "dijahit" bersama-sama. Saya sangat suka bahwa atribut dan efeknya dibandingkan dengan menjahit. </p><br><p>  Secara default, tidak ada upaya yang dilakukan untuk mencapai transisi yang mulus di perbatasan sheet yang berisi fungsi turbulensi, karena nilai default untuk <strong>stitchTiles</strong> adalah <strong>noStitch</strong> .  Jika Anda ingin membuat efek jahitan, Anda dapat mengubah nilai untuk <strong>menjahit</strong> . </p><br><p>  Untuk membandingkan hasil <strong>stitchTiles</strong> dengan hasil <strong>seed</strong> , saya menerapkan nilai <strong>seed yang</strong> sama ke noise yang dihasilkan di dua persegi panjang di demo berikutnya.  Anda sudah dapat melihat bahwa suara itu tampaknya terus menerus di antara mereka.  Ganti opsi <strong>stitchTiles</strong> ke " <strong>on</strong> ", ubah nilainya ke <strong>stitch</strong> untuk melihat bagaimana noise mengubah penempatannya di tepinya. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/VqoOwz" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Seperti yang saya sebutkan sebelumnya, hanya ada tiga atribut, Anda kemungkinan besar akan menggunakan <strong>tipe</strong> , <strong>baseFrequency</strong> dan <strong>numOctave</strong> .  Jadi kita akan fokus pada ketiganya, bergerak maju. </p><br><h2 id="ispolzuem-shum-feturbulence-dlya-iskazheniya-kontenta">  Menggunakan noise feTurbulence untuk mendistorsi konten </h2><br><p>  Di sini kesenangan dimulai.  Dan bagaimana kita mulai menggunakan noise yang dihasilkan.  Memang, mengisi area penyaringan dengan noise tidak berguna. </p><br><p>  Dalam artikel sebelumnya, kami menggunakan <strong>feDisplacementMap</strong> untuk membawa sepotong teks sesuai dengan tekstur gambar eksternal.  Dan kami menyebutkan bahwa <strong>feDisplacementMap</strong> menggunakan informasi warna dari satu gambar untuk mendistorsi yang lain.  Gambar yang digunakan sebagai peta perpindahan bisa berupa apa saja.  Ini berarti bahwa itu bisa berupa gambar eksternal atau gambar yang dihasilkan dalam SVG, misalnya, gambar gradien atau pola ... baik, atau tekstur noise. </p><br><p>  Dengan kata lain, noise yang kami hasilkan dengan <strong>feTurbulence</strong> juga dapat digunakan untuk mendistorsi konten jika diterapkan bersama dengan <strong>feDisplacementMap</strong> .  Dalam contoh berikut, kami menggunakan jalan keluar dari <strong>feTurbulence</strong> untuk mengimbangi gambar bersama dengan <strong>feDisplacementMap</strong> .  Saya menggunakan model derau horizontal dengan memberikan dua nilai berbeda untuk atribut <strong>baseFrequency</strong> , mirip dengan yang kami lakukan sebelumnya. </p><br><pre><code class="plaintext hljs">&lt;svg viewBox="0 0 180 100"&gt; &lt;filter id="noise" x="0%" y="0%" width="100%" height="100%"&gt; &lt;feTurbulence baseFrequency="0.01 0.4" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="20" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#noise)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/VgZZqB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Intensitas turbulensi yang mendistorsi gambar ditunjukkan dalam atribut <strong>penjualan</strong> pada <strong>feDisplacementMap</strong> .  Saya menggunakan sangat penting untuk membuat efeknya terlihat lebih dramatis. </p><br><p>  Sekarang, berdasarkan aplikasi sederhana ini, kita dapat membuka lebih banyak kemungkinan untuk menggabungkan fakta-fakta ini: </p><br><ul><li>  Filter SVG juga dapat diterapkan pada konten HTML; </li><li>  Nilai <strong>baseFrequency</strong> adalah angka dan dengan demikian dapat dianimasikan .. </li></ul><br><p>  Kurang dari dua tahun yang lalu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Adrien Denat</strong></a> menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>artikel yang benar</strong></a> di mana ia bereksperimen dengan efek serupa yang diterapkan pada tombol HTML.  Kami akan memecah dan menciptakan kembali efek klik tombol berikut: </p><br><p><img src="https://habrastorage.org/webt/zc/j1/1u/zcj11uzosfkidw_nhs51icwucn0.gif"></p><br><p>  Kami akan mulai dengan membuat tekstur noise.  Ini adalah keadaan di mana tombol terdistorsi, dan kemudian, segera setelah kami mendapatkannya, kami akan menghidupkan keadaan awal tombol ke keadaan terdistorsi ini dan kembali dengan mengklik. </p><br><p>  Tujuan kami di sini adalah untuk mendistorsi tombol secara horizontal.  Yaitu  kami akan menggunakan dan menyesuaikan noise horizontal dari demo sebelumnya.  Efek distorsi pada gambar bahkan terlalu kuat, jadi untuk permulaan saya akan memutar kode dengan mengubah nilai turbulensi dari (0,01 0,4) menjadi (0 0,2): </p><br><pre> <code class="plaintext hljs">&lt;filter id='noise' x='0%' y='0%' width='100%' height='100%'&gt; &lt;feTurbulence type="turbulence" baseFrequency="0 0.2" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="30" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt;</code> </pre> <br><p>  Efeknya menjadi sedikit lebih baik, tetapi tombolnya masih terdistorsi lebih dari yang kita inginkan: </p><br><p><img src="https://habrastorage.org/webt/zc/3k/ef/zc3kefcfi1uifcdsaqskvyh8rya.png"></p><br><p>  Kami ingin distorsi menjadi kurang dramatis.  Ingatlah bahwa kita dapat langsung mengurangi efek derau dengan mengalihkan jenis derau dari turbulensi default ke <strong>fractalNoise yang</strong> lebih halus.  Begitu kita melakukan ini, kita akan melihat bahwa efek distorsi juga akan dihaluskan: </p><br><p><img src="https://habrastorage.org/webt/od/7-/3u/od7-3ubszs7r5_axgrbdzx1lixi.png"></p><br><p>  Terlihat jauh lebih baik. </p><br><p>  Sekarang kita memiliki efek distorsi yang kita senangi, kita akan memulai demo kita dengan filter yang awalnya hampir tidak menghasilkan apa-apa: </p><br><pre> <code class="plaintext hljs">&lt;filter id='noise' x='0%' y='0%' width='100%' height='100%'&gt; &lt;feTurbulence type="fractalNoise" baseFrequency="0 0.000001" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="30" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt;</code> </pre> <br><p>  Kami akan menerapkan filter ini ke tombol kami di CSS: </p><br><pre> <code class="plaintext hljs">button { -webkit-filter: url(#noise); filter: url(#noise); }</code> </pre> <br><p>  Pada titik ini, tombol masih tidak tampak terdistorsi. </p><br><p>  Selanjutnya, kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>kode Adrien</strong></a> , meskipun versi yang sedikit dimodifikasi yang menggunakan GSAP untuk menghidupkan nilai atribut <strong>baseFrequency</strong> ke (0 0,2) dan sebaliknya di dalam <strong>feTurbulence</strong> primitive dengan mengklik: </p><br><pre> <code class="plaintext hljs">var bt = document.querySelectorAll('.button')[0], turbVal = { val: 0.000001 }, turb = document.querySelectorAll('#noise feTurbulence')[0], btTl = new TimelineLite({ paused: true, onUpdate: function() { turb.setAttribute('baseFrequency', '0 ' + turbVal.val); } }); btTl.to(turbVal, 0.2, { val: 0.2 }) .to(turbVal, 0.2, { val: 0.000001 }); bt.addEventListener('click', function() { btTl.restart(); });</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Dan itu sebenarnya yang dibutuhkan.</strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Anda dapat bermain dengan demo di sini</strong></a> : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/rPBmOa" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Pada saat penulisan ini, demo berfungsi di Chrome dan Firefox.  Ini adalah bug di versi Safari saat ini, tetapi masalah akan teratasi di versi berikutnya, karena Safari Tech Preview menunjukkan demo berfungsi dengan baik. </p><br><p>  Meskipun ini tidak berfungsi di MS Edge, tombolnya tidak terdistorsi sama sekali, yang berarti bahwa kurangnya dukungan tidak mempengaruhi kemampuan untuk menggunakannya.  Ini bagus karena <strong>Anda masih bisa menggunakan efek ini sebagai perangkat tambahan</strong> .  Jika efeknya tidak didukung, maka tombol akan terlihat dan berperilaku seperti tombol biasa tanpa efek. </p><br><p>  Artikel Adrian mencakup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>beberapa efek distorsi tombol lagi</strong></a> yang menggunakan prinsip yang sama seperti yang baru saja kita lihat dan yang pasti patut dicoba.  Ada satu atau dua trik bagus yang perlu dipelajari setiap orang. </p><br><h2 id="volnistyy-tekst-s-ispolzovaniem-feturbulence">  Teks bergelombang menggunakan feTurbulence </h2><br><p>  Salah satu kegunaan favorit saya dari <strong>feTurbulence</strong> adalah efek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>teks bergelombang</strong></a> dari Lucas Beber.  Dalam demo-nya, Lucas menggunakan beberapa fungsi <strong>feTurbulence</strong> : </p><br><pre> <code class="plaintext hljs">&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt; &lt;defs&gt; &lt;filter id="squiggly-0"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="0" /&gt; &lt;feDisplacementMap id="displacement" in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-1"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="1" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="8" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-2"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-3"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="3" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="8" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-4"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="4" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;/svg&gt;</code> </pre> <br><p>  ... dan menerapkannya melalui CSS ke sepotong teks HTML menggunakan animasi CSS, menjiwai dari satu ke yang lain: </p><br><pre> <code class="plaintext hljs">@keyframes squiggly-anim { 0% { -webkit-filter: url("#squiggly-0"); filter: url("#squiggly-0"); } 25% { -webkit-filter: url("#squiggly-1"); filter: url("#squiggly-1"); } 50% { -webkit-filter: url("#squiggly-2"); filter: url("#squiggly-2"); } 75% { -webkit-filter: url("#squiggly-3"); filter: url("#squiggly-3"); } 100% { -webkit-filter: url("#squiggly-4"); filter: url("#squiggly-4"); } }</code> </pre> <br><p>  ... sehingga menciptakan efek bergelombang. </p><br><p>  Sekali lagi, teks yang digunakan adalah nyata, yaitu  ini tersedia untuk pencarian, pemilihan, akses dan pengeditan (menggunakan atribut <strong>contenteditable</strong> ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Lihat demo langsung</strong></a> , tetapi hati-hati, karena  Demo ini intensif sumber daya dan Anda mungkin tidak perlu membuka Codepen di ponsel Anda. </p><br><p><img src="https://habrastorage.org/webt/zu/24/_o/zu24_ohstp_gwe4srzy80dxv8ig.gif"></p><br><p>  Jadi, beberapa kesimpulan yang berguna dari bagian ini: </p><br><ul><li>  Noise yang dihasilkan oleh <strong>feTurbulence</strong> dapat digunakan untuk mengubah konten SVG dan HTML. </li><li>  Nilai <strong>baseFrequency</strong> dapat dianimasikan. </li><li>  Anda dapat memutar jumlah distorsi ke bawah dengan menyesuaikan nilai-nilai dalam <strong>baseFrequency</strong> dan merapikan suara dengan tipe <strong>fractalNoise</strong> . </li><li>  Meskipun Anda dapat menghidupkan filter SVG secara umum, umumnya disarankan untuk tidak berlebihan, karena mereka bisa menjadi sumber daya yang cukup intensif.  Usahakan animasi terbatas pada area kecil;  semakin besar area animasi, semakin banyak sumber daya yang akan dikonsumsi. </li></ul><br><p>  <strong>Primurensi</strong> primitif sangat jarang, jika pernah, digunakan sendiri.  Itu hampir selalu digunakan oleh filter primitif lainnya untuk mencapai efek individu. </p><br><p>  Di bagian ini, kami menggunakannya sebagai peta perpindahan di <strong>feDisplacementMap</strong> .  Mari kita lihat apa lagi yang bisa Anda lakukan dengannya. </p><br><h2 id="imitaciya-prirodnoy-tekstury-pri-pomoschi-feturbulence">  Imitasi tekstur alami dengan feTurbulence </h2><br><p>  Cara lain yang bermanfaat untuk menggunakan noise yang dihasilkan oleh <strong>feTurbulence</strong> adalah mensimulasikan tekstur alami.  Jika Anda pernah menggunakan Noise Generation Plugins di <strong>After Effects</strong> , Anda mungkin sudah menemukan fungsionalitas dan contoh ini. </p><br><p><img src="https://habrastorage.org/webt/iy/cd/-k/iycd-kxtpu0ac7be_d6ooscwlmk.png"><br>  Fig_7.  Contoh tekstur yang dibuat di After Effects menggunakan plugin <strong>Fractal Noise</strong> .  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> ) </p><br><p>  <strong>feTurbulence</strong> menghasilkan noise (nilai acak) untuk masing-masing komponen R, G, B dan A. Anda dapat mengubah nilai dari masing-masing komponen ini untuk mendapatkan variasi kebisingan yang berbeda.  Untuk mensimulasikan tekstur, kita biasanya perlu melakukan hal itu: sesuaikan komponen R / G / B / A (membatalkan komponen, menjenuhkan orang lain, dll.).) Untuk mendapatkan hasil yang diinginkan.  Dalam kasus lain, yang perlu kita lakukan adalah memberi sedikit penjelasan tentang ini.  Secara harfiah. </p><br><p>  Pada bagian ini, kita akan melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>efek tekstur kertas kasar yang</strong></a> dibuat oleh Michael Mullany.  Untuk menciptakan tekstur ini, kita perlu menerangi tekstur suara yang dihasilkan oleh <strong>feTurbulence</strong> menggunakan sumber pencahayaan SVG. </p><br><h3 id="istochniki-sveta-v-svg">  Sumber cahaya di SVG </h3><br><p>  SVG dengan mudah menyediakan beberapa primitif yang dapat Anda gunakan untuk menerangi objek atau gambar. </p><br><p>  Ada dua filter primitif yang digunakan untuk menunjukkan jenis cahaya yang Anda inginkan: </p><br><ul><li>  <strong>feDiffuseLighting</strong> , yang menunjukkan cahaya tidak langsung dari sumber eksternal, dan paling baik digunakan untuk efek sinar matahari; </li><li>  <strong>feSpecularLighting</strong> , mendefinisikan cahaya sekunder yang kembali dari permukaan reflektif. </li></ul><br><p>  Kedua primitif menerangi objek atau gambar menggunakan saluran alpha dari gambar ini sebagai peta medan.  Nilai transparan tetap datar, sementara nilai buram naik untuk membentuk puncak yang diterangi lebih nyata. </p><br><p>  Dengan kata lain, filter sumber cahaya menggunakan saluran alfa input untuk mendapatkan informasi kedalaman: area dengan opacity lebih besar naik ke pengamat, dan area dengan opacity lebih sedikit menjauh darinya.  Ini berarti bahwa nilai alfa piksel dalam input digunakan sebagai ketinggian piksel dalam dimensi z, dan filter menggunakan ketinggian ini untuk menghitung permukaan virtual yang akan memantulkan sejumlah cahaya tertentu dari sumber cahaya.  Ini adalah hal yang sangat kuat! </p><br><p>  Kedua jenis cahaya menerima atribut yang disebut <strong>surfaceScale</strong> , yang praktis merupakan faktor indeks-z.  Ketika nilai ini meningkat, "kemiringan" tekstur permukaan menjadi lebih curam. </p><br><blockquote>  “Karena <strong>feTurbulence</strong> menghasilkan saluran alpha yang penuh dengan nilai noise dari 0 hingga 1, itu membentuk variabel Z-surface yang bagus yang menciptakan silau ketika kita menyinarinya.”  —Michael Mullany </blockquote><p>  Setelah menentukan jenis cahaya, Anda harus memilih sumber cahaya.  Ada <strong>tiga jenis sumber cahaya</strong> di SVG: </p><br><ul><li>  <strong>feDistantLight</strong> : adalah sumber cahaya jarak jauh yang sejauh yang diinginkan, dan karenanya ditentukan dari sudut kemiringannya dari target.  Ini adalah cara yang paling cocok untuk mewakili sinar matahari. </li><li>  <strong>fePointLight</strong> : mewakili cahaya titik yang berasal dari titik tertentu, direpresentasikan sebagai koordinat X / Y / Z tiga dimensi.  Itu terlihat seperti sumber cahaya di dalam ruangan atau di dalam pemandangan. </li><li>  <strong>feSpotLight</strong> : adalah lampu sorot yang berperilaku seperti titik cahaya, tetapi sorotnya dapat dipersempit menjadi kerucut, dan cahaya dapat beralih ke target lain. </li></ul><br><p>  Masing-masing dari ketiga sumber cahaya ini memiliki atributnya sendiri, yang digunakan untuk mengatur cahaya yang dihasilkannya dengan menunjukkan lokasi sumber dalam ruang 3D.  Atribut berada di luar cakupan artikel ini, tetapi Anda dapat mempelajari lebih lanjut tentang mereka dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>spesifikasi ini</strong></a> . </p><br><p>  Untuk membuat dan menerapkan efek pencahayaan, Anda harus memasang sumber cahaya ke jenis pencahayaan.  Jadi, Anda mulai dengan memilih jenis pencahayaan yang Anda inginkan, dan kemudian pilih sumber dari mana itu akan datang.  Dan akhirnya, Anda perlu menentukan warna pencahayaan Anda.  Properti <strong>warna-pencahayaan</strong> digunakan untuk menentukan warna sumber cahaya untuk <strong>feDiffuseLighting</strong> dan <strong>feSpecularLighting</strong> . </p><br><p>  Setelah mempertimbangkan dasar-dasar sumber pencahayaan, kita sekarang beralih ke contoh kita. </p><br><p>  Untuk tekstur kertas kasar, kita akan menggunakan sinar matahari.  Ini berarti bahwa kita akan menggunakan cahaya putih yang berasal dari sumber yang jauh.  Diterjemahkan ke dalam kode, cahaya kami terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">&lt;feDiffuseLighting lighting-color="white" surfaceScale="2" in=".." result=".."&gt; &lt;feDistantLight azimuth="45" elevation="60" /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Atribut <strong>azimuth</strong> dan <strong>elevasi</strong> menentukan posisi sumber cahaya dalam ruang tiga dimensi.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>sebuah artikel oleh Rafael Pons</strong></a> yang sangat luar biasa dalam menjelaskan kedua konsep ini dengan cara yang sederhana, mudah dipahami, bersama dengan ilustrasi yang indah dan nyaman yang membantu dengan penjelasan.  Saya sangat merekomendasikan melihatnya. </p><br><p>  Sekarang setelah kita memiliki cahaya, kita perlu membuat suara kita untuk menerangi dengan cahaya ini.  Kami akan memecah demo menjadi beberapa tahap untuk mencari tahu bagaimana itu dibuat. </p><br><p>  Kita perlu memulai suatu tempat, dan kita akan mulai dengan menghasilkan suara acak, dasar sebagai dasar dari tekstur kita: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence baseFrequency='0.04' result='noise' /&gt;</code> </pre> <br><p>  Suara kami terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/x3/s1/nc/x3s1nczn8xxc_3nndnn0dnzp474.png"></p><br><p>  Lalu kami menjelaskan padanya, dan kemudian mengambilnya dari sana: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence baseFrequency='0.04' result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Pencahayaan terang dari kebisingan kami memberi kami tekstur berikut: </p><br><p><img src="https://habrastorage.org/webt/wn/tv/ax/wntvaxtgh5kv1s3k4e8ouexcyzm.png"></p><br><p>  Ini bukan hasil dari tekstur yang kami cari.  Hal pertama yang kami perhatikan di sini adalah adanya banyak garis tajam pada tekstur.  Kami ingin menyingkirkan mereka karena tidak ada garis tajam di permukaan kertas.  Kita perlu menghaluskan garis-garis ini.  Ini bisa dilakukan dengan mengubah tipe noise yang dihasilkan menjadi <strong>fractalNoise</strong> : </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence type="fractalNoise" baseFrequency='0.04' result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Ini menghilangkan semua tepi tajam yang selaras dari tekstur kami: </p><br><p><img src="https://habrastorage.org/webt/x0/ql/iy/x0qliy7petifqf1j6j3t0uiwkpg.png"></p><br><p>  Sekarang kita selangkah lebih dekat dengan tekstur kertas kasar kita. </p><br><p>  Namun, tekstur di atas tidak cukup kasar.  Dia tidak memiliki "kekasaran" yang diperlukan.  Peningkatan jumlah bagian kecil di dalamnya harus membuatnya lebih kasar.  Untuk melakukan ini, kami akan meningkatkan nilai <strong>numOctave</strong> .  Kami menemukan bahwa sekitar 5 adalah angka yang bagus untuk mendapatkan tingkat kekasaran yang diinginkan: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence type="fractalNoise" baseFrequency='0.04' numOctaves="5" result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Dan tekstur kertas kami sekarang terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/2l/us/_c/2lus_co5ckpwdne52rnmqochozq.png"></p><br><p>  Hebat! </p><br><p>  Anda dapat bermain dengan demo di sini: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/SaraSoueidan/embed/preview/oppeJM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Demo ini berfungsi di semua browser utama, termasuk MS Edge. </p><br><p>  Jika mau, Anda dapat menyesuaikan efeknya sedikit lebih jauh, bermain dengan sumber dan jarak cahaya.  Sebagai contoh, mengurangi <strong>ketinggian</strong> sumber cahaya dari 60 menjadi 40 harus meningkatkan kontras antara bukit-bukit kecil di tekstur.  Maka teksturnya akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/nt/kh/o-/ntkho-s-ilzh9lzzwchmrtvqktm.png"></p><br><p>  Saya sangat merekomendasikan bermain-main dengan nilai atribut sumber cahaya dan noise dan melihat bagaimana mereka mempengaruhi tekstur yang dihasilkan. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Primitif <strong>feTurbulence</strong> adalah salah satu operasi SVG yang paling menarik dan kuat.  Dalam kombinasi dengan primitif dan animasi lainnya, ia mampu menciptakan efek, tekstur, dan interaksi yang sangat menarik dan menarik. </p><br><p>  Saya berasumsi <strong>feTurbulence</strong> adalah salah satu filter yang ingin Anda coba atau parsing kode orang lain untuk mempelajarinya dengan lebih baik.  Namun, saya pikir saya menebak bagaimana tekstur akan terlihat setelah beberapa saat.  Dan karena kita dapat melakukan begitu banyak hanya dengan satu tekstur, jika Anda menggunakannya dengan primitif lain, ada efek yang hampir tak terhitung jumlahnya yang dapat Anda buat dengannya.  Saya sangat menyarankan Anda melihat pekerjaan orang lain dan membedahnya untuk belajar lebih baik. </p><br><p>  Yoksel sedang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>bereksperimen dengan filter SVG</strong></a> Codepen setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>saya berbicara tentang filter SVG</strong></a> beberapa bulan lalu.  Jadi, Anda dapat menemukan beberapa efek untuk diuraikan dan dipelajari di profil Codepen-nya. </p><br><p><img src="https://habrastorage.org/webt/ou/d2/yi/oud2yi8fduvtdb8exyqibtbos0w.gif" alt="Salah satu percobaan terbaru Yoksel dengan filter SVG menggunakan ** feTurbulence **"><br>  Fig_13.  Salah satu percobaan terbaru Yoksel dengan filter SVG menggunakan <strong>feTurbulence</strong> . </p><br><p>  Saya harap artikel ini menginspirasi Anda dan membuka pintu baru untuk imajinasi Anda sehingga Anda dapat melihat apa yang dapat Anda lakukan dengan filter SVG. </p><br><p>  Pada artikel terakhir dalam seri ini, saya akan membagikan beberapa sumber daya dan alat tambahan untuk membantu Anda bergerak maju dengan filter SVG dan mulai membangun sendiri.  Tetap bersama kami. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441234/">https://habr.com/ru/post/id441234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441218/index.html">OpenAI Gym + ROS + Gazebo: melatih robot mandiri di rumah. Bagian 1</a></li>
<li><a href="../id441220/index.html">Analisis serangan massal terbaru dengan penangkapan DNS</a></li>
<li><a href="../id441222/index.html">Mengapa Kubernet begitu rumit dengan repositori?</a></li>
<li><a href="../id441224/index.html">Buat contoh Augmented Faces ARCore di Unity</a></li>
<li><a href="../id441226/index.html">Forbes menerbitkan daftar perusahaan Internet Rusia paling mahal di tahun 2019</a></li>
<li><a href="../id441236/index.html">Habraiting 2018: bahan terbaik untuk 2018</a></li>
<li><a href="../id441238/index.html">Memprogram Bahasa Inggris</a></li>
<li><a href="../id441240/index.html">Apakah mereka kehilangan bukti fisika baru di Large Hadron Collider?</a></li>
<li><a href="../id441242/index.html">Communication Network Monitoring Center: negara baru “pembela” Runet</a></li>
<li><a href="../id441244/index.html">Kerentanan WinRar, tidak tertutup selama 19 tahun, memungkinkan Anda untuk menempatkan file yang sudah dibongkar di mana saja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>