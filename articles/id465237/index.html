<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜€ ğŸ§œğŸ» ğŸ•µğŸ» Polygonal Mesh ke B-Rep Konversi Padat: Detail Algoritma dan Sampel Kode C ++ ğŸ”¼ ğŸ¨ ğŸ¤œğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Representasi batas (B-rep) adalah metode utama untuk mewakili objek yang dimodelkan di sebagian besar kernel geometris, termasuk kernel C3D Modeler ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Polygonal Mesh ke B-Rep Konversi Padat: Detail Algoritma dan Sampel Kode C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465237/">  Representasi batas (B-rep) adalah metode utama untuk mewakili objek yang dimodelkan di sebagian besar kernel geometris, termasuk kernel C3D Modeler kami.  Algoritma inti yang mengedit model, seperti menerapkan operasi fillet, melakukan operasi pemotongan, dan mendapatkan proyeksi datar membutuhkan ketelitian representasi B-rep.  Variasi data 3D yang berkembang pesat dalam format poligon membuat tugas transformasi model dari poligon menjadi representasi batas semakin relevan.  Sebagai hasilnya, kami mengembangkan SDK baru, C3D B-Shaper, yang merupakan bagian dari C3D Toolkit kami. <br><br><img src="https://habrastorage.org/webt/jt/2y/jv/jt2yjvnxfahxck-a1poawxfx8vc.png" alt="gambar"><br><a name="habracut"></a><br>  Menggunakan algoritma triangulasi (dikenal sebagai tessellation) pada representasi batas model relatif mudah.  Membangun representasi poligon (tessellated) berguna untuk tujuan visualisasi dan untuk melakukan perhitungan geometrik. <br><br>  Namun transformasi terbalik - dari representasi poligon ke B-rep - menghadapi serangkaian masalah terkait dengan kompleksitas dalam mengenali berbagai jenis permukaan, termasuk yang berbentuk bebas.  Juga, ada masalah kebisingan dalam model poligonal yang muncul secara khas sebagai hasil pemindaian 3D. <br><br>  Proses umum dimana C3D B-Shaper mengubah model dari format poligonal ke B-rep terdiri dari tiga tahap: segmentasi, rekonstruksi permukaan, dan konstruksi model b-rep.  Proses transformasi bersifat berulang: jika pengguna dengan alasan apa pun tidak senang dengan hasilnya, maka koreksi dapat dilakukan selama tahap segmentasi dan rekonstruksi permukaan. <br><br><img src="https://habrastorage.org/webt/qx/wf/jp/qxwfjpqgfavnukkhjusspnjdzjg.png" alt="gambar"><br>  <i>Mengubah representasi poligon menjadi B-rep</i> <br><br>  Namun, sebelum memulai proses transformasi b-rep, kami meningkatkan kualitas mesh poligon sumber dengan menerapkan perbaikan berikut: mengoordinasikan arah normal dalam poligon yang berdekatan;  menghilangkan lubang;  dan menerapkan algoritma perataan ke sumber mesh yang bising, jika ada. <br><br><h1>  <font color="#00B2FF">Segmentasi model poligonal</font> </h1><br>  Tahap pertama transformasi adalah segmentasi model poligonal.  Kami mengklasifikasikan poligon jala ke dalam himpunan bagian (segmen).  Informasi tentang normals pada setiap vertex mesh memungkinkan untuk melakukan segmentasi orde pertama dan kemudian melakukan pemisahan mesh awal, serta mengklasifikasikan area sebagai datar atau sangat melengkung.  Pemisahan mesh awal didasarkan pada mendefinisikan tepi "tajam".  Ini adalah tepi antara dua poligon segitiga di mana sudut antara normalnya rata-rata melebihi nilai yang telah ditentukan. <br><br>  Segmentasi orde kedua menganalisis mesh berdasarkan kelengkungan utamanya, yang cukup untuk mengklasifikasikan permukaan dasar.  Ketika menghitung kelengkungan pada simpul jala, kami menggunakan hasil karya Meyer (Mark Meyer, Mathieu Desbrun, Peter Schroder, dan Alan H. Barr, "Operator Geometri Diferensial-Diskrit untuk Triangulasi 2-Manifold," Visualisasi dan Matematika III, 2003) dalam mendefinisikan operator diferensial diskrit untuk daerah triangulasi: satu set simpul yang berdekatan (terkait dengan simpul yang diberikan melalui tepi) dipertimbangkan untuk setiap simpul mesh awal.  Selanjutnya, operator diskrit <i>K</i> dihitung untuk simpul tersebut.  Berdasarkan pada operator, rata-rata kelengkungan normal, rata-rata <i>K <sub>H</sub></i> , dan Gaussian <i>K <sub>G</sub></i> ditentukan pada vertex mesh. <br><br><img src="https://habrastorage.org/webt/rz/ni/kf/rznikfmo-7jumijuvqo4pjgmurs.png" alt="gambar"><br>  <i>Menentukan operator diferensial diskrit untuk wilayah triangulasi</i> <br><br>  Dengan cara ini tensor kelengkungan dihitung untuk setiap simpul mesh, dari mana nilai kelengkungan utama <i>K <sub>1</sub></i> dan <i>K <sub>2</sub></i> dan arah kelengkungan utama diekstraksi. <br><br>  Verteks mesh diklasifikasikan berdasarkan nilai-nilai lengkungan utama mereka <i>K <sub>1</sub></i> dan <i>K <sub>2</sub></i> , dan kemudian dihitung untuk mereka.  Algoritma klasifikasi vertex didasarkan pada k-means, yaitu, meminimalkan deviasi kuadrat total dari titik-titik cluster dari pusat-pusat cluster.  Output yang dihasilkan dari algoritma berisi simpul jala terkait dengan sebuah cluster <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>i</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.569ex" height="2.057ex" viewBox="0 -780.1 1106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/465237/&amp;usg=ALkJrhibpnSLP1GvQ6xQn5Mz_-hokYZkLw#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/465237/&amp;usg=ALkJrhibpnSLP1GvQ6xQn5Mz_-hokYZkLw#MJMATHI-69" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>i</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Ci </script>  dan sepasang kelengkungan (cluster-center - L. Guillaume, "Segitiga Berbasis Kelengkungan Tensor Berbasis Segitiga dengan Boundary Rectification," Prosiding Computer Graphics International (CGI), 2004). <br><br><img src="https://habrastorage.org/webt/rr/sf/zg/rrsfzgnpnkdjbk6tkaj2huigmno.png" alt="gambar"><br>  <i>Mengklasifikasikan simpul poligonal dalam ruang kelengkungan</i> <br><br>  Setelah kita selesai mengklasifikasikan simpul poligon, kita pergi ke mengklasifikasikan poligon.  Untuk memulai prosedur ini, kami memilih poligon segitiga yang kelengkungannya dapat dipertimbangkan sepenuhnya.  Ini adalah salah satu yang memiliki tiga simpul dalam satu cluster, atau memiliki dua simpul pada sisi yang tajam.  Poligon dilabeli sebagai segmen baru dan menjadi titik awal untuk prosedur rekursif yang memperluas segmen: untuk setiap poligon segitiga, poligon yang berdekatan dianggap sepanjang tepi di antara keduanya tidak "tajam."  Ketika simpul poligon yang berdekatan, yang berlawanan dengan tepi yang sama, berada di tepi yang tajam atau milik cluster yang sama, poligon ditambahkan ke segmen.  Proses ini diulang sampai semua poligon yang membentuk mesh hilang. <br><br><img src="https://habrastorage.org/webt/dm/19/to/dm19tosiw5tu-_p97ufs380khyy.png" alt="gambar"><br>  <i>Segmentasi mesh poligonal</i> <br><br>  Setelah prosedur pembuatan segmen selesai, algoritma lain menjahit segmen yang berdekatan bersama-sama untuk menghilangkan segmentasi berlebih dari mesh. <br><br><h1>  <font color="#00B2FF">Pengenalan tipe permukaan</font> </h1><br>  Tahap kedua adalah pengenalan permukaan.  Setiap segmen harus didekati dengan permukaan dengan ketelitian yang ditentukan oleh sistem atau oleh pengguna. <br><br>  Pertama, nilai-nilai kelengkungan utama dari segmen digunakan untuk menentukan apakah mungkin untuk menggambarkan bentuk segmen dengan salah satu permukaan dasar berikut: <br><br><ul><li>  Pesawat: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = 0 </li><li>  Sphere: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = <i>K</i> &gt; 0 </li><li>  Silinder: <i>k <sub>1</sub></i> = <i>K</i> &gt; 0, <i>k <sub>2</sub></i> = 0 </li><li>  Cone: <i>k <sub>1</sub></i> âˆˆ [ <i>a</i> , <i>b</i> ], <i>k <sub>2</sub></i> = 0 </li><li>  Toroid: <i>k <sub>1</sub></i> = <i>K</i> , <i>k <sub>2</sub></i> âˆˆ [ <i>a</i> , <i>b</i> ] </li></ul><br>  Untuk membuat permukaan dasar, kita paskan objek geometris sederhana ke set titik menggunakan algoritma yang sesuai.  Misalnya, agar sesuai dengan lingkaran dan bola ke satu set poin, metode kuadrat terkecil digunakan;  agar sesuai dengan bidang, analisis komponen utama digunakan.  Sistem ini memastikan bahwa setiap permukaan yang direkonstruksi terkait dengan segmen dalam ketepatan pengakuan yang telah ditentukan. <br><br>  Gambar di bawah ini mengilustrasikan permukaan yang dikenali berdasarkan warna: bidang ditunjukkan dengan warna biru, silinder berwarna merah, bidang berwarna hijau, kerucut berwarna kuning, dan toroid violet. <br><br><img src="https://habrastorage.org/webt/az/z_/jh/azz_jhkz6xkn0ffe8z95dhrfzum.png" alt="gambar"><br>  <i>Sumber mesh poligonal (kiri) dan mesh tersegmentasi (kanan) dengan segmen permukaan yang dikenal</i> <br><br>  Jika tidak ada permukaan dasar yang dapat menggambarkan segmen, maka sistem mencoba mengenali permukaan ekstrusi atau permukaan revolusi. <br><br>  Ketika sistem pada akhirnya gagal menemukan permukaan analitis yang digunakan untuk menggambarkan bentuk segmen, permukaan NURBS dibuat untuk itu. <br><br><h1>  <font color="#00B2FF">Pembuatan model B-rep</font> </h1><br>  Tahap akhir dari transformasi adalah membuat model B-rep berdasarkan pada segmentasi dan data permukaan yang direkonstruksi.  Grafik kedekatan dibuat dari daerah tersegmentasi untuk mewakili topologi model, dan membentuk dasar untuk membuat model B-rep yang dihasilkan.  Model B-rep dirakit dalam mode otomatis penuh, berbeda dengan tahapan sebelumnya: <br><br><ul><li>  Tepi B-rep dibuat dari kurva persimpangan dari permukaan yang direkonstruksi yang berdekatan </li><li>  Permukaan B-rep dikonstruksi oleh permukaan yang dikenali yang dibatasi dan tepi B-rep </li></ul><br>  Namun, tidak selalu memungkinkan untuk membuat shell dengan topologi yang benar.  Misalnya, ambil dua permukaan seperti silinder dan bidang yang hampir bersinggungan satu sama lain di ruang angkasa.  Karena toleransi yang ditentukan untuk permukaan yang direkonstruksi, mereka mungkin tidak berpotongan sama sekali.  Akibatnya, shell yang dibuat mungkin memiliki cacat.  Pengguna dapat menghilangkan cacat dengan memperbaiki parameter permukaan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UPasZTasOps" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#00B2FF">Jenis Model Poligon</font> </h1><br>  Ada banyak sumber model poligonal yang tersedia online: <br><br><ul><li>  Katalog dan basis data online menawarkan model 3D dalam format poligon seperti STL, VRML, dan OBJ dari 3D Warehouse, Cults 3D, dan sebagainya. </li><li>  File yang dihasilkan dari pemindaian 3D </li><li>  Output dari optimasi topologi model menggunakan algoritma CAE </li></ul><br>  Model-model poligonal dari sumber-sumber ini dapat dibagi menjadi dua kelompok: model-model yang triangulasi (disatukan) dari objek B-rep, dan semua model lainnya.  Sepasang fitur khusus untuk kelompok pertama adalah tidak adanya kebisingan mesh poligonal dan dominasi permukaan analitis.  Ini berarti bahwa model dari kelompok pertama dapat dengan mudah diubah menjadi b-repetisi dalam mode otomatis penuh atau dengan upaya pengguna yang minimal. <br><br>  Jerat poligonal model dalam kelompok kedua memiliki kebisingan, mengandung permukaan organik, dan karenanya mereka cenderung membutuhkan partisipasi interaktif dari pengguna. <br><br>  Jadi kami menyediakan dua mode untuk mengoperasikan C3D B-Shape, sepenuhnya otomatis dan interaktif.  Pengguna dapat beralih di antara mode pengenalan, dan mengelola jenis permukaan selama proses rekonstruksi.  Memilih mode dapat bergantung pada tujuan melakukan transformasi: pengguna kadang-kadang mungkin ingin mengabaikan konektivitas topologi dari shell yang dihasilkan, atau kebenaran keseluruhannya.  Ini sering terjadi ketika mengoptimalkan tampilan dalam aplikasi BIM, di mana pengguna menambahkan elemen interior khusus ke model arsitektur. <br><br>  Di sisi lain, tugas rekayasa balik memerlukan salinan yang paling akurat dari model sumber sehingga model yang dihasilkan memiliki topologi yang benar.  Jadi, perlu untuk menentukan presisi, katakanlah, koaksialitas silinder atau singgung dua permukaan.  Dalam kasus-kasus seperti ini, partisipasi pengguna dalam proses transformasi sangat penting. <br><br>  Transformasi otomatis C3D B-Shaper menggunakan fungsi-fungsi berikut yang digunakan sebagai input data mesh pengaturan dan transformasi: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertMeshToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbMesh &amp; mesh, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertCollectionToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbCollection &amp; collection, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>;</code> </pre> <br>  Salah satu pengaturan transformasi adalah nilai ketepatan pengakuan yang menetapkan toleransi maksimum untuk jarak antara simpul segmen dan permukaan yang dikenal.  Ketepatannya bisa absolut atau relatif.  Saat menggunakan presisi relatif, penyimpangan wajah dari badan mesh diukur relatif terhadap ukuran model. <br><br>  Kelas antarmuka Prosesor MbMesh menawarkan opsi lanjutan untuk mengelola segmentasi dan pengenalan permukaan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MbMeshProcessor</span></span></span><span class="hljs-class"> {</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Mesh rectification. void SetUseMeshSmoothing( bool useSmoothing ); // Mesh segmentation management. const MbCollection &amp; GetSegmentedMesh(); MbResultType SegmentMesh( bool createSurfaces = true ); void ResetSegmentation(); void UniteSegments( size_t firstSegmentIdx, size_t secondSegmentIdx ); MbResultType SegmentMeshBySeparators( const std::vector&lt;std::vector&lt;uint&gt;&gt; &amp; sep ); // Surface recognition management. void FitSurfaceToSegment( size_t idxSegment ); void FitSurfaceToSegment( size_t idxSegment, MbeSpaceType surfaceType ); const MbSurface * GetSegmentSurface( size_t idxSegment ) const; // B-rep shell construction. MbResultType CreateBRepShell( MbFaceShell *&amp; pShell ); .. }</span></span></code> </pre> <br>  Sebagai contoh, untuk mengoreksi hasil dari segmentasi otomatis, C3D B-Shaper menawarkan alat untuk menggabungkan dan membagi segmen, dan sebagainya.  Pengguna dapat memasukkan permukaan jenis tertentu ke segmen yang dipilih, serta memodifikasi parameter permukaan yang dikenali. <br><br><h1>  <font color="#00B2FF">Ringkasan</font> </h1><br>  Hasil algoritma transformasi C3D B-Shaper diilustrasikan oleh gambar di bawah ini, di mana model 3D yang kompleks berhasil ditransformasikan dari representasi jala poligonal menjadi solid-representasi padatan. <br><br><img src="https://habrastorage.org/webt/om/i7/zw/omi7zwcrrc3qzdvyfkvzphvsyra.png" alt="gambar"><br><br><img src="https://habrastorage.org/webt/is/zt/nw/isztnwvohh4t9nzgj4pusg9awek.png" alt="gambar"><br>  <i>Mesh poligonal (kiri) dan model B-rep (kanan) dikonversi dengan C3D B-Shaper</i> <br><br>  Tujuan kami adalah untuk membuat SDK yang kuat untuk mengubah model dari poligonal ke B-rep, dan pengembangan C3D B-Shaper terus berlanjut.  Beberapa hal yang sedang kami kerjakan meliputi memajukan algoritma segmentasi otomatis, mengembangkan alat untuk mengedit segmentasi, meningkatkan konstruksi permukaan NURBS bentuk bebas, dan meningkatkan kualitas rakitan shell B-rep. <br><br>  Pelanggan yang menggunakan kernel geometrik C3D juga merupakan faktor dalam mendorong pengembangan C3D B-Shaper. <br><br>  Pengembang dipersilakan menguji C3D B-Shaper sebagai bagian dari C3D Toolkit atau sebagai komponen mandiri. <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/k8/za/vg/k8zavgo-xihodwssql3y-aqlmam.jpeg"></a>  Oleh Andrey Tumanin, Pimpinan Pengembangan Perangkat Lunak di C3D Labs </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465237/">https://habr.com/ru/post/id465237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465217/index.html">Acronis True Image 2020: Skema Replikasi Baru dan Perlindungan yang Ditingkatkan</a></li>
<li><a href="../id465221/index.html">Seperti apa register dalam 1C di hadapan OOP</a></li>
<li><a href="../id465223/index.html">Bagaimana memanfaatkan keamanan kertas secara praktis, atau mengapa kita perlu kepatuhan dengan 152-Ğ¤Ğ— dan PCI DSS dalam satu cloud</a></li>
<li><a href="../id465227/index.html">Augmented Reality dalam Retail Online</a></li>
<li><a href="../id465229/index.html">"Konsultan +": perubahan aliran materi. Font, gaya, perataan teks dengan python</a></li>
<li><a href="../id465239/index.html">Datang dan ambil buku dalam bahasa Inggris</a></li>
<li><a href="../id465241/index.html">Hari ketujuh saya dengan Haiku: daftar, pemindaian, jaringan</a></li>
<li><a href="../id465245/index.html">Lihat antarmuka "melalui mata desainer": tentang interaksi front-end dengan desainer</a></li>
<li><a href="../id465247/index.html">Sudut Memahami @Input, @Output, dan EventEmitter</a></li>
<li><a href="../id465249/index.html">Kuliah oleh Richard Stallman di Politeknik Moskow. Agustus 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>