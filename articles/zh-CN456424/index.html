<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↩️ 🤛 ➿ Utreexo：压缩很多UTXO比特币 💵 👪 👩🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 


 在比特币网络中，所有节点都在许多UTXO上达成共识：可用于消费的硬币数量，对象和对象以及条件。 UTXO的集合是验证者节点所需的最小数据集，否则该节点将无法验证传入事务及其包含的块的有效性。 


 在这方面，以各种方式尝试减少该组的存储表示，以压缩它而不损失安全保证。 存储的数据...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utreexo：压缩很多UTXO比特币</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456424/"><p><img src="https://habrastorage.org/webt/5_/dt/be/5_dtbegl1errsyauglpuftz1xus.png"></p><br><p> 哈Ha！ </p><br><p> 在比特币网络中，所有节点都在许多UTXO上达成共识：可用于消费的硬币数量，对象和对象以及条件。  UTXO的集合是验证者节点所需的最小数据集，否则该节点将无法验证传入事务及其包含的块的有效性。 </p><br><p> 在这方面，以各种方式尝试减少该组的存储表示，以压缩它而不损失安全保证。 存储的数据量越小，对验证器节点的磁盘空间的要求越低，这使得启动验证器节点变得便宜，从而使您能够扩展网络并从而提高网络稳定性。 </p><br><p> 在本说明中，我们将介绍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lightning Network Paper</a>合著者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Utreexo</a>最近提出的一项提案的Rust原型<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">：这是一种基于哈希的动态累加器，已针对比特币UTXO集进行了优化</a> ，从而减少了验证器节点的磁盘空间需求。 </p><a name="habracut"></a><br><h2 id="v-chyom-problema"> 怎么了 </h2><br><p> 比特币的永恒问题之一是它的可扩展性。  “拥有银行”的想法要求网络参与者跟踪所有可用资金。 在比特币中，可用资金表示为一组未使用的输出-UTXO集。 尽管这不是一个非常直观的视图，但与每个钱包都有“余额”作为单独条目并增加隐私（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CoinJoin</a>提供工作）的视图相比，它在实现性能上具有优势。 </p><br><p> 区分交易历史记录（称为区块链）和系统当前状态非常重要。 比特币的交易历史目前占据约200 GB的磁盘空间，并且还在继续增长。 但是，系统的状态要小得多，大约为4 GB，并且仅考虑到某人当前拥有硬币这一事实。 这些数据的数量也随时间增加，但是速率要低得多，有时甚至会减少（请参阅KDPV）。 </p><br><p> 轻客户端（SPV）交换安全性保证，以确保不存储除私钥之外的任何最低状态（UTXO集）。 </p><br><h2 id="utxo-i-utxo-set">  UTXO和UTXO集 </h2><br><p>  UTXO（未花费的交易输出）-未花费的交易输出，即交易中传输的每个聪的旅程的终点​​。 未使用的输出将成为新交易的输入并同时花费，并从UTXO集中删除。 </p><br><p> 新的UTXO始终由事务创建： </p><br><ul><li> 没有输入的币库交易：在矿工发行硬币期间创建新的UTXO </li><li> 常规交易：创建新的UTXO，同时花费一些现有的UTXO </li></ul><br><p> 使用UTXO的过程： <br><img src="https://habrastorage.org/webt/rw/ey/fh/rweyfhzcoy-cgcigbrlfv0qbypi.gif"></p><br><p> 钱包会根据可用于该钱包消费的UTXO数量，考虑可用于消费的硬币数量（余额）。 </p><br><p> 为了防止重复尝试，每个验证器节点必须在验证<strong>每个</strong>块的<strong>每个</strong>事务期间跟踪<strong>所有</strong> UTXO的收集。 </p><br><p> 该节点必须具有逻辑： </p><br><ul><li>  UTXO集的补充 </li><li>  UTXO集删除 </li><li> 检查集中是否存在单个UTXO </li></ul><br><p> 有一些方法可以减少对有关集合的存储信息的要求，同时保留使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">密码电池</a>添加和删​​除元素，检查并证明集合中元素存在的能力。 </p><br><h2 id="akkumulyatory-dlya-utxo">  UTXO电池 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前面</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已经讨论了</a>使用电池存储许多UTXO的想法。 </p><br><p>  UTXO集是在块链的初始加载（IBD，初始块下载）过程中动态构建的，它被完整且不断地存储，而其内容在处理来自每个新的正确网络块的事务后会发生变化。 此过程需要下载大约200 GB的数据块并验证数亿个数字签名。  IBD过程完成后，UTXO-set中的干燥残留物将占据约4 GB。 </p><br><p> 但是，在使用电池时，有关资金的共识规则归结为检查和生成加密证据，而追踪可用资金的负担就落在这些资金所有者的肩上，这为它们的存在和所有权提供了证据。 </p><br><p> 电池可以称为该装置的紧凑表示。 在这种情况下，存储视图的大小必须恒定 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.791ex" height="2.298ex" viewBox="0 -780.1 2924 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMAIN-31" x="1593" y="0"></use><g transform="translate(2093,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mn>1</mn><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-1"> O（1）</script>  ，或相对于元素集合的大小和元素本身的大小亚线性增加，例如 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x5BF9;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x6570;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>n</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.734ex" height="2.298ex" viewBox="0 -780.1 6343.9 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g transform="translate(1593,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">对</text></g><g transform="translate(2423,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">数</text></g><g transform="translate(3253,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMATHI-6E" x="4083" y="0"></use><g transform="translate(4683,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g><g transform="translate(5513,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>对</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>数</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-2"> O（对数（n））</script> 其中n是存储集的幂。 </p><br><p> 在这种情况下，累加器应允许生成元素包含在集合中的证据（包含证明），并使其能够有效地验证该证明。 </p><br><p> 如果电池允许您添加电池组中的物品或从电池组中取出物品，则称为<strong>动态</strong>电池。 </p><br><p> 这种电池的一个例子是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">由Boneh，Bunz，Fisch在2018年12月提出</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RSA电池</a> 。 这样的电池具有恒定的存储视图大小，但是需要<em>共享的机密</em> （可信设置）。 该要求否定了这种累加器在诸如比特币之类的不信任网络中的适用性，因为在生成机密期间数据泄漏可能使攻击者通过基于此类累加器对带有UTXO集合的节点进行欺骗来创建UTXO存在的虚假证据。 </p><br><h3 id="utreexo">  Utreexo </h3><br><p>  Utreexo提议的Thaddeus Dryja设计使您可以创建<strong>动态</strong>电池， <strong>而无需进行</strong>可信设置。 </p><br><p>  Utreexo是理想的二进制<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Merkle树的森林</a> ，是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对分布式pki的高效异步累加器中</a>提出的思想的发展，增加了从集合中删除元素的能力。 </p><br><h4 id="logicheskaya-struktura-akkumulyatora"> 电池的逻辑结构 </h4><br><p> 电池单元排列在完美的二叉树林中。 树木按高度排序。 该演示文稿被选为最直观的演示文稿，可让您在电池操作过程中可视化树木的融合。 </p><br><p> 作者指出，由于森林中的所有树木都是完美的，因此它们的高度由2的幂表示，就像任何自然数都可以表示为2的幂之和一样。 因此，可以以二叉树的形式将任何一组图纸分组，并且在所有情况下，添加新元素<em>仅</em>需要<em>有关所存储树的根节点的</em>知识。 </p><br><p> 因此，Utreexo电池的存储视图是根节点（Merkle根）的列表， <em>而不是整个树丛</em> 。 </p><br><p>想象根元素列表为<code>Vec&lt;Option&lt;Hash&gt;&gt;</code> 。 可选的<code>Option&lt;Hash&gt;</code>指示可能缺少根元素，这意味着该树没有合适高度的树。 </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// SHA-256  #[derive(Copy, Clone, Hash, Eq, PartialEq)] pub struct Hash(pub [u8; 32]); #[derive(Debug, Clone)] pub struct Utreexo { pub roots: Vec&lt;Option&lt;Hash&gt;&gt;, } impl Utreexo { pub fn new(capacity: usize) -&gt; Self { Utreexo { roots: vec![None; capacity], } } }</span></span></code> </pre> <br><h4 id="dobavlenie-elementov"> 新增项目 </h4><br><p> 首先，我们描述<code>parent()</code>函数，该函数识别两个给定元素的父节点。 </p><br><div class="spoiler">  <b class="spoiler_title">父（）函数</b> <div class="spoiler_text"><p> 由于我们使用Merkle树，因此两个节点中的每个节点的父节点都是一个节点，该节点存储后代节点的哈希值的串联哈希： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span></span>(bytes: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sha = Sha256::new(); sha.input(bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = sha.result(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res_bytes = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]; res_bytes.copy_from_slice(res.as_slice()); Hash(res_bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>(left: &amp;Hash, right: &amp;Hash) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> concat = left .<span class="hljs-number"><span class="hljs-number">0</span></span> .into_iter() .chain(right.<span class="hljs-number"><span class="hljs-number">0</span></span>.into_iter()) .map(|b| *b) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;&gt;(); hash(&amp;concat[..]) }</code> </pre> <br><p> 作者指出，为防止Charles Bouillaguet，Pierre-Alain Fouque，Adi Shamir和Sebastien Zimmer在 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对抖动的散列函数的第二次原像攻击</a> ，除了两个散列外，还应将树内的高度添加到串联中。 </p></div></div><br><p> 在向电池添加项目时，需要跟踪正在更改的根项目。 按照更改添加的每个元素的根元素的路径，以后可以构造这些元素存在的证明。 </p><br><div class="spoiler">  <b class="spoiler_title">在上传过程中跟踪更改</b> <div class="spoiler_text"><p> 为了跟踪所做的更改，我们将声明<code>Update</code>结构，该结构将存储有关节点更改的数据。 </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> utreexo: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Utreexo, <span class="hljs-comment"><span class="hljs-comment">// ProofStep  ""     pub updated: HashMap&lt;Hash, ProofStep&gt;, }</span></span></code> </pre> </div></div><br><p> 要向电池添加元素，您需要： </p><br><ul><li> 创建一组由根元素<code>new_roots</code>组成的篮子，并将现有的根元素放在此处，每个篮子一个： </li></ul><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> new_roots = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::&lt;Hash&gt;::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hash) = root { vec.push(*hash); } new_roots.push(vec); }</code> </pre> </div></div><br><ul><li> 将添加的元素（ <code>insertions</code>数组）添加到第一个购物篮<code>new_roots[0]</code> ： </li></ul><br><p><img src="https://habrastorage.org/webt/8f/ne/jg/8fnejgnqbngrgygwreduomorpni.gif"></p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="rust hljs">new_roots[<span class="hljs-number"><span class="hljs-number">0</span></span>].extend_from_slice(insertions);</code> </pre> </div></div><br><ul><li> 对添加到第一个购物篮中的商品与其余商品进行“促销”： <br><ul><li> 对于所有一件以上的篮子： <br><ol><li> 我们从篮子的末尾取两个元素，计算它们的父元素，删除两个元素 </li><li> 将计算出的父项添加到下一个篮子。 </li></ol></li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/df/dl/fm/dfdlfm0iw0tvwxtlomxmrml1ijc.gif"></p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> new_roots[i].len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         let a = new_roots[i][new_roots[i].len() - 2]; let b = new_roots[i][new_roots[i].len() - 1]; new_roots[i].pop(); new_roots[i].pop(); let hash = self.parent(&amp;a, &amp;b); //      if new_roots.len() &lt;= i + 1 { new_roots.push(vec![]); } //      new_roots[i + 1].push(hash); //    ; //        updated.insert(a, ProofStep { hash: b, is_left: false }); updated.insert(b, ProofStep {hash: a, is_left: true }); } }</span></span></code> </pre> </div></div><br><ul><li> 将根元素从篮子移动到生成的电池阵列 </li></ul><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, bucket) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_roots.into_iter().enumerate() { <span class="hljs-comment"><span class="hljs-comment">//     if self.roots.len() &lt;= i { self.roots.push(None); } if bucket.is_empty() { self.roots[i] = None; } else { self.roots[i] = Some(bucket[0]); } }</span></span></code> </pre> </div></div><br><h4 id="sozdanie-dokazatelstva-dlya-dobavlennyh-elementov"> 为添加的项目创建证据 </h4><br><p> 在电池中包含元素的<code>Proof</code> （ <code>Proof</code> ）将用作Merkle路径（Merkle Path），由<code>ProofStep</code>链<code>ProofStep</code> 。 如果路径无路可走，则证明是错误的。 </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///         . #[derive(Debug, Copy, Clone)] pub struct ProofStep { pub hash: Hash, pub is_left: bool, } ///   .       . #[derive(Debug, Clone)] pub struct Proof { pub steps: Vec&lt;ProofStep&gt;, pub leaf: Hash, }</span></span></code> </pre> <br><p> 使用前面在添加元素（ <code>Update</code>结构）过程中获得的信息，可以创建将元素添加到电池的证据。 为此，我们四处浏览所做的更改，并将每个步骤添加到Merkle的路径中，随后将用作证明： </p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Update&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prove</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, leaf: &amp;Hash) -&gt; Proof { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> proof = Proof { steps: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], leaf: *leaf, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> item = *leaf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updated.get(&amp;item) { proof.steps.push(*s); item = parent(&amp;item, &amp;s); } proof } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">证据程序</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8i/2h/gy/8i2hgyqkn8syqa0wdsybg3o9asm.gif"></p></div></div><br><h4 id="proverka-dokazatelstva-dlya-elementa"> 物品的证据证明 </h4><br><p> 检查包含元素的证明（包含证明）简化为遵循Merkle的路径，直到它导致现有的根元素为止： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = proof.steps.len(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expected) = expected { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> current_parent = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> proof.steps.iter() { current_parent = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.is_left { parent(&amp;s.hash, &amp;current_parent) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent(&amp;current_parent, &amp;s.hash) }; } current_parent == expected } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><p> 显然： </p><br><div class="spoiler">  <b class="spoiler_title">A的证据验证过程</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sx/49/dz/sx49dzfpgnzqv-x6-hl1fxgey1a.gif"></p></div></div><br><h4 id="udalenie-elementov"> 删除项目 </h4><br><p> 要从电池中取出电池，必须提供有效的证据证明电池在其中。 使用证明中的数据，我们可以计算出该证明不再适用的新电池根元素。 </p><br><p> 算法如下： </p><br><ol><li> 与添加项一样，我们组织了一组与Merkle树相对应的空篮子，其高度等于篮子索引的两倍 </li><li> 将Merkle路径台阶中的物品插入篮子； 篮子指数等于当前步数 </li><li> 我们删除证明路径通往的根元素。 </li><li> 与加法运算一样，我们计算新的根元素，将成对的篮子中的元素成对组合，然后将并集结果移至下一个篮子 </li></ol><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof, new_roots: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Hash&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() &lt; proof.steps.len() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.get(proof.steps.len()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> height = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> hash = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt; new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (index, ok) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.find_root(&amp;hash, &amp;new_roots[height]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { <span class="hljs-comment"><span class="hljs-comment">// Remove hash from new_roots new_roots[height].remove(index); loop { if height &gt;= proof.steps.len() { if !self.roots[height] .and_then(|h| Some(h == hash)) .unwrap_or(false) { return Err(()); } return Ok(()); } s = proof.steps[height]; hash = self.parent(&amp;hash, &amp;s); height += 1; } } } if height &gt;= proof.steps.len() { return Err(()); } while height &gt; new_roots.len() { new_roots.push(vec![]); } s = proof.steps[height]; new_roots[height].push(s.hash); hash = self.parent(&amp;hash, &amp;s); height += 1; } }</span></span></code> </pre> </div></div><br><p> 删除项目“ A”的过程： <br><img src="https://habrastorage.org/webt/pi/uf/rb/piufrb9ivxabdm_45vbmohgm5os.gif"></p><br><h2 id="integraciya-v-suschestvuyuschuyu-set"> 集成到现有网络 </h2><br><p> 使用建议的电池，节点可以拒绝使用数据库来存储所有UTXO，同时保持更改UTXO集的能力。 但是，存在处理证据的问题。 </p><br><p> 我们将调用一个使用UTXO电池<em>紧凑</em>型的验证器节点（紧凑型节点），以及一个不使用电池的验证器- <em>充满</em> （完整节点）。 两类节点的存在带来了将它们集成到单个网络中的问题，因为紧凑型节点需要证明UTXO的存在，UTXO花费在事务中，而完整节点则不需要。 如果所有网络节点没有同时协调地切换到Utreexo，则紧凑型节点将被丢弃，并且将无法在比特币网络上工作。 </p><br><p> 为了解决将紧凑型节点集成到网络中的问题，建议引入另一类节点- <em>网桥</em> 。 桥接节点是一个完整的节点，除其他外，它存储Utreexo电池并包含来自UTXO集中的<strong>所有</strong> UTXO的证据。 当新的区块随交易到达时，网桥计算新的哈希值并更新电池和证据。 支持和更新电池以及证据不会在此类节点上施加额外的计算负荷。 桥梁牺牲了磁盘空间：保持秩序 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="1.937ex" viewBox="0 -728.2 1101 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMATHI-6E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> 2n </script> 哈希与 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>l</mi><mi>o</mi><mi>g</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>n</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.187ex" height="2.419ex" viewBox="0 -780.1 3525 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMATHI-67" x="784" y="0"></use><g transform="translate(1264,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgfS56etgr3zAtPHrgdQlfv-pyJJg#MJMATHI-6E" x="2094" y="0"></use><g transform="translate(2694,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>o</mi><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-4"> log（n）</script> 紧凑节点的哈希，其中n是设置的UTXO的幂。 </p><br><h3 id="arhitektura-seti"> 网络架构 </h3><br><p><img src="https://habrastorage.org/webt/fj/at/9t/fjat9tzhyxy_ncflmmzgt8ere_4.gif"></p><br><p> 网桥使逐渐将紧凑的节点添加到网络成为可能，而无需更改现有节点的软件。 完整节点像以前一样工作，在它们之间分配事务和块。 桥节点是完整的节点，可以额外存储Utreexo电池数据和当前<strong>所有</strong> UTXO的一组包含证据。 桥节点不会像这样通告自己，而是假装为所有完整节点的完整节点和所有紧凑节点的紧凑节点。 尽管网桥将两个网络连接在一起，但实际上，它们仅需要一个方向进行连接：从现有的完整节点到紧凑型节点。 这是可能的，因为不需要更改事务格式，并且可以丢弃用于紧凑型节点的UTXO证据，因此任何紧凑型节点都可以以相同的方式向所有网络参与者发送事务，而无需桥接节点的参与。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 我们审查了Utreexo电池，并在Rust中实现了其原型。 我们检查了网络架构，该架构将基于电池集成节点。 紧凑捕获的优点是存储数据的大小，它在对数上取决于许多UTXO的功能，从而大大减少了此类节点的磁盘空间要求和存储性能。 缺点是用于证据传输的额外节点流量，但是证据聚合技术（当一个证据证明存在多个元素时）和缓存可以帮助将流量保持在可接受的范围内。 </p><br><p>  <strong>参考文献</strong> ： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Utreexo Rust原型GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Utreexo：针对比特币UTXO集优化的基于哈希的动态累加器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章中的动画图稿</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456424/">https://habr.com/ru/post/zh-CN456424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456412/index.html">Yandex有争议的创新-通过信函登录到您的帐户</a></li>
<li><a href="../zh-CN456414/index.html">防止数据中心火灾或如何存储数据</a></li>
<li><a href="../zh-CN456416/index.html">全书敏捷</a></li>
<li><a href="../zh-CN456418/index.html">电子游戏作弊简史</a></li>
<li><a href="../zh-CN456422/index.html">宣布新版本的Styled Components v5：Animal Grin</a></li>
<li><a href="../zh-CN456426/index.html">BASS-自动合成防病毒签名的框架</a></li>
<li><a href="../zh-CN456428/index.html">如何实施BI方法进行数据分析：实用建议</a></li>
<li><a href="../zh-CN456430/index.html">技术债务的永恒问题</a></li>
<li><a href="../zh-CN456436/index.html">星期一的简短JS任务</a></li>
<li><a href="../zh-CN456440/index.html">难以捉摸的马尔瓦里历险记，第一部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>