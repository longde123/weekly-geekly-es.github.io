<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕳️ 🔎 🌂 Pembuatan Acara, CQRS dan Laravel 😺 🐵 🌦️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan artikel disiapkan untuk siswa dari kursus profesional "Framework Laravel" 
 



 Pendahuluan 
 Artikel ini dikhususkan untuk dasar-dasar me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembuatan Acara, CQRS dan Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/461899/">  <i>Terjemahan artikel disiapkan untuk siswa dari kursus profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Framework Laravel"</a></i> <i><br></i> <br><img src="https://habrastorage.org/webt/h8/4u/y5/h84uy5i5spnt3rdmpaiw2aynd0s.png"><br><br><hr><br><h2>  Pendahuluan </h2><br>  Artikel ini dikhususkan untuk dasar-dasar menciptakan sistem acara CQRS dalam bahasa PHP dan dalam kerangka Laravel.  Diasumsikan bahwa Anda terbiasa dengan skema pengembangan menggunakan bus perintah dan memiliki gagasan tentang peristiwa (khususnya, publikasi acara untuk berbagai pendengar).  Untuk menyegarkan kembali pengetahuan ini, Anda dapat menggunakan layanan Laracasts.  Selain itu, diasumsikan bahwa Anda memiliki pemahaman tertentu tentang prinsip CQRS.  Jika tidak, saya sangat merekomendasikan mendengarkan dua ceramah: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mathias Verraes Workshop Generasi Acara</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CQRS dan Generasi Acara Greg Young</a> . <br><a name="habracut"></a><br>  Jangan gunakan kode yang diberikan di sini di proyek Anda!  Ini adalah platform pembelajaran untuk memahami ide-ide di balik CQRS.  Kode ini tidak dapat disebut andal, tidak diuji dengan baik, dan selain itu, saya jarang memprogram antarmuka, jadi akan jauh lebih sulit untuk mengubah bagian-bagian individual dari kode.  Contoh yang jauh lebih baik dari paket CQRS yang dapat Anda gunakan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Broadway, yang dikembangkan oleh Qandidate Lab</a> .  Ini adalah kode yang bersih dan longgar, namun, beberapa abstraksi membuatnya tidak sepenuhnya jelas jika Anda belum pernah menemukan sistem acara. <br><br>  Dan yang terakhir - kode saya terhubung dengan acara dan bus perintah Laravel.  Saya ingin melihat bagaimana kode akan terlihat di Laravel (saya biasanya menggunakan kerangka kerja ini untuk proyek-proyek agen kecil), namun, melihat ke belakang, saya pikir saya harus membuat implementasi saya sendiri.  Saya berharap kode saya akan jelas bahkan bagi mereka yang tidak menggunakan kerangka kerja. <br><br>  Di github, kode ini terletak di <a href="">https://github.com/scazz/cqrs-tutorial.git</a> , dan dalam panduan kami, kami akan mempertimbangkan komponen-komponennya untuk meningkatkan logika. <br><br>  Kami akan membuat sistem pendaftaran awal untuk sekolah selancar.  Dengan bantuannya, klien sekolah dapat mendaftar untuk kelas.  Untuk proses perekaman, kami merumuskan aturan berikut: <br><br><ul><li>  Setiap pelajaran harus memiliki setidaknya satu klien ... </li><li>  ... tapi tidak lebih dari tiga. </li></ul><br>  Salah satu fitur yang paling mengesankan dari sistem CQRS berbasis acara adalah pembuatan model bacaan khusus untuk setiap metrik yang diperlukan dari sistem.  Anda akan menemukan contoh proyeksi model membaca di ElasticSearch, dan Greg Young telah menerapkan bahasa berorientasi subjek di toko acaranya untuk menangani acara yang kompleks.  Namun, untuk kesederhanaan, proyeksi baca kami akan menjadi database SQL standar untuk digunakan dengan Eloquent.  Sebagai hasilnya, kami akan memiliki satu tabel untuk kelas dan satu untuk klien. <br><br>  Konsep pembuatan acara juga memungkinkan Anda memproses acara secara offline.  Tetapi dalam artikel ini saya akan mematuhi model pengembangan "tradisional" secara maksimal (sekali lagi, untuk menyederhanakan), dan proyeksi bacaan kami akan diperbarui secara real time, segera setelah peristiwa disimpan dalam repositori. <br><br><h2>  Pengaturan proyek dan tes pertama </h2><br><pre><code class="plaintext hljs">git clone https://github.com/scazz/cqrs-tutorial</code> </pre> <br>  Buat proyek Laravel 5 baru <br><br><pre> <code class="plaintext hljs">$&gt; laravel new cqrs-tutorial</code> </pre> <br>  Sebagai permulaan, kita perlu tes.  Kami akan menggunakan tes integrasi, yang akan memastikan bahwa pendaftaran klien untuk kelas mengarah pada fakta bahwa pelajaran dibuat dalam model Eloquent kami. <br><br>  Tes daftar / CQRSTest.php: <br><br><pre> <code class="plaintext hljs">use Illuminate\Foundation\Bus\DispatchesCommands; class CQRSTest extends TestCase { use DispatchesCommands;</code> </pre><br><pre> <code class="bash hljs">/** *  ,   BookLesson       * @<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> void */ public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span> = <span class="hljs-string"><span class="hljs-string">'123e4567-e89b-12d3-a456-426655440000'</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertNotNull(Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)-&gt;clientName, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ); } }</code> </pre> <br>  Kami menugaskan aktivitas baru ke ID, membuat tim untuk mendaftar untuk aktivitas baru, dan memberi tahu Laravel untuk mengirimkannya.  Di tabel pelajaran, kita perlu membuat catatan baru yang bisa kita baca menggunakan model Eloquent.  Kami membutuhkan database, jadi isilah file .env Anda dengan benar. <br><br>  Setiap acara yang direkam di toko acara kami menempel pada akar agregat, yang kami sebut entitas (Entity) - sebuah abstraksi untuk tujuan pendidikan hanya menambah kebingungan.  ID adalah pengidentifikasi unik universal (UUID).  Toko acara tidak peduli jika acara tersebut berlaku untuk pelajaran atau klien.  Dia hanya tahu bahwa itu terkait dengan ID. <br><br>  Berdasarkan kesalahan yang diidentifikasi selama pengujian, kami dapat membuat kelas yang hilang.  Pertama, kita akan membuat kelas LessonId, lalu perintah BookLesson (jangan khawatir tentang metode handler, terus jalankan tes).  Kelas Pelajaran adalah model membaca di luar namespace Pelajaran.  Model bacaan eksklusif - logika area subjek tidak akan pernah disimpan di sini.  Sebagai kesimpulan, kita perlu membuat migrasi untuk tabel pelajaran. <br><br>  Untuk menjaga kejelasan kode, saya akan menggunakan pustaka verifikasi pernyataan.  Itu dapat ditambahkan dengan perintah berikut: <br><br><pre> <code class="plaintext hljs">$&gt; composer require beberlei/assert</code> </pre> <br>  Pertimbangkan proses yang harus dimulai oleh perintah ini: <br><br><ol><li>  Validasi: perintah imperatif mungkin gagal, dan acara telah terjadi dan karenanya tidak boleh gagal. </li><li>  Buat acara LessonWasBooked baru (mendaftar untuk pelajaran). </li><li>  Perbarui status aktivitas.  (Model catatan harus menyadari keadaan model sehingga dapat melakukan validasi.) </li><li>  Tambahkan acara ini ke aliran acara yang tidak terikat yang disimpan dalam model catatan aktivitas. </li><li>  Simpan aliran acara yang tidak dikomit ke repositori. </li><li>  Angkat acara LessonWasBooked secara global untuk memberi tahu semua proyektor membaca untuk memperbarui tabel pelajaran. </li></ol><br>  Anda harus terlebih dahulu membuat model rekaman untuk pelajaran.  Kami akan menggunakan metode pabrik statis <code>Lesson::bookClientOntoNewLesson()</code> .  Ini menghasilkan acara <code>LessonWasOpened</code> baru (pelajaran terbuka), menerapkan acara ini untuk dirinya sendiri (hanya menetapkan ID-nya), menambahkan acara baru ke daftar acara yang tidak terikat dalam bentuk <code>DomainEventMessage</code> (acara ditambah beberapa metadata yang kami gunakan saat menyimpan ke toko acara). <br><br>  Proses ini diulangi untuk menambahkan klien ke acara tersebut.  Saat menerapkan acara <code>ClientWasBookedOntoLesson</code> (klien terdaftar dalam pelajaran), model rekaman tidak melacak nama klien, tetapi hanya jumlah klien terdaftar.  Model rekaman tidak perlu tahu nama pelanggan untuk memastikan konsistensi. <br><br>  Metode <code>applyLessonWasOpened</code> dan <code>applyClientWasBookedOntoLesson</code> mungkin tampak agak aneh sekarang.  Kami akan menggunakannya nanti ketika kami perlu mereproduksi acara lama untuk membentuk keadaan model rekaman.  Tidak mudah untuk dijelaskan, jadi saya akan memberikan kode yang akan membantu Anda memahami proses ini.  Nanti kita akan mengekstrak kode yang memproses uncommittedEvents dan menghasilkan pesan peristiwa domain. <br><br><pre> <code class="bash hljs">app/School/Lesson/Lesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> openLesson( LessonId <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ) { /*      ,      ,       */ <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new LessonWasOpened( <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); } protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients = 0; } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> bookClient( <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients &gt;= 3) { throw new TooManyClientsAddedToLesson(); } <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new ClientBookedOntoLesson( <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>) ); } /** *       — *  ,       *      ,       , *      . */ protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyClientBookedOntoLesson( ClientBookedOntoLesson <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients++; }</code> </pre> <br>  Kita dapat mengekstrak komponen CQRS dari model rekaman kami - fragmen kelas yang terlibat dalam pemrosesan acara yang tidak dikomit.  Kami juga dapat menghapus API untuk entitas yang dihasilkan acara dengan membuat fungsi <code>apply()</code> aman yang menerima acara, memanggil metode <code>applyEventName()</code> sesuai, dan menambahkan acara <code>DomainEventMessage</code> baru ke daftar acara yang tidak dikomit.  Kelas yang diekstrak adalah detail dari implementasi CQRS dan tidak mengandung logika domain, sehingga kami dapat membuat namespace baru: App \ CQRS: <br><br>  <i>Perhatikan <code>app/CQRS/EventSourcedEntity.php</code> kode <code>app/CQRS/EventSourcedEntity.php</code></i> <i><br></i>  <i>Agar kode berfungsi, kita perlu menambahkan kelas <code>DomainEventMessage</code> , yang merupakan DTO sederhana - dapat ditemukan di <code>app/CQRS/DomainEventMessage.php</code></i> <br><br>  Dengan demikian, kami mendapatkan sistem yang menghasilkan acara untuk setiap upaya penulisan dan menggunakan acara untuk mencatat perubahan yang diperlukan untuk mencegah invarian.  Langkah selanjutnya adalah menyimpan acara ini di toko (EventStore).  Pertama-tama, repositori acara ini perlu dibuat.  Untuk menyederhanakan, kita akan menggunakan model Eloquent, tabel SQL sederhana dengan bidang-bidang berikut: * <code>UUID</code> (untuk mengetahui entitas mana yang menerapkan acara tersebut) * <code>event_payload</code> (pesan berseri berisi semua yang diperlukan untuk membuat ulang acara) * <code>event_payload</code> - stempel waktu untuk mengetahui kapan acara terjadi  Jika Anda hati-hati meninjau kode, Anda akan melihat bahwa saya membuat dua perintah - untuk membuat dan menghancurkan tabel penyimpanan acara kami: <br><br><ul><li>  php artisan eloquenteventstore: create (App \ CQRS \ EloquentEventStore \ CreateEloquentEventStore) </li><li>  php artisan eloquenteventstore: drop (App \ CQRS \ EloquentEventStore \ DropEloquentEventStore) (jangan lupa menambahkannya ke App \ Console \ Kernel.php sehingga mereka memuat). </li></ul><br>  Ada dua alasan yang sangat baik untuk tidak menggunakan SQL sebagai event store: tidak menerapkan model append-only (hanya menambahkan data, peristiwa harus tidak berubah), dan juga karena SQL bukan bahasa query yang ideal untuk database temporal.  Kami memprogram antarmuka untuk memfasilitasi penggantian toko acara dalam publikasi berikutnya. <br><br>  Untuk menyimpan acara, gunakan repositori.  Setiap kali <code>save()</code> dipanggil untuk model rekaman, kami menyimpan daftar uncommittedEvents di event store.  Untuk menyimpan acara, kita memerlukan mekanisme untuk serialisasi dan deserialisasi mereka.  Buat Serializer untuk ini.  Kita akan membutuhkan metadata, seperti kelas acara (misalnya, <code>App\School\Lesson\Events\LessonWasOpened</code> ) dan payload acara (data yang diperlukan untuk merekonstruksi suatu peristiwa). <br><br>  Semua ini akan dikodekan dalam format JSON, dan kemudian ditulis ke basis data kami bersama dengan entitas UUID dan timestamp.  Kami ingin memperbarui model membaca kami setelah menangkap peristiwa, sehingga repositori akan memicu setiap peristiwa setelah menyimpan.  Serializer akan bertanggung jawab untuk menulis kelas acara, sedangkan acara tersebut akan bertanggung jawab untuk membuat serial muatannya.  Acara berseri lengkap akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs"> { class: "App\\School\\Lesson\\Events\\", event: $event-&gt;serialize() }</code> </pre> <br>  Karena semua acara memerlukan metode serialisasi dan deserialisasi, kita dapat membuat antarmuka <code>SerializableEvent</code> dan menambahkan indikasi jenis nilai yang diharapkan.  Perbarui acara <code>LessonWasOpened</code> kami: <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php class LessonWasOpened implements SerializableEvent { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'lessonId'</span></span>=&gt; (string) <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;getLessonId() ); } }</code> </pre> <br>  Buat repositori <code>LessonRepository</code> .  Kita dapat melakukan refactor dan mengekstraksi komponen CQRS inti nanti. <br><br> <code>app/School/Lesson/LessonRepository.php</code> <br> <pre> <code class="plaintext hljs">eventStoreRepository = new EloquentEventStoreRepository( new EventSerializer() ); } public function save(Lesson $lesson) { /** @var DomainEventMessage $domainEventMessage */ foreach( $lesson-&gt;getUncommittedDomainEvents() as $domainEventMessage ) { $this-&gt;eventStoreRepository-&gt;append( $domainEventMessage-&gt;getId(), $domainEventMessage-&gt;getEvent(), $domainEventMessage-&gt;getRecordedAt() ); Event::fire($domainEventMessage-&gt;getEvent()); } } }</code> </pre> <br>  Jika Anda menjalankan tes integrasi lagi dan kemudian memeriksa tabel SQL <code>domain_events</code> , Anda akan melihat dua peristiwa dalam database. <br><br>  Langkah terakhir kami dalam berhasil lulus tes adalah mendengarkan acara siaran dan memperbarui proyeksi model membaca Pelajaran.  Acara siaran Lesson akan dicegat oleh <code>LessonProjector</code> , yang akan menerapkan perubahan yang diperlukan untuk <code>LessonProjection</code> (model <code>LessonProjection</code> dari tabel pelajaran): <br><br><pre> <code class="bash hljs"> app/School/Lesson/Projections/LessonProjector.php class LessonProjector { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span> = new LessonProjection(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;id = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;save(); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> subscribe(Dispatcher <span class="hljs-variable"><span class="hljs-variable">$events</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span> = self::class; <span class="hljs-variable"><span class="hljs-variable">$events</span></span>-&gt;listen( LessonWasOpened::class, <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span>.<span class="hljs-string"><span class="hljs-string">'@applyLessonWasOpened'</span></span>); } }  app/School/Lesson/Projections/LessonProjection.php class LessonProjection extends Model { public <span class="hljs-variable"><span class="hljs-variable">$timestamps</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; protected <span class="hljs-variable"><span class="hljs-variable">$table</span></span> = <span class="hljs-string"><span class="hljs-string">"lessons"</span></span>; }</code> </pre> <br>  Jika Anda menjalankan tes, Anda akan melihat bahwa kesalahan SQL telah terjadi: <br><br><pre> <code class="plaintext hljs">Unknown column 'clientName' in 'field list'</code> </pre> <br>  Segera setelah kami membuat migrasi untuk menambahkan <code>clientName</code> ke tabel pelajaran, kami akan berhasil lulus tes.  Kami telah menerapkan fungsionalitas dasar CQRS: tim membuat acara yang digunakan untuk menghasilkan model membaca. <br><br><h2>  Memperbaiki model membaca dengan tautan </h2><br>  Kami telah mencapai tonggak penting, tetapi itu belum semuanya!  Sejauh ini, model membaca hanya mendukung satu klien (kami menetapkan tiga dalam aturan domain kami).  Perubahan yang kami buat pada model bacaan cukup sederhana: kami hanya membuat model proyeksi Klien dan <code>ClientProjector</code> yang menangkap acara <code>ClientBookedOntoLesson</code> .  Pertama, kami memperbarui tes kami untuk mencerminkan perubahan yang ingin kami lihat dalam model bacaan kami: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;id, (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$client</span></span> = <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients()-&gt;first(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals(<span class="hljs-variable"><span class="hljs-variable">$client</span></span>-&gt;name, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); }</code> </pre><br>  Ini adalah demonstrasi yang jelas tentang betapa mudahnya mengubah model membaca.  Semuanya, sampai ke penyimpanan acara, tetap tidak berubah.  Sebagai bonus, saat menggunakan sistem acara, kami mendapatkan data untuk tes dasar - saat mengganti proyektor model bacaan, kami mendengarkan setiap peristiwa yang pernah terjadi dalam sistem kami. <br><br>  Kami mereproduksi peristiwa ini menggunakan proyektor baru, memeriksa pengecualian, dan membandingkan hasilnya dengan proyeksi sebelumnya.  Setelah sistem bekerja selama beberapa waktu, kami akan memiliki pilihan acara yang cukup representatif untuk menguji proyektor kami. <br><br>  Model rekaman kami saat ini tidak memiliki kemampuan memuat keadaan saat ini.  Jika kami ingin menambahkan klien kedua ke pelajaran, kami dapat dengan mudah membuat acara ClientWasAddedToLesson yang kedua, tetapi kami tidak dapat memberikan perlindungan terhadap invarian.  Untuk kejelasan yang lebih besar, saya mengusulkan untuk menulis tes kedua yang mensimulasikan rekaman dua klien per pelajaran. <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLoadingWriteModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span> = <span class="hljs-string"><span class="hljs-string">"Fred"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); }</code> </pre> <br>  Untuk model perekaman kami, kami perlu menerapkan metode "memuat" entitas yang sudah menerapkan peristiwa di dalamnya di event store.  Kita dapat mencapai ini dengan memutar ulang setiap peristiwa yang mengacu pada UUID entitas.  Secara umum, prosesnya adalah sebagai berikut: <br><br><ol><li>  Kami menerima semua pesan acara yang relevan dari toko acara. </li><li>  Untuk setiap pesan, kami membuat ulang acara terkait. </li><li>  Kami membuat model catatan entitas baru dan memutar ulang setiap acara. </li></ol><br>  Saat ini, tes kami mengeluarkan pengecualian, jadi kami akan mulai dengan membuat <code>BookClientOntoLesson</code> diperlukan (daftarkan klien untuk pelajaran) menggunakan perintah <code>BookLesson</code> sebagai templat.  Metode handler akan terlihat seperti ini: <br><br><pre> <code class="bash hljs"> app/School/Lesson/Commands/BookClientOntoLesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handle(LessonRepository <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>) { /** @var Lesson <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> */ <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;bookClient(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;clientName); <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;save(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>); }      : app/School/Lesson/LessonRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(LessonId <span class="hljs-variable"><span class="hljs-variable">$id</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventStoreRepository-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$id</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = new Lesson(); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;initializeState(<span class="hljs-variable"><span class="hljs-variable">$events</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>; }</code> </pre> <br>  Fungsi beban repositori mengembalikan array peristiwa yang dibuat kembali.  Untuk melakukan ini, ia pertama kali menemukan pesan tentang peristiwa di repositori, dan kemudian meneruskannya ke <code>Serializer</code> untuk mengonversi setiap pesan menjadi suatu peristiwa.  <code>Serializer</code> membuat pesan dari acara, jadi kita perlu menambahkan metode <code>deserialize()</code> untuk melakukan transformasi terbalik.  Ingat bahwa <code>Serializer</code> diteruskan ke setiap peristiwa untuk membuat serialisasi data acara (misalnya, nama klien).  Kami akan melakukan hal yang sama untuk melakukan transformasi terbalik, sementara antarmuka <code>SerializableEvent</code> kami harus diperbarui menggunakan metode <code>deserialize()</code> .  Mari kita lihat kodenya sehingga semuanya jatuh pada tempatnya.  Pertama adalah <code>EventStoreRepository</code> memuat <code>EventStoreRepository</code> : <br><br><pre> <code class="bash hljs">app/CQRS/EloquentEventStore/EloquentEventStoreRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(<span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> = EloquentEventStoreModel::<span class="hljs-built_in"><span class="hljs-built_in">where</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid'</span></span>, <span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>)-&gt;get(); <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = []; foreach(<span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> as <span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>) { /*       event_payload,        . */ <span class="hljs-variable"><span class="hljs-variable">$events</span></span>[] = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventSerializer-&gt;deserialize( json_decode(<span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>-&gt;event_payload)); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$events</span></span>; }</code> </pre><br>  Menggunakan fungsi deserialisasi yang sesuai di <code>eventSerializer</code> : <br><br><pre> <code class="bash hljs">app/CQRS/Serializer/EventSerializer.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> serialize( SerializableEvent <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; get_class(<span class="hljs-variable"><span class="hljs-variable">$event</span></span>), <span class="hljs-string"><span class="hljs-string">'payload'</span></span> =&gt; <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;serialize() ); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize( <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;class; <span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;payload; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span>::deserialize(<span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span>); }</code> </pre> <br>  Kesimpulannya, kita akan menggunakan metode pabrik statis <code>deserialize()</code> di <code>LessonWasOpened</code> (kita perlu menambahkan metode ini ke setiap peristiwa) <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php public static <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>-&gt;lessonId); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> new self(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); }</code> </pre> <br>  Sekarang kami memiliki larik semua peristiwa yang baru saja direproduksi relatif terhadap model catatan Entitas kami untuk menginisialisasi keadaan dalam metode <code>initializeState</code> di <code>app/CQRS/EventSouredEntity.php</code> <br><br>  Sekarang jalankan pengujian kami.  Bingo! <br>  Faktanya, saat ini kami tidak memiliki tes untuk memverifikasi kepatuhan dengan aturan domain kami, jadi mari kita tulis: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMoreThan3ClientsCannotBeAddedToALesson</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"george"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"fred"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;setExpectedException( TooManyClientsAddedToLesson::class ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"emma"</span></span>) ); }</code> </pre> <br>  Harap dicatat bahwa kita hanya perlu <code>lessonId</code> - tes ini menginisialisasi ulang kondisi pelajaran selama setiap perintah. <br><br>  Saat ini, kami hanya mentransfer <code>UUID</code> dibuat secara manual, sedangkan pada kenyataannya kami ingin membuatnya secara otomatis.  Saya akan menggunakan paket <code>Ramsy\UUID</code> , jadi mari kita instal dengan <code>composer</code> : <br><br><pre> <code class="plaintext hljs">$&gt; composer require ramsey/uuid</code> </pre> <br>  Sekarang perbarui tes kami untuk menggunakan paket baru: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEntityCreationWithUUIDGenerator</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertInstanceOf( Lesson::class, Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); }</code> </pre><br>  Sekarang pengembang proyek baru dapat melihat kode, lihat <code>App\School\ReadModels</code> , yang berisi sekumpulan model Eloquent, dan menggunakan model ini untuk menulis perubahan pada tabel pelajaran.  Kita bisa mencegah ini dengan membuat kelas <code>ImmutableModel</code> yang memperluas kelas Eloquent Model dan menimpa metode simpan di <code>app/CQRS/ReadModelImmutableModel.php</code> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461899/">https://habr.com/ru/post/id461899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461885/index.html">EDS adalah jenis penipuan lainnya</a></li>
<li><a href="../id461887/index.html">Memasuki Aeronet Episode 2: Dring Homing</a></li>
<li><a href="../id461891/index.html">Bagaimana kami berteman di infrastruktur bank menggunakan ManageIQ</a></li>
<li><a href="../id461895/index.html">Learn While Travel - bagaimana kami melaju pada Hari Analisis Bisnis Eropa pertama</a></li>
<li><a href="../id461897/index.html">Bagaimana kami menjaga stabilitas aplikasi Lamoda</a></li>
<li><a href="../id461901/index.html">Tiga tahun autotests: cara meningkatkan kecepatan dan tidak hanya</a></li>
<li><a href="../id461903/index.html">Musuh misterius: peminjaman kabur</a></li>
<li><a href="../id461905/index.html">Tic Tac Toe, bagian 7: pytest dan Travis CI</a></li>
<li><a href="../id461907/index.html">Analitik produk di studio siklus penuh</a></li>
<li><a href="../id461913/index.html">Kegunaan seluler dalam e-Commerce: analisis toko online TOP-20 di Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>