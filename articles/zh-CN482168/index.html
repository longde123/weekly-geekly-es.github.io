<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏾 👎🏾 🐝 “时钟敲十二点。” 或浏览器中的花环 🍉 🎇 🤪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="假设我们有几个监视器。 我们想将这些显示器用作花环。 例如，使它们同时闪烁。 或者也许根据某种智能算法来同步更改颜色。 而且，如果您在浏览器中进行操作，那么可以将智能手机和平板电脑与此连接。 一切就在眼前。 



 而且，由于我们使用的是浏览器，因此您还可以添加声音设计。 毕竟，如果它足够准确，可...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>“时钟敲十二点。” 或浏览器中的花环</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482168/"> 假设我们有几个监视器。 我们想将这些显示器用作花环。 例如，使它们同时闪烁。 或者也许根据某种智能算法来同步更改颜色。 而且，如果您在浏览器中进行操作，那么可以将智能手机和平板电脑与此连接。 一切就在眼前。 <br><br><img src="https://habrastorage.org/webt/yo/1c/a8/yo1ca85ahnnxg_5crc1hh84n9ng.jpeg"><br><br> 而且，由于我们使用的是浏览器，因此您还可以添加声音设计。 毕竟，如果它足够准确，可以及时同步设备，那么您可以像在一个多声道系统上一样在每个设备上播放声音。 <br><br><hr>  <i>在javascript应用程序中同步Web音频和游戏时钟时会遇到什么情况；</i>  <i>javasctipt中有多少个不同的“小时”（三个！），为什么需要所有这些“小时”，以及猫下的node.js的<a href="http://habr.snowtime.fun/" rel="nofollow">现成应用程序</a> 。</i> <a name="habracut"></a><hr><br><h2> 检查时钟 </h2><br> 对于任何有条件的在线花环，都需要精确的时钟同步。 毕竟，您可以忽略任何（甚至是间歇性的）网络延迟。 为控制命令提供时间戳并在“将来”生成这些命令就足够了。 在客户端上，它们将被缓冲，然后按时同步执行。 <br><br> 或者甚至可以走得更远-采用良好的老式确定性随机算法，并在所有设备上使用一个公共种子（由服务器在连接时发出一次）。 如果将此类种子与准确时间<i>一起</i>使用，则可以完全确定算法在所有设备上的行为。 试想一下：实际上，您不需要网络或服务器来唯一且同步地更改状态。 种子已经预先包含动作的全部（有条件的无限）“视频录制”。 最主要的是确切的时间。 <br><br><img src="https://habrastorage.org/webt/kd/tx/tt/kdtxttvwqoqkb69jvoov077o8vs.gif"><br><hr>  <i>每种方法都有其适用范围。</i>  <i>当然，有了即时用户输入，就什么都不做，剩下的就是“按原样”传输。</i>  <i>但是所有可以计算的都是要计算的。</i>  <i>在实现过程中，我会根据情况使用所有三种方法。</i> <hr><br><h2> 主观“同时” </h2><br> 理想情况下，所有声音都应“同时”听起来-组合设备中最差的一对的相差不超过±10 ms。 您无法从系统时间上获得这种准确性，并且浏览器中不提供使用NTP协议同步时间的标准方法。 因此，我们将驱动我们的同步服务器。 原理很简单：头盔“ pings”并接受带有服务器时间戳的“ pongs”。 如果您连续执行多次，则可以从统计角度上对错误进行平均，并获得平均延迟时间。 <br><br><div class="spoiler">  <b class="spoiler_title">代码：在客户端上计算服务器时间</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pingClientTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// performace.now() time when ping started let pongClientTime = 3; // performace.now() time when pong received let pongServerTime = 20; // server timstamp in pong answer let clientServerRawOffset = pongServerTime - pongClientTime; let pingPongOffset = pongClientTime - pingClientTime; // roundtrip let estimatedPingOffset = pingPongOffset / 2; // one-way let offset = clientServerRawOffset + estimatedPingOffset; console.log(estimatedPingOffset) // 1 console.log(offset); // 18 let sharedServerTime = performace.now() + offset;</span></span></code> </pre> <br></div></div><br><br>  Websocket和基于它的解决方案最适合，因为它们不需要时间来创建TCP连接，并且您可以在两个方向上与其进行“通信”。 当然不是UDP或ICMP，但是比使用HTTP API的常规冷连接要快得多。 因此，请使用socket.io。 那里的一切都很容易： <br><br><div class="spoiler">  <b class="spoiler_title">代码：socket.io实现</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// server socket.on('ping', (pongCallback) =&gt; { let pongServerTime = performace.now(); pongCallback(pongServerTime); }); //client const binSize = 100; let clientServerCalculatedOffset; function ping() { socket.emit('ping', pongCallback); const pingClientTime = performace.now(); function pongCallback(pongServerTime) { const pongClientTime = performace.now(); const clientServerRawOffset = pongServerTime - pongClientTime; const pingPongOffset = pongClientTime - pingClientTime; // roundtrip const estimatedPingOffset = pingPongOffset / 2; // one-way const offset = clientServerRawOffset + estimatedPingOffset; offsets.unshift(offset); offsets.splice(binSize); let offsetSum = 0; offsets.forEach((offset) =&gt; { offsetSum += offset; }); clientServerCalculatedOffset = offsetSum / offset.length(); } }</span></span></code> </pre> <br>  <i>与其计算平均值，不如计算平均值，这将是不错的选择-如果连接不稳定，这将提高准确性。</i>  <i>过滤方法的选择取决于读者。</i>  <i>我故意在这里简化代码，以使用示意图。</i>  <i>我的完整解决方案可以在存储库中找到。</i> <br></div></div><br><br><h2>  performance.now（） </h2><br> 让我提醒您， <code>performance</code>对象是一个提供对高分辨率计时器的访问的API。 比较： <br><br><ul><li>  <b><code>Date.now()</code></b>返回自1970年1月1日以来的毫秒数，并且以<b>整数</b>形式进行计算。 即，仅来自舍入的误差平均为0.5ms。 例如，在一个减法运算<code>ab</code>您最多可能失败“丢失” 2 ms。 另外，从历史上和概念上讲，计时器本身不能保证高精度，并且对于较大的时标工作会变得更加尖锐。 </li><li>  <b><code>performance.now()</code></b>返回<a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="nofollow">自打开网页以来的</a>毫秒数。 <br> 这是一个相对较新的API，专门针对时间间隔的精确测量而“锐化”。 返回<b>浮点值</b> ，理论上讲其精度水平接近于OS本身的功能。 <br></li></ul><br><br> 我认为此信息几乎为所有javascript开发人员所了解。 但并非所有人都知道... <br><br><h2> 幽灵 </h2><br> 由于Spectre在2018年引起了轰动的计时攻击，如果没有其他解决漏洞问题的方法，一切都将变成高分辨率计时器被人为地粗糙化的地步。 从版本60开始的Firefox将此计时器的值四舍五入到毫秒，而Edge甚至更糟。 <br><br> 这是<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="nofollow">MDN</a>所说的： <br><br><blockquote> 时间戳实际上不是高分辨率的。 为了缓解诸如Spectre之类的安全威胁，浏览器当前将结果不同程度地取整。  （Firefox在Firefox 60中开始四舍五入到1毫秒。）某些浏览器可能还会稍微随机化时间戳。 在将来的版本中，精度可能会再次提高； 浏览器开发人员仍在调查这些计时攻击以及如何最好地缓解它们。 </blockquote><br> 让我们运行测试并查看图表。 这是间隔10毫秒的测试结果： <br><br><div class="spoiler">  <b class="spoiler_title">测试代码：一个周期中的时间测量</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3> 边缘 </h3><br><img src="https://habrastorage.org/webt/g2/t2/bs/g2t2bssr-dhq8cbyb95-pwjxclw.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：44.17763.771.0 <br><br><h3>  Date.now（） </h3> 平均间隔：1.0538336052202284 ms <br> 与平均间隔的偏差RMS：0.7547819181245603 ms <br> 间隔中位数：1毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：1.567100970873786 ms <br> 与平均间隔的偏差，RMS：0.6748006785171455 ms <br> 间隔中位数：1.5015000000003056 ms <br></div></div><br><br><h3> 火狐浏览器 </h3><br><img src="https://habrastorage.org/webt/7y/6b/a_/7y6ba_0b_lgehjq2yko_60ip4am.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：71.0 <br><br><h3>  Date.now（） </h3> 平均间隔：1.0168350168350169 ms <br> 与平均间隔的偏差，RMS：0.21645930182417966 ms <br> 间隔中位数：1毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：1.0134453781512605 ms <br> 与平均间隔的偏差，RMS：0.1734108492762375 ms <br> 间隔中位数：1毫秒 <br></div></div><br><br><h3> 镀铬 </h3><br><img src="https://habrastorage.org/webt/zv/_y/pp/zv_yppcegrbidigvmp6npdcwzf0.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：79.0.3945.88 <br><br><h3>  Date.now（） </h3> 平均间隔：1.02442996742671 ms <br> 与平均间隔的偏差，RMS：0.49858684744444 ms <br> 间隔中位数：1毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：0.005555847229948915 ms <br> 与平均间隔的偏差，RMS：0.027497846727194235 ms <br> 间隔中位数：0.0050000089686363935 ms <br></div></div><br><br> 好的，Chrome，放大到1毫秒。 <br><br><img src="https://habrastorage.org/webt/2o/9m/ik/2o9mikwf_owbi8mn1saodrmd_e8.png"><br><br> 因此，Chrome仍在坚持，其<code>performance.now()</code>实现尚未被勒死，步长为0.005毫秒。 在Edge下， <code>performance.now()</code>计时器比<code>Date.now()</code>还要粗糙！ 在Firefox中，两个计时器的毫秒精度相同。 <br><br> 在这一阶段，已经可以得出一些结论。 但是javascript中还有另一个计时器（没有它，我们不能没有）。 <br><br><h2>  WebAudio API计时器 </h2><br> 这是一个略有不同的野兽。 它用于延迟的音频队列。 事实是，音频事件（弹奏音符，管理效果​​）不能依赖于标准的异步javascript工具： <code>setInterval</code>和<code>setTimeout</code>因为它们的误差太大。 这不仅是计时器<i>值</i>的错误（我们之前已经处理过），而且是事件机执行事件的错误。 即使在温室条件下，也已经是5-25毫秒左右。 <br><br><div class="spoiler">  <b class="spoiler_title">扰流器下异步情况的图形</b> <div class="spoiler_text"> 间隔100毫秒的测试结果： <br><br><div class="spoiler">  <b class="spoiler_title">测试代码：异步周期中的时间测量</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3> 边缘 </h3><br><img src="https://habrastorage.org/webt/_z/im/h2/_zimh2thj4w5t2o_ounushbk94m.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：44.17763.771.0 <br><br><h3>  Date.now（） </h3> 平均间隔：25.595959595959595 ms <br> 与平均间隔的偏差，RMS：10.12639235162126 ms <br> 间隔中值：28毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：25.862596938775525 ms <br> 与平均间隔的偏差，RMS：10.123711255512573 ms <br> 间隔中位数：27.027099999999336 ms <br></div></div><br><br><h3> 火狐浏览器 </h3><br><img src="https://habrastorage.org/webt/bm/pn/bs/bmpnbsvv3esgusduj0djwdvazg4.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：71.0 <br><br><h3>  Date.now（） </h3> 平均间隔：1.6914893617021276 ms <br> 与平均间隔的偏差，RMS：0.6018870280772611 ms <br> 间隔中位数：2毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：1.7865168539325842 ms <br> 与平均间隔的偏差，RMS：0.6442818510935484 ms <br> 间隔中位数：2毫秒 <br></div></div><br><br><h3> 镀铬 </h3><br><img src="https://habrastorage.org/webt/ig/my/wf/igmywf_jvwphlqdqm9qac2evy64.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：79.0.3945.88 <br><br><h3>  Date.now（） </h3> 平均间隔：4.7878787878787888，ms <br> 平均间隔偏差，RMS：0.7557553886872682 ms <br> 间隔中位数：5毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：4.783989898979516 ms <br> 与平均间隔的偏差，RMS：0.6483716900974945 ms <br> 中位间隔：4.750000000058208 ms <br></div></div><br></div></div><br><br> 也许有人会记得最早的实验性HTML音频应用程序。 在成熟的WebAudio进入浏览器之前，它们听起来都像是有点醉，马虎。 只是因为他们使用<code>setTimeout</code>作为定序器。 <br><br> 相比之下，现代的WebAudio API可以保证高达0.02 ms的分辨率（基于44100Hz的采样频率进行推测）。 这是由于以下事实：与<code>setTimeout</code>相比，延迟的声音回放使用了不同的机制： <br><br><pre> <code class="javascript hljs">source.start(when);</code> </pre> <br> 实际上，音频样本的任何复制都是“延迟的”。 只是要丢失它“不推迟”，您需要将其推迟到“直到现在”。 <br><br><pre> <code class="javascript hljs">source.start(audioCtx.currentTime);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">关于实时软件生成的音乐</b> <div class="spoiler_text"> 如果您从音符中播放程序合成的旋律，则需要提前将这些音符添加到播放队列中。 这样，尽管计时器受到了所有非基本的限制和不规则，旋律仍将完美流畅地播放。 <br><br> 换句话说，实时合成的旋律不应实时“发明”，而应提前一点。 <br></div></div><br><br><h2> 一个计时器来统治所有人 </h2><br> 由于<code>audioCtx.currentTime</code>非常稳定且准确，因此也许我们应该将它用作相对时间的主要来源？ 让我们再次运行测试。 <br><br><div class="spoiler">  <b class="spoiler_title">测试代码：在一个周期中测量同步时间测量</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); a[i] = audioCtx.currentTime * <span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p, a } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3> 边缘 </h3><br><img src="https://habrastorage.org/webt/rt/xx/u0/rtxxu0ckburybooxuw93uiya7-s.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：44.17763.771.0 <br><br><h3>  Date.now（） </h3> 平均间隔：1.037037037037037 ms <br> 与平均间隔的偏差，RMS：0.6166609846299806 ms <br> 间隔中位数：1毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：1.5447103117505993 ms <br> 与平均间隔的偏差，RMS：0.4390514285320851 ms <br> 间隔中位数：1.5015000000000782 ms <br><br><h3>  audioCtx.currentTime </h3> 平均间隔：2.955751134714949 ms <br> 与平均间隔的偏差，RMS：0.6193645611529503 ms <br> 间隔中位数：2.902507781982422 ms <br><br></div></div><br><br><h3> 火狐浏览器 </h3><br><img src="https://habrastorage.org/webt/rr/v6/ws/rrv6wsi1tmnpdb8yf7y6wmfvyo8.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：71.0 <br><br><h3>  Date.now（） </h3> 平均间隔：1.005128205128205205​​ ms <br> 与平均间隔的偏差，RMS：0.12392867665225249 ms <br> 间隔中位数：1毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：1.00513698630137 ms <br> 与平均间隔的偏差，RMS：0.07148844433269844 ms <br> 间隔中位数：1毫秒 <br><br><h3>  audioCtx.currentTime </h3>  Firefox不会在同步循环中更新音频计时器值 <br><br></div></div><br><br><h3> 镀铬 </h3><br><img src="https://habrastorage.org/webt/yx/wx/rk/yxwxrkmxhv3yzxzpzckvfhouz6y.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：79.0.3945.88 <br><br><h3>  Date.now（） </h3> 平均间隔：1.0207612456747406 ms <br> 与平均间隔的偏差，RMS：0.49870223457982504 ms <br> 间隔中位数：1毫秒 <br><br><h3>  performance.now（） </h3> 平均间隔：0.005414502034674972 ms <br> 与平均间隔的偏差，RMS：0.027441293974958335 ms <br> 中位间隔：0.004999999873689376 ms <br><br><h3>  audioCtx.currentTime </h3> 平均间隔：3.0877599266656963 ms <br> 与平均间隔的偏差，RMS：1.1445555956407658 ms <br> 间隔中位数：2.9024943310650997 ms <br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">扰流器下异步情况的图形</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">测试代码：异步周期中的时间测量</b> <div class="spoiler_text"> 间隔100毫秒的测试结果： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3> 边缘 </h3><br><img src="https://habrastorage.org/webt/3o/sz/az/3oszazaq71kxfdaftgn6v3z23xe.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：44.17763.771.0 <br><br><h3>  Date.now（）： </h3> 平均间隔：24.505050505050505 ms <br> 与平均间隔的偏差：11.513166584195204 ms <br> 间隔中值：26毫秒 <br><br><h3>  performance.now（）： </h3> 平均间隔：24.50935757575754 ms <br> 与平均间隔的偏差：11.679091435527388 ms <br> 间隔中位数：25.525499999999738 ms <br><br><h3>  audioCtx.currentTime： </h3> 平均间隔：24.76005164944396 ms <br> 与平均间隔的偏差：11.311571546205316 ms <br> 间隔中位数：26.121139526367187 ms <br><br></div></div><br><h3> 火狐浏览器 </h3><br><img src="https://habrastorage.org/webt/wf/4n/jn/wf4njn3z7u9uoxluprufhlbctai.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：71.0 <br><br><h3>  Date.now（）： </h3> 平均间隔：1.6875毫秒 <br> 平均间隔偏差：0.6663410663216448 ms <br> 间隔中位数：2毫秒 <br><br><h3>  performance.now（）： </h3> 平均间隔：1.7234042553191489 ms <br> 与平均间隔的偏差：0.6588877688171075 ms <br> 间隔中位数：2毫秒 <br><br><h3>  audioCtx.currentTime： </h3> 平均间隔：10.158730158730123 ms <br> 与平均间隔的偏差：1.4512471655330046 ms <br> 中位间隔：8.707482993195299 ms <br><br></div></div><br><h3> 镀铬 </h3><br><img src="https://habrastorage.org/webt/_s/hd/uh/_shduhzpetwube_gn6kxmwyobiu.png"><br><div class="spoiler">  <b class="spoiler_title">统计资料</b> <div class="spoiler_text"> 浏览器版本：79.0.3945.88 <br><br><h3>  Date.now（）： </h3> 平均间隔：4.585858585858586 ms <br> 与平均间隔的偏差：0.9102125516015199 ms <br> 间隔中位数：5毫秒 <br><br><h3>  performance.now（）： </h3> 平均间隔：4.592424242424955 ms <br> 与平均间隔的偏差：0.719936993603155 ms <br> 间隔中位数：4.605000001902226 ms <br><br><h3>  audioCtx.currentTime： </h3> 平均间隔：10.12648022171832 ms <br> 与平均间隔的偏差：1.4508887886499262 ms <br> 间隔中位数：8.707482993197118 ms <br><br></div></div><br></div></div><br> 好吧，那行不通。 在“外部”，此计时器最不准确。  Firefox不会在循环内更新计时器值。 但总的来说：分辨率为3毫秒，并且抖动更明显。 也许<code>audioCtx.currentTime</code>的值反映了声卡驱动程序在环形缓冲区中的位置。 换句话说，它显示了可以安全延迟播放的最短时间。 <br><br> 怎么办？ 毕竟，我们既需要用于与服务器同步并在屏幕上启动javascript事件的准确计时器，又需要用于声音事件的音频计时器！ <br><br> 事实证明，您需要将所有计时器彼此同步： <br><br><ul><li> 客户端上的客户端<code>audioCtx.currentTime</code>与客户端<code>performance.now()</code> 。 </li><li> 而客户端的<code>performance.now()</code>与<code>performance.now()</code>服务器端。 </li></ul><br><h2> 同步，同步 </h2><br><img src="https://habrastorage.org/webt/f1/ph/o9/f1pho9gss4d40786nszfeicwrog.png" align="right"> 通常，如果考虑一下，这是很有趣的：您可以有两个良好的时间源A和B，每个时间源在输出端都非常粗糙且嘈杂（A'= A + err <sub>A</sub> ; B'= B + err <sub>B</sub> ），以便可以甚至无法单独使用。 但是原始非噪声源之间的差异d可以非常准确地恢复。 <br><br> 由于理想时钟之间的真实时间距离是一个常数，因此要进行n次测量，因此我们将分别减少err次测量误差。 当然，除非时钟以相同的速度运行。 <br><br><h2> 是，未同步 </h2><br> 坏消息是，不，它们的运行速度不同。 我并不是在谈论服务器和客户端上的时间差异，这是可以理解和期望的。 更出乎意料的是： <code>audioCtx.currentTime</code>逐渐与<code>performance.now()</code> <code>audioCtx.currentTime</code> 。 它在客户端内部。 我们可能没有注意到，但是有时在负载下，音频系统可能不会吞噬一小段数据，并且（与环形缓冲区的性质相反），音频时间将相对于系统时间偏移。 发生这种情况的情况并不罕见，它并没有引起很多人的关注：但是，例如，如果您同时在不同的计算机上同时启动两个YouTube视频，那么它们就不会同时停止播放了。 当然，重点不在于广告。 <br><br> 因此，用于稳定和同步的操作。 我们需要<i>定期</i>以服务器时间作为参考重新检查所有时钟。 然后要权衡的是要使用多少个测量值进行平均：越多-越准确，但是<code>audioCtx.currentTime</code>的急剧跳<code>audioCtx.currentTime</code>落入我们过滤值的时间窗口的机会就越大。 然后，例如，如果我们使用分钟窗口，则所有分钟都将经过时间。 过滤器的选择范围很广： <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B6%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">指数</a>过滤器， <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)" rel="nofollow">中值</a> <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%259A%25D0%25B0%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0" rel="nofollow">过滤器</a> ， <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%259A%25D0%25B0%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0" rel="nofollow">卡尔曼过滤器</a>等。 但是无论如何，这种权衡都是有代价的。 <br><br><h2> 时间窗 </h2><br> 在异步循环<code>audioCtx.currentTime</code>与<code>performance.now()</code>同步的情况下，为了不干扰UI，我们可以进行一次测量，例如100 ms。 <br> 假设测量误差err = errA + errB = 1 + 3 = 4 ms <br> 因此，我们可以在1秒内将其减少到0.4毫秒，并在10秒内减少到0.04毫秒。 结果的进一步改善是没有意义的，一个好的过滤窗口将是：1-10秒。 <br><br> 在网络同步的情况下，延迟和错误已经非常重要，但不会出现时间的突然跳动，就像<code>audioCtx.currentTime</code>的情况<code>audioCtx.currentTime</code> 。 而且，您可以让自己积累非常出色的统计数据。 毕竟，ping的err可能长达500毫秒。 而测量本身我们就不会那么频繁了。 <br><br> 在这一点上，我建议停止。 如果有人感兴趣，我很乐意告诉您如何“绘制其余的猫头鹰”。 但是，作为有关计时器的故事的一部分，我认为我的故事结束了。 <br><br> 我想分享我得到的。 都一样，新的一年。 <br><br><h2> 发生什么事了 </h2><br> 免责声明：从技术上讲，这是Habré上的PR网站，但这是一个完全非营利的开源宠物项目，我保证永远不会在该项目上投放广告或以任何其他方式赚钱。 相反，我现在从我的资金中筹集了更多的实例，以求生存。 因此，请好人，不要打扰我，也不要接近我。 这纯粹是很有趣。 <br><br> 新年快乐，哈伯！ <br><br><hr><br><h3>  <a href="http://habr.snowtime.fun/" rel="nofollow">雪地乐趣</a> </h3> 您可以旋转旋钮并控制可视化，音乐和音频效果。 如果您有普通的视频卡，请转到设置并将粒子数设置为100％。 <br><br> 需要WebAudio和WebGL。 <br><br><hr><br><br>  <b>UPD：</b>在macOS Mojave下的Safari中不起作用。 不幸的是，由于缺少Safari本身，因此无法快速确定发生了什么。  iOS似乎正在运行。 <br><br>  <b>UPD2：</b>如果<a href="http://snowtime.fun/" rel="nofollow">snowtime.fun</a>和<a href="http://web.snowtime.fun/" rel="nofollow">web.snowtime.fun</a>没有响应，请尝试新的<a href="http://habr.snowtime.fun/" rel="nofollow"><b>habr</b> .snowtime.fun</a>子域。 他将服务器移至另一个数据中心，并将旧IP缓存在DNS中， <code>expire=1w</code> 。  :( <br><br> 仓库： <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">bitbucket</a> <br> 在撰写本文时，使用了<a href="http://www.freepik.com/" rel="nofollow">macrovector / Freepik</a>插图。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482168/">https://habr.com/ru/post/zh-CN482168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482152/index.html">实时操作系统中的漏洞</a></li>
<li><a href="../zh-CN482154/index.html">为什么用final限制继承？</a></li>
<li><a href="../zh-CN482156/index.html">威尔·库尔特（Will Kurt）采访他的新书《贝叶斯统计-太好了》</a></li>
<li><a href="../zh-CN482162/index.html">数学家找到了一种模式，了解如何避免其出现</a></li>
<li><a href="../zh-CN482166/index.html">机场的狗狗训练服务：您已经被嗅探到</a></li>
<li><a href="../zh-CN482170/index.html">处理器大战。 蓝兔和红龟的故事</a></li>
<li><a href="../zh-CN482176/index.html">@Kubernetes会议在11月29日进行得如何：视频和结果</a></li>
<li><a href="../zh-CN482178/index.html">一名韩国学生的故事得到了部委的队列监控系统奖</a></li>
<li><a href="../zh-CN482182/index.html">如果我为IT中的性别平衡而奋斗，会遇到什么问题？</a></li>
<li><a href="../zh-CN482186/index.html">生活和IT或我辞去上一份工作的年份</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>