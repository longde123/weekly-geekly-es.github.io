<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏽 🚦 🌲 Pengenalan gerakan dengan APDS-9960 👶🏼 🕋 😿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Membaca komentar di artikel saya sebelumnya tentang APDS-9960, di mana itu tentang pengenalan warna dan tingkat cahaya, dua hal menjadi jelas bagi say...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengenalan gerakan dengan APDS-9960</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424947/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/bk/bh/oxbkbhl6uwlr0-1dynm5tppscw0.jpeg" alt="gambar"></div><br>  Membaca komentar di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> saya sebelumnya tentang APDS-9960, di mana itu tentang pengenalan warna dan tingkat cahaya, dua hal menjadi jelas bagi saya: 1) topik pengenalan gerakan menarik dan 2) topik ini tidak diungkapkan. <br><br>  Memang, jika saya mengambil deskripsi dari APDS-9960, maka tanpa mempertimbangkan gerakannya, deskripsi tersebut terlihat agak tidak lengkap.  Jadi saya menemukan waktu luang untuk menjelajahi topik ini juga. <br><br>  Pada artikel ini, saya memberikan Anda gambaran tentang kemampuan pengenalan gerakan yang disediakan oleh sensor APDS-9960. <br><a name="habracut"></a><br>  Artikel ini akan mempertimbangkan mekanisme untuk mengatur sensor, pengumpulan data, pemrosesan dan presentasi.  Anda sendiri dapat melihat betapa mudahnya bekerja dengan gerakan menggunakan APDS-9960. <br><br>  Seperti yang terakhir kali, artikel tersebut akan disertai dengan kode, semua yang terjadi di mana akan dijelaskan secara rinci.  Versi lengkap kode tersedia di akhir artikel. <br><br>  Segera komentar kecil: APDS-9960 tidak memiliki mekanisme pendeteksian isyarat otomatis bawaan;  yaitu, sedemikian rupa sehingga di sini, saya membaca, artinya, register, dan sudah ada kebohongan yang diproses - ini bukan dalam APDS-9960;  dan ini berarti Anda harus menulis algoritma interpretasi isyarat Anda sendiri, yang akan kami lakukan nanti. <br><br>  Secara umum, ini baik dan tidak terlalu baik.  Tidak juga - karena dapat mempersulit studi sensor ini untuk pemula, tetapi bagus, karena, ditambah dengan data perkiraan, Anda dapat, dengan penyempurnaan, bahkan menghasilkan gerakan Anda sendiri dari berbagai jenis dan apa saja. <br><br>  Namun, karena artikel ini hanya memiliki fungsi ikhtisar, kami membatasi diri hanya untuk gerakan dasar UP-DOWN-LEFT-RIGHT. <br><br>  Baiklah, mari kita mulai. <br><br><h3>  Teori </h3><br>  Saya akan membiarkan diri saya sedikit material. <br><br>  Untuk mendapatkan informasi yang diperlukan tentang gerakan dan arah gerakan, APDS-9960 menggunakan LED IR dan empat fotodioda, yang, seperti diilustrasikan dalam gambar di bawah ini, mendeteksi sinyal dalam kisaran near infrared (NIR). <br><br><img src="https://habrastorage.org/webt/__/k4/vq/__k4vqf3yty6sjcshtq77znw_v0.jpeg" alt="gambar"><br><br>  LED IR (LED) memiliki fungsi lampu latar, dan fotodioda (UDLR) mendaftarkan cahaya yang dipantulkan dari "penghalang". <br><br>  Fotodioda terletak pada sensor sedemikian rupa sehingga, tergantung pada arah gerakan "hambatan", fotodioda yang sesuai akan menerima sebagian besar sinyal IR yang dipantulkan pada input dan bagian yang lebih kecil pada output.  Pada saat yang sama, dokumentasi pada APDS-9960 dengan tegas memberi tahu kami bahwa Anda dapat menginterpretasikan arah gerakan dengan mengukur dan membandingkan perbedaan amplitudo dan fase dari sinyal dari fotodioda UDLR. <br><br><img src="https://habrastorage.org/webt/aj/ts/ok/ajtsok_p-tpsaa1cyx5uoy2uonm.jpeg" alt="gambar"><br><br><h3>  Berlatih </h3><br>  Untuk bekerja dengan APDS-9960, dan juga yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir kali</a> , kami akan menggunakan STM32VLDISCOVERY.  Koneksi juga tidak berubah. <br><br>  <u>Konfigurasikan APDS-9960</u> <br><br>  Kami membuat pengaturan awal sensor. <br><br>  Seperti ini: <br><br><div class="spoiler">  <b class="spoiler_title">APDS9960_init</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">APDS9960_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN); i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH); i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN); i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH); }</code> </pre> </div></div><br>  Apa yang sedang terjadi di sini?  Mari kita perbaiki. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN);</code> </pre> <br>  PGAIN (Proximity Gain Control) adalah parameter yang mengontrol penguatan sensitivitas jarak.  Tetapkan nilai 2, yang sesuai dengan empat kali perolehan. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH);</code> </pre> <br>  GPENTH (Gesture Proximity Enter Threshold Register) - parameter ini menetapkan nilai ambang proximity untuk menentukan awal pengenalan gerakan. <br><br>  GEXTH (Gesture Exit Threshold Register), masing-masing, menetapkan nilai ambang untuk menentukan akhir pengenalan gerakan. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN);</code> </pre> <br>  Dalam register GCONF2 (Konfigurasi dua), kami secara eksplisit menetapkan hanya parameter GGAIN (Kontrol Gesture) untuk empat kali nilai perolehan. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH);</code> </pre> <br>  Lampu latar  Secara default, nilai untuk sumber saat ini dari lampu latar IR diatur ke 0, yang sesuai dengan arus 100 mA, ini akan cocok untuk kita - kita tidak akan mengubahnya. <br><br>  Penerangan IR dalam APDS-9960 adalah urutan pulsa dan ditandai dengan parameter register yang sesuai untuk gestur GPULSE (Gesture pulse count and length): GPLEN (Gesture Pulse Length) dan GPULSE (Number Pulsa Gesture), serta PPULSE (Register Proximity Pulse Count Register) perkiraan ): PPLEN (Panjang Proximity Pulse) dan PPULSE (Proximity Pulse Count) mengatur jumlah pulsa dan periode masing-masing pulsa individu. <br><br>  Tentukan bahwa GPLEN dan PPLEN akan mengambil nilai 2 sama dengan 16 μs, dan GPULSE dan PPULSE nilai 9, yang sesuai dengan 10 pulsa. <br><br>  Seperti yang Anda lihat, pengaturan ternyata sedikit lebih rumit daripada yang serupa untuk pengenalan warna dan pencahayaan dari tinjauan APDS-9960 sebelumnya. <br><br>  <u>Membaca data</u> <br><br>  Sekarang kita beralih ke siklus program utama, di mana kita mulai mendaftar dan menafsirkan data dari fotodioda setiap sekarang dan kemudian, dan juga belajar bagaimana membedakan satu gerakan dari yang lain. <br><br>  Hal pertama yang pertama, mari kita mulai APDS-9960 dengan fungsi untuk bekerja dengan gerakan dan zoom. <br><br><pre> <code class="cpp hljs">GesturesSet(GESTURES_START);</code> </pre> <br>  Dan segera kita mulai melacak parameter GVALID.  GVALID (Gesture FIFO Data) adalah parameter dari register GSTATUS (Gesture Status Register), yang, dalam keadaan tidak nol, memberi tahu kami bahwa sensor memiliki data isyarat yang dapat digunakan. <br><br>  Dokumentasi mengajarkan kita bahwa informasi gerakan ada di buffer, di bidang RAM, yang secara umum berukuran 32 x 4 byte. <br><br>  Dalam praktiknya, ukuran aktual buffer ini dapat ditemukan dengan membaca nilai register GFLVL (Gesture FIFO), mis.  menurut pengamatan eksperimental empiris murni saya, GFLVL * 4 diperoleh.  Sesuatu seperti ini: <br><br><img src="https://habrastorage.org/webt/oy/57/ry/oy57ryfaagi3qqrur9htiefckx0.jpeg" alt="gambar"><br><br>  Nah, sebagai berikut dari nama buffer, data di dalamnya disusun dalam urutan First In - First Out.  Artinya, secara kasar, "sebelumnya" sinyal dari masing-masing fotodioda tiba, "lebih tinggi" di GFLVL. <br><br>  Data dari fotodioda (UDLR) dapat dibaca dari Gesture FIFO Register yang sesuai: <br><br>  - GFIFO_U (Gesture FIFO Data, UP) <br>  - GFIFO_D (Gesture Data FIFO, BAWAH) <br>  - GFIFO_L (Isyarat Data FIFO, KIRI) <br>  - GFIFO_R (Isyarat Data FIFO, KANAN) <br><br>  Setelah setiap pembacaan nilai dari register ini, GFLVL dikurangi;  dengan demikian, dengan cara yang baik, perlu membaca seluruh buffer sampai GFLVL mencapai nol. <br><br>  Untuk mendefinisikan gerakan, kita hanya perlu empat byte pertama buffer ini, tidak lebih.  Karena itu, kami hanya akan membacanya. <br><br><pre> <code class="cpp hljs">GestureUp = i2c1_read(APDS9960_GFIFO_U); GestureDown = i2c1_read(APDS9960_GFIFO_D); GestureLeft = i2c1_read(APDS9960_GFIFO_L); GestureRight = i2c1_read(APDS9960_GFIFO_R);</code> </pre><br>  <u>Pengenalan gerakan</u> <br><br>  Untuk menginterpretasikan gerakan seperti apa yang terjadi, kami akan membuat perhitungan sederhana: <br><br><pre> <code class="cpp hljs">GestUpDown = GestureUp-GestureDown; GestLeftRight = GestureLeft-GestureRight;</code> </pre> <br>  Untuk menentukan gerakan mana yang saat ini terjadi, bukan nilai-nilai GestUpDown dan GestLeftRight yang penting bagi kami, tetapi hanya tanda, dengan kata lain, bilangan real. <br><br>  Dengan kata lain, dengan mengambil nilai negatif dan positif dari variabel GestUpDown dan GestLeftRight sebagai input, kami menentukan gerakan mana yang sempurna. <br><br>  Tabel kebenaran untuk variabel GestUpDown dan GestLeftRight ditunjukkan pada gambar di bawah ini. <br><br><img src="https://habrastorage.org/webt/xx/ts/g-/xxtsg-0zw2h7ralowsgsd_8tmoc.jpeg" alt="gambar"><br><br>  Sekarang atur ulang GFLVL: <br><br><pre> <code class="cpp hljs">GesturesSet(GESTURES_STOP);</code> </pre> <br>  ... dan kembali ke awal siklus program utama. <br><br>  Dan sekarang seluruh kode: <br><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_I2C_ADDR 0x39 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_ENABLE 0x80 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GSTATUS 0xAF #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GFLVL 0xAE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Gesture FIFO Register (0xFC – 0xFF): #define APDS9960_GFIFO_U 0xFC #define APDS9960_GFIFO_D 0xFD #define APDS9960_GFIFO_L 0xFE #define APDS9960_GFIFO_R 0xFF #define APDS9960_CONTROL 0x8F #define APDS9960_GPENTH 0xA0 #define APDS9960_GEXTH 0xA1 #define APDS9960_GCONF2 0xA3 #define APDS9960_GPULSE 0xA6 #define APDS9960_PPULSE 0x8E #define GESTURES_START 0x01 #define GESTURES_STOP 0x02 #define DEFAULT_GPENTH 40 // Threshold for entering gesture mode #define DEFAULT_GEXTH 30 // Threshold for exiting gesture mode #define DEFAULT_PGAIN 8 // Proximity Gain Control: 4X #define DEFAULT_GGAIN 0x40 // Gesture Gain Control: 4X #define DEFAULT_PULSE_LENGTH 0x89 // 16us, 10 pulses /* Bit fields */ #define APDS9960_PON 0x01 #define APDS9960_AEN 0x02 #define APDS9960_PEN 0x04 #define APDS9960_WEN 0x08 #define APSD9960_AIEN 0x10 #define APDS9960_PIEN 0x20 #define APDS9960_GEN 0x40 #define APDS9960_GVALID 0x01 int GestUpDown = 0; int GestLeftRight = 0; //----------------------------------------------------------------------- uint8_t i2c1_read(uint8_t addr); void i2c1_write(uint8_t addr, uint8_t data); void I2C1_init(void) { I2C_InitTypeDef I2C_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB| RCC_APB2Periph_AFIO , ENABLE); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); I2C_StructInit(&amp;I2C_InitStructure); I2C_InitStructure.I2C_ClockSpeed = 100000; I2C_InitStructure.I2C_OwnAddress1 = 0x01; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; I2C_Init(I2C1, &amp;I2C_InitStructure); I2C_Cmd(I2C1, ENABLE); } //----------------------------------------------------------------------- void APDS9960_init(void) { i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN); i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH); i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN); i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH); } //----------------------------------------------------------------------- uint8_t i2c1_read(uint8_t addr) { uint8_t data; while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Transmitter); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Receiver); while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)); data = I2C_ReceiveData(I2C1); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); I2C_AcknowledgeConfig(I2C1, DISABLE); I2C_GenerateSTOP(I2C1, ENABLE); while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); return data; } //----------------------------------------------------------------------- void i2c1_write(uint8_t addr, uint8_t data) { I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Transmitter); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_SendData(I2C1, data); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTOP(I2C1, ENABLE); while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {}; } //----------------------------------------------------------------------- void GesturesSet(uint8_t GestSel) { switch (GestSel) { case GESTURES_START: i2c1_write(APDS9960_ENABLE, APDS9960_GEN | APDS9960_PEN | APDS9960_PON); break; case GESTURES_STOP: i2c1_write(APDS9960_ENABLE, APDS9960_PEN | APDS9960_PON); break; default: i2c1_write(APDS9960_ENABLE, APDS9960_GEN | APDS9960_PEN | APDS9960_PON); } } //----------------------------------------------------------------------- int main() { uint8_t GFLVL_buf = 0; uint8_t GSTATUS_buf = 0; uint8_t GestureUp = 0; uint8_t GestureDown = 0; uint8_t GestureLeft = 0; uint8_t GestureRight = 0; I2C1_init(); APDS9960_init(); while (1) { GFLVL_buf = 0; GSTATUS_buf = 0; GestureUp = 0; GestureDown = 0; GestureLeft = 0; GestureRight = 0; GestUpDown = 0; GestLeftRight = 0; GesturesSet(GESTURES_START); GSTATUS_buf = i2c1_read(APDS9960_GSTATUS); if(GSTATUS_buf &amp; APDS9960_GVALID) { GFLVL_buf = i2c1_read(APDS9960_GFLVL); if(GFLVL_buf) { GestureUp = i2c1_read(APDS9960_GFIFO_U); GestureDown = i2c1_read(APDS9960_GFIFO_D); GestureLeft = i2c1_read(APDS9960_GFIFO_L); GestureRight = i2c1_read(APDS9960_GFIFO_R); //Truth table: //UP: GestUpDown(+) | GestLeftRight(+) //DOWN: GestUpDown(-) | GestLeftRight(-) //LEFT: GestUpDown(+) | GestLeftRight(-) //RIGHT: GestUpDown(-) | GestLeftRight(+) GestUpDown = GestureUp-GestureDown; GestLeftRight = GestureLeft-GestureRight; GesturesSet(GESTURES_STOP); } } } }</span></span></span></span></code> </pre><br></div></div><br>  Saya ingin mencatat bahwa mekanisme gerakan APDS-9960 bekerja dengan sangat baik.  Pengakuan stabil, filter yang dibangun di dalam APDS-9960 UV dan IR bekerja dengan baik. <br><br>  Semoga materi ini bermanfaat bagi seseorang.  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424947/">https://habr.com/ru/post/id424947/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424935/index.html">Intisari Desain Makanan, September 2018</a></li>
<li><a href="../id424937/index.html">Acara digital di Moskow dari tanggal 1 hingga 7 Oktober</a></li>
<li><a href="../id424939/index.html">Polymorphic Quine</a></li>
<li><a href="../id424941/index.html">Streaming data dari layanan REST ke antrian MQ</a></li>
<li><a href="../id424945/index.html">Smartphone mengendarai mobil mainan.</a></li>
<li><a href="../id424949/index.html">PHP Digest No. 140 (17 - 30 September 2018)</a></li>
<li><a href="../id424951/index.html">Hore! Itu bukan paranoia</a></li>
<li><a href="../id424955/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 332 (24 - 30 September 2018)</a></li>
<li><a href="../id424957/index.html">Menghasilkan Gambar dari Teks Menggunakan AttnGAN</a></li>
<li><a href="../id424961/index.html">MTA-STS untuk Postfix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>