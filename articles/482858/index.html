<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏻 🤼 🧛🏾 Sensores de ventana inalámbricos caseros: STM32L051 + RFM69 + Android 💲 🕖 🥨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buenas tardes, queridos Khabrovites! Hace unos años, compré un anuncio colorido de zWave e instalé sensores de ventana basados ​​en este protocolo. Se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sensores de ventana inalámbricos caseros: STM32L051 + RFM69 + Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482858/"> Buenas tardes, queridos Khabrovites!  Hace unos años, compré un anuncio colorido de zWave e instalé sensores de ventana basados ​​en este protocolo.  Se conectó un zWave-Stick USB al servidor doméstico, que desempeñaba el papel de un controlador, se escribió un pequeño módulo Java que recibió datos de este controlador y se escribió una pequeña aplicación para Android que mostraba maravillosamente el estado de todos los sensores.  Las baterías están insertadas, los sensores están registrados en el controlador, todo funcionó.  Pero después de un par de meses hubo una terrible decepción.  En primer lugar, estos sensores zWave funcionan según el principio de "enviar un mensaje y quedarse dormido sin esperar la confirmación".  En mi caso, esto condujo al hecho de que la señal de los sensores más lejanos del controlador simplemente no llegó al controlador.  Incluso la instalación de un repetidor zWave adicional no ayudó.  En segundo lugar, agotaron la batería tan rápido que después de unos seis meses, todos los sensores dejaron de funcionar.  La razón es que se despertaban cada hora para informar al controlador de su condición.  Desactivar o cambiar esta opción no funcionó, ya que el software estándar categóricamente no lo permitió.  Después de dos años de tormento con esta tecnología cruda, poco confiable y poco amigable, decidí que tenía suficiente.  Pero en lugar de guardar todo y tirarlo a la basura, tuve la idea de dejar los estuches, pero cambiar la electrónica en ellos.  La elección recayó en un transceptor RFM69 bastante simple (433 MHz), sobre la base de lo cual fue posible hacer una placa para el sensor y un controlador conectado a través de USB al servidor.  El nuevo sistema ya ha estado en funcionamiento durante 5 meses, la fiabilidad es cercana al 100% (pero todavía hubo algunas fallas), las baterías aún no parecen estar agotadas.  Es decir, ya es visible que se han eliminado todas las deficiencias del sistema antiguo basado en zWave, y quiero compartir los detalles técnicos de este artículo, vea la imagen. <br><br><img src="https://habrastorage.org/webt/n-/gz/rd/n-gzrd4pxnz2h38utebhqhtakjg.png"><br><br>  A quién le importa, por favor, debajo del gato. <br><a name="habracut"></a><br>  Me parece que zWave en mi caso resultó inoperante por dos razones: la casa tiene dos pisos con pisos de concreto reforzado y un área grande (es decir, una eliminación significativa de algunos sensores del controlador).  Bueno, fallas en el software propietario, que no permitieron desactivar el despertar periódico de los sensores, lo que condujo a una descarga rápida de la batería.  Cuando se hizo evidente que no estaba en camino con zWave, comencé a buscar otras opciones que pudieran introducirse en las mismas carcasas de sensores. <br><br>  Mi primer prototipo de sensores se basó en el ESP8266.  El controlador: sobre la base de mi pago sobre el que ya <a href="https://habr.com/en/post/413101">escribí en Habré</a> .  El sistema incluso funcionó como un prototipo, pero tuve que abandonarlo por dos razones.  La primera razón es la misma: en la casa había rincones con un nivel muy bajo de señal WiFi, lo que condujo a un tiempo de activación muy largo del ESP8266 al despertar y, como resultado, a una fuerte descarga de la batería.  Aunque admito que simplemente no sé cómo cocinar esto ESP8266 (artículos <a href="https://habr.com/ru/post/480316">como este</a> confirman esta tesis).  Pero la segunda razón fue más seria.  Como decidí dejar no solo la carcasa, sino también el compartimento de la batería, me limité a una batería CR123A, que es de 3.0 voltios.  Es decir, el precio y la complejidad del sensor aumentaron debido al aumento del convertidor CC / CC.  Aunque <a href="https://habr.com/ru/post/304936">hay un artículo maravilloso</a> sobre este tema en Habré.  Pero, de todos modos, estas dos razones han superado y rechacé ESP8266. <br><br>  El segundo prototipo fue conectado.  Hice un prototipo tanto del sensor como del controlador USB, agregué un módulo de servidor para que entendiera este controlador además del zWave-Stick.  Hubo una idea de tirar gradualmente los cables y el sensor tras sensor para cambiar la placa zWave a una cableada.  Pero al final, no eligió paredes y este prototipo también se descartó. <br><br>  Luego decidió mirar hacia los módulos de radio a 433 y 868 MHz y ordenó varios módulos para experimentos: <a href="https://www.sparkfun.com/products/13910" rel="nofollow">RFM69HCW</a> , <a href="https://www.mouser.de/datasheet/2/21/A110LR09A_ProductBrief-1511797.pdf" rel="nofollow">A110LR09A</a> y <a href="https://www.mouser.de/datasheet/2/268/70651A-60467.pdf" rel="nofollow">MRF89XAM8A</a> .  En términos de tamaño del módulo, precio y también debido a la disponibilidad de ambas bibliotecas y <a href="https://learn.sparkfun.com/tutorials/rfm69hcw-hookup-guide" rel="nofollow">buenos ejemplos, me</a> decidí por RFM69HCW, que formó la base del sistema. <br><br>  El sistema tiene solo cuatro componentes: <br><br><ul><li>  sensores inalámbricos (433 MHz, batería CR123A 3.0V), </li><li>  controlador de red (433 MHz, alimentado por USB desde el servidor) </li><li>  el servidor (sobre el cual ya escribí sobre Habré <a href="https://habr.com/en/post/268197">en este artículo</a> ) y el módulo del programa del servidor </li><li>  cliente móvil (aplicación de Android) </li></ul><br>  A continuación describiré cada módulo en detalle, y al final daré estadísticas sobre el funcionamiento del sistema durante los últimos meses de funcionamiento. <br><br><h3>  Sensores </h3><br>  Los sensores utilizan el <a href="https://www.sparkfun.com/products/13910" rel="nofollow">módulo de</a> radio <a href="https://www.sparkfun.com/products/13910" rel="nofollow">RFM69HCW</a> .  Tiene un amplio rango de voltaje de funcionamiento (1.8V-2.4V 17dBm, 2.4V-3.6V 20dBm) y se controla a través de SPI.  Es decir, necesitas un microcontrolador.  Hace algún tiempo, me familiaricé con la serie STM32L y pedí el STM32L051 para experimentos.  Me sobornó como una pequeña corriente en modo de suspensión (0.27 μA), y el voltaje de funcionamiento, casi idéntico al voltaje del módulo de radio (1.65V-3.6V).  Más bajo precio. <br><br>  Resultó el siguiente esquema: <br><br><img src="https://habrastorage.org/webt/0b/xx/kb/0bxxkbtvavy113lz23izewdi4yk.png" alt="imagen"><br><br>  La tensión de alimentación tanto del microcontrolador como del módulo de radio es tal que pueden alimentarse directamente desde el elemento CR123A.  STM32L051 tiene una referencia de voltaje interno conectada al canal 17 del ADC, así como el valor de calibración de esta fuente, que le permite medir el valor actual del voltaje de suministro VDD.  El módulo de radio está conectado a la alimentación a través del dispositivo de campo Q1, que le permite controlar su alimentación desde el microcontrolador. <br><br>  El modo de suspensión se implementa transfiriendo el microcontrolador a "En espera".  En este modo, el STM32L051 tiene un núcleo deshabilitado, casi todos los periféricos y un regulador de voltaje interno, que asegura el consumo al nivel de 0.29 μA (con el reloj en tiempo real deshabilitado).  Pero en este modo hay una característica: el microcontrolador se activa solo a lo largo del borde ascendente de la señal en el pin WKUP (A0).  Como se usa un interruptor magnético, que está activado / desactivado (cerrado o abierto), necesita un pequeño bloque que genere un pulso de corta duración tanto al cerrar como al abrir un contacto magnético.  Este pulso se alimenta a la entrada A0 del microcontrolador y lo despierta.  Tal convertidor se implementa en el chip exclusivo IC3 de la serie 74AUP de eficiencia energética (74AUP1G86), que opera en el rango de voltaje de 0.8V-3.6V y consume 0.2 μA.  Por lo tanto, el consumo total en el modo de reposo debe ser de alrededor de 0,5 μA, lo que se confirma mediante mediciones en un sensor completamente ensamblado. <br><br>  Cuando el microcontrolador se despierta, primero mide el voltaje de suministro y, si es inferior a 1,8 voltios, entonces no es el destino: el transmisor no se puede encender y el microcontrolador se queda dormido. <br><br>  Si el voltaje de la batería es superior a 1,8 voltios, el microcontrolador se enciende e inicializa el módulo de radio, transfiere el estado al controlador de red y espera la confirmación.  El paquete de datos incluye un número único de paquete de 32 bits (evento), voltaje de la batería, temperatura, estado de contacto magnético, byte de control (CRC7).  En caso de confirmación exitosa, el microcontrolador se duerme nuevamente.  Si no, envía el estado nuevamente, pero un máximo de 10 veces.  Establecí este límite para que el sensor no intente esperar indefinidamente una respuesta en una situación en la que el controlador de red simplemente está apagado.  El último número de evento único transmitido se almacena en la EEPROM interna del microcontrolador. <br><br>  Durante la transferencia de datos, el microcontrolador parpadea un LED (sin él).  El LED se enciende mediante PWM, donde el ciclo de trabajo depende del valor de voltaje actual, lo que le permite tener casi el mismo brillo en casi todo el rango de voltaje de funcionamiento. <br><br>  Los tableros están diseñados en EagleCAD, el diseño del tablero <a href="https://github.com/mkulesh/stm32WindowSensor/tree/master/pcb" rel="nofollow">está disponible aquí</a> .  Los tableros son de doble cara: el microcontrolador y su arnés se encuentran en la parte superior hacia el marco de la ventana, y el módulo de radio y el LED están en la parte inferior hacia la habitación.  Pedí en China, me solde en un horno de cocina convencional (capa superior) y un secador de pelo (capa inferior). <br><br><img src="https://habrastorage.org/webt/rj/io/9l/rjio9lhfs3psrwyw8_xefn1lcmi.jpeg" alt="imagen"><br><br>  El módulo de radio necesita una antena.  Esto es solo un trozo de alambre de 164 mm de largo. <br><br>  Después de la instalación, cada sensor debe ser programado, para lo cual se proporciona un conector SWD.  Dejé los contactos restantes en el tablero para posibles experimentos en el futuro. <br>  El firmware está escrito en C ++, parte del código se lleva a cabo en clases básicas bastante universales que encapsulan las llamadas a la biblioteca ST HAL.  El código fuente <a href="https://github.com/mkulesh/stm32WindowSensor/tree/master/src" rel="nofollow">está aquí</a> .  Para el desarrollo, se utilizó System Workbench para STM32.  El tamaño del archivo de firmware binario final es de 22 kB. <br><br>  Y aquí está el sensor en el caso: <br><br><img src="https://habrastorage.org/webt/91/fx/ap/91fxapzu7uwnpr0wp2cjydbpwaa.jpeg" alt="imagen"><br><br>  Dependiendo de la posición del sensor, para algunos sensores dejé la antena afuera (contra el fondo del marco blanco, sin embargo, no es visible), y para algunos sensores doblé el cable dentro del marco y lo metí completamente dentro de la carcasa. <br><br>  En aras del interés, calculé el costo de los componentes para un sensor (a los precios del catálogo de Mouser, el precio y el precio total en euros) <br><table cellspacing="0" border="0"><tbody><tr><td align="left">  <b><font>Artículo</font></b> </td><td align="left">  <b><font>Descripción</font></b> </td><td align="left">  <b><font>Valor</font></b> </td><td align="left">  <b><font>Número de MOUSER</font></b> </td><td align="left">  <b><font>Cantidad</font></b> </td><td align="left">  <b><font>Costo</font></b> </td></tr><tr><td align="left">  <font>IC3</font> </td><td align="left">  <font>O exclusivo</font> </td><td align="left">  <font>1G86</font> </td><td align="left">  <font>771-74AUP1G86GW-G</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0.254</font> </td></tr><tr><td align="left">  <font>IC1</font> </td><td align="left">  <font>Microcontrolador</font> </td><td align="left">  <font>STM32L051</font> </td><td align="left">  <font>511-STM32L051K6T6</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>2,14</font> </td></tr><tr><td align="left">  <font>SV1</font> </td><td align="left">  <font>Conector</font> </td><td align="left">  <font>Swd</font> </td><td align="left">  <font>68602-406HLF</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0,157</font> </td></tr><tr><td align="left">  <font>LED1</font> </td><td align="left">  <font>LED 3 mm</font> </td><td align="left">  <font>3mm</font> </td><td align="left">  <font>630-HLMP-K155</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0.351</font> </td></tr><tr><td align="left">  <font>Q1</font> </td><td align="left">  <font>P-mosfet</font> </td><td align="left">  <font>BSH205</font> </td><td align="left">  <font>771-BSH205G2R</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0.276</font> </td></tr><tr><td align="left">  <font>S1</font> </td><td align="left">  <font>Contacto magnético</font> </td><td align="left">  <font>ORD211-0810</font> </td><td align="left">  <font>876-ORD211-0810</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0.625</font> </td></tr><tr><td align="left">  <font>IC2</font> </td><td align="left">  <font>Módulo de radio RFM69HCW</font> </td><td align="left">  <font>RFM69HCW</font> </td><td align="left">  <font>474-COM-13910</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>5.36</font> </td></tr><tr><td align="left">  <font>C1, C2, C3, C6</font> </td><td align="left">  <font>Condensador SMD</font> </td><td align="left">  <font>0.1uF</font> </td><td align="left">  <font>80-C0805C104J5RAC</font> </td><td align="left">  <font>4 4</font> </td><td align="left">  <font>0.1</font> </td></tr><tr><td align="left">  <font>C5</font> </td><td align="left">  <font>Condensador SMD</font> </td><td align="left">  <font>0.4nF</font> </td><td align="left">  <font>C0805C471K8HACTU</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0,021</font> </td></tr><tr><td align="left">  <font>C4</font> </td><td align="left">  <font>Condensador SMD (tantalio)</font> </td><td align="left">  <font>47uF</font> </td><td align="left">  <font>581-TAJR225K016RNJ</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0,333</font> </td></tr><tr><td align="left">  <font>R1</font> </td><td align="left">  <font>Resistencia SMD</font> </td><td align="left">  <font>10K</font> </td><td align="left">  <font>660-RK73H2ATTDD1002F</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0,01</font> </td></tr><tr><td align="left">  <font>R10</font> </td><td align="left">  <font>Resistencia SMD</font> </td><td align="left">  <font>330</font> </td><td align="left">  <font>660-RK73H2ATTDD3300F</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0,01</font> </td></tr><tr><td align="left">  <font>R3, R4, R6, R7, R8, R11</font> </td><td align="left">  <font>Resistencia SMD</font> </td><td align="left">  <font>47K</font> </td><td align="left">  <font>660-RK73H2ATTDD4702F</font> </td><td align="left">  <font>6 6</font> </td><td align="left">  <font>0,06</font> </td></tr><tr><td align="left">  <font>R5</font> </td><td align="left">  <font>Resistencia SMD</font> </td><td align="left">  <font>56</font> </td><td align="left">  <font>660-RK73H2ATTD56R0F</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0,013</font> </td></tr><tr><td align="left">  <font>R9</font> </td><td align="left">  <font>Resistencia SMD</font> </td><td align="left">  <font>56 millones</font> </td><td align="left">  <font>603-RC0805JR-0756ML</font> </td><td align="left">  <font>1</font> </td><td align="left">  <font>0,037</font> </td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">  <b><font>9,748</font></b> </td></tr></tbody></table><br>  Por cierto, resultó exactamente tres veces más barato que el sensor zWave original.  Aunque esto es solo el costo de las piezas, excluyendo el caso.  Pero, en mi opinión, en el comercio minorista, los sensores zWave son excesivamente caros. <br><br><h3>  Controlador de red </h3><br>  Para el controlador, se utilizaron el mismo módulo de radio y el mismo microcontrolador que para los sensores.  Esto permitió reutilizar la mayor parte del código de firmware.  Para el controlador, elegí este factor de forma de la placa para usar el estuche ya preparado de Raspberry Pi.  En comparación con el sensor, se agregaron un conector de antena externa y un circuito USB basado en el aislador FT232RL y SI-8621.  Por supuesto, en cambio, uno podría tomar un STM32 con USB a bordo.  Pero luego, en primer lugar, sería necesario separar el código del firmware y, en segundo lugar, realizar la implementación del software del propio USB.  La opción con un FT232RL externo, aunque es más costosa, es más confiable y más rápida de implementar.  El resultado es el <a href="https://github.com/mkulesh/stm32WindowSensor/tree/master/pcb" rel="nofollow">siguiente esquema</a> : <br><br><img src="https://habrastorage.org/webt/wh/ij/_k/whij_k04j8jqetojnlz0hblpnom.png" alt="imagen"><br><br>  Y en forma ensamblada resultó así: <br><br><img src="https://habrastorage.org/webt/f2/-4/io/f2-4iog6apig6hfmq-6zhhxmzno.jpeg" alt="imagen"><br><br><img src="https://habrastorage.org/webt/dp/gg/cu/dpggcuqsrdegbwobtujrbf1rlck.jpeg" alt="imagen"><br><br>  El microcontrolador no se pone en suspensión aquí, el módulo de radio funciona para la recepción, pero después de recibir con éxito un paquete de cualquiera de los sensores, el módulo pasa al modo de transmisión y envía un acuse de recibo.  Además, cualquier paquete recibido con éxito se transmite a través de USB al servidor.  El formato del paquete es una cadena de valores separados por el símbolo ";": <br>  GW; 3; 12; -57; 0; 146; 30; 18 <br>  donde: <br><br><ul><li>  La primera posición es la etiqueta del paquete (siempre "GW") </li><li>  segunda posición - tipo de datos (estado del sensor o código de error) </li><li>  tercera posición - número de sensor </li><li>  cuarta posición: calidad de la señal en el lateral del controlador de red (RFM69HCW conserva la calidad de la señal durante la recepción y le permite interrogarla cuando finaliza la recepción) </li><li>  quinta posición - estado de la ventana (0 abierto, 1 cerrado) </li><li>  sexta posición: un número único del paquete (evento) del sensor.  Este número le permite controlar en el lado del servidor si todos los eventos fueron recibidos por el servidor o si uno o más eventos se perdieron. </li><li>  séptima posición - voltaje actual de la batería (30 corresponde a 3.0V) </li><li>  la última, octava posición es la temperatura del sensor interno del microcontrolador.  Todavía no he descubierto cómo usarlo </li></ul><br>  El código fuente para el firmware está <a href="https://github.com/mkulesh/stm32WindowSensor/tree/master/src" rel="nofollow">en el mismo lugar que para el sensor</a> .  Tienen un archivo principal común y una biblioteca común de clases base.  La opción de firmware (sensor o controlador) se selecciona utilizando la directiva define en el archivo main.cpp. <br><br>  El costo del controlador de red es mayor debido al circuito USB, la antena y los conectores adicionales.  Pero este aditivo se puede descuidar, ya que solo hay un controlador.  Pero incluso con este suplemento, también resultó ser tres veces más barato que el zWave-Stick, que antes estaba en su lugar. <br><br><h3>  Módulo de servidor </h3><br>  El controlador de red está conectado a un servidor que ejecuta CentOS 7. El servidor ejecuta un programa escrito en Java.  Y en su estructura, implementación y tareas, el programa es bastante simple: <br><br><ul><li>  Utilizando una biblioteca <a href="http://rxtx.qbang.org/wiki/index.php/Main_Page" rel="nofollow">RxTx</a> muy antigua y que aparentemente ya no es compatible, se <a href="http://rxtx.qbang.org/wiki/index.php/Main_Page" rel="nofollow">supervisa</a> el puerto USB especificado en la configuración (en mi caso / dev / ttyUSB0).  Por el momento, esta es la parte menos optimizada de todo el sistema, ya que la biblioteca carga mucho el procesador del servidor. </li><li>  Si se reciben datos del puerto USB, se registran en un archivo de registro y se almacenan en la clase de estado del sensor.  Cuando reinicia el servidor, se pierde el estado.  Para restaurarlo, debe recorrer la casa y abrir y cerrar manualmente todas las ventanas.  Este es probablemente el mayor inconveniente de mi sistema, pero conscientemente me negué a sondear periódicamente los sensores para ahorrar baterías. </li><li>  La aplicación también es un pequeño servidor TCP / IP y escucha en el puerto TCP / IP especificado en la configuración.  En este puerto, puede aceptar conexiones desde un cliente móvil. </li><li>  Si el cliente móvil se conecta al servidor, envía el estado actual de todos los sensores.  Usando mensajes periódicos de heartbit, el servidor también monitorea la actividad de la conexión. </li><li>  El servidor y el cliente móvil intercambian mensajes en formato XML.  Estos mensajes se implementan en forma de una pequeña <a href="https://github.com/mkulesh/stm32WindowSensor/tree/master/zNetMonitor/common" rel="nofollow">biblioteca Java</a> , que se comparte tanto en el lado del servidor como en el lado de la aplicación móvil de Android. </li><li>  Aunque esto no tiene mucho sentido, por razones de interés, agregué la función de autorizar un cliente móvil a través de IMEI, así como el cifrado AES de mensajes entre el servidor y el cliente utilizando una clave cosida en el código fuente (paquete javax.crypto Java).  Pero esto es solo para el experimento, ya que el puerto TCP / IP de este módulo de servidor solo es accesible desde la red interna y no es visible desde el exterior.  Aunque, si quiero abrir este puerto al gran mundo, ahora no será tan aterrador hacerlo. </li></ul><br>  A quién le importa, el código fuente del módulo del servidor está <a href="https://github.com/mkulesh/stm32WindowSensor/tree/master/zNetMonitor/server" rel="nofollow">aquí</a> . <br><br><h3>  Cliente móvil (aplicación de Android) </h3><br>  No escribirá mucho aquí, a pesar de que esta aplicación es el resultado final de todo el proyecto.  Esta es una aplicación Java estándar y muy simple con tres pestañas: el estado de las ventanas del primer piso, el estado del segundo piso y una pequeña telemetría del servidor (vea el <a href="https://github.com/mkulesh/stm32WindowSensor/tree/master/zNetMonitor/app" rel="nofollow">código fuente aquí</a> ): <br><br><img src="https://habrastorage.org/webt/j5/hz/hd/j5hzhduedoxedwhuuhrpe0e4s8e.png" alt="imagen"><br><br>  Los gráficos se basan en un conjunto de archivos SVG, que se apilan uno encima del otro según el estado de los sensores.  Se admite una pulsación larga en el área de cada ventana, de acuerdo con la cual se muestra una pista con la hora a la que se abrió esta ventana: <br><br><img src="https://habrastorage.org/webt/4e/_z/42/4e_z42j_o2j11j7tl9lzzefeffi.png" alt="imagen"><br><br>  En principio, nada le impide agregar un icono de batería a esta información sobre herramientas, pero sus manos aún no lo han alcanzado. <br><br><h3>  Experiencia operativa </h3><br>  "Cada estornudo" se registra en un archivo de registro en el lado del servidor.  El análisis de estos archivos en los últimos 5 meses nos permite comprender con un poco más de detalle cómo se siente este sistema. <br><br>  El análisis es muy simple: simplemente grep en la carpeta de archivos de registro en el servidor. <br><br>  ¿Cuántos errores hubo en la transmisión de datos en el canal de radio?  Durante 5 meses, se registraron 8 errores cuando el mensaje se recibió en el tamaño incorrecto y 25 errores en el CRC incorrecto.  En ambos casos, no puede decir directamente qué sensor tuvo problemas, ya que el paquete de datos en este caso está completamente dañado.  Dado que el controlador de red no confirma la recepción de datos en todos estos casos, el sensor debe enviar los datos de una manera nueva, que en la mayoría de los casos corrige estos errores. <br><br>  Y aquí hay una tabla resumen sobre el funcionamiento de los sensores durante 5 meses. <br><table cellspacing="0" border="0"><tbody><tr><td align="center">  <b><font>Piso</font></b> </td><td align="center">  <b><font>Sensor</font></b> </td><td align="center">  <b><font>Cantidad</font></b> <b><font><br></font></b>  <b><font>De eventos</font></b> </td><td align="center">  <b><font>De los perdidos</font></b> <b><font><br></font></b>  <b><font>De eventos</font></b> </td><td align="center">  <b><font>Voltaje</font></b> <b><font><br></font></b>  <b><font>Las pilas</font></b> </td><td align="center">  <b><font>Mediana</font></b> <b><font><br></font></b>  <b><font>Poder</font></b> <b><font><br></font></b>  <b><font>Señal</font></b> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>10</font> </td><td align="center">  <font>105</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font color="#800000">3.1</font> </td><td align="center">  <font>-66</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>11</font> </td><td align="center">  <font>52</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-70</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>12</font> </td><td align="center">  <font>122</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-61</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>13</font> </td><td align="center">  <font>89</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-74</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>14</font> </td><td align="center">  <font>2573</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-68</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>15</font> </td><td align="center">  <font>261</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-60</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>16</font> </td><td align="center">  <font>543</font> </td><td align="center">  <font color="#800000">2</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-70</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>17</font> </td><td align="center">  <font>156</font> </td><td align="center">  <font color="#800000">2</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-74</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>18 años</font> </td><td align="center">  <font>177</font> </td><td align="center">  <font color="#800000">2</font> </td><td align="center">  <font>3.2</font> </td><td align="center">  <font>-68</font> </td></tr><tr><td align="center">  <font>1</font> </td><td align="center">  <font>19</font> </td><td align="center">  <font>384</font> </td><td align="center">  <font color="#800000">3</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-56</font> </td></tr><tr><td align="center">  <font>2</font> </td><td align="center">  <font>3</font> </td><td align="center">  <font>368</font> </td><td align="center">  <font color="#800000">2</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-62</font> </td></tr><tr><td align="center">  <font>2</font> </td><td align="center">  <font>4 4</font> </td><td align="center">  <font>86</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-71</font> </td></tr><tr><td align="center">  <font>2</font> </td><td align="center">  <font>5 5</font> </td><td align="center">  <font>521</font> </td><td align="center">  <font color="#800000">2</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-59</font> </td></tr><tr><td align="center">  <font>2</font> </td><td align="center">  <font>6 6</font> </td><td align="center">  <font>115</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-62</font> </td></tr><tr><td align="center">  <font>2</font> </td><td align="center">  <font>7 7</font> </td><td align="center">  <font>316</font> </td><td align="center">  <font color="#800000">2</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-63</font> </td></tr><tr><td align="center">  <font>2</font> </td><td align="center">  <font>8</font> </td><td align="center">  <font>419</font> </td><td align="center">  <font color="#800000">1</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-60</font> </td></tr><tr><td align="center">  <font>2</font> </td><td align="center">  <font>9 9</font> </td><td align="center">  <font>89</font> </td><td align="center">  <font>0 0</font> </td><td align="center">  <font>3,3</font> </td><td align="center">  <font>-68</font> </td></tr></tbody></table><br>  El sensor n. ° 10 se congela una vez.  Esto aparentemente condujo a una disminución significativa en el voltaje de la batería.  La razón de la congelación aún no está clara.  Se cuelga de nuevo, tienes que resolverlo. <br><br>  El sensor n. ° 14 está instalado en la puerta frontal, por lo que tiene una gran cantidad de respuestas.  Pero una cantidad tan grande de viajes aún no ha afectado el voltaje de la batería. <br><br>  Un evento perdido es cuando el sensor intentó enviar un estado, pero el servidor no lo confirmó.  Todos los eventos perdidos se deben al hecho de que apagué el servidor durante aproximadamente medio día para la limpieza. <br><br>  La columna Median Strength Signal Strength muestra el valor medio de RSSI (en dBm), donde se obtiene cada valor individual después de recibir cada paquete.  El sensor con la mejor señal (No. 19, -56 dBm) se encuentra a una distancia de 2 metros en visibilidad directa desde el controlador de red, pero la antena en este sensor está plegada con un marco dentro de la carcasa.  El controlador de red en sí está ubicado en la planta baja.  Sin embargo, la señal de los sensores del segundo piso es muy buena.  Esto se debe al hecho de que en todos los sensores del segundo piso, la antena se retira de la carcasa del sensor. <br><br><h3>  En lugar de un epílogo </h3><br>  Por un lado, me alegro de que por mi cuenta, como hobby, haya resultado desde cero diseñar, ensamblar y ejecutar un sistema de este nivel.  Y aún más contento de que funcione mejor que el sistema "patentado" basado en la tecnología zWave hype.  También hay espacio para desarrollar y mejorar este sistema.  Solo me corroen las pequeñas dudas.  Es decir, que una persona sin una educación eléctrica especializada recolecta en su rodilla algo que funciona de manera más confiable que los productos de marca conocidos en los círculos estrechos de las marcas IOT.  Probablemente, el progreso giró en alguna dirección equivocada. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482858/">https://habr.com/ru/post/482858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482846/index.html">AirPods Pro, Apple TV + y mucho dinero: por qué las acciones de Apple alcanzaron un precio récord</a></li>
<li><a href="../482848/index.html">Live bot, parte 2</a></li>
<li><a href="../482850/index.html">Perspectivas de los biocombustibles en la aviación.</a></li>
<li><a href="../482852/index.html">La era del audio compacto: cómo llegaron las cintas a los automóviles</a></li>
<li><a href="../482856/index.html">Extraño Divino</a></li>
<li><a href="../482860/index.html">Fui jefe de relaciones internacionales en Google. Por eso me fui</a></li>
<li><a href="../482862/index.html">¿Hay un GameDev en Sakhalin? 1.V</a></li>
<li><a href="../482864/index.html">Videovigilancia en el hogar. Esquema de mantener un archivo de video sin un registrador casero</a></li>
<li><a href="../482866/index.html">¿Vale la pena comprar Bitcoin el próximo año y cuánto costará?</a></li>
<li><a href="../482870/index.html">Cómo compré una computadora portátil bloqueada en eBay y traté de hacer mi AntiTheft basado en IntelAMT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>