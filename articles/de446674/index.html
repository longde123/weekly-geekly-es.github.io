<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèø üëÉüèø üòâ Wir modellieren den MUSIC-Algorithmus zur Bestimmung der Ankunftsrichtung einer elektromagnetischen Welle ‚úàÔ∏è üßùüèæ üòè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 


 Ich werde meine Einf√ºhrung von weitem beginnen. Es war einmal, dass Ihr bescheidener Diener im fernen Jahr 2016-2017 einen sechsmonatigen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir modellieren den MUSIC-Algorithmus zur Bestimmung der Ankunftsrichtung einer elektromagnetischen Welle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446674/"><p><img src="https://media.moddb.com/cache/images/groups/1/3/2392/thumb_620x2000/music-cats.jpg" alt="Aaspcats"></p><br><h2 id="predislovie">  Vorwort </h2><br><p>  Ich werde meine Einf√ºhrung von weitem beginnen.  Es war einmal, dass Ihr bescheidener Diener im fernen Jahr 2016-2017 einen sechsmonatigen Schulungskurs in der fernen Stadt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ilmenau</a> (Deutschland) absolvierte, wo er das Masterstudium <strong>Kommunikation und Signalverarbeitung</strong> (im Gro√üen und Ganzen) erfolgreich abschloss.  Das Programm war nicht einfach, aber jetzt ist es sogar angenehm, sich daran zu erinnern.  Manchmal ... </p><a name="habracut"></a><br><p>  Am Ende dieser Ausbildung hatte ich neben dem Diplom noch einige verschiedene Materialien zur Hand, die ich f√ºr falsch hielt, nicht zu teilen. </p><br><p>  Eines dieser Materialien liegt vor Ihnen. </p><br><p>  <strong>Welche Ziele habe ich bei der Vorbereitung des Seminars verfolgt</strong> : </p><br><ol><li>  √ºber einige bereits etablierte, ‚Äûintelligente‚Äú Ans√§tze zum Thema Antennenarrays sprechen, die am besten zug√§nglich sind, und dies auf Russisch; </li><li>  F√ºhren Sie eine kleine Simulation in der <strong><em>Sprache Python 3 durch</em></strong> , um andere Funkingenieure dazu zu bewegen, sich die Programmiersprachen genauer anzusehen (falls Sie dies noch nicht genau untersucht haben). </li><li>  Stellen Sie Links zu guter englischsprachiger Literatur bereit - ohne fremde Quellen zu lesen, leider nirgendwo. </li></ol><br><p>  <strong>Was zu beachten ist</strong> : </p><br><ul><li>  Die MUSIC-Methode (MUltiple SIgnal Classification) - dies bezieht sich tats√§chlich auf die Vorschau. </li></ul><br><blockquote>  Ein Beispiel f√ºr die Diagrammbildung und die MVDR-Methode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> (wenn Sie Fragen oder Vorschl√§ge f√ºr zus√§tzliches Material haben, k√∂nnen Sie die Diskussion auf Github.Gist fortsetzen). </blockquote><p>  Wie ich oben sagte, werden wir Python verwenden, n√§mlich: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p>  Warum nicht MATLAB, einer der beliebtesten und bequemsten Kandidaten f√ºr die lineare Algebra-Modellierung?  Weil ich zeigen m√∂chte, dass √§hnliche Arbeiten in Python ausgef√ºhrt werden k√∂nnen und der Umfang von Python viel gr√∂√üer ist als der von MATLAB.  Daher ist es meiner Meinung nach n√ºtzlich, mit der Python-Syntax vertraut zu sein. </p><br><p>  Fangen wir an! </p><br><blockquote>  Formeln werden √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://upmath.me/ erstellt</a> .  Vielen Dank an die Macher f√ºr ein tolles Tool! </blockquote><br><h2 id="postanovka-zadachi">  Erkl√§rung des Problems </h2><br><p>  Angenommen, es gibt eine lineare Antennenanordnung, die aus einer Anzahl von Elementen besteht, die voneinander beabstandet sind <img src="https://tex.s2cms.ru/svg/%5CDelta%20%3D%20%5Cfrac%7B%5Clambda%7D%7B2%7D" alt="\ Delta = \ frac {\ lambda} {2}">  (Schritt des Antennenarrays), wo <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  - die L√§nge der elektromagnetischen Tr√§gerwelle (EM). </p><br><p>  Elektromagnetische Wellen fallen aus verschiedenen Richtungen auf dieses Antennenarray. </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote>  Abb.  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Adaptives Antennensystem.</a> </blockquote><p>  Wie aus der Figur ersichtlich ist, wird das Antennenarray als adaptives Filter betrachtet. </p><br><p>  Finden des optimalen Koeffizientenvektors ( <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bw%7D_%7Bopt%7D" alt="\ mathbf {w} _ {opt}">  ) ist die Hauptaufgabe adaptiver Antennenarrays aus mathematischer Sicht. </p><br><p>  Zun√§chst wissen wir nicht, aus welchen bestimmten Richtungen die Signale kommen und wie viele davon.  Um diesen Widerspruch aufzul√∂sen, verwenden wir den MUSIC-Algorithmus, einen Algorithmus zur Sch√§tzung von Raumfrequenzen mit hoher Aufl√∂sung. </p><br><h2 id="modelirovanie-prinyatogo-signala">  Empfangssignalsimulation </h2><br><p>  Wir k√∂nnen das Modell des empfangenen Signals durch die Formel darstellen: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D%20%2B%20%5Cmathbf%7BN%7D%20" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BA%7D%20%3D%20%5B%5Cmathbf%7Ba%7D(%5Ctheta_1)%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_2)%20%5Cquad%20...%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_d)%5D" alt="\ mathbf {A} = [\ mathbf {a} (\ theta_1) \ quad \ mathbf {a} (\ theta_2) \ quad ... \ quad \ mathbf {a} (\ theta_d)]">  - Matrix von Abtastvektoren (Lenkvektoren) des Antennenarrays ( <img src="https://tex.s2cms.ru/svg/%20a_i%20%3D%20%5Cexp(-j%20%5Cmu%20m_i)" alt="a_i = \ exp (-j \ mu m_i)">  , <img src="https://tex.s2cms.ru/svg/m%20%3D%200%2C%201%20...%20(M-1)" alt="m = 0, 1 ... (M-1)">  , <img src="https://tex.s2cms.ru/svg/M" alt="M.">  - die Anzahl der Elemente des Antennenarrays, <img src="https://tex.s2cms.ru/svg/d" alt="d">  - die Anzahl der EM-Wellenquellen, <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ Theta">  - Winkel der Ankunftsrichtung der EM-Welle), <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BS%7D" alt="\ mathbf {S}">  - Matrix der √ºbertragenen Zeichen und <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BN%7D" alt="\ mathbf {N}">  - Matrix des additiven Rauschens. </p><br><img src="https://raw.githubusercontent.com/kirlf/CSP/master/Different/assets/ULA.png" alt="ULA" width="600"><br><blockquote>  Abb.  2. Omnidirektionales lineares Antennenarray (ULAA - Uniform Linear Antennenna Array) [1, S.  32]. </blockquote><p>  Lassen Sie uns diese Formel auf "allt√§gliche" Weise √ºberdenken: Auf unserem Gitter bekommen wir etwas "Durcheinander" von verschiedenen Signalen, die wir mit bezeichnen <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BX%7D" alt="\ mathbf {X}">  .  Wir erhalten keine expliziten Informationen √ºber die Anzahl der Quellen und Richtungen, Informationen dar√ºber sind jedoch im empfangenen Signal enthalten. </p><br><p>  Wir fangen an zu suchen! </p><br><p>  Um dies zu tun, gehen sie normalerweise zu Manipulationen nicht mit den Matrizen komplexer Signalamplituden selbst √ºber, sondern mit ihren Kovarianzen (d. H. Im Wesentlichen mit Potenzen): </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5EH%20%3D%20%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BR%7D_%7Bss%7D%20%5Cmathbf%7BA%7D%5EH%20%2B%20%5Cmathbf%7BR%7D_%7Bnn%7D%20" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><p></p><br><h2 id="usloviya">  Bedingungen </h2><br><p>  Wir f√ºhren eine wichtige Bedingung ein, die ber√ºcksichtigt werden muss: die Rayleigh-Winkelaufl√∂sungsgrenze: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/sin%20(%5Ctheta_R)%20%3D%20%5Cfrac%7B%5Clambda%7D%7BD%7D" alt="sin (\ theta_R) = \ frac {\ lambda} {D}"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/D%20%3D%20M%20%5CDelta" alt="D = M \ Delta">  Ist die L√§nge des linearen Gitters. </p><br><p>  Wir definieren den Ankunftswinkel einer elektromagnetischen Welle durch das Konzept der Ortsfrequenz neu: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmu_R%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20sin(%5Ctheta_R)%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20%5Cfrac%7B%5Clambda%7D%7B%5CDelta%20M%7D%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7BM%7D" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta sin (\ theta_R) = \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/%5Cmu_R" alt="\ mu_R">  - Es gibt eine Standardbreite der Hauptkeule des Strahls ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Standardstrahlbreite</a> ). </p><br><p>  Um zu √ºberpr√ºfen, wie effektiv unsere Methode ist und unter welchen Bedingungen, f√ºhren wir einige vorgegebene Werte f√ºr den Winkelabstand ein: </p><br><ol><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%20%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = - \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = \ mu_R \ quad">  - Aufteilung in eine Strahlbreite; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.5%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.5%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,5 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,5 \ mu_R \ quad">  - Aufteilung in eine zweite Strahlbreite; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.3%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.3%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,3 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,3 \ mu_R \ quad">  - Aufteilung in drei Zehntel der Strahlbreite. </p><br></li></ol><br><p>  Definieren Sie die Eingabeparameter: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode">  Ein bisschen Theorie √ºber die Methode selbst </h2><br><p>  Zun√§chst stellen wir fest, dass der Vorl√§ufer der MUSIC-Methode die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Pisarenko-</a> Methode (1973) ist.  Das betrachtete Problem der Pisarenko-Methode bestand darin, die Frequenzen der Summe komplexer Exponentiale in wei√üem Rauschen abzusch√§tzen.  V. F. Pisarenko zeigte, dass Frequenzen von Eigenvektoren gefunden werden k√∂nnen, die dem minimalen Eigenwert der Autokorrelationsmatrix entsprechen.  In der Folge wurde diese Methode ein Sonderfall der MUSIC-Methode.  [2, S.  459] </p><br><p>  Schmidt und seine Kollegen schlugen 1979 den Multiple Signal Classification Algorithm (MUSIC) vor [4].  Der Hauptansatz dieses Algorithmus besteht darin, die Kovarianzmatrix des empfangenen Signals in Eigenwerte zu zerlegen.  Da dieser Algorithmus unkorreliertes Rauschen ber√ºcksichtigt, hat die erzeugte Kovarianzmatrix eine diagonale Form.  Hier werden die Signal- und Rauschunterr√§ume unter Verwendung der linearen Algebra berechnet und sind orthogonal zueinander.  Daher verwendet der Algorithmus die Orthogonalit√§tseigenschaft, um Signal- und Rauschunterr√§ume zu extrahieren [5]. </p><br><p>  Der verallgemeinerte MUSIC-Algorithmus kann wie folgt definiert werden: </p><br><ul><li>  Finden Sie die Kovarianzmatrix <img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20" alt="\ mathbf {R} _ {xx}"></li><li>  Finden Sie Eigenvektoren √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">EVD</a> oder einen anderen geeigneten numerischen Algorithmus: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BU%7D%5Cmathbf%7B%5CLambda%7D%5Cmathbf%7BU%7D%5EH%20%5Cqquad(1)" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad (1)"></div><p></p><br><ul><li>  Finden Sie das Pseudospektrum (warum mit dem Pr√§fix Pseudo, wir werden unten diskutieren) MUSIK durch die folgende Formel: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(e%5E%7Bj%5Comega%7D)%20%3D%20%5Cfrac%7B1%7D%7B%5Csum%20%5Climits_%7Bi%3Dd%2B1%7D%5E%7BM%7D%7C%5Cmathbf%7Ba%7D%5EH%5Cmathbf%7Bu%7D_i%7C%5E2%7D%20%5Cqquad(2)%20" alt="P_ {MU} (e ^ {j \ omega}) = \ frac {1} {\ sum \ limit_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad (2)"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Ba%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20%20e%5E%7Bj0%5Comega%7D%20%26%20e%5E%7Bj1%5Comega%7D%20%26%20e%5E%7Bj2%5Comega%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Comega%7D%20%5Cend%7Bbmatrix%7D%5ET" alt="\ mathbf {a} = \ begin {bmatrix} e ^ {j0 \ omega} &amp; e ^ {j1 \ omega} &amp; e ^ {j2 \ omega} &amp; ... &amp; e ^ {j (M-1) \ omega } \ end {bmatrix} ^ T.">  Liegt der Exponentialvektor f√ºr die Frequenz œâ in einem gegebenen Bereich und <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bu%7D_i" alt="\ mathbf {u} _i">  - der i-te Eigenvektor (Eigenvektor) der Kovarianzmatrix (1) entsprechend dem Rauschunterraum der Matrix (1) - daher die Indexierung mit <img src="https://tex.s2cms.ru/svg/d%2B1" alt="d + 1">  ( <img src="https://tex.s2cms.ru/svg/d" alt="d">  Ist der Rang der Matrix (1)). </p><br><blockquote>  Versuchen Sie zur besseren √úbersichtlichkeit, das entsprechende MATLAB-Skript auszuf√ºhren, das als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Referenz</a> bereitgestellt wird.  Achten Sie auf zwei Hauptpunkte: <br><ul><li>  Anstatt das Quadrat der zweiten Norm im Nenner (2) zu berechnen, wenden die Autoren den FFT-Algorithmus auf Eigenvektoren an, was die Modellierung durch Verwendung integrierter Funktionen erleichtert und der Theorie im Allgemeinen aus mathematischer Sicht nicht widerspricht. </li><li>  Die Kovarianzmatrix wird durch Faltungsmatrizen berechnet. Ein anderer Ansatz wurde oben gezeigt, um r√§umliche Frequenzen abzusch√§tzen. </li></ul><br></blockquote><p>  Wie Sie dem Namen entnehmen k√∂nnen, ist MUSIC auch eine klassische Methode zur Sch√§tzung der Empfangsrichtung mit hoher Aufl√∂sung.  Der Algorithmus zur Berechnung von Pseudospektren in diesem Zusammenhang ist nachstehend angegeben: </p><br><ul><li><p>  wir finden die Kovarianzmatrix des empfangenen Signals; </p><br></li><li><p>  Finde den Null-Unterraum <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D_0" alt="\ mathbf {U} _0">  :: </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BU%7D%20%3D%20%5B%5Cmathbf%7BU%7D_s%20%5Cquad%20%5Cmathbf%7BU%7D_0%5D%20" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><p></p><br><ul><li>  W√§hlen Sie einen Suchbereich aus: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Cmu)%20%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7Bj0%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj0%5Cmu_Q%7D%20%5C%5C%20...%20%26...%26...%20%5C%5C%20e%5E%7Bj(M-1)%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Cmu_Q%7D%20%5Cend%7Bbmatrix%7D%20" alt="a (\ mu) = \ begin {bmatrix} e ^ {j0 \ mu_1} &amp; ... &amp; e ^ {j0 \ mu_Q} \\ ... &amp; ... &amp; ... \\ e ^ {j ( M-1) \ mu_1} &amp; ... &amp; e ^ {j (M-1) \ mu_Q} \ end {bmatrix}"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/%5Cmu%20%3D%20-%5Cfrac%7B2%5Cpi%20f_c%7D%7Bc%7D%5CDelta%20sin%5Ctheta%20%3D%20-%5Cfrac%7B2%5Cpi%20%7D%7B%5Clambda%20%7D%5CDelta%20sin%5Ctheta" alt="\ mu = - \ frac {2 \ pi f_c} {c} \ Delta sin \ theta = - \ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li>  Berechnen Sie das Pseudospektrum: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(%5Ctheta)%3D%5Cfrac%7B%5Cmathbf%7Ba%7D%5EH%20(%5Ctheta)%5Cmathbf%7Ba%7D(%5Ctheta)%7D%7B%5Cmathbf%7Ba%7D%5EH(%5Ctheta)%5Cmathbf%7BU%7D_0%20%5Cmathbf%7BU%7D_0%5EH%20%5Cmathbf%7Ba%7D(%5Ctheta)%7D%20" alt="P_ {MU} (\ theta) = \ frac {\ mathbf {a} ^ H (\ theta) \ mathbf {a} (\ theta)} {\ mathbf {a} ^ H (\ theta) \ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a} (\ theta)}"></div><p></p><br><p>  Die Beziehung zwischen der Spektralanalyse und der Analyse der Ankunftswinkel (DoA - Arriaval-Richtung) von EM-Wellen ist in Tabelle 1 beschrieben. </p><br><p>  Tabelle 1 <strong>Kommunikation zwischen MUSIC-Anwendungen</strong> : Signalarray-Verarbeitung und Oberschwingungssuche [6]. </p><br><div class="scrollable-table"><table><thead><tr><th>  Variable </th><th>  Signalarray-Verarbeitung </th><th>  Harmonische Suche </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/M" alt="M."></div></td><td>  Anzahl der Sensoren </td><td>  Die Anzahl der Zeitr√§ume </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/N" alt="N."></div></td><td>  Die Anzahl der Zeitr√§ume </td><td>  Anzahl der Experimente </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/d" alt="d"></div></td><td>  Anzahl der Wellenfronten </td><td>  Die Anzahl der komplexen Komponenten </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cmu" alt="\ mu"></div></td><td>  Raumfrequenzen </td><td>  Normalisierte Frequenzen </td></tr></tbody></table></div><br><p>  Im Allgemeinen kann der Prozess des Empfangens durch Arrays (Gitter) mit dem Prozess der klassischen Diskretisierung verglichen werden, weil  Tats√§chlich f√ºhrt jeder Sensor, der eine Welle mit einer bestimmten Phasenverz√∂gerung (d. h. mit einer bestimmten Zeitverz√∂gerung) empf√§ngt, die Funktionen eines Abtastdelta-Impulses aus.  Die Anzahl der Realisierungen (Experimente) der klassischen Spektralanalyse entspricht der Anzahl der Zeitsegmente (Schnappsch√ºsse).  Jede Quelle hat ihre eigene Wellenfront, was bei der Spektralanalyse der Anzahl der eindeutigen Sinuskurven des Signals entspricht. </p><br><p>  Und jetzt zur√ºck zum Moment der Berechnung der Eigenvektoren.  Wir haben oben bereits diese Vektoren erw√§hnt <img src="https://tex.s2cms.ru/svg/a(%5Ctheta_i)%5Cepsilon%20A" alt="a (\ theta_i) \ epsilon A.">  wo <img src="https://tex.s2cms.ru/svg/i%3D1%2C2%2C..%2Cd" alt="i = 1,2, .., d">  sind orthogonal zum Rauschunterraum der Kovarianzmatrix, d.h. </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Ctheta_i)%5ETU_0%3D0%5ET%20" alt="a (\ theta_i) ^ TU_0 = 0 ^ T."></div><p></p><br><p>  Tats√§chlich sehen wir ein Gleichungssystem, in dem wir die Wurzeln finden k√∂nnen - Eigenvektoren.  Ein solches Verfahren erm√∂glicht es im Gegensatz zu numerischen Algorithmen (f√ºr die, wie oben erw√§hnt, f√ºr EVD gilt), eher reale als ungef√§hre Eigenwerte zu erhalten.  Deshalb k√∂nnen wir mit diesem Ansatz kein Pseudospektrum, sondern ein Spektrum erhalten.  Die gleiche Idee bildete die Grundlage des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Root-MUSIC-</a> Algorithmus. </p><br><h2 id="modelirovanie">  Modellierung </h2><br><p>  Fuf!  Schlie√ülich werden alle Formeln beschrieben und etwas erkl√§rt.  Wir k√∂nnen mit dem Modellieren beginnen. </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles Œ∏ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p>  Wie wir sehen k√∂nnen, hat MUSIC eine h√∂here Aufl√∂sung und erm√∂glicht im Allgemeinen bessere Ergebnisse als beispielsweise MVDR - der gleiche Vertreter parametrischer Methoden der Spektralanalyse. </p><br><p>  Es sollte jedoch ber√ºcksichtigt werden, dass wir bei der Verwendung von MUSIC rechenintensivere Algorithmen wie EVD oder SVD verwenden, was f√ºr eine h√∂here Genauigkeit mit einem gewissen Preis verbunden ist. </p><br><p>  Solche Dinge. </p><br><h2 id="spisok-ispolzovannoy-literatury">  Liste der verwendeten Literatur: </h2><br><ol><li>  Haykin, Simon und KJ Ray Liu.  Handbuch zur Array-Verarbeitung und zu Sensornetzwerken.  Vol.  63. John Wiley &amp; Sons, 2010. pp.  102-107 </li><li>  Hayes MH Statistische digitale Signalverarbeitung und Modellierung.  - John Wiley &amp; Sons, 2009. </li><li>  Haykin, Simon S. Adaptive Filtertheorie.  Pearson Education India, 2008. pp.  422-427 </li><li>  Richmond, Christ D. "Capon-Algorithmus mittlere quadratische Fehlerschwelle SNR-Vorhersage und Wahrscheinlichkeit der Aufl√∂sung."  IEEE Transactions on Signal Processing 53.8 (2005): 2748 &amp; ndash; 2764. </li><li>  SKP Gupta, MUSIC und verbesserter MUSIC-Algorithmus zur Vermeidung der Ankunftsdorektion, IEEE, 2015. </li><li>  Vorlesungen von Professor Martin Haardt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Array Array</a> ) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446674/">https://habr.com/ru/post/de446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446660/index.html">KI, Sch√ºler und gro√üer Preis: Wie man maschinelles Lernen in der 8. Klasse macht</a></li>
<li><a href="../de446662/index.html">Transaktionen und Mechanismen zu ihrer Kontrolle</a></li>
<li><a href="../de446664/index.html">Das SAP Forum 2019 ist nur noch 2 Wochen entfernt! Was wird da sein?</a></li>
<li><a href="../de446666/index.html">Holen Sie das Beste aus Grafikrechnern heraus: Spiele auf dem TI-83</a></li>
<li><a href="../de446668/index.html">Python f√ºr das Web: Was ein Junior wissen muss, um zu arbeiten und zu wachsen</a></li>
<li><a href="../de446676/index.html">Fehlende Schl√ºssel f√ºr die Commodore 116-Gummitastatur erstellen</a></li>
<li><a href="../de446678/index.html">Live Battle: Porto ICPC Finale</a></li>
<li><a href="../de446680/index.html">Der Hauptinstinkt des Encoders besteht darin, ineffektive L√∂sungen von √ºberall zu entfernen</a></li>
<li><a href="../de446682/index.html">Beschleunigen von WebGL / Three.js mit OffscreenCanvas und Web Workers</a></li>
<li><a href="../de446688/index.html">SIMD-Erweiterung auf C ++ OpenMP in Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>