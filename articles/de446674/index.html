<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏿 👃🏿 😉 Wir modellieren den MUSIC-Algorithmus zur Bestimmung der Ankunftsrichtung einer elektromagnetischen Welle ✈️ 🧝🏾 😏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 


 Ich werde meine Einführung von weitem beginnen. Es war einmal, dass Ihr bescheidener Diener im fernen Jahr 2016-2017 einen sechsmonatigen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir modellieren den MUSIC-Algorithmus zur Bestimmung der Ankunftsrichtung einer elektromagnetischen Welle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446674/"><p><img src="https://media.moddb.com/cache/images/groups/1/3/2392/thumb_620x2000/music-cats.jpg" alt="Aaspcats"></p><br><h2 id="predislovie">  Vorwort </h2><br><p>  Ich werde meine Einführung von weitem beginnen.  Es war einmal, dass Ihr bescheidener Diener im fernen Jahr 2016-2017 einen sechsmonatigen Schulungskurs in der fernen Stadt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Ilmenau</a> (Deutschland) absolvierte, wo er das Masterstudium <strong>Kommunikation und Signalverarbeitung</strong> (im Großen und Ganzen) erfolgreich abschloss.  Das Programm war nicht einfach, aber jetzt ist es sogar angenehm, sich daran zu erinnern.  Manchmal ... </p><a name="habracut"></a><br><p>  Am Ende dieser Ausbildung hatte ich neben dem Diplom noch einige verschiedene Materialien zur Hand, die ich für falsch hielt, nicht zu teilen. </p><br><p>  Eines dieser Materialien liegt vor Ihnen. </p><br><p>  <strong>Welche Ziele habe ich bei der Vorbereitung des Seminars verfolgt</strong> : </p><br><ol><li>  über einige bereits etablierte, „intelligente“ Ansätze zum Thema Antennenarrays sprechen, die am besten zugänglich sind, und dies auf Russisch; </li><li>  Führen Sie eine kleine Simulation in der <strong><em>Sprache Python 3 durch</em></strong> , um andere Funkingenieure dazu zu bewegen, sich die Programmiersprachen genauer anzusehen (falls Sie dies noch nicht genau untersucht haben). </li><li>  Stellen Sie Links zu guter englischsprachiger Literatur bereit - ohne fremde Quellen zu lesen, leider nirgendwo. </li></ol><br><p>  <strong>Was zu beachten ist</strong> : </p><br><ul><li>  Die MUSIC-Methode (MUltiple SIgnal Classification) - dies bezieht sich tatsächlich auf die Vorschau. </li></ul><br><blockquote>  Ein Beispiel für die Diagrammbildung und die MVDR-Methode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> (wenn Sie Fragen oder Vorschläge für zusätzliches Material haben, können Sie die Diskussion auf Github.Gist fortsetzen). </blockquote><p>  Wie ich oben sagte, werden wir Python verwenden, nämlich: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p>  Warum nicht MATLAB, einer der beliebtesten und bequemsten Kandidaten für die lineare Algebra-Modellierung?  Weil ich zeigen möchte, dass ähnliche Arbeiten in Python ausgeführt werden können und der Umfang von Python viel größer ist als der von MATLAB.  Daher ist es meiner Meinung nach nützlich, mit der Python-Syntax vertraut zu sein. </p><br><p>  Fangen wir an! </p><br><blockquote>  Formeln werden über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://upmath.me/ erstellt</a> .  Vielen Dank an die Macher für ein tolles Tool! </blockquote><br><h2 id="postanovka-zadachi">  Erklärung des Problems </h2><br><p>  Angenommen, es gibt eine lineare Antennenanordnung, die aus einer Anzahl von Elementen besteht, die voneinander beabstandet sind <img src="https://tex.s2cms.ru/svg/%5CDelta%20%3D%20%5Cfrac%7B%5Clambda%7D%7B2%7D" alt="\ Delta = \ frac {\ lambda} {2}">  (Schritt des Antennenarrays), wo <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  - die Länge der elektromagnetischen Trägerwelle (EM). </p><br><p>  Elektromagnetische Wellen fallen aus verschiedenen Richtungen auf dieses Antennenarray. </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote>  Abb.  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Adaptives Antennensystem.</a> </blockquote><p>  Wie aus der Figur ersichtlich ist, wird das Antennenarray als adaptives Filter betrachtet. </p><br><p>  Finden des optimalen Koeffizientenvektors ( <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bw%7D_%7Bopt%7D" alt="\ mathbf {w} _ {opt}">  ) ist die Hauptaufgabe adaptiver Antennenarrays aus mathematischer Sicht. </p><br><p>  Zunächst wissen wir nicht, aus welchen bestimmten Richtungen die Signale kommen und wie viele davon.  Um diesen Widerspruch aufzulösen, verwenden wir den MUSIC-Algorithmus, einen Algorithmus zur Schätzung von Raumfrequenzen mit hoher Auflösung. </p><br><h2 id="modelirovanie-prinyatogo-signala">  Empfangssignalsimulation </h2><br><p>  Wir können das Modell des empfangenen Signals durch die Formel darstellen: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D%20%2B%20%5Cmathbf%7BN%7D%20" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BA%7D%20%3D%20%5B%5Cmathbf%7Ba%7D(%5Ctheta_1)%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_2)%20%5Cquad%20...%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_d)%5D" alt="\ mathbf {A} = [\ mathbf {a} (\ theta_1) \ quad \ mathbf {a} (\ theta_2) \ quad ... \ quad \ mathbf {a} (\ theta_d)]">  - Matrix von Abtastvektoren (Lenkvektoren) des Antennenarrays ( <img src="https://tex.s2cms.ru/svg/%20a_i%20%3D%20%5Cexp(-j%20%5Cmu%20m_i)" alt="a_i = \ exp (-j \ mu m_i)">  , <img src="https://tex.s2cms.ru/svg/m%20%3D%200%2C%201%20...%20(M-1)" alt="m = 0, 1 ... (M-1)">  , <img src="https://tex.s2cms.ru/svg/M" alt="M.">  - die Anzahl der Elemente des Antennenarrays, <img src="https://tex.s2cms.ru/svg/d" alt="d">  - die Anzahl der EM-Wellenquellen, <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ Theta">  - Winkel der Ankunftsrichtung der EM-Welle), <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BS%7D" alt="\ mathbf {S}">  - Matrix der übertragenen Zeichen und <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BN%7D" alt="\ mathbf {N}">  - Matrix des additiven Rauschens. </p><br><img src="https://raw.githubusercontent.com/kirlf/CSP/master/Different/assets/ULA.png" alt="ULA" width="600"><br><blockquote>  Abb.  2. Omnidirektionales lineares Antennenarray (ULAA - Uniform Linear Antennenna Array) [1, S.  32]. </blockquote><p>  Lassen Sie uns diese Formel auf "alltägliche" Weise überdenken: Auf unserem Gitter bekommen wir etwas "Durcheinander" von verschiedenen Signalen, die wir mit bezeichnen <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BX%7D" alt="\ mathbf {X}">  .  Wir erhalten keine expliziten Informationen über die Anzahl der Quellen und Richtungen, Informationen darüber sind jedoch im empfangenen Signal enthalten. </p><br><p>  Wir fangen an zu suchen! </p><br><p>  Um dies zu tun, gehen sie normalerweise zu Manipulationen nicht mit den Matrizen komplexer Signalamplituden selbst über, sondern mit ihren Kovarianzen (d. H. Im Wesentlichen mit Potenzen): </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5EH%20%3D%20%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BR%7D_%7Bss%7D%20%5Cmathbf%7BA%7D%5EH%20%2B%20%5Cmathbf%7BR%7D_%7Bnn%7D%20" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><p></p><br><h2 id="usloviya">  Bedingungen </h2><br><p>  Wir führen eine wichtige Bedingung ein, die berücksichtigt werden muss: die Rayleigh-Winkelauflösungsgrenze: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/sin%20(%5Ctheta_R)%20%3D%20%5Cfrac%7B%5Clambda%7D%7BD%7D" alt="sin (\ theta_R) = \ frac {\ lambda} {D}"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/D%20%3D%20M%20%5CDelta" alt="D = M \ Delta">  Ist die Länge des linearen Gitters. </p><br><p>  Wir definieren den Ankunftswinkel einer elektromagnetischen Welle durch das Konzept der Ortsfrequenz neu: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmu_R%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20sin(%5Ctheta_R)%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20%5Cfrac%7B%5Clambda%7D%7B%5CDelta%20M%7D%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7BM%7D" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta sin (\ theta_R) = \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/%5Cmu_R" alt="\ mu_R">  - Es gibt eine Standardbreite der Hauptkeule des Strahls ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Standardstrahlbreite</a> ). </p><br><p>  Um zu überprüfen, wie effektiv unsere Methode ist und unter welchen Bedingungen, führen wir einige vorgegebene Werte für den Winkelabstand ein: </p><br><ol><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%20%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = - \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = \ mu_R \ quad">  - Aufteilung in eine Strahlbreite; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.5%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.5%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,5 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,5 \ mu_R \ quad">  - Aufteilung in eine zweite Strahlbreite; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.3%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.3%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,3 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,3 \ mu_R \ quad">  - Aufteilung in drei Zehntel der Strahlbreite. </p><br></li></ol><br><p>  Definieren Sie die Eingabeparameter: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode">  Ein bisschen Theorie über die Methode selbst </h2><br><p>  Zunächst stellen wir fest, dass der Vorläufer der MUSIC-Methode die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Pisarenko-</a> Methode (1973) ist.  Das betrachtete Problem der Pisarenko-Methode bestand darin, die Frequenzen der Summe komplexer Exponentiale in weißem Rauschen abzuschätzen.  V. F. Pisarenko zeigte, dass Frequenzen von Eigenvektoren gefunden werden können, die dem minimalen Eigenwert der Autokorrelationsmatrix entsprechen.  In der Folge wurde diese Methode ein Sonderfall der MUSIC-Methode.  [2, S.  459] </p><br><p>  Schmidt und seine Kollegen schlugen 1979 den Multiple Signal Classification Algorithm (MUSIC) vor [4].  Der Hauptansatz dieses Algorithmus besteht darin, die Kovarianzmatrix des empfangenen Signals in Eigenwerte zu zerlegen.  Da dieser Algorithmus unkorreliertes Rauschen berücksichtigt, hat die erzeugte Kovarianzmatrix eine diagonale Form.  Hier werden die Signal- und Rauschunterräume unter Verwendung der linearen Algebra berechnet und sind orthogonal zueinander.  Daher verwendet der Algorithmus die Orthogonalitätseigenschaft, um Signal- und Rauschunterräume zu extrahieren [5]. </p><br><p>  Der verallgemeinerte MUSIC-Algorithmus kann wie folgt definiert werden: </p><br><ul><li>  Finden Sie die Kovarianzmatrix <img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20" alt="\ mathbf {R} _ {xx}"></li><li>  Finden Sie Eigenvektoren über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">EVD</a> oder einen anderen geeigneten numerischen Algorithmus: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BU%7D%5Cmathbf%7B%5CLambda%7D%5Cmathbf%7BU%7D%5EH%20%5Cqquad(1)" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad (1)"></div><p></p><br><ul><li>  Finden Sie das Pseudospektrum (warum mit dem Präfix Pseudo, wir werden unten diskutieren) MUSIK durch die folgende Formel: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(e%5E%7Bj%5Comega%7D)%20%3D%20%5Cfrac%7B1%7D%7B%5Csum%20%5Climits_%7Bi%3Dd%2B1%7D%5E%7BM%7D%7C%5Cmathbf%7Ba%7D%5EH%5Cmathbf%7Bu%7D_i%7C%5E2%7D%20%5Cqquad(2)%20" alt="P_ {MU} (e ^ {j \ omega}) = \ frac {1} {\ sum \ limit_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad (2)"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Ba%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20%20e%5E%7Bj0%5Comega%7D%20%26%20e%5E%7Bj1%5Comega%7D%20%26%20e%5E%7Bj2%5Comega%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Comega%7D%20%5Cend%7Bbmatrix%7D%5ET" alt="\ mathbf {a} = \ begin {bmatrix} e ^ {j0 \ omega} &amp; e ^ {j1 \ omega} &amp; e ^ {j2 \ omega} &amp; ... &amp; e ^ {j (M-1) \ omega } \ end {bmatrix} ^ T.">  Liegt der Exponentialvektor für die Frequenz ω in einem gegebenen Bereich und <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bu%7D_i" alt="\ mathbf {u} _i">  - der i-te Eigenvektor (Eigenvektor) der Kovarianzmatrix (1) entsprechend dem Rauschunterraum der Matrix (1) - daher die Indexierung mit <img src="https://tex.s2cms.ru/svg/d%2B1" alt="d + 1">  ( <img src="https://tex.s2cms.ru/svg/d" alt="d">  Ist der Rang der Matrix (1)). </p><br><blockquote>  Versuchen Sie zur besseren Übersichtlichkeit, das entsprechende MATLAB-Skript auszuführen, das als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Referenz</a> bereitgestellt wird.  Achten Sie auf zwei Hauptpunkte: <br><ul><li>  Anstatt das Quadrat der zweiten Norm im Nenner (2) zu berechnen, wenden die Autoren den FFT-Algorithmus auf Eigenvektoren an, was die Modellierung durch Verwendung integrierter Funktionen erleichtert und der Theorie im Allgemeinen aus mathematischer Sicht nicht widerspricht. </li><li>  Die Kovarianzmatrix wird durch Faltungsmatrizen berechnet. Ein anderer Ansatz wurde oben gezeigt, um räumliche Frequenzen abzuschätzen. </li></ul><br></blockquote><p>  Wie Sie dem Namen entnehmen können, ist MUSIC auch eine klassische Methode zur Schätzung der Empfangsrichtung mit hoher Auflösung.  Der Algorithmus zur Berechnung von Pseudospektren in diesem Zusammenhang ist nachstehend angegeben: </p><br><ul><li><p>  wir finden die Kovarianzmatrix des empfangenen Signals; </p><br></li><li><p>  Finde den Null-Unterraum <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D_0" alt="\ mathbf {U} _0">  :: </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BU%7D%20%3D%20%5B%5Cmathbf%7BU%7D_s%20%5Cquad%20%5Cmathbf%7BU%7D_0%5D%20" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><p></p><br><ul><li>  Wählen Sie einen Suchbereich aus: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Cmu)%20%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7Bj0%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj0%5Cmu_Q%7D%20%5C%5C%20...%20%26...%26...%20%5C%5C%20e%5E%7Bj(M-1)%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Cmu_Q%7D%20%5Cend%7Bbmatrix%7D%20" alt="a (\ mu) = \ begin {bmatrix} e ^ {j0 \ mu_1} &amp; ... &amp; e ^ {j0 \ mu_Q} \\ ... &amp; ... &amp; ... \\ e ^ {j ( M-1) \ mu_1} &amp; ... &amp; e ^ {j (M-1) \ mu_Q} \ end {bmatrix}"></div><p></p><br><p>  wo <img src="https://tex.s2cms.ru/svg/%5Cmu%20%3D%20-%5Cfrac%7B2%5Cpi%20f_c%7D%7Bc%7D%5CDelta%20sin%5Ctheta%20%3D%20-%5Cfrac%7B2%5Cpi%20%7D%7B%5Clambda%20%7D%5CDelta%20sin%5Ctheta" alt="\ mu = - \ frac {2 \ pi f_c} {c} \ Delta sin \ theta = - \ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li>  Berechnen Sie das Pseudospektrum: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(%5Ctheta)%3D%5Cfrac%7B%5Cmathbf%7Ba%7D%5EH%20(%5Ctheta)%5Cmathbf%7Ba%7D(%5Ctheta)%7D%7B%5Cmathbf%7Ba%7D%5EH(%5Ctheta)%5Cmathbf%7BU%7D_0%20%5Cmathbf%7BU%7D_0%5EH%20%5Cmathbf%7Ba%7D(%5Ctheta)%7D%20" alt="P_ {MU} (\ theta) = \ frac {\ mathbf {a} ^ H (\ theta) \ mathbf {a} (\ theta)} {\ mathbf {a} ^ H (\ theta) \ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a} (\ theta)}"></div><p></p><br><p>  Die Beziehung zwischen der Spektralanalyse und der Analyse der Ankunftswinkel (DoA - Arriaval-Richtung) von EM-Wellen ist in Tabelle 1 beschrieben. </p><br><p>  Tabelle 1 <strong>Kommunikation zwischen MUSIC-Anwendungen</strong> : Signalarray-Verarbeitung und Oberschwingungssuche [6]. </p><br><div class="scrollable-table"><table><thead><tr><th>  Variable </th><th>  Signalarray-Verarbeitung </th><th>  Harmonische Suche </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/M" alt="M."></div></td><td>  Anzahl der Sensoren </td><td>  Die Anzahl der Zeiträume </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/N" alt="N."></div></td><td>  Die Anzahl der Zeiträume </td><td>  Anzahl der Experimente </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/d" alt="d"></div></td><td>  Anzahl der Wellenfronten </td><td>  Die Anzahl der komplexen Komponenten </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cmu" alt="\ mu"></div></td><td>  Raumfrequenzen </td><td>  Normalisierte Frequenzen </td></tr></tbody></table></div><br><p>  Im Allgemeinen kann der Prozess des Empfangens durch Arrays (Gitter) mit dem Prozess der klassischen Diskretisierung verglichen werden, weil  Tatsächlich führt jeder Sensor, der eine Welle mit einer bestimmten Phasenverzögerung (d. h. mit einer bestimmten Zeitverzögerung) empfängt, die Funktionen eines Abtastdelta-Impulses aus.  Die Anzahl der Realisierungen (Experimente) der klassischen Spektralanalyse entspricht der Anzahl der Zeitsegmente (Schnappschüsse).  Jede Quelle hat ihre eigene Wellenfront, was bei der Spektralanalyse der Anzahl der eindeutigen Sinuskurven des Signals entspricht. </p><br><p>  Und jetzt zurück zum Moment der Berechnung der Eigenvektoren.  Wir haben oben bereits diese Vektoren erwähnt <img src="https://tex.s2cms.ru/svg/a(%5Ctheta_i)%5Cepsilon%20A" alt="a (\ theta_i) \ epsilon A.">  wo <img src="https://tex.s2cms.ru/svg/i%3D1%2C2%2C..%2Cd" alt="i = 1,2, .., d">  sind orthogonal zum Rauschunterraum der Kovarianzmatrix, d.h. </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Ctheta_i)%5ETU_0%3D0%5ET%20" alt="a (\ theta_i) ^ TU_0 = 0 ^ T."></div><p></p><br><p>  Tatsächlich sehen wir ein Gleichungssystem, in dem wir die Wurzeln finden können - Eigenvektoren.  Ein solches Verfahren ermöglicht es im Gegensatz zu numerischen Algorithmen (für die, wie oben erwähnt, für EVD gilt), eher reale als ungefähre Eigenwerte zu erhalten.  Deshalb können wir mit diesem Ansatz kein Pseudospektrum, sondern ein Spektrum erhalten.  Die gleiche Idee bildete die Grundlage des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Root-MUSIC-</a> Algorithmus. </p><br><h2 id="modelirovanie">  Modellierung </h2><br><p>  Fuf!  Schließlich werden alle Formeln beschrieben und etwas erklärt.  Wir können mit dem Modellieren beginnen. </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles θ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p>  Wie wir sehen können, hat MUSIC eine höhere Auflösung und ermöglicht im Allgemeinen bessere Ergebnisse als beispielsweise MVDR - der gleiche Vertreter parametrischer Methoden der Spektralanalyse. </p><br><p>  Es sollte jedoch berücksichtigt werden, dass wir bei der Verwendung von MUSIC rechenintensivere Algorithmen wie EVD oder SVD verwenden, was für eine höhere Genauigkeit mit einem gewissen Preis verbunden ist. </p><br><p>  Solche Dinge. </p><br><h2 id="spisok-ispolzovannoy-literatury">  Liste der verwendeten Literatur: </h2><br><ol><li>  Haykin, Simon und KJ Ray Liu.  Handbuch zur Array-Verarbeitung und zu Sensornetzwerken.  Vol.  63. John Wiley &amp; Sons, 2010. pp.  102-107 </li><li>  Hayes MH Statistische digitale Signalverarbeitung und Modellierung.  - John Wiley &amp; Sons, 2009. </li><li>  Haykin, Simon S. Adaptive Filtertheorie.  Pearson Education India, 2008. pp.  422-427 </li><li>  Richmond, Christ D. "Capon-Algorithmus mittlere quadratische Fehlerschwelle SNR-Vorhersage und Wahrscheinlichkeit der Auflösung."  IEEE Transactions on Signal Processing 53.8 (2005): 2748 &amp; ndash; 2764. </li><li>  SKP Gupta, MUSIC und verbesserter MUSIC-Algorithmus zur Vermeidung der Ankunftsdorektion, IEEE, 2015. </li><li>  Vorlesungen von Professor Martin Haardt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Array Array</a> ) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446674/">https://habr.com/ru/post/de446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446660/index.html">KI, Schüler und großer Preis: Wie man maschinelles Lernen in der 8. Klasse macht</a></li>
<li><a href="../de446662/index.html">Transaktionen und Mechanismen zu ihrer Kontrolle</a></li>
<li><a href="../de446664/index.html">Das SAP Forum 2019 ist nur noch 2 Wochen entfernt! Was wird da sein?</a></li>
<li><a href="../de446666/index.html">Holen Sie das Beste aus Grafikrechnern heraus: Spiele auf dem TI-83</a></li>
<li><a href="../de446668/index.html">Python für das Web: Was ein Junior wissen muss, um zu arbeiten und zu wachsen</a></li>
<li><a href="../de446676/index.html">Fehlende Schlüssel für die Commodore 116-Gummitastatur erstellen</a></li>
<li><a href="../de446678/index.html">Live Battle: Porto ICPC Finale</a></li>
<li><a href="../de446680/index.html">Der Hauptinstinkt des Encoders besteht darin, ineffektive Lösungen von überall zu entfernen</a></li>
<li><a href="../de446682/index.html">Beschleunigen von WebGL / Three.js mit OffscreenCanvas und Web Workers</a></li>
<li><a href="../de446688/index.html">SIMD-Erweiterung auf C ++ OpenMP in Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>