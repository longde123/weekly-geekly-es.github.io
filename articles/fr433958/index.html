<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎤 🤱🏻 🗯️ Applications TDD sur Spring Boot: travailler avec une base de données 💄 🔎 🖐🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le deuxième article de la série "Développement piloté par les tests d'applications sur Spring Boot" et cette fois je vais parler du test d'accès à la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Applications TDD sur Spring Boot: travailler avec une base de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433958/"><p>  Le deuxième article de la série "Développement piloté par les tests d'applications sur Spring Boot" et cette fois je vais parler du test d'accès à la base de données, un aspect important des tests d'intégration.  Je vais vous expliquer comment utiliser les tests pour déterminer l'interface d'un futur service d'accès aux données, comment utiliser les bases de données en mémoire intégrées pour les tests, travailler avec les transactions et télécharger les données de test dans la base de données. </p><a name="habracut"></a><br><p>  Je ne parlerai pas beaucoup de TDD et des tests en général, j'invite tout le monde à lire le premier article - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment construire une pyramide dans le tronc ou le développement piloté par les tests d'applications sur Spring Boot / geek magazine</a> </p><br><p>  Je vais commencer, comme la dernière fois, par une petite partie théorique, et passer au test de bout en bout. </p><br><h1 id="piramida-testirovaniya">  Test de la pyramide </h1><br><p>  Pour commencer, une petite mais nécessaire description d'une entité aussi importante dans les tests que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la pyramide de test</a> ou <em>la pyramide de test</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png" alt="image"></p><br><p>  (extrait de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la pyramide des tests pratiques</a> ) </p><br><p>  La pyramide des tests est l'approche lorsque les tests sont organisés à plusieurs niveaux. </p><br><ul><li>  <strong>Les</strong> tests d' <strong>interface utilisateur</strong> (ou de bout en bout, <strong>E2E</strong> ) sont peu nombreux et ils sont lents, mais ils testent l'application réelle - pas de simulacres et testent des homologues.  Les entreprises pensent souvent à ce niveau et tous les cadres BDD vivent ici (voir Cucumber dans un article précédent). </li><li>  Ils sont suivis de <strong>tests d'intégration</strong> (service, composant - chacun a sa propre terminologie), qui se concentrent déjà sur un composant spécifique (service) du système, l'isolant des autres composants via moki / doubles, mais vérifiant toujours l'intégration avec de vrais systèmes externes - ces tests sont connectés à la base de données, envoyer des demandes REST, je travaille avec une file d'attente de messages.  En fait, ce sont des tests qui vérifient l'intégration de la logique métier avec le monde extérieur. </li><li>  Tout en bas se trouvent des <strong>tests unitaires</strong> rapides qui testent les blocs minimum de code (classes, méthodes) de manière complètement isolée. </li></ul><br><p>  Spring aide à écrire des tests pour chaque niveau - <em>même pour les tests unitaires</em> , bien que cela puisse sembler étrange, car dans le monde des tests unitaires, aucune connaissance du framework ne devrait exister.  Après avoir écrit le test E2E, je vais simplement montrer comment Spring permet même à des choses purement «d'intégration» comme les contrôleurs de tester de manière isolée. </p><br><p>  Mais je vais commencer tout en haut de la pyramide - le test de l'interface utilisateur lente, qui démarre et teste une application à part entière. </p><br><h1 id="end-to-end-test">  Test de bout en bout </h1><br><p>  Donc, une nouvelle fonctionnalité: </p><br><pre><code class="plaintext hljs">Feature: A list of available cakes Background: catalogue is updated Given the following items are promoted | Title | Price | | Red Velvet | 3.95 | | Victoria Sponge | 5.50 | Scenario: a user visiting the web-site sees the list of items Given a new user, Alice When she visits Cake Factory web-site Then she sees that "Red Velvet" is available with price £3.95 And she sees that "Victoria Sponge" is available with price £5.50</code> </pre> <br><blockquote>  Et voici un aspect immédiatement intéressant - que faire du test précédent, à propos du message d'accueil sur la page principale?  Cela ne semble plus pertinent, après le lancement du site sur la page principale, il y aura déjà un répertoire, pas un message d'accueil.  Il n'y a pas de réponse unique, je dirais - cela dépend de la situation.  Mais le principal conseil - ne vous attachez pas aux tests!  Supprimez-les lorsqu'ils perdent leur pertinence, réécrivez pour en faciliter la lecture.  Surtout les tests E2E - cela devrait être, en fait, une <strong>spécification vivante et actuelle</strong> .  Dans mon cas, je viens de supprimer les anciens tests et de les remplacer par de nouveaux, en utilisant certaines des étapes précédentes et en ajoutant des tests inexistants. </blockquote><p>  J'en arrive maintenant à un point important - le choix de la technologie pour le stockage des données.  Conformément à l'approche <em>Lean</em> , je voudrais reporter le choix jusqu'au tout dernier moment - quand je saurai avec certitude si le modèle relationnel ou non, quelles sont les exigences de cohérence, de transactionnalité.  En général, il existe des solutions pour cela - par exemple, la création de <strong>jumeaux</strong> de <strong>test</strong> et de divers stockages en <strong>mémoire</strong> , mais jusqu'à présent, je ne veux pas compliquer l'article et choisir immédiatement la technologie - les bases de données relationnelles.  Mais afin de conserver au moins une certaine possibilité de choisir une base de données, j'ajouterai une abstraction - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spring Data JPA</a> .  JPA lui-même est une spécification assez abstraite pour accéder aux bases de données relationnelles, et Spring Data rend son utilisation encore plus facile. </p><br><blockquote>  Spring Data JPA utilise Hibernate comme fournisseur par défaut, mais prend également en charge d'autres technologies, telles que EclipseLink et MyBatis.  Pour les personnes peu familiarisées avec l'API Java Persistence - JPA est comme une interface et Hibernate est une classe qui l'implémente. </blockquote><p>  Donc, pour ajouter le support JPA, j'ai ajouté quelques dépendances: </p><br><pre> <code class="plaintext hljs">implementation('org.springframework.boot:spring-boot-starter-data-jpa') runtime('com.h2database:h2')</code> </pre> <br><p>  En tant que base de données, j'utiliserai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">H2</a> - une base de données intégrée écrite en Java, avec la possibilité de travailler en mode en mémoire. </p><br><p>  En utilisant Spring Data JPA, je définis immédiatement une interface pour accéder aux données: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br><p>  Et l'essence: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Builder</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"cakes"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) Long id; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> String title; <span class="hljs-meta"><span class="hljs-meta">@Positive</span></span> BigDecimal price; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> <span class="hljs-meta"><span class="hljs-meta">@NaturalId</span></span> String sku; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> promoted; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; CakeEntity cakeEntity = (CakeEntity) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(title, cakeEntity.title); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(title); } }</code> </pre> <br><p>  Il y a quelques éléments moins évidents dans la description de l'entité. </p><br><ul><li>  <code>@NaturalId</code> pour le champ <code>sku</code> .  Ce champ est utilisé comme «identifiant naturel» pour vérifier l'égalité des entités - utiliser tous les champs ou les champs <code>@Id</code> dans les méthodes <code>equals</code> / <code>hashCode</code> est plutôt un anti-modèle.  Il est bien écrit sur la façon de vérifier correctement l'égalité des entités, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li><li>  Pour réduire un peu le code passe-partout, j'utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Project Lombok</a> - processeur d'annotation pour Java.  Il vous permet d'ajouter diverses choses utiles, comme <code>@Builder</code> - pour générer automatiquement un générateur pour une classe et <code>@AllArgsConstructor</code> pour créer un constructeur pour tous les champs. </li></ul><br><p>  Une implémentation d'interface sera fournie automatiquement par Spring Data. </p><br><h1 id="vniz-po-piramide">  En bas de la pyramide </h1><br><p>  Il est maintenant temps de descendre au niveau suivant de la pyramide.  En règle générale, je vous recommande de <strong>toujours commencer par le test e2e</strong> , car cela vous permettra de déterminer le "but final" et les limites de la nouvelle fonctionnalité, mais il n'y a pas de règles strictes plus loin.  Il n'est pas nécessaire d'écrire un test d'intégration avant de passer au niveau unitaire.  C'est le plus souvent que c'est plus pratique et plus simple - et c'est tout à fait naturel de descendre. </p><br><p>  Mais spécifiquement maintenant, je voudrais briser immédiatement cette règle et écrire un test unitaire qui aidera à déterminer l'interface et le contrat d'un nouveau composant qui n'existe pas encore.  Le contrôleur doit renvoyer un modèle qui sera rempli à partir d'un certain composant X, et j'ai écrit ce test: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ExtendWith</span></span>(MockitoExtension.class) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> CakeFinder cakeFinder; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> IndexController indexController; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Cake&gt; cakes = Set.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 1"</span></span>, <span class="hljs-string"><span class="hljs-string">"£10"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 2"</span></span>, <span class="hljs-string"><span class="hljs-string">"£10"</span></span>)); <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(cakeFinder.findPromotedCakes()).thenReturn(cakes); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnAListOfFoundPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ModelAndView index = indexController.index(); assertThat(index.getModel()).extracting(<span class="hljs-string"><span class="hljs-string">"cakes"</span></span>).contains(cakes); } }</code> </pre> <br><p>  Il s'agit d'un test unitaire pur - pas de contextes, pas de bases de données ici, seulement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mockito</a> pour mok.  Et ce test est juste une bonne démonstration de la façon dont Spring aide les tests unitaires - le <em>contrôleur dans Spring MVC est juste une classe dont les méthodes acceptent des paramètres de types ordinaires et renvoient des objets POJO - Afficher les modèles</em> .  Il n'y a pas de requêtes HTTP, pas de réponses, en-têtes, JSON, XML - tout cela sera automatiquement appliqué sur la pile sous la forme de convertisseurs et de sérialiseurs.  Oui, il y a un petit "indice" à Spring sous la forme de <code>ModelAndView</code> , mais c'est un POJO régulier et vous pouvez même vous en débarrasser si vous le souhaitez, il est nécessaire spécifiquement pour les contrôleurs d'interface utilisateur. </p><br><blockquote>  Je ne parlerai pas beaucoup de Mockito, vous pouvez tout lire dans la documentation officielle.  Plus précisément, il n'y a que des points intéressants dans ce test - j'utilise <code>MockitoExtension.class</code> comme <code>MockitoExtension.class</code> de test, et il générera automatiquement des mokas pour les champs annotés par <code>@Mock</code> , puis injectera ces mokas en tant que dépendances dans le constructeur de l'objet dans le champ marqué <code>@InjectMocks</code> .  Vous pouvez faire tout cela manuellement en utilisant la méthode <code>Mockito.mock()</code> , puis créer une classe. </blockquote><p>  Et ce test permet de déterminer la méthode du nouveau composant - <code>findPromotedCakes</code> , une liste de gâteaux que nous voulons afficher sur la page principale.  Il ne détermine pas ce que c'est ni comment cela devrait fonctionner avec la base de données.  La seule responsabilité du contrôleur est de prendre ce qui lui a été transféré et de retourner les modèles ("gâteaux") dans un champ spécifique.  Néanmoins, <code>CakeFinder</code> déjà la première méthode dans mon interface, ce qui signifie que vous pouvez écrire un test d'intégration pour cela. </p><br><blockquote>  J'ai délibérément rendu toutes les classes à l'intérieur du <strong>paquet</strong> <code>cakes</code> <strong>privées</strong> afin que personne en dehors du paquet ne puisse les utiliser.  La seule façon d'obtenir des données de la base de données est avec l'interface CakeFinder, qui est mon «composant X» pour accéder à la base de données.  Il devient un «connecteur» naturel, que je peux facilement verrouiller si je dois tester quelque chose isolément et ne pas toucher la base.  Et sa seule implémentation est JpaCakeFinder.  Et si, par exemple, le type de base de données ou la source de données change à l'avenir, vous devrez ajouter une implémentation de l'interface <code>CakeFinder</code> sans changer le code qui l'utilise. </blockquote><br><h1 id="integracionnyy-test-dlya-jpa-ispolzuya-datajpatest">  Test d'intégration pour JPA à l'aide de @DataJpaTest </h1><br><p>  Les tests d'intégration sont le pain et le beurre de printemps.  En fait, tout a été si bien fait pour les tests d'intégration que les développeurs ne veulent parfois pas aller au niveau de l'unité ou négliger le niveau de l'interface utilisateur.  Ce n'est ni mauvais ni bon - je répète que l'objectif principal des tests est la confiance.  Et un ensemble de tests d'intégration rapides et efficaces peut suffire à fournir cette confiance.  Cependant, il existe un risque qu'avec le temps, ces tests soient plus lents ou plus lents, ou commencent simplement à tester les composants de manière isolée, au lieu de l'intégration. </p><br><p>  Les tests d'intégration peuvent exécuter l'application telle qu'elle est ( <code>@SpringBootTest</code> ) ou son composant distinct (JPA, Web).  Dans mon cas, je veux écrire un test ciblé pour JPA - donc je n'ai pas besoin de configurer de contrôleurs ou d'autres composants.  L'annotation <code>@DataJpaTest</code> est responsable dans le Spring Boot Test.  Il s'agit d'une <em>méta</em> annotation, c'est-à-dire  Il combine plusieurs annotations différentes qui configurent différents aspects du test. </p><br><ul><li>  @AutoConfigureDataJpa </li><li>  @AutoConfigureTestDatabase </li><li>  @AutoConfigureCache </li><li>  @AutoConfigureTestEntityManager </li><li>  @Transactional </li></ul><br><p>  Je vais d'abord vous parler de chacun individuellement, puis je vais vous montrer le test terminé. </p><br><p>  <strong>@AutoConfigureDataJpa</strong> <br>  Il charge un ensemble complet de configurations et met en place des référentiels (génération automatique d'implémentations pour <code>CrudRepositories</code> ), des outils de migration pour les bases de données FlyWay et Liquibase, se connectant à la base de données à l'aide de DataSource, du gestionnaire de transactions et enfin d'Hibernate.  En fait, ce n'est qu'un ensemble de configurations pertinentes pour accéder aux données - ni <code>DispatcherServlet</code> de Web MVC, ni d'autres composants ne sont inclus ici. </p><br><p>  <strong>@AutoConfigureTestDatabase</strong> <br>  C'est l'un des aspects les plus intéressants du test JPA.  Cette configuration <em>recherche le chemin de classe pour l'une des bases de données incorporées prises en charge et reconfigure le contexte afin que le DataSource pointe vers une base de données en mémoire créée de façon aléatoire</em> .  Depuis que j'ai ajouté la dépendance à la base H2, je n'ai pas besoin de faire autre chose, le fait d'avoir cette annotation automatiquement pour chaque test fournira une base vide, et c'est tout simplement incroyablement pratique. </p><br><p>  Il convient de rappeler que cette base sera complètement vide, sans schéma.  Pour générer le circuit, il existe deux options. </p><br><ol><li>  Utilisez la fonction <strong>DDL</strong> automatique d'Hibernate.  Le Spring Boot Test définira automatiquement cette valeur sur <code>create-drop</code> afin qu'Hibernate génère un schéma à partir de la description de l'entité et le supprime à la fin de la session.  Il s'agit d'une fonctionnalité incroyablement puissante d'Hibernate, qui est très utile pour les tests. </li><li>  Utilisez les migrations créées par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flyway</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liquibase</a> . </li></ol><br><p>  Vous pouvez en savoir plus sur les différentes approches d'initialisation de la base de données dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . </p><br><p>  <strong>@AutoConfigureCache</strong> <br>  Il configure simplement le cache pour utiliser NoOpCacheManager - c'est-à-dire  ne cache rien.  Ceci est utile pour éviter les surprises lors des tests. </p><br><p>  <strong>@AutoConfigureTestEntityManager</strong> <br>  Ajoute un objet <code>TestEntityManager</code> spécial au <code>TestEntityManager</code> , qui en soi est une bête intéressante.  <code>EntityManager</code> est la classe principale de JPA, qui est responsable de l'ajout d'entités à la session, de la suppression et d'autres choses similaires.  Ce n'est que lorsque, par exemple, Hibernate entre en service - l'ajout d'une entité à une session ne signifie pas qu'une demande à la base de données sera exécutée et le chargement à partir d'une session ne signifie pas qu'une demande de sélection sera exécutée.  En raison des mécanismes internes d'Hibernate, les opérations réelles avec la base de données seront effectuées au bon moment, ce que le cadre lui-même déterminera.  Mais dans les tests, il peut être nécessaire d'envoyer de force quelque chose à la base de données, car le but des tests est de tester l'intégration.  Et <code>TestEntityManager</code> est juste une aide qui aidera à effectuer de force certaines opérations avec la base de données - par exemple, <code>persistAndFlush()</code> forcera Hibernate à exécuter toutes les requêtes. </p><br><p>  <strong>@Transactional</strong> <br>  Cette annotation rend tous les tests de la classe transactionnels, avec restauration automatique de la transaction à la fin du test.  Il s'agit simplement d'un mécanisme de «nettoyage» de la base de données avant chaque test, car sinon vous devrez supprimer manuellement les données de chaque table. </p><br><blockquote>  La question de savoir si un test doit gérer une transaction n'est pas une question aussi simple et évidente que cela puisse paraître.  Malgré la commodité de l'état «propre» de la base de données, la présence de <code>@Transactional</code> dans les tests peut être une surprise désagréable si le code de «bataille» ne démarre pas la transaction lui-même, mais nécessite un code existant.  Cela peut conduire au fait que le test d'intégration réussit, mais lorsque le code réel est exécuté à partir du contrôleur, et non à partir du test, le service n'aura pas de transaction active et la méthode lèvera une exception.  Bien que cela semble dangereux, avec des tests de haut niveau de tests d'interface utilisateur, les tests transactionnels ne sont pas si mauvais.  D'après mon expérience, je n'ai vu qu'une seule fois, lors d'un test d'intégration réussi, le code de production s'est écrasé, ce qui a clairement exigé l'existence d'une transaction existante.  Mais si vous devez toujours vérifier que les services et les composants gèrent eux-mêmes correctement les transactions, vous pouvez «bloquer» l'annotation <code>@Transactional</code> sur le test avec le mode souhaité (par exemple, ne démarrez pas la transaction). </blockquote><br><h1 id="integracionnyy-test-so-springboottest">  Test d'intégration avec @SpringBootTest </h1><br><p>  Je tiens également à noter que <code>@DataJpaTest</code> n'est pas un exemple unique de test d'intégration focale, il existe <code>@WebMvcTest</code> , <code>@DataMongoTest</code> et bien d'autres.  Mais l'une des annotations de test les plus importantes reste <code>@SpringBootTest</code> , qui lance l'application <em>«telle</em> quelle <em>»</em> pour les tests - avec tous les composants et intégrations configurés.  Une question logique se pose - si vous pouvez exécuter l'application entière, pourquoi faire des tests focaux DataJpa, par exemple?  Je dirais qu'il n'y a pas de règles strictes ici encore. </p><br><p>  S'il <em>est possible</em> d'exécuter des applications à chaque fois, d'isoler les plantages dans les tests, de ne pas surcharger et de ne pas compliquer à nouveau la configuration du test, alors bien sûr, vous pouvez et devez utiliser @SpringBootTest. </p><br><p>  Cependant, dans la vie réelle, les applications peuvent nécessiter de nombreux paramètres différents, se connecter à différents systèmes et je ne voudrais pas que mes tests d'accès à la base de données tombent, car  la connexion à la file d'attente des messages n'est pas configurée.  Par conséquent, il est important d'utiliser le bon sens, et si pour que le test avec l'annotation @SpringBootTest fonctionne, vous devez verrouiller la moitié du système - est-ce que cela a du sens alors dans @SpringBootTest? </p><br><h1 id="podgotovka-dannyh-dlya-testa">  Préparation des données pour le test </h1><br><p>  L'un des points clés des tests est la préparation des données.  Chaque test doit être effectué de manière isolée et préparer l'environnement avant de démarrer, amenant le système à son état d'origine souhaité.  L'option la plus simple pour ce faire consiste à utiliser les annotations <code>@BeforeEach</code> / <code>@BeforeAll</code> et à y ajouter des entrées à la base de données à l'aide du référentiel, <code>TestEntityManager</code> ou <code>TestEntityManager</code> .  Mais il existe une autre option qui vous permet d'exécuter un script préparé ou d'exécuter la requête SQL souhaitée, c'est l'annotation <code>@Sql</code> .  Avant d'exécuter le test, le Spring Boot Test exécutera automatiquement le script spécifié, éliminant la nécessité d'ajouter le bloc <code>@BeforeAll</code> , et <code>@Transactional</code> se chargera du <code>@Transactional</code> données. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaCakeFinderTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Red Velvet"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String NON_PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Victoria Sponge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CakeFinder finder; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> CakeRepository cakeRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> TestEntityManager testEntityManager; <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().title(PROMOTED_CAKE) .sku(<span class="hljs-string"><span class="hljs-string">"SKU1"</span></span>).price(BigDecimal.TEN).promoted(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().sku(<span class="hljs-string"><span class="hljs-string">"SKU2"</span></span>) .title(NON_PROMOTED_CAKE).price(BigDecimal.ONE).promoted(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).build()); finder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JpaCakeFinder(cakeRepository); } ... }</code> </pre> <br><h1 id="red-green-refactor-cikl">  Cycle de refactorisation rouge-vert </h1><br><p>  Malgré cette quantité de texte, pour le développeur, le test ressemble toujours à une classe simple avec l'annotation @DataJpaTest, mais j'espère que j'ai pu montrer combien de choses utiles se passent sous le capot, auxquelles le développeur ne peut pas penser.  Nous pouvons maintenant passer au cycle TDD et cette fois, je vais montrer quelques itérations TDD, avec des exemples de refactoring et de code minimal.  Pour le rendre plus clair, je vous recommande fortement de regarder l'historique dans Git, où chaque commit est une étape distincte et significative avec une description de ce qu'il fait et comment il le fait. </p><br><h2 id="podgotovka-dannyh">  Préparation des données </h2><br><p>  J'utilise l'approche avec <code>@BeforeAll</code> / <code>@BeforeEach</code> et crée manuellement tous les enregistrements de la base de données.  L'exemple avec l'annotation <code>@Sql</code> a été déplacé dans une classe distincte <code>JpaCakeFinderTestWithScriptSetup</code> , il duplique les tests, ce qui, bien sûr, ne devrait pas l'être, et existe dans le seul but de démontrer l'approche. </p><br><p>  L'état initial du système - il y a deux entrées dans le système, un gâteau participe à la promotion et doit être inclus dans le résultat retourné par la méthode, le second - non. </p><br><h2 id="pervyy-test-integracionnyy-test">  Premier test test d'intégration </h2><br><p>  Le premier test est le plus simple - <code>findPromotedCakes</code> doit inclure une description et le prix du gâteau participant à la promotion. </p><br><h3 id="red">  Rouge </h3><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle).contains(PROMOTED_CAKE); assertThat(promotedCakes).extracting(Cake::getPrice).contains(<span class="hljs-string"><span class="hljs-string">"£10.00"</span></span>); }</code> </pre> <br><p>  Le test se bloque, bien sûr, l'implémentation par défaut renvoie un ensemble vide. </p><br><h3 id="green">  Vert </h3><br><p>  Naturellement, nous aimerions écrire immédiatement le filtrage, faire une demande à la base de données avec <code>where</code> et ainsi de suite.  Mais suivant la pratique TDD, je dois écrire le <em>code minimum pour que le test réussisse</em> .  Et ce code minimal consiste à renvoyer tous les enregistrements de la base de données.  Oui, si simple et ringard. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal price)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"£"</span></span> + price.setScale(<span class="hljs-number"><span class="hljs-number">2</span></span>, RoundingMode.DOWN).toPlainString(); }</code> </pre> <br><blockquote>  Certains diront probablement qu'ici, vous pouvez rendre le test vert même sans base - il suffit de coder en dur le résultat attendu par le test.  J'entends parfois un tel argument, mais je pense que tout le monde comprend que le TDD n'est pas un dogme ou une religion, cela n'a aucun sens d'amener cela au point d'absurdité.  Mais si vous le voulez vraiment, vous pouvez, par exemple, randomiser des données sur l'installation afin qu'elles ne soient pas codées en dur. </blockquote><br><h3 id="refactor">  Refactor </h3><br><p>  Je ne vois pas beaucoup de refactoring ici, donc cette phase peut être ignorée pour ce test particulier.  Mais je ne recommanderais toujours pas d'ignorer cette phase, il vaut mieux s'arrêter et penser à chaque fois dans l'état «vert» du système - est-il possible de refactoriser quelque chose pour le rendre meilleur et plus facile? </p><br><h2 id="vtoroy-test">  Deuxième test </h2><br><p>  Mais le deuxième test vérifiera déjà qu'aucun gâteau promu ne tombera dans le résultat renvoyé par <code>findPromotedCakes</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldNotReturnNonPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle) .doesNotContain(NON_PROMOTED_CAKE); }</code> </pre> <br><h3 id="red-1">  Rouge </h3><br><p>  Comme prévu, le test se bloque - il y a deux enregistrements dans la base de données et le code les renvoie simplement tous. </p><br><h3 id="green-1">  Vert </h3><br><p>  Et encore une fois, vous pouvez penser - et quel est le code minimum que vous pouvez écrire pour réussir le test?  Puisqu'il y a déjà un flux et son assemblage, vous pouvez simplement y ajouter un bloc de <code>filter</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .filter(cakeEntity -&gt; cakeEntity.promoted) .map(cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  Nous recommençons les tests - les tests d'intégration sont désormais verts.  Un moment important est venu - grâce à la combinaison du test unitaire du contrôleur et du test d'intégration pour travailler avec la base de données, ma fonctionnalité est prête - et le test de l'interface utilisateur passe maintenant! </p><br><h3 id="refactor-1">  Refactor </h3><br><p>  Et puisque tous les tests sont verts - il est temps de refactoriser.  Je pense qu'il n'est pas nécessaire de préciser que le filtrage en mémoire n'est pas une bonne idée, il vaut mieux le faire dans la base de données.  Pour ce faire, j'ai ajouté une nouvelle méthode dans le <code>CakesRepository</code> - <code>CakesRepository</code> : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Iterable&lt;CakeEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByPromotedIsTrue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Pour cette méthode, Spring Data a généré automatiquement une méthode qui exécutera une requête du formulaire de <code>select from cakes where promoted = true</code> .  En savoir plus sur la génération de requêtes dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> Spring Data. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findByPromotedIsTrue() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  C'est un bon exemple de la flexibilité offerte par les tests d'intégration et l'approche par boîte noire.  Si le référentiel était verrouillé, il n'était pas impossible d'ajouter une nouvelle méthode sans modifier les tests. </p><br><h1 id="podklyuchenie-k-production-baze">  Connexion à la base de production </h1><br><p>  Pour ajouter un peu de «réalisme» et montrer comment séparer la configuration des tests et l'application principale, j'ajouterai une configuration d'accès aux données pour l'application «production». </p><br><p>  Tout est traditionnellement ajouté par la section dans <code>application.yml</code> : </p><br><pre> <code class="plaintext hljs">datasource: url: jdbc:h2:./data/cake-factory</code> </pre><br><p>  Cela enregistrera automatiquement les données du système de fichiers dans le dossier <code>./data</code> .  Je note que ce dossier ne sera pas créé dans les tests - <code>@DataJpaTest</code> remplacera automatiquement la connexion à la base de données de fichiers par une base de données aléatoire en mémoire en raison de la présence de l'annotation <code>@AutoConfigureTestDatabase</code> . </p><br><blockquote>   ,    —   <code>data.sql</code>  <code>schema.sql</code> .   , Spring Boot             .          ,   , ,    . </blockquote><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p> ,               ,    ,       TDD . </p><br><p>      Spring Security —                Spring,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433958/">https://habr.com/ru/post/fr433958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433946/index.html">Aide-mémoire pour l'intelligence artificielle - jetez l'excédent, enseignez l'essentiel. Technique de traitement des séquences de formation</a></li>
<li><a href="../fr433948/index.html">Comment rendre le paiement plus pratique: l'expérience d'un fournisseur IaaS</a></li>
<li><a href="../fr433952/index.html">10 raisons de choisir une solution pour SAP HANA de HPE. 2e partie</a></li>
<li><a href="../fr433954/index.html">Huit technologies audio et gadgets audio qui entreront au Temple de la renommée de TECnology en 2019</a></li>
<li><a href="../fr433956/index.html">Les modders ont utilisé l'IA pour améliorer la texture dans les jeux</a></li>
<li><a href="../fr433964/index.html">Modules ECMAScript dans Node.js: un nouveau plan</a></li>
<li><a href="../fr433966/index.html">Carte de Noël de Mars. L'ESA a montré une grande accumulation de glace à la surface de la planète rouge</a></li>
<li><a href="../fr433968/index.html">Le jeu de communication le plus dégénéré</a></li>
<li><a href="../fr433972/index.html">HolyJS 2018 Moscou à travers les yeux du participant</a></li>
<li><a href="../fr433974/index.html">Chatbot fait entendre ou souffre amateur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>