<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😧 🦁 🌶️ Cara kerja kriptografi kurva elips di TLS 1.3 🐮 🌲 🐚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa peringatan pembaca: 

 Untuk (agak) menyederhanakan proses deskripsi dan memperketat volume artikel yang akan kita tulis, penting untuk membu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja kriptografi kurva elips di TLS 1.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/474810/"><img src="https://hsto.org/webt/qy/r5/a6/qyr5a6ywaf8vbc2kxtaazdmvgz8.png" alt="gambar"><br><br>  Beberapa peringatan pembaca: <br><br>  Untuk (agak) menyederhanakan proses deskripsi dan memperketat volume artikel yang akan kita tulis, penting untuk membuat komentar yang signifikan dan segera menyatakan batasan utama - semua yang akan kami sampaikan kepada Anda hari ini tentang hal praktis sisi problematika hanya dapat dilakukan dalam hal TLS 1.3.  Berarti bahwa sementara sertifikat ECDSA Anda masih akan bekerja di TLS 1.2 jika Anda menginginkannya, memberikan kompatibilitas ke belakang, deskripsi proses jabat tangan yang sebenarnya, pakaian sandi dan tolok ukur server klien hanya mencakup TLS 1.3 saja.  Tentu saja, ini tidak berhubungan dengan deskripsi matematis dari algoritma di balik sistem enkripsi modern. <br><br>  Artikel ini ditulis oleh matematikawan atau insinyur - meskipun mereka membantu menemukan jalan di sekitar matematika menakutkan dan meninjau artikel ini.  Terima kasih banyak kepada karyawan Qrator Labs. <br><br><h3>  ( <b>E</b> lliptic <b>C</b> urve) <b>D</b> iffie- <b>H</b> ellman ( <b>E</b> phemeral) </h3> <b>Warisan Diffie - Hellman di abad ke-21</b> <br><br>  Tentu saja, ini sudah dimulai dengan baik Diffie maupun Hellman.  Tetapi untuk memberikan garis waktu yang benar, kita perlu menunjukkan tanggal dan acara utama. <br><br>  Ada beberapa kepribadian utama dalam pengembangan kriptografi modern.  Yang paling menonjol, Alan Turing dan Claud Shannon keduanya bekerja dalam jumlah yang luar biasa di bidang teori komputasi dan teori informasi serta kriptanalisis umum, dan baik Diffie maupun Hellman, secara resmi dikreditkan karena memunculkan gagasan kunci publik. (atau disebut asimetris) kriptografi (meskipun diketahui bahwa di Inggris ada kemajuan serius dalam kriptografi yang bertahan dalam kerahasiaan untuk waktu yang sangat lama), membuat kedua pria ini menjadi perintis. <br><br>  Tepatnya apa? <br><a name="habracut"></a><br>  Yah, ini mungkin terdengar aneh;  Namun, sebelum 6 November 1976, tidak ada pengetahuan publik tentang sistem enkripsi kunci publik.  Whitfield Diffie dan Martin Hellman (dan, pada kenyataannya, Ralph Merkle) - matematikawan, insinyur komputer dan penggemar, serta ahli kriptologi adalah yang pertama. <br><br>  Bagi mereka yang tidak sadar - karena peran cryptanalysis mengambil alih selama Perang Dunia II dan dampaknya yang sangat besar pada menjaga informasi secara rahasia, kedua negara yang percaya bahwa mereka memiliki pengetahuan kriptografi paling maju - AS dan Inggris memasukkan enkripsi ke dalam Daftar Munisi mereka dan memanfaatkannya. larangan ekspor yang berat (secara bersamaan melemahkan implementasi enkripsi untuk penggunaan pribadi dan komersial dalam negeri).  Untuk alasan ini, para peneliti Inggris yang bekerja di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20141030210530/">teknik pertukaran kunci asimetris</a> di Kantor Pusat Komunikasi Pemerintah dan mengembangkan skema analog tidak diakui untuk penemuan ini sampai 1997, ketika pembatasan pada algoritma kriptografi dan deskripsi mereka dibuat tidak efektif. <br><br>  Kembali ke penemu ganda kami - apa yang telah Diffie dan Hellman rubah secara khusus? <br><br>  Mari kita lihat makalah asli mereka, dengan sempurna menggambarkan lompatan raksasa yang telah mereka perkenalkan (bahkan secara teoritis dengan makalah penelitian mereka): <br><img src="https://habrastorage.org/webt/tt/rb/ig/ttrbigv4-qiw2ugkittwgox65se.png" alt="gambar"><br>  Dan yang berikut: <br><img src="https://habrastorage.org/webt/3c/n5/6g/3cn56g2moitap1tsu-dpsnspfc4.png" alt="gambar"><br>  Kedua gambar ini dengan sempurna menggambarkan perubahan besar yang diperkenalkan Whitfield Diffie dan Martin Hellman setelah kriptografi dan kriptanalisis abad evolusi - pembentukan kunci rahasia bersama sebagai hasil dari perhitungan kriptografi. <br><br>  Mari kita lihat gambar bagus lainnya dengan warna: <br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Diffie-Hellman_Key_Exchange.svg/375px-Diffie-Hellman_Key_Exchange.svg.png" alt="gambar"><br><br>  Ini menjelaskan apa yang sedang terjadi.  Sebelum Diffie dan Hellman perjanjian kunci penemuan, hanya ada satu kunci simetris - digunakan baik untuk mengenkripsi dan mendekripsi pesan.  Jika Anda ingin memberikan "kunci" kepada seseorang, itu harus ditransfer melalui saluran "aman".  Anda dapat membayangkan semua batasan skema generasi sebelumnya - Anda membutuhkan saluran aman yang sudah ada, Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak dapat menggunakan kembali kunci</a> , dan, idealnya, panjang kunci harus sama dengan panjang pesan. <br><br>  Claude Shannon dalam karyanya yang diklasifikasikan sebagai masa perang " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori Komunikasi Sistem Kerahasiaan</a> " membuktikan bahwa semua sandi yang tidak dapat dipecahkan secara teoritis harus memiliki persyaratan yang sama dengan pad satu kali - yang dikenal sebagai sandi Vernam, oleh penulis sandi aliran poliffabetik simetris ini. <br><br>  Sekali lagi, kita akan melihat kertas aslinya: <br><img src="https://habrastorage.org/webt/p1/p0/yf/p1p0yfmprijaobfof3kb2lu4bpk.png" alt="gambar"><br><br>  Sebelum kita melangkah lebih jauh, mari kita bertanya pada diri sendiri - bagaimana dua, bahkan jika brilian, manusia muncul dengan peningkatan yang begitu signifikan dalam bidang terapan dengan sejarah seperti itu, terutama pada saat perang? <br>  Yah, karena: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori informasi</a> , dirumuskan oleh Claude Shannon; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori perhitungan</a> dipengaruhi oleh, terutama, Gereja Alonzo, John von Neumann, dan Alan Turing; </li><li>  Dan, yang lebih penting, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori komputabilitas</a> sebagian besar didasarkan pada karya Turing, yang bisa kita katakan semua dikembangkan dan matang pada periode yang sama di abad ke-20.  Diffie dan Hellman sama-sama menyebut Claude Shannon sebagai orang yang paling berpengaruh dalam pekerjaan mereka. </li></ul><br>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keamanan Universal</a> " Lenstra menggambarkan jumlah energi yang dibutuhkan untuk "memecahkan" kriptografi simetris dengan berbagai panjang kunci.  Ternyata memecahkan kunci kurva eliptik 228-bit yang panjang akan membutuhkan jumlah energi yang sama yang diperlukan untuk merebus semua air di Bumi.  Namun, itu hanya valid dengan pertimbangan algoritma dan perangkat keras yang diketahui, karena, sebenarnya, tidak ada yang tahu apakah ada algoritma atau perangkat keras yang jauh lebih efisien.  Kunci EC 228-bit sebanding dengan kunci RSA panjang 2380-bit, lebih lanjut tentang itu nanti.  Meskipun dalam estimasi ini kunci RSA dan EC digunakan dalam skema enkripsi asimetris, panjang kunci semacam itu agak setara dengan kunci enkripsi simetris 128-bit. <br><br>  Sangat mudah untuk membayangkan bahwa sesuatu yang "sulit untuk dihitung" akan membutuhkan banyak energi dan / atau waktu yang dibutuhkan untuk perhitungan.  Kita cenderung berpikir bahwa komputer dapat "menghitung semuanya", tetapi ternyata itu tidak benar.  Pertama, ada contoh-contoh yang tidak dapat dipastikan, seperti masalah penghentian, meskipun dalam bidang kriptografi, kita dapat menghindari perangkap ini.  Kedua, jika kita mempertimbangkan waktu yang dibutuhkan untuk menjalankan algoritma tertentu, itu mungkin arbitrary tinggi.  Itulah yang kami manfaatkan dalam kriptografi.  Masalah dianggap "mudah" untuk dihitung jika waktu yang diperlukan untuk menjalankan masing-masing algoritma tergantung pada ukuran input (diukur dalam bit) seperti polinomial: <math> </math> $ inline $ T (n) = O (n ^ k) $ inline $   , untuk beberapa konstanta positif <math> </math> $ inline $ k $ inline $   .  Dalam bidang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori kompleksitas komputasi</a> , masalah tersebut membentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas kompleksitas P.</a> <br><br>  Kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompleksitas P</a> hampir menjadi pusat, karena mewakili masalah yang ada algoritma waktu polinomial deterministik.  Kelas kompleksitas lainnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NP</a> (masalah yang “sulit” untuk dihitung), mewakili serangkaian masalah keputusan, yaitu, masalah yang membutuhkan jawaban “ya” atau “tidak”, yang memiliki bukti yang dapat diverifikasi dalam waktu polinomial.  Anda melihat kata "bukti" di sini?  Di situlah kita sampai ke fungsi pintu jebakan, milik kelas kompleksitas NP. <br><br><img src="https://imgs.xkcd.com/comics/travelling_salesman_problem.png" alt="gambar"><br>  Kredit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xkcd</a> <br><br><h3>  Fungsi satu arah;  Fungsi trapdoor </h3><br>  Menurut definisi, fungsi satu arah adalah fungsi yang mudah untuk dihitung pada setiap input tetapi sulit untuk dibalik, yaitu menghitung input asli yang diberikan hanya output.  "Mudah" dan "keras" merujuk pada definisi teori kompleksitas komputasi di atas.  Menariknya, bahwa keberadaan fungsi satu arah tidak (secara matematis) terbukti karena keberadaan mereka akan membuktikan bahwa kelas kompleksitas P dan NP tidak sama, sedangkan P sama dengan NP atau tidak saat ini merupakan masalah terbuka.  Jadi, perlu diingat bahwa semua kriptografi modern bergantung pada hipotesis yang tidak terbukti. <br><br>  Sekarang, dalam makalah aslinya, Diffie dan Hellman memperkenalkan generasi lain dari fungsi satu arah yang mereka sebut "fungsi pintu jebakan".  Bagaimana mereka berbeda? <br>  Seperti yang mereka jelaskan dalam makalah tengara mereka: <blockquote>  Dalam kriptografi kunci-publik, penyandian dan penguraian diatur oleh kunci yang berbeda, E dan D, sehingga komputasi D dari E tidak dapat dilakukan secara komputasi (misalnya membutuhkan <math> </math> $ inline $ 10 ^ {100} $ inline $   instruksi).  Kunci penyandian E dapat diungkapkan [dalam direktori] tanpa mengurangi kunci penguraian D. Ini memungkinkan setiap pengguna sistem untuk mengirim pesan ke pengguna lain yang dienkripsi sedemikian rupa sehingga hanya penerima yang dimaksudkan yang dapat menguraikannya. .. Masalah otentikasi mungkin bahkan menjadi penghalang yang lebih serius terhadap adopsi universal telekomunikasi untuk transaksi bisnis daripada masalah distribusi utama ... [itu] ... adalah inti dari sistem apa pun yang melibatkan kontrak dan penagihan. </blockquote>  Dengan konvensi, karakter kriptografi "Alice" dan "Bob" (mencari komunikasi yang aman) sering digunakan untuk menjelaskan konsep kunci publik.  Alice dan Bob menyetujui bilangan bulat besar <math> </math> $ inline $ n $ inline $   dan <math> </math> $ inline $ g $ inline $   dengan <math> </math> $ inline $ 1 &lt;g &lt;n $ inline $   .  Seleksi berdampak pada keamanan sistem.  “Modulusnya <math> </math> $ inline $ n $ inline $   harus menjadi yang utama;  lebih penting <math> </math> $ inline $ (n-1) / 2 $ inline $   juga harus menjadi yang utama &lt;...&gt; dan <math> </math> $ inline $ g $ inline $   harus menjadi modulo root primitif <math> </math> $ inline $ n $ inline $   &lt;...&gt; [dan] <math> </math> $ inline $ n $ inline $   harus &lt;...&gt; paling tidak panjangnya 512 bit. ”Protokol Diffie - Hellman dapat dinyatakan dalam bentuk elemen dalam 5 langkah. <br><br><ol><li>  Alice memilih <math> </math> $ inline $ x $ inline $   (bilangan bulat acak besar) dan menghitung <math> </math> $ inline $ X = g ^ x \ bmod n $ inline $ </li><li>  Bob memilih <math> </math> $ inline $ y $ inline $   (bilangan bulat acak besar) dan menghitung <math> </math> $ inline $ Y = g ^ y \ bmod n $ inline $ </li><li>  Alice mengirim <math> </math> $ inline $ X $ inline $   untuk Bob, sementara Bob mengirim <math> </math> $ inline $ Y $ inline $   untuk Alice (mereka tetap <math> </math> $ inline $ x $ inline $   dan <math> </math> $ inline $ y $ inline $   rahasia satu sama lain) </li><li>  Alice menghitung <math> </math> $ inline $ k = Y ^ x \ bmod n $ inline $ </li><li>  Bob menghitung <math> </math> $ inline $ k '= X ^ y \ bmod n $ inline $ </li></ol><br>  Akibatnya Alice dan Bob memiliki nilai yang sama <math> </math> $ inline $ k = k '$ inline $   yang berfungsi sebagai rahasia bersama. <br><br>  Fungsi trapdoor adalah fungsi satu arah yang memungkinkan untuk menemukan kebalikannya jika seseorang memiliki informasi khusus yang disebut "pintu jebakan".  Kedengarannya mudah, meskipun agak sulit untuk menemukan fungsi-fungsi tersebut - metode pertama yang layak ditemukan dalam implementasi algoritma enkripsi asimetris kriptografi kunci publik bernama RSA setelah penciptanya: Ron Rivest, Adi Shamir dan Leonard Adleman. <br><br><h3>  RSA </h3><br>  Dalam RSA kekerasan fungsi pembalikan didasarkan pada fakta bahwa anjak (mencari pengganda utama angka) membutuhkan waktu lebih banyak daripada perkalian, atau haruskah kita katakan di sini bahwa tidak ada metode waktu polinomial untuk memfaktorkan bilangan bulat besar pada komputer klasik memiliki telah ditemukan, bagaimanapun, belum terbukti bahwa tidak ada. <br><br>  Di RSA, seperti dalam sistem enkripsi kunci publik lainnya, ada dua kunci: publik dan pribadi.  RSA menerima pesan input (direpresentasikan sebagai string bit) dan menerapkan operasi matematika (modul eksponensial bilangan bulat besar) untuk mendapatkan hasil yang terlihat tidak dapat dibedakan dari acak.  Dekripsi mengambil hasil ini dan menerapkan operasi serupa untuk mendapatkan kembali pesan aslinya.  Dalam kriptografi asimetris, enkripsi dibuat dengan kunci publik dan dekripsi dengan yang pribadi. <br><br>  Bagaimana?  Karena operan milik grup siklik terbatas (satu set bilangan bulat dengan perkalian dalam aritmatika modular).  omputer tidak berurusan dengan angka-angka besar yang sewenang-wenang, tetapi, untungnya, grup bilangan bulat kami adalah untuk melakukan operasi yang disebut "membungkus" - angka yang lebih besar dari jumlah maksimum yang diizinkan dibungkus ke angka dalam rentang valid yang kami operasikan .  Ini memungkinkan kami untuk beroperasi dengan kunci yang panjangnya "tidak lebih dari".  Dalam kurva eliptik, kriptografi, kelompok siklik (multiplikasi) digunakan juga tetapi dikonstruksi sedikit berbeda seperti yang akan kita lihat nanti. <br><br>  Pada dasarnya yang dilakukan RSA adalah mengambil dua bilangan prima besar dan mengalikannya untuk mendapatkan apa yang disebut modulus.  Semua angka lain yang harus ditangani berada di antara nol dan modulus.  Modulus harus menjadi bagian dari kunci publik, dan panjang bitnya menentukan panjang kunci.  Bagian kedua dari kunci publik adalah angka yang dipilih antara nol dan jumlah Euler (implementasi RSA modern mengambil jumlah Carmichael dan bukan Euler) dari modulus dengan beberapa batasan tambahan.  Akhirnya, kunci pribadi harus dihitung dengan menyelesaikan beberapa persamaan modular.  Untuk mengenkripsi angka, kami hanya menaikkannya ke kekuatan yang sama dengan kunci publik, dan untuk mendekripsi kembali nomor, kami menaikkannya ke kekuatan yang sama dengan kunci pribadi.  Berkat sifat siklus grup, kami mendapatkan kembali angka awal. <br><br>  Ada dua masalah signifikan dengan RSA saat ini, satu menjadi konsekuensi dari yang lain.  Seiring panjang kunci (mis., Jumlah bitnya) tumbuh, faktor kompleksitas tumbuh tidak secepat yang diharapkan.  Itu karena ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma</a> faktorisasi sub-eksponensial (tapi masih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">super polinomial</a> ).  Jadi, untuk menjaga tingkat keamanan yang tepat, panjang kunci RSA perlu tumbuh agak lebih cepat daripada panjang kunci ECC.  Itu sebabnya kunci RSA yang paling luas saat ini adalah 2048 atau 3072 bit. <br><br>  Beberapa saat kemudian, kita akan melihat dalam angka bagaimana panjang kunci mempengaruhi efisiensi cryptosystem secara keseluruhan dengan membandingkan sertifikat RSA dan ECDSA yang ditandatangani dengan otoritas Let's Encrypt. <br><br><h3>  ( <b>E</b> lliptic <b>C</b> urve) <b>D</b> igital <b>S</b> ignature <b>A</b> lgorithm </h3><br>  Pencarian untuk fungsi pintu jebakan yang lebih baik akhirnya menyebabkan cryptographers untuk secara aktif berkembang di pertengahan 80-an cabang matematika yang didedikasikan untuk kurva elips. <br><br>  Ini akan menjadi tugas utama untuk menggambarkan kriptografi kurva eliptik dalam satu artikel, jadi kita tidak akan melakukannya.  Sebagai gantinya, mari kita lihat fungsi pintu jebakan kurva eliptik berdasarkan masalah logaritma diskrit. <br><br>  Ada banyak primer dan pengantar yang lebih mendalam tentang kriptografi kurva eliptik, dan kami terutama akan merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"ECC: pengantar lembut" karya Andrea Corbellini</a> jika Anda tertarik pada matematika. <br><br>  Yang kami minati adalah parameter yang “sederhana”. <br><br>  Kurva eliptik didefinisikan oleh persamaan seperti ini: <math> </math> $ inline $ y ^ 2 = x ^ 3 + ax + b $ inline $ <br>  Kurva seperti itu diperlukan untuk membangun subkelompok siklik di atas bidang yang terbatas.  Oleh karena itu, parameter berikut digunakan: <br><br><ul><li>  <b>Perdana</b> <math> </math> <b>$ inline $ p $ inline $</b>   yang menentukan ukuran bidang hingga; </li><li>  <b>Koefisien</b> <math> </math> <b>$ inline $ a $ inline $</b>   <b>dan</b> <math> </math> <b>$ inline $ b $ inline $</b>   persamaan kurva eliptik; </li><li>  Titik <b>dasar</b> <math> </math> <b>$ inline $ g $ inline $</b>   yang menghasilkan subkelompok yang disebutkan; </li><li>  <b>Pesanan</b> <math> </math> <b>$ inline $ n $ inline $</b>   dari subkelompok; </li><li>  <b>Kofaktor</b> <math> </math> <b>$ inline $ h $ inline $</b>   dari subkelompok. </li></ul><br>  Kesimpulannya, <b>parameter domain</b> untuk algoritma kami adalah <b>sextuplet</b> <math> </math> $ inline $ (p, a, b, G, n, h) $ inline $   . <br>  Kurva eliptik seperti itu bekerja di atas bidang hingga <math> </math> $ inline $ \ mathbb {F} _p $ inline $   dimana <math> </math> $ inline $ p $ inline $   adalah bilangan prima yang agak besar.  Jadi kami memiliki satu set bilangan bulat modulo <math> </math> $ inline $ p $ inline $   , di mana operasi, seperti penjumlahan, pengurangan, perkalian, inversi aditif, inversi multiplikatif dimungkinkan.  Penambahan dan perkalian bekerja mirip dengan aritmatika "jam" modular atau biasa kita lihat di RSA "wrap arounds". <br>  Karena kurva simetris tentang sumbu x, diberikan titik apa pun <math> </math> $ inline $ P $ inline $   , kita bisa ambil <math> </math> $ inline $ −P $ inline $   menjadi titik sebaliknya.  Kami ambil <math> </math> $ inline $ −O $ inline $   menjadi adil <math> </math> $ inline $ O $ inline $   . <br>  Penambahan untuk titik kurva didefinisikan dengan cara yang memberikan poin <math> </math> $ inline $ P $ inline $   dan <math> </math> $ inline $ Q $ inline $   , kita bisa menggambar garis yang memotong kedua titik tersebut dan kurva yang memotong di titik ketiga <math> </math> $ inline $ R $ inline $   jadi itu <math> </math> $ inline $ P + Q = -R $ inline $   dan <math> </math> $ inline $ P + Q + R = 0 $ inline $   . <br><br>  Mari kita lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjelasan Marc Hughes</a> : <br><blockquote><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig09.jpg" alt="gambar"><br><br>  Garis kemiringan konstan yang bergerak di sepanjang permukaan torus ditunjukkan di atas.  Baris ini melewati dua titik integer yang dipilih secara acak pada kurva. <br><br><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig10.gif" alt="gambar"><br><br>  Untuk menambahkan dua titik pada grafik, gambarlah garis dari titik yang dipilih pertama <math> </math> $ inline $ P $ inline $   ke titik yang dipilih kedua <math> </math> $ inline $ Q $ inline $   , dan perluas garis sampai memotong titik lain pada grafik <math> </math> $ inline $ -R $ inline $   , perluas melintasi batas plot jika perlu. <br><br>  Setelah Anda mencegat titik integer, mencerminkan titik secara vertikal di tengah grafik (garis oranye bertitik) untuk menemukan titik baru <math> </math> $ inline $ R $ inline $   pada grafik.  Oleh karena itu <math> </math> $ inline $ P + Q = R $ inline $   . </blockquote>  Perkalian dengan skalar sekarang sepele: <math> </math> $ inline $ n \ cdot P = P + P + P + \ dots + P $ inline $   (ini dia <math> </math> $ inline $ n $ inline $   summands). <br><br>  Fungsi pintu jebakan di sini terletak di dalam masalah logaritma diskrit (untuk kurva elips), bukan faktorisasi yang kami lihat di dalam bagian RSA.  Masalahnya adalah: jika kita tahu <math> </math> $ inline $ P $ inline $   dan <math> </math> $ inline $ Q $ inline $   , apa itu <math> </math> $ inline $ k $ inline $   itu <math> </math> $ inline $ Q = k \ cdot P $ inline $   ? <br><br>  Baik masalah faktorisasi (yang mendasari RSA) dan logaritma diskrit untuk kurva elips (yang merupakan dasar untuk ECDSA dan ECDH) seharusnya sulit, mis., Tidak ada algoritma yang diketahui untuk memecahkan masalah ini dalam waktu polinomial untuk kunci yang diberikan panjangnya <br><br>  Sementara, biasanya, siapa pun akan dipermalukan karena mencampurkan pertukaran kunci (ECDH) dengan algoritma tanda tangan (ECDSA), kita perlu menjelaskan bagaimana mereka bekerja bersama.  Sertifikat TLS modern berisi kunci publik, dalam kasus kami, dari pasangan kunci yang dihasilkan algoritma kurva eliptik, biasanya ditandatangani oleh otoritas tingkat yang lebih tinggi.  Klien memverifikasi tanda tangan server dan mendapatkan rahasia bersama.  Rahasia bersama digunakan dalam algoritma enkripsi simetris, seperti AES atau ChaCha20.  Namun, prinsipnya tetap sama: sepakati parameter domain (sextuplet), dapatkan pasangan kunci, di mana kunci pribadi adalah bilangan bulat yang dipilih secara acak (multiplicand dari <math> </math> $ inline $ Q = k \ cdot P $ inline $   ), dan kunci publik adalah titik di kurva.  Algoritme tanda tangan menggunakan titik dasar <math> </math> $ inline $ g $ inline $   , yang merupakan generator untuk subkelompok pesanan utama yang besar <math> </math> $ inline $ n $ inline $   , seperti itu <math> </math> $ inline $ n \ cdot G = 0 $ inline $   , di mana 0 adalah elemen identitas.  Tanda tangan membuktikan bahwa koneksi aman sedang dibuat dengan pihak asli - server yang memiliki sertifikat TLS (kunci publik) yang ditandatangani oleh beberapa otoritas sertifikat untuk nama server yang diberikan. <br><br><h3>  (EC) DH (E) + ECDSA = Bentuk jabat tangan saat ini </h3><br>  Dalam TLS modern (1.3) klien dan server menghasilkan pasangan kunci publik-pribadi mereka dengan cepat, sementara membuat koneksi, ini disebut versi kunci pertukaran Ephemeral.  Perpustakaan TLS browser paling populer mendukung ini.  Sebagian besar mereka menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kurva eliptik Edwards 25519</a> , diperkenalkan oleh Daniel J. Bernstein (djb), menawarkan keamanan 128-bit.  Sejak 2014 openssh menggunakan kurva ini untuk pembuatan pasangan kunci.  Pada tahun 2019, browser masih tidak mendukung sesi TLS dengan server yang memiliki sertifikat dengan kunci publik EdDSA. <br><br>  Tapi mari kita kembali ke bagaimana semuanya bekerja pada akhir 2019 dengan TLS 1.3. <br><br>  Mekanisme pertukaran kunci dalam TLS 1.3 terbatas pada (EC) DH (E) berbasis (dengan x25519 adalah yang didukung di perpustakaan TLS sisi klien dari browser paling populer serta perpustakaan TLS sisi server, seperti OpenSSL, yang akan kami periksa sedikit kemudian), dan daftar paket sandi hanya berisi tiga entri: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384 dan TLS_CHACHA20_POLY1305_SHA256.  Bagi Anda yang mengetahui bagaimana cipher suites diberi nama dalam versi TLS 1.2, segera terlihat bahwa mekanisme pertukaran kunci sekarang "terlepas" dari nama cipher suite, juga RSA statis dan Diffie - Hellman yang statis, mode pertukaran dihapus. dari spesifikasi seluruhnya.  Bahkan dimulainya kembali sesi berdasarkan PSK dibuat lebih dari ECDHE di TLS 1.3.  Hal ini juga berlaku untuk parameter DH khusus, yang tidak diizinkan sekarang, hanya menyisakan yang umumnya disepakati untuk aman dalam spesifikasi protokol final. <br><br>  Sangat menarik bahwa ada perbedaan yang cukup signifikan dalam cara kerja algoritma enkripsi asimetris saat ini.  Dengan ECC (dan sertifikat ECDSA pada khususnya) kami menggunakan kunci yang lebih kecil untuk mencapai tingkat keamanan yang "nyaman", dibandingkan dengan RSA.  Itu memungkinkan penggunaan algoritma enkripsi asimetris yang lebih kuat dan mekanisme pertukaran kunci pada perangkat yang lebih kecil dan kadang-kadang bahkan dalam hal-hal yang umumnya tidak dianggap sebagai perangkat (smartcard). <br><br>  Pertama-tama, perlu disebutkan apa yang dimaksud dengan "cryptosystem hybrid" dalam hal TLS 1.3. <br>  Hybrid cryptosystem adalah yang menggunakan enkripsi asimetris (kunci publik) untuk membangun rahasia bersama, yang selanjutnya digunakan sebagai kunci dalam aliran simetris atau blok cipher. <br><br>  Kedua, infrastruktur dan sertifikat kunci publik.  Sangat menarik bahwa dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wawancara 2004</a> Martin Hellman menyebutkan "pahlawan tanpa tanda jasa" Loren Kohnfelder, yang tesis sarjana MIT-nya memperkenalkan struktur pohon dari apa yang sekarang kita kenal sebagai infrastruktur kunci publik.  Namun demikian, mari kembali ke sertifikat. <br><br>  Fakta bahwa server benar-benar memiliki kunci pribadi dijamin oleh tanda tangannya, yang dapat diverifikasi dengan kunci publik server.  Dan sertifikat memastikan bahwa beberapa kunci publik milik server tertentu.  Ini berarti bahwa Anda menjalin komunikasi yang aman dengan pihak tertentu dan bukan dengan penipu.  Bank Anda, bukan penjahat cyber.  Dalam TLS 1.3 terdapat peningkatan yang signifikan dibandingkan format negosiasi sebelumnya - server menandatangani semua informasi yang dimilikinya hingga saat ini: klien menyapa dan server menyapa, termasuk cipher yang dinegosiasikan.  Mari kita lihat bagian yang sesuai dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 8446</a> : <br><br><pre><code class="plaintext hljs">Client Server Key ^ ClientHello Exch | + key_share* | + signature_algorithms* | + psk_key_exchange_modes* v + pre_shared_key* --------&gt; ServerHello ^ Key + key_share* | Exch + pre_shared_key* v {EncryptedExtensions} ^ Server {CertificateRequest*} v Params {Certificate*} ^ {CertificateVerify*} | Auth {Finished} v &lt;-------- [Application Data*] ^ {Certificate*} Auth | {CertificateVerify*} v {Finished} --------&gt; [Application Data] &lt;-------&gt; [Application Data]</code> </pre> <br>  Dalam TLS 1.3 klien mengirim pembagian kunci (bersama dengan parameter yang diperlukan), algoritma tanda tangan segera di pesan pertama (Klien Halo).  Kunci yang diperlukan untuk bertukar dengan server dibuat di latar belakang, tanpa pengguna bahkan menyadari fakta itu.  Mereka selanjutnya ditukar dengan server untuk membuat rahasia umum, dari kunci-kunci rahasia pra-master yang dibuat ketika server mengirim pesannya (Server Hello) menjawab klien. <br>  Di sisi "Server Halo" Anda dapat melihat Sertifikat * ditransfer ke klien, bersama dengan bagian Verifikasi Sertifikat * yang memverifikasi bahwa pihak tersebut memiliki kunci pribadi untuk entri kunci publik yang sesuai, dan membuat kunci sesi (simetris) jika semuanya berjalan sesuai rencana - artinya, pihak yang meminta data (klien) berhasil memverifikasi pihak penjawab (server), yang selanjutnya menciptakan rahasia umum. <br><br>  Ada dua operasi penting yang disembunyikan dalam transmisi ini - pembuatan tanda tangan dan verifikasi tanda tangan.  Itu dibuat di kedua sisi komunikasi karena "tanda tangan" pada dasarnya adalah bukti bahwa pihak tersebut sebenarnya memiliki kunci pribadi yang sesuai dengan kunci publik, bahwa data berasal dari penandatangan dan pesan tidak diubah dalam perjalanan. <br><br>  Dengan RSA, seperti yang akan kita lihat lebih lanjut, operasi penandatanganan adalah yang paling mahal.  Karena kami menandatangani dengan kunci panjang 2048 atau 3072-bit, operasi seperti itu memuat server secara signifikan, lebih banyak daripada memuat klien yang memverifikasi tanda tangan tersebut. <br><br>  Dengan ECDSA, kami memiliki kunci yang lebih kecil (kami akan melihat ECDSA dengan NIST P-256 (atau secp256v1)) tetapi operasi yang lebih kompleks.  Akibatnya, itu dapat dilihat sebagai RSA "terbalik" - klien dimuat paling banyak, dengan perhitungan verifikasi tanda tangan, sementara server dengan mudah menangani pembuatan tanda tangan.  Pengukuran memverifikasi bahwa, lihat bagian "Sedikit patokan". <br><br>  Efek ini dengan mudah skala Internet saat ini - karena klien modern hampir sama kuatnya dengan server (mengingat hanya frekuensi inti CPU), sehingga mereka dapat secara efektif mengambil operasi mahal untuk telanjang.  Server, pada gilirannya, dapat menggunakan kemampuan yang dibebaskan untuk membuat lebih banyak tanda tangan dan membuat lebih banyak sesi. <br><br><h3>  Mari Enkripsi tanda tangan sertifikat </h3><br>  Jadi, untuk memberikan pembaca sedikit petunjuk praktis dan praktis tentang cara membuat server yang mendukung TLS dengan pasangan kunci ECDSA yang ditandatangani oleh otoritas Let's Encrypt, kami memutuskan untuk mengilustrasikan proses penuh untuk menciptakan pasangan kunci yang diperlukan. untuk membuat CSR (permintaan penandatanganan sertifikat) untuk Let's Encrypt dan, sebagai hasilnya, dapatkan sertifikat ECDSA yang diperlukan untuk server kami. <br><br>  Kami harus membuat kunci pribadi untuk melanjutkan.  Kami akan menggunakan pustaka OpenSSL. <br>  Manual OpenSSL menjelaskan pembuatan kunci EC apa pun melalui perintah khusus, yang dirancang khusus untuk cabang kurva eliptik dari algoritma pembuatan. <br><br><pre> <code class="plaintext hljs">openssl ecparam -genkey -name -secp256v1 -out privatekey.pem</code> </pre> <br>  Untuk memeriksa apakah pustaka OpenSSL melakukan semuanya dengan benar, kita dapat menjalankan perintah <code>ec</code> . <br><br><pre> <code class="plaintext hljs">openssl ec -in privatekey.pem -noout -text</code> </pre> <br>  Output akan menunjukkan kepada kita kurva yang ditentukan dengan kunci yang telah dibuat. <br><br>  Langkah selanjutnya sangat penting untuk penciptaan CSR - untuk melewati proses mengisi semua rincian informasi yang diperlukan untuk mendapatkan sertifikat kita memerlukan file konfigurasi.  Untungnya, Mozilla melakukan seluruh pekerjaan untuk kami, memperkenalkan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generator Konfigurasi SSL</a> ".  Di sana, Anda dapat memilih dari opsi server yang tersedia.  Konfigurasi OpenSSL murni, secara khusus tidak ada pada halaman Generator akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">[ req ] prompt = no encrypt_key = no default_md = sha256 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:*.example.com</code> </pre> <br>  <i>Catatan: Anda tidak perlu memiliki CNF - jika tidak, Anda akan diminta untuk mengisi perincian ini di baris perintah.</i> <br><br>  Sekarang, ikuti pembuatan CSR itu sendiri.  Di sini kita memiliki perintah OpenSSL yang berguna. <br><br><pre> <code class="plaintext hljs">openssl req -new -config -pathtoconfigfile.cnf -key privatekey.pem -out csr.pem</code> </pre> <br>  Kami juga dapat memverifikasi kebenaran CSR yang baru dibuat. <br><br><pre> <code class="plaintext hljs">openssl req -in csr.pem -noout -text -verify</code> </pre> <br>  Di sini kita telah sampai pada tahap akhir - menggunakan klien ACME, certbot, untuk meneruskan permintaan penandatanganan sertifikat kami ke Let's Encrypt. <br><br>  Certbot membantu Anda mendapatkan sertifikat yang diperlukan dan memiliki banyak opsi.  Di sini dikatakan, jika Anda baru mengenal enkripsi kunci publik, dan infrastruktur PKI yang kami miliki pada tahun 2019, Anda sebaiknya menggunakan <code>--dry-run</code> sebelum Anda mencoba mendapatkan sertifikat untuk domain apa pun dari domain Anda. <br><br><pre> <code class="plaintext hljs">certbot certonly --dry-run --dns-somednsprovider --domain “example.com” --domain “*.example.com” --csr csr.pem</code> </pre> <br>  Dalam kasus ini, klien certbot memeriksa apakah daftar domain yang diminta (pada baris perintah) cocok dengan domain yang tercantum dalam permintaan penandatanganan sertifikat.  Dalam perintah <code>--dns-somednsprovider</code> terletak sedikit kebohongan, karena ada banyak cara yang bisa Anda buktikan. Mari Enkripsi Anda memiliki bagian tertentu dari lalu lintas Internet.  Namun, jika Anda menggunakan penyedia hosting awan publik, katakan DigitalOcean, Hetzner, Amazon, Azure, apa pun - mungkin akan ada cara yang lebih alami untuk memberikan informasi yang diperlukan, karena penyedia Anda sudah membuat beberapa alat integrasi. <br><br>  Setelah, jika Anda yakin tentang kebenaran dari parameter yang Anda gunakan dalam meneruskan CSR Anda ke Let's Encrypt melalui klien certbot - kecualikan <code>--dry-run</code> dari perintah Anda dan lanjutkan. <br><br>  Jika berhasil, klien akan menghasilkan beberapa sertifikat sebagai output: sertifikat yang ditandatangani itu sendiri, sertifikat root dan perantara, dan kombinasi yang terakhir sebagai rantai sertifikat yang terakhir disebut, semua dalam format file .pem. <br><br>  OpenSSL memiliki perintah yang dapat kita gunakan untuk memeriksa sertifikat: <br><br><pre> <code class="plaintext hljs">openssl x509 -in chainfilepath.pem -noout -text</code> </pre> <br>  Pada titik ini, menjadi jelas bahwa Let's Encrypt menandatangani sertifikat menggunakan SHA256 digest.  Selain itu, penandatanganan Root dan Intermediate ECDSA berada di bawah bagian "Fitur Mendatang", yang secara efektif berarti bahwa saat ini Anda hanya akan mendapatkan perantara RSA.  Tapi tidak apa-apa karena Anda masih menggunakan kunci publik ECDSA. <br><br>  Di akhir bagian ini, kami ingin mengatakan sesuatu sehubungan dengan panjang kunci.  Dalam keamanan informasi, adalah umum untuk mengatakan tingkat keamanan adalah 2 ^ x, di mana x adalah panjang bit (RSA adalah sedikit pengecualian di sini, karena ia tumbuh agak lebih lambat daripada secara eksponensial).  Untuk memperkirakan bagaimana kunci yang digunakan untuk algoritma yang berbeda saling bersesuaian, kami akan merujuk ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman wiki</a> OpenSSL. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Panjang kunci simetris</b> <br></td><td>  <b>Panjang Kunci RSA</b> <br></td><td>  <b>Panjang Kurva Elliptic</b> <br></td></tr><tr><td>  80 <br></td><td>  1024 <br></td><td>  160 <br></td></tr><tr><td>  112 <br></td><td>  2048 <br></td><td>  224 <br></td></tr><tr><td>  128 <br></td><td>  3072 <br></td><td>  256 <br></td></tr><tr><td>  192 <br></td><td>  7680 <br></td><td>  384 <br></td></tr><tr><td>  256 <br></td><td>  15360 <br></td><td>  512 <br></td></tr></tbody></table></div>  Seperti yang Anda lihat, perbedaannya cukup menonjol.  Meskipun dengan Let's Encrypt kami tidak bisa mendapatkan sertifikat yang ditandatangani di luar 256 (secp256v1) dan 384 (secp384r1) kunci kurva eliptik. <br><br><h3>  Masalah dan pengecualian yang diketahui, dan THE NSA </h3><br><img src="https://imgs.xkcd.com/comics/random_number.png" alt="gambar"><br>  Kredit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xkcd</a> <br><br>  Mungkin, masalah utama menggunakan kriptografi kurva eliptik selama bertahun-tahun adalah perlunya generator angka acak yang dibuat dengan sangat hati-hati, untuk membuat kunci tingkat keamanan yang diperlukan. <br><br>  Ada skandal besar di sekitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Dual_EC_DRBG</a> (dual elliptic curve deterministic random bit), yang membutuhkan waktu bertahun-tahun untuk menyelesaikannya.  Juga, ada ketidakpastian di sekitar paten ECC, seperti diketahui bahwa banyak dari mereka milik perusahaan Certicom, yang diakuisisi oleh Blackberry.  Ada juga perusahaan yang diketahui bersertifikat penggunaan ECC dari Blackberry.  Tentu saja, ada ketidakpercayaan sederhana pada beberapa standar NIST, yang dapat atau tidak dapat dipengaruhi oleh NSA atau institusi penegakan dan pengawasan Amerika Serikat lainnya. <br><br>  Sisi implementasi dari suatu masalah adalah pertanyaan yang sama sekali berbeda.  Pada tahun 2010 konsol PlayStation 3 mengalami pemulihan kunci privat Sony karena implementasi yang tidak tepat dari algoritma ECDSA - mereka memiliki acak statis yang membuat fungsi pintu jebakan dipecahkan.  OpenSSL juga menderita pada tahun berikutnya, namun, dengan cepat memperbaiki kerentanan yang memungkinkan pengambilan kunci privat dengan bantuan serangan waktu, untuk informasi lebih lanjut lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kertas asli</a> . <br><br>  Pada 2013 di konferensi RSA, sekelompok peneliti mempresentasikan “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gagal Secara Acak!</a>  ”Makalah tentang kerentanan kelas Java SecureRandom.  Setengah tahun kemudian datang ke dompet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitcoin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Android</a> , dibuat dengan menggunakan PRNG yang tidak cukup aman secara kriptografis. <br><br>  Karena kerentanan serial yang serius ditemukan, pada bulan Agustus 2013 yang sama, IETF merilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 6979</a> , menggambarkan generasi deterministik k yang digunakan dalam pembuatan kunci.  Kita dapat mengatakan bahwa tindakan semacam itu memperbaiki masalah, tetapi kita tidak akan melakukannya - kapan saja para peneliti dapat menemukan masalah dalam berbagai implementasi karena penyimpangan yang tidak perlu dari spesifikasi protokol. <br><br>  Tentang NSA.  Jika Anda belum pernah mendengar tentang cerita Dual_EC_DRBG - meluangkan waktu dan membaca artikel yang sesuai, Anda tidak akan menyesal masuk ke detail.  Edward Snowden adalah bagian dari kisah ini karena wahyu 2013 membuktikan kecurigaan sebelumnya.  Itu mengakibatkan banyak cryptographers terkemuka kehilangan kepercayaan kepada NIST karena organisasi itu merancang dan mendeskripsikan banyak kurva dan algoritma lebih lanjut, yang mendasari ECDSA. <br><br>  Fungsi 25519 kurva dan fungsi Daniel Bernstein adalah jawaban untuk kedua masalah ini dan, seperti yang kami jelaskan sebelumnya, transisi menuju EdDSA lambat meskipun terbukti.  Bahkan dengan kurva NIST, tidak ada bukti kerentanan mereka telah ditemukan dan, seperti yang telah kami sebutkan, pengalaman yang terkait secara acak telah cukup instruktif. <br><br>  Untuk mengakhiri bagian ini, kami ingin memberikan kutipan John von Neumann: "Siapa pun yang berusaha menghasilkan angka acak dengan cara deterministik, tentu saja, hidup dalam keadaan berdosa." <br><br><h3>  Sedikit patokan </h3><br>  Kami menggunakan server NGINX 1.16.0 dengan OpenSSL 1.1.1d untuk menjalankan benchmark ini dengan berbagai sertifikat.  Seperti yang kami sebutkan sebelumnya, saat ini Mari Enkripsi hanya memungkinkan algoritma prime256v1 dan secp384r1 untuk permintaan penandatanganan sertifikat, dan tidak menyediakan sertifikat ECDSA root dan perantara, mungkin bekerja pada fitur ini pada saat kami menulis artikel ini. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis tanda tangan</b> </td><td>  <b>Jabat tangan per detik</b> </td></tr><tr><td>  <b>ECDSA (prime256v1 / nistp256)</b> </td><td>  3358.6 </td></tr><tr><td>  <b>RSA 2048</b> </td><td>  972.5 </td></tr></tbody></table></div>  Seperti yang Anda lihat, untuk satu inti CPU Intel® Xeon® Silver 4114 @ 2.20GHz (diluncurkan Q3'17), perbedaan keseluruhan dalam kinerja ECDSA, dibandingkan dengan RSA 2048 yang diadopsi secara luas adalah 3,5x. <br><br>  Sekarang mari kita lihat hasil kecepatan-OpenSSL prosesor yang sama dengan ECDSA dan RSA. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Jenis tanda tangan</b> <br></td><td>  <b>tanda</b> <br></td><td>  <b>verifikasi</b> <br></td><td>  <b>tanda / dtk</b> <br></td><td>  <b>verifikasi / dtk</b> <br></td></tr><tr><td>  <b>RSA 2048 bit</b> <br></td><td>  717 μs <br></td><td>  20,2 μs <br></td><td>  1393.9 <br></td><td>  49458.2 <br></td></tr><tr><td>  <b>256 bit ECDSA (nistp256)</b> <br></td><td>  25,7 μs <br></td><td>  81,8 μs <br></td><td>  38971.6 <br></td><td>  12227.1 <br></td></tr></tbody></table></div>  Di sini kita dapat melihat konfirmasi untuk tesis yang diberikan sebelumnya tentang biaya komputasi yang berbeda untuk menandatangani dan memverifikasi operasi ECC dan RSA.  Akibatnya, saat ini dilengkapi dengan TLS 1.3 ECC memberikan peningkatan kinerja yang signifikan pada tingkat keamanan bit yang lebih tinggi, dibandingkan dengan RSA.  Itulah alasan paling mendasar mengapa kami di Qrator Labs mendorong klien kami untuk mengadopsi ECDSA.  Dengan CPU modern, Anda mendapatkan hampir perbedaan 5x dalam mendukung ECDSA. <br><br>  Jika Anda tertarik pada bagaimana CPU Anda melakukan perhitungan kriptografi, Anda dapat menjalankan perintah <code>openssl speed</code> sederhana.  <code>-rsa</code> , <code>-ecdsa</code> dan <code>-eddsa</code> akan memberi Anda hasil benchmark untuk algoritme tanda tangan yang sesuai. <br><br><h3>  (Superposisi) Masa Depan </h3><br><img src="https://pbs.twimg.com/media/CB4sHACVEAAYMyZ?format=jpg&amp;name=large" alt="gambar"><br>  Kredit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">djb</a> <br><br>  Sangat ironis bahwa ketika kami sedang mempersiapkan artikel ini, Google mengumumkan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mencapai supremasi kuantum</a> ".  Apakah ini berarti bahwa kita dalam bahaya sekarang dan segala sesuatu yang berkembang hingga saat ini tidak memberikan kerahasiaan? <br><br>  Ya tidak. <br><br>  Seperti yang ditulis Bruce Schneier dalam esainya untuk Keamanan dan Privasi IEEE “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kriptografi setelah Tanah Alien</a> ”, sebuah pukulan besar dengan komputer kuantum yang cukup kuat dapat dilakukan terhadap kriptografi kunci publik (asimetris).  Kriptografi simetris masih akan kuat. <br><br>  Kami ingin mengutip Bruce Schneier sebagai berikut: <br><blockquote>  Ada satu lagi skenario masa depan yang perlu dipertimbangkan, satu yang tidak memerlukan komputer kuantum.  Sementara ada beberapa teori matematika yang mendukung satu arah yang kita gunakan dalam kriptografi, membuktikan validitas teori-teori itu sebenarnya adalah salah satu masalah besar yang terbuka dalam ilmu komputer.  Seperti halnya kriptografer pintar untuk menemukan trik baru yang membuatnya lebih mudah untuk memecahkan algoritma tertentu, kita dapat membayangkan alien dengan teori matematika yang cukup untuk memecahkan semua algoritma enkripsi.  Bagi kami, hari ini, ini konyol.  Kriptografi kunci publik adalah semua teori bilangan, dan berpotensi rentan terhadap alien yang cenderung matematis.  Kriptografi simetris adalah begitu banyak kekusutan nonlinear, begitu mudah untuk membuat lebih kompleks, dan begitu mudah untuk menambah panjang kunci, bahwa masa depan ini tidak terbayangkan.  Pertimbangkan varian AES dengan ukuran blok dan kunci 512-bit, dan 128 putaran.  Kecuali matematika secara fundamental berbeda dari pemahaman kita saat ini, itu akan aman sampai komputer terbuat dari sesuatu selain materi dan menempati sesuatu selain ruang. <br><br>  Tetapi jika hal yang tak terbayangkan terjadi, itu akan meninggalkan kita dengan kriptografi hanya berdasarkan teori informasi: pembalut satu kali dan variannya. </blockquote><br>  Ini adalah area di mana, kecuali mencari kekurangan implementasi, sebagian besar masalah dapat ditemukan.  Jika ada sekelompok ahli matematika, cryptanalysts / cryptographers, dan insinyur komputer yang didanai dengan baik dan bekerja untuk membuktikan atau menyangkal beberapa masalah matematika kompleks yang luar biasa (seperti P? = NP) dan mencapai hasil yang substansial hingga saat ini, kita bisa berada dalam masalah.  Namun, kemajuan dalam ilmu komputer, informasi dan teori komputabilitas seperti itu tidak mungkin disembunyikan, karena fakta itu akan menulis nama-nama pencipta mereka di halaman History dan, khususnya, History of the Internet textbooks, yang tak ternilai bagi siapa pun yang cerdas .  Jadi, skenario seperti itu bisa dianggap hampir mustahil. <br><br>  Tidak jelas, apakah dalam 5 tahun terdekat akan ada keberhasilan dengan komputasi kuantum, meskipun sudah ada beberapa primitif kriptografi yang dianggap cocok untuk dunia pasca-kuantum: kisi-kisi, kurva elips supersingular berbasis isogeny, hash, dan kode.  Untuk saat ini, spesialis keamanan hanya bereksperimen dengan mereka.  Namun, tidak ada keraguan bahwa dalam hal kebutuhan, umat manusia akan dengan cepat menggunakan algoritme tersebut dalam skala massal. <br><br>  Untuk saat ini, kriptografi berbasis kurva eliptik tampaknya sangat cocok untuk dekade mendatang, memberikan keamanan dan kinerja. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474810/">https://habr.com/ru/post/id474810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474796/index.html">Apa itu Internet hal dan bagaimana hal itu membantu perusahaan memperoleh lebih banyak?</a></li>
<li><a href="../id474800/index.html">Kinerja dalam .NET Core</a></li>
<li><a href="../id474804/index.html">Kemajuan teknologi Rusia dalam olahraga: antarmuka saraf, kamera IP, CRM olahraga dan BigData dari mobil balap</a></li>
<li><a href="../id474806/index.html">UDP Banjir dari Google atau bagaimana tidak menghilangkan semua Youtube</a></li>
<li><a href="../id474808/index.html">Rilis Rust 1.39.0: async / await, atribut untuk parameter fungsi, fungsi konstan baru</a></li>
<li><a href="../id474812/index.html">Shader bukanlah sihir. Menulis shader di Unity. Vertex Shaders</a></li>
<li><a href="../id474814/index.html">Antiquities: messenger dari pembusukan atau keusangan yang tidak direncanakan</a></li>
<li><a href="../id474816/index.html">Proyek kesayangan - kehidupan kecil</a></li>
<li><a href="../id474818/index.html">Apakah ada angka acak di CSS?</a></li>
<li><a href="../id474822/index.html">WISE-PaaS - platform cloud untuk berbagai hal industri Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>