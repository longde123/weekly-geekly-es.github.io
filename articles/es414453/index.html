<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§í üìá üë©‚Äçüë©‚Äçüë¶ Implemente Path Finder para agentes de IA con NavMesh üîï ‚ô¶Ô∏è ü§ûüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siguiendo el camino y controlando el tr√°fico 
 A veces necesitamos personajes de IA para recorrer el mundo del juego, siguiendo un camino m√°s o menos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implemente Path Finder para agentes de IA con NavMesh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414453/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png" alt="imagen"></div><br><h2>  Siguiendo el camino y controlando el tr√°fico </h2><br>  A veces necesitamos personajes de IA para recorrer el mundo del juego, siguiendo un camino m√°s o menos definido o definido con precisi√≥n.  Por ejemplo, en un juego de carreras, los oponentes de IA deben viajar a lo largo del camino, y en RTS, las unidades deben poder moverse al punto deseado, moverse a lo largo del terreno y teniendo en cuenta la posici√≥n de los dem√°s. <br><br>  Para parecer inteligentes, los agentes de IA deben poder determinar lo que est√°n haciendo, y si no pueden llegar al punto deseado, deben ser capaces de trazar la ruta m√°s efectiva y cambiar su camino cuando aparecen obst√°culos en el camino. <br><br>  Evitar obst√°culos es un comportamiento simple que permite a las entidades de IA alcanzar los puntos objetivo.  Es importante tener en cuenta que el comportamiento implementado en esta publicaci√≥n es para comportamientos como la simulaci√≥n de multitudes, en el que el objetivo principal de cada agente es evitar a otros agentes y lograr el objetivo.  No determinan el camino m√°s eficiente y m√°s corto. <br><br><h2>  Requisitos t√©cnicos </h2><br>  Requiere Unity 2017 instalado en un sistema con Windows 7 SP1 +, 8, 10 o Mac OS X 10.9+.  El c√≥digo de este art√≠culo no funcionar√° en Windows XP y Vista, y las versiones de servidor de Windows y OS X no se han probado. <br><br>  Los archivos de c√≥digo para esta publicaci√≥n se pueden encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Para aprender el c√≥digo en acci√≥n, mira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">este video</a> . <br><a name="habracut"></a><br><h2>  Malla de navegaci√≥n </h2><br>  Veamos c√≥mo usar el generador de malla de navegaci√≥n incorporado de Unity, que puede simplificar enormemente la b√∫squeda de rutas para agentes de IA.  En las primeras etapas de Unity 5.x, la funci√≥n NavMesh estuvo disponible para todos los usuarios, incluidos aquellos con licencias de edici√≥n personal, aunque anteriormente era una funci√≥n solo para Unity Pro.  Antes del lanzamiento de 2017.1, el sistema se actualiz√≥ para proporcionar un flujo de trabajo basado en componentes, pero dado que requiere un paquete descargable adicional, que en el momento de la escritura solo est√° disponible en la versi√≥n de vista previa, nos adheriremos al flujo de trabajo est√°ndar basado en escenas.  No se preocupe, los conceptos de ambos enfoques son similares, y cuando la implementaci√≥n final finalmente llegue a 2017.x, no deber√≠a haber cambios significativos. <br><br>  Obtenga m√°s informaci√≥n sobre el sistema de componentes NavMesh en Unity en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Ahora exploraremos todas las posibilidades que este sistema puede ofrecernos.  Para buscar rutas de IA, la escena debe presentarse en un formato espec√≠fico;  en un mapa 2D, se usa una cuadr√≠cula (matriz) bidimensional para buscar rutas utilizando el algoritmo A *.  Los agentes de IA necesitan saber d√≥nde est√°n los obst√°culos, especialmente los est√°ticos.  Lidiar con las colisiones entre objetos din√°micamente en movimiento es otro problema com√∫nmente conocido como comportamiento de direcci√≥n.  Unity tiene una herramienta incorporada para generar NavMesh, que representa la escena en un contexto conveniente para que los agentes de IA encuentren la ruta √≥ptima hacia el objetivo.  Para comenzar, abra un proyecto de demostraci√≥n y vaya a la escena NavMesh. <br><br><h3>  Tarjeta de estudio </h3><br>  Despu√©s de abrir la escena de demostraci√≥n NavMesh, deber√≠a verse como en la captura de pantalla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a3/35c/15a/7a335c15ad8084dee2aab59de7cdcd3f.png"></div><br>  <em>Obst√°culo y escena de pendiente</em> <br><br>  Esta ser√° nuestra caja de arena para explicar y probar la funcionalidad del sistema NavMesh.  El esquema general es similar a un juego en el g√©nero de RTS (estrategia en tiempo real).  Conducimos un tanque azul.  Haga clic en diferentes puntos para que el tanque se mueva hacia ellos.  El indicador amarillo es el objetivo actual del tanque. <br><br><h3>  Navegaci√≥n est√°tica </h3><br>  Primero, debe decir que debe marcar toda la geometr√≠a de la escena, horneada en NavMesh, como <b>est√°tica de navegaci√≥n</b> .  Es posible que haya visto esto antes, por ejemplo, en el sistema de mapa de iluminaci√≥n Unity.  Hacer que los objetos del juego est√©n est√°ticos es muy simple, simplemente marque la casilla <b>Est√°tico</b> para ver todas sus propiedades (navegaci√≥n, iluminaci√≥n, selecci√≥n, procesamiento por lotes, etc.), o use la lista desplegable para especificar propiedades.  La casilla de verificaci√≥n se encuentra en la esquina superior derecha del inspector de los objetos seleccionados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/cfd/224/f7ccfd224088652d0831282397b5eb5c.png"></div><br>  <em>Navegaci√≥n de propiedad est√°tica</em> <br><br>  Esto se puede hacer individualmente para diferentes objetos o, si tiene una jerarqu√≠a incorporada de objetos de juego, aplique el par√°metro al objeto principal, despu√©s de lo cual Unity ofrecer√° aplicarlo a todos los objetos secundarios. <br><br><h3>  Asar una malla de navegaci√≥n </h3><br>  Para toda la escena, las opciones de navegaci√≥n navmesh se aplican mediante la ventana de <b>navegaci√≥n</b> .  Esta ventana se puede abrir yendo a <b>Ventana</b> |  <b>La navegaci√≥n</b>  Al igual que cualquier otra ventana, puede desconectarse para moverse libremente o repararse.  En nuestras capturas de pantalla, se muestra como una pesta√±a acoplada junto a la jerarqu√≠a, pero puede colocar esta ventana en cualquier lugar conveniente. <br><br>  Al abrir la ventana, ver√° pesta√±as individuales.  Se ver√° m√°s o menos as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/872/7a6/b30/8727a6b301be8f979821ab0446ce5e7d.png"></div><br>  <em>Ventana de navegaci√≥n</em> <br><br>  En nuestro caso, la captura de pantalla anterior muestra la pesta√±a <b>Hornear</b> , pero en su editor, cualquier pesta√±a se puede seleccionar de forma predeterminada. <br><br>  Veamos cada una de las pesta√±as, comenzando desde la izquierda y movi√©ndose hacia la derecha.  Comencemos con la pesta√±a <b>Agentes</b> , que parece que la captura de pantalla muestra: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e2/3e9/db3/9e23e9db3a55b407af7a7bde83c56c4b.png"></div><br>  <em>Pesta√±a Agentes</em> <br><br>  Si est√° trabajando en otro proyecto, es posible que algunas de las configuraciones sean diferentes de las que configuramos para el proyecto de ejemplo que se muestra en la captura de pantalla.  En la parte superior de la pesta√±a hay una lista donde puede agregar nuevos tipos de agentes haciendo clic en el bot√≥n <b>+</b> .  Puede eliminar agentes adicionales seleccion√°ndolos y haciendo clic en el bot√≥n <b>-</b> .  La ventana muestra claramente lo que hacen varias configuraciones al cambiarlas.  Veamos qu√© hace cada una de las configuraciones: <br><br><ul><li>  Nombre: nombre del tipo de agente que se muestra en la lista desplegable Tipos de agente. </li><li>  Radio: Puedes considerarlo como el "espacio personal" de un agente.  Los agentes tratar√°n de evitar el contacto demasiado cercano con otros agentes en funci√≥n de este valor, ya que se usa para evitarlo. </li><li>  Altura: como puede suponer, esta configuraci√≥n establece la altura del agente que utiliza para evitar verticalmente (por ejemplo, al pasar por debajo de los objetos). </li><li>  Altura del paso: este valor determina qu√© altura puede subir el agente. </li><li>  Pendiente m√°xima: como veremos en la siguiente secci√≥n, este valor determina el √°ngulo m√°ximo en el que el agente puede subir.  Con este par√°metro, puede hacer que las pendientes pronunciadas del mapa sean inaccesibles para el agente. </li></ul><br>  A continuaci√≥n, tenemos la pesta√±a <b>√Åreas</b> , que se parece a la que se muestra en esta captura de pantalla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/e36/4f6/68be364f6605a8b3f567dfeb31bf56db.png"></div><br>  Como puede ver en la captura de pantalla, Unity proporciona varios tipos de √°reas que no se pueden cambiar: <b>Caminable</b> , <b>No caminable</b> y <b>Saltar</b> .  Adem√°s de nombrar y crear nuevas √°reas, puede asignar a estas √°reas el costo de moverse por ellas. <br><br>  Las √°reas tienen dos prop√≥sitos: hacer que las √°reas sean accesibles o inaccesibles para el agente, y marcar las √°reas como menos deseables en t√©rminos de costos de viaje.  Por ejemplo, puedes desarrollar un juego de rol en el que los demonios enemigos no puedan entrar en √°reas marcadas como "terreno consagrado".  Tambi√©n puede marcar algunas √°reas del mapa como un "atolladero" o "pantano", que el agente evitar√° debido al alto costo de la mudanza. <br><br>  La tercera pesta√±a <b>Bake</b> es probablemente la m√°s importante.  Le permite crear NavMesh para la escena.  Ya deber√≠a estar familiarizado con algunas de las opciones.  La pesta√±a <b>Hornear se</b> ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16a/fc2/a66/16afc2a6659910152c0f4d673c9bcacb.png"></div><br>  <em>Pesta√±a hornear</em> <br><br>  Las opciones de tama√±o de agente en esta pesta√±a determinan c√≥mo los agentes interactuar√°n con el entorno, mientras que las opciones en la pesta√±a <b>Agentes</b> controlan las interacciones con otros agentes y objetos en movimiento.  Pero controlan los mismos par√°metros, por lo que los omitiremos.  <b>La altura de ca√≠da</b> y la <b>distancia de salto</b> controlan qu√© tan lejos puede "saltar" el agente para llegar a la parte de NavMesh que no est√° directamente relacionada con aquella en la que el agente se encuentra actualmente.  Consideraremos esto con m√°s detalle a continuaci√≥n, por lo que si no est√° seguro, a√∫n no puede estudiar estos par√°metros. <br><br>  Adem√°s, hay opciones avanzadas que generalmente est√°n ocultas de forma predeterminada.  Para expandir estas opciones, simplemente haga clic en el tri√°ngulo desplegable junto al encabezado <b>Avanzado</b> .  <b>El tama√±o manual de Voxel</b> puede considerarse como una configuraci√≥n de "calidad".  Cuanto m√°s peque√±o sea el tama√±o, m√°s detalles se almacenar√°n en la malla.  <b>El √°rea de regi√≥n m√≠nima se</b> usa para omitir plataformas o superficies para hornear por debajo del umbral seleccionado.  <b>La malla de altura</b> nos proporciona datos verticales m√°s detallados al hornear una malla.  Por ejemplo, esta opci√≥n le permite mantener la ubicaci√≥n correcta del agente al subir escaleras. <br><br>  El bot√≥n <b>Borrar</b> elimina todos los datos NavMesh de la escena, y el bot√≥n <b>Hornear</b> crea una malla para la escena.  El proceso de horneado es bastante r√°pido.  Mientras tenga una ventana seleccionada, puede observar la generaci√≥n de NavMesh con el bot√≥n <b>Bake</b> en la ventana de escena.  Hagamos clic en el bot√≥n <b>Hornear</b> para ver los resultados.  En nuestra escena de ejemplo, terminamos con algo similar a esta captura de pantalla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png"></div><br>  Las √°reas azules muestran NavMesh.  A continuaci√≥n volveremos a esto.  Mientras tanto, pasemos a la √∫ltima pesta√±a: <b>Objeto</b> , que se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/6c7/4e8/b446c74e8154bca80133ff95ce378d31.png"></div><br>  Los tres botones que se muestran en la captura de pantalla anterior ( <b>Todos</b> , <b>Renderizadores de</b> <b>malla</b> y <b>Terrenos</b> ) se utilizan como filtros de escena.  Son √∫tiles cuando se trabaja en escenas complejas con muchos objetos en la jerarqu√≠a.  Al seleccionar una opci√≥n, se filtra el tipo correspondiente de la jerarqu√≠a, lo que facilita su selecci√≥n.  Puede usar los botones para explorar su escena en busca de objetos que desee marcar como navegaci√≥n est√°tica. <br><br><h3>  Usando Nav Mesh Agent </h3><br>  Ahora que hemos configurado la escena con NavMesh, necesitamos una forma para que el agente use esta informaci√≥n.  Afortunadamente para nosotros, Unity tiene un componente <b>Nav Mesh Agent</b> que puedes arrastrar a un personaje.  En nuestra escena de ejemplo, hay un objeto de juego llamado <b>Tank</b> , al que ya se ha adjuntado un componente.  Mire la jerarqu√≠a y ver√° algo como esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/3ba/68f/a313ba68f88b2417e0225c6f724cbce8.png"></div><br>  Hay bastantes par√°metros aqu√≠, y no consideraremos todo, porque son bastante claros, y la descripci√≥n se puede encontrar en la documentaci√≥n oficial de Unity.  Pero mencionaremos las cosas principales: <br><br><ul><li>  <strong>Tipo de agente</strong> : ¬øRecuerda la pesta√±a <strong>Agentes</strong> en la ventana de <strong>navegaci√≥n</strong> ?  Los tipos de agentes asignables se pueden seleccionar aqu√≠. </li><li>  <strong>Auto Traverse Off Mesh Link</strong> : esta opci√≥n permite a los agentes usar autom√°ticamente la funci√≥n <strong>Off Mesh Links</strong> , que discutiremos a continuaci√≥n. </li><li>  <strong>M√°scara de √°rea</strong> : aqu√≠ puede seleccionar las √°reas configuradas en la pesta√±a <strong>√Åreas</strong> de la ventana de <strong>navegaci√≥n</strong> . </li></ul><br>  Eso es todo  Este componente hace el 90% del trabajo duro para nosotros: allanando el camino, evitando obst√°culos, etc.  Lo √∫nico que necesita es transferir el punto objetivo al agente.  Miremos este problema. <br><br><h3>  Ajuste del punto objetivo </h3><br>  Despu√©s de configurar el agente de IA, necesitamos una forma de decirle a d√≥nde ir.  En nuestro proyecto de ejemplo, hay un script llamado <b>Target.cs</b> que realiza exactamente esta tarea. <br><br>  Esta es una clase simple que hace tres cosas: <br><br><ul><li>  "Dispara" el haz de la c√°mara a la posici√≥n del mouse en el mundo </li><li>  Actualiza la posici√≥n del marcador </li><li>  Actualiza la propiedad de destino para todos los agentes NavMesh. </li></ul><br>  El c√≥digo es bastante simple.  Toda la clase es la siguiente: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Target</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent[] navAgents; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform targetMarker; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { navAgents = FindObjectsOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(NavMeshAgent)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NavMeshAgent[]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTargets</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 targetPosition </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(NavMeshAgent agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navAgents) { agent.destination = targetPosition; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetInput()) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray.origin, ray.direction, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hitInfo)) { Vector3 targetPosition = hitInfo.point; UpdateTargets(targetPosition); targetMarker.position = targetPosition; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * <span class="hljs-number"><span class="hljs-number">5</span></span>, Color.red); } }</code> </pre> <br>  Aqu√≠ se producen las siguientes acciones: en el m√©todo <b>Start</b> , inicializamos la matriz <b>navAgents</b> utilizando el m√©todo <b>FindObjectsOfType ()</b> . <br><br>  El m√©todo <b>UpdateTargets ()</b> pasa a trav√©s de nuestra matriz <b>navAgents</b> y establece el punto de destino para ellos en el <b>Vector3</b> dado.  Esta es la clave del c√≥digo.  Puede usar cualquier mecanismo para obtener el punto objetivo y para que el agente se mueva all√≠, simplemente configure el campo <b>NavMeshAgent.destination</b> ;  El agente har√° el resto. <br><br>  En nuestro ejemplo, los clics se usan para moverse, por lo que cuando un jugador hace clic en el mouse, liberamos el rayo de la c√°mara al mundo en la direcci√≥n del cursor del mouse, y si se cruza con algo, le asignamos un punto de colisi√≥n al nuevo agente <b>targetPosition</b> .  Tambi√©n ajustamos el marcador de objetivo en consecuencia para visualizar f√°cilmente el destino en el juego. <br><br>  Para probar la operaci√≥n, debe hornear NavMesh de acuerdo con la descripci√≥n de la secci√≥n anterior, luego iniciar el modo Reproducir y seleccionar cualquier √°rea en el mapa.  Si hace clic muchas veces, puede ver que el agente no puede alcanzar algunas √°reas: la parte superior de los cubos rojos, la plataforma superior y la plataforma en la parte inferior de la pantalla. <br><br>  Los cubos rojos son demasiado altos.  La pendiente que conduce a la plataforma m√°s alta es demasiado pronunciada para nuestra configuraci√≥n de <b>Max Slope</b> , y el agente no puede subirla.  Las siguientes capturas de pantalla muestran c√≥mo la configuraci√≥n de <b>Pendiente m√°xima</b> afecta a NavMesh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/539/7b8/fd75397b851d088fc1fd8d4d53210cc9.png"></div><br>  <i>NavMesh con pendiente m√°xima = 45</i> <br><br>  Si cambia el valor de <b>Pendiente m√°xima</b> a algo as√≠ como <b>51</b> , y luego vuelve a hacer clic en el bot√≥n <b>Hornear</b> para hornear NavMesh, los resultados ser√°n los siguientes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09a/936/b78/09a936b78c4958c9200d00867dbbc418.png"></div><br>  <em>NavMesh con pendiente m√°xima = 51</em> <br><br>  Como puede ver, podemos personalizar el dise√±o del nivel, haciendo que √°reas enteras sean inaccesibles al cambiar un solo par√°metro.  Esto puede ser √∫til, por ejemplo, cuando tiene una plataforma o repisa que requiere una cuerda, escalera o elevador para subir.  ¬øO tal vez una habilidad especial, por ejemplo, la capacidad de escalar? <br><br><h3>  Aplicaci√≥n fuera de enlaces de malla </h3><br>  Puede notar que hay dos pausas en nuestra escena.  Nuestro agente puede entrar en el primero, pero el que est√° en la parte inferior de la pantalla est√° demasiado lejos.  Estos c√°lculos no son completamente arbitrarios.  <strong>Los enlaces Off Mesh</strong> esencialmente crean un puente a trav√©s de los espacios entre segmentos NavMesh no relacionados.  Estos enlaces se pueden ver en el editor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/b0a/425/b4bb0a425446298ae08ea4684bbcef10.png"></div><br>  <i>Los c√≠rculos azules con l√≠neas de conexi√≥n son conexiones.</i> <br><br>  Unity puede generar estos enlaces de dos maneras.  El primero ya lo hemos considerado.  ¬øRecuerdas el valor de <b>Distancia de salto</b> en la pesta√±a <b>Hornear</b> de la ventana de <b>navegaci√≥n</b> ?  Unity usa autom√°ticamente ese valor para generar estos enlaces cuando hornea NavMesh.  Intente cambiar el valor en nuestra escena de prueba a 5 y hornee nuevamente.  ¬øVes - las plataformas est√°n ahora conectadas?  Esto se debe a que las mallas ahora est√°n dentro del nuevo umbral especificado. <br><br>  Cambie el valor a 2 nuevamente y hornee.  Ahora veamos la segunda forma.  Crea las esferas que se usar√°n para conectar las dos plataformas.  Col√≥quelos aproximadamente como se muestra en la captura de pantalla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/28e/020/a7a28e020255bb8855d48017da4188f1.png"></div><br>  Ya puede ver lo que est√° sucediendo, pero analicemos el proceso que les permite conectarse.  En nuestro caso, llam√© a la esfera en el <b>comienzo</b> derecho y a la esfera en el <b>extremo</b> izquierdo.  Pronto entender√°s por qu√©.  A continuaci√≥n, agregu√© el componente <b>Off Mesh Link</b> a la plataforma a la derecha (en relaci√≥n con la captura de pantalla anterior).  Notar√° que el componente tiene campos de <b>inicio</b> y <b>fin</b> .  Como puede suponer, arrastraremos las esferas creadas previamente a las ranuras correspondientes: la esfera de inicio en el campo de <b>inicio</b> y la esfera de fin en el campo de <b>fin</b> .  El inspector se ver√° as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/720/2b4/251/7202b4251068b5d0b1b8b1d7e4b09ff2.png"></div><br>  El valor de la <b>anulaci√≥n</b> de <b>costos se</b> tiene en cuenta cuando se le da un valor positivo.  Aplica un factor de costo cuando se usa esta relaci√≥n en lugar de una ruta m√°s rentable hacia el objetivo. <br><br>  <b>Bi direccional</b> si es verdadero permite que el agente se mueva en ambas direcciones.  Para crear enlaces con tr√°fico unidireccional, puede deshabilitar este valor.  El valor <b>Activado se</b> usa seg√∫n su nombre.  Si es falso, el agente ignora esta asociaci√≥n.  Puedes activarlo y desactivarlo para crear escenarios de juego en los que, por ejemplo, un jugador debe presionar un interruptor para activar una conexi√≥n. <br><br>  Para habilitar esta relaci√≥n, no es necesario volver a hornear.  Mire su NavMesh y ver√° que se ve exactamente como en la captura de pantalla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/15a/e57/be815ae574360beea94d8907e37fc309.png"></div><br>  Como puede ver, la brecha m√°s peque√±a todav√≠a se conecta autom√°ticamente, y ahora tenemos una nueva conexi√≥n generada por el componente <b>Off Mesh Link</b> entre las dos esferas.  Inicie el modo Play y haga clic en la plataforma lejana.  Como se esperaba, el agente ahora puede navegar a la plataforma desconectada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/0c7/a61/7f60c7a61db24f3961ea0b7332de56a1.png"></div><br>  En los niveles de su juego, es posible que necesite cambiar estos par√°metros para lograr los resultados deseados, pero una combinaci√≥n de estas caracter√≠sticas le proporciona una herramienta conveniente y lista para usar.  Puedes crear r√°pidamente un juego simple usando la funcionalidad NavMesh. <br><br>  <em>Este tutorial es parte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">la Programaci√≥n de IA de juegos</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="external nofollow">Unity 2017 - Tercera edici√≥n</a> de Ray Barrera, Aung Sithu Kyaw y Thet Naing Swe.</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414453/">https://habr.com/ru/post/es414453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414443/index.html">Caracter√≠sticas de las llamadas a funciones en C ++</a></li>
<li><a href="../es414445/index.html">Mejorando Zimbra con la Suite Zextras</a></li>
<li><a href="../es414447/index.html">Tipos de todos los tiempos</a></li>
<li><a href="../es414449/index.html">C√≥mo hacer amigos de todos los operadores en el estadio y no sembrarlo con cientos de antenas</a></li>
<li><a href="../es414451/index.html">"Calendario de pruebas" para junio. El probador debe atrapar el error, leer a Caner y organizar el movimiento.</a></li>
<li><a href="../es414455/index.html">Algoritmo de generaci√≥n de paleta de colores</a></li>
<li><a href="../es414459/index.html">Detectores y descriptores de puntos singulares R√ÅPIDO, BREVE, ORB</a></li>
<li><a href="../es414463/index.html">La IA misma aprendi√≥ a construir un cubo de Rubik</a></li>
<li><a href="../es414465/index.html">Meta Crush Saga: juego en tiempo de compilaci√≥n</a></li>
<li><a href="../es414467/index.html">Art√≠culos de la Conferencia de Minsk C ++ CoreHard Spring 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>