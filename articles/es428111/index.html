<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèº üåê üßò Aritm√©tica de precisi√≥n arbitraria en Erlang ü§∞üèº üÜó üß°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="@rawpixel 


 Incluso los escolares son conscientes de la existencia de varios sistemas num√©ricos y del hecho de que no todas las fracciones decimales...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aritm√©tica de precisi√≥n arbitraria en Erlang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428111/"><p><img src="https://habrastorage.org/webt/h6/vn/cg/h6vncgl-xdc_8d5peworwhnrg4a.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@rawpixel</a> </p><br><p>  Incluso los escolares son conscientes de la existencia de varios sistemas num√©ricos y del hecho de que no todas las fracciones decimales finitas son una fracci√≥n finita en un sistema num√©rico binario.  Pocas personas piensan que debido a este hecho, las operaciones en flotante y doble no son exactas. </p><br><p>  Si hablamos de Erlang, entonces, como muchos otros idiomas, implementa el est√°ndar IEEE754 para flotante, mientras que el tipo entero est√°ndar en Erlang se implementa utilizando aritm√©tica de precisi√≥n arbitraria.  Sin embargo, me gustar√≠a tener no solo bigint, sino tambi√©n la capacidad de operar con n√∫meros racionales, complejos y de coma flotante con la precisi√≥n necesaria. </p><br><p> El art√≠culo proporciona una visi√≥n general m√≠nima de la teor√≠a de codificaci√≥n de n√∫meros de coma flotante y los ejemplos m√°s sorprendentes de efectos emergentes.  La soluci√≥n que proporciona la precisi√≥n necesaria de las operaciones a trav√©s de la transici√≥n a una representaci√≥n de punto fijo est√° dise√±ada como una biblioteca EAPA (Erlang Arbitrary Precision Arithmetic), dise√±ada para satisfacer las necesidades de las aplicaciones financieras desarrolladas en Erlang / Elixir. </p><a name="habracut"></a><br><hr><br><h2 id="standarty-standarty-standarty">  Normas, normas, normas ... </h2><br><p>  Hoy, el est√°ndar principal para la aritm√©tica de punto flotante binario es el IEEE754, ampliamente utilizado en ingenier√≠a y programaci√≥n.  Define cuatro formatos de presentaci√≥n: </p><br><ul><li>  precisi√≥n simple 32 bits </li><li>  doble precisi√≥n de 64 bits </li><li>  precisi√≥n de extensi√≥n √∫nica&gt; = 43 bits (rara vez se usa) </li><li>  precisi√≥n de doble extensi√≥n&gt; = 79 bits (normalmente se utilizan 80 bits) <br>  y cuatro modos de redondeo: </li><li>  Redondeando, tendiendo al entero m√°s cercano. </li><li>  Redondeo tendiente a cero. </li><li>  Redondeo tendiente a + ‚àû </li><li>  Redondeando hacia -‚àû </li></ul><br><p>  La mayor√≠a de los microprocesadores modernos se fabrican con una implementaci√≥n de hardware de la representaci√≥n de variables reales en el formato IEEE754.  Los formatos de presentaci√≥n limitan el l√≠mite de tama√±o de un n√∫mero, y los modos de redondeo afectan la precisi√≥n.  Los programadores a menudo no pueden cambiar el comportamiento del hardware e implementar lenguajes de programaci√≥n.  Por ejemplo, la implementaci√≥n oficial de Erlang almacena un flotante en 3 palabras en una m√°quina de 64 bits y en 4 palabras en una de 32 bits. </p><br><p>  Como se mencion√≥ anteriormente, los n√∫meros en el formato IEEE754 son un conjunto finito en el que se asigna un conjunto infinito de n√∫meros reales, por lo que el n√∫mero original puede presentarse en el formato IEEE754 con un error. </p><br><p>  La mayor parte de los n√∫meros cuando se muestran en un conjunto finito tiene un error relativo estable y peque√±o.  Entonces, para flotaci√≥n es 11.920928955078125e-6%, y para doble - 2.2204460492503130808472633361816e-14%.  En la vida de los programadores, la mayor√≠a de las tareas diarias que se pueden resolver nos permiten descuidar este error, aunque debe tenerse en cuenta que incluso en tareas simples puede pisar el rastrillo, ya que la magnitud del error absoluto puede alcanzar 10 <sup>31</sup> y 10 <sup>292</sup> para flotaci√≥n y doble, respectivamente, causando dificultades en los c√°lculos. </p><br><h2 id="illyustraciya-effektov">  Ilustraci√≥n de efectos </h2><br><p>  De la informaci√≥n general a los negocios.  Intentemos reproducir los efectos emergentes en Erlang. </p><br><p>  Todos los ejemplos a continuaci√≥n est√°n dise√±ados como pruebas ct. </p><br><h3 id="okruglenie-i-poterya-tochnosti">  Redondeo y p√©rdida de precisi√≥n. </h3><br><p>  Comencemos con los cl√°sicos: la suma de dos n√∫meros: 0.1 + 0.2 = ?: </p><br><pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t30000000000000004</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> [<span class="hljs-string"><span class="hljs-string">"0.30000000000000004"</span></span>] = io_lib:format(<span class="hljs-string"><span class="hljs-string">"~w"</span></span>, [<span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">0.2</span></span>]).</code> </pre> <br><p>  El resultado de la adici√≥n es ligeramente diferente del intuitivo esperado, y la prueba pasa con √©xito.  Tratemos de lograr el resultado correcto.  Reescribe la prueba usando EAPA: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t30000000000000004_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">%% prec = 1 symbols after coma X = eapa_int:with_val(1, &lt;&lt;"0.1"&gt;&gt;), Y = eapa_int:with_val(1, &lt;&lt;"0.2"&gt;&gt;), &lt;&lt;"0.3"&gt;&gt; = eapa_int:to_float(1, eapa_int:add(X, Y)).</span></span></code> </pre> <br><p>  Esta prueba tambi√©n tiene √©xito, mostrando que el problema ha sido resuelto. <br>  Continuemos los experimentos, agreguemos un valor muy peque√±o a 1.0: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, Y = <span class="hljs-number"><span class="hljs-number">0.0000000000000000000000001</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> = X + Y.</code> </pre> <br><p>  Como puede ver, nuestro aumento pas√≥ desapercibido.  Estamos tratando de solucionar el problema, ilustrando simult√°neamente una de las caracter√≠sticas de la biblioteca: el escalado autom√°tico: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tiny_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X1 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt;), X2 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">25</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"0.0000000000000000000000001"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0000000000000000000000001"</span></span>&gt;&gt; = eapa_int:to_float(eapa_int:add(X1, X2)).</code> </pre> <br><h3 id="perepolnenie-razryadnoy-setki">  Bit Grid Overflow </h3><br><p>  Adem√°s de los problemas asociados con n√∫meros peque√±os, el desbordamiento es un problema obvio y significativo. </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float_overflow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740991.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740990.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740992.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740991.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740993.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740992.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740994.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740993.0</span></span>.</code> </pre> <br><p>  Como puede ver en la prueba, en alg√∫n momento la diferencia deja de ser igual a 1.0, lo que obviamente es un problema.  EAPA tambi√©n resuelve este problema: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float_overflow_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X11 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740992.0"</span></span>&gt;&gt;), X21 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740991.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X11, X21)), X12 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740993.0"</span></span>&gt;&gt;), X22 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740992.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X12, X22)), X13 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740994.0"</span></span>&gt;&gt;), X23 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740993.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X13, X23)).</code> </pre> <br><h3 id="opasnaya-redukciya">  Reducci√≥n peligrosa </h3><br><p>  La siguiente prueba demuestra la ocurrencia de una reducci√≥n peligrosa.  Este proceso va acompa√±ado de una disminuci√≥n catastr√≥fica en la precisi√≥n de los c√°lculos en operaciones donde el valor resultante es mucho menor que la entrada.  En nuestro caso, el resultado de la resta 1. </p><br><p>  Mostramos que en Erlang este problema est√° presente: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = float(<span class="hljs-number"><span class="hljs-number">87654321098765432</span></span>), Y = float(<span class="hljs-number"><span class="hljs-number">87654321098765431</span></span>), <span class="hljs-number"><span class="hljs-number">16.0</span></span> = XY. <span class="hljs-comment"><span class="hljs-comment">%% has to be 1.0</span></span></code> </pre> <br><p>  Result√≥ 16.0 en lugar del esperado 1.0.  Intentemos solucionar esta situaci√≥n: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduction_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"87654321098765432"</span></span>&gt;&gt;), Y = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"87654321098765431"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(eapa_int:sub(X, Y)).</code> </pre> <br><h3 id="drugie-osobennosti-arifmetiki-s-plavayuschey-tochkoy-v-erlang">  Otras caracter√≠sticas de la aritm√©tica de coma flotante en Erlang </h3><br><p>  Comencemos ignorando el cero negativo. </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> = list_to_float(<span class="hljs-string"><span class="hljs-string">"0.0"</span></span>) =:= list_to_float(<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>).</code> </pre> <br><p>  Solo quiero decir que EAPA conserva este comportamiento: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"0.0"</span></span>&gt;&gt;), Y = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>&gt;&gt;), <span class="hljs-literal"><span class="hljs-literal">true</span></span> = eapa_int:eq(X, Y).</code> </pre> <br><p>  Ya que es v√°lido.  Erlang no tiene una sintaxis y un procesamiento claros de NaN e infinitos, lo que da lugar a una serie de caracter√≠sticas, por ejemplo, estas: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">1&gt; </span></span>math:sqrt(list_to_float(<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>)). <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  El siguiente punto es la caracter√≠stica de procesar n√∫meros grandes y peque√±os.  Tratemos de reproducir para los peque√±os: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">2&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">322</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"1"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e-323</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">323</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"1"</span></span>). <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  y para grandes n√∫meros: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">4&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"1"</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">308</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">".0"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e308</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"1"</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">309</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">".0"</span></span>). ** exception error: bad argument</code> </pre> <br><p>  Aqu√≠ hay un par de ejemplos m√°s para n√∫meros peque√±os: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">6&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">322</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"123456789"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e-323</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">300</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"123456789"</span></span>). <span class="hljs-number"><span class="hljs-number">1.23456789e-301</span></span></code> </pre> <br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">8&gt; </span></span><span class="hljs-number"><span class="hljs-number">0.123456789e-100</span></span> * <span class="hljs-number"><span class="hljs-number">0.123456789e-100</span></span>. <span class="hljs-number"><span class="hljs-number">1.524157875019052e-202</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0.123456789e-200</span></span> * <span class="hljs-number"><span class="hljs-number">0.123456789e-200</span></span>. <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  Los ejemplos anteriores confirman la verdad para los proyectos de Erlang: el dinero no se puede contar en IEEE754. </p><br><h2 id="eapa-erlang-arbitrary-precision-arithmetic">  EAPA (Aritm√©tica de precisi√≥n arbitraria de Erlang) </h2><br><p>  EAPA es una extensi√≥n NIF escrita en Rust.  Por el momento, el repositorio EAPA proporciona la interfaz eapa_int m√°s simple y conveniente para trabajar con n√∫meros de punto fijo.  Las caracter√≠sticas de eapa_int incluyen lo siguiente: </p><br><ol><li>  Falta de efectos de la codificaci√≥n IEEE754 </li><li>  Soporte de grandes n√∫meros </li><li>  Precisi√≥n configurable hasta 126 decimales.  (en implementaci√≥n actual) </li><li>  Autoescalado </li><li>  Soporte para todas las operaciones b√°sicas en n√∫meros. </li><li>  Pruebas m√°s o menos completas, incluidas las basadas en propiedades. </li></ol><br><p>  Interfaz <code>eapa_int</code> : </p><br><ul><li>  <code>with_val/2</code> : traducci√≥n de un n√∫mero de coma flotante en una representaci√≥n fija, que se puede utilizar, incluso de forma segura, en json, xml. </li><li>  <code>to_float/2</code> : traducci√≥n de un n√∫mero de punto fijo a un n√∫mero de punto flotante con una precisi√≥n dada. </li><li>  <code>to_float/1</code> - traduce un n√∫mero de punto fijo a un n√∫mero de punto flotante. </li><li>  <code>add/2</code> - la suma de dos n√∫meros </li><li>  <code>sub/2</code> - diferencia </li><li>  <code>mul/2</code> - multiplicaci√≥n </li><li>  <code>divp/2</code> - divisi√≥n </li><li>  <code>min/2</code> - el m√≠nimo de n√∫meros </li><li>  <code>max/2</code> - el m√°ximo de los n√∫meros </li><li>  <code>eq/2</code> - verificar igualdad de n√∫meros </li><li>  <code>lt/2</code> - verifica que el n√∫mero sea menor </li><li>  <code>lte/2</code> - comprobaci√≥n menos que igual </li><li>  <code>gt/2</code> - verifica que el n√∫mero sea mayor </li><li>  <code>gte/2</code> : la comprobaci√≥n es m√°s que igual </li></ul><br><p>  El c√≥digo EAPA se puede encontrar en el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/Vonmo/eapa</a> </p><br><p>  ¬øCu√°ndo deber√≠as usar eapa_int?  Por ejemplo, si su aplicaci√≥n funciona con dinero o necesita realizar operaciones computacionales de manera conveniente y precisa en n√∫meros como 92233720368547758079223372036854775807.92233720368547758079223372036854775807, puede usar EAPA de manera segura. </p><br><p>  Como cualquier soluci√≥n, EAPA es un compromiso.  Obtenemos la precisi√≥n necesaria al sacrificar la memoria y la velocidad de c√°lculo.Las pruebas de rendimiento y las estad√≠sticas recopiladas en sistemas reales muestran que la mayor√≠a de las operaciones se realizan en el rango de 3-30 Œºs.  Este punto tambi√©n debe tenerse en cuenta al elegir una interfaz de punto fijo EAPA. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Por supuesto, est√° lejos de ser siempre necesario resolver tales problemas en Erlang o Elixir, pero cuando surge un problema y no se encuentra una herramienta adecuada, debe inventar una soluci√≥n. <br>  Este art√≠culo es un intento de compartir con la comunidad la herramienta y la experiencia, con la esperanza de que para algunas personas esta biblioteca sea √∫til y ayude a ahorrar tiempo. <br>  ¬øQu√© opinas sobre el dinero en Erlang? </p><br><p>  PD El trabajo con n√∫meros racionales y complejos, as√≠ como el acceso nativo a n√∫meros enteros, flotantes, complejos y racionales de precisi√≥n arbitraria se tratar√°n en las siguientes publicaciones.  ¬°No cambies! </p><br><hr><br><p>  Materiales relacionados: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lo que todo inform√°tico debe saber sobre la aritm√©tica de coma flotante</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lo que necesita saber sobre aritm√©tica de coma flotante</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫meros de punto flotante est√°ndar IEEE 754</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IEEE 754 - est√°ndar aritm√©tico binario</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">punto flotante</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">0.30000000000000004</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428111/">https://habr.com/ru/post/es428111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428101/index.html">C√≥mo automatizar con Jenkins construyendo y rodando artefactos de artefactos de modelos de metadatos para tablas en el repositorio</a></li>
<li><a href="../es428103/index.html">Mitap en San Petersburgo: ingenier√≠a de datos y m√°s</a></li>
<li><a href="../es428105/index.html">Blogger recomienda: marketing de influencia</a></li>
<li><a href="../es428107/index.html">Contenedorizaci√≥n de aplicaciones Angular 6 SPA Template ASP .NET Core 2.1</a></li>
<li><a href="../es428109/index.html">Muro corporativo</a></li>
<li><a href="../es428113/index.html">A la pregunta de las curvas de Bezier, la velocidad de Arduino y un sitio interesante, o c√≥mo pas√© el fin de semana</a></li>
<li><a href="../es428115/index.html">Desarrollo web para comercio electr√≥nico: 5 tendencias tecnol√≥gicas para 2019</a></li>
<li><a href="../es428117/index.html">Procesadores de tensor gratuitos de Google en la nube colaborativa</a></li>
<li><a href="../es428119/index.html">"Clase-campos-propuesta" o "¬øQu√© sali√≥ mal en tc39 commit"</a></li>
<li><a href="../es428121/index.html">Stan Drapkin. Trampas de criptograf√≠a de alto nivel en .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>