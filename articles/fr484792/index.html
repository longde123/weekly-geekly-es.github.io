<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçü§ù‚Äçüë®üèª üë®‚Äçüë©‚Äçüë¶ ü§öüèΩ Optimisation des mod√®les 3D pour la sc√®ne du jeu üçº üéà ü§úüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article compl√®te une s√©rie de publications du studio Krasnodar Plarium sur divers aspects du travail avec des mod√®les 3D dans Unity. Articles pr√©c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimisation des mod√®les 3D pour la sc√®ne du jeu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/">  Cet article compl√®te une s√©rie de publications du studio Krasnodar Plarium sur divers aspects du travail avec des mod√®les 3D dans Unity.  Articles pr√©c√©dents: <a href="https://habr.com/ru/company/plarium/blog/440690/">"Fonctionnalit√©s du travail avec Mesh dans Unity"</a> , <a href="https://habr.com/ru/company/plarium/blog/443870/">"Unity: √©dition proc√©durale de Mesh"</a> , <a href="https://habr.com/ru/company/plarium/blog/447820/">"Importation de mod√®les 3D dans Unity et pi√®ges"</a> , <a href="https://habr.com/ru/company/plarium/blog/451794/">"Indentation de pixels dans le scan de texture"</a> . <br><br>  Il y a pr√®s de 2 ans, nous avons √©crit <a href="https://habr.com/ru/company/plarium/blog/348494/">un article</a> dans lequel nous parlions de l'option d'optimisation de la g√©om√©trie 3D dans une sc√®ne avec des restrictions sur l'angle de la cam√©ra et la rotation des objets correspondants.  Depuis, peu de choses ont coul√©, mais la possibilit√© d'am√©liorer la solution, d'envisager diff√©rentes approches et d'espionner les autres hante l'esprit des d√©veloppeurs.  Dans cet article, nous d√©crirons une version am√©lior√©e de l'algorithme bas√© sur la peinture de polygones, ainsi que parler d'essayer de transf√©rer une partie de ce travail vers un package 3D. <br><br><img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br><br><h3>  Recadrer dans la sc√®ne </h3><br>  Nous avons d√©j√† consid√©r√© le principe de base de cet algorithme dans l'article ci-dessus: nous √©teignons tous les effets et les objets transparents, peignons les polygones non trait√©s avec une couleur et ceux trait√©s avec des couleurs diff√©rentes, restituons et extrayons le r√©sultat.  Dans l'ancienne version, ils peignaient pour que tout le noir soit redondant et qu'un seul triangle soit marqu√© en rouge. <br><br>  <a href="https://habr.com/ru/company/plarium/blog/348494/">Dans les commentaires</a> de cet article, l'un des lecteurs a soulign√© la possibilit√© d'optimiser l'algorithme en √©tablissant une correspondance biunivoque entre l'ensemble des polygones et un ensemble de nombres uniques.  Ensuite, il sera possible de traiter plus d'un triangle de la m√™me mani√®re.  Consid√©rez cette option. <br><br>  Dans ce cas, ainsi que la derni√®re fois, une pr√©-formation est cens√©e √™tre li√©e √† la d√©sactivation de tous les objets sifflants sur la sc√®ne et des objets garantis de ne pas affecter la visibilit√© du mod√®le cible.  Les vues de cam√©ra sont trait√©es de mani√®re presque ind√©pendante; elles ne sont connect√©es que par un tampon d'index commun de polygones visibles.  De plus, un pr√©traitement de la g√©om√©trie est effectu√© pour chaque angle, pendant lequel les polygones sont retourn√©s qui sont retourn√©s vers la cam√©ra (face arri√®re).  Cela est d√ª au fait qu'√† un certain stade de l'algorithme, un maillage temporaire est cr√©√© avec un nombre de sommets beaucoup plus important que celui d'origine.  Ce nombre peut facilement d√©passer le seuil de 65 535, ce qui n√©cessitera des gestes suppl√©mentaires dans les calculs et entra√Ænera une baisse des performances.  Dans tous les cas, ces polygones seront supprim√©s, car leur couleur ne tombera pas dans le cadre.  Cependant, √©tant donn√© que chaque triangle donne potentiellement lieu √† trois sommets de d√©chets, l'√©limination des polygones inutiles √† l'avance facilite l'√©tape principale de l'algorithme et r√©duit les co√ªts de m√©moire. <br><br>  Soit un mod√®le 3D dont la g√©om√©trie est repr√©sent√©e par un maillage.  Pour peindre un polygone sp√©cifique dans une couleur unique, vous devez peindre tous ses sommets dans cette couleur.  √âtant donn√© que dans le cas g√©n√©ral, un sommet peut appartenir √† diff√©rents polygones, cela ne fonctionnera pas pour r√©soudre le probl√®me de front.  Peu importe la fa√ßon dont nous colorions un sommet, lors du rendu, sa couleur se glissera sur tous les triangles qui le poss√®dent, conform√©ment √† l'algorithme d'interpolation sur le c√¥t√© de la carte vid√©o. <br><br><img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>  <i>Un exemple d'interpolation des couleurs lors de l'affichage de polygones avec des sommets communs</i> <br><br>  Par cons√©quent, il est n√©cessaire de diviser le maillage en polygones ind√©pendants distincts, tout en pr√©servant la topologie et la g√©om√©trie de l'objet.  Dictum factum.  Nous transformons les tableaux de triangles et de sommets de mani√®re √† cr√©er pour chaque triangle 3 sommets uniques, dont la position est d√©termin√©e par les sommets correspondants du maillage d'origine.  Il est √† noter que dans le cas g√©n√©ral, un tel maillage aura un nombre de sommets significativement plus important que l'original.  Et si ce nombre d√©passe 65 535, lors de la cr√©ation du maillage, vous devez sp√©cifier le format d'indexation appropri√©. <br><br><div class="spoiler">  <b class="spoiler_title">Convertissez le maillage d'origine en un maillage avec des sommets uniques √† chaque polygone</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNotSmoothMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oVertices = origin.vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oTriangles = origin.triangles; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triangles.Length; i++) { vertices[i] = oVertices[oTriangles[i]]; triangles[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh() { indexFormat = vertices.Length &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span> ? IndexFormat.UInt32 : IndexFormat.UInt16, vertices = vertices, triangles = triangles }; }</code> </pre> <br></div></div><br>  Vous devez maintenant d√©signer les polygones de ce maillage afin qu'apr√®s l'op√©ration de rendu, il soit possible de d√©terminer celui qui est apparu √† l'√©cran.  Comme d√©j√† mentionn√©, nous g√©n√©rons des couleurs uniques pour les polygones et peignons chacun des trois sommets dans la couleur correspondante.  Le r√©sultat est un nouveau maillage, que nous avons appel√© <b>maillage de couleur octet</b> . <br><br><img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>  <i><b>Maille de couleur octet</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Coloration de maillage dans laquelle chaque sommet appartient √† un seul polygone</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorizePolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pColors = ColorsOfPolygons(mesh); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.vertexCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { colors[i] = pColors[i / <span class="hljs-number"><span class="hljs-number">3</span></span>]; } mesh.colors = colors; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetColorsOfPolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = Int2Color(i);<span class="hljs-comment"><span class="hljs-comment">//         ,     Color2Int //      ,       int     Color32 colors[i] = color; } return colors; }</span></span></code> </pre> <br></div></div><br>  N'oubliez pas la coloration.  Il est temps de rendre.  Nous effectuons un rendu 3D pour tous les angles de cam√©ra et, lors du traitement de chacun d'eux, reconstituons le tampon d'indices de polygone uniques dont les couleurs ont √©t√© d√©tect√©es dans le cadre.  Pour le temps des calculs pour la cam√©ra, vous devez d√©sactiver l'anticr√©nelage pour √©viter l'apparition de nouvelles couleurs en raison de l'interpolation des pixels voisins. <br><br><div class="spoiler">  <b class="spoiler_title">Lecture et stockage des couleurs sous diff√©rents angles de cam√©ra</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// CameraTransform ‚Äî         //      SetCameraTransform private static HashSet&lt;Color&gt; GetVisibleColors(Camera camera, CameraTransform[] cameraTransforms) { var renderTexture = new RenderTexture(1920, 1080, 24);//for example var rtRect = new Rect(0, 0, renderTexture.width, renderTexture.height); var frame = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, false);//    -  RGB24   ,    RGBA32 var visibleColorsSet = new HashSet&lt;Color&gt;(); foreach (var cameraTransform in cameraTransforms) { SetCameraTransform(camera, cameraTransform); CreateScreenShot(camera, renderTexture, frame, rtRect); visibleColorsSet.UnionWith(GetTextureColors(frame)); } return visibleColorsSet; } public static void SetCameraTransform(Camera camera, CameraTransform camTransform) { camera.transform.position = camTransform.Position; camera.transform.rotation = camTransform.Rotation; camera.fieldOfView = camTransform.FieldOfView; camera.orthographic = camTransform.IsOrthographic; camera.nearClipPlane = camTransform.NearClippingPlane; camera.farClipPlane = camTransform.FarClippingPlane; } private static HashSet&lt;Color&gt; GetTextureColors(Texture2D texture) { return new HashSet&lt;Color&gt;(texture.GetPixels()); } private static void CreateScreenShot(Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect) { cam.targetTexture = renderTexture; cam.Render(); RenderTexture.active = cam.targetTexture; screenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; cam.targetTexture = null; } }</span></span></code> </pre> <br></div></div><br>  Il convient de mentionner qu'en raison de la discr√©tisation, certains triangles peuvent ne pas s'afficher en raison de la taille particuli√®rement petite de leur projection sur l'√©cran, et non pas parce que quelque chose les chevauche ou qu'ils sont tourn√©s du mauvais c√¥t√©.  Nous avons impl√©ment√© une version conservatrice de l'algorithme.  Dans ce cas, l' <b>AABB de la</b> projection du triangle sur l'√©cran est calcul√©, et si au moins un de ses c√¥t√©s est inf√©rieur au c√¥t√© texel de l'image, alors un tel polygone est marqu√© comme visible.  Cette approche prot√®ge contre les artefacts lors de l'ex√©cution de l'algorithme avec une r√©solution inf√©rieure √† la r√©solution d'√©cran du p√©riph√©rique cible.  Si vous ignorez les petits polygones, le r√©sultat sera √©galement acceptable √† condition que la r√©solution de la texture de rendu utilis√©e soit sup√©rieure √† la r√©solution des √©crans des appareils pr√©vus. <br><br>  Nous avons impl√©ment√© cet algorithme de recadrage dans <b>Unity</b> et l'avons utilis√© pour optimiser des objets statiques dont les mod√®les se trouvent plus d'une fois dans la sc√®ne dans diff√©rentes positions.  C'est principalement le d√©cor: pierres, arbres, statues, vases, etc. qui fait r√©f√©rence au pr√©fabriqu√© souvent utilis√©.  Nous aimerions optimiser ces objets plus t√¥t, au stade de la cr√©ation dans un package 3D, mais qui sait dans quelle pose fantasmagorique le level designer veut mettre son cand√©labre pr√©f√©r√©. <br><br>  Le fait de rogner l'ensemble d'objets du m√™me type avec un tel outil r√©duit la taille de la sc√®ne, car lors du <b>batching statique, les</b> donn√©es du maillage <b>pr√©fabriqu√©</b> commun sont en tout cas copi√©es au stade de la construction autant de fois que les objets dessin√©s actifs avec ce maillage sont repr√©sent√©s dans la sc√®ne.  Notre m√©thode lib√®re √©galement de l'espace dans les atlas de textures, comme les <b>lightmap</b> .  Nous utilisons l'espace √©conomis√© pour augmenter le d√©tail des parties des mod√®les qui ont surv√©cu au nettoyage. <br><br><h3>  Recadrage 3D </h3><br>  N√©anmoins, il vaut mieux que l‚Äôartiste puisse couper tout ce qui est inutile dans son √©diteur, r√©duisant ainsi le nombre d‚Äô√©tapes de pr√©paration du contenu.  Cela se justifie lorsque le mod√®le est utilis√© dans une sc√®ne avec une seule rotation pr√©d√©termin√©e par rapport √† la cam√©ra.  Auparavant, les objets qui seraient exactement tourn√©s vers l'utilisateur d'un c√¥t√© √©taient souvent simplifi√©s manuellement avant leur int√©gration dans le projet.  Il est important de noter que la mise en ≈ìuvre d'une telle simplification par programme dans <b>Unity est</b> beaucoup plus difficile en raison de la complexit√© du d√©veloppement de l'emballage <b>UV</b> , de sorte que l'automatisation au stade d'un package 3D facilite parfois la vie d'un artiste. <br><br>  Un des outils pour travailler avec des mod√®les 3D dans notre entreprise est <b>Blender</b> .  Nous y sommes mont√©s.  Il semble qu'un tel logiciel "adulte", comme <b>Blender</b> , devrait avoir des fonctionnalit√©s similaires.  Cependant, il s'est av√©r√© qu'il ne devrait pas.  J'ai d√ª voir mon propre v√©lo. <br><br>  La premi√®re id√©e a √©t√© d'utiliser l'outil de s√©lection familier - essentiellement r√©p√©ter une partie du travail manuel de l'artiste pour un angle de cam√©ra: s√©lectionner des polygones visibles, inverser la s√©lection, supprimer.  Le plan √©tait le suivant: d√©placer la cam√©ra, d√©terminer la projection <b>AABB</b> du mod√®le dans chaque position, puis demander le r√©sultat de la s√©lection des polygones de la zone correspondant √† l' <b>AABB</b> , obtenir l'union de l'ensemble des polygones de la vue actuelle avec les pr√©c√©dents et supprimer les polygones non s√©lectionn√©s √† la fin. <br><br>  Cependant, lors de la mise en ≈ìuvre du script, un inconv√©nient important a √©t√© constat√© au niveau de la t√¢che.  Les outils de s√©lection dans <b>Blender (s√©lection de rectangle, s√©lection de cercle)</b> <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">perdent en pr√©cision</a> avec l'augmentation du nombre d'√©l√©ments s√©lectionn√©s par unit√© de surface de l'√©cran (certains polygones ne sont pas s√©lectionn√©s), ce qui rend leur utilisation dans nos outils d'automatisation impossible.  Fait int√©ressant: dans le m√™me <b>3ds Max</b> , un tel probl√®me n'est pas observ√©. <br><br><img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>  <i>Mise en √©vidence de loin dans <b>Blender</b></i> <br><br><img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>  <i>R√©sultat de la s√©lection</i> <br><br>  La tentative suivante visait √† r√©soudre le probl√®me de front: nous avons envoy√© des rayons de la cam√©ra √† travers chaque pixel de la fen√™tre et regard√© quels polygones √©taient les premiers √† se croiser avec au moins un rayon.  Nous n'esp√©rions pas de r√©sultats pr√©cis avec cette approche, mais cela valait la peine d'essayer.  Le r√©sultat est √©vident: tr√®s faible productivit√© lors du traitement sur le <b>CPU</b> ou les m√™mes trous avec un petit nombre de rayons. <br><br>  N√©anmoins, nous avons pris pied pour la mise en ≈ìuvre d'une approche plus avanc√©e.  L'id√©e √©tait de s√©lectionner un certain nombre de points al√©atoires sur chaque polygone puis d'envoyer des rayons de la cam√©ra dans leur direction.  Cette approche a bien fonctionn√©, mais nous avons eu quelques cas limites: des polygones ont √©galement √©t√© coup√©s, dans lesquels l'angle entre le faisceau et leur normale √©tait approximativement √©gal √† œÄ / 2.  Ainsi, lorsque la cam√©ra effectue un zoom en raison de distorsions de perspective, des zones de d√©coupe peuvent s'ouvrir. <br><br>  Cette m√©thode √©tait, de l'avis des artistes, trop agressive, nous avons donc d√©cid√© d'arr√™ter de <b>recadrer</b> uniquement les <b>faces arri√®re</b> . <br><br><h3>  Conclusion </h3><br>  Ce n'est un secret pour personne qu'une attitude prudente envers les ressources de l'appareil lors de la cr√©ation de jeux est le facteur le plus important affectant la qualit√© du produit final.  Cela est particuli√®rement vrai pour les plates-formes mobiles, de mauvaise humeur √† l'utilisation active de la RAM.  La r√©duction du nombre de polygones vous permet de remplir plus efficacement l'espace des atlas de texture et r√©duit l√©g√®rement la charge de calcul. <br><br>  N'oubliez pas non plus le co√ªt des heures-homme et le co√ªt des erreurs lors de l'utilisation des outils d√©crits ci-dessus, etc.  L'approche propos√©e suppose un pipeline qui fonctionne bien pour le travail du d√©partement artistique, en particulier les employ√©s impliqu√©s dans l'int√©gration des mod√®les dans le projet. <br><br>  Ainsi, ayant les conditions et les outils discut√©s dans cet article, nous adh√©rons aux r√®gles suivantes.  S'il est suppos√© que le mod√®le cr√©√© sera toujours tourn√© d'un c√¥t√© vers l'utilisateur, et aussi si sous ces angles le chevauchement de certaines parties du mod√®le par d'autres est assez petit, alors l'artiste utilise notre <b>outil de rognage de face arri√®re</b> dans l'√©diteur 3D, v√©rifie l'exactitude et proc√®de √† l'empaquetage du d√©veloppement <b>UV</b> .  Si le mod√®le est souvent utilis√© dans diff√©rentes positions ou a une g√©om√©trie plus complexe, alors apr√®s l'importation dans le projet, nous ex√©cutons l'algorithme d√©crit dans la premi√®re partie de l'article, en traitant tous les objets statiques de la sc√®ne avec. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484792/">https://habr.com/ru/post/fr484792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484776/index.html">√âv√©nements num√©riques √† Saint-P√©tersbourg du 21 au 26 janvier</a></li>
<li><a href="../fr484778/index.html">Intel Parallel Studio XE 2020: tout ce qu'il y a de mieux pour les d√©veloppeurs</a></li>
<li><a href="../fr484782/index.html">Boutique en ligne c√¥t√© client Blazor: Partie 2 - CI / CD</a></li>
<li><a href="../fr484788/index.html">Plus de fonctionnalit√©s pour votre syst√®me: int√©gration de la t√©l√©phonie et CRM / ERP / Helpdesk. Quoi, comment et pourquoi?</a></li>
<li><a href="../fr484790/index.html">L'histoire de la fa√ßon dont, en raison d'une option sur le serveur Windows, nos sites ont ralenti</a></li>
<li><a href="../fr484796/index.html">Comment ai-je obtenu la certification OSWE?</a></li>
<li><a href="../fr484798/index.html">Pourquoi le tri rapide est-il vraiment lent? Nouvelle m√©thode de tri de tableau</a></li>
<li><a href="../fr484800/index.html">Analyseur de code source de Microsoft Application Inspector</a></li>
<li><a href="../fr484802/index.html">Mode d'autodestruction: d√©composition de la capsule endoscopique due √† la lumi√®re</a></li>
<li><a href="../fr484804/index.html">Que chiffrer dans un syst√®me d'entreprise? Et pourquoi faire √ßa?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>