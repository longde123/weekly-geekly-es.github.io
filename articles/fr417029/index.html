<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎮 🤧 🚙 Profilage de code avec LLVM 👩🏽‍🔬 🐇 👩🏾‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La malédiction du non-déterminisme 

 Ma première tentative d'écrire un passage LLVM - j'adore ces segfolty 

 Récemment, j'ai rencontré un problème i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Profilage de code avec LLVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417029/"><h3>  La malédiction du non-déterminisme </h3><br><img src="https://habrastorage.org/webt/41/_f/as/41_fasuco5jnfutepliohcp44pm.jpeg"><br>  <i>Ma première tentative d'écrire un passage LLVM - j'adore ces segfolty</i> <br><br>  Récemment, j'ai rencontré un problème intéressant - j'avais besoin d'une méthode déterministe et multiplateforme pour déterminer le temps d'exécution du code C ++.  Par le mot «déterministe», je veux dire que le même code sera exécuté pour le même nombre d'unités de temps.  Par multiplateforme, je comprends que le même code sous Windows et sous Ubuntu fonctionnera pour le même nombre d'unités de temps. <br><br>  Naturellement, la mesure du temps sur le CPU ne remplit pas ces conditions.  Le code machine varie en fonction de l'architecture et du système d'exploitation, et le même code prendra un temps différent à exécuter.  Même sur la même machine, des facteurs tels que les échecs de cache joueront un grand rôle - suffisamment pour déformer les résultats de mesure du temps d'exécution du même code.  J'avais besoin de quelque chose de plus intelligent ... <br><a name="habracut"></a><br><h3>  La motivation </h3><br>  J'ai rencontré ce problème lorsque je travaillais sur mon projet, Code Character.  Code Character est un concours d'IA en ligne dans lequel les participants écrivent des robots pour contrôler une armée dans une stratégie au tour par tour.  Je voulais limiter la quantité de code qu'un participant peut exécuter en un seul mouvement. <br><br>  Ma première pensée a été simplement de mesurer le temps d'exécution du code, mais, comme nous le voyons, cette stratégie n'est pas déterministe, et le participant qui a envoyé le même code deux fois obtiendra des résultats complètement différents.  En fait, nous avons essayé d'implémenter cette solution, et les résultats changent tellement qu'un participant peut gagner ou perdre avec le même code.  Le résultat sera complètement aléatoire et nous avons abandonné l'idée de mesurer le temps. <br><br><h3>  ByLecode LLVM </h3><br>  Comme nous ne pouvons pas mesurer le temps, nous avons plutôt décidé de mesurer le nombre d'instructions exécutées.  Par conséquent, nous devons instrumenter le code du participant.  Si vous n'êtes pas familier avec ce terme, cela ajoute du code à l'application, afin de surveiller certains paramètres, par exemple, l'utilisation du processeur ou l'exécution.  Naturellement, nous ne nous attendons pas à ce que les participants le fassent eux-mêmes, nous devons automatiser le processus. <br><br>  Nous voulions éviter les frais généraux pour les outils d'exécution lorsque vous travaillez sur notre serveur, et donc quelque chose comme un outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PIN</a> ne convient pas à nos fins.  Au lieu de cela, nous avons décidé d'instruire directement le code des participants afin de compter le nombre d'instructions qui seraient exécutées.  Au lieu d'instrumenter les binaires (code machine), nous avons décidé d'utiliser Clang pour compiler le code et le bytecode LLVM de l'instrument. <br><br>  Si vous débutez avec LLVM, il s'agit d'une collection de compilateurs modulaires et réutilisables et de technologies de chaîne d'outils.  L'un des principaux projets est LLVM IR et backend.  En termes simples, une représentation intermédiaire a été développée dans laquelle un front-end de compilation compile du code.  Ce code, LLVM IR, est ensuite compilé en code machine par le backend LLVM.  Ainsi, si vous créez un nouveau langage, vous pouvez décider d'autoriser LLVM à prendre en charge la génération et l'optimisation de code machine et à écrire un frontend pour convertir votre langage en LLVM IR. <br><br><img src="https://habrastorage.org/webt/ag/ud/pm/agudpmnchiuciou-p29zk8z5nzo.png"><br>  <i>Clang convertit le code C ++ en LLVM IR, qui est ensuite converti en code machine par le backend LLVM.</i> <br><br>  Clang est l'interface de LLVM.  Comme nous avons besoin d'une méthode multiplateforme pour mesurer le code, nous ne pouvons pas instrumenter de code binaire.  LLVM IR, cependant, est indépendant de la plate-forme, car il ne s'agit que d'une représentation intermédiaire du code.  L'instrumentation du code IR avec les bibliothèques LLVM est une solution multiplateforme simple. <br><br><h3>  Solution </h3><br>  Un simple compte d'instructions LLVM IR n'est évidemment pas approprié, car nous avons besoin du nombre d'instructions qui seront réellement exécutées, et pas seulement du nombre d'instructions dans le code.  Au final, nous avons développé un algorithme simple basé sur le concept de blocs de code de base. <br><br>  Une unité de base est un ensemble d'instructions dans lequel seule la première instruction peut être le point d'entrée et seule la dernière instruction peut être le point de sortie.  ( <i>Toutes les transitions à l'intérieur du bloc de base sont également interdites - environ la traduction</i> ) <i>.</i> Pour comprendre cela, essayez de diviser le code en morceaux dans lesquels les instructions de branche (transitions, boucles et retours) ne peuvent être que les dernières de l'ensemble et l'entrée dans le bloc (première instruction dans fonction, boucle ou bloc if / else) n'est possible que sur la première instruction.  Le résultat est un ensemble de blocs de base - des blocs de code séquentiel qui s'exécutent simplement séquentiellement, sans décider quelle instruction exécuter ensuite. <br><br>  Pourquoi ne l'essayons-nous pas maintenant?  Voici un extrait de code fourni par un contributeur de caractères de code: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the soldiers who aren't patrolling attack the enemy for (int i = NUM_SOLDIERS / 2; i &lt; NUM_SOLDIERS; ++i) { auto &amp;soldier = state.soldiers[i]; if (soldier.hp == 0) // If this soldier is dead, skip it continue; for (auto enemy_soldier : state.enemy_soldiers) { if (enemy_soldier.hp != 0) { // Ensure your prospective target has // not already been slain soldier.soldier_target = enemy_soldier.id; break; } } }</span></span></code> </pre> <br>  Lien Github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://gist.github.com/JHurricane96/8c9c3a45ec5e969de4d9fecb47ebef69#file-player_code-cpp</a> <br><br>  En utilisant le fait que l'unité de base n'a qu'un seul point d'entrée (la première instruction), nous pouvons diviser ce fragment en les unités de base suivantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-------------------------------- BB 1 ---------------------------------- for (int i = NUM_SOLDIERS / 2; i &lt; NUM_SOLDIERS; ++i) { //-------------------------------- BB 2 ---------------------------------- auto &amp;soldier = state.soldiers[i]; if (soldier.hp == 0) //-------------------------------- BB 3 ---------------------------------- continue; //-------------------------------- BB 4 ---------------------------------- for (auto enemy_soldier : state.enemy_soldiers) { //-------------------------------- BB 5 ---------------------------------- if (enemy_soldier.hp != 0) { //-------------------------------- BB 6 ---------------------------------- soldier.soldier_target = enemy_soldier.id; break; //-------------------------------- BB 7 ---------------------------------- } } }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien Github</a> <br>  Cela nous a aidés à comprendre le fonctionnement des blocs de base, regardons maintenant cet algorithme dans LLVM IR: <br><br><pre> <code class="cpp hljs">; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">140</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">181</span></span>, %<span class="hljs-number"><span class="hljs-number">139</span></span> %<span class="hljs-number"><span class="hljs-number">141</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">142</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">141</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">143</span></span> = icmp slt i64 %<span class="hljs-number"><span class="hljs-number">142</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> br i1 %<span class="hljs-number"><span class="hljs-number">143</span></span>, label %<span class="hljs-number"><span class="hljs-number">144</span></span>, label %<span class="hljs-number"><span class="hljs-number">184</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">144</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">140</span></span> %<span class="hljs-number"><span class="hljs-number">145</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">146</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">147</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">146</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">148</span></span> = call dereferenceable(<span class="hljs-number"><span class="hljs-number">72</span></span>) %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* @_ZNSt5arrayIN12player_state7SoldierELm20EEixEm( %<span class="hljs-string"><span class="hljs-string">"struct.std::array.10"</span></span>* %<span class="hljs-number"><span class="hljs-number">145</span></span>, i64 %<span class="hljs-number"><span class="hljs-number">147</span></span>) #<span class="hljs-number"><span class="hljs-number">3</span></span> store %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">148</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">149</span></span> = load %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>*, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">150</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">149</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">151</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">150</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">152</span></span> = icmp eq i64 %<span class="hljs-number"><span class="hljs-number">151</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> br i1 %<span class="hljs-number"><span class="hljs-number">152</span></span>, label %<span class="hljs-number"><span class="hljs-number">153</span></span>, label %<span class="hljs-number"><span class="hljs-number">154</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">153</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">144</span></span> br label %<span class="hljs-number"><span class="hljs-number">181</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien Github</a> <br><br>  Si vous regardez attentivement, vous remarquerez que le fragment de code ci-dessus est les trois premiers blocs du fragment de code C ++ compilé dans LLVM IR (chaque ligne est le début du bloc de base). <br><br>  LLVM possède des bibliothèques qui nous permettent d'écrire des «passes» - du code qui peut transformer LLVM IR.  L'API LLVM nous permet de lire et d'analyser facilement LLVM IR en parcourant les modules, les fonctions et les blocs de base, et de modifier LLVM IR avant de le compiler en code machine. <br><br>  Maintenant que nous avons les blocs de base et l'API LLVM, il devient simple de calculer le nombre d'instructions à exécuter à l'aide d'un algorithme aussi simple: <br><br><ol><li>  Nous écrivons la fonction IncrementCount, qui prend un entier et incrémente un entier statique avec cette valeur, chaque fois qu'elle est appelée.  Il doit être lié au code membre. </li><li>  Nous faisons des itérations sur tous les blocs de base.  Pour chaque unité de base, effectuez les étapes 3 et 4. </li><li>  Nous trouvons n - le nombre d'instructions dans cette unité de base. </li><li>  Nous insérons l'appel à la fonction IncrementCount avant la dernière instruction de l'unité de base, avec l'argument n. </li><li>  L'entier statique avec lequel IncrementCount fonctionne sera le compteur d'instructions après l'exécution du code.  Il peut être enregistré quelque part puis vérifié. </li></ol><br>  Notre IR instrumenté fonctionne comme ceci: <br><br><pre> <code class="cpp hljs">; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">140</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">181</span></span>, %<span class="hljs-number"><span class="hljs-number">139</span></span> %<span class="hljs-number"><span class="hljs-number">141</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">142</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">141</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">143</span></span> = icmp slt i64 %<span class="hljs-number"><span class="hljs-number">142</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">4</span></span>) br i1 %<span class="hljs-number"><span class="hljs-number">143</span></span>, label %<span class="hljs-number"><span class="hljs-number">144</span></span>, label %<span class="hljs-number"><span class="hljs-number">184</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">144</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">140</span></span> %<span class="hljs-number"><span class="hljs-number">145</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">146</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">147</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">146</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">148</span></span> = call dereferenceable(<span class="hljs-number"><span class="hljs-number">72</span></span>) %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* @_ZNSt5arrayIN12player_state7SoldierELm20EEixEm( %<span class="hljs-string"><span class="hljs-string">"struct.std::array.10"</span></span>* %<span class="hljs-number"><span class="hljs-number">145</span></span>, i64 %<span class="hljs-number"><span class="hljs-number">147</span></span>) #<span class="hljs-number"><span class="hljs-number">3</span></span> store %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">148</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">149</span></span> = load %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>*, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">150</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">149</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">151</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">150</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">152</span></span> = icmp eq i64 %<span class="hljs-number"><span class="hljs-number">151</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">10</span></span>) br i1 %<span class="hljs-number"><span class="hljs-number">152</span></span>, label %<span class="hljs-number"><span class="hljs-number">153</span></span>, label %<span class="hljs-number"><span class="hljs-number">154</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">153</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">144</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">1</span></span>) br label %<span class="hljs-number"><span class="hljs-number">181</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien Github</a> <br><br>  Comme nous pouvons le voir, un appel IncrementCount est effectué à la fin de chaque bloc de base, juste avant la dernière instruction.  En utilisant l'int. Statique avec lequel IncrementCount fonctionne, nous pouvons obtenir le nombre d'instructions à la fin du déplacement de chaque participant.  Cette méthode est déterministe et multiplateforme, comme  le même code source est garanti pour générer le même IR LLVM si nous utilisons la même version du compilateur et les mêmes drapeaux. <br><br><h3>  Conclusion </h3><br>  Le profilage de code n'est pas une chose aussi simple que je le pensais.  Dans le processus de travail sur une tâche relativement simple, je me suis familiarisé avec le fonctionnement du compilateur et comment écrire des passes LLVM.  Si vous êtes intéressé à générer du code et que vous souhaitez écrire vos propres passages, LLVM a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide pour débutants</a> .  il y a aussi un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de</a> blog que j'ai utilisé pour écrire mon propre passage.  Étant donné que l'API LLVM n'est pas rétrocompatible entre les principales versions, faites attention à la version de LLVM que vous utilisez. <br><br>  Vous pouvez obtenir le code source du pass <a href="">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417029/">https://habr.com/ru/post/fr417029/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417013/index.html">Les «dunes de sable» de Pluton ne sont pas faites de sable - ce sont des granules de méthane gelé</a></li>
<li><a href="../fr417015/index.html">Nous comprenons ce qui enregistre et ce qui n'enregistre pas l'application Burger King</a></li>
<li><a href="../fr417017/index.html">Comment une expérience nucléaire ratée a généré accidentellement l'astronomie des neutrinos</a></li>
<li><a href="../fr417023/index.html">Expérience du Groupe Rambler: comment nous avons commencé à contrôler complètement la formation et le comportement des composants frontaux React</a></li>
<li><a href="../fr417027/index.html">Comment ai-je écrit la bibliothèque C ++ 11 standard ou pourquoi boost est si effrayant. Présentation</a></li>
<li><a href="../fr417031/index.html">Sécurité Mobile OAuth 2.0</a></li>
<li><a href="../fr417033/index.html">QIWI Kitchen le 7 juin - vidéo des discours de nos intervenants</a></li>
<li><a href="../fr417035/index.html">UnnyWorld: post-mortem</a></li>
<li><a href="../fr417037/index.html">BEERBRAZZERS. Contrôle de la lumière. Vixen Lights 3. Démarrage rapide (1/4)</a></li>
<li><a href="../fr417039/index.html">Apprenez wordpress (et plus) pour rendre les joueurs Youtube rapidement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>