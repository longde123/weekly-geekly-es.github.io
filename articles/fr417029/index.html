<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÆ ü§ß üöô Profilage de code avec LLVM üë©üèΩ‚Äçüî¨ üêá üë©üèæ‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La mal√©diction du non-d√©terminisme 

 Ma premi√®re tentative d'√©crire un passage LLVM - j'adore ces segfolty 

 R√©cemment, j'ai rencontr√© un probl√®me i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Profilage de code avec LLVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417029/"><h3>  La mal√©diction du non-d√©terminisme </h3><br><img src="https://habrastorage.org/webt/41/_f/as/41_fasuco5jnfutepliohcp44pm.jpeg"><br>  <i>Ma premi√®re tentative d'√©crire un passage LLVM - j'adore ces segfolty</i> <br><br>  R√©cemment, j'ai rencontr√© un probl√®me int√©ressant - j'avais besoin d'une m√©thode d√©terministe et multiplateforme pour d√©terminer le temps d'ex√©cution du code C ++.  Par le mot ¬´d√©terministe¬ª, je veux dire que le m√™me code sera ex√©cut√© pour le m√™me nombre d'unit√©s de temps.  Par multiplateforme, je comprends que le m√™me code sous Windows et sous Ubuntu fonctionnera pour le m√™me nombre d'unit√©s de temps. <br><br>  Naturellement, la mesure du temps sur le CPU ne remplit pas ces conditions.  Le code machine varie en fonction de l'architecture et du syst√®me d'exploitation, et le m√™me code prendra un temps diff√©rent √† ex√©cuter.  M√™me sur la m√™me machine, des facteurs tels que les √©checs de cache joueront un grand r√¥le - suffisamment pour d√©former les r√©sultats de mesure du temps d'ex√©cution du m√™me code.  J'avais besoin de quelque chose de plus intelligent ... <br><a name="habracut"></a><br><h3>  La motivation </h3><br>  J'ai rencontr√© ce probl√®me lorsque je travaillais sur mon projet, Code Character.  Code Character est un concours d'IA en ligne dans lequel les participants √©crivent des robots pour contr√¥ler une arm√©e dans une strat√©gie au tour par tour.  Je voulais limiter la quantit√© de code qu'un participant peut ex√©cuter en un seul mouvement. <br><br>  Ma premi√®re pens√©e a √©t√© simplement de mesurer le temps d'ex√©cution du code, mais, comme nous le voyons, cette strat√©gie n'est pas d√©terministe, et le participant qui a envoy√© le m√™me code deux fois obtiendra des r√©sultats compl√®tement diff√©rents.  En fait, nous avons essay√© d'impl√©menter cette solution, et les r√©sultats changent tellement qu'un participant peut gagner ou perdre avec le m√™me code.  Le r√©sultat sera compl√®tement al√©atoire et nous avons abandonn√© l'id√©e de mesurer le temps. <br><br><h3>  ByLecode LLVM </h3><br>  Comme nous ne pouvons pas mesurer le temps, nous avons plut√¥t d√©cid√© de mesurer le nombre d'instructions ex√©cut√©es.  Par cons√©quent, nous devons instrumenter le code du participant.  Si vous n'√™tes pas familier avec ce terme, cela ajoute du code √† l'application, afin de surveiller certains param√®tres, par exemple, l'utilisation du processeur ou l'ex√©cution.  Naturellement, nous ne nous attendons pas √† ce que les participants le fassent eux-m√™mes, nous devons automatiser le processus. <br><br>  Nous voulions √©viter les frais g√©n√©raux pour les outils d'ex√©cution lorsque vous travaillez sur notre serveur, et donc quelque chose comme un outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PIN</a> ne convient pas √† nos fins.  Au lieu de cela, nous avons d√©cid√© d'instruire directement le code des participants afin de compter le nombre d'instructions qui seraient ex√©cut√©es.  Au lieu d'instrumenter les binaires (code machine), nous avons d√©cid√© d'utiliser Clang pour compiler le code et le bytecode LLVM de l'instrument. <br><br>  Si vous d√©butez avec LLVM, il s'agit d'une collection de compilateurs modulaires et r√©utilisables et de technologies de cha√Æne d'outils.  L'un des principaux projets est LLVM IR et backend.  En termes simples, une repr√©sentation interm√©diaire a √©t√© d√©velopp√©e dans laquelle un front-end de compilation compile du code.  Ce code, LLVM IR, est ensuite compil√© en code machine par le backend LLVM.  Ainsi, si vous cr√©ez un nouveau langage, vous pouvez d√©cider d'autoriser LLVM √† prendre en charge la g√©n√©ration et l'optimisation de code machine et √† √©crire un frontend pour convertir votre langage en LLVM IR. <br><br><img src="https://habrastorage.org/webt/ag/ud/pm/agudpmnchiuciou-p29zk8z5nzo.png"><br>  <i>Clang convertit le code C ++ en LLVM IR, qui est ensuite converti en code machine par le backend LLVM.</i> <br><br>  Clang est l'interface de LLVM.  Comme nous avons besoin d'une m√©thode multiplateforme pour mesurer le code, nous ne pouvons pas instrumenter de code binaire.  LLVM IR, cependant, est ind√©pendant de la plate-forme, car il ne s'agit que d'une repr√©sentation interm√©diaire du code.  L'instrumentation du code IR avec les biblioth√®ques LLVM est une solution multiplateforme simple. <br><br><h3>  Solution </h3><br>  Un simple compte d'instructions LLVM IR n'est √©videmment pas appropri√©, car nous avons besoin du nombre d'instructions qui seront r√©ellement ex√©cut√©es, et pas seulement du nombre d'instructions dans le code.  Au final, nous avons d√©velopp√© un algorithme simple bas√© sur le concept de blocs de code de base. <br><br>  Une unit√© de base est un ensemble d'instructions dans lequel seule la premi√®re instruction peut √™tre le point d'entr√©e et seule la derni√®re instruction peut √™tre le point de sortie.  ( <i>Toutes les transitions √† l'int√©rieur du bloc de base sont √©galement interdites - environ la traduction</i> ) <i>.</i> Pour comprendre cela, essayez de diviser le code en morceaux dans lesquels les instructions de branche (transitions, boucles et retours) ne peuvent √™tre que les derni√®res de l'ensemble et l'entr√©e dans le bloc (premi√®re instruction dans fonction, boucle ou bloc if / else) n'est possible que sur la premi√®re instruction.  Le r√©sultat est un ensemble de blocs de base - des blocs de code s√©quentiel qui s'ex√©cutent simplement s√©quentiellement, sans d√©cider quelle instruction ex√©cuter ensuite. <br><br>  Pourquoi ne l'essayons-nous pas maintenant?  Voici un extrait de code fourni par un contributeur de caract√®res de code: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the soldiers who aren't patrolling attack the enemy for (int i = NUM_SOLDIERS / 2; i &lt; NUM_SOLDIERS; ++i) { auto &amp;soldier = state.soldiers[i]; if (soldier.hp == 0) // If this soldier is dead, skip it continue; for (auto enemy_soldier : state.enemy_soldiers) { if (enemy_soldier.hp != 0) { // Ensure your prospective target has // not already been slain soldier.soldier_target = enemy_soldier.id; break; } } }</span></span></code> </pre> <br>  Lien Github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://gist.github.com/JHurricane96/8c9c3a45ec5e969de4d9fecb47ebef69#file-player_code-cpp</a> <br><br>  En utilisant le fait que l'unit√© de base n'a qu'un seul point d'entr√©e (la premi√®re instruction), nous pouvons diviser ce fragment en les unit√©s de base suivantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-------------------------------- BB 1 ---------------------------------- for (int i = NUM_SOLDIERS / 2; i &lt; NUM_SOLDIERS; ++i) { //-------------------------------- BB 2 ---------------------------------- auto &amp;soldier = state.soldiers[i]; if (soldier.hp == 0) //-------------------------------- BB 3 ---------------------------------- continue; //-------------------------------- BB 4 ---------------------------------- for (auto enemy_soldier : state.enemy_soldiers) { //-------------------------------- BB 5 ---------------------------------- if (enemy_soldier.hp != 0) { //-------------------------------- BB 6 ---------------------------------- soldier.soldier_target = enemy_soldier.id; break; //-------------------------------- BB 7 ---------------------------------- } } }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien Github</a> <br>  Cela nous a aid√©s √† comprendre le fonctionnement des blocs de base, regardons maintenant cet algorithme dans LLVM IR: <br><br><pre> <code class="cpp hljs">; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">140</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">181</span></span>, %<span class="hljs-number"><span class="hljs-number">139</span></span> %<span class="hljs-number"><span class="hljs-number">141</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">142</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">141</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">143</span></span> = icmp slt i64 %<span class="hljs-number"><span class="hljs-number">142</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> br i1 %<span class="hljs-number"><span class="hljs-number">143</span></span>, label %<span class="hljs-number"><span class="hljs-number">144</span></span>, label %<span class="hljs-number"><span class="hljs-number">184</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">144</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">140</span></span> %<span class="hljs-number"><span class="hljs-number">145</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">146</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">147</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">146</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">148</span></span> = call dereferenceable(<span class="hljs-number"><span class="hljs-number">72</span></span>) %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* @_ZNSt5arrayIN12player_state7SoldierELm20EEixEm( %<span class="hljs-string"><span class="hljs-string">"struct.std::array.10"</span></span>* %<span class="hljs-number"><span class="hljs-number">145</span></span>, i64 %<span class="hljs-number"><span class="hljs-number">147</span></span>) #<span class="hljs-number"><span class="hljs-number">3</span></span> store %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">148</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">149</span></span> = load %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>*, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">150</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">149</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">151</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">150</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">152</span></span> = icmp eq i64 %<span class="hljs-number"><span class="hljs-number">151</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> br i1 %<span class="hljs-number"><span class="hljs-number">152</span></span>, label %<span class="hljs-number"><span class="hljs-number">153</span></span>, label %<span class="hljs-number"><span class="hljs-number">154</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">153</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">144</span></span> br label %<span class="hljs-number"><span class="hljs-number">181</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien Github</a> <br><br>  Si vous regardez attentivement, vous remarquerez que le fragment de code ci-dessus est les trois premiers blocs du fragment de code C ++ compil√© dans LLVM IR (chaque ligne est le d√©but du bloc de base). <br><br>  LLVM poss√®de des biblioth√®ques qui nous permettent d'√©crire des ¬´passes¬ª - du code qui peut transformer LLVM IR.  L'API LLVM nous permet de lire et d'analyser facilement LLVM IR en parcourant les modules, les fonctions et les blocs de base, et de modifier LLVM IR avant de le compiler en code machine. <br><br>  Maintenant que nous avons les blocs de base et l'API LLVM, il devient simple de calculer le nombre d'instructions √† ex√©cuter √† l'aide d'un algorithme aussi simple: <br><br><ol><li>  Nous √©crivons la fonction IncrementCount, qui prend un entier et incr√©mente un entier statique avec cette valeur, chaque fois qu'elle est appel√©e.  Il doit √™tre li√© au code membre. </li><li>  Nous faisons des it√©rations sur tous les blocs de base.  Pour chaque unit√© de base, effectuez les √©tapes 3 et 4. </li><li>  Nous trouvons n - le nombre d'instructions dans cette unit√© de base. </li><li>  Nous ins√©rons l'appel √† la fonction IncrementCount avant la derni√®re instruction de l'unit√© de base, avec l'argument n. </li><li>  L'entier statique avec lequel IncrementCount fonctionne sera le compteur d'instructions apr√®s l'ex√©cution du code.  Il peut √™tre enregistr√© quelque part puis v√©rifi√©. </li></ol><br>  Notre IR instrument√© fonctionne comme ceci: <br><br><pre> <code class="cpp hljs">; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">140</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">181</span></span>, %<span class="hljs-number"><span class="hljs-number">139</span></span> %<span class="hljs-number"><span class="hljs-number">141</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">142</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">141</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">143</span></span> = icmp slt i64 %<span class="hljs-number"><span class="hljs-number">142</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">4</span></span>) br i1 %<span class="hljs-number"><span class="hljs-number">143</span></span>, label %<span class="hljs-number"><span class="hljs-number">144</span></span>, label %<span class="hljs-number"><span class="hljs-number">184</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">144</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">140</span></span> %<span class="hljs-number"><span class="hljs-number">145</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::State"</span></span>* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">146</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">19</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">147</span></span> = sext i32 %<span class="hljs-number"><span class="hljs-number">146</span></span> to i64 %<span class="hljs-number"><span class="hljs-number">148</span></span> = call dereferenceable(<span class="hljs-number"><span class="hljs-number">72</span></span>) %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* @_ZNSt5arrayIN12player_state7SoldierELm20EEixEm( %<span class="hljs-string"><span class="hljs-string">"struct.std::array.10"</span></span>* %<span class="hljs-number"><span class="hljs-number">145</span></span>, i64 %<span class="hljs-number"><span class="hljs-number">147</span></span>) #<span class="hljs-number"><span class="hljs-number">3</span></span> store %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">148</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">149</span></span> = load %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>*, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>** %<span class="hljs-number"><span class="hljs-number">20</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">150</span></span> = getelementptr inbounds %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>, %<span class="hljs-string"><span class="hljs-string">"struct.player_state::Soldier"</span></span>* %<span class="hljs-number"><span class="hljs-number">149</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">151</span></span> = load i64, i64* %<span class="hljs-number"><span class="hljs-number">150</span></span>, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">152</span></span> = icmp eq i64 %<span class="hljs-number"><span class="hljs-number">151</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">10</span></span>) br i1 %<span class="hljs-number"><span class="hljs-number">152</span></span>, label %<span class="hljs-number"><span class="hljs-number">153</span></span>, label %<span class="hljs-number"><span class="hljs-number">154</span></span> ; &lt;label&gt;:<span class="hljs-number"><span class="hljs-number">153</span></span>: ; preds = %<span class="hljs-number"><span class="hljs-number">144</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @_Z14IncrementCountm(i32 <span class="hljs-number"><span class="hljs-number">1</span></span>) br label %<span class="hljs-number"><span class="hljs-number">181</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien Github</a> <br><br>  Comme nous pouvons le voir, un appel IncrementCount est effectu√© √† la fin de chaque bloc de base, juste avant la derni√®re instruction.  En utilisant l'int. Statique avec lequel IncrementCount fonctionne, nous pouvons obtenir le nombre d'instructions √† la fin du d√©placement de chaque participant.  Cette m√©thode est d√©terministe et multiplateforme, comme  le m√™me code source est garanti pour g√©n√©rer le m√™me IR LLVM si nous utilisons la m√™me version du compilateur et les m√™mes drapeaux. <br><br><h3>  Conclusion </h3><br>  Le profilage de code n'est pas une chose aussi simple que je le pensais.  Dans le processus de travail sur une t√¢che relativement simple, je me suis familiaris√© avec le fonctionnement du compilateur et comment √©crire des passes LLVM.  Si vous √™tes int√©ress√© √† g√©n√©rer du code et que vous souhaitez √©crire vos propres passages, LLVM a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide pour d√©butants</a> .  il y a aussi un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de</a> blog que j'ai utilis√© pour √©crire mon propre passage.  √âtant donn√© que l'API LLVM n'est pas r√©trocompatible entre les principales versions, faites attention √† la version de LLVM que vous utilisez. <br><br>  Vous pouvez obtenir le code source du pass <a href="">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417029/">https://habr.com/ru/post/fr417029/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417013/index.html">Les ¬´dunes de sable¬ª de Pluton ne sont pas faites de sable - ce sont des granules de m√©thane gel√©</a></li>
<li><a href="../fr417015/index.html">Nous comprenons ce qui enregistre et ce qui n'enregistre pas l'application Burger King</a></li>
<li><a href="../fr417017/index.html">Comment une exp√©rience nucl√©aire rat√©e a g√©n√©r√© accidentellement l'astronomie des neutrinos</a></li>
<li><a href="../fr417023/index.html">Exp√©rience du Groupe Rambler: comment nous avons commenc√© √† contr√¥ler compl√®tement la formation et le comportement des composants frontaux React</a></li>
<li><a href="../fr417027/index.html">Comment ai-je √©crit la biblioth√®que C ++ 11 standard ou pourquoi boost est si effrayant. Pr√©sentation</a></li>
<li><a href="../fr417031/index.html">S√©curit√© Mobile OAuth 2.0</a></li>
<li><a href="../fr417033/index.html">QIWI Kitchen le 7 juin - vid√©o des discours de nos intervenants</a></li>
<li><a href="../fr417035/index.html">UnnyWorld: post-mortem</a></li>
<li><a href="../fr417037/index.html">BEERBRAZZERS. Contr√¥le de la lumi√®re. Vixen Lights 3. D√©marrage rapide (1/4)</a></li>
<li><a href="../fr417039/index.html">Apprenez wordpress (et plus) pour rendre les joueurs Youtube rapidement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>