<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🔬 👰 🧛🏼 Kubernetes RBAC Benutzer und Autorisierung 🤘 💔 👩‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Wir setzen das kürzlich angesprochene Thema Kubernetes Sicherheit im Allgemeinen und RBAC im Besonderen fort und veröffentlichen eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes RBAC Benutzer und Autorisierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/470503/">  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Wir setzen das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kürzlich angesprochene</a> Thema Kubernetes Sicherheit im Allgemeinen und RBAC im Besonderen fort und veröffentlichen eine Übersetzung dieses Materials von einem französischen Berater des internationalen Unternehmens Adaltas Big Data.</i>  <i>Der Autor zeigt im Detail, wie Benutzer erstellt, ihnen Rechte erteilt und weiterhin bereitgestellt werden.</i> <br><br>  Das Einrichten und Starten eines Kubernetes-Clusters ist nur der Anfang: Es muss ebenfalls ausgenutzt werden.  Um den Zugriff auf den Cluster zu sichern, müssen Sie Benutzeranmeldeinformationen festlegen und die Authentifizierungs- und Autorisierungseinstellungen korrekt verwalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m5/y9/az/m5y9azz-gbidcxue2_eesz-gvxo.png"></div>  <i>(Abbildung aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem CNCF-Blog</a> - ca. übersetzt.)</i> <br><br>  In diesem Artikel wird beschrieben, wie Sie Benutzer mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">X.509-</a> Clientzertifikaten erstellen und die Autorisierung mithilfe der grundlegenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC-</a> APIs in Kubernetes verwalten.  Wir werden auch über einige Open-Source-Projekte sprechen, die die Clusterverwaltung vereinfachen: rakkess, kubectl-who-can, rbac-lookup und RBAC Manager. <a name="habracut"></a><br><h2>  Voraussetzungen und Annahmen </h2><br>  Zunächst müssen mehrere Annahmen getroffen werden: <br><br><ul><li>  Zumindest können Sie sich vorstellen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Kubernetes funktioniert</a> . </li><li>  Sie haben einen funktionierenden Kubernetes- oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minikube-Cluster</a> . </li><li>  Sie haben das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstprogramm kubectl CLI installiert</a> . </li><li>  Sie haben das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSSL-</a> Paket installiert. </li></ul><cut></cut><br>  Wenn Sie keinen vorgefertigten Kubernetes-Cluster haben, empfehlen wir Ihnen, auf den Artikel eines Kollegen (Arthur BUSSER) zu verweisen, in dem er über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installation von Kubernetes unter CentOS 7</a> mit Vagrant spricht. <br><br>  Es gibt 4 Knoten in unserem Cluster: einen Master und 3 Worker.  Der Assistent wird auch als Randknoten für die Interaktion mit dem Cluster verwendet. <br><br><h2>  RBAC-APIs </h2><br>  Die rollenbasierte Zugriffssteuerung (RBAC) ist eine Methode zur Steuerung des Zugriffs auf Computer und Netzwerkressourcen, basierend auf den Rollen einzelner Benutzer in einem Unternehmen.  RBAC kann mit allen Kubernetes-Ressourcen verwendet werden, die CRUD unterstützen (Erstellen, Lesen, Aktualisieren, Löschen).  Beispiele für solche Ressourcen: <br><br><ul><li>  Namespaces </li><li>  Pods </li><li>  Bereitstellungen </li><li>  persistente Volumes (PersistentVolumes); </li><li>  ConfigMaps </li></ul><br>  Und hier sind Beispiele für mögliche Operationen mit ihnen: <br><br><ul><li>  <code>create</code> ; </li><li>  <code>get</code> </li><li>  <code>delete</code> <i>(löschen)</i> ; </li><li>  <code>list</code> <i>(Listenansicht)</i> ; </li><li>  <code>update</code> . </li></ul><br>  Um RBAC in Kubernetes zu verwalten, müssen wir Folgendes deklarieren: <br><br><ul><li>  <b><code>Role</code> und <code>ClusterRole</code></b> .  Dies sind einfach Regelsätze, die eine Reihe von Berechtigungen darstellen.  <code>Role</code> kann nur verwendet werden, um den Zugriff auf Ressourcen in Namespaces zu ermöglichen.  <code>ClusterRole</code> kann dieselben Berechtigungen wie <code>Role</code> bereitstellen und auch Zugriff auf Ressourcen gewähren, die im gesamten Cluster verfügbar sind, sowie auf sogenannte Nicht-Ressourcen-Endpunkte <i>(wie <code>/healthz</code> - ca. Transl.)</i> . </li><li>  <b><code>Subjects</code></b>  Der Betreff ist eine Entität, die Operationen in einem Cluster ausführt.  Dies können Benutzer, Dienste oder sogar Gruppen sein. </li><li>  <b><code>RoleBinding</code> und <code>ClusterRoleBinding</code></b> .  Wie der Name schon sagt, handelt es sich lediglich um eine Bindung des Betreffs an Role oder ClusterRole. </li></ul><br>  Kubernetes hat die folgenden Standardrollen: <br><br><ul><li>  <code>view</code> : Nur-Lese-Zugriff, schließt Geheimnisse aus; </li><li>  <code>edit</code> : Das oben Genannte + die Fähigkeit, die meisten Ressourcen zu bearbeiten, schließt Rollen und Rollenbindungen aus. </li><li>  <code>admin</code> : die oben genannten + die Fähigkeit, Rollen und Rollenzuordnungen auf Namespace-Ebene zu verwalten; </li><li>  <code>cluster-admin</code> : Alle möglichen Berechtigungen. </li></ul><br>  Natürlich können Sie Ihre eigenen <code>Roles</code> und <code>ClusterRoles</code> erstellen. Wir empfehlen jedoch, die Standardrollen so weit wie möglich zu verwenden, sofern die Situation dies zulässt.  Andernfalls können Sie schnell verwirrt werden. <br><br><h2>  Anwendungsbeispiel </h2><br>  Wir werden zwei Namespaces erstellen: <code>my-project-dev</code> und <code>my-project-prod</code> sowie zwei Benutzer: <code>jean</code> und <code>sarah</code> - mit unterschiedlichen Rollen in diesen Namespaces: <br><br><ul><li>  my-project-dev: <br><ul><li>  Jean: Bearbeiten </li></ul></li><li>  my-project-prod: <br><ul><li>  Jean: Ansicht </li><li>  sarah: bearbeiten </li></ul></li></ul><br><h3>  Erstellen und authentifizieren Sie Benutzer mithilfe von X.509-Clientzertifikaten </h3><br>  In der Regel gibt es zwei Arten von Benutzern: von Kubernetes verwaltete Dienstkonten und reguläre Benutzer.  Wir werden uns auf Letzteres konzentrieren.  So werden sie in der offiziellen Dokumentation beschrieben: <br><br><blockquote>  Es wird davon ausgegangen, dass reguläre Benutzer von einem externen, unabhängigen Dienst verwaltet werden.  Die Rolle kann von einem Administrator gespielt werden, der private Schlüssel verteilt, von einem Benutzer-Repository wie Keystone oder Google Accounts oder sogar von einer Datei mit einer Liste von Benutzernamen und Kennwörtern.  In dieser Hinsicht hat Kubernetes keine Objekte, die normale Benutzer darstellen.  Normale Benutzer können nicht über einen API-Aufruf zum Cluster hinzugefügt werden. </blockquote><br>  Es gibt verschiedene Möglichkeiten, reguläre Benutzer zu verwalten: <br><br><ul><li>  Grundlegende <i>Authentifizierung</i> : <ul><li>  Übertragen der Konfiguration auf den API-Server mit den folgenden (oder ähnlichen) Inhalten: Kennwort, Benutzername, UID, Gruppe; </li></ul></li><li>  X.509 Client-Zertifikat: <ul><li>  Erstellung eines geheimen Schlüssels und einer Zertifikatsignierungsanforderung eines Benutzers; </li><li>  Zertifizierung in einer Zertifizierungsstelle (Kubernetes CA), um ein Benutzerzertifikat zu erhalten; </li></ul></li><li>  Inhaber-Token (JSON Web Tokens, JWT): <ul><li>  OpenID Connect </li><li>  Authentifizierungsschicht über OAuth 2.0; </li><li>  Webhooks </li></ul></li></ul><br>  In diesem Artikel werden X.509- und OpenSSL-Zertifikate aufgrund ihrer Einfachheit verwendet.  Das Erstellen von Benutzern erfolgt in mehreren Schritten - wir werden sie alle durchgehen.  Vorgänge sollten unter dem Benutzerkonto mit Administratorrechten des Clusters (Cluster-Administrator) ausgeführt werden.  Hier sind alle Schritte zum Erstellen eines Benutzers (am Beispiel von <code>jean</code> ): <br><br><ul><li>  Erstellen Sie im Assistenten einen Benutzer, und wechseln Sie in sein Ausgangsverzeichnis, um die verbleibenden Schritte auszuführen: <br><br><pre> <code class="bash hljs">useradd jean &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /home/jean</code> </pre> </li><li>  Erstellen Sie einen privaten Schlüssel: <br><br><pre> <code class="bash hljs">openssl genrsa -out jean.key 2048</code> </pre> </li><li>  Erstellen Sie eine Zertifikatsignierungsanforderung (CSR).  <code>CN</code> ist der Benutzername, <code>O</code> ist die Gruppe.  Sie können Berechtigungen nach Gruppe festlegen.  Dies vereinfacht die Arbeit, wenn Sie beispielsweise viele Benutzer mit denselben Berechtigungen haben: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   openssl req -new -key jean.key \ -out jean.csr \ -subj "/CN=jean" #     $group openssl req -new -key jean.key \ -out jean.csr \ -subj "/CN=jean/O=$group" #       openssl req -new -key jean.key \ -out jean.csr \ -subj "/CN=jean/O=$group1/O=$group2/O=$group3"</span></span></code> </pre> </li><li>  Unterzeichnen Sie CSR in Kubernetes CA.  Wir müssen das CA-Zertifikat und den CA-Schlüssel verwenden, die normalerweise in <code>/etc/kubernetes/pki</code> .  Das Zertifikat ist 500 Tage gültig: <br><br><pre> <code class="bash hljs">openssl x509 -req -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> jean.csr \ -CA /etc/kubernetes/pki/ca.crt \ -CAkey /etc/kubernetes/pki/ca.key \ -CAcreateserial \ -out jean.crt -days 500</code> </pre> </li><li>  Erstellen Sie das Verzeichnis <code>.certs</code> .  Darin speichern wir die öffentlichen und privaten Schlüssel des Benutzers: <br><br><pre> <code class="bash hljs">mkdir .certs &amp;&amp; mv jean.crt jean.key .certs</code> </pre> </li><li>  Erstellen Sie einen Benutzer in Kubernetes: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-credentials jean \ --client-certificate=/home/jean/.certs/jean.crt \ --client-key=/home/jean/.certs/jean.key</code> </pre> </li><li>  Kontext für Benutzer festlegen: <br><br><pre> <code class="bash hljs">kubectl config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-context jean-context \ --cluster=kubernetes --user=jean</code> </pre> </li><li>  Bearbeiten Sie die Benutzerkonfigurationsdatei.  Es enthält die für die Authentifizierung in einem Cluster erforderlichen Informationen.  Sie können die Cluster-Konfigurationsdatei verwenden, die normalerweise in <code>/etc/kubernetes</code> : Die <code>certificate-authority-data</code> und <code>server</code> sollten mit denen in der genannten Datei identisch sein: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 clusters: - cluster: certificate-authority-data: {  } server: {  } name: kubernetes contexts: - context: cluster: kubernetes user: jean name: jean-context current-context: jean-context kind: Config preferences: {} users: - name: jean user: client-certificate: /home/jean/.certs/jean.cert client-key: /home/jean/.certs/jean.key</code> </pre> <br>  Jetzt müssen Sie die obige Konfiguration in das <code>.kube</code> Verzeichnis <code>.kube</code> : <br><br><pre> <code class="bash hljs">mkdir .kube &amp;&amp; vi .kube/config</code> </pre> </li><li>  Es bleibt, den Benutzer zum Eigentümer aller erstellten Dateien und Verzeichnisse zu machen: <br><br><pre> <code class="bash hljs">chown -R jean: /home/jean/</code> </pre> </li></ul><br>  User <code>jean</code> erfolgreich erstellt.  Wir werden das Gleiche für <code>sarah</code> tun.  Es gibt einige Schritte, und das Erstellen einer großen Anzahl von Benutzern kann lange dauern.  Deshalb habe ich Bash-Skripte geschrieben, die den Prozess automatisieren: Sie befinden sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository auf GitHub</a> . <br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Wie wir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem kürzlich erschienenen Artikel geschrieben haben</a> , kann dieses Verfahren für Kubernetes auf eine „native“ Weise vereinfacht werden - durch neue Funktionen im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstprogramm kubeadm console</a> .</i>  <i>Beachten Sie jedoch, dass diese zum Zeitpunkt der Veröffentlichung dieser Übersetzung in Alpha-Form verfügbar sind.</i>  <i>Ein Beispiel für einen Befehl zum Erstellen eines Benutzers ist <code>kubeadm alpha kubeconfig user</code> .</i> <br><br>  Wir haben jetzt Benutzer und können zwei Namespaces erstellen: <br><br><pre> <code class="bash hljs">kubectl create namespace my-project-dev kubectl create namespace my-project-prod</code> </pre> <br>  Da wir die Benutzerberechtigung noch nicht festgelegt haben, sollten sie keinen Zugriff auf Clusterressourcen haben: <br><br><pre> <code class="bash hljs">User: Jean kubectl get nodes Error from server (Forbidden): nodes is forbidden: User <span class="hljs-string"><span class="hljs-string">"jean"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"nodes"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> at the cluster scope kubectl get pods -n default Error from server (Forbidden): pods is forbidden: User <span class="hljs-string"><span class="hljs-string">"jean"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"pods"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"default"</span></span> kubectl get pods -n my-project-prod Error from server (Forbidden): pods is forbidden: User <span class="hljs-string"><span class="hljs-string">"jean"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"pods"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"my-project-prod"</span></span> kubectl get pods -n my-project-dev Error from server (Forbidden): pods is forbidden: User <span class="hljs-string"><span class="hljs-string">"jean"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"pods"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"my-project-dev"</span></span></code> </pre> <br><pre> <code class="bash hljs">User: Sarah kubectl get nodes Error from server (Forbidden): nodes is forbidden: User <span class="hljs-string"><span class="hljs-string">"sarah"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"nodes"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> at the cluster scope kubectl get pods -n default Error from server (Forbidden): pods is forbidden: User <span class="hljs-string"><span class="hljs-string">"sarah"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"pods"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"default"</span></span> kubectl get pods -n my-project-prod Error from server (Forbidden): pods is forbidden: User <span class="hljs-string"><span class="hljs-string">"sarah"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"pods"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"my-project-prod"</span></span> kubectl get pods -n my-project-dev Error from server (Forbidden): pods is forbidden: User <span class="hljs-string"><span class="hljs-string">"sarah"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"pods"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"my-project-dev"</span></span></code> </pre> <br><h3>  Erstellung von Rolle und ClusterRole </h3><br>  Wir werden <code>ClusterRole</code> , das standardmäßig verfügbar ist.  Wir zeigen jedoch auch, wie Sie Ihre eigene <code>Role</code> und <code>ClusterRole</code> .  Im Wesentlichen sind <code>Role</code> und <code>ClusterRole</code> nur eine Reihe von Aktionen <i>( <code>verbs</code> ,</i> <code>ClusterRole</code> <i>wörtlich - Verben)</i> , die für bestimmte Ressourcen und Namespaces zulässig sind.  Hier ist eine Beispiel-YAML-Datei: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1beta1 kind: Role metadata: name: list-deployments namespace: my-project-dev rules: - apiGroups: [ apps ] resources: [ deployments ] verbs: [ get, list ] --------------------------------- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRole metadata: name: list-deployments rules: - apiGroups: [ apps ] resources: [ deployments ] verbs: [ get, list ]</code> </pre> <br>  Führen Sie den folgenden Befehl aus, um sie zu erstellen: <br><br><pre> <code class="bash hljs">kubectl create -f /path/to/your/yaml/file</code> </pre> <br><h3>  Bindungsrolle oder Clusterrolle an Benutzer </h3><br>  Binden Sie nun die Standard- <code>ClusterRole</code> ( <code>edit</code> und <code>view</code> ) wie folgt an unsere Benutzer: <br><br><ul><li>  <code>jean</code> : <ul><li>  <code>edit</code> - im Namespace <code>my-project-dev</code> ; </li><li>  <code>view</code> - im Namespace <code>my-project-prod</code> ; </li></ul></li><li>  <code>sarah</code> : <ul><li>  <code>edit</code> - im Namespace <code>my-project-prod</code> . </li></ul></li></ul><br>  RoleBindings müssen durch Namespaces angegeben werden, nicht durch Benutzer.  Mit anderen Worten, um Jean zu autorisieren, erstellen wir zwei RoleBindings.  Ein Beispiel für eine YAML-Datei, die RoleBindings für Jean definiert: <br><br><pre> <code class="plaintext hljs">apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: jean namespace: my-project-dev subjects: - kind: User name: jean apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: edit apiGroup: rbac.authorization.k8s.io --------------------------------- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: jean namespace: my-project-prod subjects: - kind: User name: jean apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: view apiGroup: rbac.authorization.k8s.io</code> </pre> <br>  Wir erlauben <code>jean</code> , <code>my-project-prod</code> <code>view</code> und <code>my-project-dev</code> bearbeiten.  Das gleiche muss mit Berechtigungen für <code>sarah</code> .  Führen Sie den folgenden Befehl aus, um sie zu aktivieren: <br><br><pre> <code class="bash hljs">kubectl apply -f /path/to/your/yaml/file</code> </pre> <br>  In diesem Fall wurde <code>kubectl apply</code> anstelle von <code>kubectl create</code> .  Der Unterschied zwischen den beiden besteht darin, dass <code>create</code> das Objekt erstellt und nichts anderes tut und <code>apply</code> - erstellt nicht nur das Objekt (falls es nicht vorhanden ist), sondern aktualisiert es bei Bedarf auch. <br><br>  Lassen Sie uns überprüfen, ob unsere Benutzer die erforderlichen Berechtigungen erhalten haben. <br><br><ul><li>  Benutzer: <code>sarah</code> (in <code>my-project-prod</code> <code>edit</code> ) <ul><li> <code>my-project-prod</code> <ul> <li>  kann Pods (1) auflisten; </li><li>  kann Bereitstellungen erstellen (2). </li></ul></li><li> <code>my-project-dev</code> <ul> <li>  Pods (4) können nicht aufgelistet werden; </li><li>  Bereitstellungen können nicht erstellt werden (5). </li></ul></li></ul></li></ul><br><pre> <code class="bash hljs">(1) kubectl get pods -n my-project-prod No resources found. (2) kubectl run nginx --image=nginx --replicas=1 -n my-project-prod deployment.apps/nginx created (3) kubectl get pods -n my-project-prod NAME READY STATUS RESTARTS AGE nginx-7db9fccd9b-t14qw 1/1 Running 0 4s (4) kubectl get pods -n my-project-dev Error from server (Forbidden): pods is forbidden: User <span class="hljs-string"><span class="hljs-string">"sarah"</span></span> cannot list resource <span class="hljs-string"><span class="hljs-string">"pods"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"my-project-dev"</span></span> (5) kubectl run nginx --image=nginx --replicas=1 -n my-project-dev Error from server (Forbidden): deployments.apps is forbidden: User <span class="hljs-string"><span class="hljs-string">"sarah"</span></span> cannot create resource <span class="hljs-string"><span class="hljs-string">"deployments"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">"apps"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"my-project-dev"</span></span></code> </pre> <br><ul><li>  Benutzer: <code>jean</code> (in <code>my-project-prod</code> <code>view</code> und in <code>my-project-dev</code> <code>edit</code> ) <ul><li> <code>my-project-prod</code> <ul> <li>  kann Pods (1) auflisten; </li><li>  kann Deployment'ov (2) auflisten; </li><li>  Bereitstellungen können nicht gelöscht werden (3). </li></ul></li><li>  my-project-dev: <ul><li>  kann Pods auflisten (4); </li><li>  kann Bereitstellungen erstellen (5); </li><li>  kann Deployment'ov (6) auflisten; </li><li>  kann Bereitstellungen entfernen (7). </li></ul></li></ul></li></ul><br><pre> <code class="bash hljs">(1) kubectl get pods -n my-project-prod NAME READY STATUS RESTARTS AGE nginx-7db9fccd9b-t14qw 1/1 Running 0 101s (2) kubectl get deploy -n my-project-prod NAME READY UP-TO-DATE AVAILABLE AGE nginx 1/1 1 1 110s (3) kubectl delete deploy/nginx -n my-project-prod Error from server (Forbidden): deployments.extensions <span class="hljs-string"><span class="hljs-string">"nginx"</span></span> is forbidden: User <span class="hljs-string"><span class="hljs-string">"jean"</span></span> cannot delete resource <span class="hljs-string"><span class="hljs-string">"deployments"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> API group <span class="hljs-string"><span class="hljs-string">"extensions"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the namespace <span class="hljs-string"><span class="hljs-string">"my-project-prod"</span></span> (4) kubectl get pods -n my-project-dev No resources found. (5) kubectl run nginx --image=nginx --replicas=1 -n my-project-dev deployment.apps/nginx created (6) kubectl get deploy -n my-project-dev NAME READY UP-TO-DATE AVAILABLE AGE nginx 0/1 1 0 13s (7) kubectl delete deploy/nginx -n my-project-dev deployment.extensions <span class="hljs-string"><span class="hljs-string">"nginx"</span></span> deleted (8) kubectl get deploy -n my-project-dev No resources found.</code> </pre> <br><h2>  Benutzerverwaltung und Autorisierung </h2><br>  Daher haben wir erfolgreich verschiedene Rollen und Benutzerberechtigungen festgelegt.  Es stellt sich die Frage: Wie geht das jetzt?  Woher weiß ich, ob die Berechtigungen für einen bestimmten Benutzer richtig eingestellt sind?  Woher weiß ich, wer befugt ist, eine bestimmte Aktion auszuführen?  Wie bekomme ich ein allgemeines Bild der Benutzerberechtigungen? <br><br>  Wir brauchen Antworten auf all diese Fragen, um die Cluster-Sicherheit zu gewährleisten.  Mit dem <code>kubectl auth can-i</code> können Sie herausfinden, ob ein Benutzer eine bestimmte Aktion ausführen kann: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># kubectl auth can-i $action $resource --as $subject (1) kubectl auth can-i list pods (2) kubectl auth can-i list pods --as jean</span></span></code> </pre> <br>  Mit dem ersten Befehl (1) kann der Benutzer herausfinden, ob er eine Aktion ausführen kann.  Die zweite (2) - ermöglicht es dem Administrator, sich als Benutzer auszugeben, um herauszufinden, ob er eine bestimmte Aktion ausführen kann.  Diese "Reinkarnation" ist nur für Benutzer mit Cluster-Administratorrechten zulässig. <br><br>  Dies ist praktisch alles, was mit dem integrierten Toolkit möglich ist.  Aus diesem Grund werde ich einige Open Source-Projekte vorstellen, die die Funktionen des kubectl auth can-i-Teams erweitern.  Bevor wir sie einführen, legen wir die Abhängigkeiten fest: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Krew</a> . <br><br><h2>  Gehen Sie zur Installation </h2><br>  Go ist eine Open Source-Programmiersprache, mit der Sie einfache, zuverlässige und effiziente Software erstellen können.  Es wurde von Google unter der Inspiration von C und Pascal entwickelt, basierend auf den ursprünglichen Konzepten von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Robert Griesemer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rob Pike</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ken Thompson</a> . <br><br><pre> <code class="bash hljs">wget https://dl.google.com/go/go1.12.5.linux-amd64.tar.gz sudo tar -C /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span> -xzf go1.12.5.linux-amd64.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=<span class="hljs-variable"><span class="hljs-variable">$PATH</span></span>:/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/go/bin</code> </pre> <br><h2>  Krew Installation </h2><br>  Krew ist ein Tool, das die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubectl-Plugins</a> vereinfacht.  Krew hilft Ihnen beim Suchen, Installieren und Verwalten von Plugins.  In Bezug auf Funktionen ähnelt es Werkzeugen wie apt, dnf oder Brew.  Krew ist nur mit kubectl Version 1.12 und höher kompatibel. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -x; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -d)</span></span></span><span class="hljs-string">"</span></span> &amp;&amp; curl -fsSLO <span class="hljs-string"><span class="hljs-string">"https://storage.googleapis.com/krew/v0.2.1/krew.{tar.gz,yaml}"</span></span> &amp;&amp; tar zxvf krew.tar.gz &amp;&amp; ./krew-<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(uname | tr '[:upper:]' '[:lower:]')</span></span></span><span class="hljs-string">_amd64"</span></span> install \ --manifest=krew.yaml --archive=krew.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KREW_ROOT:-$HOME/.krew}</span></span></span><span class="hljs-string">/bin:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PATH</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br><h2>  Rakkess </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In diesem Projekt</a> können Sie alle Berechtigungen anzeigen, die dem Benutzer erteilt wurden.  Zum Beispiel hilft es bei der Beantwortung der Frage, was <code>jean</code> tun kann.  Lassen Sie es uns zunächst installieren: <br><br><pre> <code class="bash hljs">kubectl krew install access-matrix</code> </pre> <br>  Die Projektdokumentation finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository auf GitHub</a> .  Hier ist ein Beispiel seiner Arbeit: <br><br><pre> <code class="bash hljs">kubectl access-matrix -n my-project-dev --as jean</code> </pre> <br><img src="https://habrastorage.org/webt/0g/sq/b6/0gsqb6cw-paqkn6yxbuozzccgpq.png"><br><br><h2>  kubect-who-can </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit diesem Projekt</a> können wir herausfinden, welche Benutzer eine bestimmte Aktion ausführen können.  Es hilft, die Frage zu beantworten: "Wer kann das?"  Installation: <br><br><pre> <code class="bash hljs">go get -v github.com/aquasecurity/kubectl-who-can</code> </pre> <br>  Die Dokumentation befindet sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Repository</a> .  Arbeitsbeispiel: <br><br><pre> <code class="bash hljs">kubectl-who-can list pods -n default No subjects found with permissions to list pods assigned through RoleBindings CLUSTERROLEBINDING SUBJECT TYPE SA-NAMESPACE cluster-admin system:masters Group rbac-manager rbac-manager ServiceAccount rbac-manager system:controller:attachdetach-controller attachdetach-controller ServiceAccount kube-system system:controller:clusterrole-aggregation-controller clusterrole-aggregation-controller ServiceAccount kube-system system:controller:cronjob-controller cronjob-controller ServiceAccount kube-system system:controller:daemon-set-controller daemon-set-controller ServiceAccount kube-system system:controller:deployment-controller deployment-controller ServiceAccount kube-system system:controller:endpoint-controller endpoint-controller ServiceAccount kube-system system:controller:generic-garbage-collector generic-garbage-collector ServiceAccount kube-system system:controller:horizontal-pod-autoscaler horizontal-pod-autoscaler ServiceAccount kube-system system:controller:job-controller job-controller ServiceAccount kube-system system:controller:namespace-controller namespace-controller ServiceAccount kube-system system:controller:node-controller node-controller ServiceAccount kube-system system:controller:persistent-volume-binder persistent-volume-binder ServiceAccount kube-system system:controller:pod-garbage-collector pod-garbage-collector ServiceAccount kube-system system:controller:pvc-protection-controller pvc-protection-controller ServiceAccount kube-system system:controller:replicaset-controller replicaset-controller ServiceAccount kube-system system:controller:replication-controller replication-controller ServiceAccount kube-system system:controller:resourcequota-controller resourcequota-controller ServiceAccount kube-system system:controller:statefulset-controller statefulset-controller ServiceAccount kube-system system:coredns coredns ServiceAccount kube-system system:kube-controller-manager system:kube-controller-manager User system:kube-scheduler system:kube-scheduler User</code> </pre> <br><h2>  rbac-lookup </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieses Projekt</a> bietet einen Überblick über die RBAC-Regeln.  Es hilft bei der Beantwortung der Fragen: „Zu welcher Rolle gehören <code>jean</code> und <code>sarah</code> ?“, „Zu welcher Rolle gehören alle Benutzer?“, „Zu welcher Rolle gehört die gesamte Gruppe?“.  Führen Sie zum Installieren den folgenden Befehl aus: <br><br><pre> <code class="bash hljs">kubectl krew install rbac-lookup</code> </pre> <br>  Die Dokumentation befindet sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Repository</a> .  Hier ist ein Beispiel für die Arbeit: <br><br><pre> <code class="bash hljs">kubectl-rbac_lookup jean SUBJECT SCOPE ROLE jean my-project-dev ClusterRole/edit jean my-project-prod ClusterRole/view kubectl-rbac_lookup sarah SUBJECT SCOPE ROLE sarah my-project-prod ClusterRole/edit kubectl-rbac_lookup --kind user SUBJECT SCOPE ROLE jean my-project-dev ClusterRole/edit jean my-project-prod ClusterRole/view sarah my-project-prod ClusterRole/edit system:anonymous kube-public Role/kubeadm:bootstrap-signer-clusterinfo system:kube-controller-manager kube-system Role/extension-apiserver-authentication-reader system:kube-controller-manager kube-system Role/system::leader-locking-kube-controller-manager system:kube-controller-manager cluster-wide ClusterRole/system:kube-controller-manager system:kube-proxy cluster-wide ClusterRole/system:node-proxier system:kube-scheduler kube-system Role/extension-apiserver-authentication-reader system:kube-scheduler kube-system Role/system::leader-locking-kube-scheduler system:kube-scheduler cluster-wide ClusterRole/system:kube-scheduler system:kube-scheduler cluster-wide ClusterRole/system:volume-scheduler kubectl-rbac_lookup --kind group SUBJECT SCOPE ROLE system:authenticated cluster-wide ClusterRole/system:basic-user system:authenticated cluster-wide ClusterRole/system:discovery system:authenticated cluster-wide ClusterRole/system:public-info-viewer system:bootstrappers:kubeadm:default-node-token cluster-wide ClusterRole/system:node-bootstrapper system:bootstrappers:kubeadm:default-node-token cluster-wide ClusterRole/system:certificates.k8s.io:certificatesigningrequests:nodeclient system:bootstrappers:kubeadm:default-node-token kube-system Role/kube-proxy system:bootstrappers:kubeadm:default-node-token kube-system Role/kubeadm:kubelet-config-1.14 system:bootstrappers:kubeadm:default-node-token kube-system Role/kubeadm:nodes-kubeadm-config system:masters cluster-wide ClusterRole/cluster-admin system:nodes kube-system Role/kubeadm:kubelet-config-1.14 system:nodes kube-system Role/kubeadm:nodes-kubeadm-config system:nodes cluster-wide ClusterRole/system:certificates.k8s.io:certificatesigningrequests:selfnodeclient system:unauthenticated cluster-wide ClusterRole/system:public-info-viewer</code> </pre> <br><h2>  RBAC Manager </h2><br>  Wie der Name <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Projekts</a> offensichtlich folgt, ist er der Manager von RBAC.  Es vereinfacht die vielen notwendigen Manipulationen.  Das vielleicht wichtigste ist die Erstellung von RoleBindings.  Wir haben bereits früher gesehen, dass beim Erstellen verschiedener Rollen für einen Benutzer unterschiedliche Rollenbindungen erstellt werden müssen.  Mit RBAC Manager können Sie nur eine Rollenbindung mit allen Berechtigungen gleichzeitig erstellen.  Zur Installation müssen Sie die YAML-Datei aus dem Repository auf GitHub herunterladen: <br><br><pre> <code class="bash hljs">kubectl apply -f /path/to/rbac/manager/yaml/file</code> </pre> <br>  Die offizielle Dokumentation befindet sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Repository</a> .  Arbeitsbeispiel: <br><br><pre> <code class="plaintext hljs">apiVersion: rbacmanager.reactiveops.io/v1beta1 kind: RBACDefinition metadata: name: jose rbacBindings: - name: jose subjects: - kind: User name: jose roleBindings: - namespace: my-project-prod clusterRole: edit - namespace: my-project-dev clusterRole: edit</code> </pre> <br><h2>  Fazit </h2><br>  Wir haben Benutzer im Kubernetes-Cluster mithilfe des X.509-Clientzertifikats mit OpenSSL erstellt und sie aktiviert.  Zur einfacheren Benutzererstellung können Sie das in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem Repository auf GitHub</a> verfügbare Skript <i>(oder die experimentellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubeadm-Befehle</a> - ca. Transl.) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden</a></i> .  Für die Clusterverwaltung können Sie die im Artikel vorgestellten Open Source-Projekte verwenden: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubectl auth can-i</a> : Finden Sie heraus, ob der Benutzer eine Aktion ausführen kann. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rakkess</a> : Finden Sie alle Aktionen heraus, die der Benutzer ausführen kann. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubectl-who-can</a> : Bestimmen Sie, welche Benutzer eine Aktion ausführen können. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rbac-lookup</a> : einen allgemeinen Überblick über RBAC erhalten; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC Manager</a> : Vereinfachen Sie die Konfiguration, indem Sie Rechtebindungen kombinieren, Änderungen an RBAC automatisieren und Beschriftungen als Selektoren zum Zuweisen von Rechten verwenden. </li></ul><br>  Das Erstellen von Benutzern kann zu einer sehr zeitaufwändigen Aufgabe werden, insbesondere wenn Sie eine große Anzahl von Benutzern gleichzeitig festlegen müssen (oder diese häufig erstellen müssen).  Um die Situation zu verbessern, kann LDAP für Unternehmen mit dem Kubernetes-Cluster verbunden werden.  Einige Open Source-Projekte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kismatic</a> <i>[</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Object</a> <i>sieht wie aufgegeben aus]</i> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ObjectifLibre</a> ) bieten Kubernetes-Webhooks an, die eine direkte Authentifizierung über LDAP ermöglichen.  Eine andere mögliche Lösung besteht darin, einen OpenID-Server mit Unternehmens-LDAP als Backend zu konfigurieren. <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  "Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ABC der Sicherheit in Kubernetes: Authentifizierung, Autorisierung, Prüfung</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC bei Kubernetes verstehen</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">33+ Kubernetes-Sicherheitstools</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9 Best Practices für die Kubernetes-Sicherheit</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470503/">https://habr.com/ru/post/de470503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470483/index.html">Azure Technology Laboratory in Moskau</a></li>
<li><a href="../de470489/index.html">Sicherheitswoche 41: Mehr Sicherheitslücken bei SIM-Karten, PDF-Entschlüsselung</a></li>
<li><a href="../de470491/index.html">Durch Dornen zum Spiel der Träume - Fortschritt und Entwicklung der Kreaturen</a></li>
<li><a href="../de470497/index.html">Verwendung von systemd-nspawn zum Wiederherstellen eines Linux-Systems</a></li>
<li><a href="../de470501/index.html">Monade "Reader" über async / warte in C #</a></li>
<li><a href="../de470517/index.html">Russische EP für die Kleinsten</a></li>
<li><a href="../de470519/index.html">Erleben Sie das Erstellen von Linux-Assemblys für Single-Board-Updates mit Unterstützung</a></li>
<li><a href="../de470525/index.html">Windows in einem Browser ohne Registrierung und SMS - Übersicht über HTML5-RDP-Clients</a></li>
<li><a href="../de470529/index.html">Wie wir ein Legacy-Projekt in GraphQL übersetzt haben</a></li>
<li><a href="../de470531/index.html">Der Neurophysiologe diskutiert das Neuralink-Projekt und spricht über die Arbeit des Gehirns „an den Fingern“.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>