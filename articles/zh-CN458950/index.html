<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎤 👘 👩🏿‍🎓 使用示例在JavaScript中解析异步/等待 🖕🏾 👩🏻‍⚕️ ♒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文的作者使用示例分析了JavaScript中的Async / Await。 通常，Async / Await是编写异步代码的便捷方法。 在此机会之前，使用回调和Promise编写了类似的代码。 原始文章的作者通过研究各种示例来揭示Async / Await的好处。 

 我们提醒您： 对于所有“ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用示例在JavaScript中解析异步/等待</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/458950/"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/f4a/252/2c8f4a252d33ee663665fd7df02b45ed.jpg"><br><br> 本文的作者使用示例分析了JavaScript中的Async / Await。 通常，Async / Await是编写异步代码的便捷方法。 在此机会之前，使用回调和Promise编写了类似的代码。 原始文章的作者通过研究各种示例来揭示Async / Await的好处。 <br><a name="habracut"></a><br><blockquote>  <b>我们提醒您：</b> <i>对于所有“ Habr”读者来说，使用“ Habr”促销代码注册任何Skillbox课程时均可享受10,000卢布的折扣。</i> <br><br>  <b>Skillbox建议：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java开发人员</a>在线教育课程。 </blockquote><br><h3> 回叫 </h3><br> 回调是一个函数，其调用会无限期延迟。 以前，回调用于那些无法立即获得结果的代码部分。 <br><br> 这是在Node.js上异步读取文件的示例： <br><br><pre><code class="javascript hljs">fs.readFile(__filename, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>, (err, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br> 当您需要一次执行多个异步操作时，就会出现问题。 让我们想象一下这种情况：向Arfat用户数据库发出请求，您需要读取其profile_img_url字段并从someserver.com服务器下载图片。 <br> 下载后，将图像转换为其他格式，例如，从PNG转换为JPEG。 如果转换成功，则会向用户的邮件发送一封电子邮件。 此外，有关事件的信息与日期一起输入到Transformations.log文件中。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad5/c3f/e3b/ad5c3fe3bf0f7a68a4d3444614c3133e.png"><br><br> 值得在代码的最后部分中强加回调和大量的}。 这称为末日回响地狱或金字塔。 <br><br> 这种方法的缺点很明显： <br><br><ul><li> 此代码很难阅读。 </li><li> 还很难处理其中的错误，这通常会导致代码质量下降。 </li></ul><br> 为了解决此问题，向JavaScript添加了promise。 它们使您可以将.then替换为回调的深层嵌套。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/503/0ad/9e15030ad0dbb431a63d9f98ec228111.png"><br><br> 承诺的积极之处在于，有了它们，从上到下，而不是从左到右，代码阅读得更好。 然而，承诺也存在以下问题： <br><br><ul><li> 需要添加大量的.then。 </li><li>  .catch代替try / catch来处理所有错误。 </li><li> 在一个周期内处理多个promise并非总是很方便；在某些情况下，它们会使代码复杂化。 </li></ul><br> 这是一个任务，将显示最后一段的含义。 <br><br> 假设有一个for循环，以随机间隔（0 – n秒）打印从0到10的数字序列。 使用promise，您需要更改此周期，以便以从0到10的顺序显示数字。因此，如果零输出花费6秒而单位花费2秒，则必须先输出零，然后才开始倒数输出。 <br><br> 当然，要解决此问题，我们不使用Async / Await或.sort。 最后是一个解决方案的例子。 <br><br><h3> 异步功能 </h3><br> 向ES2017（ES8）添加异步功能已简化了使用Promise的任务。 我注意到异步功能在promise之上起作用。 这些功能并不代表质的不同概念。 异步功能被认为是使用Promise的代码的替代方法。 <br><br>  Async / Await使得以异步方式组织异步代码的工作成为可能。 <br><br> 因此，对Promise的了解使您更容易理解Async / Await的原理。 <br><br>  <b>句法</b> <br><br> 在典型情况下，它由两个关键字组成：async和await。 第一个单词使函数异步。 这些功能允许等待。 在任何其他情况下，使用此功能都将导致错误。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// With function declaration async function myFn() { // await ... } // With arrow function const myFn = async () =&gt; { // await ... } function myFn() { // await fn(); (Syntax Error since no async) }</span></span></code> </pre><br> 异步插入在函数声明的最开始，对于箭头函数，插入在“ =”符号和方括号之间。 <br><br> 这些函数可以作为方法放置在对象中，也可以在类声明中使用。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// As an object's method const obj = { async getName() { return fetch('https://www.example.com'); } } // In a class class Obj { async getResource() { return fetch('https://www.example.com'); } }</span></span></code> </pre> <br> 注意！ 值得记住的是，类的构造函数和getters / setter方法不能异步进行。 <br><br>  <b>语义和执行规则</b> <br><br> 异步函数基本上类似于标准JS函数，但是也有例外。 <br><br> 因此，异步函数总是返回promise： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br> 特别是，fn返回字符串hello。 好吧，由于这是一个异步函数，因此使用构造函数将字符串值包装在promise中。 <br><br> 这是没有异步的替代设计： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br> 在这种情况下，承诺的归还是“手动”进行的。 异步函数总是将自己包装在新的Promise中。 <br><br> 如果返回值是原始值，则异步函数将返回一个值，并将其包装在promise中。 如果返回值是promise的对象，则其解决方案将在新promise中返回。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) p <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// true Promise.resolve(p) === p; // true</span></span></code> </pre><br> 但是，如果异步函数内部发生错误怎么办？ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>); } foo().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br> 如果未处理，则foo（）将返回带有redject的promise。 在这种情况下，Promise.reject代替Promise.resolve将返回包含错误的信息。 <br><br> 不管返回什么，输出上的异步函数总是给出承诺。 <br><br> 每次等待时都会暂停异步功能。 <br><br> 等待会影响表达式。 因此，如果表达式是一个Promise，则异步函数将被挂起，直到执行Promise。 如果表达式不是promise，则将其通过Promise.resolve转换为promise，然后终止。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// utility function to cause delay // and get random value const delayAndGetRandom = (ms) =&gt; { return new Promise(resolve =&gt; setTimeout( () =&gt; { const val = Math.trunc(Math.random() * 100); resolve(val); }, ms )); }; async function fn() { const a = await 9; const b = await delayAndGetRandom(1000); const c = await 5; await delayAndGetRandom(1000); return a + b * c; } // Execute fn fn().then(console.log);</span></span></code> </pre> <br> 这是fn函数工作方式的描述。 <br><br><ul><li> 调用它之后，第一行从const a = await 9转换； 在const a =等待Promise.resolve（9）; </li><li> 使用Await之后，函数的执行将被挂起，直到接收到它的值为止（在当前情况下为9）。 </li><li>  delayAndGetRandom（1000）暂停fn函数的执行，直到完成为止（1秒后）。 实际上，这将使fn功能停止1秒钟。 </li><li>  delayAndGetRandom（1000）通过resolve返回一个随机值，然后将其分配给变量b。 </li><li> 好吧，变量c的情况类似于变量a的情况。 在那之后，一切停止一秒钟，但是现在delayAndGetRandom（1000）不返回任何内容，因为这不是必需的。 </li><li> 结果，这些值由公式a + b * c计算。 结果使用Promise.resolve包装在一个Promise中，并由该函数返回。 </li></ul><br> 这些暂停可能类似于ES6中的生成器，但这是有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原因的</a> 。 <br><br><h3> 我们解决问题 </h3><br> 好了，现在让我们看一下上面提到的问题的解决方案。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/ec5/c45/40bec5c4564dfabbe1810db3d4a60c2d.png"><br><br>  finishMyTask函数使用Await等待诸如queryDatabase，sendEmail，logTaskInFile等操作的结果。 如果我们将此决定与承诺的使用地点进行比较，相似之处将显而易见。 不过，带有Async / Await的版本大大简化了所有语法上的困难。 在这种情况下，没有太多的回调和链接，例如.then / .catch。 <br><br> 这是输出数字的一种解决方案，有两种选择。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i, ms</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(i), ms)); <span class="hljs-comment"><span class="hljs-comment">// Implementation One (Using for-loop) const printNumbers = () =&gt; new Promise((resolve) =&gt; { let pr = Promise.resolve(0); for (let i = 1; i &lt;= 10; i += 1) { pr = pr.then((val) =&gt; { console.log(val); return wait(i, Math.random() * 1000); }); } resolve(pr); }); // Implementation Two (Using Recursion) const printNumbersRecursive = () =&gt; { return Promise.resolve(0).then(function processNextPromise(i) { if (i === 10) { return undefined; } return wait(i, Math.random() * 1000).then((val) =&gt; { console.log(val); return processNextPromise(i + 1); }); }); };</span></span></code> </pre> <br> 这是使用异步功能的解决方案。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printNumbersUsingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> wait(i, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }</code> </pre> <br>  <b>错误处理</b> <br><br> 未处理的错误包含在被拒绝的承诺中。 但是，在异步函数中，可以使用try / catch构造执行同步错误处理。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canRejectOrReturn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// wait one second await new Promise(res =&gt; setTimeout(res, 1000)); // Reject with ~50% probability if (Math.random() &gt; 0.5) { throw new Error('Sorry, number too big.') } return 'perfect number'; }</span></span></code> </pre> <br>  canRejectOrReturn（）是一个异步函数，要么成功（“完美数字”），要么失败并显示错误（“抱歉，数字太大”）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br> 由于可以在上面的示例中执行canRejectOrReturn，因此其自身不成功的终止将需要执行catch块。 结果，foo函数将以未定义（在try块中未返回任何内容）或捕获到错误的情况下结束。 结果，此函数不会失败，因为try / catch将处理foo函数本身。 <br><br> 这是另一个示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br> 值得注意的是，在foo的示例中，返回了canRejectOrReturn。 在这种情况下，Foo要么以一个完美的数字结尾，要么返回错误（“抱歉，数字太大”）错误。  catch块将永远不会执行。 <br><br> 问题是foo返回从canRejectOrReturn传递的promise。 因此，foo函数的解决方案成为canRejectOrReturn的解决方案。 在这种情况下，代码将仅包含两行： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise; }</code> </pre> <br> 但是，如果使用await然后一起返回，会发生什么情况： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br> 在上面的代码中，foo成功执行，同时出现了完美数字和错误。 没有失败。 但是foo将以canRejectOrReturn结尾，而不是以undefined结尾。 让我们通过删除return await canRejectOrReturn（）行来确保这一点： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-comment"><span class="hljs-comment">// …</span></span></code> </pre> <br><h3> 常见的错误和陷阱 </h3><br> 在某些情况下，使用异步/等待可能会导致错误。 <br><br>  <b>被遗忘的等待</b> <br><br> 这种情况经常发生-在承诺之前，忘记了await关键字： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'caught'</span></span>; } }</code> </pre> <br> 如您所见，在代码中，既没有等待也没有返回。 因此，foo始终以undefined退出，没有1秒的延迟。 但是诺言将兑现。 如果给出错误或拒绝，则将调用UnhandledPromiseRejectionWarning。 <br><br>  <b>回调中的异步功能</b> <br><br> 异步函数通常在.map或.filter中用作回调。 一个示例是fetchPublicReposCount（用户名）函数，该函数返回在GitHub上打开的存储库数量。 假设我们需要三个用户的指标。 这是此任务的代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://api.github.com/users'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Utility fn to fetch repo counts const fetchPublicReposCount = async (username) =&gt; { const response = await fetch(`${url}/${username}`); const json = await response.json(); return json['public_repos']; }</span></span></code> </pre> <br> 我们需要帐户ArfatSalman，octocat，norvig。 在这种情况下，执行： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ <span class="hljs-string"><span class="hljs-string">'ArfatSalman'</span></span>, <span class="hljs-string"><span class="hljs-string">'octocat'</span></span>, <span class="hljs-string"><span class="hljs-string">'norvig'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; });</code> </pre> <br> 您应该注意.map回调中的Await。 这里counts是一个promise数组，.map是每个指定用户的匿名回调。 <br><br>  <b>过度一致地使用await</b> <br><br> 以以下代码为例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; users.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = users[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); counts.push(count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; }</code> </pre> <br> 此处，将回购编号放置在count变量中，然后将此编号添加到counts数组中。 该代码的问题在于，在第一个用户数据从服务器到达之前，所有后续用户都将处于待机模式。 因此，在一瞬间，仅处理一个用户。 <br><br> 例如，如果处理一个用户大约需要300毫秒，那么对于所有用户来说，这已经是一秒钟，花费的时间线性地取决于用户数量。 但是由于获取回购单的数量并不相互依赖，因此可以并行处理。 这需要使用.map和Promise.all： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promises = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promises); }</code> </pre> <br> 输入中的Promise.all会收到一个带有诺言返回的诺言数组。 完成数组中的所有promise或第一个redject之后的最后一个完成。 它们可能并非同时启动，可能会发生-为了确保同时启动，可以使用p-map。 <br><br><h3> 结论 </h3><br> 异步功能对开发变得越来越重要。 好吧，对于异步功能的自适应使用，值得使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow noopener noreferrer">Async Iterators</a> 。  JavaScript开发人员应该精通这一点。 <br><br><blockquote>  <b>Skillbox建议：</b> <br><br><ul><li> 实用课程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Mobile Developer PRO”</a> 。 </li><li> 在线应用课程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Python中的数据分析”</a> 。 </li><li> 两年实践课程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“我是PRO Web开发人员”</a> 。 </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458950/">https://habr.com/ru/post/zh-CN458950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458936/index.html">“回答要比保持沉默更容易”-交易记忆之父Maurice Herlichi的一次大型访谈</a></li>
<li><a href="../zh-CN458938/index.html">捆绑了C ++ 20，启动了C ++ 23。 科隆会议的结果</a></li>
<li><a href="../zh-CN458940/index.html">我们如何实施敏捷测试</a></li>
<li><a href="../zh-CN458944/index.html">雇用员工始于……尊重。 我们将采访工程师</a></li>
<li><a href="../zh-CN458948/index.html">《哈伯周刊》第8期/ Yandex Sorcerers，一本关于波斯王子的书，针对黑客的YouTube，五角大楼的“心脏”激光</a></li>
<li><a href="../zh-CN458952/index.html">调整PostgreSQL设置以优化性能</a></li>
<li><a href="../zh-CN458954/index.html">哪些类型的检测在视频监视中很有用。 机制与功能</a></li>
<li><a href="../zh-CN458956/index.html">机器学习与 分析方法</a></li>
<li><a href="../zh-CN458960/index.html">企业追求</a></li>
<li><a href="../zh-CN458962/index.html">将图像转换为声音-您会听到什么？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>