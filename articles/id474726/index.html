<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏾 ⚪️ 🥚 Bahkan anak-anak akan mengerti: penjelasan sederhana tentang async / menunggu dan janji dalam JavaScript 🈶 🖐🏼 😵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan untuk Anda terjemahan artikel “JavaScript Async / Menunggu dan Menjanjikan: Dijelaskan seperti Anda berusia lima tahu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bahkan anak-anak akan mengerti: penjelasan sederhana tentang async / menunggu dan janji dalam JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474726/">  Halo, Habr!  Saya mempersembahkan untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“JavaScript Async / Menunggu dan Menjanjikan: Dijelaskan seperti Anda berusia lima tahun”</a> oleh Jack Pordi. <br><br>  Siapa pun yang menganggap dirinya sebagai pengembang JavaScript, pada titik tertentu, harus mengalami fungsi panggilan balik, janji, atau, baru-baru ini, sintaks async / menunggu.  Jika Anda sudah cukup lama bermain, Anda mungkin akan menemukan saat-saat ketika fungsi panggilan balik bersarang adalah satu-satunya cara untuk mencapai sinkronisasi di JavaScript. <br><br>  Ketika saya mulai belajar dan menulis dalam JavaScript, sudah ada satu miliar tutorial dan tutorial yang menjelaskan cara mencapai asinkron dalam JavaScript.  Namun, banyak dari mereka hanya menjelaskan cara mengubah fungsi panggilan balik ke janji atau janji di async / menunggu.  Bagi banyak orang, ini mungkin lebih dari cukup untuk bergaul dengan mereka dan mulai menggunakannya dalam kode mereka. <br><br>  Namun, jika Anda, seperti saya, benar-benar ingin memahami pemrograman asinkron (dan bukan hanya sintaksis JavaScript!), Maka Anda mungkin setuju dengan saya bahwa ada kekurangan materi yang menjelaskan pemrograman asinkron dari awal. <a name="habracut"></a><br><br><h2>  Apakah yang dimaksud dengan asinkron? </h2><br><img src="https://habrastorage.org/webt/sk/ml/pc/skmlpcgi3gmhov77moxcfyengek.jpeg" alt="gambar menunjukkan orang yang berpikir"><br><br>  Sebagai aturan, menanyakan pertanyaan ini, Anda dapat mendengar sesuatu dari yang berikut: <br><br><ul><li>  Ada beberapa utas yang mengeksekusi kode pada saat bersamaan. </li><li>  Lebih dari satu bagian kode dieksekusi sekaligus. </li><li>  Ini konkurensi. </li></ul><br>  Sampai batas tertentu, semua opsi sudah benar.  Tetapi alih-alih memberi Anda definisi teknis yang kemungkinan akan segera Anda lupakan, saya akan memberikan <b>contoh yang bahkan seorang anak pun bisa mengerti</b> . <br><br><h2>  Contoh hidup </h2><br><img src="https://habrastorage.org/webt/lu/gq/ww/lugqwwbgniupu-afgs3oxavro9a.jpeg" alt="gambar menunjukkan sayuran dan pisau dapur"><br><br>  Bayangkan Anda sedang memasak sup sayur.  Untuk analogi yang bagus dan sederhana, misalkan sup sayuran hanya terdiri dari bawang dan wortel.  Resep untuk sup seperti itu adalah sebagai berikut: <br><br><ol><li>  Potong wortel. </li><li>  Potong bawang. </li><li>  Tambahkan air ke wajan, nyalakan kompor dan tunggu sampai mendidih. </li><li>  Tambahkan wortel ke dalam wajan dan biarkan selama 5 menit. </li><li>  Tambahkan bawang ke wajan dan masak selama 10 menit. </li></ol><br>  Petunjuk ini sederhana dan dapat dimengerti, tetapi jika salah satu dari Anda, membaca ini, benar-benar tahu cara memasak, Anda dapat mengatakan bahwa ini bukan cara memasak yang paling efektif.  Dan Anda akan benar, itu sebabnya: <br><br><ul><li>  Langkah 3, 4 dan 5 sebenarnya <i><b>tidak mengharuskan</b></i> Anda sebagai koki untuk melakukan apa pun kecuali untuk mengamati proses dan melacak waktu. </li><li>  Langkah 1 dan 2 <i><b>mengharuskan</b></i> Anda untuk secara aktif melakukan sesuatu. </li></ul><br>  Oleh karena itu, resep untuk koki yang lebih berpengalaman mungkin sebagai berikut: <br><br><ol><li>  Mulailah merebus panci air. </li><li>  <b>Sambil menunggu panci mendidih,</b> mulailah memotong wortel. </li><li>  <b>Saat Anda selesai</b> memotong wortel, air akan mendidih, jadi tambahkan wortel. </li><li>  <b>Sementara wortel dimasak dalam wajan,</b> potong bawang. </li><li>  Tambahkan bawang dan masak 10 menit lagi. </li></ol><br>  Terlepas dari kenyataan bahwa semua tindakan tetap sama, Anda memiliki hak untuk berharap bahwa opsi ini akan jauh lebih cepat dan lebih efisien.  Ini persis prinsip pemrograman asinkron: <b>Anda tidak akan pernah ingin duduk, hanya menunggu sesuatu, sementara Anda bisa menghabiskan waktu Anda pada beberapa hal berguna lainnya.</b> <b><br></b> <br>  Kita semua tahu bahwa dalam pemrograman, <b>menunggu</b> sesuatu terjadi cukup sering - apakah menunggu respons HTTP dari server atau tindakan dari pengguna atau sesuatu yang lain.  Tetapi siklus eksekusi prosesor Anda sangat berharga dan harus <b>selalu</b> digunakan secara aktif, melakukan sesuatu, dan tidak mengharapkan: ini menghasilkan <b>pemrograman asinkron</b> . <br><br><h2>  Sekarang mari kita ke JavaScript, oke? </h2><br>  Jadi, mengikuti contoh yang sama dari sup sayuran, saya akan menulis beberapa fungsi untuk mewakili langkah-langkah resep yang dijelaskan di atas. <br><br>  Pertama, mari kita menulis fungsi sinkron yang mewakili tugas yang tidak memakan waktu.  Ini adalah fungsi-fungsi JavaScript lama yang baik, tetapi perhatikan bahwa saya telah mendeskripsikan <b><code>chopOnions</code></b> dan <b><code>chopOnions</code></b> sebagai tugas yang membutuhkan kerja aktif (dan waktu), yang memungkinkan mereka melakukan beberapa perhitungan panjang.  Kode lengkap tersedia di akhir artikel [1]. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }</code> </pre><br>  Sebelum beralih ke fungsi asinkron, saya pertama-tama akan menjelaskan bagaimana sistem tipe JavaScript menangani asinkron: pada dasarnya <b>semua hasil (termasuk kesalahan) operasi asinkron harus dibungkus dengan janji</b> . <br><br>  Agar suatu fungsi mengembalikan janji, Anda dapat: <br><br><ul><li>  secara eksplisit mengembalikan janji, yaitu  <b><code>return new Promise(…)</code></b> ; </li><li>  secara implisit mengembalikan janji - tambahkan <b><code>async</code></b> ke deklarasi fungsi, mis.  <b><code>async function foo()</code></b> ; </li><li>  <i>gunakan kedua opsi</i> . </li></ul><br>  Ada artikel yang bagus [2], yang membahas tentang perbedaan antara fungsi dan fungsi asinkron yang menghasilkan janji.  Oleh karena itu, dalam artikel saya, saya tidak akan membahas topik ini, hal utama yang perlu diingat: Anda harus <i><b>selalu</b></i> menggunakan <b><code>async</code></b> dalam fungsi asinkron. <br><br>  Jadi, fungsi asinkron kami, mewakili langkah 3-5 dalam menyiapkan sup sayur, adalah sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">letPotKeepBoiling</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">time</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,      } async function boilPot() { return; //  ,       }</span></span></code> </pre><br>  Sekali lagi, saya menghapus detail implementasi agar tidak terganggu oleh mereka, tetapi mereka diterbitkan pada akhir artikel [1]. <br><br>  Penting untuk diketahui bahwa untuk menunggu hasil dari janji, sehingga nantinya Anda dapat melakukan sesuatu dengannya, Anda cukup menggunakan kata kunci <b><code>await</code></b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  ... */</span></span> } result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncFunction();</code> </pre><br>  Jadi, sekarang kita hanya perlu menyatukannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Tapi tunggu!  Ini tidak bekerja!  Anda akan melihat <b><code>SyntaxError: await is only valid in async functions</code></b> kesalahan <b><code>SyntaxError: await is only valid in async functions</code></b> .  Mengapa  Karena jika Anda tidak mendeklarasikan fungsi menggunakan <b><code>async</code></b> , maka secara default JavaScript mendefinisikannya sebagai fungsi sinkron - dan sinkron berarti tidak menunggu!  [3].  Ini juga berarti bahwa Anda tidak dapat menggunakan <b><code>await</code></b> luar fungsi. <br><br>  Karenanya, kami cukup menambahkan <b><code>async</code></b> ke fungsi <b><code>makeSoup</code></b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Dan voila!  Perhatikan bahwa pada baris kedua, saya memanggil fungsi asinkron <b><code>boilPot</code></b> tanpa <b><code>await</code></b> kata kunci, karena kami tidak ingin menunggu wajan mendidih sebelum kami mulai memotong wortel.  Kita hanya mengharapkan janji <b><code>pot</code></b> di baris kelima sebelum kita perlu meletakkan wortel di dalam wajan, karena kita tidak ingin melakukan ini sebelum air mendidih. <br><br>  Apa yang terjadi selama <b><code>await</code></b> panggilan?  Yah, tidak ada ... semacam ... <br><br>  Dalam konteks fungsi <b><code>makeSoup</code></b> Anda bisa menganggapnya sebagai sesuatu yang Anda harapkan terjadi (atau hasil yang pada akhirnya akan dikembalikan). <br><br>  Tapi ingat: <b>Anda (seperti prosesor Anda) tidak akan pernah mau hanya duduk di sana dan menunggu sesuatu, sementara Anda dapat menghabiskan waktu Anda untuk hal-hal lain</b> . <br><br>  Karena itu, alih-alih hanya memasak sup, kita bisa memasak sesuatu yang lain secara paralel: <br><br><pre> <code class="javascript hljs">makeSoup(); makePasta();</code> </pre><br>  Sementara kita menunggu <b><code>letPotKeepBoiling</code></b> , kita dapat, misalnya, memasak pasta. <br><br>  Lihat?  Sintaks async / await sebenarnya cukup mudah digunakan, jika Anda memahaminya, setuju? <br><br><h2>  Bagaimana dengan janji terbuka? </h2><br>  Nah, jika Anda bersikeras, saya akan beralih ke penggunaan janji-janji eksplisit ( <i>komentar</i> terjemahan <i>: dengan janji-janji eksplisit, penulis menyiratkan secara langsung sintaks dari janji-janji, dan secara implisit menjanjikan sintaksis async / menunggu, karena ia mengembalikan janji secara implisit - tidak perlu menulis <code>return new Promise(…)</code></i> ).  Perlu diingat bahwa metode async / menunggu <b>didasarkan pada janji itu sendiri, dan oleh karena itu kedua opsi sepenuhnya kompatibel</b> . <br><br>  Janji-janji eksplisit, menurut pendapat saya, ada di antara panggilan balik gaya lama dan sintaksis seksual baru yang menunggu.  Atau, Anda juga dapat menganggap sintaksis seksual async / menunggu sebagai tidak lebih dari janji tersirat.  Pada akhirnya, async / menunggu menunggu datang setelah janji, yang pada gilirannya datang setelah fungsi panggilan balik. <br><br>  Gunakan mesin waktu kami untuk pindah ke neraka panggilan balik [4]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callbackHell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boilPot( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>, chopCarrots(), chopOnions() ); }</code> </pre><br>  Saya tidak akan berbohong, saya menulis contoh ini dengan cepat ketika saya mengerjakan artikel ini, dan butuh waktu lebih lama daripada yang ingin saya akui.  Banyak dari Anda mungkin tidak tahu apa yang sedang terjadi di sini.  <i><b>Sahabatku, bukankah semua fungsi panggilan balik ini mengerikan?</b></i>  <i><b>Jadikan itu pelajaran untuk tidak pernah menggunakan fungsi callback lagi ...</b></i> <br><br>  Dan, seperti yang dijanjikan, contoh yang sama dengan janji eksplisit: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reject, resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { chopCarrots(); chopOnions(); resolve(); }), boilPot() ]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }); }</code> </pre><br>  Seperti yang Anda lihat, janji masih mirip dengan fungsi panggilan balik. <br>  Saya tidak akan merinci, tetapi yang paling penting: <br><br><ul><li>  <b><code>.then</code></b> adalah metode janji yang mengambil hasilnya dan meneruskannya ke fungsi argumen (pada dasarnya, ke fungsi panggilan balik ...) </li><li>  Anda tidak pernah dapat menggunakan hasil dari janji di luar konteks <b><code>.then</code></b> .  Intinya, .kemudian seperti blok asinkron yang mengharapkan hasil dan kemudian meneruskannya ke fungsi panggilan balik. </li><li>  Selain metode <b><code>.then</code></b> , ada metode lain dalam <b><code>.catch</code></b> - <b><code>.catch</code></b>  Diperlukan untuk menangani kesalahan dalam janji-janji.  Tetapi saya tidak akan membahas lebih rinci, karena sudah ada satu miliar artikel dan tutorial tentang topik ini. </li></ul><br><h2>  Kesimpulan </h2><br>  Saya harap Anda mendapat beberapa gagasan tentang janji dan pemrograman asinkron dari artikel ini, atau mungkin setidaknya belajar contoh yang baik dari kehidupan untuk menjelaskan hal ini kepada orang lain. <br><br>  <b>Jadi, ke arah mana Anda menggunakan: janji atau async / menunggu?</b> <br>  Jawabannya sepenuhnya terserah Anda - dan saya akan mengatakan bahwa menggabungkan mereka tidak terlalu buruk, karena kedua pendekatan tersebut sepenuhnya kompatibel satu sama lain. <br><br>  Namun demikian, saya pribadi 100% di async / menunggu camp, karena bagi saya kode jauh lebih dimengerti dan lebih baik mencerminkan multitasking sebenarnya dari pemrograman asynchronous. <br><br><hr><br>  <b>[1]</b> : Kode sumber lengkap tersedia di <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a></u> . <br>  <b>[2]</b> : Artikel asli <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Fungsi Async vs.</a></u>  <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi yang mengembalikan Janji "</a></u> , terjemahan artikel <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">" Perbedaan antara fungsi asinkron dan fungsi yang mengembalikan janji</a></u> . <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a></u> <br>  <b>[3]</b> : Anda dapat berargumen bahwa JavaScript mungkin dapat menentukan tipe async / tunggu berdasarkan fungsi dan memeriksa secara rekursif, tetapi JavaScript tidak dirancang untuk menjaga keamanan tipe statis pada waktu kompilasi, belum lagi yang jauh lebih nyaman bagi pengembang untuk secara eksplisit melihat jenis fungsi. <br>  <b>[4]</b> : Saya menulis fungsi “asinkron”, dengan asumsi mereka berfungsi di bawah antarmuka yang sama dengan <b><code>setTimeout</code></b> .  Perhatikan bahwa panggilan balik tidak kompatibel dengan janji dan sebaliknya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474726/">https://habr.com/ru/post/id474726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474716/index.html">Bug C ++ 20. Hasil pertemuan di Belfast</a></li>
<li><a href="../id474718/index.html">Keselamatan dalam elektronik otomatis - Halo dunia pada pengontrol dasbor</a></li>
<li><a href="../id474720/index.html">Laboratorium radio Nizhny Novgorod dan "cristadins" Losev</a></li>
<li><a href="../id474722/index.html">“Tidak ada yang memberi tahu orang lain apa yang harus mereka lakukan”: Nicolò Ribaudo tentang pengembangan Babel dan banyak lagi</a></li>
<li><a href="../id474724/index.html">Apa yang akan terjadi pada PHP dalam 5 tahun: kami bertanya kepada pembicara mitap Moskow terdekat</a></li>
<li><a href="../id474732/index.html">Bekerja dengan daftar pin, dalam C ++ untuk mikrokontroler (menggunakan CortexM sebagai contoh)</a></li>
<li><a href="../id474738/index.html">Pemodelan geometris permukaan fillet</a></li>
<li><a href="../id474740/index.html">Museum Sejarah Komputer Terbaik di Mountain View</a></li>
<li><a href="../id474744/index.html">Uber memasuki pasar layanan keuangan dan meluncurkan divisi Uber Money</a></li>
<li><a href="../id474746/index.html">Penyimpanan objek di ruang belakang, atau Bagaimana menjadi penyedia layanan Anda sendiri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>