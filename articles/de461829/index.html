<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏼 👐🏼 🙇🏻 TCP vs UDP oder die Zukunft der Netzwerkprotokolle 🕺🏿 🤾🏻 🤾🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor jedem Dienst, der mindestens 1 MBit / s Internetverkehr generiert, stellt sich die Frage: „Wie? über TCP oder über UDP? " In Anwendungsbereichen, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TCP vs UDP oder die Zukunft der Netzwerkprotokolle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461829/">  Vor jedem Dienst, der mindestens 1 MBit / s Internetverkehr generiert, stellt sich die Frage: „Wie?  über TCP oder über UDP? "  In Anwendungsbereichen, einschließlich Bereitstellungsplattformen, haben sich bereits Präferenzen und Traditionen für solche Entscheidungen entwickelt. <br><br>  Wenn beispielsweise ein fauler Entwickler nicht einmal versucht hätte, seine ML in Python bereitzustellen (weil er es nur wusste), wäre die Welt theoretisch höchstwahrscheinlich nie von einer solchen Liebe für die verabscheuungswürdige Sprache der „Super-Java-Encoder“ erfüllt worden.  Und heute haben die Schwächen dieser Sprache im früheren Anwendungskontext bedingungslos Vorrang bei der Bereitstellung und dem Start zahlreicher Mining-A / B. <br><br>  Sie können viel vergleichen: ARM mit Intel, iOS und Android und Mortal Kombat mit Injustice.  Und stoßen Sie auf einen Weltraum-Holivar, also zurück zum Thema der Bereitstellung großer Mengen von Inhalten mit mehreren Formaten. <br><br>  Vor zehn Jahren war sich jeder absolut sicher, dass es bei UDP um nicht garantierte Lieferung geht.  Wenn Sie ein zuverlässiges Protokoll benötigen, ist es TCP.  Und entgegen der Tradition in diesem Artikel werden wir scheinbar unvergleichliche Dinge wie TCP und UDP vergleichen. <br><br><img src="https://habrastorage.org/webt/p5/tk/9z/p5tk9z_pumv5hmxly_ob3rvdikg.jpeg"><br>  <i>Achtung, unter dem Schnitt 99 Abbildungen und Diagramme und alles Wichtige.</i> <br><a name="habracut"></a><br>  Der Vergleich wird vom Entwicklungsleiter der Video- und Tape-Plattformen in OK <b>Alexander Tobol</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">alatobol</a> ) durchgeführt.  Die Video- und Newsfeed-Dienste im sozialen Netzwerk OK - ausschließlich über Inhalte und deren Bereitstellung auf allen vorhandenen Client-Plattformen unter schlechten oder ausgezeichneten Netzwerkbedingungen, und die Frage, wie diese über TCP oder UDP bereitgestellt werden sollen, sind von entscheidender Bedeutung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aXYJlizk3CQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  TCP gegen UDP.  Minimale Theorie </h2><br>  Um zum Vergleich zu gelangen, brauchen wir eine kleine Grundtheorie. <br><br><img src="https://habrastorage.org/webt/fd/2q/ko/fd2qkoeptll1vmmm0ptkscrhu9i.jpeg"><br><br>  Was wissen wir über IP-Netzwerke?  Der von Ihnen gesendete Datenstrom ist in Pakete unterteilt. Eine Art Black Box liefert diese Pakete an den Client.  Der Client sammelt Pakete und empfängt einen Datenstrom.  Normalerweise ist dies alles transparent und es besteht kein Grund zu überlegen, was sich auf den unteren Ebenen befindet. <br><br><img src="https://habrastorage.org/webt/dj/6r/xm/dj6rxmcr3xayjlmfnblkxet-1le.jpeg"><br><br>  Das Diagramm zeigt den TCP / IP- und UDP / IP-Stack.  Unten befinden sich Ethernet-Pakete, IP-Pakete und auf Betriebssystemebene TCP und UDP.  TCP und UDP in diesem Stapel unterscheiden sich nicht sehr voneinander.  Sie sind in IP-Paketen gekapselt und können von Anwendungen verwendet werden.  Um die Unterschiede zu erkennen, müssen Sie sich die TCP- und UDP-Pakete ansehen. <br><br><img src="https://habrastorage.org/webt/mz/pr/lt/mzprltftvytepznp_xufo63xb0g.jpeg"><br><br>  Sowohl dort als auch dort gibt es Ports.  <strong>In UDP gibt es jedoch nur eine Prüfsumme</strong> - die Paketlänge, dieses Protokoll ist so einfach wie möglich.  Und in TCP gibt es viele Daten, die das Fenster, die Bestätigung, die Sequenz, die Pakete usw. klar anzeigen.  Offensichtlich ist <strong>TCP komplexer</strong> . <br><br><blockquote>  Ganz grob gesagt ist TCP ein zuverlässiges Übermittlungsprotokoll und UDP ein unzuverlässiges. </blockquote><br>  Trotz der angeblichen Unzuverlässigkeit von UDP werden wir herausfinden, ob es möglich ist, Daten schneller und zuverlässiger zu liefern als mit TCP.  Lassen Sie uns versuchen, das Netzwerk von innen zu betrachten und zu verstehen, wie es funktioniert.  Auf dem Weg werden wir die folgenden Fragen ansprechen: <br><br><ul><li>  Warum TCP vergleichen oder was ist daran falsch? </li><li>  womit und womit sollten Sie TCP vergleichen? </li><li>  Was hat Google getan und welche Entscheidung hat es getroffen? </li><li>  Was erwartet uns die Zukunft der Netzwerkprotokolle? </li></ul><br>  Dieser Artikel wird keine Theorie haben: OSI-Ebenen und -Modelle, komplexe mathematische Modelle, obwohl alles durch sie gezählt werden kann.  Wir werden maximal analysieren, wie man das Netzwerk nicht theoretisch, sondern mit eigenen Händen berührt. <br><br><h2>  Warum TCP vergleichen oder was daran falsch ist? </h2><br>  TCP wurde 1974 erfunden und 20 Jahre später, als ich zur Schule ging, kaufte ich Internetkarten, löschte den Code und rief irgendwo an.  Wenn Sie von 2 Nächten bis 7 Uhr morgens anrufen, war das Internet kostenlos, aber es war schwierig, durchzukommen. <br><br>  Weitere 20 Jahre vergingen, und Benutzer in mobilen drahtlosen Netzwerken setzten sich gegen „verkabelte“ Benutzer durch, während sich TCP konzeptionell nicht änderte. <br><br><blockquote>  Die mobile Welt gewann, drahtlose Protokolle erschienen und TCP blieb unverändert. </blockquote><br>  Heutzutage verwenden 80% der Benutzer Wi-Fi oder ein drahtloses 3G-4G-Netzwerk. <br><br><img src="https://habrastorage.org/webt/mw/a9/u4/mwa9u4ew7v6e1uevlbgrvf2jlrw.jpeg"><br><br>  In drahtlosen Netzwerken gibt es: <br><br><ul><li>  Paketverlust - Ungefähr 0,6% der von uns gesendeten Pakete gehen unterwegs verloren. </li><li>  Neuordnung - Neuordnung von Paketen an Orten im wirklichen Leben ist ein eher seltenes Phänomen, das jedoch in 0,2% der Fälle auftritt. </li><li>  Jitter - wenn Pakete gleichmäßig gesendet werden und mit einer Verzögerung von ca. 50 ms in Warteschlangen eintreffen. </li></ul><br>  TCP verbirgt erfolgreich alle diese Funktionen der Datenübertragung in heterogenen Netzwerken vor Ihnen, und Sie müssen nicht eintauchen. <br><br>  Unten auf der Karte ist die durchschnittliche TCP-Datenrate in Russland angegeben.  Wenn Sie den westlichen Teil entfernen, ist klar, dass die Geschwindigkeit mehr in Kilobit als in Megabit gemessen wird. <br><br><img src="https://habrastorage.org/webt/ck/a4/y5/cka4y5puk4gyorr-uaq2xcdtuom.jpeg"><br><br>  Das ist im Durchschnitt für unsere Benutzer (ohne den westlichen Teil Russlands): Durchsatz 1,1 Mbit / s, 0,6% Paketverlust, RTT (Round-Trip-Zeit) von etwa 200 ms. <br><br><h3>  Wie berechnet man die RTT? </h3><br>  Als ich den Durchschnitt von 200 ms sah, dachte ich, dass es einen Fehler in der Statistik gab, und entschied mich, die RTT für unsere Server in der MSC auf alternative Weise mithilfe von RIPE Atlas zu messen.  Dies ist ein System zum Sammeln von Daten über den Zustand des Internets.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RIPE Atlas-</a> Sonde ist kostenlos erhältlich. <br><br><img src="https://habrastorage.org/webt/za/rj/3g/zarj3gndghr0wnxs4yqt_odm68a.jpeg"><br><br>  Das Fazit ist, dass Sie es mit Ihrem Heim-Internet verbinden und „Karma“ sammeln.  Sie arbeitet tagelang, einige Leute erfüllen einige ihrer Anfragen an sie.  Dann können Sie selbst verschiedene Aufgaben einstellen.  Ein Beispiel für eine solche Aufgabe: Nehmen Sie versehentlich 30 Punkte im Internet und fragen Sie nach der RTT-Messung, dh führen Sie den Ping-Befehl auf der Odnoklassniki-Website aus. <br><br><img src="https://habrastorage.org/webt/kb/qa/5k/kbqa5k7sgl6wt5modhjfpa2fg00.jpeg"><br><br>  Seltsamerweise gibt es unter zufälligen Punkten viele solche, die einen Ping von 200 bis 300 ms haben. <br><br>  Insgesamt sind <strong>drahtlose Netzwerke beliebt und instabil</strong> (obwohl letzteres normalerweise ignoriert wird, da angenommen wird, dass TCP damit umgehen kann): <br><br><ul><li>  Über 80% der Benutzer nutzen das drahtlose Internet. </li><li>  Die Parameter von drahtlosen Netzwerken ändern sich dynamisch, beispielsweise abhängig von der Tatsache, dass der Benutzer um die Ecke gegangen ist. </li><li>  Drahtlose Netzwerke weisen eine hohe Rate an Paketverlust, Jitter und Neuordnung auf. </li><li>  Asymmetrischer Kanal behoben, Änderung der IP-Adresse. </li></ul><br><h3>  Der Verbrauch von Inhalten hängt von der Internetgeschwindigkeit ab </h3><br>  Dies ist sehr einfach zu überprüfen - es gibt viele Statistiken.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statistiken</a> zu dem Video erstellt. Je höher die Internetgeschwindigkeit im Land, desto mehr Benutzer sehen sich das Video an. <br><br><img src="https://habrastorage.org/webt/de/6q/_r/de6q_ruks-vpbgoo4yt5vokfkno.jpeg"><br><br>  Nach diesen Statistiken hat Russland ein ziemlich schnelles Internet, aber nach unseren internen Daten ist die Durchschnittsgeschwindigkeit etwas niedriger. <br><br>  Für die Tatsache, dass die Internetgeschwindigkeit insgesamt nicht ausreicht, heißt es, dass alle Entwickler großer Anwendungen, sozialer Netzwerke, Videodienste usw. ihre Dienste für die Arbeit in einem schlechten Netzwerk optimieren.  Nach 10 KB empfangener Daten sehen Sie ein Minimum an Informationen auf dem Band, und bei einer Geschwindigkeit von 500 KB können Sie Videos ansehen. <br><br><h3>  So beschleunigen Sie das Laden </h3><br>  Bei der Entwicklung der Videoplattform haben wir festgestellt, dass TCP in drahtlosen Netzwerken nicht sehr effektiv ist.  Wie sind Sie zu diesem Schluss gekommen? <br><br>  Wir beschlossen, den Download zu beschleunigen und machten den nächsten Trick. <br><br><img src="https://habrastorage.org/webt/n2/gg/xf/n2ggxfu9tzoskihc7itlm28j7ui.jpeg"><br><br>  Wir haben das Video in mehreren Streams vom Client auf den Server heruntergeladen, dh 40 MB werden in 4 Teile von 10 MB aufgeteilt und parallel geladen.  Wir haben es auf Android gestartet und festgestellt, dass es parallel schneller geladen wird als in einer Verbindung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> im Bericht).  Das Interessanteste ist, dass wir bei der Einführung paralleler Downloads in der Produktion festgestellt haben, dass sich die Download-Geschwindigkeit in einigen Regionen verdreifacht hat! <br><br><blockquote>  Vier TCP-Verbindungen können tatsächlich dreimal schneller Daten auf den Server hochladen. </blockquote><br>  Deshalb haben wir die Download-Geschwindigkeit für Videos erhöht und sind zu dem Schluss gekommen, dass der Download parallelisiert werden muss. <br><br><h3>  TCP in instabilen Netzwerken </h3><br>  Ein unglaublicher Effekt mit Parallelität kann berührt werden.  Es reicht aus, einen Geschwindigkeitsmesser zum Empfangen / Senden von Daten (z. B. Geschwindigkeitstest) und Traffic Shaper (z. B. Network Link Conditioner, wenn Sie einen Mac haben) zu verwenden. Wir beschränken das Netzwerk auf 1-Mbit / s-Parameter zum Hoch- und Herunterladen und beginnen, den Paketverlust zu erhöhen. <br><br><img src="https://habrastorage.org/webt/lk/ki/j8/lkkij8appdgsvglvlp1rdt3em7s.jpeg"><br><br>  Die Tabelle zeigt RTT und Verluste.  Es ist ersichtlich, dass im Falle eines Verlusts von 0% das Netzwerk zu 100% ausgelastet ist. <br><br>  Bei der nächsten Iteration erhöhen wir den Paketverlust um 5% und sehen, dass das Netzwerk nur zu 74% ausgelastet ist.  Es scheint in Ordnung zu sein - bei einem Paketverlust von 5% gehen 26% des Netzwerks verloren.  Wenn Sie jedoch auch den Ping erhöhen, bleibt <strong>weniger als die Hälfte des Kanals</strong> übrig. <br><br><blockquote>  Wenn der Kanal eine hohe RTT und einen großen Paketverlust aufweist, nutzt eine TCP-Verbindung das Netzwerk nicht vollständig aus. </blockquote><br>  Ein weiterer Trick zeigt, dass Sie bei Verwendung paralleler TCP-Verbindungen (Sie können nur mehrere Geschwindigkeitstests gleichzeitig ausführen) das umgekehrte Wachstum der Kanalauslastung feststellen können. <br><br><img src="https://habrastorage.org/webt/co/n7/v_/con7v_t-dxmnrsxe6e0kkakbnwm.jpeg"><br><br>  Mit zunehmender Anzahl paralleler TCP-Verbindungen entspricht die Netzwerkauslastung fast dem Durchsatz abzüglich des Prozentsatzes der Verluste. <br><br>  So stellte sich heraus: <br><br><ul><li>  Drahtlose Mobilfunknetze haben gewonnen und sind instabil. </li><li>  TCP nutzt den Kanal in instabilen Netzwerken nicht vollständig aus. </li><li>  Der Verbrauch von Inhalten hängt von der Geschwindigkeit des Internets ab: Je höher die Geschwindigkeit des Internets, desto mehr Benutzer sehen zu, und wir lieben unsere Benutzer wirklich und möchten, dass sie mehr sehen. </li></ul><br>  Natürlich müssen Sie irgendwohin ziehen und Alternativen zu TCP in Betracht ziehen. <br><br><h2>  TCP gegen nicht TCP </h2><br>  Wie vergleiche ich die Wärme?  Es gibt zwei Möglichkeiten. <br><br>  Die erste Option - auf IP-Ebene gibt es TCP und UDP. Wir können uns ein anderes Protokoll von oben leisten.  Wenn Sie Ihr eigenes Protokoll parallel zu TCP und UDP starten, wissen Firewall, Brandmauer, Router und der Rest der Welt, die an der Paketzustellung beteiligt sind, offensichtlich nichts davon.  Infolgedessen müssen Sie jahrelang warten, bis alle Geräte aktualisiert sind und mit dem neuen Protokoll arbeiten. <br><br>  Die zweite Möglichkeit besteht darin, zusätzlich zu unzuverlässigem UDP ein eigenes zuverlässiges Datenübermittlungsprotokoll zu erstellen.  Natürlich können Sie lange warten, bis Linux, Android und iOS Ihrem Kernel ein neues Protokoll hinzufügen. Daher müssen Sie das Protokoll in den User Space schneiden. <br><br>  Diese Lösung scheint interessant zu sein, wir werden sie als selbst erstelltes UDP-Protokoll bezeichnen.  Um mit der Entwicklung zu beginnen, benötigen Sie nichts Besonderes: Öffnen Sie einfach den UDP-Socket und senden Sie die Daten. <br><br><img src="https://habrastorage.org/webt/zy/zt/sn/zyztsnsutwgufcqwlhxb6qslhpg.jpeg"><br><br>  Wir werden es entwickeln und untersuchen, wie das Netzwerk funktioniert. <br><br><h2>  TCP gegen selbst erstelltes UDP </h2><br>  Nun, und was zu vergleichen? <br><br>  Netzwerke sind unterschiedlich: <br><br><ul><li>  Bei Überlastung, wenn es viele Pakete gibt und einige von ihnen aufgrund einer Überlastung von Kanälen oder Geräten fallen. </li><li>  Hohe Geschwindigkeit mit großer Hin- und Rückfahrt (z. B. wenn der Server relativ weit entfernt ist). </li><li>  Seltsam - wenn im Netzwerk nichts zu passieren scheint, Pakete jedoch immer noch verschwinden, nur weil sich der Wi-Fi-Zugangspunkt hinter der Wand befindet. </li></ul><br>  Sie können Netzwerkprofile jederzeit selbst berühren: Wählen Sie das eine oder andere Profil auf Ihrem Telefon aus und führen Sie den Geschwindigkeitstest aus. <br><br><img src="https://habrastorage.org/webt/v1/0j/-p/v10j-p8absukvs6s4jn2ntd8qau.jpeg"><br><br>  Neben Netzwerkprofilen müssen Sie auch das Profil des Verkehrsverbrauchs ermitteln.  Hier sind die, die wir verwendet haben: <br><br><img src="https://habrastorage.org/webt/3k/dc/fb/3kdcfbeyhjpduwbumk1n1iz2-c0.jpeg"><br><br>  Da ich für das Video und den Stream verantwortlich bin, sind die Profile angemessen: <br><br><ul><li>  Profilvideo, wenn Sie diesen oder jenen Inhalt verbinden und streamen.  Die Verbindungsgeschwindigkeit erhöht sich wie in der oberen Grafik.  Anforderungen an dieses Protokoll: geringe Latenz und Bitratenanpassung. </li><li>  Option für die Bandansicht: Laden von Impulsdaten, Hintergrundabfragen, Ausfallzeiten.  Anforderungen an dieses Protokoll: Die empfangenen Daten werden gemultiplext und priorisiert, die Priorität des Benutzerinhalts ist höher als bei Hintergrundprozessen, der Download wird abgebrochen. </li></ul><br>  Natürlich müssen Sie die Protokolle auf dem beliebtesten HTTP vergleichen. <br><br><h3>  HTTP 1.1 und HTTP 2.0 </h3><br>  Der Standardstapel der 2000er Jahre sah aus wie HTTP 1.1 über SSL.  Der moderne Stack ist HTTP 2.0, TLS 1.3 und alles über TCP. <br><br><img src="https://habrastorage.org/webt/k9/yp/ng/k9ypngmth9i_4m8pqzx5n-kipf0.jpeg"><br><br>  Der Hauptunterschied besteht darin, dass HTTP 1.1 einen begrenzten Pool von Verbindungen im Browser zu einer Domäne verwendet, sodass eine separate Domäne für Bilder, Daten usw. erstellt wird.  HTTP 2.0 bietet eine Multiplexverbindung, über die alle diese Daten übertragen werden. <br><br><img src="https://habrastorage.org/webt/uo/aj/uu/uoajuubf2yfz_femlhzhvq6buty.jpeg"><br><br>  HTTP 1.1 funktioniert folgendermaßen: Anfrage stellen, Daten abrufen, Anfrage stellen, Daten abrufen. <br><br><img src="https://habrastorage.org/webt/1y/nv/xd/1ynvxdxpfkluduputf3szhfi75a.jpeg"><br><br>  Normalerweise ist ein Browser oder eine mobile Anwendung eine Kugel, dh eine Verbindung zum Empfangen von Bildern, Daten per API, und Sie führen gleichzeitig eine Anforderung für ein Bild, eine API, ein Video usw. aus. <br><br><img src="https://habrastorage.org/webt/cn/ub/kl/cnubklsdxjrcuwpamcckap5_uu8.jpeg"><br><br>  Das Hauptproblem ist der Wettbewerb.  Sie haben keine Kontrolle über die übermittelten Anfragen.  Sie verstehen, dass der Benutzer das Bild, das er durchgeblättert hat, nicht mehr benötigt, aber nichts mehr tun kann. <br><br><blockquote>  Mit HTTP 1.1 erhalten Sie immer noch das, was Sie angefordert haben. Es ist schwierig, den Download abzubrechen. </blockquote><br>  Die einzige Möglichkeit, die Verbindung zu schließen, besteht darin, die Verbindung zu schließen.  Dann werden wir sehen, warum das schlecht ist. <br><br><h3>  Unterschiede in HTTP 2.0 </h3><br>  HTTP 2.0 löst diese Probleme: <br><br><ul><li>  binäre Header-Komprimierung; </li><li>  Datenmultiplex; </li><li>  Priorisierung; </li><li>  Abbrechen des Downloads; </li><li>  Server Push </li></ul><br>  Betrachten wir wichtigere Punkte für uns. <br><br><img src="https://habrastorage.org/webt/tb/nl/ur/tbnlurtfdzcqaxpy6_hgcphtye0.jpeg"><br><br>  Fordern Sie ein Bild und eine API an.  Das Bild wird sofort gegeben, die API nach einer Weile vorbereitet.  Die API wurde gegeben - das Bild wurde bis zum Ende gegeben.  All dies geschieht transparent.  <strong>Inhalte mit hoher Priorität werden früher heruntergeladen.</strong> <br><br><img src="https://habrastorage.org/webt/gw/ws/wp/gwwswpducmtjv2huz9jprbhwpha.jpeg"><br><br>  <strong>Server-Push</strong> ist so etwas, wenn Sie nach etwas Bestimmtem wie einer API gefragt haben, aber selbst beim Laden auf dem Client wurden Bilder zwischengespeichert, die definitiv benötigt würden, um beispielsweise ein Band anzuzeigen. <br><br>  Es gibt auch einen Befehl zum <strong>Zurücksetzen des Streams</strong> , den der Browser selbst ausführt, wenn Sie zwischen Seiten usw. wechseln.  Für einen mobilen Client können Sie mit seiner Hilfe den Empfang von Daten verweigern, ohne die Verbindung zu verlieren. <br><br>  Daher werden wir TCP auf verschiedene vergleichen: <br><br><ul><li>  Netzwerkprofile: Wi-Fi, 3G, LTE. </li><li>  Verbrauchsprofile: Streaming (Video), Multiplexing und Priorisierung mit Abbrechen des Downloads (HTTP / 2), um den Inhalt des Bandes zu empfangen. </li></ul><br><h3>  Verlustfreies Modell </h3><br>  Beginnen wir den Vergleich mit einem einfachen Netzwerk, in dem es nur zwei Parameter gibt: Roundtrip-Zeit und Bandbreite. <br><br>  <b>RTT</b> ist Ping, die Bearbeitungszeit eines Pakets, der Empfang der Bestätigung oder die Antwortechozeit. <br><br>  Um die <b>Bandbreite</b> - die Netzwerkbandbreite - zu messen, senden wir ein Paket von Paketen und zählen die Anzahl der übertragenen Pakete in einem bestimmten Zeitintervall. <br><br><img src="https://habrastorage.org/webt/6r/du/2l/6rdu2lwrhgztjekbwsfgvtuwdec.jpeg"><br><br>  Da wir mit zuverlässigen Protokollen arbeiten, gibt es natürlich eine Bestätigung - wir senden Pakete und erhalten eine Empfangsbestätigung. <br><br><h3>  Das Problem des langsamen Internets </h3><br>  Zu Beginn der Entwicklung unseres Videodienstes im Jahr 2013 ging mein Freund nach Kalifornien und beschloss, eine neue Serie seiner Lieblingsserien auf Odnoklassniki anzusehen.  Er hatte eine 250 ms RTT, perfektes Wi-Fi 400 Mbit / s auf dem Google-Campus, er wollte die neue Serie in FullHD sehen. <br><br>  Glaubst du, er konnte das Video sehen?  Die Antwort hängt von der Konfiguration des Sende- / Empfangspuffers auf unseren Servern ab. <br><br><img src="https://habrastorage.org/webt/qf/sk/qj/qfskqjvyygm-klersirdlmfdreo.jpeg"><br><br>  Da wir ein Protokoll mit Bestätigung haben, werden alle Daten, die keine Zustellbestätigung erhalten haben, in einem Puffer gespeichert.  Wenn der Sendepuffer auf 128 KB begrenzt ist, sind diese 128 KB geringer als bei RTT. Wir können nicht senden.  Somit verbleiben aus unserem Netzwerk von 400 Mbit / s 4 Mbit / s.  Dies reicht nicht aus, um Online-Videos in FullHD anzusehen. <br><br>  Dann habe ich die Größe des Puffers erhöht und mir angesehen, wie sich die Ausgabegeschwindigkeit eines Videosegments in Abhängigkeit von der Änderung der Puffergröße wirklich ändert.  Machen Sie sofort eine Reservierung, dass der Recv-Puffer automatisch eingestellt wurde, d. H.  Was der Server gesendet hat, konnte der Client immer akzeptieren. <br><br><img src="https://habrastorage.org/webt/vj/yi/ef/vjyiefcatf55inm_ka-0b1vpake.jpeg"><br><br><blockquote>  Ein offensichtliches TCP-Rezept: Wenn Sie Hochgeschwindigkeitsdaten über große Entfernungen übertragen, müssen Sie den Sendepuffer erhöhen. </blockquote><br>  Alles scheint in Ordnung zu sein.  Sie können zum Dienst fast.com gehen, der die Geschwindigkeit Ihres Internets zu Netflix-Servern misst.  Aus dem Büro bekam ich eine Geschwindigkeit von 210 Mbit / s.  Und dann habe ich durch Net Shaper die Bedingungen für die Aufgabe festgelegt und bin wieder auf diese Seite gegangen.  Magie - Ich habe genau 4 Mbit / s. <br><br><img src="https://habrastorage.org/webt/xx/sl/nr/xxslnr1m5syfgyludnghfp7d6yw.jpeg"><br><br>  Egal wie ich es verdrehe, Netflix hat es nicht geschafft, einen Puffer größer als 128 KB zu bekommen. <br><br><h3>  Puffergröße </h3><br>  Um die optimale Puffergröße zu ermitteln, müssen Sie die On-the-Fly-Pakete verstehen. <br><br><img src="https://habrastorage.org/webt/cl/ym/ws/clymwsmlyixceklwgevvv00izru.jpeg"><br><br>  Es gibt einen Netzwerkstatus: <br><br><ul><li>  Pakete 1 und 2 wurden bereits gesendet, eine Bestätigung wurde für sie empfangen; </li><li>  Pakete 3, 4, 5, 6 wurden gesendet, aber das Zustellergebnis ist unbekannt (On-the-Fly-Pakete); </li><li>  andere Pakete befinden sich in der Warteschlange. </li></ul><br><img src="https://habrastorage.org/webt/if/oh/m0/ifohm0lal6uotlodse6vrehnoqc.jpeg"><br><br>  Wenn die Anzahl der Pakete in On-the-Fly der Größe des Puffers entspricht, ist sie nicht groß genug.  In diesem Fall ist das Netzwerk ausgehungert und nicht vollständig ausgelastet. <br><br>  Die umgekehrte Situation ist möglich - der Puffer ist zu groß.  In diesem Fall quillt der Puffer auf.  Warum ist das so schlimm? <br><br><img src="https://habrastorage.org/webt/m1/4y/fk/m14yfka8426esfgz8a8xeglxko4.jpeg"><br><br>  Wenn wir über Datenmultiplex sprechen und mehrere Anforderungen gleichzeitig senden, z. B. Bilder in derselben Verbindung und API, dann schwillt der Puffer an, wenn das gesamte riesige Megabyte-Bild in den Puffer gelangt und wir versuchen, auch die API mit hoher Priorität zu stopfen.  Sie müssen sehr lange warten, bis das Bild verschwindet. <br><br>  Eine einfache Lösung besteht darin, die Puffergröße automatisch anzupassen.  Jetzt ist es auf vielen Clients verfügbar und funktioniert in etwa so. <br><br><img src="https://habrastorage.org/webt/pm/dj/rj/pmdjrjtekrknmzgogzn6bzkgplq.jpeg"><br><br>  Wenn jetzt viele Pakete gesendet werden können, erhöht sich der Puffer, die Datenübertragung beschleunigt sich, die Größe des Puffers wächst, alles scheint großartig zu sein. <br><br>  Aber es gibt ein Problem.  Wenn der Puffer vergrößert wurde, kann er nicht so einfach reduziert werden.  Dies ist eine schwierigere Aufgabe.  Wenn die Geschwindigkeit nachlässt, tritt die gleiche Pufferquellung auf.  Der Puffer ist ziemlich groß und voll. Wir müssen warten, bis alle Daten an den Client gesendet wurden. <br><br>  Wenn wir unser eigenes UDP-Protokoll schreiben, ist alles sehr einfach - wir haben Zugriff auf den Puffer. <br><br><img src="https://habrastorage.org/webt/ow/lz/5m/owlz5m0em5dqvtz3ni14pgc3khm.jpeg"><br><br>  Wenn TCP in solchen Situationen einfach Daten am Ende hinzufügt und Sie nichts tun können, können Sie in einem selbst erstellten Protokoll Daten beispielsweise unmittelbar nach On-the-Fly-Paketen weiterleiten. <br><br>  Und wenn Abbrechen kommt und der Client sagt, dass dieses Bild nicht mehr benötigt wird, benötigt er die API-Daten, er hat den Inhalt weiter gescrollt, Sie können all dies aus dem Puffer werfen und das erforderliche senden. <br><br>  Wie wird das gemacht?  Es ist bekannt, dass Sie zum Wiederherstellen von Paketen, Verwalten der Zustellung und Empfangen von Bestätigungen eine Sequenz-ID von Paketen benötigen.  Sequence_id Wir werden nur für On-the-Fly-Pakete geschrieben, dh wir geben sie nur aus, wenn wir Pakete senden.  Alles andere im Puffer kann beliebig verschoben werden, bis die Pakete verschwunden sind. <br><br>  <strong>Fazit:</strong> Der TCP-Puffer muss korrekt konfiguriert sein, das Gleichgewicht abfangen, um nicht an das Netzwerk zu stoßen und den Puffer nicht aufzublasen.  Für Ihr eigenes UDP-Protokoll ist alles einfach - dies kann gesteuert werden. <br><br><h3>  Verlustbehaftetes Netzwerkmodell </h3><br>  Wir bewegen uns auf eine höhere Ebene, das Netzwerk wird etwas komplizierter, Paketverlust tritt darin auf.  Für Mobilfunknetze ist dies eine häufige Situation.  Einige der gesendeten Pakete erreichen den Client nicht.  Der Standard-Wiederherstellungsalgorithmus für die erneute Übertragung funktioniert ungefähr so: <br><br><img src="https://habrastorage.org/webt/tg/z7/tv/tgz7tvr6zchscr49onnqepvjvje.jpeg"><br><br>  Sendet Pakete, denn jedes Paket erhält eine Bestätigung.   Retransmit timeout (RTO)  RTT     ,   . <br><br>     TCP,    5% ,     50%. <br><br><img src="https://habrastorage.org/webt/ob/vi/qf/obviqfawoiesuiex2yqf_idbvei.jpeg"><br><br>  retransmit,    ,      .    ,  ,   Congestion control. <br><br><h3> Congestion control </h3><br>      flow control,    . <br><br><img src="https://habrastorage.org/webt/bc/3k/g9/bc3kg9sb5k5sppttampxxaeaypu.jpeg"><br><br><ul><li> <b>Flow control</b> —      .  ,           ,      .    flow control  recv window,      .  flow control —  back pressure  ,    -    . </li><li>  <b>congestion control</b>   .  ,   —    . </li></ul><br><img src="https://habrastorage.org/webt/mf/b5/9d/mfb59d5xp1ph_irk_rhkckjpbew.jpeg"><br><br>   ,     :  ,    ,    ,      .        ,     congestion control. <br><br>    TCP window. <br><br><img src="https://habrastorage.org/webt/tj/u0/9s/tju09sic8asow88ehlwsuyfjj6q.jpeg"><br><br>     flow control  congestion control,       . <br><br>  Beispiele: <br><br><ul><li>  TCP window = 1,       :  acknowledgement,     .. </li><li>  TCP window = 4,       ,  acknowledgement   . </li></ul><br>    ,    .  initial window  TCP = 10. <br><br><img src="https://habrastorage.org/webt/ar/jf/ja/arjfjayzxewtfl-iulsna677qa0.jpeg"><br><br>    ,  ,        . <br><br>     ? <br><br><img src="https://habrastorage.org/webt/yj/ck/_t/yjck_tpkuuze0pjmkdb5mhfrlri.jpeg"><br><br><ul><li>    ,    .     ,      . </li><li>      :   , acknowledgements   . </li><li>            -    , acknowledgements      ( ). </li></ul><br>       . <br><br><img src="https://habrastorage.org/webt/jp/6c/di/jp6cdirmtiqosalz9vw-mvkjkei.jpeg"><br><br>   ,    ,   .     :     ,     ..    ,      .   congestion control,  TCP window,    ,    . <br><br><img src="https://habrastorage.org/webt/__/w0/zg/__w0zgqdiycta2u7yla0svmhof4.jpeg"><br><br>     congestion control,   ,   —   .      packet loss —  ,   .        ,   ,         —    ,    . <br><br> ,  TCP , ,   congestion control   loss-.    congestion control  loss delay,     ,   . <br><br><img src="https://habrastorage.org/webt/44/no/5k/44no5kuc601zfx2h8dm_kwoqete.jpeg"><br><br> : <br><br><ul><li> <b>Cubic</b> —  Congestion Control  Linux 2.6.        :   —  . </li><li> <b>BBR</b> —   Congestion Control,    Google  2016 .   . </li></ul><br><h3> BBR Congestion Control </h3><br>   Cubic  BBR   feedback. <br><br><img src="https://habrastorage.org/webt/7u/5z/zr/7u5zzrcv5cr3eyywvi0ui75qxr8.jpeg"><br><br>       ,      —   acknowledgement       .   : <br><br><ul><li> BBR ,    ,    ,    . </li><li> Cubic        . </li></ul><br>  Unten sehen Sie eine grafische Darstellung der Verzögerung gegenüber der Verbindungszeit, die zeigt, was bei verschiedenen Überlastungssteuerungen geschieht. <br><br><img src="https://habrastorage.org/webt/xn/l5/c_/xnl5c_gfgpby_vchj-lt5ftptta.jpeg"><br><br>  Der BBR erfasst zuerst die Umlaufzeit, sendet immer mehr Pakete, stellt dann fest, dass der Puffer verstopft ist, und wechselt mit minimaler Verzögerung in den Betriebsmodus. <br><br>  Cubic arbeitet aggressiv - es läuft über den gesamten Puffer, und wenn der Puffer überläuft und Paketverlust auftritt, reduziert Cubic das Fenster. <br><br>  Es scheint, dass es mit Hilfe von BBR möglich wäre, alle Probleme zu lösen, aber es gibt <strong>Jitter</strong> in den Netzwerken - Pakete werden manchmal verzögert, manchmal in Bündeln gruppiert.  Sie senden sie mit einer bestimmten Häufigkeit und sie kommen in Gruppen.  Schlimmer noch, wenn Sie Bestätigungen zurück zu diesen Paketen erhalten, und sie auch irgendwie "jitter". <br><br>  Da ich versprochen habe, dass alles von Hand berührt werden kann, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pingen</a> wir zum Beispiel die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++ -</a> Site an, schauen uns Ping an und betrachten Jitter zwischen Paketen. <br><br><img src="https://habrastorage.org/webt/be/pu/fj/bepufjz6mtygfhqppfkeyvi3phq.jpeg"><br><br>  Es ist ersichtlich, dass die Pakete ungleichmäßig kommen, der durchschnittliche Jitter beträgt ca. 50 ms.  Natürlich kann BBR falsch sein. <br><br>  BBR ist gut, weil es unterscheidet zwischen: echtem Überlastungsverlust, Paketverlust aufgrund von Gerätepufferüberläufen und zufälligem Verlust aufgrund eines schlechten drahtlosen Netzwerks.  Bei hohem Jitter funktioniert es jedoch nicht gut.  Wie kann ich ihm helfen? <br><br><h3>  So verbessern Sie die Überlastungskontrolle </h3><br>  Tatsächlich hat TCP nicht genügend Informationen zur Bestätigung, sondern nur die Pakete, die es gesehen hat.  Es gibt auch eine selektive Bestätigung, die besagt, welche Pakete bestätigt wurden, welche noch nicht angekommen sind.  Diese Informationen reichen jedoch nicht aus. <br><br><img src="https://habrastorage.org/webt/fs/9j/gm/fs9jgmfd67brdk7wynu6sqjprk8.jpeg"><br><br>  Wenn Sie die Möglichkeit haben, die Bestätigung aufzublähen, können Sie trotzdem die ganze Zeit sparen - nicht nur diese Pakete senden, sondern auch beim Client ankommen.  Das ist in der Tat auf dem Server, um den Jitter-Client zu sammeln. <br><br>  Warum ist es im Allgemeinen effektiv, die Bestätigung zu erhöhen?  Weil Mobilfunknetze asymmetrisch sind.  Beispielsweise werden normalerweise mit 3G oder LTE 70% der Bandbreite für das Herunterladen von Daten und 30% für das Hochladen zugewiesen.  Der Sender wechselt: Upload - Download, Upload - Download, und Sie haben keinerlei Auswirkungen darauf.  Wenn Sie nichts entladen, ist es einfach im Leerlauf.  Wenn Sie also interessante Ideen haben, erhöhen Sie die Anerkennung, seien Sie nicht schüchtern - dies ist kein Problem. <br><br><img src="https://habrastorage.org/webt/cv/0t/gd/cv0tgdq9vzirpmrvzx4optqe0ik.jpeg"><br><br>  Ein Beispiel dafür, wie Sie mithilfe einer Bestätigung den Jitter in Senden und Empfangen in Jitter unterteilen und separat verfolgen können.  Dann werden wir flexibler und verstehen, wann ein Überlastungsverlust aufgetreten ist und wann ein zufälliger Verlust aufgetreten ist.  Sie können beispielsweise verstehen, wie viel Jitter in jeder Richtung vorhanden ist, und das Fenster genauer konfigurieren. <br><br><img src="https://habrastorage.org/webt/ti/qj/zk/tiqjzkihljlcb2pn2oj-wdlbmkq.jpeg"><br><br><h3>  Welche Überlastungskontrolle soll man wählen? </h3><br>  Klassenkameraden sind ein großes Netzwerk mit viel unterschiedlichem Verkehr: Video, API, Bilder.  Und es gibt Statistiken, für die die Überlastungskontrolle besser zu wählen ist. <br><br>  BBR ist für Videos immer effektiv, da es Verzögerungen reduziert.  In anderen Fällen wird normalerweise Cubic verwendet - es ist gut für Fotos.  Es gibt aber auch andere Möglichkeiten. <br><br><img src="https://habrastorage.org/webt/9m/ea/gd/9meagdum2m9dvmtn4eeawrmbtay.jpeg"><br><br>  Es gibt Dutzende verschiedener Optionen zur Überlastungskontrolle.  Um die beste auszuwählen, können Sie Statistiken auf dem Client sammeln und die eine oder andere Überlastungskontrolle für verschiedene Arten von Lastprofilen ausprobieren. <br><br>  Dies ist beispielsweise der Effekt des Startens von BBR für ein Video. <br><br><img src="https://habrastorage.org/webt/hy/h8/dh/hyh8dhiugrgtyl6vgaozjzitnxq.jpeg"><br><br>  Wir haben es geschafft, die Betrachtungstiefe ernsthaft zu erhöhen.  Google sagt, dass der Player bei Verwendung von BBR etwa 10% weniger Puffer enthält. <br><br>  Großartig, aber was ist mit unseren Kunden? <br><br><img src="https://habrastorage.org/webt/np/m1/uy/npm1uywvt78qoudkof3mkebqrj8.jpeg"><br><br>  Kunden sind etwas langsam, sie haben alle Cubic und Sie können es nicht beeinflussen.  Aber es ist okay, manchmal können Sie Daten parallelisieren, und es wird gut sein. <br><br>  <strong>Schlussfolgerungen zur Überlastungskontrolle:</strong> <br><br><ul><li>  BBR ist immer gut für Videos. </li><li>  In anderen Fällen können Sie die Überlastungskontrolle mitnehmen, wenn wir unser eigenes UDP-Protokoll verwenden. </li><li>  Aus TCP-Sicht können Sie nur die Überlastungskontrolle verwenden, die sich im Kernel befindet.  Wenn Sie Ihre Überlastungskontrolle im Kernel implementieren möchten, müssen Sie die TCP-Spezifikation einhalten.  Es ist unmöglich, die Bestätigung zu erhöhen, Änderungen vorzunehmen, weil sie einfach nicht auf dem Client liegen. </li></ul><br><blockquote>  Wenn Sie Ihr UDP-Protokoll erstellen, haben Sie viel mehr Freiheit bei der Überlastungskontrolle. </blockquote><br><h3>  Multiplexing und Priorisierung </h3><br>  Dies ist ein neuer Trend, jeder macht es jetzt.  Welche Probleme gibt es?  Wenn wir TCP verwenden, kennt sicherlich jeder (oder fast jeder) die Head-of-Line-Blockierungssituation. <br><br><img src="https://habrastorage.org/webt/zv/rt/6t/zvrt6t3igpnzn4vea3lgdw7vb1e.jpeg"><br><br>  Es gibt mehrere Anforderungen, die über eine einzelne TCP-Verbindung gemultiplext werden.  Wir haben sie an das Netzwerk gesendet, aber ein Paket fehlte.  Eine TCP-Verbindung überträgt dieses Paket erneut, und zwar in einer Zeit nahe RTT oder länger.  Derzeit können wir nichts abrufen, obwohl der TCP-Puffer Daten von einer anderen Anforderung enthält, die vollständig zur Abholung bereit ist. <br><br><blockquote>  Es stellt sich heraus, dass Multiplexing über TCP, wenn Sie HTTP 2.0 verwenden, in schlechten Netzwerken nicht immer effektiv ist. </blockquote><br>  Das nächste Problem ist die Pufferquellung. <br><br><img src="https://habrastorage.org/webt/fy/zh/rw/fyzhrwlr4mmtdgxwhp-mxfa9k-y.jpeg"><br><br>  Wenn ein Bild an den Client gesendet wird, erhöht sich der Puffer.  Wir senden es für eine lange Zeit, und dann erscheint eine API-Anfrage, die in keiner Weise priorisiert werden kann.  In solchen Fällen funktioniert die TCP-Priorisierung nicht. <br><br>  Wenn also ein Paketverlust auftritt, kommt es zu einer Head-of-Line-Blockierung, und wenn der Client eine variable Bitrate hat (und dies passiert häufig bei mobilen Clients), wird der Bufferbloat-Effekt angezeigt.  Infolgedessen funktionieren weder Multiplexing noch Priorisierung noch Server-Push oder alles andere, da wir entweder Puffer haben oder der Client etwas erwartet. <br><br>  Wenn wir unser eigenes Multiplexing durchführen, können wir dort verschiedene Daten ablegen. <br><br><img src="https://habrastorage.org/webt/_g/er/5g/_ger5gqpdxllo3-p1eo7ytzupce.jpeg"><br><br>  Dies ist nicht schwierig, fügen Sie einfach Pakete mit Zahlen zum Puffer hinzu.  On-the-Fly - Berühren Sie nicht, was bereits gesendet wurde, aber was noch nicht gesendet wurde, kann neu angeordnet werden.  Es sieht so aus. <br><br><img src="https://habrastorage.org/webt/9g/_v/xr/9g_vxrrlkavxucnmocy3kggc-f8.jpeg"><br><br>  Sie haben Bilder gesendet, sie in Pakete aufgeteilt, eine vorrangige API-Anfrage gestellt: Sie haben sie eingefügt und das Bild gesendet.  Selbst wenn ein Paket fehlt, können wir eine vorgefertigte API-Anfrage aus dem Puffer erhalten. Diese hat hohe Priorität und erreicht schnell den Client.  In TCP ist per Definition keine Streaming-Datenübertragung möglich. <br><br><h3>  Stellen Sie eine Verbindung her </h3><br>  Wenn wir unsere Anwendung profilieren, werden wir feststellen, dass das Netzwerk zu Beginn der Anwendung die meiste Zeit inaktiv ist, da die Verbindung zuerst vor der API hergestellt wird, dann die Daten abgerufen werden und die Verbindung vor den Bildern hergestellt wird, diese Daten heruntergeladen werden usw.  Dies geschieht immer - das Netzwerk wird von Spitzen genutzt. <br><br><img src="https://habrastorage.org/webt/14/cn/ck/14cnckztbu1v-otwf__j9dqzahu.jpeg"><br><br>  Lassen Sie uns sehen, wie die Verbindung hergestellt wird, um damit umzugehen. <br><br><img src="https://habrastorage.org/webt/ca/eb/ij/caebijcqzlqj0h5soblnfudqedo.jpeg"><br><br>  Das erste ist DNS auflösen - wir können damit nichts anfangen.  Stellen Sie als Nächstes eine TCP-Verbindung her, stellen Sie eine sichere Verbindung her, führen Sie die Anforderung aus und erhalten Sie eine Antwort.  Das Interessanteste ist, dass ein Teil der Arbeit, die der Server bei der Beantwortung einer Anfrage leistet, normalerweise weniger Zeit in Anspruch nimmt als das Herstellen einer Verbindung. <br><br>  Jetzt ist es sehr modern, Latenzzahlen für Speicher, Festplatten und etwas anderes zu messen.  Sie können sie für ein 3G-, 4G-Netzwerk messen und sehen, wie lange es im schlimmsten Fall dauert, eine TCP-Verbindung mit TLS herzustellen. <br><br><img src="https://habrastorage.org/webt/qe/ux/1p/qeux1p7brp9mvpxeptinhubywmc.jpeg"><br><br>  Und es kann Sekunden sein!  Auch bei 4G sind bis zu 700 ms von Bedeutung.  Aber TCP konnte die ganze Zeit nicht so einfach leben. <br><br>  Die Verbindung basiert auf dem grundlegenden <strong>TCP-3-Wege-Handshake-</strong> Algorithmus.  Führen Sie syn, syn + ack aus und korrigieren Sie die Anforderung später (links im Diagramm). <br><br><img src="https://habrastorage.org/webt/ty/mj/-a/tymj-amfsa1c4j8sirtaspnvq1o.jpeg"><br><br>  Es gibt <strong>TCP Fast Open</strong> (rechts).  Wenn Sie bereits mit diesem Server von Hand geschüttelt haben, gibt es ein Cookie. Sie können Ihre Anfrage für Zero-RTT sofort senden.  Um dies zu verwenden, müssen Sie einen Socket erstellen, sendto () zu den ersten Daten machen und sagen, dass Sie FASTOPEN möchten. <br><br><img src="https://habrastorage.org/webt/ab/kl/b9/abklb93dq3g__tw2rihxrhagkl8.jpeg"><br><br>  Nginx kann all dies - schalten Sie es einfach ein, alles wird funktionieren (oder schalten Sie es im Kernel ein). <br><br><h2>  TLS </h2><br>  Lassen Sie uns überprüfen, ob TLS schlecht ist. <br><br>  Ich stellte den Net Shaper erneut für 200 ms ein, pingte google.com und sah, dass RTT = 220 mein RTT + RTT Shaper ist.  Dann habe ich eine Anfrage über HTTP und HTTPS gestellt.  Ich habe herausgefunden, dass es über HTTP möglich ist, während RTT eine Antwort zu erhalten, dh TFO funktioniert für Google von meinem Computer aus.  Bei HTTPS dauerte dies länger. <br><br><img src="https://habrastorage.org/webt/po/hl/kj/pohlkjs39dl7kk3rp5kzbxrwsna.jpeg"><br><br>  Dies ist ein so häufiger TLS-Overhead, für den Messaging erforderlich ist, um eine sichere Verbindung herzustellen. <br><br><img src="https://habrastorage.org/webt/zf/j2/qn/zfj2qndcohpiok8cqpc82kiun3s.jpeg"><br><br>  Um dies zu tun, haben sie für uns gedacht, TLS 1.3 hinzugefügt.  Es ist auch einfach, in Nginx aufzunehmen. <br><br><img src="https://habrastorage.org/webt/m5/eo/i0/m5eoi0z5a2rzb4hthqlbjchxhyi.jpeg"><br><br>  Alles scheint zu funktionieren.  Aber mal sehen, was auf unseren mobilen Clients ist, die all dies nutzen. <br><br><h3>  Was ist mit Kunden los? </h3><br>  TCP Fast Open ist eine coole Sache.  Laut Statistik. <br><br><img src="https://habrastorage.org/webt/pq/yy/l8/pqyyl89jhtoulpwalg61q8pqbnw.jpeg"><br><br>  Es gibt viele Artikel, die besagen, dass das Herstellen einer Verbindung garantiert 10% schneller verläuft.  Aber auf Android 8.1.0 (ich habe verschiedene Geräte gesehen) hat niemand TFO.  Unter Android 9 habe ich TFO auf dem Emulator gesehen, aber nicht auf echten Geräten.  IOS ist ein bisschen besser.  Hier können Sie es sehen: <br><br><pre><code class="plaintext hljs">sysctl -a | grep fast net.ipv4.tcp_fastopen = 0</code> </pre> <br>  Warum ist das passiert?  TCP Fast Open wurde bereits 2014 vorgeschlagen, jetzt ist es bereits ein Standard, es wird unter Linux unterstützt und alles ist großartig.  Es gibt jedoch ein derartiges Problem, dass der TFO-Handshake in einigen Netzwerken auseinanderzufallen begann.  Dies liegt daran, dass einige Anbieter (oder einige Geräte) es gewohnt sind, TCP zu überprüfen und ihre Optimierungen vorzunehmen, und nicht damit gerechnet haben, dass es zu einem TFO-Handshake kommt.  Daher hat die Implementierung so viel Zeit in Anspruch genommen, und bis jetzt enthalten mobile Clients sie standardmäßig nicht, zumindest nicht Android. <br><br>  Mit TLS 1.3, das uns verspricht, dass der Aufbau einer Null-RTT-Verbindung noch besser ist.  Ich habe keine Android-Geräte gefunden, auf denen es funktionieren würde.  Deshalb hat Facebook die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fizz-</a> Bibliothek erstellt.  Vor ein paar Monaten wurde es in Open Source verfügbar. Sie können es mit sich ziehen und TLS 1.3 verwenden.  Es stellt sich heraus, dass sogar Sicherheit mitgeschleppt werden muss, nichts erscheint im Kern davon. <br><br><img src="https://habrastorage.org/webt/07/qm/kf/07qmkfwywo3llz5nrrh04kg3a_o.jpeg"><br><br>  Das Diagramm zeigt die Verwendung verschiedener Android-Versionen durch unsere mobilen Clients.  V 9.x ist ziemlich viel - wo TFO erscheinen kann und TLS1.3 nirgendwo anders zu finden ist. <br><br>  <strong>Schlussfolgerungen zum Herstellen einer Verbindung:</strong> <br><br><ul><li>  TFO ist für 95% der Geräte nicht verfügbar. </li><li>  TLS1.3 muss mitgebracht werden. </li><li>  Wenn Sie dies in UDP wiederholen müssen, übertragen Sie dies alles auf UDP und wiederholen Sie den Vorgang. </li></ul><br><img src="https://habrastorage.org/webt/n2/tj/v1/n2tjv1g-04l2jfghy_6--uqaqjc.jpeg"><br><br>  Es stellte sich heraus, dass 97% der erstellten Verbindungen den vorhandenen Schlüssel verwenden, dh 97% werden für RTT Null erstellt und nur 3% sind neu.  Der Schlüssel ist einige Zeit auf dem Gerät gespeichert. <br><br>  TCP kann nicht damit prahlen.  In maximal 5% der Fälle können Sie, wenn Sie alles richtig machen, die echte Null-RTT erhalten, über die jetzt alle sprechen. <br><br><h2>  Änderung der IP-Adresse </h2><br>  Wenn Sie das Haus verlassen, wechselt Ihr Telefon häufig von Wi-Fi zu 4G. <br><br><blockquote>  TCP funktioniert folgendermaßen: Die IP-Adresse hat sich geändert - die Verbindung ist fehlgeschlagen. </blockquote><br><img src="https://habrastorage.org/webt/km/nu/u8/kmnuu8dtr8jeipuzx4bhpfezuwm.jpeg"><br><br>  Wenn Sie Ihr UDP-Protokoll schreiben, ist es sehr einfach, indem Sie in jedem Paket eine Verbindungs-ID (CUID) implementieren. Sie können es identifizieren, auch wenn es von einer anderen IP-Adresse stammt. <br><br><img src="https://habrastorage.org/webt/xu/ga/r_/xugar_l9pbltv6419btnrimfhv8.jpeg"><br><br>  Es ist klar, dass Sie sicherstellen müssen, dass es den richtigen Schlüssel hat, alles entschlüsselt ist usw.  Aber im Prinzip können Sie auf diese Adresse antworten, es wird keine Probleme damit geben. <br><br><blockquote>  In TCP ist die IP-Migration unmöglich. </blockquote><br>  Wenn Sie Ihr UDP erstellen und zum selben Server gekommen sind, müssen Sie ein wenig zaubern, die CID in jedes Paket aufnehmen und die hergestellte Verbindung beim Ändern der IP-Adresse verwenden. <br><br><h2>  Wiederverwendung der Verbindung </h2><br>  Jeder sagt, dass Sie Verbindungen wiederverwenden müssen, weil Verbindungen eine sehr teure Sache sind. <br><br><img src="https://habrastorage.org/webt/8-/lr/ot/8-lrot44ac9mwo6m7ue_ksezk0g.jpeg"><br><br>  Die Wiederverwendung von Verbindungen birgt jedoch Fallstricke. <br><br><img src="https://habrastorage.org/webt/_n/aa/z3/_naaz3uac-hwdd7uikndioiupry.jpeg"><br><br>  Wahrscheinlich erinnern sich viele Leute (wenn nicht, dann sehen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ), dass nicht jeder öffentliche Adressen hat, aber es gibt NAT, das normalerweise die Zuordnung für einige Zeit auf dem Heimrouter speichert.  Für TCP ist klar, wie viel gespeichert werden soll, für UDP ist jedoch nicht klar.  NAT arbeitet mit einem Timeout. Wenn Sie dieses Timeout sorgfältig messen, stellen wir fest, dass in etwa 15 bis 30 Sekunden mehr als 50% der Verbindungen ausfallen. <br><br>  Es ist okay - wir machen für 15 s ein Ping-Pong-Paket.  In Fällen, in denen die Verbindung immer noch unterbrochen ist, gibt es eine IP-Migration, mit der Sie den Port des Routers kostengünstig ändern können. <br><br><img src="https://habrastorage.org/webt/7g/mu/bf/7gmubflfj-yenwqvgiqbkc8toa8.jpeg"><br><br><h2>  Paketstimulation </h2><br>  Dies ist sehr wichtig, wenn Sie Ihr UDP-Protokoll ausführen. <br><br><img src="https://habrastorage.org/webt/cf/d5/97/cfd597jt4v7uopygyyu-dfsx_8s.jpeg"><br><br>  Wenn dies sehr einfach ist, ist die Wahrscheinlichkeit eines Paketverlusts umso größer, je länger Sie kontinuierlich Pakete an das Netzwerk senden.  Wenn Sie Pakete herausfiltern, ist der Paketverlust geringer. <br><br>  Es gibt viele verschiedene Theorien, wie das funktioniert, aber ich mag diese. <br><br><img src="https://habrastorage.org/webt/75/79/xl/7579xlvo70vmotoqjjp3zmmplr8.jpeg"><br><br>  Es gibt 3 Verbindungen, die gleichzeitig erstellt werden.  Sie haben das sogenannte Anfangsfenster - 10 Pakete gleichzeitig erstellt.  Natürlich reicht die Bandbreite zu diesem Zeitpunkt möglicherweise nicht aus.  Wenn Sie sie jedoch sorgfältig verteilen und trennen, ist alles in Ordnung, wie in der richtigen Abbildung dargestellt. <br><br>  Wenn Sie also eine einheitliche Rate für das Senden von Paketen festlegen und diese ausdünnen, wird die Wahrscheinlichkeit eines gleichzeitigen Pufferüberlaufs geringer.  Dies ist nicht bewiesen, aber theoretisch sieht es so aus. <br><br><img src="https://habrastorage.org/webt/vw/mg/vw/vwmgvw6oyq3v_yaliklp4ilnocm.jpeg"><br><br>  Wenn Sie Pakete durchschneiden müssen (Schritt machen): <br><br><ul><li>  Wenn Sie ein Fenster erstellen. </li><li>  Wenn Sie beispielsweise das Fenster vergrößern, wird empfohlen, so viele Pakete hinzuzufügen, wie für RTT / 2 gesendet werden können.  Dies verkürzt die Lieferzeit nicht, verringert jedoch den Paketverlust. </li><li>  Im Falle eines Überlastungsverlusts müssen Sie die Pakete noch mehr verschmieren, um das Fenster zu verkleinern.  4/5 RTT ist eine empirisch ausgewählte Zahl. </li></ul><br><h2>  MTU </h2><br>  Denken Sie beim Schreiben Ihres UDP-Protokolls unbedingt an MTU.  MTU ist die Größe der Daten, die Sie weiterleiten können. <br><br><img src="https://habrastorage.org/webt/c2/7_/ow/c27_ow36h5amg3d4zkskjph_ama.jpeg"><br><br>  Wir senden beispielsweise Pakete vom Server an den Client mit einer Größe von 1500. Wenn sich auf dem Pfad ein Router befindet, der diese MTU-Größe nicht unterstützt, wird er fragmentiert.  Das einzige Fragmentierungsproblem besteht darin, dass bei einem Verlust eines Pakets beide verloren gehen und all dies erneut übertragen werden muss.  Daher verfügt TCP über einen Algorithmus zur Bestimmung von MTU - PMTU. <br><br><img src="https://habrastorage.org/webt/je/gs/ks/jegskszkwrb3pm2nghgfpplez8o.jpeg"><br><br>  Jeder Router betrachtet die MTU seiner Schnittstelle, sendet sie an einen Client, der andere sendet sie an seinen Client, jeder weiß, wie viele MTUs er auf dem Client hat.  Dann wird die Fragmentierung durch das Flag verhindert und Pakete der Größe MTU werden gesendet.  Wenn in diesem Moment jemand im Netzwerk feststellt, dass er weniger MTU hat, sagt er über ICMP: "Entschuldigung, das Paket ist verloren gegangen, weil eine Fragmentierung erforderlich ist" und gibt die Größe der MTU an.  Wir werden diese Größe ändern und den Versand fortsetzen.  Im schlimmsten Fall ist unser kleiner Overhead RTT / 2.  Dies ist in TCP. <br><br><img src="https://habrastorage.org/webt/vl/br/fo/vlbrfo8a7p80neysmtjguosakww.jpeg"><br><br>  Wenn Sie sich in UDP nicht mit ICMP beschäftigen möchten, können Sie Folgendes tun: Fragmentierung beim Senden normaler Daten zulassen.  Das heißt, fragmentierte Pakete senden - lassen Sie sie arbeiten.  Parallel zum Auswählen eines Prozesses, der die Fragmentierung verhindert, wird bei einer binären Suche die optimale MTU ausgewählt, zu der wir dann gehen.  Dies ist nicht ganz effektiv, da sich die MTU zunächst aufzuwärmen scheint. <br><br>  Eine schwierigere Option besteht darin, die Verteilung der MTU auf mobile Clients zu untersuchen. <br><br><img src="https://habrastorage.org/webt/ie/a5/w8/iea5w8h3msrkprfxpgfhb2nkjyu.jpeg"><br><br>  Von allen Kunden haben wir Pakete unterschiedlicher Größe mit dem Verbot der Fragmentierung gesendet.  Das heißt, wenn das Paket nicht erreicht wird, fällt es ab und die kleinste MTU sollte 100% erreichen.  Da es jedoch einen kleinen Paketverlust gibt, gibt es zwei Folien in der Tabelle: <br><br><ol><li>  1350 Bytes - statt 98% erhalten wir sofort 95% Lieferung. </li><li>  1500 Bytes - MTU, nach der bereits 80% der Clients solche Pakete nicht empfangen. </li></ol><br><blockquote>  In der Tat können wir das sagen: Wir vernachlässigen 1-2% unserer Kunden, lassen sie von fragmentierten Paketen leben.  Aber wir werden sofort von dem ausgehen, was wir brauchen - das ist ab 1350. </blockquote><br><h2>  Fehlerkorrektur (SACK, NACK, FEC) </h2><br>  Wenn Sie Ihr Protokoll erstellen, müssen Sie die Fehler korrigieren.  Wenn das Paket fehlt (dies ist normal für drahtlose Netzwerke), muss es wiederhergestellt werden. <br><br>  Im einfachsten Fall (weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) gibt es ein Relais über Retransmit Time Out (RTO).  Wenn das Paket fehlt, warten Sie auf die Zeit für die erneute Übertragung und senden Sie es erneut. <br><br>  Der nächste Algorithmus ist <b>Fast Retransmit</b> .  Dies sind alles TCP-Algorithmen, die jedoch problemlos auf UDP portiert werden können. <br><br><img src="https://habrastorage.org/webt/hm/s1/ee/hms1eey-ntpj2x0piswhxc4e5fa.jpeg"><br><br>  Wenn das Paket weg ist, senden wir weiter - es werden andere Pakete übertragen.  Zu diesem Zeitpunkt gibt der Server an, dass er das nächste Paket empfangen hat, aber es gab kein vorheriges.  Dazu macht er eine knifflige Bestätigung, die der Paketnummer + 1 entspricht, und setzt das Flag für die doppelte Bestätigung.  Er sendet diese Dup Ack so, und am dritten verstehen wir normalerweise, dass das Paket verschwunden ist und senden es erneut. <br><br>  Was Sie sonst noch edel machen möchten, was nicht in TCP enthalten ist und was sie in UDP tun möchten, ist die <b>Vorwärtsfehlerkorrektur</b> . <br><br><img src="https://habrastorage.org/webt/ex/_u/gg/ex_uggyt0-4ntdgzy-vn7hvmyzg.jpeg"><br><br>  Es scheint, dass wir, wenn wir wissen, dass Pakete verloren gehen können, eine Reihe von Paketen nehmen, ein XOR-Paket hinzufügen und das Problem ohne zusätzliche Neuübertragungen sofort auf dem Client beim Empfang von Daten beheben können.  Es gibt jedoch ein Problem, wenn mehrere Pakete verschwinden.  Es scheint, dass es durch Paritätsschutz, Reed-Solomon usw. gelöst werden kann. <br><br>  Wir haben es so versucht, es stellte sich heraus, dass die Pakete tatsächlich in Bündeln verschwinden. <br><br><img src="https://habrastorage.org/webt/fg/qo/jj/fgqojj1gas9pgutyyyzkla_m5ze.jpeg"><br><br>  Die durchschnittliche Paketlücke betrug 6. Dies ist eine sehr unpraktische Paketlücke - Sie benötigen viele Fehlerkorrekturcodes.  Gleichzeitig gibt es bei 11 eine Art Peak - ich weiß nicht warum, aber Pakete verschwinden manchmal in Paketen von 11.  Aufgrund dieser Paketlücke funktioniert dies nicht. <br><br>  Google hat das auch versucht, jeder träumt von FEC, aber bisher hat niemand gearbeitet. <br><br>  Es gibt eine andere Option, wenn FEC helfen kann. <br><br><img src="https://habrastorage.org/webt/d9/tb/tw/d9tbtwafxbt_t08_j9wvarw5icc.jpeg"><br><br>  Zusätzlich zur erneuten Übertragung durch Retransmit Time Out, Fast Retransmit, gibt es auch eine <strong>Schwanzverlustsonde</strong> .  Dies ist so etwas, wenn Sie Daten senden und der Schwanz weg ist.  Das heißt, Sie haben einen Teil der Daten gesendet und das fünfte Paket gesendet - es ist angekommen.  Dann begannen Pakete zu verschwinden, zum Beispiel weil das Netzwerk ausgefallen war.  Pakete verschwinden, verschwinden und Sie haben nur für das fünfte Paket eine Bestätigung erhalten. <br><br>  Um zu verstehen, ob diese Daten erreicht sind, fragen Sie nach einer Weile, ob Sie mit dem TLP (Tail Loss Probe) beginnen, ob das Ende empfangen wurde.  Tatsache ist, dass die Datenübertragung beendet wurde und Sie nichts senden, dann funktioniert Fast Retransmit nicht.  Um dies zu beheben, führen Sie einen TLP durch. <br><br>  Sie können TLPs FEC hinzufügen.  Sie können alle nicht eingetroffenen Pakete anzeigen, die Parität darauf zählen und TLPs mit einem Paritätspaket senden. <br><br>  Das ist alles cool, es scheint zu funktionieren.  Aber es gibt so ein Problem. <br><br><img src="https://habrastorage.org/webt/pt/y5/qm/pty5qmye2nqwrocxnp3fv5-gll4.jpeg"><br><br>  Wir haben Statistiken gesammelt und es stellte sich heraus, dass 98% der Fehler durch Fast Retransmit repariert werden.  Der Rest wird über Retransmit Time Out und weniger als 1% über TLP repariert.  Wenn Sie etwas anderes FEC reparieren, beträgt es weniger als 0,5%. <br><br><blockquote>  TCP unterstützt FEC nicht.  In UDP ist dies nicht schwierig, aber im allgemeinen Fall reichen Standard-TCP-Wiederherstellungsalgorithmen aus. </blockquote><br><h2>  Leistung </h2><br>  Es wäre möglich, die Leistung durch einen Vergleich von TCP mit UDP nicht zu beeinträchtigen. <br><br>  TCP ist ein sehr altes Protokoll mit vielen verschiedenen Optimierungen, z. B. LSO (Large Segment Offload) und Zerocopy.  Jetzt ist für UDP alles nicht verfügbar.  Daher beträgt die UDP-Leistung nur 20% im Vergleich zu TCP von denselben Servern.  Es gibt jedoch bereits vorgefertigte Lösungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP GSO</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zerocopy</a> ), mit denen Linux dies unterstützen kann. <br><br>  Das Hauptproblem bei der Optimierung für Nullkopie und LSO besteht darin, dass die Stimulation verloren geht. <br><br><img src="https://habrastorage.org/webt/qu/6i/th/qu6ith66mowy_jm9iznjsstsadm.jpeg"><br><br><h2>  Time to Market oder was TCP getötet hat </h2><br>  Vor kurzem, als mobile drahtlose Netzwerke populär wurden, erschienen viele verschiedene TCP-Standards: TLP, TFO, neue Überlastungskontrolle, RACK, BBR und mehr. <br><br><img src="https://habrastorage.org/webt/nq/lx/5a/nqlx5a_sq5zzvi2au81ulptczew.jpeg"><br><br><blockquote>  Das Hauptproblem ist jedoch, dass viele von ihnen nicht implementiert werden, da TCP angeblich verknöchert ist.  In vielen Fällen betrachten Betreiber TCP-Pakete und erwarten, dass sie sehen, was sie erwarten.  Daher ist es sehr schwierig zu ändern. </blockquote><br>  Darüber hinaus werden mobile Clients lange Zeit aktualisiert, und wir können diese Updates nicht bereitstellen.  Wenn Sie sich ansehen, welche neuesten Updates auf dem Client verfügbar sind und was sich auf dem Server befindet, können Sie sagen, dass auf dem Client fast nichts vorhanden ist. <br><br><img src="https://habrastorage.org/webt/au/57/iw/au57iwnkvrjzkvrpo2osdo7f49e.jpeg"><br><br>  Daher scheint die Entscheidung, ein Protokoll im Benutzerbereich zu schreiben, zumindest solange Sie alle diese Funktionen sammeln, nicht so schlecht zu sein. <br><br><img src="https://habrastorage.org/webt/6i/o6/po/6io6poew2qopzofy3vbflm3-5a8.jpeg"><br><br>  Mit TCP rollen Funktionen seit Jahren.  Für Ihr UDP-Protokoll können Sie die Version buchstäblich in einem Update von Client und Server aktualisieren.  Sie müssen jedoch eine Versionsverhandlung hinzufügen. <br><br><h2>  TCP gegen selbst erstelltes UDP.  Endkämpfe </h2><br><img src="https://habrastorage.org/webt/fx/q6/ct/fxq6ctnz94vaf7pfr7jmrcbz7lu.jpeg"><br><br><ul><li>  Sende- / Empfangspuffer: Der veränderbare Puffer kann für Ihr Protokoll erstellt werden. Es treten Probleme mit dem Aufblähen des Puffers mit TCP auf. </li><li>  Überlastungskontrolle können Sie vorhandene verwenden.  Bei UDP sind sie alle. </li><li>  Das neue Überlastungssteuerelement lässt sich nur schwer zu TCP hinzufügen, da Sie die Bestätigung ändern müssen. Dies ist auf dem Client nicht möglich. </li><li>  Multiplexing ist ein kritisches Thema.  Head-of-Line-Blockierung tritt auf. Wenn Sie ein Paket verlieren, können Sie nicht zu TCP multiplexen.  Daher sollte HTTP2.0 über TCP keinen ernsthaften Anstieg bewirken. </li><li>  Fälle, in denen Sie einen Verbindungsaufbau für 0-RTT in TCP erhalten können, sind äußerst selten, in der Größenordnung von 5% und in der Größenordnung von 97% für selbst erstelltes UDP. </li></ul><br><img src="https://habrastorage.org/webt/4f/_f/oe/4f_foen6zvxf5mexl8p6jfu2izm.jpeg"><br><br><ul><li>  Die IP-Migration ist keine so wichtige Funktion, wird jedoch bei komplexen Abonnements und beim Speichern des Status auf dem Server unbedingt benötigt, ist jedoch nicht in TCP implementiert. </li><li>  Nat Unbindung ist nicht für UDP.  In diesem Fall muss UDP häufig Ping-Pong-Pakete ausführen. </li><li>  Die Paketstimulation in UDP ist einfach, während es keine Optimierung gibt. In TCP funktioniert diese Option nicht. </li><li>  MTU und Fehlerkorrektur sind beide vergleichbar. </li><li>  Die Geschwindigkeit von TCP ist jetzt natürlich schneller als die von UDP, wenn Sie eine Menge Verkehr verteilen.  Einige Optimierungen dauern jedoch sehr lange. </li></ul><br>  Wenn Sie das Wichtigste sammeln, hat UDP wahrscheinlich mehr Vor- als Nachteile. <br><br><img src="https://habrastorage.org/webt/p4/7k/ys/p47kysilkuqtb-x-zc0cwhigeoe.jpeg"><br><br>  <b>Wählen Sie UDP!</b> <br><br><h2>  Testen von selbst erstelltem UDP an Benutzern </h2><br>  Wir haben einen Prüfstand zusammengestellt. <br><br><img src="https://habrastorage.org/webt/rh/er/ec/rherec8kewip9-ycek5qimdgvuw.jpeg"><br><br>  Es gibt einen Client für TCP und UDP.  Wir haben den Datenverkehr über Net Shaper normalisiert, an das Internet und an den Server gesendet.  Ein REST-API-Service, der zweite mit UDP.  Und UDP verwendet dieselbe REST-API im selben Rechenzentrum, um die Daten zu überprüfen.  Wir haben verschiedene Profile unserer mobilen Kunden gesammelt und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Test gestartet</a> . <br><br><img src="https://habrastorage.org/webt/sy/rf/nf/syrfnflhcgpr13bngr1y7cv5fle.jpeg"><br><br>  Bei der Messung des Durchschnitts über das Portal haben wir festgestellt, dass wir die Zeit für den Aufruf der API um 10% und für Bilder um 7% reduzieren konnten.  Die Nutzeraktivität wuchs nur um 1%, aber wir geben nicht auf, wir denken, es wird besser. <br><br><img src="https://habrastorage.org/webt/o9/wr/bj/o9wrbjk45dk58yjji6t8boe9-xw.jpeg"><br><br>  In Bezug auf die Auslastung haben wir jetzt ungefähr 10 Millionen Benutzer in unserem selbst erstellten UDP, Datenverkehr mit bis zu 80 Gbit / s, 6 Millionen Pakete pro Sekunde und 20 Server, die dies alles bedienen. <br><br><h2>  UDP-Checkliste <br></h2><br>  Wenn Sie Ihr Protokoll schreiben möchten, benötigen Sie eine Checkliste: <br><br><ul><li>  Tempo </li><li>  MTU-Entdeckung. </li><li>  <strong>Fehlerbehebungen erforderlich</strong> . </li><li>  Flusskontrolle und Überlastungskontrolle. </li><li>  Optional können Sie die IP-Migration unterstützen. TLP ist einfach. </li></ul><br>  Denken Sie daran, dass die Kanäle asymmetrisch sind. Während Sie Daten vom Server empfangen, ist Ihr Upload möglicherweise inaktiv. Versuchen Sie es. <br><br><h2>  QUIC </h2><br>  Es wäre unehrlich zu sagen, dass Google dies nicht getan hat. <br><br><img src="https://habrastorage.org/webt/z0/b9/-v/z0b9-v9kmmobln4nv2yado-rble.jpeg"><br><br>  Es gibt ein QUIC-Protokoll, das Google unter HTTP 2.0 implementiert hat und das fast dasselbe unterstützt. <br><br><h3>  Warum QUIC nicht so schnell ist </h3><br>  Als QUIC herauskam, gab es viel Hass gegen die Tatsache, dass Google sagt, dass alles schneller funktioniert, und "ich habe es zu Hause auf einem Computer gemessen - es funktioniert langsamer." <br><br><img src="https://habrastorage.org/webt/db/5a/vd/db5avdtu1zaito8ntcmg-hdvwy8.jpeg"><br><br>  Dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel enthält eine</a> Reihe von Bildern und Maßen. <br><br>  Nun, es stellt sich heraus, dass wir das alles umsonst getan haben, haben die Leute für uns gemessen?  Selbst mit Codebeispielen gibt es echte Hausmessungen. <br><br><img src="https://habrastorage.org/webt/id/wr/39/idwr39saesks74hbadevlunieua.jpeg"><br><br>  Tatsächlich wird es keine Verbesserung geben, bis Sie Anforderungen parallelisieren, in realen Netzwerken arbeiten und bis Paketverluste in Überlastungsverlust und Zufallsverlust unterteilt sind.  Wir brauchen eine echte Emulation eines echten Netzwerks. <br><br>  Aber es gibt eine positive, sagen sie, QUIC ist weder besser noch schlechter.  Somit funktioniert QUIC in perfekten Netzwerken gut. <br><br><h2>  Die Zukunft </h2><br>  Google hat kürzlich HTTP 2.0 über QUIC HTTP 3 benannt, nicht zu verwechseln, da HTTP 2.0 über TCP und über QUIC stehen könnte.  Jetzt ist es HTTP 3. <br><br><img src="https://habrastorage.org/webt/go/ra/z4/goraz4ktgsje7ankwyipapzeow0.jpeg"><br><br>  Es gab auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google QUIC</a> - dies ist QUIC, das in Chrome implementiert ist, und iQUIC - ein standardisiertes QUIC.  Das standardisierte QUIC wurde nirgendwo implementiert, die Standard-iQUIC-Server haben kein Handshake mit Google QUIC durchgeführt.  Jetzt versprechen sie, dieses Problem zu lösen, und bald wird es verfügbar sein. <br><br><h3>  QUIC ist überall </h3><br>  Wenn Sie immer noch nicht glauben, dass TCP tot ist, sage ich Ihnen, dass Sie QUIC und UDP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prooflink</a> ) verwenden, wenn Sie Chrome, Android und bald auch iOS verwenden und zu Google, Youtube usw. gehen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QUIC ist jetzt</a> : <br><br><ul><li>  1,9% aller Websites; </li><li>  12% des gesamten Verkehrs; </li><li>  30% des Videoverkehrs in Mobilfunknetzen. </li></ul><br>  Wie können Sie überprüfen, ob Sie QUIC verwenden, wenn Sie nicht glauben?  In Chrome Wireshark öffnen.  Ich habe nach iQUIC gesucht, ich habe es nirgendwo gefunden, aber GQUIC passiert. <br><br><img src="https://habrastorage.org/webt/t_/8v/9q/t_8v9qsq9jcgbjkf9vqqr67vw7k.jpeg"><br><br>  Sie können auch in Ihrem Browser online gehen und sehen, was GQUIC dort ist. <br><br><img src="https://habrastorage.org/webt/av/ko/p5/avkop5nphmxm6ee3rqc2hi23wzu.jpeg"><br><br><h3>  Noch etwas Zukunft </h3><br>  Multipath wartet bald auf uns. <br><br><img src="https://habrastorage.org/webt/d8/bi/wo/d8biwobqjbdjqdn8g-wb7gegka0.jpeg"><br><br>  Wenn Sie einen mobilen Client haben, der sowohl über WLAN als auch über 3G verfügt, können Sie beide Kanäle verwenden.  Multipath TCP befindet sich derzeit in der Entwicklung und wird in Kürze im Linux-Kernel verfügbar sein.  Offensichtlich wird es Kunden nicht bald erreichen, ich denke, es kann auf UDP viel schneller gemacht werden. <br><br><img src="https://habrastorage.org/webt/pb/7o/yt/pb7oytnkrhutg6qtqlwq0jf3p4o.jpeg"><br><br>  Da wir viele Übersetzungen mit jeweils 3 TB durchführen, verwenden wir sehr häufig Technologien wie CDN- und P2P-Distribution, wenn derselbe Inhalt vielen Benutzern auf der ganzen Welt bereitgestellt werden muss. <br><br>  In IPv6 gibt es Multicast mit UDP, mit dem Pakete an mehrere abonnierte Benutzer gleichzeitig gesendet werden können.  Daher denke ich, dass CDN- und P2P-Technologien in naher Zukunft nicht benötigt werden, wenn wir alle Inhalte mithilfe von Multicast an IPv6 liefern. <br><br><h2>  Schlussfolgerungen </h2><br>  Ich hoffe du verstehst: <br><br><ul><li>  Wie das Netzwerk wirklich funktioniert und dass TCP über UDP wiederholt und besser gemacht werden kann. </li><li>  Das TCP ist nicht so schlecht, wenn Sie es richtig konfigurieren, aber es hat wirklich aufgegeben und entwickelt sich fast nicht mehr. </li><li>  Vertrauen Sie keinen UDP-Hassern, die sagen, dass sie nicht im Benutzerbereich arbeiten.  All diese Probleme können gelöst werden.  Probieren Sie es aus - dies ist die nahe Zukunft. </li><li>  Wenn Sie es nicht glauben, können und sollten Sie das Netzwerk mit Ihren Händen berühren.  Ich habe gezeigt, wie fast alles überprüft werden kann. </li></ul><br>  Sie haben alles gelesen und herausgefunden, was als nächstes kommt? <br><br><ul><li>  Konfigurieren Sie das Protokoll (TCP, UDP - es spielt keine Rolle) für die Situation (Netzwerkprofil + Lastprofil). </li><li>  Verwenden Sie die TCP-Rezepte, die ich Ihnen gesagt habe: TFO, Sende- / Empfangspuffer, TLS1.3, CC ... </li><li>  Erstellen Sie Ihre UDP-Protokolle, wenn Sie über die Ressourcen verfügen. </li><li>  Wenn Sie Ihr UDP durchgeführt haben, überprüfen Sie in der UDP-Checkliste, ob Sie alles getan haben, was Sie benötigen.  Unsinn wie das Tempo zu vergessen, wird nicht funktionieren. </li></ul><br>  Wenn Sie nicht über die Ressourcen verfügen, bereiten Sie Ihre Infrastruktur für QUIC vor.  Früher oder später wird er zu dir kommen. <br><br><blockquote>  Wir bestimmen die Zukunft.  Wir entscheiden, welche Protokolle verwendet werden sollen.  Wenn Sie QUIC verwenden möchten - verwenden Sie es, wenn Sie Ihr UDP möchten oder auf TCP bleiben - entscheiden Sie selbst über die Zukunft. </blockquote><br><h3>  Nützliche Links </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Millionen Videoanrufe pro Tag oder "Call Mom!"</a>  . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir schreiben unser Protokoll über UDP</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Podcast zur Netzwerkoptimierung</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erhöhen Sie die Datenübertragungsgeschwindigkeit in fehlerhaften Netzwerken</a> . </li></ul><br><blockquote>  Bis zum 7. September können Sie weiterhin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Antrag</a> für Moscow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++ stellen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mitteilen,</a> wie Sie Ihre Dienste auf hohe Lasten vorbereiten.  Das Programm wird jedoch bereits nach und nach gefüllt. Aus Odnoklassniki-Berichten gingen Berichte über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Architektur des</a> Freundesdiagramms, über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierung des Geschenkservices</a> für hohe Lasten und darüber ein, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was zu tun ist,</a> wenn Sie alles optimiert haben und die Daten den Benutzer nicht schnell genug erreichen. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461829/">https://habr.com/ru/post/de461829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461817/index.html">CMake und C ++ - Brüder für immer</a></li>
<li><a href="../de461819/index.html">Warum einfaches Website-Design wissenschaftlich besser ist</a></li>
<li><a href="../de461821/index.html">Neue Immuntherapie entfernte alle Tumoren bei einer Frau mit metastasiertem Brustkrebs</a></li>
<li><a href="../de461823/index.html">Erweiterte vier Regeln für das Software-Design</a></li>
<li><a href="../de461827/index.html">Entwicklung hybrider PHP / Go-Anwendungen mit RoadRunner</a></li>
<li><a href="../de461831/index.html">StealthWatch: Bereitstellung und Anpassung. Teil 2</a></li>
<li><a href="../de461833/index.html">Verlieren Sie sich nicht in drei Kiefern: einer egozentrischen Darstellung der Umwelt</a></li>
<li><a href="../de461835/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen und stärken</a></li>
<li><a href="../de461841/index.html">PVS-Studio untersuchte die Bullet Engine der Red Dead Redemption</a></li>
<li><a href="../de461845/index.html">Investitionen an der Börse als Mittel zur Erhaltung der Finanzen: 3 Arbeitsmethoden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>