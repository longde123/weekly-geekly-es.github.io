<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèº üëêüèº üôáüèª TCP vs UDP oder die Zukunft der Netzwerkprotokolle üï∫üèø ü§æüèª ü§æüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor jedem Dienst, der mindestens 1 MBit / s Internetverkehr generiert, stellt sich die Frage: ‚ÄûWie? √ºber TCP oder √ºber UDP? " In Anwendungsbereichen, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TCP vs UDP oder die Zukunft der Netzwerkprotokolle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461829/">  Vor jedem Dienst, der mindestens 1 MBit / s Internetverkehr generiert, stellt sich die Frage: ‚ÄûWie?  √ºber TCP oder √ºber UDP? "  In Anwendungsbereichen, einschlie√ülich Bereitstellungsplattformen, haben sich bereits Pr√§ferenzen und Traditionen f√ºr solche Entscheidungen entwickelt. <br><br>  Wenn beispielsweise ein fauler Entwickler nicht einmal versucht h√§tte, seine ML in Python bereitzustellen (weil er es nur wusste), w√§re die Welt theoretisch h√∂chstwahrscheinlich nie von einer solchen Liebe f√ºr die verabscheuungsw√ºrdige Sprache der ‚ÄûSuper-Java-Encoder‚Äú erf√ºllt worden.  Und heute haben die Schw√§chen dieser Sprache im fr√ºheren Anwendungskontext bedingungslos Vorrang bei der Bereitstellung und dem Start zahlreicher Mining-A / B. <br><br>  Sie k√∂nnen viel vergleichen: ARM mit Intel, iOS und Android und Mortal Kombat mit Injustice.  Und sto√üen Sie auf einen Weltraum-Holivar, also zur√ºck zum Thema der Bereitstellung gro√üer Mengen von Inhalten mit mehreren Formaten. <br><br>  Vor zehn Jahren war sich jeder absolut sicher, dass es bei UDP um nicht garantierte Lieferung geht.  Wenn Sie ein zuverl√§ssiges Protokoll ben√∂tigen, ist es TCP.  Und entgegen der Tradition in diesem Artikel werden wir scheinbar unvergleichliche Dinge wie TCP und UDP vergleichen. <br><br><img src="https://habrastorage.org/webt/p5/tk/9z/p5tk9z_pumv5hmxly_ob3rvdikg.jpeg"><br>  <i>Achtung, unter dem Schnitt 99 Abbildungen und Diagramme und alles Wichtige.</i> <br><a name="habracut"></a><br>  Der Vergleich wird vom Entwicklungsleiter der Video- und Tape-Plattformen in OK <b>Alexander Tobol</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">alatobol</a> ) durchgef√ºhrt.  Die Video- und Newsfeed-Dienste im sozialen Netzwerk OK - ausschlie√ülich √ºber Inhalte und deren Bereitstellung auf allen vorhandenen Client-Plattformen unter schlechten oder ausgezeichneten Netzwerkbedingungen, und die Frage, wie diese √ºber TCP oder UDP bereitgestellt werden sollen, sind von entscheidender Bedeutung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aXYJlizk3CQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  TCP gegen UDP.  Minimale Theorie </h2><br>  Um zum Vergleich zu gelangen, brauchen wir eine kleine Grundtheorie. <br><br><img src="https://habrastorage.org/webt/fd/2q/ko/fd2qkoeptll1vmmm0ptkscrhu9i.jpeg"><br><br>  Was wissen wir √ºber IP-Netzwerke?  Der von Ihnen gesendete Datenstrom ist in Pakete unterteilt. Eine Art Black Box liefert diese Pakete an den Client.  Der Client sammelt Pakete und empf√§ngt einen Datenstrom.  Normalerweise ist dies alles transparent und es besteht kein Grund zu √ºberlegen, was sich auf den unteren Ebenen befindet. <br><br><img src="https://habrastorage.org/webt/dj/6r/xm/dj6rxmcr3xayjlmfnblkxet-1le.jpeg"><br><br>  Das Diagramm zeigt den TCP / IP- und UDP / IP-Stack.  Unten befinden sich Ethernet-Pakete, IP-Pakete und auf Betriebssystemebene TCP und UDP.  TCP und UDP in diesem Stapel unterscheiden sich nicht sehr voneinander.  Sie sind in IP-Paketen gekapselt und k√∂nnen von Anwendungen verwendet werden.  Um die Unterschiede zu erkennen, m√ºssen Sie sich die TCP- und UDP-Pakete ansehen. <br><br><img src="https://habrastorage.org/webt/mz/pr/lt/mzprltftvytepznp_xufo63xb0g.jpeg"><br><br>  Sowohl dort als auch dort gibt es Ports.  <strong>In UDP gibt es jedoch nur eine Pr√ºfsumme</strong> - die Paketl√§nge, dieses Protokoll ist so einfach wie m√∂glich.  Und in TCP gibt es viele Daten, die das Fenster, die Best√§tigung, die Sequenz, die Pakete usw. klar anzeigen.  Offensichtlich ist <strong>TCP komplexer</strong> . <br><br><blockquote>  Ganz grob gesagt ist TCP ein zuverl√§ssiges √úbermittlungsprotokoll und UDP ein unzuverl√§ssiges. </blockquote><br>  Trotz der angeblichen Unzuverl√§ssigkeit von UDP werden wir herausfinden, ob es m√∂glich ist, Daten schneller und zuverl√§ssiger zu liefern als mit TCP.  Lassen Sie uns versuchen, das Netzwerk von innen zu betrachten und zu verstehen, wie es funktioniert.  Auf dem Weg werden wir die folgenden Fragen ansprechen: <br><br><ul><li>  Warum TCP vergleichen oder was ist daran falsch? </li><li>  womit und womit sollten Sie TCP vergleichen? </li><li>  Was hat Google getan und welche Entscheidung hat es getroffen? </li><li>  Was erwartet uns die Zukunft der Netzwerkprotokolle? </li></ul><br>  Dieser Artikel wird keine Theorie haben: OSI-Ebenen und -Modelle, komplexe mathematische Modelle, obwohl alles durch sie gez√§hlt werden kann.  Wir werden maximal analysieren, wie man das Netzwerk nicht theoretisch, sondern mit eigenen H√§nden ber√ºhrt. <br><br><h2>  Warum TCP vergleichen oder was daran falsch ist? </h2><br>  TCP wurde 1974 erfunden und 20 Jahre sp√§ter, als ich zur Schule ging, kaufte ich Internetkarten, l√∂schte den Code und rief irgendwo an.  Wenn Sie von 2 N√§chten bis 7 Uhr morgens anrufen, war das Internet kostenlos, aber es war schwierig, durchzukommen. <br><br>  Weitere 20 Jahre vergingen, und Benutzer in mobilen drahtlosen Netzwerken setzten sich gegen ‚Äûverkabelte‚Äú Benutzer durch, w√§hrend sich TCP konzeptionell nicht √§nderte. <br><br><blockquote>  Die mobile Welt gewann, drahtlose Protokolle erschienen und TCP blieb unver√§ndert. </blockquote><br>  Heutzutage verwenden 80% der Benutzer Wi-Fi oder ein drahtloses 3G-4G-Netzwerk. <br><br><img src="https://habrastorage.org/webt/mw/a9/u4/mwa9u4ew7v6e1uevlbgrvf2jlrw.jpeg"><br><br>  In drahtlosen Netzwerken gibt es: <br><br><ul><li>  Paketverlust - Ungef√§hr 0,6% der von uns gesendeten Pakete gehen unterwegs verloren. </li><li>  Neuordnung - Neuordnung von Paketen an Orten im wirklichen Leben ist ein eher seltenes Ph√§nomen, das jedoch in 0,2% der F√§lle auftritt. </li><li>  Jitter - wenn Pakete gleichm√§√üig gesendet werden und mit einer Verz√∂gerung von ca. 50 ms in Warteschlangen eintreffen. </li></ul><br>  TCP verbirgt erfolgreich alle diese Funktionen der Daten√ºbertragung in heterogenen Netzwerken vor Ihnen, und Sie m√ºssen nicht eintauchen. <br><br>  Unten auf der Karte ist die durchschnittliche TCP-Datenrate in Russland angegeben.  Wenn Sie den westlichen Teil entfernen, ist klar, dass die Geschwindigkeit mehr in Kilobit als in Megabit gemessen wird. <br><br><img src="https://habrastorage.org/webt/ck/a4/y5/cka4y5puk4gyorr-uaq2xcdtuom.jpeg"><br><br>  Das ist im Durchschnitt f√ºr unsere Benutzer (ohne den westlichen Teil Russlands): Durchsatz 1,1 Mbit / s, 0,6% Paketverlust, RTT (Round-Trip-Zeit) von etwa 200 ms. <br><br><h3>  Wie berechnet man die RTT? </h3><br>  Als ich den Durchschnitt von 200 ms sah, dachte ich, dass es einen Fehler in der Statistik gab, und entschied mich, die RTT f√ºr unsere Server in der MSC auf alternative Weise mithilfe von RIPE Atlas zu messen.  Dies ist ein System zum Sammeln von Daten √ºber den Zustand des Internets.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RIPE Atlas-</a> Sonde ist kostenlos erh√§ltlich. <br><br><img src="https://habrastorage.org/webt/za/rj/3g/zarj3gndghr0wnxs4yqt_odm68a.jpeg"><br><br>  Das Fazit ist, dass Sie es mit Ihrem Heim-Internet verbinden und ‚ÄûKarma‚Äú sammeln.  Sie arbeitet tagelang, einige Leute erf√ºllen einige ihrer Anfragen an sie.  Dann k√∂nnen Sie selbst verschiedene Aufgaben einstellen.  Ein Beispiel f√ºr eine solche Aufgabe: Nehmen Sie versehentlich 30 Punkte im Internet und fragen Sie nach der RTT-Messung, dh f√ºhren Sie den Ping-Befehl auf der Odnoklassniki-Website aus. <br><br><img src="https://habrastorage.org/webt/kb/qa/5k/kbqa5k7sgl6wt5modhjfpa2fg00.jpeg"><br><br>  Seltsamerweise gibt es unter zuf√§lligen Punkten viele solche, die einen Ping von 200 bis 300 ms haben. <br><br>  Insgesamt sind <strong>drahtlose Netzwerke beliebt und instabil</strong> (obwohl letzteres normalerweise ignoriert wird, da angenommen wird, dass TCP damit umgehen kann): <br><br><ul><li>  √úber 80% der Benutzer nutzen das drahtlose Internet. </li><li>  Die Parameter von drahtlosen Netzwerken √§ndern sich dynamisch, beispielsweise abh√§ngig von der Tatsache, dass der Benutzer um die Ecke gegangen ist. </li><li>  Drahtlose Netzwerke weisen eine hohe Rate an Paketverlust, Jitter und Neuordnung auf. </li><li>  Asymmetrischer Kanal behoben, √Ñnderung der IP-Adresse. </li></ul><br><h3>  Der Verbrauch von Inhalten h√§ngt von der Internetgeschwindigkeit ab </h3><br>  Dies ist sehr einfach zu √ºberpr√ºfen - es gibt viele Statistiken.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statistiken</a> zu dem Video erstellt. Je h√∂her die Internetgeschwindigkeit im Land, desto mehr Benutzer sehen sich das Video an. <br><br><img src="https://habrastorage.org/webt/de/6q/_r/de6q_ruks-vpbgoo4yt5vokfkno.jpeg"><br><br>  Nach diesen Statistiken hat Russland ein ziemlich schnelles Internet, aber nach unseren internen Daten ist die Durchschnittsgeschwindigkeit etwas niedriger. <br><br>  F√ºr die Tatsache, dass die Internetgeschwindigkeit insgesamt nicht ausreicht, hei√üt es, dass alle Entwickler gro√üer Anwendungen, sozialer Netzwerke, Videodienste usw. ihre Dienste f√ºr die Arbeit in einem schlechten Netzwerk optimieren.  Nach 10 KB empfangener Daten sehen Sie ein Minimum an Informationen auf dem Band, und bei einer Geschwindigkeit von 500 KB k√∂nnen Sie Videos ansehen. <br><br><h3>  So beschleunigen Sie das Laden </h3><br>  Bei der Entwicklung der Videoplattform haben wir festgestellt, dass TCP in drahtlosen Netzwerken nicht sehr effektiv ist.  Wie sind Sie zu diesem Schluss gekommen? <br><br>  Wir beschlossen, den Download zu beschleunigen und machten den n√§chsten Trick. <br><br><img src="https://habrastorage.org/webt/n2/gg/xf/n2ggxfu9tzoskihc7itlm28j7ui.jpeg"><br><br>  Wir haben das Video in mehreren Streams vom Client auf den Server heruntergeladen, dh 40 MB werden in 4 Teile von 10 MB aufgeteilt und parallel geladen.  Wir haben es auf Android gestartet und festgestellt, dass es parallel schneller geladen wird als in einer Verbindung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> im Bericht).  Das Interessanteste ist, dass wir bei der Einf√ºhrung paralleler Downloads in der Produktion festgestellt haben, dass sich die Download-Geschwindigkeit in einigen Regionen verdreifacht hat! <br><br><blockquote>  Vier TCP-Verbindungen k√∂nnen tats√§chlich dreimal schneller Daten auf den Server hochladen. </blockquote><br>  Deshalb haben wir die Download-Geschwindigkeit f√ºr Videos erh√∂ht und sind zu dem Schluss gekommen, dass der Download parallelisiert werden muss. <br><br><h3>  TCP in instabilen Netzwerken </h3><br>  Ein unglaublicher Effekt mit Parallelit√§t kann ber√ºhrt werden.  Es reicht aus, einen Geschwindigkeitsmesser zum Empfangen / Senden von Daten (z. B. Geschwindigkeitstest) und Traffic Shaper (z. B. Network Link Conditioner, wenn Sie einen Mac haben) zu verwenden. Wir beschr√§nken das Netzwerk auf 1-Mbit / s-Parameter zum Hoch- und Herunterladen und beginnen, den Paketverlust zu erh√∂hen. <br><br><img src="https://habrastorage.org/webt/lk/ki/j8/lkkij8appdgsvglvlp1rdt3em7s.jpeg"><br><br>  Die Tabelle zeigt RTT und Verluste.  Es ist ersichtlich, dass im Falle eines Verlusts von 0% das Netzwerk zu 100% ausgelastet ist. <br><br>  Bei der n√§chsten Iteration erh√∂hen wir den Paketverlust um 5% und sehen, dass das Netzwerk nur zu 74% ausgelastet ist.  Es scheint in Ordnung zu sein - bei einem Paketverlust von 5% gehen 26% des Netzwerks verloren.  Wenn Sie jedoch auch den Ping erh√∂hen, bleibt <strong>weniger als die H√§lfte des Kanals</strong> √ºbrig. <br><br><blockquote>  Wenn der Kanal eine hohe RTT und einen gro√üen Paketverlust aufweist, nutzt eine TCP-Verbindung das Netzwerk nicht vollst√§ndig aus. </blockquote><br>  Ein weiterer Trick zeigt, dass Sie bei Verwendung paralleler TCP-Verbindungen (Sie k√∂nnen nur mehrere Geschwindigkeitstests gleichzeitig ausf√ºhren) das umgekehrte Wachstum der Kanalauslastung feststellen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/co/n7/v_/con7v_t-dxmnrsxe6e0kkakbnwm.jpeg"><br><br>  Mit zunehmender Anzahl paralleler TCP-Verbindungen entspricht die Netzwerkauslastung fast dem Durchsatz abz√ºglich des Prozentsatzes der Verluste. <br><br>  So stellte sich heraus: <br><br><ul><li>  Drahtlose Mobilfunknetze haben gewonnen und sind instabil. </li><li>  TCP nutzt den Kanal in instabilen Netzwerken nicht vollst√§ndig aus. </li><li>  Der Verbrauch von Inhalten h√§ngt von der Geschwindigkeit des Internets ab: Je h√∂her die Geschwindigkeit des Internets, desto mehr Benutzer sehen zu, und wir lieben unsere Benutzer wirklich und m√∂chten, dass sie mehr sehen. </li></ul><br>  Nat√ºrlich m√ºssen Sie irgendwohin ziehen und Alternativen zu TCP in Betracht ziehen. <br><br><h2>  TCP gegen nicht TCP </h2><br>  Wie vergleiche ich die W√§rme?  Es gibt zwei M√∂glichkeiten. <br><br>  Die erste Option - auf IP-Ebene gibt es TCP und UDP. Wir k√∂nnen uns ein anderes Protokoll von oben leisten.  Wenn Sie Ihr eigenes Protokoll parallel zu TCP und UDP starten, wissen Firewall, Brandmauer, Router und der Rest der Welt, die an der Paketzustellung beteiligt sind, offensichtlich nichts davon.  Infolgedessen m√ºssen Sie jahrelang warten, bis alle Ger√§te aktualisiert sind und mit dem neuen Protokoll arbeiten. <br><br>  Die zweite M√∂glichkeit besteht darin, zus√§tzlich zu unzuverl√§ssigem UDP ein eigenes zuverl√§ssiges Daten√ºbermittlungsprotokoll zu erstellen.  Nat√ºrlich k√∂nnen Sie lange warten, bis Linux, Android und iOS Ihrem Kernel ein neues Protokoll hinzuf√ºgen. Daher m√ºssen Sie das Protokoll in den User Space schneiden. <br><br>  Diese L√∂sung scheint interessant zu sein, wir werden sie als selbst erstelltes UDP-Protokoll bezeichnen.  Um mit der Entwicklung zu beginnen, ben√∂tigen Sie nichts Besonderes: √ñffnen Sie einfach den UDP-Socket und senden Sie die Daten. <br><br><img src="https://habrastorage.org/webt/zy/zt/sn/zyztsnsutwgufcqwlhxb6qslhpg.jpeg"><br><br>  Wir werden es entwickeln und untersuchen, wie das Netzwerk funktioniert. <br><br><h2>  TCP gegen selbst erstelltes UDP </h2><br>  Nun, und was zu vergleichen? <br><br>  Netzwerke sind unterschiedlich: <br><br><ul><li>  Bei √úberlastung, wenn es viele Pakete gibt und einige von ihnen aufgrund einer √úberlastung von Kan√§len oder Ger√§ten fallen. </li><li>  Hohe Geschwindigkeit mit gro√üer Hin- und R√ºckfahrt (z. B. wenn der Server relativ weit entfernt ist). </li><li>  Seltsam - wenn im Netzwerk nichts zu passieren scheint, Pakete jedoch immer noch verschwinden, nur weil sich der Wi-Fi-Zugangspunkt hinter der Wand befindet. </li></ul><br>  Sie k√∂nnen Netzwerkprofile jederzeit selbst ber√ºhren: W√§hlen Sie das eine oder andere Profil auf Ihrem Telefon aus und f√ºhren Sie den Geschwindigkeitstest aus. <br><br><img src="https://habrastorage.org/webt/v1/0j/-p/v10j-p8absukvs6s4jn2ntd8qau.jpeg"><br><br>  Neben Netzwerkprofilen m√ºssen Sie auch das Profil des Verkehrsverbrauchs ermitteln.  Hier sind die, die wir verwendet haben: <br><br><img src="https://habrastorage.org/webt/3k/dc/fb/3kdcfbeyhjpduwbumk1n1iz2-c0.jpeg"><br><br>  Da ich f√ºr das Video und den Stream verantwortlich bin, sind die Profile angemessen: <br><br><ul><li>  Profilvideo, wenn Sie diesen oder jenen Inhalt verbinden und streamen.  Die Verbindungsgeschwindigkeit erh√∂ht sich wie in der oberen Grafik.  Anforderungen an dieses Protokoll: geringe Latenz und Bitratenanpassung. </li><li>  Option f√ºr die Bandansicht: Laden von Impulsdaten, Hintergrundabfragen, Ausfallzeiten.  Anforderungen an dieses Protokoll: Die empfangenen Daten werden gemultiplext und priorisiert, die Priorit√§t des Benutzerinhalts ist h√∂her als bei Hintergrundprozessen, der Download wird abgebrochen. </li></ul><br>  Nat√ºrlich m√ºssen Sie die Protokolle auf dem beliebtesten HTTP vergleichen. <br><br><h3>  HTTP 1.1 und HTTP 2.0 </h3><br>  Der Standardstapel der 2000er Jahre sah aus wie HTTP 1.1 √ºber SSL.  Der moderne Stack ist HTTP 2.0, TLS 1.3 und alles √ºber TCP. <br><br><img src="https://habrastorage.org/webt/k9/yp/ng/k9ypngmth9i_4m8pqzx5n-kipf0.jpeg"><br><br>  Der Hauptunterschied besteht darin, dass HTTP 1.1 einen begrenzten Pool von Verbindungen im Browser zu einer Dom√§ne verwendet, sodass eine separate Dom√§ne f√ºr Bilder, Daten usw. erstellt wird.  HTTP 2.0 bietet eine Multiplexverbindung, √ºber die alle diese Daten √ºbertragen werden. <br><br><img src="https://habrastorage.org/webt/uo/aj/uu/uoajuubf2yfz_femlhzhvq6buty.jpeg"><br><br>  HTTP 1.1 funktioniert folgenderma√üen: Anfrage stellen, Daten abrufen, Anfrage stellen, Daten abrufen. <br><br><img src="https://habrastorage.org/webt/1y/nv/xd/1ynvxdxpfkluduputf3szhfi75a.jpeg"><br><br>  Normalerweise ist ein Browser oder eine mobile Anwendung eine Kugel, dh eine Verbindung zum Empfangen von Bildern, Daten per API, und Sie f√ºhren gleichzeitig eine Anforderung f√ºr ein Bild, eine API, ein Video usw. aus. <br><br><img src="https://habrastorage.org/webt/cn/ub/kl/cnubklsdxjrcuwpamcckap5_uu8.jpeg"><br><br>  Das Hauptproblem ist der Wettbewerb.  Sie haben keine Kontrolle √ºber die √ºbermittelten Anfragen.  Sie verstehen, dass der Benutzer das Bild, das er durchgebl√§ttert hat, nicht mehr ben√∂tigt, aber nichts mehr tun kann. <br><br><blockquote>  Mit HTTP 1.1 erhalten Sie immer noch das, was Sie angefordert haben. Es ist schwierig, den Download abzubrechen. </blockquote><br>  Die einzige M√∂glichkeit, die Verbindung zu schlie√üen, besteht darin, die Verbindung zu schlie√üen.  Dann werden wir sehen, warum das schlecht ist. <br><br><h3>  Unterschiede in HTTP 2.0 </h3><br>  HTTP 2.0 l√∂st diese Probleme: <br><br><ul><li>  bin√§re Header-Komprimierung; </li><li>  Datenmultiplex; </li><li>  Priorisierung; </li><li>  Abbrechen des Downloads; </li><li>  Server Push </li></ul><br>  Betrachten wir wichtigere Punkte f√ºr uns. <br><br><img src="https://habrastorage.org/webt/tb/nl/ur/tbnlurtfdzcqaxpy6_hgcphtye0.jpeg"><br><br>  Fordern Sie ein Bild und eine API an.  Das Bild wird sofort gegeben, die API nach einer Weile vorbereitet.  Die API wurde gegeben - das Bild wurde bis zum Ende gegeben.  All dies geschieht transparent.  <strong>Inhalte mit hoher Priorit√§t werden fr√ºher heruntergeladen.</strong> <br><br><img src="https://habrastorage.org/webt/gw/ws/wp/gwwswpducmtjv2huz9jprbhwpha.jpeg"><br><br>  <strong>Server-Push</strong> ist so etwas, wenn Sie nach etwas Bestimmtem wie einer API gefragt haben, aber selbst beim Laden auf dem Client wurden Bilder zwischengespeichert, die definitiv ben√∂tigt w√ºrden, um beispielsweise ein Band anzuzeigen. <br><br>  Es gibt auch einen Befehl zum <strong>Zur√ºcksetzen des Streams</strong> , den der Browser selbst ausf√ºhrt, wenn Sie zwischen Seiten usw. wechseln.  F√ºr einen mobilen Client k√∂nnen Sie mit seiner Hilfe den Empfang von Daten verweigern, ohne die Verbindung zu verlieren. <br><br>  Daher werden wir TCP auf verschiedene vergleichen: <br><br><ul><li>  Netzwerkprofile: Wi-Fi, 3G, LTE. </li><li>  Verbrauchsprofile: Streaming (Video), Multiplexing und Priorisierung mit Abbrechen des Downloads (HTTP / 2), um den Inhalt des Bandes zu empfangen. </li></ul><br><h3>  Verlustfreies Modell </h3><br>  Beginnen wir den Vergleich mit einem einfachen Netzwerk, in dem es nur zwei Parameter gibt: Roundtrip-Zeit und Bandbreite. <br><br>  <b>RTT</b> ist Ping, die Bearbeitungszeit eines Pakets, der Empfang der Best√§tigung oder die Antwortechozeit. <br><br>  Um die <b>Bandbreite</b> - die Netzwerkbandbreite - zu messen, senden wir ein Paket von Paketen und z√§hlen die Anzahl der √ºbertragenen Pakete in einem bestimmten Zeitintervall. <br><br><img src="https://habrastorage.org/webt/6r/du/2l/6rdu2lwrhgztjekbwsfgvtuwdec.jpeg"><br><br>  Da wir mit zuverl√§ssigen Protokollen arbeiten, gibt es nat√ºrlich eine Best√§tigung - wir senden Pakete und erhalten eine Empfangsbest√§tigung. <br><br><h3>  Das Problem des langsamen Internets </h3><br>  Zu Beginn der Entwicklung unseres Videodienstes im Jahr 2013 ging mein Freund nach Kalifornien und beschloss, eine neue Serie seiner Lieblingsserien auf Odnoklassniki anzusehen.  Er hatte eine 250 ms RTT, perfektes Wi-Fi 400 Mbit / s auf dem Google-Campus, er wollte die neue Serie in FullHD sehen. <br><br>  Glaubst du, er konnte das Video sehen?  Die Antwort h√§ngt von der Konfiguration des Sende- / Empfangspuffers auf unseren Servern ab. <br><br><img src="https://habrastorage.org/webt/qf/sk/qj/qfskqjvyygm-klersirdlmfdreo.jpeg"><br><br>  Da wir ein Protokoll mit Best√§tigung haben, werden alle Daten, die keine Zustellbest√§tigung erhalten haben, in einem Puffer gespeichert.  Wenn der Sendepuffer auf 128 KB begrenzt ist, sind diese 128 KB geringer als bei RTT. Wir k√∂nnen nicht senden.  Somit verbleiben aus unserem Netzwerk von 400 Mbit / s 4 Mbit / s.  Dies reicht nicht aus, um Online-Videos in FullHD anzusehen. <br><br>  Dann habe ich die Gr√∂√üe des Puffers erh√∂ht und mir angesehen, wie sich die Ausgabegeschwindigkeit eines Videosegments in Abh√§ngigkeit von der √Ñnderung der Puffergr√∂√üe wirklich √§ndert.  Machen Sie sofort eine Reservierung, dass der Recv-Puffer automatisch eingestellt wurde, d. H.  Was der Server gesendet hat, konnte der Client immer akzeptieren. <br><br><img src="https://habrastorage.org/webt/vj/yi/ef/vjyiefcatf55inm_ka-0b1vpake.jpeg"><br><br><blockquote>  Ein offensichtliches TCP-Rezept: Wenn Sie Hochgeschwindigkeitsdaten √ºber gro√üe Entfernungen √ºbertragen, m√ºssen Sie den Sendepuffer erh√∂hen. </blockquote><br>  Alles scheint in Ordnung zu sein.  Sie k√∂nnen zum Dienst fast.com gehen, der die Geschwindigkeit Ihres Internets zu Netflix-Servern misst.  Aus dem B√ºro bekam ich eine Geschwindigkeit von 210 Mbit / s.  Und dann habe ich durch Net Shaper die Bedingungen f√ºr die Aufgabe festgelegt und bin wieder auf diese Seite gegangen.  Magie - Ich habe genau 4 Mbit / s. <br><br><img src="https://habrastorage.org/webt/xx/sl/nr/xxslnr1m5syfgyludnghfp7d6yw.jpeg"><br><br>  Egal wie ich es verdrehe, Netflix hat es nicht geschafft, einen Puffer gr√∂√üer als 128 KB zu bekommen. <br><br><h3>  Puffergr√∂√üe </h3><br>  Um die optimale Puffergr√∂√üe zu ermitteln, m√ºssen Sie die On-the-Fly-Pakete verstehen. <br><br><img src="https://habrastorage.org/webt/cl/ym/ws/clymwsmlyixceklwgevvv00izru.jpeg"><br><br>  Es gibt einen Netzwerkstatus: <br><br><ul><li>  Pakete 1 und 2 wurden bereits gesendet, eine Best√§tigung wurde f√ºr sie empfangen; </li><li>  Pakete 3, 4, 5, 6 wurden gesendet, aber das Zustellergebnis ist unbekannt (On-the-Fly-Pakete); </li><li>  andere Pakete befinden sich in der Warteschlange. </li></ul><br><img src="https://habrastorage.org/webt/if/oh/m0/ifohm0lal6uotlodse6vrehnoqc.jpeg"><br><br>  Wenn die Anzahl der Pakete in On-the-Fly der Gr√∂√üe des Puffers entspricht, ist sie nicht gro√ü genug.  In diesem Fall ist das Netzwerk ausgehungert und nicht vollst√§ndig ausgelastet. <br><br>  Die umgekehrte Situation ist m√∂glich - der Puffer ist zu gro√ü.  In diesem Fall quillt der Puffer auf.  Warum ist das so schlimm? <br><br><img src="https://habrastorage.org/webt/m1/4y/fk/m14yfka8426esfgz8a8xeglxko4.jpeg"><br><br>  Wenn wir √ºber Datenmultiplex sprechen und mehrere Anforderungen gleichzeitig senden, z. B. Bilder in derselben Verbindung und API, dann schwillt der Puffer an, wenn das gesamte riesige Megabyte-Bild in den Puffer gelangt und wir versuchen, auch die API mit hoher Priorit√§t zu stopfen.  Sie m√ºssen sehr lange warten, bis das Bild verschwindet. <br><br>  Eine einfache L√∂sung besteht darin, die Puffergr√∂√üe automatisch anzupassen.  Jetzt ist es auf vielen Clients verf√ºgbar und funktioniert in etwa so. <br><br><img src="https://habrastorage.org/webt/pm/dj/rj/pmdjrjtekrknmzgogzn6bzkgplq.jpeg"><br><br>  Wenn jetzt viele Pakete gesendet werden k√∂nnen, erh√∂ht sich der Puffer, die Daten√ºbertragung beschleunigt sich, die Gr√∂√üe des Puffers w√§chst, alles scheint gro√üartig zu sein. <br><br>  Aber es gibt ein Problem.  Wenn der Puffer vergr√∂√üert wurde, kann er nicht so einfach reduziert werden.  Dies ist eine schwierigere Aufgabe.  Wenn die Geschwindigkeit nachl√§sst, tritt die gleiche Pufferquellung auf.  Der Puffer ist ziemlich gro√ü und voll. Wir m√ºssen warten, bis alle Daten an den Client gesendet wurden. <br><br>  Wenn wir unser eigenes UDP-Protokoll schreiben, ist alles sehr einfach - wir haben Zugriff auf den Puffer. <br><br><img src="https://habrastorage.org/webt/ow/lz/5m/owlz5m0em5dqvtz3ni14pgc3khm.jpeg"><br><br>  Wenn TCP in solchen Situationen einfach Daten am Ende hinzuf√ºgt und Sie nichts tun k√∂nnen, k√∂nnen Sie in einem selbst erstellten Protokoll Daten beispielsweise unmittelbar nach On-the-Fly-Paketen weiterleiten. <br><br>  Und wenn Abbrechen kommt und der Client sagt, dass dieses Bild nicht mehr ben√∂tigt wird, ben√∂tigt er die API-Daten, er hat den Inhalt weiter gescrollt, Sie k√∂nnen all dies aus dem Puffer werfen und das erforderliche senden. <br><br>  Wie wird das gemacht?  Es ist bekannt, dass Sie zum Wiederherstellen von Paketen, Verwalten der Zustellung und Empfangen von Best√§tigungen eine Sequenz-ID von Paketen ben√∂tigen.  Sequence_id Wir werden nur f√ºr On-the-Fly-Pakete geschrieben, dh wir geben sie nur aus, wenn wir Pakete senden.  Alles andere im Puffer kann beliebig verschoben werden, bis die Pakete verschwunden sind. <br><br>  <strong>Fazit:</strong> Der TCP-Puffer muss korrekt konfiguriert sein, das Gleichgewicht abfangen, um nicht an das Netzwerk zu sto√üen und den Puffer nicht aufzublasen.  F√ºr Ihr eigenes UDP-Protokoll ist alles einfach - dies kann gesteuert werden. <br><br><h3>  Verlustbehaftetes Netzwerkmodell </h3><br>  Wir bewegen uns auf eine h√∂here Ebene, das Netzwerk wird etwas komplizierter, Paketverlust tritt darin auf.  F√ºr Mobilfunknetze ist dies eine h√§ufige Situation.  Einige der gesendeten Pakete erreichen den Client nicht.  Der Standard-Wiederherstellungsalgorithmus f√ºr die erneute √úbertragung funktioniert ungef√§hr so: <br><br><img src="https://habrastorage.org/webt/tg/z7/tv/tgz7tvr6zchscr49onnqepvjvje.jpeg"><br><br>  Sendet Pakete, denn jedes Paket erh√§lt eine Best√§tigung.   Retransmit timeout (RTO)  RTT     ,   . <br><br>     TCP,    5% ,     50%. <br><br><img src="https://habrastorage.org/webt/ob/vi/qf/obviqfawoiesuiex2yqf_idbvei.jpeg"><br><br>  retransmit,    ,      .    ,  ,   Congestion control. <br><br><h3> Congestion control </h3><br>      flow control,    . <br><br><img src="https://habrastorage.org/webt/bc/3k/g9/bc3kg9sb5k5sppttampxxaeaypu.jpeg"><br><br><ul><li> <b>Flow control</b> ‚Äî      .  ,           ,      .    flow control  recv window,      .  flow control ‚Äî  back pressure  ,    -    . </li><li>  <b>congestion control</b>   .  ,   ‚Äî    . </li></ul><br><img src="https://habrastorage.org/webt/mf/b5/9d/mfb59d5xp1ph_irk_rhkckjpbew.jpeg"><br><br>   ,     :  ,    ,    ,      .        ,     congestion control. <br><br>    TCP window. <br><br><img src="https://habrastorage.org/webt/tj/u0/9s/tju09sic8asow88ehlwsuyfjj6q.jpeg"><br><br>     flow control  congestion control,       . <br><br>  Beispiele: <br><br><ul><li>  TCP window = 1,       :  acknowledgement,     .. </li><li>  TCP window = 4,       ,  acknowledgement   . </li></ul><br>    ,    .  initial window  TCP = 10. <br><br><img src="https://habrastorage.org/webt/ar/jf/ja/arjfjayzxewtfl-iulsna677qa0.jpeg"><br><br>    ,  ,        . <br><br>     ? <br><br><img src="https://habrastorage.org/webt/yj/ck/_t/yjck_tpkuuze0pjmkdb5mhfrlri.jpeg"><br><br><ul><li>    ,    .     ,      . </li><li>      :   , acknowledgements   . </li><li>            -    , acknowledgements      ( ). </li></ul><br>       . <br><br><img src="https://habrastorage.org/webt/jp/6c/di/jp6cdirmtiqosalz9vw-mvkjkei.jpeg"><br><br>   ,    ,   .     :     ,     ..    ,      .   congestion control,  TCP window,    ,    . <br><br><img src="https://habrastorage.org/webt/__/w0/zg/__w0zgqdiycta2u7yla0svmhof4.jpeg"><br><br>     congestion control,   ,   ‚Äî   .      packet loss ‚Äî  ,   .        ,   ,         ‚Äî    ,    . <br><br> ,  TCP , ,   congestion control   loss-.    congestion control  loss delay,     ,   . <br><br><img src="https://habrastorage.org/webt/44/no/5k/44no5kuc601zfx2h8dm_kwoqete.jpeg"><br><br> : <br><br><ul><li> <b>Cubic</b> ‚Äî  Congestion Control  Linux 2.6.        :   ‚Äî  . </li><li> <b>BBR</b> ‚Äî   Congestion Control,    Google  2016 .   . </li></ul><br><h3> BBR Congestion Control </h3><br>   Cubic  BBR   feedback. <br><br><img src="https://habrastorage.org/webt/7u/5z/zr/7u5zzrcv5cr3eyywvi0ui75qxr8.jpeg"><br><br>       ,      ‚Äî   acknowledgement       .   : <br><br><ul><li> BBR ,    ,    ,    . </li><li> Cubic        . </li></ul><br>  Unten sehen Sie eine grafische Darstellung der Verz√∂gerung gegen√ºber der Verbindungszeit, die zeigt, was bei verschiedenen √úberlastungssteuerungen geschieht. <br><br><img src="https://habrastorage.org/webt/xn/l5/c_/xnl5c_gfgpby_vchj-lt5ftptta.jpeg"><br><br>  Der BBR erfasst zuerst die Umlaufzeit, sendet immer mehr Pakete, stellt dann fest, dass der Puffer verstopft ist, und wechselt mit minimaler Verz√∂gerung in den Betriebsmodus. <br><br>  Cubic arbeitet aggressiv - es l√§uft √ºber den gesamten Puffer, und wenn der Puffer √ºberl√§uft und Paketverlust auftritt, reduziert Cubic das Fenster. <br><br>  Es scheint, dass es mit Hilfe von BBR m√∂glich w√§re, alle Probleme zu l√∂sen, aber es gibt <strong>Jitter</strong> in den Netzwerken - Pakete werden manchmal verz√∂gert, manchmal in B√ºndeln gruppiert.  Sie senden sie mit einer bestimmten H√§ufigkeit und sie kommen in Gruppen.  Schlimmer noch, wenn Sie Best√§tigungen zur√ºck zu diesen Paketen erhalten, und sie auch irgendwie "jitter". <br><br>  Da ich versprochen habe, dass alles von Hand ber√ºhrt werden kann, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pingen</a> wir zum Beispiel die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++ -</a> Site an, schauen uns Ping an und betrachten Jitter zwischen Paketen. <br><br><img src="https://habrastorage.org/webt/be/pu/fj/bepufjz6mtygfhqppfkeyvi3phq.jpeg"><br><br>  Es ist ersichtlich, dass die Pakete ungleichm√§√üig kommen, der durchschnittliche Jitter betr√§gt ca. 50 ms.  Nat√ºrlich kann BBR falsch sein. <br><br>  BBR ist gut, weil es unterscheidet zwischen: echtem √úberlastungsverlust, Paketverlust aufgrund von Ger√§tepuffer√ºberl√§ufen und zuf√§lligem Verlust aufgrund eines schlechten drahtlosen Netzwerks.  Bei hohem Jitter funktioniert es jedoch nicht gut.  Wie kann ich ihm helfen? <br><br><h3>  So verbessern Sie die √úberlastungskontrolle </h3><br>  Tats√§chlich hat TCP nicht gen√ºgend Informationen zur Best√§tigung, sondern nur die Pakete, die es gesehen hat.  Es gibt auch eine selektive Best√§tigung, die besagt, welche Pakete best√§tigt wurden, welche noch nicht angekommen sind.  Diese Informationen reichen jedoch nicht aus. <br><br><img src="https://habrastorage.org/webt/fs/9j/gm/fs9jgmfd67brdk7wynu6sqjprk8.jpeg"><br><br>  Wenn Sie die M√∂glichkeit haben, die Best√§tigung aufzubl√§hen, k√∂nnen Sie trotzdem die ganze Zeit sparen - nicht nur diese Pakete senden, sondern auch beim Client ankommen.  Das ist in der Tat auf dem Server, um den Jitter-Client zu sammeln. <br><br>  Warum ist es im Allgemeinen effektiv, die Best√§tigung zu erh√∂hen?  Weil Mobilfunknetze asymmetrisch sind.  Beispielsweise werden normalerweise mit 3G oder LTE 70% der Bandbreite f√ºr das Herunterladen von Daten und 30% f√ºr das Hochladen zugewiesen.  Der Sender wechselt: Upload - Download, Upload - Download, und Sie haben keinerlei Auswirkungen darauf.  Wenn Sie nichts entladen, ist es einfach im Leerlauf.  Wenn Sie also interessante Ideen haben, erh√∂hen Sie die Anerkennung, seien Sie nicht sch√ºchtern - dies ist kein Problem. <br><br><img src="https://habrastorage.org/webt/cv/0t/gd/cv0tgdq9vzirpmrvzx4optqe0ik.jpeg"><br><br>  Ein Beispiel daf√ºr, wie Sie mithilfe einer Best√§tigung den Jitter in Senden und Empfangen in Jitter unterteilen und separat verfolgen k√∂nnen.  Dann werden wir flexibler und verstehen, wann ein √úberlastungsverlust aufgetreten ist und wann ein zuf√§lliger Verlust aufgetreten ist.  Sie k√∂nnen beispielsweise verstehen, wie viel Jitter in jeder Richtung vorhanden ist, und das Fenster genauer konfigurieren. <br><br><img src="https://habrastorage.org/webt/ti/qj/zk/tiqjzkihljlcb2pn2oj-wdlbmkq.jpeg"><br><br><h3>  Welche √úberlastungskontrolle soll man w√§hlen? </h3><br>  Klassenkameraden sind ein gro√ües Netzwerk mit viel unterschiedlichem Verkehr: Video, API, Bilder.  Und es gibt Statistiken, f√ºr die die √úberlastungskontrolle besser zu w√§hlen ist. <br><br>  BBR ist f√ºr Videos immer effektiv, da es Verz√∂gerungen reduziert.  In anderen F√§llen wird normalerweise Cubic verwendet - es ist gut f√ºr Fotos.  Es gibt aber auch andere M√∂glichkeiten. <br><br><img src="https://habrastorage.org/webt/9m/ea/gd/9meagdum2m9dvmtn4eeawrmbtay.jpeg"><br><br>  Es gibt Dutzende verschiedener Optionen zur √úberlastungskontrolle.  Um die beste auszuw√§hlen, k√∂nnen Sie Statistiken auf dem Client sammeln und die eine oder andere √úberlastungskontrolle f√ºr verschiedene Arten von Lastprofilen ausprobieren. <br><br>  Dies ist beispielsweise der Effekt des Startens von BBR f√ºr ein Video. <br><br><img src="https://habrastorage.org/webt/hy/h8/dh/hyh8dhiugrgtyl6vgaozjzitnxq.jpeg"><br><br>  Wir haben es geschafft, die Betrachtungstiefe ernsthaft zu erh√∂hen.  Google sagt, dass der Player bei Verwendung von BBR etwa 10% weniger Puffer enth√§lt. <br><br>  Gro√üartig, aber was ist mit unseren Kunden? <br><br><img src="https://habrastorage.org/webt/np/m1/uy/npm1uywvt78qoudkof3mkebqrj8.jpeg"><br><br>  Kunden sind etwas langsam, sie haben alle Cubic und Sie k√∂nnen es nicht beeinflussen.  Aber es ist okay, manchmal k√∂nnen Sie Daten parallelisieren, und es wird gut sein. <br><br>  <strong>Schlussfolgerungen zur √úberlastungskontrolle:</strong> <br><br><ul><li>  BBR ist immer gut f√ºr Videos. </li><li>  In anderen F√§llen k√∂nnen Sie die √úberlastungskontrolle mitnehmen, wenn wir unser eigenes UDP-Protokoll verwenden. </li><li>  Aus TCP-Sicht k√∂nnen Sie nur die √úberlastungskontrolle verwenden, die sich im Kernel befindet.  Wenn Sie Ihre √úberlastungskontrolle im Kernel implementieren m√∂chten, m√ºssen Sie die TCP-Spezifikation einhalten.  Es ist unm√∂glich, die Best√§tigung zu erh√∂hen, √Ñnderungen vorzunehmen, weil sie einfach nicht auf dem Client liegen. </li></ul><br><blockquote>  Wenn Sie Ihr UDP-Protokoll erstellen, haben Sie viel mehr Freiheit bei der √úberlastungskontrolle. </blockquote><br><h3>  Multiplexing und Priorisierung </h3><br>  Dies ist ein neuer Trend, jeder macht es jetzt.  Welche Probleme gibt es?  Wenn wir TCP verwenden, kennt sicherlich jeder (oder fast jeder) die Head-of-Line-Blockierungssituation. <br><br><img src="https://habrastorage.org/webt/zv/rt/6t/zvrt6t3igpnzn4vea3lgdw7vb1e.jpeg"><br><br>  Es gibt mehrere Anforderungen, die √ºber eine einzelne TCP-Verbindung gemultiplext werden.  Wir haben sie an das Netzwerk gesendet, aber ein Paket fehlte.  Eine TCP-Verbindung √ºbertr√§gt dieses Paket erneut, und zwar in einer Zeit nahe RTT oder l√§nger.  Derzeit k√∂nnen wir nichts abrufen, obwohl der TCP-Puffer Daten von einer anderen Anforderung enth√§lt, die vollst√§ndig zur Abholung bereit ist. <br><br><blockquote>  Es stellt sich heraus, dass Multiplexing √ºber TCP, wenn Sie HTTP 2.0 verwenden, in schlechten Netzwerken nicht immer effektiv ist. </blockquote><br>  Das n√§chste Problem ist die Pufferquellung. <br><br><img src="https://habrastorage.org/webt/fy/zh/rw/fyzhrwlr4mmtdgxwhp-mxfa9k-y.jpeg"><br><br>  Wenn ein Bild an den Client gesendet wird, erh√∂ht sich der Puffer.  Wir senden es f√ºr eine lange Zeit, und dann erscheint eine API-Anfrage, die in keiner Weise priorisiert werden kann.  In solchen F√§llen funktioniert die TCP-Priorisierung nicht. <br><br>  Wenn also ein Paketverlust auftritt, kommt es zu einer Head-of-Line-Blockierung, und wenn der Client eine variable Bitrate hat (und dies passiert h√§ufig bei mobilen Clients), wird der Bufferbloat-Effekt angezeigt.  Infolgedessen funktionieren weder Multiplexing noch Priorisierung noch Server-Push oder alles andere, da wir entweder Puffer haben oder der Client etwas erwartet. <br><br>  Wenn wir unser eigenes Multiplexing durchf√ºhren, k√∂nnen wir dort verschiedene Daten ablegen. <br><br><img src="https://habrastorage.org/webt/_g/er/5g/_ger5gqpdxllo3-p1eo7ytzupce.jpeg"><br><br>  Dies ist nicht schwierig, f√ºgen Sie einfach Pakete mit Zahlen zum Puffer hinzu.  On-the-Fly - Ber√ºhren Sie nicht, was bereits gesendet wurde, aber was noch nicht gesendet wurde, kann neu angeordnet werden.  Es sieht so aus. <br><br><img src="https://habrastorage.org/webt/9g/_v/xr/9g_vxrrlkavxucnmocy3kggc-f8.jpeg"><br><br>  Sie haben Bilder gesendet, sie in Pakete aufgeteilt, eine vorrangige API-Anfrage gestellt: Sie haben sie eingef√ºgt und das Bild gesendet.  Selbst wenn ein Paket fehlt, k√∂nnen wir eine vorgefertigte API-Anfrage aus dem Puffer erhalten. Diese hat hohe Priorit√§t und erreicht schnell den Client.  In TCP ist per Definition keine Streaming-Daten√ºbertragung m√∂glich. <br><br><h3>  Stellen Sie eine Verbindung her </h3><br>  Wenn wir unsere Anwendung profilieren, werden wir feststellen, dass das Netzwerk zu Beginn der Anwendung die meiste Zeit inaktiv ist, da die Verbindung zuerst vor der API hergestellt wird, dann die Daten abgerufen werden und die Verbindung vor den Bildern hergestellt wird, diese Daten heruntergeladen werden usw.  Dies geschieht immer - das Netzwerk wird von Spitzen genutzt. <br><br><img src="https://habrastorage.org/webt/14/cn/ck/14cnckztbu1v-otwf__j9dqzahu.jpeg"><br><br>  Lassen Sie uns sehen, wie die Verbindung hergestellt wird, um damit umzugehen. <br><br><img src="https://habrastorage.org/webt/ca/eb/ij/caebijcqzlqj0h5soblnfudqedo.jpeg"><br><br>  Das erste ist DNS aufl√∂sen - wir k√∂nnen damit nichts anfangen.  Stellen Sie als N√§chstes eine TCP-Verbindung her, stellen Sie eine sichere Verbindung her, f√ºhren Sie die Anforderung aus und erhalten Sie eine Antwort.  Das Interessanteste ist, dass ein Teil der Arbeit, die der Server bei der Beantwortung einer Anfrage leistet, normalerweise weniger Zeit in Anspruch nimmt als das Herstellen einer Verbindung. <br><br>  Jetzt ist es sehr modern, Latenzzahlen f√ºr Speicher, Festplatten und etwas anderes zu messen.  Sie k√∂nnen sie f√ºr ein 3G-, 4G-Netzwerk messen und sehen, wie lange es im schlimmsten Fall dauert, eine TCP-Verbindung mit TLS herzustellen. <br><br><img src="https://habrastorage.org/webt/qe/ux/1p/qeux1p7brp9mvpxeptinhubywmc.jpeg"><br><br>  Und es kann Sekunden sein!  Auch bei 4G sind bis zu 700 ms von Bedeutung.  Aber TCP konnte die ganze Zeit nicht so einfach leben. <br><br>  Die Verbindung basiert auf dem grundlegenden <strong>TCP-3-Wege-Handshake-</strong> Algorithmus.  F√ºhren Sie syn, syn + ack aus und korrigieren Sie die Anforderung sp√§ter (links im Diagramm). <br><br><img src="https://habrastorage.org/webt/ty/mj/-a/tymj-amfsa1c4j8sirtaspnvq1o.jpeg"><br><br>  Es gibt <strong>TCP Fast Open</strong> (rechts).  Wenn Sie bereits mit diesem Server von Hand gesch√ºttelt haben, gibt es ein Cookie. Sie k√∂nnen Ihre Anfrage f√ºr Zero-RTT sofort senden.  Um dies zu verwenden, m√ºssen Sie einen Socket erstellen, sendto () zu den ersten Daten machen und sagen, dass Sie FASTOPEN m√∂chten. <br><br><img src="https://habrastorage.org/webt/ab/kl/b9/abklb93dq3g__tw2rihxrhagkl8.jpeg"><br><br>  Nginx kann all dies - schalten Sie es einfach ein, alles wird funktionieren (oder schalten Sie es im Kernel ein). <br><br><h2>  TLS </h2><br>  Lassen Sie uns √ºberpr√ºfen, ob TLS schlecht ist. <br><br>  Ich stellte den Net Shaper erneut f√ºr 200 ms ein, pingte google.com und sah, dass RTT = 220 mein RTT + RTT Shaper ist.  Dann habe ich eine Anfrage √ºber HTTP und HTTPS gestellt.  Ich habe herausgefunden, dass es √ºber HTTP m√∂glich ist, w√§hrend RTT eine Antwort zu erhalten, dh TFO funktioniert f√ºr Google von meinem Computer aus.  Bei HTTPS dauerte dies l√§nger. <br><br><img src="https://habrastorage.org/webt/po/hl/kj/pohlkjs39dl7kk3rp5kzbxrwsna.jpeg"><br><br>  Dies ist ein so h√§ufiger TLS-Overhead, f√ºr den Messaging erforderlich ist, um eine sichere Verbindung herzustellen. <br><br><img src="https://habrastorage.org/webt/zf/j2/qn/zfj2qndcohpiok8cqpc82kiun3s.jpeg"><br><br>  Um dies zu tun, haben sie f√ºr uns gedacht, TLS 1.3 hinzugef√ºgt.  Es ist auch einfach, in Nginx aufzunehmen. <br><br><img src="https://habrastorage.org/webt/m5/eo/i0/m5eoi0z5a2rzb4hthqlbjchxhyi.jpeg"><br><br>  Alles scheint zu funktionieren.  Aber mal sehen, was auf unseren mobilen Clients ist, die all dies nutzen. <br><br><h3>  Was ist mit Kunden los? </h3><br>  TCP Fast Open ist eine coole Sache.  Laut Statistik. <br><br><img src="https://habrastorage.org/webt/pq/yy/l8/pqyyl89jhtoulpwalg61q8pqbnw.jpeg"><br><br>  Es gibt viele Artikel, die besagen, dass das Herstellen einer Verbindung garantiert 10% schneller verl√§uft.  Aber auf Android 8.1.0 (ich habe verschiedene Ger√§te gesehen) hat niemand TFO.  Unter Android 9 habe ich TFO auf dem Emulator gesehen, aber nicht auf echten Ger√§ten.  IOS ist ein bisschen besser.  Hier k√∂nnen Sie es sehen: <br><br><pre><code class="plaintext hljs">sysctl -a | grep fast net.ipv4.tcp_fastopen = 0</code> </pre> <br>  Warum ist das passiert?  TCP Fast Open wurde bereits 2014 vorgeschlagen, jetzt ist es bereits ein Standard, es wird unter Linux unterst√ºtzt und alles ist gro√üartig.  Es gibt jedoch ein derartiges Problem, dass der TFO-Handshake in einigen Netzwerken auseinanderzufallen begann.  Dies liegt daran, dass einige Anbieter (oder einige Ger√§te) es gewohnt sind, TCP zu √ºberpr√ºfen und ihre Optimierungen vorzunehmen, und nicht damit gerechnet haben, dass es zu einem TFO-Handshake kommt.  Daher hat die Implementierung so viel Zeit in Anspruch genommen, und bis jetzt enthalten mobile Clients sie standardm√§√üig nicht, zumindest nicht Android. <br><br>  Mit TLS 1.3, das uns verspricht, dass der Aufbau einer Null-RTT-Verbindung noch besser ist.  Ich habe keine Android-Ger√§te gefunden, auf denen es funktionieren w√ºrde.  Deshalb hat Facebook die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fizz-</a> Bibliothek erstellt.  Vor ein paar Monaten wurde es in Open Source verf√ºgbar. Sie k√∂nnen es mit sich ziehen und TLS 1.3 verwenden.  Es stellt sich heraus, dass sogar Sicherheit mitgeschleppt werden muss, nichts erscheint im Kern davon. <br><br><img src="https://habrastorage.org/webt/07/qm/kf/07qmkfwywo3llz5nrrh04kg3a_o.jpeg"><br><br>  Das Diagramm zeigt die Verwendung verschiedener Android-Versionen durch unsere mobilen Clients.  V 9.x ist ziemlich viel - wo TFO erscheinen kann und TLS1.3 nirgendwo anders zu finden ist. <br><br>  <strong>Schlussfolgerungen zum Herstellen einer Verbindung:</strong> <br><br><ul><li>  TFO ist f√ºr 95% der Ger√§te nicht verf√ºgbar. </li><li>  TLS1.3 muss mitgebracht werden. </li><li>  Wenn Sie dies in UDP wiederholen m√ºssen, √ºbertragen Sie dies alles auf UDP und wiederholen Sie den Vorgang. </li></ul><br><img src="https://habrastorage.org/webt/n2/tj/v1/n2tjv1g-04l2jfghy_6--uqaqjc.jpeg"><br><br>  Es stellte sich heraus, dass 97% der erstellten Verbindungen den vorhandenen Schl√ºssel verwenden, dh 97% werden f√ºr RTT Null erstellt und nur 3% sind neu.  Der Schl√ºssel ist einige Zeit auf dem Ger√§t gespeichert. <br><br>  TCP kann nicht damit prahlen.  In maximal 5% der F√§lle k√∂nnen Sie, wenn Sie alles richtig machen, die echte Null-RTT erhalten, √ºber die jetzt alle sprechen. <br><br><h2>  √Ñnderung der IP-Adresse </h2><br>  Wenn Sie das Haus verlassen, wechselt Ihr Telefon h√§ufig von Wi-Fi zu 4G. <br><br><blockquote>  TCP funktioniert folgenderma√üen: Die IP-Adresse hat sich ge√§ndert - die Verbindung ist fehlgeschlagen. </blockquote><br><img src="https://habrastorage.org/webt/km/nu/u8/kmnuu8dtr8jeipuzx4bhpfezuwm.jpeg"><br><br>  Wenn Sie Ihr UDP-Protokoll schreiben, ist es sehr einfach, indem Sie in jedem Paket eine Verbindungs-ID (CUID) implementieren. Sie k√∂nnen es identifizieren, auch wenn es von einer anderen IP-Adresse stammt. <br><br><img src="https://habrastorage.org/webt/xu/ga/r_/xugar_l9pbltv6419btnrimfhv8.jpeg"><br><br>  Es ist klar, dass Sie sicherstellen m√ºssen, dass es den richtigen Schl√ºssel hat, alles entschl√ºsselt ist usw.  Aber im Prinzip k√∂nnen Sie auf diese Adresse antworten, es wird keine Probleme damit geben. <br><br><blockquote>  In TCP ist die IP-Migration unm√∂glich. </blockquote><br>  Wenn Sie Ihr UDP erstellen und zum selben Server gekommen sind, m√ºssen Sie ein wenig zaubern, die CID in jedes Paket aufnehmen und die hergestellte Verbindung beim √Ñndern der IP-Adresse verwenden. <br><br><h2>  Wiederverwendung der Verbindung </h2><br>  Jeder sagt, dass Sie Verbindungen wiederverwenden m√ºssen, weil Verbindungen eine sehr teure Sache sind. <br><br><img src="https://habrastorage.org/webt/8-/lr/ot/8-lrot44ac9mwo6m7ue_ksezk0g.jpeg"><br><br>  Die Wiederverwendung von Verbindungen birgt jedoch Fallstricke. <br><br><img src="https://habrastorage.org/webt/_n/aa/z3/_naaz3uac-hwdd7uikndioiupry.jpeg"><br><br>  Wahrscheinlich erinnern sich viele Leute (wenn nicht, dann sehen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ), dass nicht jeder √∂ffentliche Adressen hat, aber es gibt NAT, das normalerweise die Zuordnung f√ºr einige Zeit auf dem Heimrouter speichert.  F√ºr TCP ist klar, wie viel gespeichert werden soll, f√ºr UDP ist jedoch nicht klar.  NAT arbeitet mit einem Timeout. Wenn Sie dieses Timeout sorgf√§ltig messen, stellen wir fest, dass in etwa 15 bis 30 Sekunden mehr als 50% der Verbindungen ausfallen. <br><br>  Es ist okay - wir machen f√ºr 15 s ein Ping-Pong-Paket.  In F√§llen, in denen die Verbindung immer noch unterbrochen ist, gibt es eine IP-Migration, mit der Sie den Port des Routers kosteng√ºnstig √§ndern k√∂nnen. <br><br><img src="https://habrastorage.org/webt/7g/mu/bf/7gmubflfj-yenwqvgiqbkc8toa8.jpeg"><br><br><h2>  Paketstimulation </h2><br>  Dies ist sehr wichtig, wenn Sie Ihr UDP-Protokoll ausf√ºhren. <br><br><img src="https://habrastorage.org/webt/cf/d5/97/cfd597jt4v7uopygyyu-dfsx_8s.jpeg"><br><br>  Wenn dies sehr einfach ist, ist die Wahrscheinlichkeit eines Paketverlusts umso gr√∂√üer, je l√§nger Sie kontinuierlich Pakete an das Netzwerk senden.  Wenn Sie Pakete herausfiltern, ist der Paketverlust geringer. <br><br>  Es gibt viele verschiedene Theorien, wie das funktioniert, aber ich mag diese. <br><br><img src="https://habrastorage.org/webt/75/79/xl/7579xlvo70vmotoqjjp3zmmplr8.jpeg"><br><br>  Es gibt 3 Verbindungen, die gleichzeitig erstellt werden.  Sie haben das sogenannte Anfangsfenster - 10 Pakete gleichzeitig erstellt.  Nat√ºrlich reicht die Bandbreite zu diesem Zeitpunkt m√∂glicherweise nicht aus.  Wenn Sie sie jedoch sorgf√§ltig verteilen und trennen, ist alles in Ordnung, wie in der richtigen Abbildung dargestellt. <br><br>  Wenn Sie also eine einheitliche Rate f√ºr das Senden von Paketen festlegen und diese ausd√ºnnen, wird die Wahrscheinlichkeit eines gleichzeitigen Puffer√ºberlaufs geringer.  Dies ist nicht bewiesen, aber theoretisch sieht es so aus. <br><br><img src="https://habrastorage.org/webt/vw/mg/vw/vwmgvw6oyq3v_yaliklp4ilnocm.jpeg"><br><br>  Wenn Sie Pakete durchschneiden m√ºssen (Schritt machen): <br><br><ul><li>  Wenn Sie ein Fenster erstellen. </li><li>  Wenn Sie beispielsweise das Fenster vergr√∂√üern, wird empfohlen, so viele Pakete hinzuzuf√ºgen, wie f√ºr RTT / 2 gesendet werden k√∂nnen.  Dies verk√ºrzt die Lieferzeit nicht, verringert jedoch den Paketverlust. </li><li>  Im Falle eines √úberlastungsverlusts m√ºssen Sie die Pakete noch mehr verschmieren, um das Fenster zu verkleinern.  4/5 RTT ist eine empirisch ausgew√§hlte Zahl. </li></ul><br><h2>  MTU </h2><br>  Denken Sie beim Schreiben Ihres UDP-Protokolls unbedingt an MTU.  MTU ist die Gr√∂√üe der Daten, die Sie weiterleiten k√∂nnen. <br><br><img src="https://habrastorage.org/webt/c2/7_/ow/c27_ow36h5amg3d4zkskjph_ama.jpeg"><br><br>  Wir senden beispielsweise Pakete vom Server an den Client mit einer Gr√∂√üe von 1500. Wenn sich auf dem Pfad ein Router befindet, der diese MTU-Gr√∂√üe nicht unterst√ºtzt, wird er fragmentiert.  Das einzige Fragmentierungsproblem besteht darin, dass bei einem Verlust eines Pakets beide verloren gehen und all dies erneut √ºbertragen werden muss.  Daher verf√ºgt TCP √ºber einen Algorithmus zur Bestimmung von MTU - PMTU. <br><br><img src="https://habrastorage.org/webt/je/gs/ks/jegskszkwrb3pm2nghgfpplez8o.jpeg"><br><br>  Jeder Router betrachtet die MTU seiner Schnittstelle, sendet sie an einen Client, der andere sendet sie an seinen Client, jeder wei√ü, wie viele MTUs er auf dem Client hat.  Dann wird die Fragmentierung durch das Flag verhindert und Pakete der Gr√∂√üe MTU werden gesendet.  Wenn in diesem Moment jemand im Netzwerk feststellt, dass er weniger MTU hat, sagt er √ºber ICMP: "Entschuldigung, das Paket ist verloren gegangen, weil eine Fragmentierung erforderlich ist" und gibt die Gr√∂√üe der MTU an.  Wir werden diese Gr√∂√üe √§ndern und den Versand fortsetzen.  Im schlimmsten Fall ist unser kleiner Overhead RTT / 2.  Dies ist in TCP. <br><br><img src="https://habrastorage.org/webt/vl/br/fo/vlbrfo8a7p80neysmtjguosakww.jpeg"><br><br>  Wenn Sie sich in UDP nicht mit ICMP besch√§ftigen m√∂chten, k√∂nnen Sie Folgendes tun: Fragmentierung beim Senden normaler Daten zulassen.  Das hei√üt, fragmentierte Pakete senden - lassen Sie sie arbeiten.  Parallel zum Ausw√§hlen eines Prozesses, der die Fragmentierung verhindert, wird bei einer bin√§ren Suche die optimale MTU ausgew√§hlt, zu der wir dann gehen.  Dies ist nicht ganz effektiv, da sich die MTU zun√§chst aufzuw√§rmen scheint. <br><br>  Eine schwierigere Option besteht darin, die Verteilung der MTU auf mobile Clients zu untersuchen. <br><br><img src="https://habrastorage.org/webt/ie/a5/w8/iea5w8h3msrkprfxpgfhb2nkjyu.jpeg"><br><br>  Von allen Kunden haben wir Pakete unterschiedlicher Gr√∂√üe mit dem Verbot der Fragmentierung gesendet.  Das hei√üt, wenn das Paket nicht erreicht wird, f√§llt es ab und die kleinste MTU sollte 100% erreichen.  Da es jedoch einen kleinen Paketverlust gibt, gibt es zwei Folien in der Tabelle: <br><br><ol><li>  1350 Bytes - statt 98% erhalten wir sofort 95% Lieferung. </li><li>  1500 Bytes - MTU, nach der bereits 80% der Clients solche Pakete nicht empfangen. </li></ol><br><blockquote>  In der Tat k√∂nnen wir das sagen: Wir vernachl√§ssigen 1-2% unserer Kunden, lassen sie von fragmentierten Paketen leben.  Aber wir werden sofort von dem ausgehen, was wir brauchen - das ist ab 1350. </blockquote><br><h2>  Fehlerkorrektur (SACK, NACK, FEC) </h2><br>  Wenn Sie Ihr Protokoll erstellen, m√ºssen Sie die Fehler korrigieren.  Wenn das Paket fehlt (dies ist normal f√ºr drahtlose Netzwerke), muss es wiederhergestellt werden. <br><br>  Im einfachsten Fall (weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) gibt es ein Relais √ºber Retransmit Time Out (RTO).  Wenn das Paket fehlt, warten Sie auf die Zeit f√ºr die erneute √úbertragung und senden Sie es erneut. <br><br>  Der n√§chste Algorithmus ist <b>Fast Retransmit</b> .  Dies sind alles TCP-Algorithmen, die jedoch problemlos auf UDP portiert werden k√∂nnen. <br><br><img src="https://habrastorage.org/webt/hm/s1/ee/hms1eey-ntpj2x0piswhxc4e5fa.jpeg"><br><br>  Wenn das Paket weg ist, senden wir weiter - es werden andere Pakete √ºbertragen.  Zu diesem Zeitpunkt gibt der Server an, dass er das n√§chste Paket empfangen hat, aber es gab kein vorheriges.  Dazu macht er eine knifflige Best√§tigung, die der Paketnummer + 1 entspricht, und setzt das Flag f√ºr die doppelte Best√§tigung.  Er sendet diese Dup Ack so, und am dritten verstehen wir normalerweise, dass das Paket verschwunden ist und senden es erneut. <br><br>  Was Sie sonst noch edel machen m√∂chten, was nicht in TCP enthalten ist und was sie in UDP tun m√∂chten, ist die <b>Vorw√§rtsfehlerkorrektur</b> . <br><br><img src="https://habrastorage.org/webt/ex/_u/gg/ex_uggyt0-4ntdgzy-vn7hvmyzg.jpeg"><br><br>  Es scheint, dass wir, wenn wir wissen, dass Pakete verloren gehen k√∂nnen, eine Reihe von Paketen nehmen, ein XOR-Paket hinzuf√ºgen und das Problem ohne zus√§tzliche Neu√ºbertragungen sofort auf dem Client beim Empfang von Daten beheben k√∂nnen.  Es gibt jedoch ein Problem, wenn mehrere Pakete verschwinden.  Es scheint, dass es durch Parit√§tsschutz, Reed-Solomon usw. gel√∂st werden kann. <br><br>  Wir haben es so versucht, es stellte sich heraus, dass die Pakete tats√§chlich in B√ºndeln verschwinden. <br><br><img src="https://habrastorage.org/webt/fg/qo/jj/fgqojj1gas9pgutyyyzkla_m5ze.jpeg"><br><br>  Die durchschnittliche Paketl√ºcke betrug 6. Dies ist eine sehr unpraktische Paketl√ºcke - Sie ben√∂tigen viele Fehlerkorrekturcodes.  Gleichzeitig gibt es bei 11 eine Art Peak - ich wei√ü nicht warum, aber Pakete verschwinden manchmal in Paketen von 11.  Aufgrund dieser Paketl√ºcke funktioniert dies nicht. <br><br>  Google hat das auch versucht, jeder tr√§umt von FEC, aber bisher hat niemand gearbeitet. <br><br>  Es gibt eine andere Option, wenn FEC helfen kann. <br><br><img src="https://habrastorage.org/webt/d9/tb/tw/d9tbtwafxbt_t08_j9wvarw5icc.jpeg"><br><br>  Zus√§tzlich zur erneuten √úbertragung durch Retransmit Time Out, Fast Retransmit, gibt es auch eine <strong>Schwanzverlustsonde</strong> .  Dies ist so etwas, wenn Sie Daten senden und der Schwanz weg ist.  Das hei√üt, Sie haben einen Teil der Daten gesendet und das f√ºnfte Paket gesendet - es ist angekommen.  Dann begannen Pakete zu verschwinden, zum Beispiel weil das Netzwerk ausgefallen war.  Pakete verschwinden, verschwinden und Sie haben nur f√ºr das f√ºnfte Paket eine Best√§tigung erhalten. <br><br>  Um zu verstehen, ob diese Daten erreicht sind, fragen Sie nach einer Weile, ob Sie mit dem TLP (Tail Loss Probe) beginnen, ob das Ende empfangen wurde.  Tatsache ist, dass die Daten√ºbertragung beendet wurde und Sie nichts senden, dann funktioniert Fast Retransmit nicht.  Um dies zu beheben, f√ºhren Sie einen TLP durch. <br><br>  Sie k√∂nnen TLPs FEC hinzuf√ºgen.  Sie k√∂nnen alle nicht eingetroffenen Pakete anzeigen, die Parit√§t darauf z√§hlen und TLPs mit einem Parit√§tspaket senden. <br><br>  Das ist alles cool, es scheint zu funktionieren.  Aber es gibt so ein Problem. <br><br><img src="https://habrastorage.org/webt/pt/y5/qm/pty5qmye2nqwrocxnp3fv5-gll4.jpeg"><br><br>  Wir haben Statistiken gesammelt und es stellte sich heraus, dass 98% der Fehler durch Fast Retransmit repariert werden.  Der Rest wird √ºber Retransmit Time Out und weniger als 1% √ºber TLP repariert.  Wenn Sie etwas anderes FEC reparieren, betr√§gt es weniger als 0,5%. <br><br><blockquote>  TCP unterst√ºtzt FEC nicht.  In UDP ist dies nicht schwierig, aber im allgemeinen Fall reichen Standard-TCP-Wiederherstellungsalgorithmen aus. </blockquote><br><h2>  Leistung </h2><br>  Es w√§re m√∂glich, die Leistung durch einen Vergleich von TCP mit UDP nicht zu beeintr√§chtigen. <br><br>  TCP ist ein sehr altes Protokoll mit vielen verschiedenen Optimierungen, z. B. LSO (Large Segment Offload) und Zerocopy.  Jetzt ist f√ºr UDP alles nicht verf√ºgbar.  Daher betr√§gt die UDP-Leistung nur 20% im Vergleich zu TCP von denselben Servern.  Es gibt jedoch bereits vorgefertigte L√∂sungen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP GSO</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zerocopy</a> ), mit denen Linux dies unterst√ºtzen kann. <br><br>  Das Hauptproblem bei der Optimierung f√ºr Nullkopie und LSO besteht darin, dass die Stimulation verloren geht. <br><br><img src="https://habrastorage.org/webt/qu/6i/th/qu6ith66mowy_jm9iznjsstsadm.jpeg"><br><br><h2>  Time to Market oder was TCP get√∂tet hat </h2><br>  Vor kurzem, als mobile drahtlose Netzwerke popul√§r wurden, erschienen viele verschiedene TCP-Standards: TLP, TFO, neue √úberlastungskontrolle, RACK, BBR und mehr. <br><br><img src="https://habrastorage.org/webt/nq/lx/5a/nqlx5a_sq5zzvi2au81ulptczew.jpeg"><br><br><blockquote>  Das Hauptproblem ist jedoch, dass viele von ihnen nicht implementiert werden, da TCP angeblich verkn√∂chert ist.  In vielen F√§llen betrachten Betreiber TCP-Pakete und erwarten, dass sie sehen, was sie erwarten.  Daher ist es sehr schwierig zu √§ndern. </blockquote><br>  Dar√ºber hinaus werden mobile Clients lange Zeit aktualisiert, und wir k√∂nnen diese Updates nicht bereitstellen.  Wenn Sie sich ansehen, welche neuesten Updates auf dem Client verf√ºgbar sind und was sich auf dem Server befindet, k√∂nnen Sie sagen, dass auf dem Client fast nichts vorhanden ist. <br><br><img src="https://habrastorage.org/webt/au/57/iw/au57iwnkvrjzkvrpo2osdo7f49e.jpeg"><br><br>  Daher scheint die Entscheidung, ein Protokoll im Benutzerbereich zu schreiben, zumindest solange Sie alle diese Funktionen sammeln, nicht so schlecht zu sein. <br><br><img src="https://habrastorage.org/webt/6i/o6/po/6io6poew2qopzofy3vbflm3-5a8.jpeg"><br><br>  Mit TCP rollen Funktionen seit Jahren.  F√ºr Ihr UDP-Protokoll k√∂nnen Sie die Version buchst√§blich in einem Update von Client und Server aktualisieren.  Sie m√ºssen jedoch eine Versionsverhandlung hinzuf√ºgen. <br><br><h2>  TCP gegen selbst erstelltes UDP.  Endk√§mpfe </h2><br><img src="https://habrastorage.org/webt/fx/q6/ct/fxq6ctnz94vaf7pfr7jmrcbz7lu.jpeg"><br><br><ul><li>  Sende- / Empfangspuffer: Der ver√§nderbare Puffer kann f√ºr Ihr Protokoll erstellt werden. Es treten Probleme mit dem Aufbl√§hen des Puffers mit TCP auf. </li><li>  √úberlastungskontrolle k√∂nnen Sie vorhandene verwenden.  Bei UDP sind sie alle. </li><li>  Das neue √úberlastungssteuerelement l√§sst sich nur schwer zu TCP hinzuf√ºgen, da Sie die Best√§tigung √§ndern m√ºssen. Dies ist auf dem Client nicht m√∂glich. </li><li>  Multiplexing ist ein kritisches Thema.  Head-of-Line-Blockierung tritt auf. Wenn Sie ein Paket verlieren, k√∂nnen Sie nicht zu TCP multiplexen.  Daher sollte HTTP2.0 √ºber TCP keinen ernsthaften Anstieg bewirken. </li><li>  F√§lle, in denen Sie einen Verbindungsaufbau f√ºr 0-RTT in TCP erhalten k√∂nnen, sind √§u√üerst selten, in der Gr√∂√üenordnung von 5% und in der Gr√∂√üenordnung von 97% f√ºr selbst erstelltes UDP. </li></ul><br><img src="https://habrastorage.org/webt/4f/_f/oe/4f_foen6zvxf5mexl8p6jfu2izm.jpeg"><br><br><ul><li>  Die IP-Migration ist keine so wichtige Funktion, wird jedoch bei komplexen Abonnements und beim Speichern des Status auf dem Server unbedingt ben√∂tigt, ist jedoch nicht in TCP implementiert. </li><li>  Nat Unbindung ist nicht f√ºr UDP.  In diesem Fall muss UDP h√§ufig Ping-Pong-Pakete ausf√ºhren. </li><li>  Die Paketstimulation in UDP ist einfach, w√§hrend es keine Optimierung gibt. In TCP funktioniert diese Option nicht. </li><li>  MTU und Fehlerkorrektur sind beide vergleichbar. </li><li>  Die Geschwindigkeit von TCP ist jetzt nat√ºrlich schneller als die von UDP, wenn Sie eine Menge Verkehr verteilen.  Einige Optimierungen dauern jedoch sehr lange. </li></ul><br>  Wenn Sie das Wichtigste sammeln, hat UDP wahrscheinlich mehr Vor- als Nachteile. <br><br><img src="https://habrastorage.org/webt/p4/7k/ys/p47kysilkuqtb-x-zc0cwhigeoe.jpeg"><br><br>  <b>W√§hlen Sie UDP!</b> <br><br><h2>  Testen von selbst erstelltem UDP an Benutzern </h2><br>  Wir haben einen Pr√ºfstand zusammengestellt. <br><br><img src="https://habrastorage.org/webt/rh/er/ec/rherec8kewip9-ycek5qimdgvuw.jpeg"><br><br>  Es gibt einen Client f√ºr TCP und UDP.  Wir haben den Datenverkehr √ºber Net Shaper normalisiert, an das Internet und an den Server gesendet.  Ein REST-API-Service, der zweite mit UDP.  Und UDP verwendet dieselbe REST-API im selben Rechenzentrum, um die Daten zu √ºberpr√ºfen.  Wir haben verschiedene Profile unserer mobilen Kunden gesammelt und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Test gestartet</a> . <br><br><img src="https://habrastorage.org/webt/sy/rf/nf/syrfnflhcgpr13bngr1y7cv5fle.jpeg"><br><br>  Bei der Messung des Durchschnitts √ºber das Portal haben wir festgestellt, dass wir die Zeit f√ºr den Aufruf der API um 10% und f√ºr Bilder um 7% reduzieren konnten.  Die Nutzeraktivit√§t wuchs nur um 1%, aber wir geben nicht auf, wir denken, es wird besser. <br><br><img src="https://habrastorage.org/webt/o9/wr/bj/o9wrbjk45dk58yjji6t8boe9-xw.jpeg"><br><br>  In Bezug auf die Auslastung haben wir jetzt ungef√§hr 10 Millionen Benutzer in unserem selbst erstellten UDP, Datenverkehr mit bis zu 80 Gbit / s, 6 Millionen Pakete pro Sekunde und 20 Server, die dies alles bedienen. <br><br><h2>  UDP-Checkliste <br></h2><br>  Wenn Sie Ihr Protokoll schreiben m√∂chten, ben√∂tigen Sie eine Checkliste: <br><br><ul><li>  Tempo </li><li>  MTU-Entdeckung. </li><li>  <strong>Fehlerbehebungen erforderlich</strong> . </li><li>  Flusskontrolle und √úberlastungskontrolle. </li><li>  Optional k√∂nnen Sie die IP-Migration unterst√ºtzen. TLP ist einfach. </li></ul><br>  Denken Sie daran, dass die Kan√§le asymmetrisch sind. W√§hrend Sie Daten vom Server empfangen, ist Ihr Upload m√∂glicherweise inaktiv. Versuchen Sie es. <br><br><h2>  QUIC </h2><br>  Es w√§re unehrlich zu sagen, dass Google dies nicht getan hat. <br><br><img src="https://habrastorage.org/webt/z0/b9/-v/z0b9-v9kmmobln4nv2yado-rble.jpeg"><br><br>  Es gibt ein QUIC-Protokoll, das Google unter HTTP 2.0 implementiert hat und das fast dasselbe unterst√ºtzt. <br><br><h3>  Warum QUIC nicht so schnell ist </h3><br>  Als QUIC herauskam, gab es viel Hass gegen die Tatsache, dass Google sagt, dass alles schneller funktioniert, und "ich habe es zu Hause auf einem Computer gemessen - es funktioniert langsamer." <br><br><img src="https://habrastorage.org/webt/db/5a/vd/db5avdtu1zaito8ntcmg-hdvwy8.jpeg"><br><br>  Dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel enth√§lt eine</a> Reihe von Bildern und Ma√üen. <br><br>  Nun, es stellt sich heraus, dass wir das alles umsonst getan haben, haben die Leute f√ºr uns gemessen?  Selbst mit Codebeispielen gibt es echte Hausmessungen. <br><br><img src="https://habrastorage.org/webt/id/wr/39/idwr39saesks74hbadevlunieua.jpeg"><br><br>  Tats√§chlich wird es keine Verbesserung geben, bis Sie Anforderungen parallelisieren, in realen Netzwerken arbeiten und bis Paketverluste in √úberlastungsverlust und Zufallsverlust unterteilt sind.  Wir brauchen eine echte Emulation eines echten Netzwerks. <br><br>  Aber es gibt eine positive, sagen sie, QUIC ist weder besser noch schlechter.  Somit funktioniert QUIC in perfekten Netzwerken gut. <br><br><h2>  Die Zukunft </h2><br>  Google hat k√ºrzlich HTTP 2.0 √ºber QUIC HTTP 3 benannt, nicht zu verwechseln, da HTTP 2.0 √ºber TCP und √ºber QUIC stehen k√∂nnte.  Jetzt ist es HTTP 3. <br><br><img src="https://habrastorage.org/webt/go/ra/z4/goraz4ktgsje7ankwyipapzeow0.jpeg"><br><br>  Es gab auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google QUIC</a> - dies ist QUIC, das in Chrome implementiert ist, und iQUIC - ein standardisiertes QUIC.  Das standardisierte QUIC wurde nirgendwo implementiert, die Standard-iQUIC-Server haben kein Handshake mit Google QUIC durchgef√ºhrt.  Jetzt versprechen sie, dieses Problem zu l√∂sen, und bald wird es verf√ºgbar sein. <br><br><h3>  QUIC ist √ºberall </h3><br>  Wenn Sie immer noch nicht glauben, dass TCP tot ist, sage ich Ihnen, dass Sie QUIC und UDP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prooflink</a> ) verwenden, wenn Sie Chrome, Android und bald auch iOS verwenden und zu Google, Youtube usw. gehen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QUIC ist jetzt</a> : <br><br><ul><li>  1,9% aller Websites; </li><li>  12% des gesamten Verkehrs; </li><li>  30% des Videoverkehrs in Mobilfunknetzen. </li></ul><br>  Wie k√∂nnen Sie √ºberpr√ºfen, ob Sie QUIC verwenden, wenn Sie nicht glauben?  In Chrome Wireshark √∂ffnen.  Ich habe nach iQUIC gesucht, ich habe es nirgendwo gefunden, aber GQUIC passiert. <br><br><img src="https://habrastorage.org/webt/t_/8v/9q/t_8v9qsq9jcgbjkf9vqqr67vw7k.jpeg"><br><br>  Sie k√∂nnen auch in Ihrem Browser online gehen und sehen, was GQUIC dort ist. <br><br><img src="https://habrastorage.org/webt/av/ko/p5/avkop5nphmxm6ee3rqc2hi23wzu.jpeg"><br><br><h3>  Noch etwas Zukunft </h3><br>  Multipath wartet bald auf uns. <br><br><img src="https://habrastorage.org/webt/d8/bi/wo/d8biwobqjbdjqdn8g-wb7gegka0.jpeg"><br><br>  Wenn Sie einen mobilen Client haben, der sowohl √ºber WLAN als auch √ºber 3G verf√ºgt, k√∂nnen Sie beide Kan√§le verwenden.  Multipath TCP befindet sich derzeit in der Entwicklung und wird in K√ºrze im Linux-Kernel verf√ºgbar sein.  Offensichtlich wird es Kunden nicht bald erreichen, ich denke, es kann auf UDP viel schneller gemacht werden. <br><br><img src="https://habrastorage.org/webt/pb/7o/yt/pb7oytnkrhutg6qtqlwq0jf3p4o.jpeg"><br><br>  Da wir viele √úbersetzungen mit jeweils 3 TB durchf√ºhren, verwenden wir sehr h√§ufig Technologien wie CDN- und P2P-Distribution, wenn derselbe Inhalt vielen Benutzern auf der ganzen Welt bereitgestellt werden muss. <br><br>  In IPv6 gibt es Multicast mit UDP, mit dem Pakete an mehrere abonnierte Benutzer gleichzeitig gesendet werden k√∂nnen.  Daher denke ich, dass CDN- und P2P-Technologien in naher Zukunft nicht ben√∂tigt werden, wenn wir alle Inhalte mithilfe von Multicast an IPv6 liefern. <br><br><h2>  Schlussfolgerungen </h2><br>  Ich hoffe du verstehst: <br><br><ul><li>  Wie das Netzwerk wirklich funktioniert und dass TCP √ºber UDP wiederholt und besser gemacht werden kann. </li><li>  Das TCP ist nicht so schlecht, wenn Sie es richtig konfigurieren, aber es hat wirklich aufgegeben und entwickelt sich fast nicht mehr. </li><li>  Vertrauen Sie keinen UDP-Hassern, die sagen, dass sie nicht im Benutzerbereich arbeiten.  All diese Probleme k√∂nnen gel√∂st werden.  Probieren Sie es aus - dies ist die nahe Zukunft. </li><li>  Wenn Sie es nicht glauben, k√∂nnen und sollten Sie das Netzwerk mit Ihren H√§nden ber√ºhren.  Ich habe gezeigt, wie fast alles √ºberpr√ºft werden kann. </li></ul><br>  Sie haben alles gelesen und herausgefunden, was als n√§chstes kommt? <br><br><ul><li>  Konfigurieren Sie das Protokoll (TCP, UDP - es spielt keine Rolle) f√ºr die Situation (Netzwerkprofil + Lastprofil). </li><li>  Verwenden Sie die TCP-Rezepte, die ich Ihnen gesagt habe: TFO, Sende- / Empfangspuffer, TLS1.3, CC ... </li><li>  Erstellen Sie Ihre UDP-Protokolle, wenn Sie √ºber die Ressourcen verf√ºgen. </li><li>  Wenn Sie Ihr UDP durchgef√ºhrt haben, √ºberpr√ºfen Sie in der UDP-Checkliste, ob Sie alles getan haben, was Sie ben√∂tigen.  Unsinn wie das Tempo zu vergessen, wird nicht funktionieren. </li></ul><br>  Wenn Sie nicht √ºber die Ressourcen verf√ºgen, bereiten Sie Ihre Infrastruktur f√ºr QUIC vor.  Fr√ºher oder sp√§ter wird er zu dir kommen. <br><br><blockquote>  Wir bestimmen die Zukunft.  Wir entscheiden, welche Protokolle verwendet werden sollen.  Wenn Sie QUIC verwenden m√∂chten - verwenden Sie es, wenn Sie Ihr UDP m√∂chten oder auf TCP bleiben - entscheiden Sie selbst √ºber die Zukunft. </blockquote><br><h3>  N√ºtzliche Links </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Millionen Videoanrufe pro Tag oder "Call Mom!"</a>  . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir schreiben unser Protokoll √ºber UDP</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Podcast zur Netzwerkoptimierung</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erh√∂hen Sie die Daten√ºbertragungsgeschwindigkeit in fehlerhaften Netzwerken</a> . </li></ul><br><blockquote>  Bis zum 7. September k√∂nnen Sie weiterhin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Antrag</a> f√ºr Moscow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HighLoad ++ stellen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mitteilen,</a> wie Sie Ihre Dienste auf hohe Lasten vorbereiten.  Das Programm wird jedoch bereits nach und nach gef√ºllt. Aus Odnoklassniki-Berichten gingen Berichte √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Architektur des</a> Freundesdiagramms, √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimierung des Geschenkservices</a> f√ºr hohe Lasten und dar√ºber ein, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">was zu tun ist,</a> wenn Sie alles optimiert haben und die Daten den Benutzer nicht schnell genug erreichen. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461829/">https://habr.com/ru/post/de461829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461817/index.html">CMake und C ++ - Br√ºder f√ºr immer</a></li>
<li><a href="../de461819/index.html">Warum einfaches Website-Design wissenschaftlich besser ist</a></li>
<li><a href="../de461821/index.html">Neue Immuntherapie entfernte alle Tumoren bei einer Frau mit metastasiertem Brustkrebs</a></li>
<li><a href="../de461823/index.html">Erweiterte vier Regeln f√ºr das Software-Design</a></li>
<li><a href="../de461827/index.html">Entwicklung hybrider PHP / Go-Anwendungen mit RoadRunner</a></li>
<li><a href="../de461831/index.html">StealthWatch: Bereitstellung und Anpassung. Teil 2</a></li>
<li><a href="../de461833/index.html">Verlieren Sie sich nicht in drei Kiefern: einer egozentrischen Darstellung der Umwelt</a></li>
<li><a href="../de461835/index.html">Wie Gantt-Diagramme das Projektmanagement vereinfachen und st√§rken</a></li>
<li><a href="../de461841/index.html">PVS-Studio untersuchte die Bullet Engine der Red Dead Redemption</a></li>
<li><a href="../de461845/index.html">Investitionen an der B√∂rse als Mittel zur Erhaltung der Finanzen: 3 Arbeitsmethoden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>