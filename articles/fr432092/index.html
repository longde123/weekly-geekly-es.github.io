<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👦 🔧 🚔 Erreurs désagréables lors de l'écriture des tests unitaires 🎚️ 🐄 👟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'autre jour, je ferai un rapport interne dans lequel je parlerai à nos développeurs des erreurs désagréables qui peuvent survenir lors de l'écriture ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erreurs désagréables lors de l'écriture des tests unitaires</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432092/">  L'autre jour, je ferai un rapport interne dans lequel je parlerai à nos développeurs des erreurs désagréables qui peuvent survenir lors de l'écriture des tests unitaires.  Les erreurs les plus désagréables de mon point de vue sont lorsque les tests réussissent, mais en même temps, ils le font si mal qu'il vaut mieux ne pas réussir.  Et j'ai décidé de partager des exemples de telles erreurs avec tout le monde.  Sûrement autre chose à dire de cette région.  Des exemples sont écrits pour Node.JS et Mocha, mais en général, ces erreurs sont vraies pour tout autre écosystème. <br><br>  Pour le rendre plus intéressant, certains d'entre eux sont encadrés sous la forme d'un code de problème et d'un spoiler, ouvrant qui, vous verrez quel était le problème.  Je vous recommande donc de regarder d'abord le code, d'y trouver une erreur, puis d'ouvrir le spoiler.  Aucune solution aux problèmes ne sera indiquée - je propose d'y penser nous-mêmes.  Tout simplement parce que je suis paresseux.  L'ordre de la liste n'a pas de sens profond - c'est juste une séquence dans laquelle j'ai rappelé toutes sortes de problèmes réels qui nous ont fait pleurer.  Beaucoup de choses vous sembleront sûrement évidentes - mais même les développeurs expérimentés peuvent accidentellement écrire un tel code. <br><br><a name="habracut"></a><br>  Alors allons-y. <br><br><h3>  0. Manque de tests </h3><br>  Curieusement, beaucoup croient encore que l'écriture de tests ralentit la vitesse de développement.  Bien sûr, il est évident qu'il faut passer plus de temps à écrire des tests et à écrire du code qui peut être testé.  Mais après le débogage et la régression après cela, vous devez passer plusieurs fois plus de temps ... <br><br><h3>  1. L'absence de tests en cours </h3><br>  Si vous avez des tests que vous n'exécutez pas, ou exécutez de temps en temps, alors c'est comme l'absence de tests.  Et c'est encore pire - vous avez un code de test obsolète et un faux sentiment de sécurité.  Les tests doivent au moins s'exécuter dans les processus CI lors de la transmission de code à une branche.  Et mieux - localement avant la poussée.  Ensuite, le développeur n'aura pas à revenir à la build dans quelques jours, ce qui, en fait, ne s'est pas passé. <br><br><h3>  2. Absence de couverture </h3><br>  Si vous ne savez toujours pas quelle est la couverture des tests, il est temps d'aller lire dès maintenant.  Au moins <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipédia</a> .  Sinon, il y a de fortes chances que votre test vérifie 10% du code que vous pensez qu'il vérifie.  Tôt ou tard, vous marcherez certainement dessus.  Bien sûr, même une couverture à 100% du code ne garantit en aucune façon son exactitude complète - mais c'est bien mieux que le manque de couverture car cela vous montrera beaucoup plus d'erreurs potentielles.  Pas étonnant que les dernières versions de Node.JS aient même des outils intégrés pour le lire.  En général, le sujet de la couverture est profond et extrêmement holistique, mais je ne m'y attarderai pas trop - je veux en dire un peu plus sur beaucoup. <br><br><h3>  3. </h3><br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bluebird'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MightyLibrary</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> someLongFunction() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// just imagine a really complex and long function here } } async function doItQuickOrFail() { let res; try { res = await MightyLibrary.someLongFunction().timeout(1000); } catch (err) { if (err instanceof Promise.TimeoutError) { return false; } throw err; } return res; } describe('using Timeouts', ()=&gt;{ it('should return false if waited too much', async ()=&gt;{ // stub function to emulate looong work sinon.stub(MightyLibrary, 'someLongFunction').callsFake(()=&gt;Promise.delay(10000).then(()=&gt;true)); const res = await doItQuickOrFail(); assert.equal(res, false); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Délais d'attente dans les tests unitaires. <br><br>  Ici, ils voulaient vérifier que le réglage des délais d'attente pour une longue opération fonctionne vraiment.  En général, cela n'a aucun sens de toute façon - vous ne devriez pas vérifier les bibliothèques standard - mais ce code entraîne également un autre problème - pour augmenter le temps d'exécution des tests pendant une seconde.  Il semblerait que ce ne soit pas tellement ... Mais multipliez cette seconde par le nombre de tests similaires, par le nombre de développeurs, par le nombre de lancements par jour ... Et vous comprendrez qu'à cause de tels délais d'attente, vous pouvez perdre de nombreuses heures de travail par semaine, sinon quotidiennement. </blockquote><br></div></div><br><br><h3>  4. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'./testData.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); describe(<span class="hljs-string"><span class="hljs-string">'some block'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should do something'</span></span>, ()=&gt;{ someTest(testData); }) })</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Chargement des données de test en dehors des blocs de test. <br><br>  À première vue, il semble que peu importe où lire les données de test - dans la description, elles bloquent ou dans le module lui-même.  Le deuxième aussi.  Mais imaginez que vous ayez des centaines de tests, et que beaucoup d'entre eux utilisent des données lourdes.  Si vous les chargez en dehors du test, cela entraînera le fait que toutes les données de test resteront en mémoire jusqu'à la fin de l'exécution du test, et au fil du temps, le lancement consommera de plus en plus de RAM - jusqu'à ce qu'il s'avère que les tests ne s'exécutent plus du tout machines de travail standard. </blockquote><br></div></div><br><br><h3>  5. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// eslint-disable-next-line class-methods-use-this say() { return 'Wow'; } } describe('stubsEverywhere', ()=&gt;{ before(()=&gt;{ sinon.stub(Dog.prototype, 'say').callsFake(()=&gt;{ return 'meow'; }); }); it('should say meow', ()=&gt;{ const dog = new Dog(); assert.equal(dog.say(), 'meow', 'dog should say "meow!"'); }); });</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Le code est en fait remplacé par des talons. <br><br>  Vous avez sûrement immédiatement vu cette erreur ridicule.  Dans le vrai code, cela, bien sûr, n'est pas si évident - mais j'ai vu du code tellement accroché avec des talons que je n'ai rien testé du tout. </blockquote><br></div></div><br><br><h3>  6. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sinon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'sinon'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ fetch() {} loadData() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fetch(); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sinon.sandbox || !sinon.sandbox.stub) { sinon.sandbox = sinon.createSandbox(); } describe(<span class="hljs-string"><span class="hljs-string">'My widget'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'is awesome'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> widget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Widget(); widget.fetch = sinon.sandbox.stub().returns({ <span class="hljs-attr"><span class="hljs-attr">one</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">two</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); widget.loadData(); assert.isTrue(widget.fetch.called); }); });</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Dépendance entre les tests. <br><br>  À première vue, il est clair qu'ils ont oublié d'écrire ici <br><br><pre> <code class="javascript hljs"> afterEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { sinon.sandbox.restore(); });</code> </pre> <br><br>  Mais le problème n'est pas seulement ceci, mais le même bac à sable est utilisé pour tous les tests.  Et il est très facile de confondre l'environnement d'exécution des tests de telle manière qu'ils commencent à dépendre les uns des autres.  Après cela, les tests ne commenceront à être effectués que dans un certain ordre, et en général, il ne sera pas clair quoi tester. <br><br>  Heureusement, à un moment donné, sinon.sandbox a été déclaré obsolète et supprimé, de sorte que vous ne pouvez rencontrer un tel problème que sur un projet hérité - mais il existe tellement d'autres façons de confondre l'environnement d'exécution des tests de telle sorte qu'il sera douloureusement douloureux d'enquêter plus tard. quel code est coupable d'un comportement incorrect.  Soit dit en passant, il y a récemment eu un message sur un hub sur une sorte de modèle comme «Ice Factory» - ce n'est pas une panacée, mais parfois cela aide dans de tels cas. </blockquote><br><br></div></div><br><br><h3>  7. D'énormes données de test dans le fichier de test </h3><br><br>  Très souvent, j'ai vu comment les énormes fichiers JSON, et même XML, se trouvaient directement dans le test.  Je pense que c'est évident pourquoi cela ne vaut pas la peine d'être fait - cela devient pénible à regarder, à éditer, et aucun IDE ne vous en remerciera.  Si vous disposez de données de test volumineuses, supprimez-les du fichier de test. <br><br><h3>  8. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>); describe(<span class="hljs-string"><span class="hljs-string">'extraTests'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should generate unique bytes'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = crypto.randomBytes(<span class="hljs-number"><span class="hljs-number">256</span></span>); arr.push(value); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unique = arr.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, index</span></span></span><span class="hljs-function">)=&gt;</span></span>arr.indexOf(el) === index); assert.equal(arr.length, unique.length, <span class="hljs-string"><span class="hljs-string">'Data is not random enough!'</span></span>); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Tests supplémentaires. <br><br>  Dans ce cas, le développeur était très préoccupé par le fait que ses identifiants uniques seraient uniques, il a donc rédigé un chèque pour cela.  En général, un désir compréhensible - mais il est préférable de lire la documentation ou d'exécuter un tel test plusieurs fois sans l'ajouter au projet.  L'exécuter dans chaque build n'a aucun sens. <br><br>  Eh bien, le lien pour les valeurs aléatoires dans le test est en soi un excellent moyen de se tirer une balle dans le pied en faisant un test instable à partir de zéro. </blockquote><br></div></div><br><br><h3>  9. Manque de mok </h3><br>  Il est beaucoup plus facile d'exécuter des tests avec une base de données en direct et des services à 100%, et d'exécuter des tests sur eux. <br>  Mais tôt ou tard, cela reviendra à son terme - des tests de suppression de données seront exécutés sur la base de produits, commenceront à tomber en raison d'un service partenaire défectueux, ou votre CI n'aura tout simplement pas de base sur laquelle les exécuter.  En général, l'élément est assez holistique, mais en règle générale - si vous pouvez émuler des services externes, il est préférable de le faire. <br><br><h3>  11. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomError</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mytestFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomError(<span class="hljs-string"><span class="hljs-string">'important message'</span></span>); } describe(<span class="hljs-string"><span class="hljs-string">'badCompare'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should throw only my custom errors'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> errorHappened = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mytestFunction(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { errorHappened = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; assert.isTrue(err <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CustomError); } assert.isTrue(errorHappened); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Débogage d'erreur compliqué. <br><br>  Tout n'est pas mal, mais il y a un problème - si le test se bloque soudainement, vous verrez une erreur de forme <br><br> <code>1) badCompare <br> should throw only my custom errors: <br> <br> AssertionError: expected false to be true <br> + expected - actual <br> <br> -false <br> +true <br> <br> at Context.it (test/011_badCompare/test.js:23:14)</code> <br> <br>  De plus, pour comprendre quel type d'erreur s'est réellement produit - vous devez réécrire le test.  Donc, en cas d'erreur inattendue - essayez de faire en sorte que le test en parle, et pas seulement le fait que cela se soit produit. </blockquote><br></div></div><br><br><h3>  12. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someVeryBigFunc1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// imagine a tonn of code here } function someVeryBigFunc2() { return 2; // imagine a tonn of code here } describe('all Before Tests', ()=&gt;{ let res1; let res2; before(async ()=&gt;{ res1 = await someVeryBigFunc1(); res2 = await someVeryBigFunc2(); }); it('should return 1', ()=&gt;{ assert.equal(res1, 1); }); it('should return 2', ()=&gt;{ assert.equal(res2, 2); }); });</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Tout dans le bloc avant. <br><br>  Il semblerait qu'une approche intéressante consiste à effectuer toutes les opérations dans le bloc «avant», et donc à ne laisser que des vérifications à l'intérieur du «il». <br>  Pas vraiment. <br>  Parce que dans ce cas, il y a un gâchis dans lequel vous ne pouvez ni comprendre le moment de l'exécution réelle des tests, ni la raison de la chute, ni ce qui se rapporte à un test et quoi à un autre. <br>  Ainsi, tout le travail du test (à l'exception des initialisations standard) doit être effectué à l'intérieur du test lui-même. </blockquote><br></div></div><br><br><h3>  13. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> moment = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moment'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someDateBasedFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">date</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moment().isAfter(date)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } describe(<span class="hljs-string"><span class="hljs-string">'useFutureDate'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should return 0 for passed date'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pastDate = moment(<span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>); assert.equal(someDateBasedFunction(pastDate), <span class="hljs-number"><span class="hljs-number">0</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should return 1 for future date'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itWillAlwaysBeInFuture = moment(<span class="hljs-string"><span class="hljs-string">'2030-01-01'</span></span>); assert.equal(someDateBasedFunction(itWillAlwaysBeInFuture), <span class="hljs-number"><span class="hljs-number">1</span></span>); }); });</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Attachez sur les dates. <br><br>  Cela semblerait également être une erreur évidente - mais cela se produit également périodiquement chez les développeurs fatigués qui croient déjà que demain ne viendra jamais.  Et la construction qui allait bien hier tombe soudainement aujourd'hui. <br><br>  N'oubliez pas que n'importe quelle date viendra tôt ou tard - alors utilisez l'émulation de temps avec des choses comme `sinon.fakeTimers`, ou au moins définissez des dates à distance comme 2050 - laissez vos descendants blesser ... </blockquote><br></div></div><br><br><h3>  14. </h3><br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'dynamicRequires'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should return english locale'</span></span>, ()=&gt;{ <span class="hljs-comment"><span class="hljs-comment">// HACK : // Some people mutate locale in tests to chinese so I will require moment here // eslint-disable-next-line global-require const moment = require('moment'); const someDate = moment('2010-01-01').format('MMMM'); assert.equal(someDate, 'January'); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Chargement dynamique des modules. <br><br>  Si vous avez Eslint, vous avez probablement déjà interdit les dépendances dynamiques.  Ou pas. <br>  Souvent, je vois que les développeurs essaient de charger des bibliothèques ou divers modules directement à l'intérieur des tests.  Cependant, ils savent généralement comment «require» fonctionne - mais ils préfèrent l'illusion qu'ils sont censés recevoir un module propre que personne n'a confondu jusqu'à présent. <br>  Cette hypothèse est dangereuse dans la mesure où le chargement de modules supplémentaires pendant les tests est plus lent et conduit à nouveau à un comportement plus indéfini. </blockquote><br></div></div><br><br><h3>  15. </h3><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someComplexFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Imagine a piece of really strange code here return 1; } describe('cryptic', ()=&gt;{ it('success', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('should not fail', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('is right', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); it('makes no difference for solar system', ()=&gt;{ const result = someComplexFunc(); assert.equal(result, 1); }); });</span></span></code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Noms de test incompréhensibles. <br><br>  Vous devez être fatigué des choses évidentes, non?  Mais vous devez encore en parler parce que beaucoup ne prennent pas la peine d'écrire des noms compréhensibles pour les tests - et en conséquence, il est possible de comprendre ce qu'un test particulier fait seulement après de nombreuses recherches. </blockquote><br></div></div><br><br><h3>  16. </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {assert} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bluebird'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someTomeoutingFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.TimeoutError(); } describe(<span class="hljs-string"><span class="hljs-string">'no Error check'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should throw error'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timedOut = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> someTomeoutingFunction(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { timedOut = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } assert.equal(timedOut, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Manque de vérification de l'erreur levée. <br><br>  Souvent, vous devez vérifier que, dans certains cas, la fonction génère une erreur.  Mais vous devez toujours vérifier si ce sont les droïdes que nous recherchons - car il peut soudainement se produire qu'une autre erreur a été rejetée, dans un autre endroit et pour d'autres raisons ... </blockquote><br></div></div><br><br><h3>  17. </h3><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someBadFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'I am just wrong!'</span></span>); } describe.skip(<span class="hljs-string"><span class="hljs-string">'skipped test'</span></span>, ()=&gt;{ it(<span class="hljs-string"><span class="hljs-string">'should be fine'</span></span>, ()=&gt;{ someBadFunc(); }); });</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce qui ne va pas ici</b> <div class="spoiler_text"><blockquote>  Tests désactivés. <br><br>  Bien sûr, une situation peut toujours se produire lorsque le code a déjà été testé plusieurs fois avec vos mains, vous devez le lancer de toute urgence et, pour une raison quelconque, le test ne fonctionne pas.  Par exemple, en raison de la complication pas évidente d'un autre test, dont j'ai parlé plus tôt.  Et le test est désactivé.  Et c'est normal.  Pas normal - ne définissez pas immédiatement la tâche de réactiver le test.  Si cela n'est pas fait, le nombre de tests désactivés se multipliera et leur code deviendra constamment obsolète.  Jusqu'à ce que la seule option reste - faites preuve de pitié et lancez tous ces tests nafig, car il est plus rapide de les réécrire que de comprendre les erreurs. </blockquote><br></div></div><br><br>  Voici une telle sélection.  Tous ces tests réussissent bien, mais ils sont brisés par conception.  Ajoutez vos options dans les commentaires ou dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel que</a> j'ai fait pour collecter de telles erreurs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432092/">https://habr.com/ru/post/fr432092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432082/index.html">Microsoft AI Chatbot lance une collection de vêtements en Chine</a></li>
<li><a href="../fr432084/index.html">Comment nous avons organisé une compétition par équipes entre les travailleurs de la production (comme en URSS)</a></li>
<li><a href="../fr432086/index.html">Impression 3D à l'école internationale du nom de M.V. Lomonosov</a></li>
<li><a href="../fr432088/index.html">Haute disponibilité MySQL sur GitHub</a></li>
<li><a href="../fr432090/index.html">Magento Meetup Kharkiv No. 4 - rapports vidéo</a></li>
<li><a href="../fr432094/index.html">Hackathon en ligne conjoint d'OpenGift et de la plateforme Blockchain de crédits</a></li>
<li><a href="../fr432096/index.html">Guide CMake complet. Deuxième partie: Build System</a></li>
<li><a href="../fr432098/index.html">Pilotes automatiques dans le transport routier, comment interagir avec les spéciaux. en transport?</a></li>
<li><a href="../fr432100/index.html">Comment nous avons amélioré la conversion de facturation</a></li>
<li><a href="../fr432102/index.html">Fonctionnalités JavaScript explicites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>