<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍✈️ 👩🏻‍🚒 🍥 Qual a cor da sua função? 🧛 👩🏽‍⚖️ 👩🏽‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Não sei você, mas para mim não há melhor começo do dia do que me preocupar com programação. O sangue ferve ao ver uma crítica bem-sucedida de uma das ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qual a cor da sua função?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466337/"><p>  Não sei você, mas para mim não há melhor começo do dia do que me preocupar com programação.  O sangue ferve ao ver uma crítica bem-sucedida de uma das línguas "ousadas" usadas pelos plebeus, atormentada durante todo o dia de trabalho entre visitas tímidas ao StackOverflow. </p><br><p>  (Enquanto isso, você e eu usamos apenas a linguagem mais esclarecida e as ferramentas sofisticadas projetadas para as mãos hábeis de mestres como nós). </p><br><p>  Obviamente, como autor do sermão, corro riscos.  Você pode gostar do idioma que eu zoo!  Um panfleto imprudente poderia ter inadvertidamente levado ao meu blog uma multidão furiosa de celulares com forquilhas e tochas prontas. </p><br><p>  Para me proteger do fogo justo e não ofender seus sentimentos (provavelmente delicados), falarei sobre a linguagem ... </p><a name="habracut"></a><br><p>  ... quem acabou de aparecer.  Sobre uma efígie de palha, cujo único papel é queimar críticos em jogo. </p><br><p>  Sei que isso parece bobagem, mas acredite, no final, veremos cujo rosto (ou rostos) foi pintado em uma cabeça de palha. </p><br><h1 id="novyy-yazyk">  Novo idioma </h1><br><p> Será um exagero aprender um idioma completamente novo (e chato) apenas para um artigo de blog, então digamos que seja muito semelhante ao idioma que já conhecemos.  Por exemplo Javascript.  Chaves e ponto e vírgula.  <code>if</code> , <code>while</code> , etc.  - <em>Lingua franca da</em> nossa multidão. </p><br><p>  Eu escolhi JS não porque este artigo é sobre ele.  É apenas uma linguagem na qual o leitor comum provavelmente entrará.  Voila: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thisIsAFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span>; }</code> </pre> <br><p>  Como o bicho de pelúcia é uma linguagem <em>legal</em> (de leitura ruim), possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">funções de primeira classe</a> .  Então você pode escrever algo como isto: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,     , //    function filter(collection, predicate) { var result = []; for (var i = 0; i &lt; collection.length; i++) { if (predicate(collection[i])){ result.push(collection[i]); } } return result; }</span></span></code> </pre> <br><p>  Este é um dos recursos de <em>primeira classe</em> e, como o nome sugere, eles são legais e super úteis.  Você provavelmente está acostumado a transformar coleções de dados com a ajuda deles, mas assim que compreende o conceito, começa a usá-los em qualquer lugar, caramba. </p><br><p>  Talvez nos testes: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ it(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ expect(<span class="hljs-string"><span class="hljs-string">""</span></span>).not.toBe(<span class="hljs-string"><span class="hljs-string">""</span></span>); }); };</code> </pre> <br><p>  Ou quando você precisar analisar (analisar) os dados: </p><br><pre> <code class="javascript hljs">tokens.match(Token.LEFT_BRACKET, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">token</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Parse a list literal... tokens.consume(Token.RIGHT_BRACKET); });</span></span></code> </pre> <br><p>  Depois de acelerar, você escreve todos os tipos de bibliotecas e aplicativos reutilizáveis ​​que giram em torno de funções, chamadas de funções, retornos de funções - um estande funcional. </p><br><blockquote>  tradutor: no original "Functapalooza".  O prefixo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-a-palooza</a> é tão legal que você deseja compartilhá-lo com todos. </blockquote><br><h1 id="kakogo-cveta-vasha-funkciya">  Qual a cor da sua função? </h1><br><p>  E aqui começam as esquisitices.  Nossa linguagem tem uma característica peculiar: </p><br><h3 id="1-kazhdaya-funkciya-imeet-cvet">  1. Cada função tem uma cor. </h3><br><p>  Cada função - um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">retorno de chamada</a> anônimo ou uma função regular com um nome - é vermelha ou azul.  Como o destaque do código em nosso blog não destaca as diferentes cores das funções, vamos concordar que a sintaxe é: </p><br><pre> <code class="javascript hljs">blue*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAzure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ... } red*function doSomethingCarnelian(){ //    ... }</span></span></code> </pre> <br><p>  Nossa linguagem não possui funções incolores.  Deseja criar um recurso?  - deve escolher uma cor.  Estas são as regras.  E há mais algumas regras que você deve seguir: </p><br><h3 id="2-cvet-vliyaet-na-sposob-vyzova-funkcii">  2. A cor afeta a maneira como a função é chamada </h3><br><p>  Imagine que existem duas sintaxes para chamar funções - "azul" e "vermelho".  Algo como: </p><br><pre> <code class="javascript hljs">doSomethingAzure(...)*blue; doSomethingCarnelian()*red;</code> </pre> <br><p>  Ao chamar uma função, você deve usar uma chamada que corresponda à sua cor.  Se você não adivinhou - eles chamaram a função vermelha com <code>*blue</code> após os colchetes (ou vice-versa) - algo muito ruim acontecerá.  Um pesadelo esquecido na infância, como um palhaço com cobras em vez de mãos que se escondia embaixo da sua cama.  Ele pulará do monitor e chupará seus olhos. </p><br><p>  Regra estúpida, certo?  Ah, mas mais uma coisa: </p><br><h3 id="3-tolko-krasnaya-funkciya-mozhet-vyzvat-krasnuyu-funkciyu">  3. Somente a função vermelha pode causar a função vermelha. </h3><br><p>  Você <em>pode</em> chamar a função azul do vermelho.  Isto é kosher: </p><br><pre> <code class="javascript hljs">red*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingCarnelian</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ doSomethingAzure()*blue; }</code> </pre> <br><p>  Mas não o contrário.  Se você tentar: </p><br><pre> <code class="javascript hljs">blue*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAzure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ doSomethingCarnelian()*red; }</code> </pre> <br><p>  - você será visitado pelo velho Clown Spider Maw. </p><br><p>  Isso torna mais difícil escrever funções mais altas, como <code>filter()</code> do exemplo.  Devemos escolher uma cor para cada nova função e isso afeta a cor das funções que podemos passar para ela.  A solução óbvia é tornar o <code>filter()</code> vermelho.  Então podemos chamar pelo menos funções vermelhas, pelo menos azuis.  Mas então nos machucamos com o próximo espinho na coroa de espinhos, que é o idioma indicado: </p><br><h3 id="4-krasnye-funkcii-bolnee-vyzyvat">  4. Funções vermelhas causam dor </h3><br><p>  Não identificaremos essa "dor", apenas imagine que o programador deve pular o arco toda vez que ele chamar a função vermelha.  A chamada pode ser muito polissilábica ou você não pode executar a função em algumas expressões.  Ou você só pode acessar a função vermelha a partir de linhas ímpares. </p><br><p>  Não importa o que seja, mas se você decidir tornar a função vermelha, todos que usarem sua API quererão cuspir no café ou fazer algo pior. </p><br><p>  A solução óbvia nesse caso é nunca usar funções vermelhas.  Apenas deixe tudo azul e você estará de volta ao mundo normal, onde todas as funções são da mesma cor, o que é igual ao fato de que elas não têm cor e que nossa linguagem não é completamente idiota. </p><br><p>  Infelizmente, os sádicos que desenvolveram essa linguagem (todos sabem que os autores de linguagens de programação são sádicos, certo?) Prendem o último espinho em nós: </p><br><h3 id="5-nekotorye-funkcii-yadra-yazyka----krasnye">  5. Algumas das principais funções do idioma são vermelhas. </h3><br><p>  Algumas funções integradas à plataforma, funções que <em>precisamos</em> usar e que não podem ser escritas por nós mesmos, estão disponíveis apenas em vermelho.  Nesse ponto, uma pessoa inteligente pode começar a suspeitar que esse idioma nos odeia. </p><br><h1 id="eto-vse-vina-funkcionalnyh-yazykov">  Isso é tudo culpa das linguagens funcionais! </h1><br><p>  Você pode pensar que o problema é que estamos tentando usar funções de ordem superior.  Se pararmos de brincar com toda essa bobagem funcional e começarmos a escrever funções azuis de <em>primeira ordem</em> normais (funções que não operam com outras funções - aprox. Translator), conforme planejado por Deus -, nos livraremos de toda essa dor. </p><br><p>  Se chamarmos apenas funções azuis, tornaremos todas as nossas funções azuis.  Caso contrário, tornamos vermelho.  Até criarmos funções que aceitem funções, não precisamos nos preocupar com "polimorfismo com a cor da função" (policromático?) Ou com outras bobagens. </p><br><p>  Mas, infelizmente, funções de ordem superior são apenas um exemplo.  O problema surge toda vez que queremos dividir nosso programa em funções para reutilização. </p><br><p>  Por exemplo, temos um pequeno pedaço de código que, bem, não sei, implementa o algoritmo de Dijkstra sobre um gráfico que representa o quanto suas conexões sociais pressionam umas às outras.  (Passei muito tempo tentando decidir o que o resultado significaria. Indesejabilidade transitiva?) </p><br><p>  Mais tarde, você precisou usar esse algoritmo em outro lugar.  Naturalmente, você quebra o código em uma função separada.  Ligue para ela do lugar antigo e do novo.  Mas que cor deve ser a função?  Você provavelmente tentará torná-lo azul, mas e se ele usar uma dessas funções "apenas vermelhas" desagradáveis ​​da biblioteca do kernel? </p><br><p>  Digamos que o novo local do qual você deseja chamar a função seja azul?  Mas agora você precisa reescrever o código de chamada em vermelho.  E, em seguida, refaça a função que chama esse código.  Ufa  Você terá que se lembrar constantemente da cor de qualquer maneira.  Esta será a areia do seu calção de banho em uma programação de férias na praia. </p><br><h1 id="cvetnaya-allegoriya">  Alegoria da cor </h1><br><p>  Na verdade, não estou falando de cores.  Isso é uma alegoria, um artifício literário.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Foda-se</a> - isso não é sobre as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrelas nas barrigas</a> , é sobre a corrida.  Você provavelmente já suspeita ... </p><br><h3 id="krasnye-funkcii---asinhronnye">  Funções vermelhas - assíncronas </h3><br><p>  Se você programar em JavaScript ou Node.js, sempre que definir uma função que chama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma função de</a> retorno de chamada (retorno de chamada) para "retornar" o resultado, você escreverá uma função vermelha.  Veja esta lista de regras e observe como elas se encaixam na minha metáfora: </p><br><ol><li>  Funções síncronas retornam um resultado, funções assíncronas não; em troca, chamam um retorno de chamada. </li><li>  As funções síncronas retornam o resultado como um valor de retorno, as funções assíncronas o retornam, causando o retorno de chamada que você passou para eles. </li><li>  Você não pode chamar uma função assíncrona de uma síncrona, porque não pode saber o resultado até que a função assíncrona seja executada posteriormente. </li><li>  Funções assíncronas não são compiladas em expressões devido a retornos de chamada, exigem que seus erros sejam tratados de maneira diferente e não podem ser usados ​​em um bloco de <code>try/catch</code> ou em várias outras expressões que controlam o programa. </li><li>  A coisa toda sobre o Node.js é que a biblioteca do kernel é toda assíncrona.  (Embora eles doem de volta e começaram a adicionar versões <code>_Sync()</code> a várias coisas). </li></ol><br><p>  Quando as pessoas falam sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"inferno de retorno de chamada"</a> , falam sobre como é irritante ter funções "vermelhas" em seu idioma.  Quando eles criam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4089 bibliotecas para programação assíncrona</a> (em 2019, já em 11217 - aprox. Tradutor), eles tentam lidar com o problema no nível da biblioteca de que estavam presos à linguagem. </p><br><h1 id="i-promise-the-future-is-better">  Eu prometo que o futuro é melhor </h1><br><blockquote>  na tradução: "Eu prometo que o futuro é melhor" o jogo de palavras do título e do conteúdo da seção está perdido </blockquote><p>  As pessoas no Node.js há muito tempo percebem que os retornos de chamada são prejudiciais e estavam procurando soluções.  Uma das técnicas que inspirou muitas pessoas são as <code>promises</code> , que você também pode conhecer pelo apelido de <code>futures</code> . </p><br><blockquote>  na TI russa, em vez de traduzir "promessas" como "promessas", foi estabelecido um papel vegetal do inglês - "promessas".  A palavra "Futuros" é usada como é, provavelmente porque os "futuros" já estão ocupados por gírias financeiras. </blockquote><p>  Promis é um wrapper para retorno de chamada e manipulador de erros.  Se você está pensando em passar um retorno de chamada para o resultado e outro retorno de chamada para o erro, o <code>future</code> é a personificação dessa ideia.  Este é um objeto básico que é uma operação assíncrona. </p><br><p>  Acabei de receber um monte de palavras sofisticadas e pode parecer uma ótima solução, mas principalmente é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">óleo de cobra</a> .  As promessas realmente facilitam a escrita de código assíncrono.  Como são mais fáceis de compor em expressões, a regra 4 é um pouco menos rigorosa. </p><br><p>  Mas, para ser sincero, é como a diferença entre um golpe no estômago ou na virilha.  Sim, não dói tanto, mas ninguém ficará encantado com essa escolha. </p><br><p>  Você ainda não pode usar promessas com tratamento de exceção ou outros <br>  operadores de gerenciamento.  Você não pode chamar uma função que retorne <code>future</code> do código síncrono.  (você <em>pode</em> , mas o próximo mantenedor do seu código inventará uma máquina do tempo, retornará no momento em que você o fez e enfiará um lápis na sua cara pelo motivo 2). </p><br><p>  As promessas ainda dividem seu mundo em metades assíncronas e síncronas com todo o sofrimento que se segue.  Portanto, mesmo que seu idioma suporte <code>promises</code> ou <code>futures</code> , ele ainda se parece muito com o meu idioma de pelúcia. </p><br><p>  (Sim, isso inclui até o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dart</a> que eu uso. Portanto, estou tão feliz que parte da equipe esteja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tentando outras abordagens do paralelismo</a> ) </p><br><blockquote>  link do projeto abandonado oficialmente </blockquote><br><h1 id="im-awaiting-a-solution">  Estou aguardando uma solução </h1><br><p>  Os programadores de C # provavelmente se sentem complacentes (a razão pela qual estão se tornando cada vez mais vítimas é que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Halesberg</a> e a empresa polvilham tudo e polvilham a linguagem com açúcar sintático).  Em C #, você pode usar a palavra-chave <code>await</code> para chamar uma função assíncrona. </p><br><p>  Isso torna a realização de chamadas assíncronas tão fácil quanto síncrona, com a adição de uma pequena palavra-chave atraente.  Você pode inserir uma chamada em <code>await</code> nas expressões, usá-las no tratamento de exceções, no fluxo de instruções.  Você pode enlouquecer.  Vamos esperar a chuva como dinheiro para o seu novo álbum de rapper. </p><br><p>  O Async-Waitit é bom, então o adicionamos ao Dart.  É muito mais fácil <em>escrever</em> código assíncrono com ele.  Mas, como sempre, há um "Mas".  Aqui está.  <em>Mas ...</em> você ainda divide o mundo ao meio.  As funções assíncronas agora são mais fáceis de escrever, mas <em>ainda são funções assíncronas.</em> </p><br><p>  Você ainda tem duas cores.  A espera assíncrona resolve o problema irritante nº 4 - eles tornam as funções de chamada em vermelho não mais difíceis do que as chamadas em azul.  Mas o restante das regras ainda está aqui: </p><br><ol><li>  Funções síncronas retornam valores, funções assíncronas retornam um wrapper ( <code>Task&lt;T&gt;</code> em C # ou <code>Future&lt;T&gt;</code> em Dart) ao redor do valor. </li><li>  Síncrono apenas chamado, necessidade assíncrona de <code>await</code> . </li><li>  Ao chamar uma função assíncrona, você obtém um objeto wrapper quando realmente deseja um valor.  Você não pode expandir o valor até tornar <em>sua</em> função assíncrona e chamá-la com <code>await</code> (mas consulte o próximo parágrafo). </li><li>  Além de aguardar um pouco de decoração, pelo menos resolvemos esse problema. </li><li>  A biblioteca principal do C # é mais antiga que a assincronia, então eu acho que eles nunca tiveram esse problema. </li></ol><br><p>  <code>Async</code> <em>realmente</em> melhor.  Eu preferiria espera assíncrona a retornos nus em qualquer dia da semana.  Mas mentimos para nós mesmos se pensarmos que todos os problemas estão resolvidos.  Assim que você começa a escrever funções de ordem superior ou a reutilizar o código, percebe novamente que a cor ainda está lá, sangrando por todo o seu código-fonte. </p><br><h1 id="kakoy-yazyk-_ne_-cvetnoy">  Qual idioma <em>não</em> é cor? </h1><br><p>  Então, JS, Dart, C # e Python têm esse problema.  CoffeeScript e a maioria das outras linguagens compilando também em JS (e Dart herdado).  Acho que mesmo o ClojureScript tem essa pegada, apesar de seus esforços ativos com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">core.async</a> </p><br><p>  Quer saber qual deles não?  <em>Java</em>  Estou certo  Com que frequência você diz: "Sim, apenas Java está fazendo certo"?  E assim aconteceu.  Em sua defesa, eles estão tentando ativamente corrigir sua supervisão promovendo <code>futures</code> e E / S assíncronas.  É como uma corrida pior que pior. </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tudo</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">já</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">está</a> em Java </blockquote><p>  C #, de fato, também <em>pode</em> contornar esse problema.  Eles <em>escolheram</em> ter cor.  Antes de adicionarem async-waitit e todo esse lixo eletrônico <code>Task&lt;T&gt;</code> , era possível usar chamadas de API síncronas regulares.  Três outros idiomas que não têm um problema de "cor": Go, Lua e Ruby. </p><br><p>  Adivinha o que eles têm em comum? </p><br><p>  <em>Streams.</em>  Ou, mais precisamente: muitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pilhas de chamadas</a> independentes que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">podem ser trocadas</a> .  Esses não são necessariamente threads do sistema operacional.  Corotinas em Go, corotinas em Lua e threads em Ruby são adequadas. </p><br><p>  (É por isso que existe essa pequena advertência para C # - você pode evitar a dor assíncrona em C # usando threads.) </p><br><h1 id="pamyat-o-proshlyh-operaciyah">  Memória de operações passadas </h1><br><p>  O problema fundamental é "como continuar do mesmo local quando a operação (assíncrona) é concluída"?  Você mergulhou no abismo da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pilha de chamadas</a> e depois chamou algum tipo de operação de E / S.  Por uma questão de aceleração, esta operação usa a API assíncrona subjacente do seu sistema operacional.  Você <em>não pode</em> esperar para concluir.  Você deve retornar ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">loop de eventos do</a> seu idioma e dar tempo ao SO para concluir a operação. </p><br><p>  Quando isso acontece, você precisa retomar o que estava fazendo.  Geralmente, o idioma "lembra onde estava" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na pilha de chamadas</a> .  Ele segue todas as funções que foram chamadas no momento e olha para onde o contador de comandos em cada uma delas aparece. </p><br><p>  Mas, para executar E / S assíncrona, você deve relaxar, descartar toda a pilha de chamadas em C. Digite Trick-22.  Você possui E / S super rápidas, mas não pode usar o resultado!  Todos os idiomas com E / S assíncrona sob o capô - ou, no caso de JS, o loop de eventos do navegador - são forçados a lidar com isso de alguma forma. </p><br><p>  Node, com seus retornos de chamada marcantes para sempre, enfia todas essas chamadas em fechamento.  Quando você escreve: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSundae</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ scoopIceCream(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">iceCream</span></span></span><span class="hljs-function">) </span></span>{ warmUpCaramel(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">caramel</span></span></span><span class="hljs-function">) </span></span>{ callback(pourOnIceCream(iceCream, caramel)); }); }); }</code> </pre> <br><p>  Cada uma dessas expressões funcionais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>fecha</em></a> todo o contexto circundante.  Isso transfere parâmetros, como <code>iceCream</code> e <code>caramel</code> , da pilha de chamadas para a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pilha</a> .  Quando uma função externa retorna um resultado e a pilha de chamadas é destruída, isso é legal.  Os dados ainda estão em algum lugar na pilha. </p><br><p>  O problema é que você precisa ressuscitar cada uma dessas chamadas malditas novamente.  Existe até um nome especial para esta conversão: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estilo de passagem de continuação</a> </p><br><blockquote>  vincular funcionalidade feroz </blockquote><p>  Isso foi inventado por hackers de linguagem nos anos 70, como uma representação intermediária para uso sob o capô de compiladores.  Essa é uma maneira muito bizarra de introduzir código que facilita a execução de algumas otimizações do compilador. </p><br><p>  Ninguém nunca pensou que um programador pudesse <em>escrever esse código</em> .  E então Node apareceu e, de repente, todos fingimos escrever um back-end do compilador.  Onde nós viramos o caminho errado? </p><br><p>  Observe que promessas e <code>futures</code> realmente não ajudam muito.  Se você usá-los, sabe que ainda está acumulando camadas gigantes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">expressões funcionais</a> .  Você apenas os passa para <code>.then()</code> vez da própria função assíncrona. </p><br><h1 id="awaiting-a-generated-solution">  Aguardando uma solução gerada </h1><br><p>  Async-waitit <em>realmente</em> ajuda.  Se você olhar embaixo do capô para o compilador quando ele encontrar, você verá que ele realmente realiza a conversão do CPS.  É <em>por isso que</em> você precisa usar <code>await</code> em C # - esta é uma dica para o compilador - "interrompa a função aqui no meio".  Tudo o que <code>await</code> depois se torna uma nova função que o compilador sintetiza em seu nome. </p><br><p>  É por isso que o async-waitit não precisa de suporte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempo de execução</a> dentro da estrutura .NET.  O compilador compila isso em uma cadeia de fechamentos relacionados, com os quais ele já sabe como lidar.  (Curiosamente, os fechamentos também não precisam de suporte de tempo de execução. Eles são compilados em classes anônimas. Em C #, os fechamentos são apenas objetos.) </p><br><p>  Você provavelmente está se perguntando quando menciono os geradores.  Existe <code>yield</code> no seu idioma?  Então ele pode fazer algo muito semelhante. </p><br><p>  (Acredito que os geradores e o async-waitit são realmente isomórficos. Em algum lugar nos cantos e recantos empoeirados do meu disco rígido existe um pedaço de código que implementa um ciclo de jogo nos geradores usando apenas o async-wait). </p><br><p>  Então, onde eu estou?  Ah sim.  Assim, com retornos de chamada, promessas, espera assíncrona e geradores, você acaba pegando sua função assíncrona e dividindo-a em vários fechamentos que ficam na pilha. </p><br><p>  Sua função chama externa em tempo de execução.  Quando o loop de eventos ou a operação de E / S é concluída, sua função é chamada e continua de onde estava.  Mas isso significa que tudo no topo da sua função <em>também</em> deve retornar.  Você ainda precisa restaurar a pilha inteira. </p><br><p>  É daí que vem a regra: "Você só pode chamar a função vermelha a partir da função vermelha"  Você deve salvar toda a pilha de chamadas nos fechamentos para <code>main()</code> ou para o manipulador de eventos. </p><br><h1 id="realizaciya-steka-vyzovov">  Implementação da pilha de chamadas </h1><br><p>  Mas, usando threads ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verde</a> ou nível do SO), você não precisa fazer isso.  Você pode simplesmente pausar o segmento inteiro e pular para o SO ou o loop de eventos <em>sem precisar retornar de todas essas funções</em> . </p><br><p>  A linguagem Go, no meu entender, faz isso da maneira mais perfeita.  Assim que você fizer qualquer operação de E / S, o Go estacionará essa corotina e continuará qualquer outra que não seja bloqueada pela E / S. </p><br><p>  Se você observar as operações de E / S na biblioteca padrão Golang, elas parecem síncronas.  Em outras palavras, eles simplesmente funcionam e retornam o resultado quando estiverem prontos.  Mas essa sincronização não significa o mesmo que no Javascript.  Go-  ,    IO .  Go       . </p><br><p>   Go —   <em></em>    ,        .       ,   ,    . </p><br><p>     ,               API,   ,     .           . </p><br><hr><br><h1 id="ot-perevodchika">   </h1><br><p>  ,           ,          .       ,        . ,      50%          . </p><br><p> ,      ,      ,                 . </p><br><p>  Javascript   -,   , ,   JS   ,    JS   ,          .   ,    JS   . </p><br><p>      ,      (     )   —  ,     ,   ,        <code>async</code>         .     <code>import threading</code>      (  ,          AsyncIO, Twisted  Tornado,    ). </p><br><p>     ,             ,     ,     ,        ,                  ,      . </p><br><p>       ,     Go,     Go . </p><br><p>  ,        ,  ,  ( -    )          ,          "async-await  ".      . </p><br><p>    ,       . </p><br><p> ,       ,     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466337/">https://habr.com/ru/post/pt466337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466319/index.html">Acordo: VMware compra startup baseada na nuvem</a></li>
<li><a href="../pt466323/index.html">Criamos um jogo de plataforma portátil no microcontrolador Cortex M0 +</a></li>
<li><a href="../pt466329/index.html">Mapa eletrônico de vinificação na Rússia. Design e conteúdo</a></li>
<li><a href="../pt466333/index.html">Como organizar um local de trabalho para si mesmo</a></li>
<li><a href="../pt466335/index.html">Criando um aplicativo Slack usando os recursos do 8base</a></li>
<li><a href="../pt466339/index.html">Como no Microsoft SQL Server para obter dados do Google Analytics usando R</a></li>
<li><a href="../pt466341/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 33. Preparação para o exame ICND1</a></li>
<li><a href="../pt466349/index.html">Como realizar testes A / B em 15.000 lojas offline</a></li>
<li><a href="../pt466355/index.html">Os crocodilos voam, mas baixo-baixo (sobre ekranoplanes sem emoções, mas com digressões)</a></li>
<li><a href="../pt466359/index.html">Por que o Dia Mundial da Dívida Ecológica e a pegada ambiental são um absurdo pseudocientífico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>