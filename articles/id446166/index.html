<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏿 👩🏿‍🚀 ✌🏿 Codec ASN1 sprintf sederhana 👨🏿‍💻 🕌 🤛🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sintaks transport ASN.1 mendefinisikan cara unik untuk mengonversi nilai variabel tipe yang valid ke dalam urutan byte untuk transmisi melalui jaringa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Codec ASN1 sprintf sederhana</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446166/"><img src="https://habrastorage.org/webt/hp/r5/am/hpr5amyaiz885olowpmujn0aad8.png" alt="gambar" align="left">  Sintaks transport ASN.1 mendefinisikan cara unik untuk mengonversi nilai variabel tipe yang valid ke dalam urutan byte untuk transmisi melalui jaringan.  Dalam ASN.1, itu disebut Aturan Pengkodean Dasar (BER).  Aturan bersifat rekursif, jadi pengodean objek komposit adalah rantai urutan komponen objek yang dikodekan.  Protokol ASN.1 menggambarkan struktur data dalam bahasa yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sederhana dan mudah dimengerti</a> . <br><a name="habracut"></a><br>  Setiap nilai yang ditransmisikan - baik tipe dasar maupun turunan - terdiri dari tiga bidang: <br><br><ul><li>  pengidentifikasi; </li><li>  panjang bidang data (dalam byte); </li><li>  bidang data. </li></ul><br>  Jika Anda selalu menentukan panjang bidang data (saya anggap ini praktik yang baik), maka bendera akhir bidang data tidak digunakan. <br><br>  Ada banyak kompiler berbeda untuk ASN.1, baik yang berbayar maupun gratis, untuk bahasa pemrograman yang berbeda, tetapi kami ingin memiliki sesuatu yang sangat sederhana. <br><br>  Sebagian besar pengembang perangkat lunak menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompleks</a> standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASN.1</a> .  Saya juga berpikir begitu sampai saat ini.  Bekerja di bidang PKI / PKI / kriptografi hampir setiap hari Anda berurusan dengan struktur ASN1 dalam bentuk sertifikat X509, permintaan sertifikat, daftar sertifikat yang dicabut.  Dan daftarnya berlanjut.  Jadi, ketika mengerjakan utilitas untuk membuat permintaan sertifikat dalam format PKCS # 10 dengan menghasilkan pasangan kunci pada token / kartu pintar PKCS, saya secara alami harus membentuk, khususnya, struktur asn1 kunci publik untuk menulisnya ke permintaan sertifikat : <br><br><pre><code class="erlang hljs">C-Sequence C-Sequence (&lt;&gt;) Object Identifier (&lt;&gt;) &lt;oid public key&gt; C-Sequence (&lt;&gt;) Object Identifier (&lt;&gt;) &lt;oid  &gt; Object Identifier (&lt;&gt;) &lt;oid &gt; Bit String (&lt;&gt;) &lt;  &gt;</code> </pre> <br>  Karena kami menggunakan token PKCS # 11 dengan dukungan untuk kriptografi Rusia sebagai alat perlindungan informasi kriptografi, bahan sumber untuk struktur ini diperoleh dari token sesuai dengan templat berikut: <br><br><pre> <code class="cpp hljs"> CK_BYTE gostr3410par[<span class="hljs-number"><span class="hljs-number">12</span></span>]; CK_BYTE gostr3411par[<span class="hljs-number"><span class="hljs-number">12</span></span>]; CK_ULONG gostr3410par_len; CK_ULONG gostr3411par_len; CK_BYTE pubkey[<span class="hljs-number"><span class="hljs-number">128</span></span>]; CK_ULONG pubkeu_len; CK_KEY_TYPE key_type; CK_ATTRIBUTE templ_pk[] = { . . . {CKA_GOSTR3410PARAMS, gostr3410par, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gostr3410par)}, {CKA_GOSTR3411PARAMS, gostr3411par, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gostr3410par)}, {CKA_VALUE, pubkey, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pubkey)}, {CKA_KEY_TYPE, &amp;key_type, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(key_type)} }</code> </pre> <br>  Langsung dari struktur ini, nilai atribut CKA_VALUE yang berisi nilai kunci publik dan nilai atribut CKA_GOSTR3410PARAMS dan CKA_GOSTR3411PARAMS yang berisi oid dari parameter tanda tangan dan parameter hash akan digunakan untuk mengisi asn1-publickeyinfo. <br><br>  Atribut CKA_KEY_TYPE, yang dapat mengambil nilai CKK_GOSTR3410 dan CKK_GOSTR3410_512 (dalam kondisi ketika algoritma tanda tangan GOST R 34.10-2001 terus beroperasi) secara ambigu mendefinisikan algoritma pasangan kunci.  Jika nilai atribut CKA_KEY_TYPE sama dengan CKK_GOSTR3410_512, maka, tentu saja, itu menunjuk secara unik ke algoritma GOST R 34.10-2012 dengan panjang kunci 512 bit (oid = 1.2.643.7.1.1.1.1.2).  Tetapi jika itu sama dengan CKK_GOSTR3410, maka ada ambiguitas tentang jenis kunci yang dimiliki oleh kunci ini: GOST R 34.10-2001 atau masih GOST R 34.10-2012 dengan panjang kunci 256 bit.  Atribut CKA_GOSTR3411PARAMS membantu menyelesaikan ambiguitas ini. <br><br>  Segera, kami mencatat bahwa parameter CKA_GOSTR3410PARAMS dan CKA_GOSTR3411PARAMS pada token sesuai dengan rekomendasi TK-26 disimpan dalam bentuk pengenal objek yang dikodekan oleh oid, misalnya: <br><br>  \ x06 \ x06 \ x2a \ x85 \ x03 \ x02 \ x02 \ x13, di mana byte nol menentukan jenis urutan (0x06 adalah pengidentifikasi objek, lihat tabel di bawah), byte kedua menunjukkan panjang (dalam kasus umum, panjangnya mungkin memerlukan beberapa byte, tetapi lebih lanjut tentang itu di bawah ini) bidang data tempat oid disimpan dalam bentuk biner. <br><br>  Jika parameter ini berisi oid dari algoritma hash GOST R 34.10-2012 dengan panjang 256 bit (oid = 1.2.643.7.1.1.2.2, dalam bentuk biner "\ x2a \ x 85 \ x 85 \ x 03 \ x 07 \ x 07 \ x 01 \ x 01 \ x 02 \ x02 "), maka jenis kunci harus ditetapkan sebagai GOST R 34.10-2012 dengan panjang kunci 256 bit.  Kalau tidak, itu adalah kunci dari GOST R 34.10-2001.  Algoritma untuk menentukan jenis kunci mungkin terlihat seperti ini: <br><br><pre> <code class="cpp hljs">. . . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (curr_attr_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; curr_attr_idx &lt; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(templ_pk)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(templ_pk[<span class="hljs-number"><span class="hljs-number">0</span></span>])); curr_attr_idx++){ curr_attr = &amp;templ_pk[curr_attr_idx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!curr_attr-&gt;pValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } swith (curr_attr-&gt;type) { . . . <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_VALUE: <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> pubkey_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_GOSTR3410PARAMS: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> gostr3410par_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_GOSTR3410PARAMS: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> gostr3411par_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_KEY_TYPE: ulattr = curr_attr-&gt;pValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*ulattr == CKK_GOSTR3410) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!memmem(gostr3411par), gostr3411par_len,<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2001*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, <span class="hljs-string"><span class="hljs-string">"1.2.643.2.2.19"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1(<span class="hljs-string"><span class="hljs-string">"\x06\x06\x2a\x85\x03\x02\x02\x13"</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2012-256*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, (<span class="hljs-string"><span class="hljs-string">"1 2 643 7 1 1 1 1"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1 (<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07\x01\x01\x01\x01"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*ulattr == CKK_GOSTR3410_512) { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2012-512*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, (<span class="hljs-string"><span class="hljs-string">"1 2 643 7 1 1 1 2"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1 (<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07\x01\x01\x01\x02"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"tclpkcs11_perform_pki_keypair CKK_GOSTR ERROR\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; . . . } } . . .</code> </pre> <br>  Sekarang kita memiliki semua sumber data untuk membuat struktur kunci publik asn1. <br><br>  Ingat bahwa setiap elemen struktur asn1 terdiri dari tiga bidang: <br><br><ul><li>  pengidentifikasi; </li><li>  panjang bidang data (dalam byte); </li><li>  bidang data. </li></ul><br>  Berikut ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah tabel</a> pengkodean untuk beberapa jenis pengidentifikasi yang digunakan dalam PKI / PKI: <br><br><table width="200"><tbody><tr><th>  <b>Ketik Nama</b> </th><th>  <b>Deskripsi singkat</b> </th><th>  <b>Ketik representasi dalam pengkodean DER</b> </th></tr><tr><td>  URUTAN </td><td>  Digunakan untuk menggambarkan struktur data yang terdiri dari berbagai jenis. </td><td>  30 </td></tr><tr><td>  INTEGER </td><td>  Integer </td><td>  02 </td></tr><tr><td>  IDENTIFIER OBYEK </td><td>  Urutan bilangan bulat. </td><td>  06 </td></tr><tr><td>  UTCTime </td><td>  Jenis sementara, berisi 2 digit untuk menentukan tahun </td><td>  17 </td></tr><tr><td>  Waktu umum </td><td>  Jenis waktu yang diperpanjang, berisi 4 digit untuk menunjukkan tahun. </td><td>  18 </td></tr><tr><td>  SET </td><td>  Menjelaskan struktur data dari berbagai jenis. </td><td>  31 </td></tr><tr><td>  UTF8String </td><td>  Menjelaskan data string. </td><td>  0C </td></tr><tr><td>  Tidak </td><td>  Sebenarnya NULL </td><td>  05 </td></tr><tr><td>  BIT STRING </td><td>  Ketik untuk menyimpan urutan bit. </td><td>  03 </td></tr><tr><td>  STRING OCTET </td><td>  Ketik untuk menyimpan urutan byte </td><td>  04 </td></tr></tbody></table><br>  Ketika bekerja dengan struktur ASN1, kejutan terbesar untuk yang belum tahu disebabkan oleh metode pengkodean panjang bidang data, terutama ketika itu terbentuk, dan jika kita memperhitungkan arsitektur komputer (littleendien, bigendien).  Ini adalah keseluruhan <a href="">ilmu</a> .  Jadi, dalam proses membahas algoritma untuk membentuk bidang ini, muncul ide untuk menggunakan fungsi sprintf, yang dengan sendirinya akan mempertimbangkan arsitektur, dan bagaimana jumlah byte untuk menyimpan panjang ditentukan dapat dilihat oleh kode fungsi, yang menyiapkan buffer dengan pengidentifikasi tipe data dan panjang data: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrap_id_with_length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//  unsigned long length, //  unsigned long *lenasn) //  asn1- { // unsigned long length; int buflen = 0; unsigned char *buf; char *format; char *buf_for_len[100]; const char *s; /*       */ char f0[] = "%02x%02x"; char f1[] = "%02x81%02x"; char f2[] = "%02x82%04x"; char f3[] = "%02x83%06x"; char f4[] = "%02x84%08x"; /*        */ buflen = ( length &lt; 0x80 ? 1: length &lt;= 0xff ? 2: length &lt;= 0xffff ? 3: length &lt;= 0xffffff ? 4: 5); /*   asn-*/ buf = malloc(length + buflen); // buf = malloc(buflen); /*        sprintf*/ switch (buflen - 1) { case 0: format = f0; break; case 1: format = f1; break; case 2: format = f2; break; case 3: format = f3; break; case 4: format = f4; break; } // sprintf    little  bigendian       sprintf((char*)buf_for_len, (const char *)format, type, length); length = 0; /* asn1-*/ fprintf(stderr, "ASN1 - :%s\n", buf_for_len); /*     */ for (s=(const char *)buf_for_len; *s; s +=2 ) { if (!hexdigitp (s) || (!hexdigitp (s+1) &amp;&amp; hexdigitp (s+1) != 0) ){ fprintf (stderr, "invalid hex digits in \"%s\"\n", buf_for_len); *lenasn = 0; return NULL; } ((unsigned char*)buf)[length++] = xtoi_2 (s); } *lenasn = length; return (buf); }</span></span></span></span></span></span></code> </pre> <br>  Fungsi mengembalikan pointer ke buffer dengan struktur asn1, dialokasikan dengan mempertimbangkan panjang data.  Tetap menyalin data ini ke dalam buffer yang diterima dengan offset dengan panjang header.  Panjang tajuk dikembalikan melalui parameter lenasn. <br><br>  Untuk memeriksa bagaimana fungsi ini bekerja, kami akan menulis sebuah utilitas sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define digitp(p) (*(p) &gt;= '0' &amp;&amp; *(p) &lt;= '9') #define hexdigitp(a) (digitp (a) \ || (*(a) &gt;= 'A' &amp;&amp; *(a) &lt;= 'F') \ || (*(a) &gt;= 'a' &amp;&amp; *(a) &lt;= 'f')) #define xtoi_1(p) (*(p) &lt;= '9'? (*(p)- '0'): \ *(p) &lt;= 'F'? (*(p)-'A'+10):(*(p)-'a'+10)) #define xtoi_2(p) ((xtoi_1(p) * 16) + xtoi_1((p)+1)) int main (int argc, char *argv[]) { unsigned char *hdrasn; unsigned char type; unsigned long length; unsigned long lenasn; if (argc != 3) { fprintf (stderr, "Usage: wrap_id_with_length &lt;id&gt; &lt;length&gt;\n"); exit(-1); } type = atoi(argv[1]); length = atol(argv[2]); fprintf (stderr, "&lt;id=%02x&gt; &lt;length=%lu&gt;\n", type, length); if (length == 0) { fprintf (stderr, "Bad length=%s\nUsage: wrap_id_with_length &lt;id&gt; &lt;length&gt;\n", argv[2]); exit(-1); } hdrasn = wrap_id_with_length(type, length, &amp;lenasn); fprintf (stderr, "Length asn1-buffer=%lu, LEN_HEADER=%lu, LEN_DATA=%lu\n", lenasn, lenasn - length, length); }</span></span></span></span></code> </pre> <br>  Simpan bersama-sama dengan fungsi wrap_id_with_length dalam file wrap_id_with_length.c. <br><br>  Kami menyiarkan: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$cc</span></span> –o wrap_id_with_length wrap_id_with_length.c $</code> </pre> <br>  Jalankan program yang dihasilkan dengan berbagai sumber data.  Tipe data ditentukan oleh desimal: <br><br><pre> <code class="bash hljs">bash-4.3$ ./wrap_id_with_length 06 8 &lt;id=06&gt; &lt;length=8&gt; ASN1 - :0608 Length asn1-buffer=10, LEN_HEADER=2, LEN_DATA=8 bash-4.3$ ./wrap_id_with_length 06 127 &lt;id=06&gt; &lt;length=127&gt; ASN1 - :067f Length asn1-buffer=129, LEN_HEADER=2, LEN_DATA=127 bash-4.3$ ./wrap_id_with_length 48 128 &lt;id=30&gt; &lt;length=128&gt; ASN1 - :308180 Length asn1-buffer=131, LEN_HEADER=3, LEN_DATA=128 bash-4.3$ ./wrap_id_with_length 48 4097 &lt;id=30&gt; &lt;length=4097&gt; ASN1 - :30821001 Length asn1-buffer=4101, LEN_HEADER=4, LEN_DATA=4097 bash-4.3$</code> </pre><br>  Anda dapat memeriksa kebenaran pembentukan header menggunakan kalkulator apa pun: <br><br><img src="https://habrastorage.org/webt/kj/rp/4s/kjrp4sc9ddsk6fhjhkohe8tkotu.png"><br><br>  Kita semua siap untuk membentuk struktur ASN1.  Tapi pertama-tama, buat perubahan kecil pada fungsi wrap_id_with_length dan panggil saja <br><br><div class="spoiler">  <b class="spoiler_title">wrap_for_asn1:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrap_for_asn1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *prefix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *wrap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrap_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lenasn)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buflen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *format; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf_for_len[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f0[] = <span class="hljs-string"><span class="hljs-string">"%02x%02x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f1[] = <span class="hljs-string"><span class="hljs-string">"%02x81%02x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f2[] = <span class="hljs-string"><span class="hljs-string">"%02x82%04x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f3[] = <span class="hljs-string"><span class="hljs-string">"%02x83%06x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f4[] = <span class="hljs-string"><span class="hljs-string">"%02x84%08x"</span></span>; length = prefix_len + wrap_len; buflen += ( length &lt;= <span class="hljs-number"><span class="hljs-number">0x80</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xff</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xffff</span></span> ? <span class="hljs-number"><span class="hljs-number">3</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xffffff</span></span> ? <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>); buf = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(length + buflen); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (buflen - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: format = f0; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: format = f1; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: format = f2; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: format = f3; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: format = f4; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// sprintf    little  bigendian    sprintf((char*)buf_for_len, (const char *)format, type, length); length = 0; for (s=buf_for_len; *s; s +=2 ) { if (!hexdigitp (s) || (!hexdigitp (s+1) &amp;&amp; hexdigitp (s+1) != 0) ){ fprintf (stderr, "invalid hex digits in \"%s\"\n", buf_for_len); } ((unsigned char*)buf)[length++] = xtoi_2 (s); } if (prefix_len &gt; 0) { memcpy(buf + length, prefix, prefix_len); } memcpy(buf + length + prefix_len, wrap, wrap_len); *lenasn = (unsigned long)(length + prefix_len + wrap_len); return (buf); }</span></span></code> </pre> <br></div></div><br>  Seperti yang Anda lihat, perubahannya minimal.  Sebagai parameter input, data itu sendiri ditambahkan, yang di dalam fungsi dikemas ke dalam struktur ASN1.  Selain itu, dua buffer dapat dimasukkan ke input sekaligus.  Bagi kami, ini mudah. <br><br>  Sebelum menyajikan kasus uji, kami memberikan kode tiga fungsi lagi.  Fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oid2buffer</a> pertama mengubah oid dari bentuk desimal bertitik ke penyandian DER.  Kami membutuhkan fungsi ini untuk mengonversi, khususnya, oids dari pasangan kunci (lihat di atas). <br><br><div class="spoiler">  <b class="spoiler_title">Teks fungsi ada di sini:</b> <div class="spoiler_text">  static char * oid2buffer (char * oid_str, unsigned long * len) { <br>  char * curstr; <br>  char * curstr1; <br>  char * nextstr; <br>  firstval int unsigned; <br>  unsvaled int secondval; <br>  val int unsigned; <br>  unsigned char buf [5]; <br>  int count; <br>  unsigned char oid_hex [100]; <br>  char * res; <br>  int i; <br>  if (oid_str == NULL) { <br>  * len = 0; <br>  mengembalikan NULL; <br>  } <br>  * len = 0; <br>  curstr = strdup ((const char *) oid_str); <br>  curstr1 = curstr; <br>  nextstr = strchr (curstr, '.'); <br>  if (nextstr == NULL) { <br>  * len = 0; <br>  mengembalikan NULL; <br>  } <br>  * nextstr = '\ 0'; <br>  firstval = atoi (curstr); <br>  curstr = nextstr + 1; <br>  nextstr = strchr (curstr, '.'); <br>  if (nextstr) { <br>  * nextstr = '\ 0'; <br>  } <br>  secondval = atoi (curstr); <br>  if (firstval&gt; 2) { <br>  * len = 0; <br>  mengembalikan NULL; <br>  } <br>  if (secondval&gt; 39) { <br>  * len = 0; <br>  mengembalikan NULL; <br>  } <br>  oid_hex [0] = (unsigned char) ((firstval * 40) + secondval); <br>  i = 1; <br>  while (nextstr) { <br>  curstr = nextstr + 1; <br><br>  nextstr = strchr (curstr, '.'); <br><br>  if (nextstr) { <br>  * nextstr = '\ 0'; <br>  } <br><br>  memset (buf, 0, sizeof (buf)); <br>  val = atoi (curstr); <br>  hitung = 0; <br>  if (curstr [0]! = '0') <br>  while (val) { <br>  buf [count] = (val &amp; 0x7f); <br>  val = val &gt;&gt; 7; <br>  hitung ++; <br>  } <br>  selain itu { <br>  buf [count] = (val &amp; 0x7f); <br>  val = val &gt;&gt; 7; <br>  hitung ++; <br>  } <br>  while (count--) { <br>  if (count) { <br>  oid_hex [i] = buf [count] |  0x80; <br>  } lain { <br>  oid_hex [i] = buf [count]; <br>  } <br>  i ++; <br>  } <br>  } <br>  res = (char *) malloc (i); <br>  if (res) { <br>  memcpy (res, oid_hex, i); <br>  * len = i; <br>  } <br>  gratis (curstr1); <br>  pengembalian res; <br>  } <br></div></div><br>  Dua fungsi lainnya memungkinkan buffer biner dikonversi menjadi heksadesimal (buffer2hex) dan sebaliknya (hex2buffer). <br><br><div class="spoiler">  <b class="spoiler_title">Fungsi-fungsi ini ada di sini:</b> <div class="spoiler_text">  char statis * <br>  buffer2hex (const unsigned char * src, size_t len) <br>  { <br>  int i; <br>  char * dest; <br>  char * res; <br>  dest = (char *) malloc (len * 2 + 1); <br>  res = dest; <br>  jika (dest) <br>  { <br>  untuk (i = 0; i &lt;len; i ++, dest + = 2) <br>  sprintf (dest, "% 02X", src [i]); <br>  } <br>  pengembalian res; <br>  } <br><br>  kekosongan statis * <br>  hex2buffer (const char * string, size_t * r_length) <br>  { <br>  const char * s; <br>  buffer * char unsigned; <br>  panjang size_t; <br><br>  buffer = malloc (strlen (string) / 2 + 1); <br>  panjang = 0; <br>  untuk (s = string; * s; s + = 2) <br>  { <br>  if (! hexdigitp (s) ||! hexdigitp (s + 1)) { <br>  fprintf (stderr, "digit hex tidak valid dalam \"% s \ "\ n", string); <br>  } <br>  ((unsigned char *) buffer) [length ++] = xtoi_2 (s); <br>  } <br>  * r_length = panjang; <br>  mengembalikan buffer; <br>  } <br></div></div><br>  Fungsi-fungsi ini sangat nyaman untuk debugging, dan kemungkinan besar banyak yang memilikinya. <br><br>  Dan sekarang kita kembali ke solusi tugas, memperoleh struktur publik kunci asn1.  Kami akan menulis sebuah utilitas yang akan menghasilkan dan menyimpan struktur kunci publik asn1 dalam file ASN1_PIBINFO.der. <br><br><div class="spoiler">  <b class="spoiler_title">Utilitas ini ada di sini:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #define digitp(p) (*(p) &gt;= '0' &amp;&amp; *(p) &lt;= '9') #define hexdigitp(a) (digitp (a) \ || (*(a) &gt;= 'A' &amp;&amp; *(a) &lt;= 'F') \ || (*(a) &gt;= 'a' &amp;&amp; *(a) &lt;= 'f')) #define xtoi_1(p) (*(p) &lt;= '9'? (*(p)- '0'): \ *(p) &lt;= 'F'? (*(p)-'A'+10):(*(p)-'a'+10)) #define xtoi_2(p) ((xtoi_1(p) * 16) + xtoi_1((p)+1)) /*   oid2buffer*/ /*   buffer2hex  hex2buffer*/ /*   wrap_for_asn1*/ int main() { int fd; unsigned char *asn, *asn1, *asn2, *asn3, *pubkeyalgo; unsigned char* pubkey_bin; //  char gost3410par[] = "\x06\x7\x2a\x85\x03\x02\x02\x23\x01"; unsigned long gost3410par_len = sizeof(gost3410par) - 1; char gost3411par[] = "\x06\x8\x2a\x85\x03\x07\x01\x01\x02\x02"; unsigned long gost3411par_len = sizeof(gost3411par) - 1; unsigned char pubkey_hex[] = "9af03570ed0c54cd4953f11ab19e551022cd48603326c1b9b630b1cff74e5a160ba1718166cc22bf70f82bdc957d924c501b9332491cb3a36ce45770f05487b5"; char pubkey_oid_2001[] = "1.2.643.2.2.19"; char pubkey_oid_2012_256[] = "1.2.643.7.1.1.1.1"; char pubkey_oid_2012_512[] = "1.2.643.7.1.1.1.2"; unsigned long pubkey_len, pubkey_len_full, len10, len11, len12, lenalgo; unsigned char *pkalgo; unsigned long pkalgo_len; uint16_t x = 1; /* 0x0001 */ printf("%s\n", *((uint8_t *) &amp;x) == 0 ? "big-endian" : "little-endian"); ////pubkeyinfo //      if (!memmem(gost3411par, 8, "\x2a\x85\x03\x07", 4)) { //   34.11-94,     34.10-2001 - 1.2.643.2.2.19 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2001, &amp;lenalgo); } else if (!memcmp(gost3411par, "\x2a\x85\x03\x07\x01\x01\x02\x02", 8)){ //   34.11-2012-256,     34.10-2012-256 - 1.2.643.7.1.1.1.1 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2012_256, &amp;lenalgo); } else { //   34.11-2012-512,     34.10-2012-512 - 1.2.643.7.1.1.1.2 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2012_512, &amp;lenalgo); } pubkey_bin =(unsigned char*)hex2buffer((const char *)pubkey_hex, &amp;pubkey_len); //    asn1 = wrap_for_asn1_bin('\x04', (unsigned char *)"", 0, pubkey_bin, pubkey_len, &amp;pubkey_len); asn = wrap_for_asn1_bin('\x03', (unsigned char *)"\x00", 1, asn1, pubkey_len, &amp;pubkey_len_full); fprintf(stderr, "PUBLIC_VALUE=%s\n", buffer2hex(asn, pubkey_len_full)); free(asn1); //  asn3 = wrap_for_asn1_bin('\x30', (unsigned char*)gost3410par, gost3410par_len, (unsigned char *)gost3411par, gost3411par_len, &amp;len12); fprintf(stderr, "\nPARAMS len12=%lu, FULL=%s\n", len12, buffer2hex(asn3, len12)); //   pkalgo = wrap_for_asn1_bin('\x06', (unsigned char *)"", 0, pubkeyalgo, lenalgo, &amp;pkalgo_len); //     asn2 = wrap_for_asn1_bin('\x30', pkalgo, pkalgo_len, asn3, len12, &amp;len11); fprintf(stderr, "PubKEY=%s\n", buffer2hex(asn3, len11)); asn1 = wrap_for_asn1_bin('\x30', asn2, len11, asn, pubkey_len_full, &amp;len10); free(asn2); free(asn3); fprintf(stderr, "\n%s\n", buffer2hex(asn1, len10)); fd = open ("ASN1_PUBINFO.der", O_TRUNC|O_RDWR|O_CREAT,S_IRWXO); write(fd, asn1, len10); close(fd); free(asn1); chmod("ASN1_PUBINFO.der", 0666); }</span></span></span></span></code> </pre> <br></div></div><br>  Untuk memverifikasi hasilnya, kami akan menggunakan utilitas derdump dan pp dari paket NSS. <br><br>  Utilitas pertama akan menunjukkan kepada kita struktur asn1 dari kunci publik: <br><br><pre> <code class="bash hljs">$ derdump -i ASN1_PUBINFO.der C-Sequence (102) C-Sequence (31) Object Identifier (8) 1 2 643 7 1 1 1 2 (GOST R 34.10-2012 Key 512) C-Sequence (19) Object Identifier (7) 1 2 643 2 2 35 1 Object Identifier (8) 1 2 643 7 1 1 2 2 (GOST R 34.11-2012 256) Bit String (67) 00 04 40 9a f0 35 70 ed 0c 54 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 49 53 f1 1a b1 9e 55 10 22 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 48 60 33 26 c1 b9 b6 30 b1 cf f7 4e 5a 16 0b a1 71 81 66 cc 22 bf 70 f8 2b dc 95 7d 92 4c 50 1b 93 32 49 1c b3 a3 6c e4 57 70 f0 54 87 b5 $</code> </pre> <br>  Yang kedua akan menampilkan konten kunci: <br><br><pre> <code class="bash hljs">$ pp -t pk -i ASN1_PUBINFO.der Public Key: Subject Public Key Info: Public Key Algorithm: GOST R 34.10-2012 512 Public Key: PublicValue: 9a:f0:35:70:ed:0c:54:<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span>:49:53:f1:1a:b1:9e:55:10: 22:<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span>:48:60:33:26:c1:b9:b6:30:b1:cf:f7:4e:5a:16: 0b:a1:71:81:66:cc:22:bf:70:f8:2b:dc:95:7d:92:4c: 50:1b:93:32:49:1c:b3:a3:6c:e4:57:70:f0:54:87:b5 GOSTR3410Params: OID.1.2.643.2.2.35.1 GOSTR3411Params: GOST R 34.11-2012 256 $</code> </pre> <br>  Mereka yang ingin dapat mengecek, misalnya, dengan utilitas openssl, lebih disukai dengan mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GOST yang terhubung</a> : <br><br><pre> <code class="bash hljs">$ /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lirssl_csp_64/bin/lirssl_static asn1parse -inform DER -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ASN1_PUBINFO.der 0:d=0 hl=2 l= 102 cons: SEQUENCE 2:d=1 hl=2 l= 31 cons: SEQUENCE 4:d=2 hl=2 l= 8 prim: OBJECT :GOST R 34.10-2012 with 512 bit modulus 14:d=2 hl=2 l= 19 cons: SEQUENCE 16:d=3 hl=2 l= 7 prim: OBJECT :id-GostR3410-2001-CryptoPro-A-ParamSet 25:d=3 hl=2 l= 8 prim: OBJECT :GOST R 34.11-2012 with 256 bit <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span> 35:d=1 hl=2 l= 67 prim: BIT STRING $</code> </pre> <br>  Seperti yang Anda lihat, struktur ASN1 yang dihasilkan berhasil diuji di mana-mana. <br><br>  Algoritme dan utilitas yang diusulkan untuk membentuk struktur ASN1 tidak memerlukan penggunaan kompiler ASN1 dan pustaka ekstensi (openssl yang sama) dan ternyata sangat nyaman digunakan.  Kami akan memanggil mereka di artikel berikutnya, ketika keinginan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Pas</a> akan terpenuhi dan utilitas grafis akan disajikan yang tidak hanya "parsing sertifikat" dan memverifikasi validitasnya, tetapi juga menghasilkan pasangan kunci pada token PKCS # 11, menghasilkan dan menandatangani permintaan untuk sertifikat yang memenuhi syarat.  Dengan permintaan ini, Anda dapat dengan aman pergi ke CA untuk mendapatkan sertifikat.  Menjelang pertanyaan, saya segera mencatat bahwa dalam kasus terakhir, token harus disertifikasi sebagai sistem perlindungan informasi kriptografis dalam sistem sertifikasi FSB Rusia. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446166/">https://habr.com/ru/post/id446166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446144/index.html">Intisari materi menarik untuk pengembang seluler # 292 (25 Maret - 31 Maret)</a></li>
<li><a href="../id446148/index.html">Linux Kernel 5.0 - menulis Perangkat Blok Sederhana di bawah blk-mq</a></li>
<li><a href="../id446150/index.html">Pembelajaran mesin tanpa Python, Anaconda dan reptil lainnya</a></li>
<li><a href="../id446152/index.html">Commando VM - Kali Linux Alternatif untuk Windows</a></li>
<li><a href="../id446162/index.html">Bagaimana menjadi "junior yang cerdas." Pengalaman pribadi</a></li>
<li><a href="../id446172/index.html">Batasi Pesan API VK - apa yang harus dilakukan</a></li>
<li><a href="../id446174/index.html">Yandex.Alice dan Telegram bot dalam PHP dengan fungsi tunggal</a></li>
<li><a href="../id446176/index.html">Pengenalan tangki dalam aliran video menggunakan metode pembelajaran mesin (+2 video di platform Elbrus dan Baikal)</a></li>
<li><a href="../id446180/index.html">Apakah MongoDB pilihan yang tepat?</a></li>
<li><a href="../id446184/index.html">Aplikasi TDD pada Spring Boot: menyelaraskan tes dan bekerja dengan konteksnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>