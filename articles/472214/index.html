<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî∞ üçï üîâ La ramificaci√≥n pronosticada err√≥neamente puede aumentar significativamente el tiempo de ejecuci√≥n del programa üí£ üìï üêÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los procesadores modernos son superescalares, es decir, pueden ejecutar varias instrucciones simult√°neamente. Por ejemplo, algunos procesadores pueden...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La ramificaci√≥n pronosticada err√≥neamente puede aumentar significativamente el tiempo de ejecuci√≥n del programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472214/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/0a4/307/7ec0a4307d749114c76ad30d974de620.png" alt="imagen"></div><br>  Los procesadores modernos son superescalares, es decir, pueden ejecutar varias instrucciones simult√°neamente.  Por ejemplo, algunos procesadores pueden procesar de cuatro a seis instrucciones por ciclo.  Adem√°s, muchos de estos procesadores son capaces de iniciar instrucciones fuera de orden: pueden comenzar a trabajar con comandos ubicados en el c√≥digo mucho m√°s tarde. <br><br>  Al mismo tiempo, el c√≥digo a menudo contiene ramas ( <code>if‚Äìthen</code> ).  Tales ramas a menudo se implementan como "transiciones", en las cuales el procesador procede a ejecutar instrucciones debajo del c√≥digo o contin√∫a la ruta actual. <br><br>  Con la ejecuci√≥n superescalar de comandos fuera de orden, la ramificaci√≥n es dif√≠cil.  Para esto, los procesadores tienen bloques de predicci√≥n de rama sofisticados.  Es decir, el procesador est√° tratando de predecir el futuro.  Cuando ve una rama y, por lo tanto, una transici√≥n, trata de adivinar hacia d√≥nde ir√° el programa. <br><a name="habracut"></a><br>  Muy a menudo esto funciona bastante bien.  Por ejemplo, la mayor√≠a de los bucles se implementan como ramas.  Al final de cada iteraci√≥n del bucle, el procesador debe predecir si se realizar√° la siguiente iteraci√≥n.  A menudo es m√°s seguro para el procesador predecir que el ciclo continuar√° (para siempre).  En este caso, el procesador predice err√≥neamente solo una rama por ciclo. <br><br>  Hay otros ejemplos comunes.  Si accede al contenido de una matriz, muchos lenguajes de programaci√≥n agregan "comprobaci√≥n encuadernada", una comprobaci√≥n oculta de la correcci√≥n del √≠ndice antes de acceder al valor de la matriz.  Si el √≠ndice es incorrecto, se genera un error; de lo contrario, el c√≥digo contin√∫a ejecut√°ndose de la manera habitual.  Los controles fronterizos son predecibles, porque en una situaci√≥n normal todas las operaciones de acceso deben ser correctas.  En consecuencia, la mayor√≠a de los procesadores deber√≠an predecir casi perfectamente el resultado. <br><br><h2>  ¬øQu√© sucede si la ramificaci√≥n es dif√≠cil de predecir? </h2><br>  Dentro del procesador, todas las instrucciones que se ejecutaron pero que se encuentran en la rama predicha incorrectamente deben cancelarse y los c√°lculos deben iniciarse nuevamente.  Es de esperar que por cada error de predicci√≥n de rama paguemos m√°s de 10 ciclos.  Debido a esto, el tiempo de ejecuci√≥n del programa puede aumentar significativamente. <br><br>  Veamos un c√≥digo simple en el que escribimos enteros aleatorios en una matriz de salida: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { out[index] = random(); index += <span class="hljs-number"><span class="hljs-number">1</span></span>; howmany--; }</code> </pre> <br>  Podemos generar un n√∫mero aleatorio adecuado en promedio durante 3 ciclos.  Es decir, el retraso total del generador de n√∫meros aleatorios puede ser igual a 10 ciclos.  Pero nuestro procesador es superescalar, es decir, podemos realizar varios c√°lculos de n√∫meros aleatorios simult√°neamente.  Por lo tanto, podremos generar un nuevo n√∫mero aleatorio aproximadamente cada 3 ciclos. <br><br>  Cambiemos un poco la funci√≥n para que solo se escriban n√∫meros impares en la matriz: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { val = random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( val is an odd integer ) { out[index] = val; index += <span class="hljs-number"><span class="hljs-number">1</span></span>; } howmany--; }</code> </pre> <br>  Puede pensar ingenuamente que esta nueva caracter√≠stica podr√≠a ser m√°s r√°pida.  Y de hecho, porque necesitamos registrar en promedio solo uno de dos enteros.  Hay una rama en el c√≥digo, pero para verificar la paridad de un n√∫mero entero, solo verifique un bit. <br><br>  Compar√© estas dos funciones en C ++ en un procesador Skylake: <br><br><div class="scrollable-table"><table><tbody><tr><td>  Registra todos los n√∫meros aleatorios </td><td>  3.3 ciclos en entero </td></tr><tr><td>  Escribir solo n√∫meros aleatorios impares </td><td>  15 ciclos en entero </td></tr></tbody></table></div><br>  ¬°La segunda funci√≥n funciona unas cinco veces m√°s! <br><br>  ¬øSe puede arreglar algo aqu√≠?  S√≠, podemos eliminar la ramificaci√≥n.  Un n√∫mero entero impar se puede caracterizar de tal manera que sea l√≥gico Y bit a bit con un valor de 1 igual a uno.  El truco consiste en incrementar el √≠ndice de la matriz en uno solo si el valor aleatorio es impar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { val = random(); out[index] = val; index += (val bitand <span class="hljs-number"><span class="hljs-number">1</span></span>); howmany--; }</code> </pre> <br>  En esta nueva versi√≥n, siempre escribimos un valor aleatorio en la matriz de salida, incluso si no es necesario.  A primera vista, esto es un desperdicio de recursos.  Sin embargo, nos salva de las ramas err√≥neamente predichas.  En la pr√°ctica, el rendimiento es casi el mismo que el c√≥digo original, y mucho mejor que la versi√≥n con ramas: <br><br><div class="scrollable-table"><table><tbody><tr><td>  Registra todos los n√∫meros aleatorios </td><td>  3.3 ciclos en entero </td></tr><tr><td>  escribir solo n√∫meros aleatorios impares </td><td>  15 ciclos en entero </td></tr><tr><td>  <strong>con ramificaci√≥n eliminada</strong> </td><td>  <strong>3.8 ciclos por entero</strong> </td></tr></tbody></table></div><br>  ¬øPodr√≠a el compilador resolver este problema por s√≠ solo?  En general, la respuesta es no.  A veces, los compiladores tienen opciones para eliminar por completo la ramificaci√≥n, incluso si hay una <code>if-then</code> en el c√≥digo fuente.  Por ejemplo, la ramificaci√≥n a veces se puede reemplazar con "movimiento condicional" u otros trucos aritm√©ticos.  Sin embargo, estos trucos no son seguros para su uso en compiladores. <br><br>  Una conclusi√≥n importante: la ramificaci√≥n pronosticada err√≥neamente no es un problema insignificante, tiene una gran influencia. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mi c√≥digo fuente est√° en Github</a> . <br><br><h2>  Crear puntos de referencia es una tarea dif√≠cil: los procesadores aprenden a predecir la ramificaci√≥n </h2><br>  [Nota  traducci√≥n: esta parte era un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo separado</a> del autor, pero lo combin√© con el anterior, porque tienen un tema en com√∫n.] <br><br>  En la parte anterior, mostr√© que la mayor parte del tiempo de ejecuci√≥n de un programa puede deberse a una predicci√≥n de rama incorrecta.  Mi punto de referencia era escribir 64 millones de valores enteros aleatorios en una matriz.  Cuando intent√© registrar solo n√∫meros aleatorios impares, el rendimiento debido a predicciones err√≥neas disminuy√≥ considerablemente. <br><br>  ¬øPor qu√© utilic√© 64 millones de enteros, en lugar de, digamos, 2000?  Si ejecuta solo una prueba, entonces no importar√°.  Sin embargo, ¬øqu√© suceder√° si hacemos muchos intentos?  El n√∫mero de ramas err√≥neamente pronosticadas caer√° r√°pidamente a cero.  El rendimiento del procesador Intel Skylake habla por s√≠ mismo: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Numero de pruebas </th><th>  Ramas predichas incorrectamente (Intel Skylake) </th></tr><tr><td>  1 </td><td>  48% </td></tr><tr><td>  2 </td><td>  38% </td></tr><tr><td>  3 </td><td>  28% </td></tr><tr><td>  4 4 </td><td>  22% </td></tr><tr><td>  5 5 </td><td>  14% </td></tr></tbody></table></div><br>  Como se puede ver en los gr√°ficos a continuaci√≥n, el "entrenamiento" contin√∫a m√°s all√°.  Poco a poco, la proporci√≥n de ramas err√≥neamente predichas se reduce a alrededor del 2%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/0a4/307/7ec0a4307d749114c76ad30d974de620.png" width="640" height="480"></div><br>  Es decir, si continuamos midiendo el tiempo que lleva la misma tarea, entonces se vuelve cada vez menos, porque el procesador aprende a predecir mejor el resultado.  La calidad de la "capacitaci√≥n" depende del modelo de procesador espec√≠fico, pero se espera que los procesadores m√°s nuevos aprendan mejor. <br><br>  Los √∫ltimos procesadores de servidor AMD aprenden a predecir casi perfectamente la ramificaci√≥n (dentro del 0.1%) en menos de 10 intentos. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Numero de pruebas </th><th>  Ramas predichas incorrectamente (AMD Roma) </th></tr><tr><td>  1 </td><td>  52% </td></tr><tr><td>  2 </td><td>  18% </td></tr><tr><td>  3 </td><td>  6% </td></tr><tr><td>  4 4 </td><td>  2% </td></tr><tr><td>  5 5 </td><td>  1% </td></tr><tr><td>  6 6 </td><td>  0.3% </td></tr><tr><td>  7 7 </td><td>  0,15% </td></tr><tr><td>  8 </td><td>  0,15% </td></tr><tr><td>  9 9 </td><td>  0.1% </td></tr></tbody></table></div><br>  Esta predicci√≥n ideal en AMD Roma desaparece cuando el n√∫mero de valores en el problema aumenta de 2000 a 10,000: la mejor predicci√≥n cambia de una fracci√≥n de errores de 0.1% a 33%. <br><br>  Probablemente deber√≠a evitar el c√≥digo de evaluaci√≥n comparativa con la ramificaci√≥n para tareas peque√±as. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mi c√≥digo github</a> <br><br>  <strong>Reconocimiento</strong> : valores AMD Roma proporcionados por Vel Erwan. <br><br>  <strong>Lectura adicional</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un caso para la predicci√≥n de rama de longitud de historia geom√©trica TAgged</a> (Seznec et al.) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472214/">https://habr.com/ru/post/472214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472202/index.html">Windows 10 + Python = C√≥digo VS + WSL</a></li>
<li><a href="../472204/index.html">Experimentos simples con el microcontrolador STM32F103 (Blue Tablet)</a></li>
<li><a href="../472208/index.html">Pantallas OLED de tel√©fonos inteligentes Android y c√≥mo lidiar con ellos</a></li>
<li><a href="../472210/index.html">"Parece que esto ya sucedi√≥?" Busque incidentes y reclamos similares</a></li>
<li><a href="../472212/index.html">C√≥mo aterrizar el transbordador espacial desde el espacio</a></li>
<li><a href="../472216/index.html">¬øQu√© debemos construir IoT? Tu IoT en Amazon en un d√≠a</a></li>
<li><a href="../472220/index.html">¬øPor qu√© a los mejores f√≠sicos no les gusta una interpretaci√≥n multimundo?</a></li>
<li><a href="../472222/index.html">‚ÄúLee si te gusta escuchar‚Äù: libros para aquellos que no son indiferentes a la m√∫sica, desde cl√°sica hasta hip-hop.</a></li>
<li><a href="../472224/index.html">Uso de la nueva SSD NVMe como disco de arranque en sistemas m√°s antiguos con BIOS heredado (para cualquier sistema operativo)</a></li>
<li><a href="../472226/index.html">Mejora de controles de formulario en Microsoft Edge y Chromium</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>