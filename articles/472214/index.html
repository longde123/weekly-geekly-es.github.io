<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔰 🍕 🔉 La ramificación pronosticada erróneamente puede aumentar significativamente el tiempo de ejecución del programa 💣 📕 🐁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los procesadores modernos son superescalares, es decir, pueden ejecutar varias instrucciones simultáneamente. Por ejemplo, algunos procesadores pueden...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La ramificación pronosticada erróneamente puede aumentar significativamente el tiempo de ejecución del programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472214/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/0a4/307/7ec0a4307d749114c76ad30d974de620.png" alt="imagen"></div><br>  Los procesadores modernos son superescalares, es decir, pueden ejecutar varias instrucciones simultáneamente.  Por ejemplo, algunos procesadores pueden procesar de cuatro a seis instrucciones por ciclo.  Además, muchos de estos procesadores son capaces de iniciar instrucciones fuera de orden: pueden comenzar a trabajar con comandos ubicados en el código mucho más tarde. <br><br>  Al mismo tiempo, el código a menudo contiene ramas ( <code>if–then</code> ).  Tales ramas a menudo se implementan como "transiciones", en las cuales el procesador procede a ejecutar instrucciones debajo del código o continúa la ruta actual. <br><br>  Con la ejecución superescalar de comandos fuera de orden, la ramificación es difícil.  Para esto, los procesadores tienen bloques de predicción de rama sofisticados.  Es decir, el procesador está tratando de predecir el futuro.  Cuando ve una rama y, por lo tanto, una transición, trata de adivinar hacia dónde irá el programa. <br><a name="habracut"></a><br>  Muy a menudo esto funciona bastante bien.  Por ejemplo, la mayoría de los bucles se implementan como ramas.  Al final de cada iteración del bucle, el procesador debe predecir si se realizará la siguiente iteración.  A menudo es más seguro para el procesador predecir que el ciclo continuará (para siempre).  En este caso, el procesador predice erróneamente solo una rama por ciclo. <br><br>  Hay otros ejemplos comunes.  Si accede al contenido de una matriz, muchos lenguajes de programación agregan "comprobación encuadernada", una comprobación oculta de la corrección del índice antes de acceder al valor de la matriz.  Si el índice es incorrecto, se genera un error; de lo contrario, el código continúa ejecutándose de la manera habitual.  Los controles fronterizos son predecibles, porque en una situación normal todas las operaciones de acceso deben ser correctas.  En consecuencia, la mayoría de los procesadores deberían predecir casi perfectamente el resultado. <br><br><h2>  ¿Qué sucede si la ramificación es difícil de predecir? </h2><br>  Dentro del procesador, todas las instrucciones que se ejecutaron pero que se encuentran en la rama predicha incorrectamente deben cancelarse y los cálculos deben iniciarse nuevamente.  Es de esperar que por cada error de predicción de rama paguemos más de 10 ciclos.  Debido a esto, el tiempo de ejecución del programa puede aumentar significativamente. <br><br>  Veamos un código simple en el que escribimos enteros aleatorios en una matriz de salida: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { out[index] = random(); index += <span class="hljs-number"><span class="hljs-number">1</span></span>; howmany--; }</code> </pre> <br>  Podemos generar un número aleatorio adecuado en promedio durante 3 ciclos.  Es decir, el retraso total del generador de números aleatorios puede ser igual a 10 ciclos.  Pero nuestro procesador es superescalar, es decir, podemos realizar varios cálculos de números aleatorios simultáneamente.  Por lo tanto, podremos generar un nuevo número aleatorio aproximadamente cada 3 ciclos. <br><br>  Cambiemos un poco la función para que solo se escriban números impares en la matriz: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { val = random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( val is an odd integer ) { out[index] = val; index += <span class="hljs-number"><span class="hljs-number">1</span></span>; } howmany--; }</code> </pre> <br>  Puede pensar ingenuamente que esta nueva característica podría ser más rápida.  Y de hecho, porque necesitamos registrar en promedio solo uno de dos enteros.  Hay una rama en el código, pero para verificar la paridad de un número entero, solo verifique un bit. <br><br>  Comparé estas dos funciones en C ++ en un procesador Skylake: <br><br><div class="scrollable-table"><table><tbody><tr><td>  Registra todos los números aleatorios </td><td>  3.3 ciclos en entero </td></tr><tr><td>  Escribir solo números aleatorios impares </td><td>  15 ciclos en entero </td></tr></tbody></table></div><br>  ¡La segunda función funciona unas cinco veces más! <br><br>  ¿Se puede arreglar algo aquí?  Sí, podemos eliminar la ramificación.  Un número entero impar se puede caracterizar de tal manera que sea lógico Y bit a bit con un valor de 1 igual a uno.  El truco consiste en incrementar el índice de la matriz en uno solo si el valor aleatorio es impar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { val = random(); out[index] = val; index += (val bitand <span class="hljs-number"><span class="hljs-number">1</span></span>); howmany--; }</code> </pre> <br>  En esta nueva versión, siempre escribimos un valor aleatorio en la matriz de salida, incluso si no es necesario.  A primera vista, esto es un desperdicio de recursos.  Sin embargo, nos salva de las ramas erróneamente predichas.  En la práctica, el rendimiento es casi el mismo que el código original, y mucho mejor que la versión con ramas: <br><br><div class="scrollable-table"><table><tbody><tr><td>  Registra todos los números aleatorios </td><td>  3.3 ciclos en entero </td></tr><tr><td>  escribir solo números aleatorios impares </td><td>  15 ciclos en entero </td></tr><tr><td>  <strong>con ramificación eliminada</strong> </td><td>  <strong>3.8 ciclos por entero</strong> </td></tr></tbody></table></div><br>  ¿Podría el compilador resolver este problema por sí solo?  En general, la respuesta es no.  A veces, los compiladores tienen opciones para eliminar por completo la ramificación, incluso si hay una <code>if-then</code> en el código fuente.  Por ejemplo, la ramificación a veces se puede reemplazar con "movimiento condicional" u otros trucos aritméticos.  Sin embargo, estos trucos no son seguros para su uso en compiladores. <br><br>  Una conclusión importante: la ramificación pronosticada erróneamente no es un problema insignificante, tiene una gran influencia. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mi código fuente está en Github</a> . <br><br><h2>  Crear puntos de referencia es una tarea difícil: los procesadores aprenden a predecir la ramificación </h2><br>  [Nota  traducción: esta parte era un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo separado</a> del autor, pero lo combiné con el anterior, porque tienen un tema en común.] <br><br>  En la parte anterior, mostré que la mayor parte del tiempo de ejecución de un programa puede deberse a una predicción de rama incorrecta.  Mi punto de referencia era escribir 64 millones de valores enteros aleatorios en una matriz.  Cuando intenté registrar solo números aleatorios impares, el rendimiento debido a predicciones erróneas disminuyó considerablemente. <br><br>  ¿Por qué utilicé 64 millones de enteros, en lugar de, digamos, 2000?  Si ejecuta solo una prueba, entonces no importará.  Sin embargo, ¿qué sucederá si hacemos muchos intentos?  El número de ramas erróneamente pronosticadas caerá rápidamente a cero.  El rendimiento del procesador Intel Skylake habla por sí mismo: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Numero de pruebas </th><th>  Ramas predichas incorrectamente (Intel Skylake) </th></tr><tr><td>  1 </td><td>  48% </td></tr><tr><td>  2 </td><td>  38% </td></tr><tr><td>  3 </td><td>  28% </td></tr><tr><td>  4 4 </td><td>  22% </td></tr><tr><td>  5 5 </td><td>  14% </td></tr></tbody></table></div><br>  Como se puede ver en los gráficos a continuación, el "entrenamiento" continúa más allá.  Poco a poco, la proporción de ramas erróneamente predichas se reduce a alrededor del 2%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/0a4/307/7ec0a4307d749114c76ad30d974de620.png" width="640" height="480"></div><br>  Es decir, si continuamos midiendo el tiempo que lleva la misma tarea, entonces se vuelve cada vez menos, porque el procesador aprende a predecir mejor el resultado.  La calidad de la "capacitación" depende del modelo de procesador específico, pero se espera que los procesadores más nuevos aprendan mejor. <br><br>  Los últimos procesadores de servidor AMD aprenden a predecir casi perfectamente la ramificación (dentro del 0.1%) en menos de 10 intentos. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Numero de pruebas </th><th>  Ramas predichas incorrectamente (AMD Roma) </th></tr><tr><td>  1 </td><td>  52% </td></tr><tr><td>  2 </td><td>  18% </td></tr><tr><td>  3 </td><td>  6% </td></tr><tr><td>  4 4 </td><td>  2% </td></tr><tr><td>  5 5 </td><td>  1% </td></tr><tr><td>  6 6 </td><td>  0.3% </td></tr><tr><td>  7 7 </td><td>  0,15% </td></tr><tr><td>  8 </td><td>  0,15% </td></tr><tr><td>  9 9 </td><td>  0.1% </td></tr></tbody></table></div><br>  Esta predicción ideal en AMD Roma desaparece cuando el número de valores en el problema aumenta de 2000 a 10,000: la mejor predicción cambia de una fracción de errores de 0.1% a 33%. <br><br>  Probablemente debería evitar el código de evaluación comparativa con la ramificación para tareas pequeñas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mi código github</a> <br><br>  <strong>Reconocimiento</strong> : valores AMD Roma proporcionados por Vel Erwan. <br><br>  <strong>Lectura adicional</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un caso para la predicción de rama de longitud de historia geométrica TAgged</a> (Seznec et al.) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472214/">https://habr.com/ru/post/472214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472202/index.html">Windows 10 + Python = Código VS + WSL</a></li>
<li><a href="../472204/index.html">Experimentos simples con el microcontrolador STM32F103 (Blue Tablet)</a></li>
<li><a href="../472208/index.html">Pantallas OLED de teléfonos inteligentes Android y cómo lidiar con ellos</a></li>
<li><a href="../472210/index.html">"Parece que esto ya sucedió?" Busque incidentes y reclamos similares</a></li>
<li><a href="../472212/index.html">Cómo aterrizar el transbordador espacial desde el espacio</a></li>
<li><a href="../472216/index.html">¿Qué debemos construir IoT? Tu IoT en Amazon en un día</a></li>
<li><a href="../472220/index.html">¿Por qué a los mejores físicos no les gusta una interpretación multimundo?</a></li>
<li><a href="../472222/index.html">“Lee si te gusta escuchar”: libros para aquellos que no son indiferentes a la música, desde clásica hasta hip-hop.</a></li>
<li><a href="../472224/index.html">Uso de la nueva SSD NVMe como disco de arranque en sistemas más antiguos con BIOS heredado (para cualquier sistema operativo)</a></li>
<li><a href="../472226/index.html">Mejora de controles de formulario en Microsoft Edge y Chromium</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>