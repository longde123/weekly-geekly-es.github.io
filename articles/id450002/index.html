<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎭 🙅🏽 👩🏽‍🎓 Menemukan Bug di LLVM 8 dengan PVS-Studio 🧥 🐷 ☄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sudah dua tahun sejak kami terakhir memeriksa kode proyek LLVM dengan PVS-Studio, jadi mari kita lihat apakah PVS-Studio masih menjadi pemimpin di ant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menemukan Bug di LLVM 8 dengan PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/450002/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png" alt="PVS-Studio dan LLVM 8.0.0"></div><br>  Sudah dua tahun sejak kami terakhir memeriksa kode proyek LLVM dengan PVS-Studio, jadi mari kita lihat apakah PVS-Studio masih menjadi pemimpin di antara alat untuk mendeteksi bug dan kelemahan keamanan.  Kami akan melakukannya dengan memindai rilis LLVM 8.0.0 untuk bug baru. <br><a name="habracut"></a><br><h2>  Artikel yang harus ditulis </h2><br>  Terus terang, saya tidak ingin menulis artikel ini.  Tidak terlalu menyenangkan membicarakan proyek yang sudah kami periksa lebih dari satu kali ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> ).  Saya lebih suka sesuatu yang baru, tetapi saya tidak punya pilihan. <br><br>  Setiap kali versi baru LLVM dirilis atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clang Static Analyzer</a> dimutakhirkan, kami mendapatkan email yang dibaca di sepanjang baris ini: <br><br>  <i>Hei, versi baru Clang Static Analyzer mendapat diagnostik baru!</i>  <i>PVS-Studio tampaknya semakin tidak relevan.</i>  <i>Dentang dapat mendeteksi lebih banyak bug dari sebelumnya dan sekarang menyusul dengan PVS-Studio.</i>  <i>Apa yang kamu katakan</i> <br><br>  Untuk itu saya dengan senang hati merespons: <br><br>  <b>Kami juga belum bermalas-malasan!</b>  Kami telah secara signifikan meningkatkan kemampuan PVS-Studio, jadi jangan khawatir - kami masih yang terbaik. <br><br>  Tapi itu jawaban yang buruk, saya khawatir.  Ia tidak menawarkan bukti, dan itulah alasan mengapa saya menulis artikel ini.  Jadi, saya telah memeriksa LLVM sekali lagi dan menemukan banyak bug dari semua jenis.  Yang paling saya sukai akan dibahas lebih lanjut.  Clang Static Analyzer tidak dapat mendeteksi bug ini (atau membuat prosesnya sangat merepotkan) - dan kami bisa.  Ngomong-ngomong, aku hanya butuh satu malam untuk menulis semua bug itu. <br><br>  Artikel itu membutuhkan waktu beberapa minggu untuk saya selesaikan.  Aku hanya tidak sanggup memasukkan materi yang dikumpulkan ke dalam teks :) <br><br>  Omong-omong, jika Anda bertanya-tanya teknik apa yang digunakan PVS-Studio untuk mendeteksi bug dan kerentanan, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> ini. <br><br><h2>  Diagnostik baru dan yang sudah ada </h2><br>  Seperti yang sudah saya katakan, yang terakhir dari banyak pemeriksaan LLVM dilakukan dua tahun lalu, dan bug yang ditemukan kemudian diperbaiki oleh penulis.  Artikel ini akan menunjukkan sebagian kesalahan baru.  Kenapa ada bug baru sama sekali?  Ada tiga alasan: <br><br><ol><li>  Proyek LLVM sedang berkembang;  penulis memodifikasi kode yang ada dan menambahkan kode baru.  Kedua bagian yang dimodifikasi dan baru secara alami memiliki bug baru.  Fakta ini adalah argumen yang kuat untuk menjalankan analisis statis secara teratur daripada sesekali.  Format artikel kami sangat cocok untuk menunjukkan kemampuan PVS-Studio, tetapi tidak ada hubungannya dengan meningkatkan kualitas kode atau membuat perbaikan bug lebih murah.  Gunakan analisis statis secara teratur! </li><li>  Kami memodifikasi dan meningkatkan diagnostik yang ada, memungkinkan penganalisa untuk mendeteksi bug yang sebelumnya tidak dapat dikenali. </li><li>  PVS-Studio telah ditingkatkan dengan diagnostik baru, yang tidak ada dua tahun lalu.  Saya mengelompokkan peringatan tersebut ke dalam bagian terpisah sehingga kemajuan PVS-Studio terlihat lebih jelas. </li></ol><br><h2>  Kerusakan ditemukan oleh diagnostik yang ada </h2><br>  <b>Cuplikan no.</b>  <b>1: Copy-Paste</b> <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldUpgradeX86Intrinsic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function *F, StringRef Name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Name == <span class="hljs-string"><span class="hljs-string">"addcarryx.u32"</span></span> || <span class="hljs-comment"><span class="hljs-comment">// Added in 8.0 .... Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0 Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0 Name == "avx512.cvtusi2sd" || // Added in 7.0 Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name == "sse2.pmulu.dq" || // Added in 7.0 Name == "sse41.pmuldq" || // Added in 7.0 Name == "avx2.pmulu.dq" || // Added in 7.0 .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V501</a> [CWE-570] Ada sub-ekspresi identik 'Name.startswith ("avx512.mask.permvar.")' Di sebelah kiri dan di sebelah kanan '||'  operator.  AutoUpgrade.cpp 73 <br><br>  Terjadinya "avx512.mask.permvar."  Substring diperiksa dua kali.  Kondisi kedua jelas untuk memeriksa sesuatu yang lain, tetapi programmer lupa untuk mengubah jalur yang disalin. <br><br>  <b>Cuplikan no.</b>  <b>2: Typo</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CXNameRefFlags { CXNameRange_WantQualifier = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, CXNameRange_WantTemplateArgs = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, CXNameRange_WantSinglePiece = <span class="hljs-number"><span class="hljs-number">0x4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnnotateTokensWorker::HandlePostPonedChildCursor( CXCursor Cursor, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> StartTokenIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier; .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: V501 Ada sub-ekspresi identik 'CXNameRange_WantQualifier' di kiri dan di kanan '|'  operator.  CIndex.cpp 7245 <br><br>  <i>CXNameRange_WantQualifier</i> konstanta bernama digunakan dua kali karena kesalahan ketik. <br><br>  <b>Cuplikan no.</b>  <b>3: Kebingungan tentang prioritas operator</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PPCTTIImpl::getVectorInstrCost(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Opcode, Type *Val, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V502</a> [CWE-783] Mungkin operator '?:' Bekerja dengan cara yang berbeda dari yang diharapkan.  Operator '?:' Memiliki prioritas lebih rendah daripada operator '=='.  PPCTargetTransformInfo.cpp 404 <br><br>  Saya menemukan bug ini sangat lucu.  Ya, saya tahu bahwa saya memiliki rasa yang aneh :). <br><br>  Seperti yang ditentukan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prioritas operator</a> , ekspresi asli dievaluasi sebagai berikut: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-&gt;isLittleEndian())) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Dari sudut pandang praktis, kondisi ini tidak masuk akal karena dapat direduksi menjadi: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian())</code> </pre> <br>  Ini jelas bug.  Itu pasti variabel <i>Indeks</i> yang ingin diperiksa oleh programmer untuk 0/1.  Untuk memperbaiki kode, operator ternary harus dilampirkan dalam tanda kurung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre> <br>  Operator ternary sebenarnya sangat rumit dan dapat menyebabkan kesalahan logika.  Gunakan dengan hati-hati dan jangan ragu untuk menempatkan tanda kurung tambahan di sekitarnya.  Subjek ini dibahas lebih rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di bagian "Waspadai ?: Operator dan lampirkan dalam tanda kurung". <br><br>  <b>Cuplikan no.</b>  <b>4, 5: Null pointer</b> <br><br><pre> <code class="cpp hljs">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) { .... TypedInit *LHS = dyn_cast&lt;TypedInit&gt;(Result); .... LHS = dyn_cast&lt;TypedInit&gt;( UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get()) -&gt;Fold(CurRec)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LHS) { Error(PasteLoc, Twine(<span class="hljs-string"><span class="hljs-string">"can't cast '"</span></span>) + LHS-&gt;getAsString() + <span class="hljs-string"><span class="hljs-string">"' to string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V522</a> [CWE-476] Dereferencing dari null pointer 'LHS' mungkin terjadi.  TGParser.cpp 2152 <br><br>  Jika pointer <i>LHS</i> menjadi nol, program diharapkan menghasilkan peringatan.  Sebagai gantinya, itu akan <i>men-decere</i> pointer yang sangat null: <i>LHS-&gt; getAsString ()</i> . <br><br>  Ini adalah situasi yang cukup khas bagi penangan kesalahan untuk mengandung bug karena pengembang tidak mengujinya dengan benar.  Analisis statis memeriksa semua kode yang dapat dijangkau, tidak peduli seberapa sering itu sebenarnya dieksekusi.  Ini adalah contoh yang baik tentang bagaimana analisis statis melengkapi pengujian kode lain dan sarana perlindungan. <br><br>  Penangan yang salah serupa untuk pointer <i>RHS</i> ditemukan sedikit lebih jauh: V522 [CWE-476] Dereferencing dari null pointer 'RHS' mungkin terjadi.  TGParser.cpp 2186 <br><br>  <b>Cuplikan no.</b>  <b>6: Menggunakan pointer setelah pindah</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ExtractBlocks(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; ProgClone = CloneModule(BD.getProgram(), VMap); .... BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= MiscompiledFunctions.clear(); for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) { Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first); // &lt;= assert(NewF &amp;&amp; "Function not found??"); MiscompiledFunctions.push_back(NewF); } .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V522 [CWE-476] Dereferencing dari null pointer 'ProgClone' mungkin terjadi.  Miscompilation.cpp 601 <br><br>  <i>ProgClone</i> pointer cerdas pertama melepaskan kepemilikan objek: <br><br><pre> <code class="cpp hljs">BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone));</code> </pre> <br>  Faktanya, <i>ProgClone</i> telah menjadi sebuah pointer nol - jadi, secara teknis, sebuah pointer null akan terdereferensi lebih jauh: <br><br><pre> <code class="cpp hljs">Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first);</code> </pre> <br>  Tetapi itu tidak akan terjadi!  Perhatikan bahwa loop tidak benar-benar dieksekusi sama sekali. <br><br>  Wadah <i>MiscompiledFunctions</i> pertama kali dihapus: <br><br><pre> <code class="cpp hljs">MiscompiledFunctions.clear();</code> </pre> <br>  Dan kemudian ukurannya digunakan dalam kondisi loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, e = MisCompFunctions.size(); i != e; ++i) {</code> </pre> <br>  Jelas, loop tidak akan dimulai.  Saya pikir itu bug juga, dan kode itu dimaksudkan untuk terlihat berbeda. <br><br>  Saya kira apa yang kita lihat di sini adalah parity error yang terkenal, di mana satu bug bertindak sebagai penyamaran untuk :) lainnya. <br><br>  <b>Cuplikan no.</b>  <b>7: Menggunakan pointer setelah pindah</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; TestOptimizer(BugDriver &amp;BD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Test, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Safe) { outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Optimizing functions being tested: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Optimized = BD.runPassesOn(Test.get(), BD.getPassesToRun()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Optimized) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error running this sequence of passes"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" on the input program!\n"</span></span>; BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Test)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= BD.EmitProgressBitcode(*Test, "pass-error", false); // &lt;= if (Error E = BD.debugOptimizerCrash()) return std::move(E); return false; } .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V522 [CWE-476] Dereferencing dari null pointer 'Test' mungkin terjadi.  Miscompilation.cpp 709 <br><br>  Yang ini mirip dengan kasus sebelumnya.  Isi objek pertama-tama dipindahkan dan kemudian digunakan seolah-olah tidak ada yang terjadi.  Kesalahan ini telah tumbuh semakin umum setelah pindahan semantik ditambahkan ke C ++.  Itulah yang saya sukai dari bahasa ini!  Anda diberi cara baru untuk menembak diri sendiri, yang berarti PVS-Studio akan selalu memiliki pekerjaan untuk dilakukan :). <br><br>  <b>Cuplikan no.</b>  <b>8: Null pointer</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FunctionDumper::dump(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDBSymbolTypeFunctionArg &amp;Symbol) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TypeId = Symbol.getTypeId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type = Symbol.getSession().getSymbolById(TypeId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Pesan diagnostik PVS-Studio: V522 [CWE-476] Dereferencing dari null pointer 'Type' mungkin terjadi.  PrettyFunctionDumper.cpp 233 <br><br>  Sama seperti penangan kesalahan, fungsi pengujian mencetak data debug biasanya tidak mendapatkan cakupan pengujian yang memadai, dan ini adalah salah satu contohnya.  Alih-alih membantu pengguna memecahkan masalah mereka, fungsi menunggu mereka untuk memperbaikinya. <br><br>  Kode tetap: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>;</code> </pre> <br>  <b>Cuplikan no.</b>  <b>9: Null pointer</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SearchableTableEmitter::collectTableEntries( GenericTable &amp;Table, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Record *&gt; &amp;Items) { .... RecTy *Ty = resolveTypes(Field.RecType, TI-&gt;getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Ty) <span class="hljs-comment"><span class="hljs-comment">// &lt;= PrintFatalError(Twine("Field '") + Field.Name + "' of table '" + Table.Name + "' has incompatible type: " + Ty-&gt;getAsString() + " vs. " + // &lt;= TI-&gt;getType()-&gt;getAsString()); .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V522 [CWE-476] Dereferencing dari null pointer 'Ty' mungkin terjadi.  SearchableTableEmitter.cpp 614 <br><br>  Saya tidak berpikir Anda perlu komentar yang satu ini. <br><br>  <b>Cuplikan no.</b>  <b>10: Typo</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FormatTokenLexer::tryMergeCSharpNullConditionals() { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Identifier = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Question = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... Identifier-&gt;ColumnWidth += Question-&gt;ColumnWidth; Identifier-&gt;Type = Identifier-&gt;Type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Tokens.erase(Tokens.end() - 1); return true; }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V570</a> Variabel 'Identifier-&gt; Type' ditugaskan untuk dirinya sendiri.  FormatTokenLexer.cpp 249 <br><br>  Menetapkan variabel untuk dirinya sendiri adalah operasi yang tidak berarti.  Programmer harus bermaksud untuk melakukan hal berikut: <br><br><pre> <code class="cpp hljs">Identifier-&gt;Type = Question-&gt;Type;</code> </pre> <br>  <b>Cuplikan no.</b>  <b>11: Istirahat yang mencurigakan</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SystemZOperand::print(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindToken: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Token:"</span></span> &lt;&lt; getToken(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindReg: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reg:"</span></span> &lt;&lt; SystemZInstPrinter::getRegisterName(getReg()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V622</a> [CWE-478] Pertimbangkan untuk memeriksa pernyataan 'switch'.  Mungkin saja operator 'case' pertama hilang.  SystemZAsmParser.cpp 652 <br><br>  Ada pernyataan <i>istirahat yang</i> sangat mencurigakan di awal.  Bukankah seharusnya ada hal lain di sini? <br><br>  <b>Cuplikan no.</b>  <b>12: Memeriksa pointer setelah dereferencing</b> <br><br><pre> <code class="cpp hljs">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) { Function *Callee = CS.getCalledFunction(); Function *Caller = CS.getCaller(); TargetTransformInfo &amp;TTI = TTIWP-&gt;getTTI(*Callee); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::InlineCost::getNever(<span class="hljs-string"><span class="hljs-string">"undefined callee"</span></span>); .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595</a> [CWE-476] Pointer 'Callee' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 172, 174. AMDGPUInline.cpp 172 <br><br>  Pointer <i>Callee</i> pertama kali <i>direferensikan</i> ketika fungsi <i>getTTI</i> dipanggil. <br><br>  Dan kemudian ternyata pointer harus diperiksa untuk <i>nullptr</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration())</code> </pre> <br>  Terlambat ... <br><br>  <b>Cuplikan no.</b>  <b>13 - Tidak ....: Memeriksa pointer setelah dereferencing</b> <br><br>  Contoh sebelumnya tidak unik.  Masalah yang sama ditemukan dalam cuplikan ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeDoubleFP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallInst *CI, IRBuilder&lt;&gt; &amp;B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isBinary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPrecise = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... Function *CalleeFn = CI-&gt;getCalledFunction(); StringRef CalleeNm = CalleeFn-&gt;getName(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= AttributeList CalleeAt = CalleeFn-&gt;getAttributes(); if (CalleeFn &amp;&amp; !CalleeFn-&gt;isIntrinsic()) { // &lt;= .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V595 [CWE-476] Pointer 'CalleeFn' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 1079, 1081. SederhanakanLibCalls.cpp 1079 <br><br>  Dan yang ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::InstantiateAttrs(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MultiLevelTemplateArgumentList &amp;TemplateArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Decl *Tmpl, Decl *New, LateInstantiatedAttrVec *LateAttrs, LocalInstantiationScope *OuterMostScope) { .... NamedDecl *ND = dyn_cast&lt;NamedDecl&gt;(New); CXXRecordDecl *ThisContext = dyn_cast_or_null&lt;CXXRecordDecl&gt;(ND-&gt;getDeclContext()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(), ND &amp;&amp; ND-&gt;isCXXInstanceMember()); // &lt;= .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V595 [CWE-476] Pointer 'ND' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 532, 534. SemaTemplateInstantiateDecl.cpp 532 <br><br>  Dan di sini: <br><br><ul><li>  V595 [CWE-476] Pointer 'U' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 404, 407. DWARFFormValue.cpp 404 </li><li>  V595 [CWE-476] Pointer 'ND' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 2149, 2151. SemaTemplateInstantiate.cpp 2149 </li></ul><br>  Lalu saya kehilangan minat untuk melacak peringatan V595, jadi saya tidak bisa memberi tahu Anda jika ada bug lain dari jenis ini selain yang ditunjukkan di atas.  Saya yakin ada. <br><br>  <b>Cuplikan no.</b>  <b>17, 18: Pergeseran mencurigakan</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLogicalImmediate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Imm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;Encoding)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Size = RegSize; .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V629</a> [CWE-190] Pertimbangkan untuk memeriksa ekspresi '~ (Ukuran - 1) &lt;&lt; 1'.  Pergeseran bit dari nilai 32-bit dengan ekspansi selanjutnya ke tipe 64-bit.  AArch64AddressingModes.h 260 <br><br>  Kode ini mungkin benar, tetapi terlihat aneh dan perlu diperiksa. <br><br>  Misalkan variabel <i>Ukuran</i> memiliki nilai 16;  maka variabel <i>NImms</i> diharapkan untuk mendapatkan nilai berikut: <br><br>  11111111111111111111111111111111111111111111111111111111111111100000000 <br><br>  Namun pada kenyataannya itu akan mendapatkan nilai: <br><br>  00000000000000000000000000000000000000111111111111111111111111111111000000 <br><br>  Ini terjadi karena semua perhitungan dilakukan pada tipe unsigned 32-bit, dan baru kemudian secara implisit dipromosikan ke <i>uint64_t</i> , dengan bit paling signifikan di- <i>zero</i> -out. <br><br>  Masalahnya dapat diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Bug lain dari jenis ini: V629 [CWE-190] Pertimbangkan untuk memeriksa ekspresi 'Immr &lt;&lt; 6'.  Pergeseran bit dari nilai 32-bit dengan ekspansi selanjutnya ke tipe 64-bit.  AArch64AddressingModes.h 269 <br><br>  <b>Cuplikan no.</b>  <b>19: Kata kunci</b> <b><i>lain tidak ada</i></b> <b>?</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OperandVector &amp;Operands) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) { <span class="hljs-comment"><span class="hljs-comment">// VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token. // Skip it. continue; } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) { // &lt;= Op.addRegWithFPInputModsOperands(Inst, 2); } else if (Op.isDPPCtrl()) { Op.addImmOperands(Inst, 1); } else if (Op.isImm()) { // Handle optional arguments OptionalIdx[Op.getImmTy()] = I; } else { llvm_unreachable("Invalid operand type"); } .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V646</a> [CWE-670] Pertimbangkan untuk memeriksa logika aplikasi.  Mungkin kata kunci 'lain' tidak ada.  AMDGPUAsmParser.cpp 5655 <br><br>  Yang ini bukan bug.  Karena <i>kemudian</i> blok pertama <i>jika</i> pernyataan diakhiri dengan <i>melanjutkan</i> , tidak masalah jika memiliki kata kunci <i>lain</i> atau tidak.  Perilaku akan sama dalam hal apa pun.  Namun, hal <i>lain yang</i> hilang membuat kode lebih mudah dibaca dan, karenanya, berpotensi berbahaya.  Jika <i>terus</i> menghilang suatu hari, perilaku itu akan berubah secara drastis.  Saya sangat menyarankan untuk menambahkan yang <i>lain</i> . <br><br>  <b>Cuplikan no.</b>  <b>20: Empat kesalahan ketik yang identik</b> <br><br><pre> <code class="cpp hljs">LLVM_DUMP_METHOD <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Symbol::dump(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUndefined()) Result += <span class="hljs-string"><span class="hljs-string">"(undef) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakDefined()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-def) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakReferenced()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-ref) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThreadLocalValue()) Result += <span class="hljs-string"><span class="hljs-string">"(tlv) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SymbolKind::GlobalSymbol: Result + Name.str(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case SymbolKind::ObjectiveCClass: Result + "(ObjC Class) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCClassEHType: Result + "(ObjC Class EH) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCInstanceVariable: Result + "(ObjC IVar) " + Name.str(); // &lt;= break; } OS &lt;&lt; Result; }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: <br><br><ul><li>  V655 [CWE-480] Senar digabungkan tetapi tidak digunakan.  Pertimbangkan untuk memeriksa ekspresi 'Hasil + Nama.str ()'.  Symbol.cpp 32 </li><li>  V655 [CWE-480] Senar digabungkan tetapi tidak digunakan.  Pertimbangkan untuk memeriksa ekspresi 'Hasil + "(Kelas ObjC)" + Name.str ()'.  Symbol.cpp 35 </li><li>  V655 [CWE-480] Senar digabungkan tetapi tidak digunakan.  Pertimbangkan untuk memeriksa ekspresi 'Hasil + "(ObjC Kelas EH)" + Name.str ()'.  Symbol.cpp 38 </li><li>  V655 [CWE-480] Senar digabungkan tetapi tidak digunakan.  Pertimbangkan untuk memeriksa ekspresi 'Hasil + "(ObjC IVar)" + Name.str ()'.  Symbol.cpp 41 </li></ul><br>  Programmer secara tidak sengaja menggunakan operator + bukannya + = dan berakhir dengan empat konstruksi yang tidak berarti. <br><br>  <b>Cuplikan no.</b>  <b>21: Perilaku yang tidak terdefinisi</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReqFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;StringRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;FeaturesMap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Record *&gt; &amp;ReqFeatures)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;R : ReqFeatures) { StringRef AsmCondString = R-&gt;getValueAsString(<span class="hljs-string"><span class="hljs-string">"AssemblerCondString"</span></span>); SmallVector&lt;StringRef, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Ops; SplitString(AsmCondString, Ops, <span class="hljs-string"><span class="hljs-string">","</span></span>); assert(!Ops.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"AssemblerCondString cannot be empty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Op : Ops) { assert(!Op.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Empty operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FeaturesMap.find(Op) == FeaturesMap.end()) FeaturesMap[Op] = FeaturesMap.size(); } } }</code> </pre> <br>  Cobalah untuk menemukan bug sendiri terlebih dahulu.  Saya menambahkan gambar sehingga Anda tidak mengintip jawabannya segera: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png" alt="???"></div><br><br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V708</a> [CWE-758] Konstruksi berbahaya digunakan: 'FeaturesMap [Op] = FeaturesMap.size ()', di mana 'FeaturesMap' adalah dari kelas 'map'.  Ini dapat menyebabkan perilaku yang tidak terdefinisi.  RISCVCompressInstEmitter.cpp 490 <br><br>  Baris yang salah adalah ini: <br><br><pre> <code class="cpp hljs">FeaturesMap[Op] = FeaturesMap.size();</code> </pre> <br>  Jika elemen <i>Op</i> belum ditemukan, program membuat elemen baru di peta dan menetapkannya jumlah total elemen di peta ini.  Anda tidak tahu apakah fungsi <i>ukuran</i> akan dipanggil sebelum atau setelah menambahkan elemen baru. <br><br>  <b>Cuplikan no.</b>  <b>22 - Tidak.</b>  <b>24: tugas rangkap</b> <br><br><pre> <code class="cpp hljs">Error MachOObjectFile::checkSymbolTable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MachO::nlist STE = getSymbolTableEntry(SymDRI); NType = STE.n_type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= NType = STE.n_type; // &lt;= NSect = STE.n_sect; NDesc = STE.n_desc; NStrx = STE.n_strx; NValue = STE.n_value; } .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V519</a> [CWE-563] Variabel 'NType' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 1663, 1664. MachOObjectFile.cpp 1664 <br><br>  Saya tidak berpikir itu adalah kesalahan sejati - bukan tugas duplikat.  Tapi itu masih cacat. <br><br>  Dua kasus lainnya: <br><br><ul><li>  V519 [CWE-563] Variabel 'B.NDesc' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 1488, 1489. llvm-nm.cpp 1489 </li><li>  V519 [CWE-563] Variabel diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 59, 61. coff2yaml.cpp 61 </li></ul><br>  <b>Cuplikan no.</b>  <b>25 - Tidak.</b>  <b>27: Lebih banyak tugas rangkap</b> <br><br>  Yang ini menangani versi tugas duplikat yang sedikit berbeda. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Vectorizer::vectorizeLoadChain( ArrayRef&lt;Instruction *&gt; Chain, SmallPtrSet&lt;Instruction *, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; *InstructionsProcessed) { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Alignment = getAlignment(L0); .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> NewAlign = getOrEnforceKnownAlignment(L0-&gt;getPointerOperand(), StackAdjustedAlignment, DL, L0, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, &amp;DT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NewAlign != <span class="hljs-number"><span class="hljs-number">0</span></span>) Alignment = NewAlign; Alignment = NewAlign; .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: V519 [CWE-563] Variabel 'Alignment' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 1158, 1160. LoadStoreVectorizer.cpp 1160 <br><br>  Ini adalah potongan yang sangat aneh, dan mungkin berisi kesalahan logika.  Variabel <i>Alignment</i> pertama kali diberi nilai berdasarkan kondisi, dan kemudian diberikan nilai sekali lagi, tetapi tanpa pemeriksaan sebelumnya. <br><br>  Cacat serupa: <br><br><ul><li>  V519 [CWE-563] Variabel 'Efek' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 152, 165. WebAssemblyRegStackify.cpp 165 </li><li>  V519 [CWE-563] Variabel 'ExpectNoDerefChunk' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 4970, 4973. SemaType.cpp 4973 </li></ul><br>  <b>Cuplikan no.</b>  <b>28: Kondisi selalu benar</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrefixes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct InternalInstruction* insn)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> nextByte; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte == <span class="hljs-number"><span class="hljs-number">0xf3</span></span> &amp;&amp; (nextByte == <span class="hljs-number"><span class="hljs-number">0x88</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0x89</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc6</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc7</span></span>)) { insn-&gt;xAcquireRelease = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextByte != <span class="hljs-number"><span class="hljs-number">0x90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PAUSE instruction support // &lt;= break; } .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> [CWE-571] Ekspresi 'nextByte! = 0x90' selalu benar.  X86DisassemblerDecoder.cpp 379 <br><br>  Cek itu tidak masuk akal.  Variabel <i>nextByte</i> tidak pernah sama dengan <i>0x90</i> : itu hanya secara logis mengikuti dari pemeriksaan sebelumnya.  Ini pasti kesalahan logika. <br><br>  <b>Cuplikan no.</b>  <b>29 - Tidak ....: Kondisi selalu benar / salah</b> <br><br>  Ada banyak peringatan tentang seluruh kondisi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> ) atau bagian dari suatu kondisi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V560</a> ) yang selalu benar atau salah.  Alih-alih bug asli, ini sering hanya kode buruk, efek ekspansi makro, dan sebagainya.  Yang mengatakan, semua peringatan seperti itu masih harus diperiksa karena beberapa dari mereka mungkin menunjukkan kesalahan logika asli.  Misalnya, cuplikan berikut tidak terlihat benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DecodeStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeGPRPairRegisterClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MCInst &amp;Inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Decoder)</span></span></span><span class="hljs-function"> </span></span>{ DecodeStatus S = MCDisassembler::Success; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RegNo &gt; <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCDisassembler::Fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((RegNo &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || RegNo == <span class="hljs-number"><span class="hljs-number">0xe</span></span>) S = MCDisassembler::SoftFail; .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V560</a> [CWE-570] Bagian dari ekspresi kondisional selalu salah: RegNo == 0xe.  ARMDisassembler.cpp 939 <br><br>  Konstanta <i>0xE</i> adalah angka desimal 14. Centang <i>RegNo == 0xe</i> tidak masuk akal karena jika <i>RegNo&gt; 13</i> , fungsi akan kembali. <br><br>  Saya melihat banyak peringatan V547 dan V560 lainnya, tetapi, seperti halnya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595</a> , saya tidak merasa bersemangat untuk memeriksanya karena saya sudah memiliki cukup bahan untuk artikel :).  Jadi, tidak ada angka untuk jumlah total bug jenis ini di LLVM. <br><br>  Berikut adalah contoh untuk mengilustrasikan mengapa memeriksa peringatan itu membosankan.  Penganalisa sepenuhnya benar ketika mengeluarkan peringatan pada kode berikut.  Tapi itu masih bukan bug. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> UnwrappedLineParser::parseBracedList(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ContinueOnSemicolons, tok::TokenKind ClosingBraceKind) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasError = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... HasError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ContinueOnSemicolons) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !HasError; .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: V547 [CWE-570] Ekspresi '! HasError' selalu salah.  UnwrappedLineParser.cpp 1635 <br><br>  <b>Cuplikan no.</b>  <b>30: Pengembalian yang mencurigakan</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isImplicitlyDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MachineRegisterInfo &amp;MRI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg), E = MRI.def_instr_end(); It != E; ++It) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*It).isImplicitDef(); } .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V612</a> [CWE-670] 'pengembalian' tanpa syarat dalam satu lingkaran.  R600OptimizeVectorRegisters.cpp 63 <br><br>  Entah itu bug atau teknik pengkodean khusus yang dimaksudkan untuk mengkomunikasikan beberapa ide kepada sesama programmer.  Bagi saya itu tidak mengatakan apa-apa kecuali bahwa itu adalah kode yang sangat mencurigakan.  Tolong jangan menulis kode seperti itu :). <br><br>  Merasa lelah?  OK, saatnya membuat teh atau kopi. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png" alt="kopi"></div><br><br><h2>  Kerusakan ditemukan oleh diagnostik baru </h2><br>  Saya pikir 30 contoh sudah cukup untuk diagnostik yang ada.  Sekarang mari kita lihat apakah kita dapat menemukan sesuatu yang menarik dengan diagnostik baru, yang ditambahkan setelah pemeriksaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> .  Selama dua tahun terakhir, modul penganalisa C ++ diperpanjang dengan 66 diagnostik baru. <br><br>  <b>Cuplikan no.</b>  <b>31: Kode tidak dapat dijangkau</b> <br><br><pre> <code class="cpp hljs">Error CtorDtorRunner::run() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CtorDtorMap = ES.lookup(JITDylibSearchList({{&amp;JD, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}}), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Names), NoDependenciesToRegister, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CtorDtorMap.takeError(); CtorDtorsByPriority.clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V779</a> [CWE-561] Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  ExecutionUtils.cpp 146 <br><br>  Seperti yang Anda lihat, kedua cabang pernyataan <i>if</i> diakhiri dengan pernyataan <i>pengembalian</i> , yang berarti wadah <i>CtorDtorsByPriority</i> tidak akan pernah dihapus. <br><br>  <b>Cuplikan no.</b>  <b>32: Kode tidak dapat dijangkau</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LLParser::ParseSummaryEntry() { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Lex.getKind()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_gv: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseGVEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_module: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseModuleEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_typeid: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; // &lt;= default: return Error(Lex.getLoc(), "unexpected summary kind"); } Lex.setIgnoreColonInIdentifiers(false); // &lt;= return false; }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V779 [CWE-561] Kode tidak terjangkau terdeteksi.  Mungkin saja ada kesalahan.  LLParser.cpp 835 <br><br>  Yang ini menarik.  Lihatlah bagian ini terlebih dahulu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  Tampaknya tidak ada yang aneh dengan kode ini;  pernyataan <i>istirahat</i> tidak perlu dan dapat dihapus dengan aman.  Tapi itu tidak sesederhana itu. <br><br>  Peringatan dipicu oleh baris berikut: <br><br><pre> <code class="cpp hljs">Lex.setIgnoreColonInIdentifiers(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Memang, kode ini tidak dapat dijangkau.  Semua label case dari pernyataan <i>switch</i> diakhiri dengan <i>return</i> , dan satu-satunya <i>break yang</i> tidak berarti tidak terlihat tidak berbahaya lagi!  Bagaimana jika salah satu cabang dimaksudkan untuk diakhiri dengan <i>istirahat</i> daripada <i>kembali</i> ? <br><br>  <b>Cuplikan no.</b>  <b>33: Kliring yang tidak disengaja dari bit yang paling signifikan</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStubAlignment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arch == Triple::systemz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; RuntimeDyldImpl::emitSection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectFile &amp;Obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SectionRef &amp;Section, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCode) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> DataSize = Section.getSize(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StubBufSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V784</a> Ukuran bit mask kurang dari ukuran operan pertama.  Ini akan menyebabkan hilangnya bit yang lebih tinggi.  RuntimeDyld.cpp 815 <br><br>  Perhatikan bahwa fungsi <i>getStubAlignment</i> mengembalikan nilai yang <i>tidak ditandatangani</i> .  Mari kita lihat bagaimana ekspresi akan mengevaluasi, dengan asumsi bahwa fungsi tersebut akan mengembalikan nilai 8: <br><br>  ~ (getStubAlignment () - 1) <br><br>  ~ (8u-1) <br><br>  0xFFFFFFF8u <br><br>  Perhatikan sekarang bahwa <i>tipe</i> variabel <i>DataSize</i> adalah 64-bit unsigned.  Jadi ternyata menjalankan operasi DataSize &amp; 0xFFFFFFF8 akan menghasilkan membersihkan semua 32 bit paling signifikan dari nilai.  Saya tidak berpikir programmer menginginkannya.  Mungkin mereka bermaksud untuk menjadi DataSize &amp; 0xFFFFFFFFFFFFFFFFFFF8u. <br><br>  Untuk memperbaiki kesalahan, kode harus ditulis ulang seperti ini: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(getStubAlignment()) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Atau seperti ini: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1U</span></span>LL);</code> </pre> <br>  <b>Cuplikan no.</b>  <b>34: Konversi tipe eksplisit yang buruk</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleShuffleMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scale, ArrayRef&lt;T&gt; Mask, SmallVectorImpl&lt;T&gt; &amp;ScaledMask)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; Scale &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Unexpected scaling factor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumElts = Mask.size(); ScaledMask.assign(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(NumElts * Scale), <span class="hljs-number"><span class="hljs-number">-1</span></span>); .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1028</a> [CWE-190] Kemungkinan meluap.  Pertimbangkan casting operan dari operator 'NumElts * Scale' ke tipe 'size_t', bukan hasilnya.  X86ISelLowering.h 1577 <br><br>  Konversi tipe eksplisit digunakan untuk menghindari overflow ketika mengalikan variabel tipe <i>int</i> .  Dalam kasus ini, meskipun, itu tidak berhasil karena perkalian akan terjadi terlebih dahulu dan hanya kemudian hasil 32-bit akan dipromosikan untuk mengetik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>size_t</i></a> . <br><br>  <b>Cuplikan no.</b>  <b>35: Copy-paste salah</b> <br><br><pre> <code class="cpp hljs">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return &amp;I; } .... }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V778</a> [CWE-682] Dua fragmen kode serupa ditemukan.  Mungkin, ini adalah kesalahan ketik dan variabel 'Op1' harus digunakan alih-alih 'Op0'.  InstCombineCompares.cpp 5507 <br><br>  Diagnostik keren baru ini mendeteksi situasi di mana sebuah fragmen kode ditulis menggunakan salin-tempel, dengan semua nama diubah kecuali satu. <br><br>  Perhatikan bahwa semua <i>Op0</i> kecuali satu diubah menjadi <i>Op1</i> di blok kedua.  Kode mungkin akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op1-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; }</code> </pre> <br>  <b>Cuplikan no.</b>  <b>36: Variabel tercampur</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1001</a> [CWE-563] Variabel 'Mode' ditugaskan tetapi tidak digunakan pada akhir fungsi.  SIModeRegister.cpp 48 <br><br>  Sangat berbahaya untuk memiliki nama yang sama untuk argumen fungsi seperti untuk anggota kelas karena Anda berisiko mencampurnya.  Apa yang Anda lihat di sini adalah contohnya.  Ungkapan berikut tidak ada artinya: <br><br><pre> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br>  Argumen diubah tetapi tidak pernah digunakan setelah itu.  Cuplikan ini mungkin terlihat seperti ini: <br><br><pre> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br>  <b>Cuplikan no.</b>  <b>37: Variabel tercampur</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionBase</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SymbolTableSection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SectionBase { .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SymbolTableSection::addSymbol(Twine Name, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Bind, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Type, SectionBase *DefinedIn, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Visibility, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Shndx, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size) { .... Sym.Value = Value; Sym.Visibility = Visibility; Sym.Size = Size; Sym.Index = Symbols.size(); Symbols.emplace_back(llvm::make_unique&lt;Symbol&gt;(Sym)); Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize; }</code> </pre> <br>  Pesan diagnostik PVS-Studio: V1001 [CWE-563] Variabel 'Ukuran' ditetapkan tetapi tidak digunakan pada akhir fungsi.  Object.cpp 424 <br><br>  Yang ini mirip dengan contoh sebelumnya.  Versi yang benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize;</code> </pre> <br>  <b>Cuplikan no.</b>  <b>38 - Tidak.</b>  <b>47: Cek pointer tidak ada</b> <br><br>  Kami melihat beberapa contoh peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595</a> sedikit lebih awal.  Apa yang dideteksi adalah situasi ketika pointer pertama kali direferensikan dan hanya kemudian diperiksa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1004</a> diagnostik baru adalah kebalikan dari itu, dan mendeteksi banyak kesalahan juga.  Tampaknya pointer sudah diuji yang tidak diuji lagi saat diperlukan.  Berikut adalah beberapa kesalahan jenis ini yang ditemukan dalam kode LLVM. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGEPCost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type *PointeeType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *Ptr, ArrayRef&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *&gt; Operands)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert(....); BaseGV = dyn_cast&lt;GlobalValue&gt;(Ptr-&gt;stripPointerCasts()); } bool HasBaseReg = (BaseGV == nullptr); auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType()); // &lt;= .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V1004 [CWE-476] Pointer 'Ptr' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 729, 738. TargetTransformInfoImpl.h 738 <br><br>  <i>Ptr</i> dapat berupa <i>nullptr</i> , yang ditunjukkan dengan tanda centang: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br>  Namun, penunjuk yang sama didereferensi tanpa pemeriksaan lebih jauh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType());</code> </pre> <br>  Kasus serupa lainnya. <br><br><pre> <code class="cpp hljs">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Stub) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *FD = dyn_cast&lt;FunctionDecl&gt;(GD.getDecl()); SmallVector&lt;QualType, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; ArgTypes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FD) <span class="hljs-comment"><span class="hljs-comment">// &lt;= for (const ParmVarDecl *Parm : FD-&gt;parameters()) ArgTypes.push_back(Parm-&gt;getType()); CallingConv CC = FD-&gt;getType()-&gt;castAs&lt;FunctionType&gt;()-&gt;getCallConv(); // &lt;= .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V1004 [CWE-476] Pointer 'FD' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 3228, 3231. CGDebugInfo.cpp 3231 <br><br>  Perhatikan penunjuk <i>FD</i> .  Kesalahan ini sangat mudah, jadi tidak ada komentar untuk ini. <br><br>  Satu lagi di sini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computePolynomialFromPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value &amp;Ptr, Polynomial &amp;Result, Value *&amp;BasePtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL)</span></span></span><span class="hljs-function"> </span></span>{ PointerType *PtrTy = dyn_cast&lt;PointerType&gt;(Ptr.getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PtrTy) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Result = Polynomial(); BasePtr = nullptr; } unsigned PointerBits = DL.getIndexSizeInBits(PtrTy-&gt;getPointerAddressSpace()); // &lt;= .... }</span></span></code> </pre> <br>  Pesan diagnostik PVS-Studio: V1004 [CWE-476] Pointer 'PtrTy' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 960, 965. InterleavedLoadCombinePass.cpp 965 <br><br>  Bagaimana Anda menghindari kesalahan seperti itu?  Berhati-hatilah saat meninjau kode Anda dan periksa secara teratur dengan PVS-Studio. <br><br>  Saya tidak berpikir kita harus memeriksa contoh-contoh lain dari jenis ini, jadi di sini hanya daftar peringatan: <br><ul><li>  V1004 [CWE-476] Pointer 'Expr' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 1049, 1078. DebugInfoMetadata.cpp 1078 </li><li>  V1004 [CWE-476] Pointer 'PI' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 733, 753. LegacyPassManager.cpp 753 </li><li>  V1004 [CWE-476] Pointer 'StatepointCall' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 4371, 4379. Verifier.cpp 4379 </li><li>  V1004 [CWE-476] Pointer 'RV' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 2263, 2268. TGParser.cpp 2268 </li><li>  V1004 [CWE-476] Pointer 'CalleeFn' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 1081, 1096. SederhanakanLibCalls.cpp 1096 </li><li>  V1004 [CWE-476] Pointer 'TC' digunakan secara tidak aman setelah diverifikasi terhadap nullptr.  Periksa baris: 1819, 1824. Driver.cpp 1824 </li></ul><br>  <b>Cuplikan no.</b>  <b>48 - Tidak.</b>  <b>60: Tidak kritis tetapi masih cacat (potensi kebocoran memori)</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutator&gt; createISelMutator() { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutationStrategy&gt;&gt; Strategies; Strategies.emplace_back( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectorIRStrategy(InjectorIRStrategy::getDefaultOps())); .... }</code> </pre> <br>  Pesan diagnostik PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1023</a> [CWE-460] Pointer tanpa pemilik ditambahkan ke wadah 'Strategi' dengan metode 'emplace_back'.  Kebocoran memori akan terjadi jika ada pengecualian.  llvm-isel-fuzzer.cpp 58 <br><br>  Anda tidak bisa hanya menulis <i>xxx.push_back (X baru)</i> untuk menambahkan elemen ke wadah tipe <i>std :: vector &lt;std :: unique_ptr &lt;X&gt;&gt;</i> karena tidak ada pemeran implisit dari <i>X *</i> ke <i>std :: unique_ptr &lt; X&gt;</i> . <br><br>  Solusi populer adalah menulis <i>xxx.emplace_back (X baru)</i> karena dapat dikompilasi: metode <i>emplace_back</i> membangun elemen langsung dari argumen dan, oleh karena itu, dapat menggunakan konstruktor eksplisit. <br><br>  Tetapi solusi itu tidak aman.  Jika vektor penuh, memori akan dialokasikan kembali.  Operasi ini mungkin gagal dan akhirnya meningkatkan <i>std :: bad_alloc</i> exception.  Dalam hal ini, pointer akan hilang dan program tidak akan dapat menghapus objek yang dibuat. <br><br>  Solusi yang lebih aman adalah membuat <i>unique_ptr</i> , yang akan mempertahankan pointer hingga vektor mencoba mengalokasikan kembali memori: <br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X))</code> </pre> <br>  Standar C ++ 14 memungkinkan Anda untuk menggunakan 'std :: make_unique': <br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;X&gt;())</code> </pre> <br>  Jenis cacat ini tidak berpengaruh pada LLVM.  Kompilasi hanya akan berakhir jika alokasi memori gagal.  Yang mengatakan, itu mungkin sangat penting dalam aplikasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uptime yang</a> lama, yang tidak bisa berakhir begitu saja ketika terjadi kegagalan alokasi memori. <br><br>  Jadi, meskipun kode ini tidak berbahaya bagi LLVM, saya pikir saya masih harus memberi tahu Anda tentang pola bug ini dan fakta bahwa PVS-Studio sekarang dapat mendeteksinya. <br><br>  Kasus serupa lainnya: <br><br><ul><li>  V1023 [CWE-460] Pointer tanpa pemilik ditambahkan ke wadah 'Lulus' dengan metode 'emplace_back'.  Kebocoran memori akan terjadi jika ada pengecualian.  PassManager.h 546 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702 </li></ul><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menuliskan 60 peringatan dan berhenti di situ. </font><font style="vertical-align: inherit;">Apakah PVS-Studio menemukan bug lain di LLVM? </font><font style="vertical-align: inherit;">Ya, benar. </font><font style="vertical-align: inherit;">Tetapi ketika saya menuliskan contoh-contohnya, malam tiba, jadi saya memutuskan untuk menyerah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap Anda menikmati membaca artikel ini dan mendorong Anda untuk mencoba alat analisa PVS-Studio untuk diri Anda sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kunjungi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">halaman ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mengunduh penganalisa dan mendapatkan kunci percobaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang paling penting, gunakan analisis statis secara teratur. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemeriksaan satu kali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seperti yang kami lakukan untuk mempopulerkan analisis statis dan mempromosikan PVS-Studio, bukan skenario normal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semoga berhasil dengan meningkatkan kualitas dan keandalan kode Anda!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450002/">https://habr.com/ru/post/id450002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449992/index.html">Showcase model driver sederhana (SDM) NodeMCU: antarmuka pengguna yang dinamis</a></li>
<li><a href="../id449994/index.html">Delapan aturan emas Schneiderman akan membantu Anda membuat antarmuka yang lebih baik</a></li>
<li><a href="../id449996/index.html">Memahami Algoritma FFT</a></li>
<li><a href="../id449998/index.html">FAQ: apa yang perlu diketahui oleh seorang pelancong tentang vaksinasi sebelum bepergian</a></li>
<li><a href="../id450000/index.html">(Kanan ke kiri (Melalui Kaca Mencari</a></li>
<li><a href="../id450004/index.html">Fast C / C ++ Cache, Thread Safety</a></li>
<li><a href="../id450006/index.html">Pendinginan pusat data chiller: pendingin mana yang harus dipilih?</a></li>
<li><a href="../id450008/index.html">Temukan bug di LLVM 8 menggunakan penganalisa PVS-Studio</a></li>
<li><a href="../id450010/index.html">Penyimpanan, cadangan, dan katalogisasi foto</a></li>
<li><a href="../id450016/index.html">Pembuatan sistem verifikasi formal dari awal. Bagian 1: mesin virtual karakter dalam PHP dan Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>