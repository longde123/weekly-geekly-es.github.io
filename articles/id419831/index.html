<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔲 🔇 🔊 Cara Kerja JS: Elemen Kustom 🖋️ ▫️ 🌃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Nasihat membaca] 19 bagian siklus lainnya  Bagian 1: Tinjauan umum mesin, mekanisme runtime, panggilan stack 
 Bagian 2: Tentang V8 internal dan opti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara Kerja JS: Elemen Kustom</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419831/"><div class="spoiler">  <b class="spoiler_title">[Nasihat membaca] 19 bagian siklus lainnya</b> <div class="spoiler_text">  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinjauan umum mesin, mekanisme runtime, panggilan stack</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang V8 internal dan optimasi kode</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengelola memori, empat jenis memori bocor dan berurusan dengannya</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Event Loop, Async, dan Five Ways untuk Meningkatkan Kode Anda dengan async / menunggu</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSocket dan HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang harus dipilih?</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur dan ruang lingkup WebAssembly</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Web dan Lima Skenario Penggunaan</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Layanan</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemberitahuan push web</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lacak perubahan di DOM dengan MutationObserver</a> <br>  Bagian 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin rendering halaman web dan tip untuk mengoptimalkan kinerja mereka</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Animasi dengan CSS dan JavaScript</a> <br>  Bagian 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Pohon Sintaks Abstrak, Parsing dan Optimalisasi nya</a> <br>  Bagian 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara kerja JS: kelas dan warisan, transpilasi dalam Babel dan TypeScript</a> <br>  Bagian 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Penyimpanan</a> <br>  Bagian 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Shadow DOM Technology dan Komponen Web</a> <br>  Bagian 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Mekanisme Komunikasi WebRTC dan P2P</a> <br>  Bagian 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Elemen Kustom</a> </div></div><br>  Kami sajikan kepada Anda terjemahan dari 19 artikel dari seri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SessionStack</a> tentang fitur berbagai mekanisme ekosistem JavaScript.  Hari ini kita akan berbicara tentang standar Elemen Kustom - yang disebut "elemen kustom".  Kami akan berbicara tentang tugas apa yang mereka biarkan selesaikan, dan bagaimana membuat dan menggunakannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/188/85f/00e18885fa38229e7bc5cc7c4489147c.png" alt="gambar"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ulasan</font> </h2><br>  Dalam salah satu artikel sebelumnya dalam seri ini, kami berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shadow DOM</a> dan beberapa teknologi lain yang merupakan bagian dari fenomena yang lebih besar - komponen web.  Komponen web dirancang untuk memungkinkan pengembang memperluas fitur standar HTML dengan membuat elemen yang ringkas, modular, dan dapat digunakan kembali.  Ini adalah standar W3C yang relatif baru yang telah diperhatikan oleh produsen dari semua browser terkemuka.  Dia dapat ditemukan dalam produksi, meskipun, tentu saja, sementara karyanya disediakan oleh polifil (kita akan membicarakannya nanti). <br><br>  Seperti yang mungkin sudah Anda ketahui, browser memberi kami beberapa alat penting untuk mengembangkan situs web dan aplikasi web.  Ini tentang HTML, CSS, dan JavaScript.  HTML digunakan untuk membuat struktur halaman web, berkat CSS, tampilannya bagus, dan JavaScript bertanggung jawab untuk fitur-fitur interaktif.  Namun, sebelum kemunculan komponen web, tidak mudah untuk mengaitkan tindakan yang diimplementasikan JavaScript dengan struktur HTML. <br><br>  Faktanya, di sini kami akan mempertimbangkan dasar komponen web - Elemen Kustom.  Singkatnya, API yang dirancang untuk bekerja dengannya memungkinkan pemrogram untuk membuat elemen HTML mereka sendiri dengan logika dan gaya JavaScript bawaan yang dijelaskan oleh CSS.  Banyak elemen kustom yang membingungkan dengan teknologi Shadow DOM.  Namun, ini adalah dua hal yang sangat berbeda yang, pada kenyataannya, saling melengkapi, tetapi tidak dapat dipertukarkan. <br><br>  Beberapa kerangka kerja (seperti Angular atau Bereaksi) mencoba memecahkan masalah yang sama yang elemen kustom pecahkan dengan memperkenalkan konsep mereka sendiri.  Elemen khusus dapat dibandingkan dengan arahan sudut atau dengan komponen Bereaksi.  Namun, elemen khusus adalah fitur standar browser, Anda tidak perlu menggunakan apa pun selain JavaScript, HTML, dan CSS biasa untuk menggunakannya.  Tentu saja, ini tidak memungkinkan kita untuk mengatakan bahwa mereka adalah pengganti kerangka kerja JS biasa.  Kerangka kerja modern memberi kita lebih dari sekadar kemampuan untuk mensimulasikan perilaku elemen kustom.  Sebagai hasilnya, kita dapat mengatakan bahwa kerangka kerja dan elemen pengguna adalah teknologi yang dapat digunakan bersama untuk menyelesaikan tugas pengembangan web. <br><br><h2>  <font color="#3AC1EF">API</font> </h2><br>  Sebelum kita melanjutkan, mari kita lihat peluang apa yang diberikan API untuk bekerja dengan elemen khusus.  Yaitu, kita berbicara tentang objek <code>customElements</code> global yang memiliki beberapa metode: <br><br><ul><li>  Metode <code>define(tagName, constructor, options)</code> memungkinkan Anda untuk mendefinisikan (membuat, mendaftar) elemen pengguna baru.  Dibutuhkan tiga argumen - nama tag untuk elemen pengguna, sesuai dengan aturan penamaan untuk elemen tersebut, deklarasi kelas, dan objek dengan parameter.  Saat ini, hanya satu parameter yang didukung - <code>extends</code> , yang merupakan string yang menentukan nama elemen inline yang akan diperluas.  Fitur ini digunakan untuk membuat versi khusus dari elemen standar. </li><li>  Metode <code>get(tagName)</code> mengembalikan konstruktor dari elemen pengguna, asalkan elemen ini sudah didefinisikan, jika tidak maka pengembaliannya <code>undefined</code> .  Dibutuhkan satu argumen - tag nama elemen pengguna. </li><li>  Metode <code>whenDefined(tagName)</code> mengembalikan janji yang diselesaikan setelah elemen pengguna dibuat.  Jika suatu elemen sudah ditentukan, janji ini segera diselesaikan.  Janji ditolak jika nama tag yang diteruskan bukan nama tag yang valid untuk elemen pengguna.  Metode ini menerima nama tag elemen pengguna. </li></ul><br><h2>  <font color="#3AC1EF">Buat item khusus</font> </h2><br>  Membuat elemen khusus sangat sederhana.  Untuk melakukan ini, dua hal harus dilakukan: membuat deklarasi kelas untuk elemen yang harus memperluas kelas <code>HTMLElement</code> dan mendaftarkan elemen ini di bawah nama yang dipilih.  Begini tampilannya: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// … } // … } customElements.define('my-custom-element', MyCustomElement);</span></span></code> </pre> <br>  Jika Anda tidak ingin mencemari ruang lingkup saat ini, Anda dapat menggunakan kelas anonim: <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// … } // … });</span></span></code> </pre> <br>  Seperti yang Anda lihat dari contoh, elemen pengguna terdaftar menggunakan metode <code>customElements.define(...)</code> sudah Anda kenal. <br><br><h2>  <font color="#3AC1EF">Masalah yang diselesaikan elemen khusus</font> </h2><br>  Mari kita bicara tentang masalah yang memungkinkan kita untuk menyelesaikan elemen khusus.  Salah satunya adalah memperbaiki struktur kode dan menghilangkan apa yang disebut "sup tag div" (sup sup).  Fenomena ini adalah struktur kode yang sangat umum dalam aplikasi web modern, di mana ada banyak elemen <code>div</code> melekat.  Begini tampilannya: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-container"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"middle-container"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-container"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-inside-container"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"are-we-really-doing-this"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"mariana-trench"</span></span>&gt;           …         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Kode HTML semacam itu digunakan untuk alasan yang dapat dibenarkan - kode ini menggambarkan tata letak halaman dan memastikan tampilan yang benar di layar.  Namun, ini merusak pembacaan kode HTML dan mempersulit pemeliharaannya. <br><br>  Misalkan kita memiliki komponen yang terlihat seperti gambar berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85a/949/ef6/85a949ef606dd68521cd83fd845d09ba.png"></div><br>  <i><font color="#999999">Penampilan komponen</font></i> <br><br>  Menggunakan pendekatan tradisional untuk menggambarkan hal-hal seperti itu, kode berikut akan sesuai dengan komponen ini: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"primary-toolbar toolbar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-undo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-redo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-print"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-toggle-button toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-paint-format"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Sekarang bayangkan kita bisa, alih-alih kode ini, menggunakan deskripsi komponen ini: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-undo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-redo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-print"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-paint-format"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Saya yakin semua orang akan setuju bahwa fragmen kode kedua terlihat jauh lebih baik.  Kode semacam itu lebih mudah dibaca, lebih mudah dipelihara, dan dapat dipahami oleh pengembang dan peramban.  Itu semua bermuara pada fakta bahwa itu lebih sederhana daripada yang ada di mana banyak tag <code>div</code> bersarang. <br><br>  Masalah selanjutnya yang dapat diselesaikan dengan elemen kustom adalah penggunaan kembali kode.  Kode yang ditulis pengembang tidak hanya berfungsi, tetapi juga didukung.  Menggunakan kembali kode, sebagai lawan untuk terus-menerus menulis konstruksi yang sama, meningkatkan kemampuan dukungan proyek. <br>  Berikut adalah contoh sederhana yang akan membantu Anda lebih memahami ide ini.  Misalkan kita memiliki elemen berikut: <br><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt; &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt;</code> </pre> <br>  Jika Anda terus-menerus membutuhkannya, maka, dengan pendekatan yang biasa, kami harus menulis kode HTML yang sama berulang kali.  Sekarang bayangkan Anda perlu membuat perubahan pada kode ini yang harus tercermin di mana pun ia digunakan.  Ini berarti bahwa kita perlu menemukan semua tempat di mana fragmen ini digunakan, dan kemudian membuat perubahan yang sama di mana-mana.  Itu panjang, keras dan penuh dengan kesalahan. <br><br>  Akan jauh lebih baik jika kita bisa di mana elemen ini diperlukan, cukup tulis yang berikut ini: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;&lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  Namun, aplikasi web modern lebih dari sekadar HTML statis.  Mereka interaktif.  Sumber interaktivitas mereka adalah JavaScript.  Biasanya, untuk memberikan kemampuan seperti itu, beberapa elemen dibuat, kemudian pendengar acara terhubung dengannya, yang memungkinkan mereka untuk menanggapi pengaruh pengguna.  Misalnya, mereka dapat merespons klik, “melayang” dari penunjuk tetikus di atasnya, menyeretnya ke layar, dan sebagainya.  Berikut cara menghubungkan pendengar acara ke elemen yang terjadi saat Anda mengkliknya dengan mouse: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.my-custom-element'</span></span>); myDiv.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, _ =&gt; { myDiv.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span></span>; });</code> </pre> <br>  Dan di sini adalah kode HTML untuk elemen ini: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; I have not been clicked yet. &lt;/div&gt;</code> </pre> <br>  Dengan menggunakan API untuk bekerja dengan elemen kustom, semua logika ini dapat dimasukkan dalam elemen itu sendiri.  Sebagai perbandingan - di bawah ini adalah kode untuk mendeklarasikan elemen kustom yang mencakup pengendali event: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;   self.addEventListener(<span class="hljs-symbol"><span class="hljs-symbol">'clic</span></span>k', _ =&gt; {     self.innerHTML = '&lt;b&gt; <span class="hljs-type"><span class="hljs-type">I</span></span> have been clicked &lt;/b&gt;';   }); } } customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-type"><span class="hljs-type">MyCustomElement</span></span>);</code> </pre> <br>  Dan di sini adalah tampilannya di kode HTML halaman: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt; I have not been clicked yet &lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  Pada pandangan pertama, sepertinya lebih banyak baris kode JS diperlukan untuk membuat elemen kustom.  Namun, dalam aplikasi dunia nyata, jarang terjadi bahwa elemen tersebut dibuat hanya untuk digunakan hanya sekali.  Fenomena khas lain dalam aplikasi web modern adalah sebagian besar elemen di dalamnya dibuat secara dinamis.  Ini mengarah pada kebutuhan untuk mendukung dua skenario yang berbeda dalam bekerja dengan elemen - situasi ketika mereka ditambahkan ke halaman secara dinamis menggunakan JavaScript, dan situasi ketika mereka dijelaskan dalam struktur HTML asli halaman.  Berkat penggunaan elemen khusus, pekerjaan dalam dua situasi ini disederhanakan. <br><br>  Akibatnya, jika kami merangkum hasil bagian ini, kami dapat mengatakan bahwa elemen pengguna membuat kode lebih jelas, menyederhanakan dukungannya, membantu memecahnya menjadi modul-modul kecil, yang mencakup semua fungsi yang diperlukan dan cocok untuk digunakan kembali. <br><br>  Sekarang kita telah membahas masalah umum bekerja dengan elemen khusus, mari kita bicara tentang fitur-fiturnya. <br><br><h2>  <font color="#3AC1EF">Persyaratan</font> </h2><br>  Sebelum Anda mulai mengembangkan elemen kustom Anda sendiri, Anda harus tahu tentang beberapa aturan yang harus Anda ikuti saat membuatnya.  Inilah mereka: <br><br><ul><li>  Nama komponen harus menyertakan tanda hubung ( <code>-</code> simbol).  Berkat ini, parser HTML dapat membedakan antara elemen yang disematkan dan pengguna.  Selain itu, pendekatan ini memastikan bahwa tidak ada tabrakan nama dengan elemen bawaan (baik dengan yang ada sekarang maupun yang muncul di masa depan).  Misalnya, nama sebenarnya dari elemen kustom adalah <code>&gt;my-custom-element&lt;</code> elemen <code>&gt;my-custom-element&lt;</code> , dan nama-nama <code>&gt;myCustomElement&lt;</code> dan <code>&lt;my_custom_element&gt;</code> tidak cocok. </li><li>  Dilarang mendaftarkan tag yang sama lebih dari satu kali.  Mencoba melakukan ini akan menyebabkan browser <code>DOMException</code> kesalahan <code>DOMException</code> .  Elemen khusus tidak dapat didefinisikan ulang. </li><li>  Tag khusus tidak dapat ditutup sendiri.  Pengurai HTML hanya mendukung serangkaian tag penutup otomatis standar terbatas (misalnya, <code>&lt;img&gt;</code> , <code>&lt;link&gt;</code> , <code>&lt;br&gt;</code> ). </li></ul><br><h2>  <font color="#3AC1EF">Kemungkinan</font> </h2><br>  Mari kita bicara tentang apa yang dapat Anda lakukan dengan elemen khusus.  Jika Anda menjawab pertanyaan ini secara singkat, ternyata Anda dapat melakukan banyak hal menarik dengannya. <br><br>  Salah satu fitur yang paling menonjol dari elemen kustom adalah bahwa deklarasi kelas elemen merujuk ke elemen DOM itu sendiri.  Ini berarti Anda dapat menggunakan kata kunci ini dalam iklan untuk menghubungkan pendengar acara, untuk mengakses properti, ke simpul anak, dan sebagainya. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   this.addEventListener('mouseover', _ =&gt; {     console.log('I have been hovered');   }); } // ... }</span></span></code> </pre> <br>  Ini, tentu saja, memungkinkan untuk menulis data baru ke simpul anak elemen.  Namun, melakukan ini tidak disarankan, karena ini dapat menyebabkan perilaku elemen yang tidak terduga.  Jika Anda membayangkan bahwa Anda menggunakan elemen yang dirancang oleh orang lain, maka Anda mungkin akan terkejut jika markup Anda sendiri yang ditempatkan di elemen diganti dengan sesuatu yang lain. <br><br>  Ada beberapa metode yang memungkinkan Anda untuk mengeksekusi kode pada titik-titik tertentu dalam siklus hidup suatu elemen. <br><br><ul><li>  Metode <code>constructor</code> dipanggil sekali, ketika membuat atau "meningkatkan" elemen (kita akan membicarakan ini di bawah).  Paling sering digunakan untuk menginisialisasi keadaan elemen, untuk menghubungkan pendengar acara, membuat Shadow DOM, dan sebagainya.  Jangan lupa bahwa Anda selalu perlu memanggil <code>super()</code> di konstruktor. </li><li>  Metode <code>connectedCallback</code> dipanggil setiap kali elemen ditambahkan ke DOM.  Itu dapat digunakan (dan ini adalah persis cara yang disarankan untuk menggunakannya) untuk menunda pelaksanaan tindakan apa pun hingga saat elemen muncul di halaman (misalnya, dengan cara ini Anda dapat menunda pemuatan beberapa data). </li><li>  Metode <code>disconnectedCallback</code> dipanggil ketika item dihapus dari DOM.  Biasanya digunakan untuk membebaskan sumber daya.  Perhatikan bahwa metode ini tidak dipanggil jika pengguna menutup tab browser dengan halaman.  Karena itu, jangan bergantung padanya ketika diperlukan untuk melakukan beberapa tindakan yang sangat penting. </li><li>  Metode <code>attributeChangedCallback</code> dipanggil ketika <code>attributeChangedCallback</code> elemen ditambahkan, dihapus, diperbarui, atau diganti.  Selain itu, ini disebut ketika elemen dibuat oleh pengurai.  Namun, perhatikan bahwa metode ini hanya berlaku untuk atribut yang terdaftar di properti yang <code>observedAttributes</code> . </li><li>  Metode <code>adoptedCallback</code> dipanggil ketika metode <code>document.adoptNode(...)</code> digunakan, yang digunakan untuk memindahkan node ke dokumen lain. </li></ul><br>  Harap dicatat bahwa semua metode di atas sinkron.  Misalnya, metode <code>connectedCallback</code> panggilan dipanggil segera setelah elemen ditambahkan ke DOM, dan sisa program menunggu penyelesaian metode ini. <br><br><h2>  <font color="#3AC1EF">Refleksi Properti</font> </h2><br>  Elemen HTML tertanam memiliki satu fitur yang sangat nyaman: refleksi properti.  Berkat mekanisme ini, nilai beberapa properti secara langsung tercermin dalam DOM sebagai atribut.  Katakanlah ini adalah karakteristik dari properti <code>id</code> .  Sebagai contoh, kami melakukan operasi berikut: <br><br><pre> <code class="hljs cs">myDiv.id = <span class="hljs-string"><span class="hljs-string">'new-id'</span></span>;</code> </pre> <br>  Perubahan yang relevan akan memengaruhi DOM: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"new-id"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Mekanisme ini beroperasi dalam arah yang berlawanan.  Ini sangat berguna karena memungkinkan Anda untuk mengkonfigurasi elemen deklaratif. <br><br>  Elemen khusus tidak memiliki fitur bawaan ini, tetapi Anda dapat menerapkannya sendiri.  Agar beberapa properti elemen pengguna memiliki perilaku yang sama, Anda dapat mengonfigurasi getter dan setter mereka. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... get myProperty() {   return this.hasAttribute('my-property'); } set myProperty(newValue) {   if (newValue) {     this.setAttribute('my-property', newValue);   } else {     this.removeAttribute('my-property');   } } // ... }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Memperluas item yang ada</font> </h2><br>  API elemen khusus memungkinkan Anda tidak hanya membuat elemen HTML baru, tetapi juga memperluas elemen yang sudah ada.  Selain itu, kita berbicara tentang elemen standar dan elemen kustom.  Ini dilakukan dengan menggunakan <code>extends</code> ketika mendeklarasikan sebuah kelas: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAwesomeButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyButton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } customElements.define('my-awesome-button', MyAwesomeButton);&lt;/cosourcede&gt;      ,  , ,    &lt;code&gt;customElements.define(...)&lt;/code&gt;,    &lt;code&gt;extends&lt;/code&gt;   ,      .     ,        ,        DOM-.   ,          ,      ,       . &lt;source&gt;class MyButton extends HTMLButtonElement { // ... } customElements.define('my-button', MyButton, {extends: 'button'});</span></span></code> </pre> <br>  Elemen standar yang diperluas juga disebut "elemen bawaan yang dapat disesuaikan". <br><br>  Disarankan untuk membuat aturan untuk selalu memperluas elemen yang ada, dan melakukannya secara progresif.  Ini akan memungkinkan Anda untuk menyimpan dalam elemen baru kemampuan yang diimplementasikan dalam elemen yang dibuat sebelumnya (yaitu, properti, atribut, fungsi). <br><br>  Harap perhatikan bahwa sekarang elemen bawaan khusus hanya didukung di Chrome 67+.  Ini akan muncul di browser lain, namun, diketahui bahwa pengembang Safari memutuskan untuk tidak menerapkan kesempatan ini. <br><br><h2>  <font color="#3AC1EF">Perbarui Item</font> </h2><br>  Seperti yang telah disebutkan, metode <code>customElements.define(...)</code> digunakan untuk mendaftarkan elemen kustom.  Namun, pendaftaran tidak dapat disebut tindakan yang harus dilakukan sejak awal.  Registrasi elemen pengguna dapat ditunda untuk sementara waktu, apalagi, kali ini mungkin datang bahkan ketika elemen sudah ditambahkan ke DOM.  Proses ini disebut pemutakhiran.  Untuk mengetahui kapan suatu barang akan didaftarkan, peramban menyediakan metode <code>customElements.whenDefined(...)</code> .  Dia diberi nama tag elemen, dan dia mengembalikan janji yang diselesaikan setelah pendaftaran elemen. <br><br><pre> <code class="hljs javascript">customElements.whenDefined(<span class="hljs-string"><span class="hljs-string">'my-custom-element'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'My custom element is defined'</span></span>); });</code> </pre> <br>  Misalnya, Anda mungkin perlu menunda pendaftaran suatu elemen hingga anak-anaknya diumumkan.  Perilaku seperti itu bisa sangat berguna jika proyek memiliki elemen pengguna bersarang.  Terkadang orangtua dapat mengandalkan implementasi elemen anak.  Dalam hal ini, Anda perlu memastikan bahwa anak-anak terdaftar sebelum orang tua. <br><br><h2>  <font color="#3AC1EF">Dom bayangan</font> </h2><br>  Seperti yang telah disebutkan, elemen khusus dan Shadow DOM adalah teknologi pelengkap.  Yang pertama memungkinkan Anda untuk merangkum logika JS di elemen pengguna, dan yang kedua memungkinkan Anda untuk membuat lingkungan terisolasi untuk fragmen DOM yang tidak terpengaruh oleh apa yang ada di luar mereka.  Jika Anda merasa perlu lebih memahami konsep Shadow DOM, lihat salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> . <br><br>  Berikut cara menggunakan Shadow DOM untuk elemen khusus: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   let elementContent = document.createElement('div');   shadowRoot.appendChild(elementContent); } // ... });</span></span></code> </pre> <br>  Seperti yang Anda lihat, memanggil <code>this.attachShadow</code> memainkan peran penting di <code>this.attachShadow</code> . <br><br><h2>  <font color="#3AC1EF">Pola</font> </h2><br>  Dalam salah satu artikel kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> , kami berbicara sedikit tentang templat, meskipun sebenarnya layak untuk artikel terpisah.  Di sini kita akan melihat contoh sederhana tentang cara menyematkan templat di elemen khusus saat dibuat.  Jadi, menggunakan <code>&lt;template&gt;</code> , Anda dapat menjelaskan fragmen DOM yang akan diproses oleh parser, tetapi tidak akan ditampilkan pada halaman: <br><br><pre> <code class="hljs scala">&lt;template id=<span class="hljs-string"><span class="hljs-string">"my-custom-element-template"</span></span>&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt;   &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt;   &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;</code> </pre> <br>  Berikut cara menerapkan templat di elemen khusus: <br><br><pre> <code class="hljs scala">let myCustomElementTemplate = document.querySelector('#my-custom-element-template'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); } // ... });</span></span></code> </pre> <br>  Seperti yang Anda lihat, ada kombinasi elemen khusus, DOM Bayangan, dan template.  Ini memungkinkan kami untuk membuat elemen yang terisolasi di ruangnya sendiri, di mana struktur HTML dipisahkan dari logika JS. <br><br><h2>  <font color="#3AC1EF">Stilisasi</font> </h2><br>  Sejauh ini, kami hanya berbicara tentang JavaScript dan HTML, mengabaikan CSS.  Karena itu, kita sekarang menyentuh topik gaya.  Jelas, kita perlu cara untuk menata elemen khusus.  Gaya dapat ditambahkan di dalam Shadow DOM, tetapi kemudian muncul pertanyaan tentang bagaimana gaya elemen-elemen tersebut dari luar, misalnya - jika mereka tidak digunakan oleh orang yang membuatnya.  Jawaban atas pertanyaan ini cukup sederhana - elemen khusus ditata dengan cara yang sama seperti elemen bawaan. <br><br><pre> <code class="hljs mel">my-custom-element { border-radius: <span class="hljs-number"><span class="hljs-number">5</span></span>px; width: <span class="hljs-number"><span class="hljs-number">30</span></span>%; height: <span class="hljs-number"><span class="hljs-number">50</span></span>%; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Perhatikan bahwa gaya eksternal lebih diutamakan daripada gaya yang dideklarasikan di dalam elemen, menimpanya. <br><br>  Anda mungkin telah melihat bagaimana, ketika sebuah halaman ditampilkan di layar, pada titik tertentu Anda dapat mengamati konten yang tidak bergaya di dalamnya (inilah yang disebut FOUC - Flash Of Unstyled Content).  Anda dapat menghindari fenomena ini dengan mengatur gaya untuk komponen yang tidak terdaftar, dan menggunakan beberapa efek visual saat mendaftarkannya.  Untuk melakukan ini, Anda dapat menggunakan pemilih <code>:defined</code> .  Anda dapat melakukan ini, misalnya, seperti ini: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">my-button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:defined)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  <font color="#3AC1EF">Elemen tidak dikenal dan elemen pengguna tidak ditentukan</font> </h2><br>  Spesifikasi HTML sangat fleksibel, memungkinkan Anda untuk mendeklarasikan setiap tag yang Anda butuhkan untuk pengembang.  Dan, jika tag tidak dikenali oleh browser, itu akan diproses oleh parser sebagai <code>HTMLUnknownElement</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'thisElementIsUnknown'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLUnknownElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is unknown'</span></span>); }</code> </pre> <br>  Namun, ketika bekerja dengan elemen khusus, skema seperti itu tidak berlaku. ,       ?     ,    ,      <code>HTMLElement</code>        . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'this-element-is-undefined'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is undefined but not unknown'</span></span>); }</code> </pre> <br>   <code>HTMLElement</code>  <code>HTMLUnknownElement</code>    ,    ,  ,  ,    -   .  ,  ,     ,    .          <code>div</code> .             . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>         Chrome 36+.     API Custom Components v0,    , ,     ,    .    API,  ,  —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . API Custom Elements v1   Chrome 54+   Safari 10.1+ (   ).  Mozilla      v50,     ,     . ,   Microsoft Edge      API.  ,        ,   webkit. ,    ,  ,         —   IE 11. <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>  ,  ,       ,        <code>customElements</code> <br>   <code>window</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportsCustomElements = <span class="hljs-string"><span class="hljs-string">'customElements'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportsCustomElements) { <span class="hljs-comment"><span class="hljs-comment">// API Custom Elements   }</span></span></code> </pre> <br>      : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>);   script.src = src;   script.onload = resolve;   script.onerror = reject;   <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script); }); } <span class="hljs-comment"><span class="hljs-comment">//    -    . if (supportsCustomElements) { //    ,    . } else { loadScript('path/to/custom-elements.min.js').then(_ =&gt; {   //   ,     . }); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>        ,     : <br><br><ul><li>     HTML- JavaScript-,   ,      CSS-. </li><li>      HTML- ( ,   ). </li><li>           . ,   —   JavaScript, HTML, CSS, ,      ,  . </li><li>             - (Shadow DOM, , ,   ). </li><li>         ,     . </li><li>       ,     . </li></ul><br>  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  Custom Elements v1      , ,    , ,   ,      . <br><br>  <b>Pembaca yang budiman!</b>         ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419831/">https://habr.com/ru/post/id419831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419817/index.html">Meluncurkan Cluster RabbitMQ di Kubernetes</a></li>
<li><a href="../id419819/index.html">Biomarker penuaan. Panel Frailty. Bagian 2</a></li>
<li><a href="../id419823/index.html">Duet yang tidak biasa - frasa sandi dan gambar mnemonik</a></li>
<li><a href="../id419825/index.html">Menguji kinerja beberapa jenis drive di lingkungan virtual</a></li>
<li><a href="../id419829/index.html">Enkripsi kunci default OpenSSH lebih buruk daripada tidak sama sekali</a></li>
<li><a href="../id419833/index.html">Pekerjaan jarak jauh, cara kerjanya</a></li>
<li><a href="../id419835/index.html">Bagaimana memotivasi penulis, bernegosiasi dengan para ahli dan umumnya menulis artikel yang bagus</a></li>
<li><a href="../id419837/index.html">Saya, RoboLoyer, atau bagaimana mencari anomali dalam dokumen</a></li>
<li><a href="../id419839/index.html">Peretasan ATM NCR Tingkat Rendah</a></li>
<li><a href="../id419843/index.html">GeekUniversity Membuka Pendaftaran di Fakultas Kecerdasan Buatan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>