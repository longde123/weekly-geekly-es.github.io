<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐩 🕙 🏯 拟牛顿法，或当Athos的二阶导数过多时 ➿ 🙍🏾 🍄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="初次接触拟牛顿法的人可能会惊讶两次。 首先，快速浏览一下公式后，人们怀疑这是否完全可行。 但是，它们可以工作。 此外，它们能否运作良好似乎值得怀疑。 而且，与梯度下降的各种变化相比，它们的速度要快得多，这不仅令人惊奇，而且不是在特殊构造的任务上，而是在实践中得到的真实任务上。 而且，如果在此之后仍然...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>拟牛顿法，或当Athos的二阶导数过多时</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470638/"> 初次接触拟牛顿法的人可能会惊讶两次。 首先，快速浏览一下公式后，人们怀疑这是否完全可行。 但是，它们可以工作。 此外，它们能否运作良好似乎值得怀疑。 而且，与梯度下降的各种变化相比，它们的速度要快得多，这不仅令人惊奇，而且不是在特殊构造的任务上，而是在实践中得到的真实任务上。 而且，如果在此之后仍然充满疑虑，那么您需要了解为什么这一切都奏效。 <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已经考虑</a>了驱动梯度方法（包括牛顿法）的起源和基本思想。 即，我们依靠有关函数在当前位置附近的行为的信息，这为我们提供了简单的数学分析。 至少假设我们可以获取有关一阶导数的信息。 如果这是我们可以使用的全部呢？ 梯度下降是我们的句子吗？ 当然，是的，除非您突然想起我们正在处理正确处理目标函数的过程。 如果是这样，为什么我们不使用有关函数行为的累积信息来使我们在函数表面上的走动少一点点呢？ <br><br> 使用有关所覆盖路径的信息的想法是大多数加快下降方法的方法的核心。 本文讨论了一种最有效但不是最便宜的会计方法来处理此类信息，从而提出了拟牛顿法的思想。 <br><br> 为了了解拟牛顿方法的支线从何而来以及名称从何而来，我们再次必须返回基于固定点方程直接解的极小化方法 <img src="https://habrastorage.org/getpro/habr/post_images/c43/946/5f9/c439465f905d9f366a2f4b3296306290.gif" title="“ \ bigtriangledown f = 0”">  。 正如考虑将牛顿法应用于该方程的解使我们找到同名的优化方法（与它的祖先不同，它具有一个全局收敛的区域），我们可以期望考虑其他方法来求解非线性方程组将在规划构建其他优化方法的想法。 <br><br><h2> 正割方法 </h2><br> 让我提醒您，牛顿法用于解方程组 <img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="“ F（x）= 0”">  ，是基于接近解的某个点附近的替换 <img src="https://habrastorage.org/getpro/habr/post_images/779/0dd/0ef/7790dd0efb4a03a4c876741804d9b559.gif" title="“X”"> 功能 <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="“ F”"> 它的线性近似 <img src="https://habrastorage.org/getpro/habr/post_images/d15/479/f23/d15479f235f0d60ce8837c9043a0d2cc.gif" title="“ L（p）= F（x）+ J（x）p”"> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/206/f34/999/206f349991c0724c2fdce788124abe1c.gif" title="“ J”"> 是线性运算符， <img src="https://habrastorage.org/getpro/habr/post_images/779/0dd/0ef/7790dd0efb4a03a4c876741804d9b559.gif" title="“X”"> 是向量， <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="“ F”"> 对每个变量具有偏导数，与雅可比矩阵重合 <img src="https://habrastorage.org/getpro/habr/post_images/4d2/826/ff6/4d2826ff6ba22f9f67cab70bfbe17a16.gif" title="“ J_ {ij} = \ dfrac {\部分F_ {i}} {\部分x_ {j}}”">  。 接下来，方程式求解 <img src="https://habrastorage.org/getpro/habr/post_images/c9d/8be/3f2/c9d8be3f2d70054db890ea34e3409544.gif" title="“ L（p）= 0”"> 并指出 <img src="https://habrastorage.org/getpro/habr/post_images/2c4/a7b/e55/2c4a7be5582848bfbcdd9ee141e7d764.gif" title="＆quot; x'= x + p＆quot;"> 作为所需解决方案的新近似值。 它很简单，而且有效。 <br><br> 但是，如果由于某种原因我们无法计算雅可比矩阵怎么办？ 在这种情况下，首先想到的是，如果我们不能通过分析来计算偏导数，那么我们就可以很好地得到它们的数值近似值。 这种近似的最简单（尽管决不是唯一的）选择可以是右有限差分的公式： <img src="https://habrastorage.org/getpro/habr/post_images/149/708/f5b/149708f5b8bab4374023295557622e82.gif" title="“ \ dfrac {\部分F_ {i}} {\部分x_ {j}} \大约\ dfrac {F_ {i}（x + h_ {j} e_ {j}）-F_ {i}（x）} { h_ {j}}“"> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/459/e61/aa0/459e61aa08f7fe807167a596e7ebd8a9.gif" title="“ e_ {j}”"> 是第j个基向量。 由这些近似组成的矩阵将用 <img src="https://habrastorage.org/getpro/habr/post_images/a51/533/990/a5153399048e881eb8661304792b8c81.gif" title="“ \ bar {J}”">  。 更换多少的分析 <img src="https://habrastorage.org/getpro/habr/post_images/206/f34/999/206f349991c0724c2fdce788124abe1c.gif" title="“ J”"> 在 <img src="https://habrastorage.org/getpro/habr/post_images/a51/533/990/a5153399048e881eb8661304792b8c81.gif" title="“ \ bar {J}”"> 在牛顿的方法中，它的收敛性会影响大量的工作，但是在这种情况下，我们会对另一个方面感兴趣。 即，这种近似需要在N个附加点处计算该函数，此外，该函数 <img src="https://habrastorage.org/getpro/habr/post_images/6c4/afd/100/6c4afd1002ddcfa43d07afbc9f103a9d.gif" title="“ \ bar {L}（p）= F（x）+ \ bar {J} p”"> 在这些点上<i>插值</i>函数 <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="“ F”">  ，即 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c56/5c9/4b4/c565c94b4a37b9cd5f42fc1be92b2e15.gif" title="“ \ bar {L（} h_ {j} e_ {j}）= F（x）+ h_ {j} \ dfrac {F（x + h_ {j} e_ {j}）-F（x）} {h_ {j}} = F（x）+ F（x + h_ {j} e_ {j}）-F（x）= F（x + h_ {j} e_ {j}）。”"><br><br> 并非Jacobi矩阵的每个近似都具有此属性，但是具有此属性的仿射函数的每个矩阵都是Jacobi矩阵的近似。 确实，如果 <img src="https://habrastorage.org/getpro/habr/post_images/88f/5c8/dd7/88f5c8dd7e9876a2d0e0980882f261da.gif" title="“ F（x + p_ {j}）= F（x）+ J（x）p_ {j} + o \左（\左\ Vert p_ {j} \右\ Vert ^ {2} \右）”"> 和 <img src="https://habrastorage.org/getpro/habr/post_images/5ad/e1e/ad2/5ade1ead2804a3bfaa8ffdf9122a179a.gif" title="“ \ bar {J} p_ {j} = F（x + p_ {j}）-F（x）”"> 然后在 <img src="https://habrastorage.org/getpro/habr/post_images/803/ca4/351/803ca4351b87edf1a13a2a2947772fa7.gif" title="“ \左\垂直p_ {j} \右\垂直\ rightarrow0 \四边形\条{J}（x）p_ {j} \ rightarrow J（x）p_ {j}”">  。 该属性，即插值属性，为我们提供了一种构造方法来推广牛顿法。 <br><br> 让 <img src="https://habrastorage.org/getpro/habr/post_images/194/ad1/d42/194ad1d42aa4320679b9498748ceb78d.gif" title="“ \ bar {L}（p）= a + Ap”">  -功能满足要求 <img src="https://habrastorage.org/getpro/habr/post_images/06e/34e/3a7/06e34e3a7a0d0058ef351da74258a637.gif" title="“ \ bar {L}（p_ {i}）= F（x + p_ {i}）”"> 对于某些线性独立矢量系统 <img src="https://habrastorage.org/getpro/habr/post_images/cf2/deb/64e/cf2deb64e8b0e4d34902a32a5fd93b7b.gif" title="“ p_ {i}”">  。 这样的函数称为<i>割线</i>函数 <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="“ F”">  ，定义它的方程是<i>割线方程</i> 。 如果向量系统 <img src="https://habrastorage.org/getpro/habr/post_images/cf2/deb/64e/cf2deb64e8b0e4d34902a32a5fd93b7b.gif" title="“ p_ {i}”"> 是完整的（也就是说，它们中正好有N个，并且它们仍然是线性独立的），此外，向量系统 <img src="https://habrastorage.org/getpro/habr/post_images/94f/cf5/579/94fcf55798902795ffb670e35359d2af.gif" title="“ \左\ {F（x + p_ {i}），i = 1 \点N \右\}”"> 然后线性独立 <img src="https://habrastorage.org/getpro/habr/post_images/77f/eec/dd2/77feecdd2ae9a4795d2f81f3eec18b1b.gif" title="“ \ bar {L}”"> 唯一定义。 <br><br> 任何基于方程局部变化的方法 <img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="“ F（x）= 0”"> 形式方程 <img src="https://habrastorage.org/getpro/habr/post_images/ccb/557/80f/ccb55780f0c8e65187b0f4c9126be81c.gif" title="“ \ bar {L}（p）= 0”"> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/77f/eec/dd2/77feecdd2ae9a4795d2f81f3eec18b1b.gif" title="“ \ bar {L}”"> 满足<i>割线方程</i> ，称为<i>割线方法</i> 。 <br><br> 关于如何以最合理的方式构造函数割线的问题出现了。 <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="“ F”">  。 下面的推理似乎很明显：让一个仿射模型在点x处构建，并在这些点上插入给定函数 <img src="https://habrastorage.org/getpro/habr/post_images/462/bcf/f32/462bcff32469c0ec5f8ccfc80534c05c.gif" title="“ x-x_ {1}，x-x_ {2}，\点，x-x_ {N}”">  。 方程解 <img src="https://habrastorage.org/getpro/habr/post_images/ccb/557/80f/ccb55780f0c8e65187b0f4c9126be81c.gif" title="“ \ bar {L}（p）= 0”"> 给我们一个新点 <img src="https://habrastorage.org/getpro/habr/post_images/2c4/a7b/e55/2c4a7be5582848bfbcdd9ee141e7d764.gif" title="＆quot; x'= x + p＆quot;">  。 然后在某个点建立仿射模型 <img src="https://habrastorage.org/getpro/habr/post_images/787/cf7/c3a/787cf7c3a3d374114b3a07305b7fa446.gif" title="＆quot; x'＆quot;"> 选择插值点以使该值最合理 <img src="https://habrastorage.org/getpro/habr/post_images/01a/a15/8fc/01aa158fc8bc3d7f7f3b2807df8b4a5e.gif" title="“ F”"> 已经知道-也就是说，从集合中取出它们 <img src="https://habrastorage.org/getpro/habr/post_images/333/297/225/33329722533f0b608b0994d2a5ba83fa.gif" title="＆quot; \左\ {x'-x，x'-x_ {1}，x'-x_ {2}，\点，x'-x_ {N} \右\}＆quot;">  。 有多种选择，可以从以前使用的许多点中进行选择。 例如，您可以将那些 <img src="https://habrastorage.org/getpro/habr/post_images/bb3/e3a/cd5/bb3e3acd5043b859fe89006d4cabe5a0.gif" title="“ \左\ Vert F \右\ Vert”"> 无关紧要或仅是第一 <img src="https://habrastorage.org/getpro/habr/post_images/055/8e9/3d9/0558e93d918ff32e873b6a71703e9969.gif" title="“ N”"> 点。 无论如何，似乎很明显 <img src="https://habrastorage.org/getpro/habr/post_images/95f/756/92b/95f75692ba0aeefcef24ae42714dbc1b.gif" title="＆quot; p = x'-x＆quot;"> 新仿射模型的许多插值点中应包含该元素。 所以超越 <img src="https://habrastorage.org/getpro/habr/post_images/f24/8e8/91e/f248e891effc6650d9d31fbefc54cbe4.gif" title="“ n”"> 我们集合中的迭代过程的步骤最多 <img src="https://habrastorage.org/getpro/habr/post_images/f24/8e8/91e/f248e891effc6650d9d31fbefc54cbe4.gif" title="“ n”"> 基于先前通过的点的位移。 如果流程的构建方式使得新的仿射模型不再使用 <img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="“ p”"> 取先前值的一个，则此过程称为p点割线方法。 <br><br> 乍一看，似乎N点割线法是替代牛顿法的最佳人选，因为它最大程度地利用了我们在求解过程中获得的信息，同时最大程度地减少了其他计算的次数-我们在后者中使用函数的值N分通过。 不幸的是，事实并非如此。 问题是向量系统 <img src="https://habrastorage.org/getpro/habr/post_images/ed0/117/8ca/ed01178ca46506fa4588780d16d705a1.gif" title="“ F（x_ {0}），F（x_ {1}），\点F（x_ {N}）”"> 固执地拒绝以足够大的N来进行线性独立。此外，即使事实证明该条件得到满足并且相应的仿射模型仍然存在，方向还是有可能 <img src="https://habrastorage.org/getpro/habr/post_images/602/ff2/50c/602ff250c473d5b28e08a1453d4175b3.gif" title="“ p_ {j} = x_ {j} -x_ {0}”"> 也证明是线性独立的，结果甚至更少。 这就导致了一个事实，即仿射模型虽然存在，但仍然退化并且实际上不适合。 <br><br> 通常，最稳定的是2点割线方法。 也就是一种方法，在该方法中，每次迭代我们都必须计算该函数的其他N-1个值。 这显然不适合我们的实际目的。 <br><br> 然后的问题是-这都是什么？ <br><br><h2> 拟牛顿法求解方程 </h2><br><br> 出路很简单，尽管并不明显。 如果我们没有基于已经计算出的值的技术能力来唯一确定满足割线方程的仿射模型，则没有必要。 我们以割线方程为基础，但是我们将要求仅对某些不完整的向量系统满足 <img src="https://habrastorage.org/getpro/habr/post_images/e5e/f2b/432/e5ef2b43292735aa2a68afffb80bf520.gif" title="“ \左\ {p_ {1}，p_ {2}，\点，p_ {m} \右\}，m＆lt; N”">  。 换句话说，我们将要求仅对于足够少量的已知值满足内插条件。 当然，在这种情况下，我们不能再保证在这种模型中使用的矩阵趋向于Jacobi矩阵，但是我们将不需要它。 除此之外，仿射模型必须在当前点内插函数，即 <img src="https://habrastorage.org/getpro/habr/post_images/3b9/9d1/7fa/3b99d17fa378aeaf36097faef3830bd5.gif" title="“ \ bar {L}（0）= F（x）”">  ，我们得到以下割线方法的公式： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78c/f30/421/78cf304219a4bc90d4f900062bf2d027.gif" title="“ \\ \条{L}（p_ {i}）= F（x）+ Ap_ {i} = F（x + p_ {i}），\ quad i = 1 \点m \\ \条{L} （p）= 0 \ quad \ Rightarrow p = A ^ {-1} F（x）“"><br><br>  Bruiden是第一个在m = 1时考虑这种方法的人，称它们为准牛顿法。 显然，这种情况下的割线条件使我们能够唯一地识别矩阵 <img src="https://habrastorage.org/getpro/habr/post_images/c9d/999/d9a/c9d999d9a4e8bd3d6f8e50519d1dfaa8.gif" title="“ A”"> 仅当对其施加了附加条件时，并且每个此类附加条件都会产生单独的方法。 布吕登本人的理由如下： <br><br>  <i>作为方向的运动</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="“ p”"></i>  <i>从点</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/460/82f/7d6/46082f7d6471c3fabb832d8f94075758.gif" title="“ x_ {0}”"></i>  <i>到这一点</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/1d0/56f/301/1d056f3016bc715aacc23418d8629173.gif" title="“ x_ {1}”"></i>  <i>除了以下功能外，我们没有提供其他任何有关功能变化的信息：</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="“ p”"></i>  <i>方向，然后新的仿射函数对向量的影响</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="“Q”"></i>  <i>应该与旧函数对相同向量的影响不同，相差越小，差异越大</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="“Q”"></i>  <i>来自</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="“ p”"></i>  <i>。</i>  <i>不得已时</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="“Q”"></i>  <i>正交的</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="“ p”"></i>  <i>，新功能的行为不应与旧功能的行为有所不同。</i> <i><br></i> <br>  Breiden的想法非常简单。 的确，如果我们没有有关函数行为的新信息，那么我们能做的最好的事情就是尽量不要破坏旧函数。 然后附加条件 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b3/d43/d20/0b3d43d207b144b926274d0c81abccbf.gif" title="“ \ bar {L} _ {1} q = \ bar {L} _ {0} q”"> 对于所有 <img src="https://habrastorage.org/getpro/habr/post_images/9fc/c76/a21/9fcc76a21130891ea5d5b10efa979bff.gif" title="“Q”"> 这样 <img src="https://habrastorage.org/getpro/habr/post_images/c16/9f6/315/c169f6315171249a34b50b26a2975c6e.gif" title="“ q ^ {T} p = 0”"><br><br> 允许您唯一地确定新转换的矩阵-通过向旧矩阵添加等级1校正获得。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/522/f36/1f9/522f361f94a7b5a2e9da68094983b21d.gif" title="“ \\ A_ {1} = A_ {0} + \ dfrac {（y-A_ {0} p）p ^ {T}} {p ^ {T} p} \\ y = F（x_ {0}） -F（x_ {1}）“"><br><br> 但是，尽管Bruiden得出的结论简单而一致，但它们并未提供可作为构建其他类似方法基础的支点。 幸运的是，他的想法有了更正式的表达。 即，以此方式构造的矩阵 <img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="“ A_ {1}”"> 原来是解决以下问题的方法： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/028/96f/3fa/02896f3facb898d70f26abad02fe90a9.gif" title="“ \\ \左\ Vert A_ {1} -A_ {0} \右\ Vert _ {F} \ rightarrow \ min \\ F（x_ {1}）-Ap = F（x_ {0}）”"><br><br> 任务约束不过是割线方程，最小化条件反映了我们希望在矩阵中保存尽可能多的信息的愿望。 <img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="“ A_ {0}”">  。 在这种情况下，矩阵之间的差异的度量是Frobenius范数，其中提出的问题具有明确的解决方案。 该配方很可能作为构建其他方法的起点。 即，我们既可以改变评估引入的变化的<i>度量</i> ，也可以改变施加在矩阵上的<i>条件</i> 。 通常，人们已经可以使用这种方法的表述。 <br><br><h2> 拟牛顿优化方法 </h2><br><br> 了解了主要思想之后，我们终于可以回到优化问题，并注意到应用Bruyden公式重新计算仿射模型并不完全适合我们的任务。 实际上，梯度函数的一阶导数 <img src="https://habrastorage.org/getpro/habr/post_images/6b8/82e/be7/6b882ebe727121dcb5fc21b091044b5a.gif" title="“ \ bigtriangledown f”"> 除了Hessian矩阵外，没有其他任何东西，该矩阵通过构造是对称的。 同时，根据Bruyden规则进行更新会导致矩阵不对称 <img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="“ A_ {1}”"> 即使 <img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="“ A_ {0}”"> 是对称的。 这并不意味着不能使用Bruden方法求解固定点方程，而是基于这样的更新规则，我们不太可能构造好的优化方法。 通常，很明显，拟牛顿法的效果更好，问题的条件系统描述特定Jacobi矩阵的特征越准确。 <br><br> 为了纠正这一缺陷，我们向Bruden最小化问题添加了一个附加约束，明确要求新矩阵与旧矩阵对称： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03e/167/aa2/03e167aa25e0f4aa6b8df8546552e79a.gif" title="“ \\ \左\ Vert A_ {1} -A_ {0} \右\ Vert _ {F} \ rightarrow \ min \\ \ bigtriangledown f（x_ {1}）-Ap = \ bigtriangledown f（x_ {0} ）\\ A_ {1} ^ {T} = A_ {1}“"><br><br> 解决这个问题的方法是 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df8/356/74b/df835674b94bab190bca3c18efed98ce.gif" title="“ A_ {1} = A_ {0} + \ dfrac {（y-A_ {0} p）p ^ {T} + p（y-A_ {0} p）^ {T}} {p ^ {T} p}-\ dfrac {（y-A_ {0} p）^ {T} p} {\左（p ^ {T} p \ right）^ {2}} pp ^ {T}“"><br><br> 在这里 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/89c/f84/f29/89cf84f292ed72d1b20755677688a054.gif" title="y = \ bigtriangledown f（x_ {1}）-\ bigtriangledown f（x_ {0}）"></a>  ，矩阵重新计算公式以其创建者Powell，Shanno和Bruyden（PSB）命名。 所得矩阵是对称的，但显然不是正定的，如果只是突然的话 <img src="https://habrastorage.org/getpro/habr/post_images/6c7/040/47d/6c704047d3148fd7a8b563aaf79dd7f4.gif" title="“ y”"> 不会共线 <img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="“ p”">  。 而且，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">看到</a>在优化方法中非常需要积极的确定性。 <br><br> 再次，我们将校正问题的条件，这次使用缩放的Frobenius范数作为矩阵散度的度量。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f37/eb1/0f4/f37eb10f4eb10d0c54acc9adab962f10.gif" title="“ \\ \左\ Vert T ^ {-T} \左（A_ {1} -A_ {0} \右）T ^ {--1} \右\ Vert _ {F} \ rightarrow \ min \\ \ bigtriangledown f（x_ {1}）-Ap = \ bigtriangledown f（x_ {0}）\\ A_ {1} ^ {T} = A_ {1}“"><br><br> 这样的问题陈述的起源是一个单独的大话题，但是有趣的是，如果矩阵T如此 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/673/872/131/673872131fa6cb0f44e6839be0e448e7.gif" title="T ^ {T} T = G，Gp = y"></a>  （也就是说，G还是一个满足方向p割线方程的仿射变换矩阵），那么该问题的解决方案就与T的选择无关，并得出更新公式 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/135/ea6/c14/135ea6c14ea8f63f961e83576f1be5d5.gif" title="“ A_ {1} = A_ {0} + \ dfrac {（y-A_ {0} p）y ^ {T} + y（y-A_ {0} p）^ {T}} {y ^ {T} p}-\ dfrac {\左（y-A_ {0} p \右）^ {T} p} {\左（y ^ {T} p \右）^ {2}} yy ^ {T}“"><br><br> 被称为Davidon-Fletcher-Powell公式。 此更新方法已在实践中证明自己，因为它具有以下属性： <br><br>  <i>如果</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/e3e/c44/1c1/e3ec441c17e1b43df108a7d8e15d3dd6.gif" title="“ y ^ {T} p＆gt; 0”"></i>  <i>和</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/107/a45/803/107a45803b226180325815eaa7be8706.gif" title="“ A_ {0}”"></i>  <i>正定则</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="“ A_ {1}”"></i>  <i>也得到肯定的肯定。</i> <br><br> 之后我注意到，如果不满足第一个条件，则不存在具有满足割线方程的正定矩阵的仿射函数。 <br><br> 如果在导致DFP方法的问题中，我们采用仿射模型之间的距离作为衡量仿射模型差异的指标，而不是矩阵本身之间的距离，则得出以下形式的问题： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/337/0b0/af2/3370b0af216ab9695789eeb586cf3604.gif" title="“ \\ \左\ Vert T ^ {-T} \左（A_ {1} ^ {-1} -A_ {0} ^ {-1} \右）T ^ {-1} \右\ Vert _ { F} \ rightarrow \ min \\ \ bigtriangledown f（x_ {1}）-Ap = \ bigtriangledown f（x_ {0}）\\ A_ {1} ^ {T} = A_ {1}“"><br><br> 它的解决方案是一个众所周知的公式，几乎由Breiden，Fletcher，Goldfarb和Shanno（BFGS）同时发现。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3fa/840/c7b/3fa840c7b6ec3de81eb02bb0e9240722.gif" title="“ A_ {1} = A_ {0} + \ dfrac {yy ^ {T}} {y ^ {T} p}-\ dfrac {A_ {0} pp ^ {T} A_ {0}} {p ^ { T} A_ {0} p}“"><br><br> 迄今为止，据信从计算的角度来看，根据该公式的重新计算是最有效的，并且同时不易发生具有大量迭代的矩阵退化。 在与DFP相同的条件下，此公式保留正定性。 <br><br> 所有描述的更新矩阵的方法都需要校正2级。这使得矩阵求逆变得容易。 <img src="https://habrastorage.org/getpro/habr/post_images/147/7e7/ca0/1477e7ca06155c3e43fd4a640e0f7f98.gif" title="“ A_ {1}”"> 使用Sherman-Morrison公式和值 <img src="https://habrastorage.org/getpro/habr/post_images/5f6/3ac/2d9/5f63ac2d91f47a730fee01b5db38f3bd.gif" title="“ A_ {0} ^ {-1}”">  。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed0/9f8/002/ed09f80027e56f58a3502cc943758509.gif" title="“ B_ {1} = B_ {0} + uv ^ {T} \ Rightarrow B_ {1} ^ {-1} = B_ {0} ^ {-1} + \ dfrac {B_ {0} ^ {-1} uv ^ {T} B_ {0} ^ {-1}} {1 + v ^ {T} B_ {0} ^ {-1} u}”"><br><br> 前提是公式的分母为非零。 我不会给出用于更新所列方法的逆矩阵的特定公式，因为它们很容易独立地找到或推导。 在这种情况下，唯一需要注意的是，与更新原始矩阵相比，用于更新逆矩阵的方法的变体通常不稳定得多（也就是说，它们遭受舍入误差的影响更大）。 最有效的方式不是更新矩阵本身，而是更新其Cholesky分解（当然除非进行这样的分解），因为这样的实现选项在数值上更稳定，此外还使求解确定运动方向的方程的成本最小化。 <br><br> 仍然需要考虑在准牛顿过程中第一个矩阵应如何显示的问题。 这里的一切都是显而易见的-它越接近于Hessian矩阵或它的校正版本，如果Hessian突然没有变成正定，从收敛的角度来看，它将越好。 但是，原则上，任何正定矩阵都适合我们。 这种矩阵的最简单形式是单个矩阵，然后第一次迭代与梯度下降的迭代重合。  Fletcher和Powell表明（对于DFP方法而言，自然），如果将二次函数最小化，则无论使用哪个（正定）矩阵作为初始DFP迭代，它们都会导致N次迭代的解，其中N为问题的维度，并且拟牛顿矩阵在最小点处与Hessian矩阵重合。 在这种幸福的一般非线性情况下，我们当然不会等待，但这至少有理由使我们不必过多担心初始矩阵的选择不当。 <br><br><h2> 结论 </h2><br><br> 所描述的构造拟牛顿法的方法并非唯一可行的方法。 至少，所描述的拟牛顿方法的发现者和许多后来的研究人员在完全不同的考虑基础上得出了相同的公式。 但是，有趣的是，一旦出现了某种拟牛顿法，很短的时间后就清楚地知道这是对一些非常容易解释的优化问题的解决方案。 在我看来，很明显可以为这种多样化的方法带来一些共同点，因为这为构建更好地考虑特定任务细节的其他方法提供了基础。 特别是，存在设计用于更新稀疏矩阵的准牛顿方法，其中尽可能少的元素受到更改的方法，还有许多其他方法将是一种幻想。 <br><br> 还应该注意的是，尽管变量度量方法的名称很广，但它们并不总是会导致构建矩阵，而矩阵实际上是度量，尽管它们会尽可能地做到这一点。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这通常不是一个大问题，但是想要保护自己免受可能的尴尬的人可能会采取与克服Newton方法类似问题的相同技巧-例如通过更改方向或应用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Levenberg-Marquardt方案</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。的确，在这种情况下，选择信任区域的形式的问题将再次变得重要，但是在这里您必须选择较少的邪恶。解决该问题的另一种方法是使用线性搜索方法，以确保满足维持肯定性确定性的必要条件。沃尔夫的规则保证了这一条件的实现，而阿米霍和戈尔茨坦的规则则没有。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从理论上讲，要确定一类问题，几乎不可能确定大量可能的拟牛顿方法中哪一种是最有效的。通常，在制定方法时，它们仅限于显示其在最小化二次函数中的有效性（顺便说一句，如果该方法在N次迭代中产生了精确的解决方案，则该方法被认为是有效的，也就是说，不比解决SLAE的直接方法慢得多）。在更罕见的情况下，人们可以研究该方法的收敛阶数（通常是超线性的，即明显优于梯度下降所给出的阶数），稳定性和其他感兴趣的特征。但是总的来说，判断特定方法对特定类别任务的有效性的唯一合理标准是实践。因此，铲在手-并成功应用。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470638/">https://habr.com/ru/post/zh-CN470638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470620/index.html">基础架构即代码：如何克服XP的问题</a></li>
<li><a href="../zh-CN470622/index.html">特征选择方法概述</a></li>
<li><a href="../zh-CN470628/index.html">太空飞船模拟器造船</a></li>
<li><a href="../zh-CN470632/index.html">Arend-基于HoTT的依存类型语言（第2部分）</a></li>
<li><a href="../zh-CN470634/index.html">在Instagram上识别跨社区以识别用户兴趣</a></li>
<li><a href="../zh-CN470640/index.html">调整Elasticsearch的大小</a></li>
<li><a href="../zh-CN470642/index.html">认识Yandex.Station Mini。 小型设备的大故事</a></li>
<li><a href="../zh-CN470644/index.html">为什么企业博客有时会发酸：一些观察和技巧</a></li>
<li><a href="../zh-CN470646/index.html">数据科学数学。 OTUS的新课程</a></li>
<li><a href="../zh-CN470648/index.html">IBM LTO-8-存储冷数据的简便方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>