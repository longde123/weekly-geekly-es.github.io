<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìà üëí ‚ùå Compacta√ß√£o de dados Huffman üòß üéª üî°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entrada 
 Neste artigo, falarei sobre o conhecido algoritmo Huffman, bem como sua aplica√ß√£o na compacta√ß√£o de dados. 

 Como resultado, escreveremos u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compacta√ß√£o de dados Huffman</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438512/"><h2>  Entrada </h2><br>  Neste artigo, falarei sobre o conhecido algoritmo Huffman, bem como sua aplica√ß√£o na compacta√ß√£o de dados. <br><br>  Como resultado, escreveremos um arquivador simples.  J√° havia um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre Habr√©</a> , mas sem implementa√ß√£o pr√°tica.  O material te√≥rico da publica√ß√£o atual √© retirado das aulas de ci√™ncias da computa√ß√£o da escola e do livro de Robert Lafore "Estruturas de dados e algoritmos em Java".  Ent√£o, est√° tudo em ordem! <br><a name="habracut"></a><br><h2>  Um pouco de reflex√£o </h2><br>  Em um arquivo de texto sem formata√ß√£o, um caractere √© codificado com 8 bits (codifica√ß√£o ASCII) ou 16 (codifica√ß√£o Unicode).  Al√©m disso, consideraremos a codifica√ß√£o ASCII.  Por exemplo, pegue a linha s1 = "SUSIE DIZ QUE √â F√ÅCIL \ n".  No total, √© claro que existem 22 caracteres na linha, incluindo espa√ßos e o caractere de nova linha - '\ n'.  Um arquivo contendo esta linha pesa 22 * ‚Äã‚Äã8 = 176 bits.  Surge imediatamente a pergunta: √© racional usar todos os 8 bits para codificar um caractere?  N√≥s n√£o usamos todos os caracteres ASCII.  Mesmo se usado, seria mais racional para a letra mais frequente - S - fornecer o menor c√≥digo poss√≠vel e para a letra mais rara - T (ou U, ou '\ n') - fornecer um c√≥digo mais aut√™ntico.  Este √© o algoritmo de Huffman: voc√™ precisa encontrar a melhor op√ß√£o de codifica√ß√£o, na qual o arquivo ter√° peso m√≠nimo.  √â bastante normal que os comprimentos do c√≥digo sejam diferentes para caracteres diferentes - essa √© a base do algoritmo. <br><br><h3>  Codifica√ß√£o </h3><br>  Por que n√£o atribuir ao caractere 'S' um c√≥digo, por exemplo, com 1 bit de comprimento: 0 ou 1. Seja 1. Ent√£o, forneceremos o segundo caractere mais encontrado - '' (espa√ßo) - 0. Imagine que voc√™ come√ßou a decodificar sua mensagem - sequ√™ncia codificada s1 - e voc√™ v√™ que o c√≥digo come√ßa com 1. Ent√£o, o que fazer: √© um caractere S ou algum outro caractere, por exemplo A?  Portanto, surge uma regra importante: <br><br>  <b>Nenhum c√≥digo deve ser o prefixo de outro</b> <br><br>  Esta regra √© a chave no algoritmo.  Portanto, a cria√ß√£o do c√≥digo come√ßa com a tabela de frequ√™ncias, que indica a frequ√™ncia (n√∫mero de ocorr√™ncias) de cada caractere: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/h6/y6/cuh6y658iqqnvb0whujokfbsaeq.jpeg" width="350"></div>  Os caracteres com mais ocorr√™ncias devem ser codificados com o menor n√∫mero <u>poss√≠vel</u> de bits.  Vou dar um exemplo de uma das tabelas de c√≥digo poss√≠veis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3j/01/_2/3j01_2tsdi_q790e8yuwa1l41zc.jpeg" width="350"></div>  Assim, a mensagem codificada ficar√° assim: <br><br><pre><code class="plaintext hljs">10 01111 10 110 1111 00 10 010 1110 10 00 110 0110 00 110 10 00 1111 010 10 1110 01110</code> </pre> <br>  Separei o c√≥digo de cada caractere com um espa√ßo.  Isso realmente n√£o acontecer√° em um arquivo compactado! <br>  Surge a pergunta: <s>como essa s√°laga surgiu com um c√≥digo</s> ? Como criar uma tabela de c√≥digos?  Isso ser√° discutido abaixo. <br><br><h4>  Construindo uma √°rvore huffman </h4><br>  Aqui, as √°rvores de busca bin√°ria v√™m em socorro.  N√£o se preocupe, aqui os m√©todos de busca, inser√ß√£o e exclus√£o n√£o s√£o necess√°rios.  Aqui est√° a estrutura da √°rvore em java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frequence; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> letter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node leftChild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node rightChild; ... }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node root; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root = root; } ... }</code> </pre><br>  Este n√£o √© um c√≥digo completo, o c√≥digo completo estar√° abaixo. <br><br>  Aqui est√° o pr√≥prio algoritmo de constru√ß√£o de √°rvore: <br><br><ol><li>  Crie um objeto N√≥ para cada caractere da mensagem (linha s1).  No nosso caso, haver√° 9 n√≥s (objetos Node).  Cada n√≥ consiste em dois campos de dados: s√≠mbolo e frequ√™ncia </li><li>  Crie um objeto de √°rvore (BinaryTree) para cada um dos n√≥s do n√≥.  O n√≥ se torna a raiz da √°rvore. </li><li>  Cole essas √°rvores na fila de prioridade.  Quanto menor a frequ√™ncia, maior a prioridade.  Assim, ao extrair, o dervo √© sempre selecionado com a menor frequ√™ncia. </li></ol><br>  Em seguida, voc√™ precisa fazer o seguinte ciclicamente: <br><br><ol><li>  Extraia duas √°rvores da fila de prioridade e torne-as descendentes do novo n√≥ (o n√≥ rec√©m-criado sem uma letra).  A frequ√™ncia do novo n√≥ √© igual √† soma das frequ√™ncias de duas √°rvores descendentes. </li><li>  Para este n√≥, crie uma √°rvore com uma raiz nesse n√≥.  Cole esta √°rvore de volta na fila de prioridade.  (Como a √°rvore tem uma nova frequ√™ncia, provavelmente chegar√° a um novo local na fila) </li><li>  Continue as etapas 1 e 2 at√© restar apenas uma √°rvore na fila - a √°rvore Huffman </li></ol><br>  Considere este algoritmo na linha s1: <br><br><img src="https://habrastorage.org/webt/v4/l2/xn/v4l2xnrj2mzomws6y696cm7o3_q.jpeg"><br><br>  Aqui, o s√≠mbolo "lf" (avan√ßo de linha) indica a transi√ß√£o para uma nova linha, "sp" (espa√ßo) √© um espa√ßo. <br><br><h4>  O que vem a seguir? </h4><br>  Temos uma √°rvore Huffman.  Bem, tudo bem.  E o que fazer com isso?  <s>Eles n√£o o levam de gra√ßa</s> e, ent√£o, voc√™ precisa acompanhar todos os caminhos poss√≠veis, desde a raiz at√© as folhas da √°rvore.  Vamos concordar em designar a aresta 0 se ela levar √† descendente esquerda e 1 se √† direita.  A rigor, nessas anota√ß√µes, o c√≥digo do s√≠mbolo √© o caminho da raiz da √°rvore at√© a planilha que cont√©m esse mesmo s√≠mbolo. <br><br><img src="https://habrastorage.org/webt/of/pi/k4/ofpik4e7t3afswjddxugb-ddkfa.jpeg"><br><br>  Assim, a tabela de c√≥digos acabou.  Observe que, se considerarmos esta tabela, podemos concluir sobre o "peso" de cada caractere - este √© o comprimento do seu c√≥digo.  O arquivo compactado pesar√°: 2 * 3 + 2 * 4 + 3 * 3 + 6 * 2 + 1 * 4 + 1 * 5 + 2 * 4 + 4 * 2 + 1 * 5 = 65 bits.  Inicialmente, pesava 176 bits.  Portanto, reduzimos em 176/65 = 2,7 vezes!  Mas isso √© utopia.  √â improv√°vel que esse coeficiente seja obtido.  Porque  Isso ser√° discutido um pouco mais tarde. <br><br><h3>  Decodifica√ß√£o </h3><br>  Bem, talvez a coisa mais simples que resta √© a decodifica√ß√£o.  Acho que muitos de voc√™s imaginaram que √© imposs√≠vel simplesmente criar um arquivo compactado sem nenhuma dica de como ele foi codificado - n√£o poderemos decodific√°-lo!  Sim, foi dif√≠cil para mim perceber isso, mas tive que criar um arquivo de texto table.txt com uma tabela de compacta√ß√£o: <br><br><pre> <code class="plaintext hljs">01110 00 A010 E1111 I110 S10 T0110 U01111 Y1110</code> </pre><br>  Registre a tabela na forma de 'caractere' "c√≥digo de caractere".  Por que 01110 √© sem caractere?  De fato, √© com um s√≠mbolo, apenas as ferramentas java usadas por mim ao gerar um arquivo, o caractere de nova linha - '\ n' - √© convertido em uma nova linha (por mais est√∫pido que pare√ßa).  Portanto, a linha vazia na parte superior √© o caractere para o c√≥digo 01110. Para o c√≥digo 00, o caractere √© um espa√ßo no in√≠cio da linha.  Devo dizer imediatamente que <s>nosso</s> m√©todo de armazenar esta tabela pode reivindicar o mais irracional.  Mas √© simples de entender e implementar.  Terei o prazer de ouvir suas recomenda√ß√µes nos coment√°rios sobre otimiza√ß√£o. <br><br>  Ter essa tabela √© muito f√°cil de decodificar.  Lembre-se de qual regra fomos guiados ao criar a codifica√ß√£o: <br><br>  <b>Nenhum c√≥digo deve prefixar outro</b> <br><br>  √â aqui que ele desempenha um papel facilitador.  Lemos sequencialmente bit a bit e, assim que a sequ√™ncia recebida d, composta por bits de leitura, corresponde √† codifica√ß√£o correspondente ao caractere, sabemos imediatamente que o caractere foi codificado (e somente ele!).  Em seguida, escrevemos caracteres na linha de decodifica√ß√£o (a linha que cont√©m a mensagem decodificada), zeramos a linha d e lemos o arquivo codificado. <br><br><h2>  Implementa√ß√£o </h2><br>  √â hora de <s>humilhar meu c√≥digo</s> escrevendo um arquivador.  Vamos cham√°-lo de compressor. <br><br>  Vamos come√ßar do come√ßo.  Primeiro, escrevemos a classe Node: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frequence;<span class="hljs-comment"><span class="hljs-comment">// private char letter;// private Node leftChild;//  private Node rightChild;//  public Node(char letter, int frequence) { //,  this.letter = letter; this.frequence = frequence; } public Node() {}//    (.       ) public void addChild(Node newNode) {//  if (leftChild == null)//  =&gt;  =&gt;    leftChild = newNode; else { if (leftChild.getFrequence() &lt;= newNode.getFrequence()) // ,   rightChild = newNode;// ,     else { rightChild = leftChild; leftChild = newNode; } } frequence += newNode.getFrequence();//  } public Node getLeftChild() { return leftChild; } public Node getRightChild() { return rightChild; } public int getFrequence() { return frequence; } public char getLetter() { return letter; } public boolean isLeaf() {//   return leftChild == null &amp;&amp; rightChild == null; } }</span></span></code> </pre><br>  Agora a √°rvore: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node root; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root = root; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFrequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.getFrequence(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root; } }</code> </pre><br>  Fila priorit√°ria: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList;<span class="hljs-comment"><span class="hljs-comment">//-,      class PriorityQueue { private ArrayList&lt;BinaryTree&gt; data;//  private int nElems;//-    public PriorityQueue() { data = new ArrayList&lt;BinaryTree&gt;(); nElems = 0; } public void insert(BinaryTree newTree) {// if (nElems == 0) data.add(newTree); else { for (int i = 0; i &lt; nElems; i++) { if (data.get(i).getFrequence() &gt; newTree.getFrequence()) {//     data.add(i, newTree);// . ,  c       1  break;//       } if (i == nElems - 1) data.add(newTree); } } nElems++;// -   1 } public BinaryTree remove() {//   BinaryTree tmp = data.get(0);//   data.remove(0);//,  nElems--;// -   1 return tmp;//  (   ) } }</span></span></code> </pre><br>  A classe que cria a √°rvore Huffman: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HuffmanTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>;<span class="hljs-comment"><span class="hljs-comment">//   private String myString;// private BinaryTree huffmanTree;//  private int[] freqArray;//  private String[] encodingArray;//  //----------------constructor---------------------- public HuffmanTree(String newString) { myString = newString; freqArray = new int[ENCODING_TABLE_SIZE]; fillFrequenceArray(); huffmanTree = getHuffmanTree(); encodingArray = new String[ENCODING_TABLE_SIZE]; fillEncodingArray(huffmanTree.getRoot(), "", ""); } //--------------------frequence array------------------------ private void fillFrequenceArray() { for (int i = 0; i &lt; myString.length(); i++) { freqArray[(int)myString.charAt(i)]++; } } public int[] getFrequenceArray() { return freqArray; } //------------------------huffman tree creation------------------ private BinaryTree getHuffmanTree() { PriorityQueue pq = new PriorityQueue(); //   for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) {//     Node newNode = new Node((char) i, freqArray[i]);//    Node BinaryTree newTree = new BinaryTree(newNode);//  Node  BinaryTree pq.insert(newTree);//   } } while (true) { BinaryTree tree1 = pq.remove();//    . try { BinaryTree tree2 = pq.remove();//     Node newNode = new Node();//  Node newNode.addChild(tree1.getRoot());//      newNode.addChild(tree2.getRoot()); pq.insert(new BinaryTree(newNode); } catch (IndexOutOfBoundsException e) {//     return tree1; } } } public BinaryTree getTree() { return huffmanTree; } //-------------------encoding array------------------ void fillEncodingArray(Node node, String codeBefore, String direction) {//   if (node.isLeaf()) { encodingArray[(int)node.getLetter()] = codeBefore + direction; } else { fillEncodingArray(node.getLeftChild(), codeBefore + direction, "0"); fillEncodingArray(node.getRightChild(), codeBefore + direction, "1"); } } String[] getEncodingArray() { return encodingArray; } public void displayEncodingArray() {//  fillEncodingArray(huffmanTree.getRoot(), "", ""); System.out.println("======================Encoding table===================="); for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) { System.out.print((char)i + " "); System.out.println(encodingArray[i]); } } System.out.println("========================================================"); } //----------------------------------------------------- String getOriginalString() { return myString; } }</span></span></code> </pre><br>  Classe que cont√©m quais codifica√ß√µes / decodifica√ß√µes: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HuffmanOperator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>;<span class="hljs-comment"><span class="hljs-comment">//  private HuffmanTree mainHuffmanTree;//  (   ) private String myString;//  private int[] freqArray;//  private String[] encodingArray;//  private double ratio;//  public HuffmanOperator(HuffmanTree MainHuffmanTree) {//for compress this.mainHuffmanTree = MainHuffmanTree; myString = mainHuffmanTree.getOriginalString(); encodingArray = mainHuffmanTree.getEncodingArray(); freqArray = mainHuffmanTree.getFrequenceArray(); } public HuffmanOperator() {}//for extract; //---------------------------------------compression----------------------------------------------------------- private String getCompressedString() { String compressed = ""; String intermidiate = "";// (  ) //System.out.println("=============================Compression======================="); //displayEncodingArray(); for (int i = 0; i &lt; myString.length(); i++) { intermidiate += encodingArray[myString.charAt(i)]; } //      .       8=&gt; //    ( 1,  ) byte counter = 0;//     (   : 0&lt;=counter&lt;8&lt;127) for (int length = intermidiate.length(), delta = 8 - length % 8; counter &lt; delta ; counter++) {//delta -    intermidiate += "0"; } // -         compressed = String.format("%8s", Integer.toBinaryString(counter &amp; 0xff)).replace(" ", "0") + intermidiate; //  setCompressionRatio(); //System.out.println("==============================================================="); return compressed; } private void setCompressionRatio() {//   double sumA = 0, sumB = 0;//A-the original sum for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { if (freqArray[i] != 0) { sumA += 8 * freqArray[i]; sumB += encodingArray[i].length() * freqArray[i]; } } ratio = sumA / sumB; } public byte[] getBytedMsg() {//final compression StringBuilder compressedString = new StringBuilder(getCompressedString()); byte[] compressedBytes = new byte[compressedString.length() / 8]; for (int i = 0; i &lt; compressedBytes.length; i++) { compressedBytes[i] = (byte) Integer.parseInt(compressedString.substring(i * 8, (i + 1) * 8), 2); } return compressedBytes; } //---------------------------------------end of compression---------------------------------------------------------------- //------------------------------------------------------------extract----------------------------------------------------- public String extract(String compressed, String[] newEncodingArray) { String decompressed = ""; String current = ""; String delta = ""; encodingArray = newEncodingArray; //displayEncodingArray(); // -   for (int i = 0; i &lt; 8; i++) delta += compressed.charAt(i); int ADDED_ZEROES = Integer.parseInt(delta, 2); for (int i = 8, l = compressed.length() - ADDED_ZEROES; i &lt; l; i++) { //i = 8, ..      -   current += compressed.charAt(i); for (int j = 0; j &lt; ENCODING_TABLE_SIZE; j++) { if (current.equals(encodingArray[j])) {//  decompressed += (char)j;//   current = "";//    } } } return decompressed; } public String getEncodingTable() { String enc = ""; for (int i = 0; i &lt; encodingArray.length; i++) { if (freqArray[i] != 0) enc += (char)i + encodingArray[i] + '\n'; } return enc; } public double getCompressionRatio() { return ratio; } public void displayEncodingArray() {//  System.out.println("======================Encoding table===================="); for (int i = 0; i &lt; ENCODING_TABLE_SIZE; i++) { //if (freqArray[i] != 0) { System.out.print((char)i + " "); System.out.println(encodingArray[i]); //} } System.out.println("========================================================"); } }</span></span></code> </pre><br>  Classe que facilita a grava√ß√£o em um arquivo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Closeable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileOutputHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closeable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> File outputFile; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileOutputStream fileOutputStream; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileOutputHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> FileNotFoundException </span></span>{ outputFile = file; fileOutputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(outputFile); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.write(msg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] msg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.write(msg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (PrintWriter pw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(outputFile)) { pw.write(msg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">" ,     !"</span></span>); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileOutputStream.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ close(); } }</code> </pre><br>  Classe que facilita a leitura de um arquivo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.EOFException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.InputStreamReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Closeable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileInputHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closeable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileInputStream fileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BufferedReader fileBufferedReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileInputHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ fileInputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); fileBufferedReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(fileInputStream)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = fileInputStream.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur == -<span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">//   throw new EOFException(); return (byte)cur; } public String readLine() throws IOException { return fileBufferedReader.readLine(); } @Override public void close() throws IOException{ fileInputStream.close(); } }</span></span></code> </pre><br>  Bem, e a classe principal: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.charset.MalformedInputException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Files; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.NoSuchFileException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Paths; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.EOFException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ENCODING_TABLE_SIZE = <span class="hljs-number"><span class="hljs-number">127</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {<span class="hljs-comment"><span class="hljs-comment">//       if (args[0].equals("--compress") || args[0].equals("-c")) compress(args[1]); else if ((args[0].equals("--extract") || args[0].equals("-x")) &amp;&amp; (args[2].equals("--table") || args[2].equals("-t"))) { extract(args[1], args[3]); } else throw new IllegalArgumentException(); } catch (ArrayIndexOutOfBoundsException | IllegalArgumentException e) { System.out.println("    "); System.out.println(" Readme.txt"); e.printStackTrace(); } } public static void compress(String stringPath) throws IOException { List&lt;String&gt; stringList; File inputFile = new File(stringPath); String s = ""; File compressedFile, table; try { stringList = Files.readAllLines(Paths.get(inputFile.getAbsolutePath())); } catch (NoSuchFileException e) { System.out.println(" ,     !"); return; } catch (MalformedInputException e) { System.out.println("    "); return; } for (String item : stringList) { s += item; s += '\n'; } HuffmanOperator operator = new HuffmanOperator(new HuffmanTree(s)); compressedFile = new File(inputFile.getAbsolutePath() + ".cpr"); compressedFile.createNewFile(); try (FileOutputHelper fo = new FileOutputHelper(compressedFile)) { fo.writeBytes(operator.getBytedMsg()); } //create file with encoding table: table = new File(inputFile.getAbsolutePath() + ".table.txt"); table.createNewFile(); try (FileOutputHelper fo = new FileOutputHelper(table)) { fo.writeString(operator.getEncodingTable()); } System.out.println("   : " + compressedFile.getAbsolutePath()); System.out.println("    " + table.getAbsolutePath()); System.out.println("     !"); double idealRatio = Math.round(operator.getCompressionRatio() * 100) / (double) 100;//  double realRatio = Math.round((double) inputFile.length() / ((double) compressedFile.length() + (double) table.length()) * 100) / (double)100;//  System.out.println("    " + idealRatio); System.out.println("      " + realRatio); } public static void extract(String filePath, String tablePath) throws FileNotFoundException, IOException { HuffmanOperator operator = new HuffmanOperator(); File compressedFile = new File(filePath), tableFile = new File(tablePath), extractedFile = new File(filePath + ".xtr"); String compressed = ""; String[] encodingArray = new String[ENCODING_TABLE_SIZE]; //read compressed file //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!check here: try (FileInputHelper fi = new FileInputHelper(compressedFile)) { byte b; while (true) { b = fi.readByte();//method returns EOFException compressed += String.format("%8s", Integer.toBinaryString(b &amp; 0xff)).replace(" ", "0"); } } catch (EOFException e) { } //-------------------- //read encoding table: try (FileInputHelper fi = new FileInputHelper(tableFile)) { fi.readLine();//skip first empty string encodingArray[(byte)'\n'] = fi.readLine();//read code for '\n' while (true) { String s = fi.readLine(); if (s == null) throw new EOFException(); encodingArray[(byte)s.charAt(0)] = s.substring(1, s.length()); } } catch (EOFException ignore) {} extractedFile.createNewFile(); //extract: try (FileOutputHelper fo = new FileOutputHelper(extractedFile)) { fo.writeString(operator.extract(compressed, encodingArray)); } System.out.println("    " + extractedFile.getAbsolutePath()); } }</span></span></code> </pre><br>  O arquivo de instru√ß√µes readme.txt depende de voc√™ escrever :-) <br><br><h2>  Conclus√£o </h2><br>  Provavelmente √© tudo o que eu queria dizer.  Se voc√™ tem algo a dizer sobre a <s>minha incompet√™ncia de</s> melhorias no c√≥digo, algoritmo e qualquer otimiza√ß√£o em geral, fique √† vontade para escrever.  Se eu entendi algo errado, tamb√©m escreva.  Ficarei feliz em ouvi-lo nos coment√°rios! <br><br><h3>  PS </h3><br>  Sim, sim, ainda estou aqui, porque n√£o esqueci o coeficiente.  Para a string s1, a tabela de codifica√ß√£o pesa 48 bytes - muito mais que o arquivo original e eles n√£o esqueceram de zeros adicionais (o n√∫mero de zeros adicionados √© 7) =&gt; a taxa de compacta√ß√£o ser√° menor que um: 176 / (65 + 48 * 8 + 7) = 0,38.  Se voc√™ tamb√©m notou isso, ent√£o <s>n√£o apenas na cara,</s> voc√™ est√° bem feito.  Sim, essa implementa√ß√£o ser√° extremamente ineficiente para arquivos pequenos.  Mas o que acontece com arquivos grandes?  Os tamanhos dos arquivos excedem em muito o tamanho da tabela de codifica√ß√£o.  Aqui o algoritmo funciona como deveria!  Por exemplo, para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mon√≥logo Faust, o</a> arquivador fornece um coeficiente real (n√£o idealizado) igual a 1,46 - quase uma vez e meia!  E sim, o arquivo deveria estar em ingl√™s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438512/">https://habr.com/ru/post/pt438512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438498/index.html">Como se preparar rapidamente para uma entrevista, que ter√° perguntas sobre algoritmos e tecnologias de processamento de informa√ß√µes?</a></li>
<li><a href="../pt438500/index.html">Do lado bom: como o Optimus Prime trouxe Kingston e HyperX para a CES 2019</a></li>
<li><a href="../pt438506/index.html">Meu segundo inverno sem neve ou magistratura na B√©lgica</a></li>
<li><a href="../pt438508/index.html">A atividade do c√©rebro humano foi traduzida pela primeira vez em discurso claro</a></li>
<li><a href="../pt438510/index.html">Composi√ß√£o versus heran√ßa, padr√£o de equipe e desenvolvimento de jogos em geral</a></li>
<li><a href="../pt438514/index.html">Como n√£o trabalho h√° um ano no Sberbank</a></li>
<li><a href="../pt438516/index.html">Quando salvar o comprimento de uma matriz em uma vari√°vel local em C #</a></li>
<li><a href="../pt438518/index.html">Criando seu jsfiddle, parte 2</a></li>
<li><a href="../pt438522/index.html">Equalizador estrat√©gico</a></li>
<li><a href="../pt438524/index.html">Arquitetura de aplicativo Flutter 101: Baunilha, modelo com escopo, BLoC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>