<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèæ üéôÔ∏è üí≤ Como o tempo linear se transforma no Windows em O (n¬≤) üßòüèº üå∏ üñï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, tive atrasos de v√°rios minutos em minha esta√ß√£o de trabalho. Ap√≥s a investiga√ß√£o, descobriu-se que a causa do problema era uma trava, qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o tempo linear se transforma no Windows em O (n¬≤)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479498/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png" alt="imagem"></div><br>  Recentemente, tive atrasos de v√°rios minutos em minha esta√ß√£o de trabalho.  Ap√≥s a investiga√ß√£o, descobriu-se que a causa do problema era uma trava, que poderia durar cinco minutos, durante os quais a fonte da trava girou basicamente em um ciclo de nove instru√ß√µes. <br><br>  √â muito importante escolher bons t√≠tulos para minhas postagens, mas lembrei-me imediatamente de que o nome apropriado "48 n√∫cleos s√£o bloqueados por nove instru√ß√µes" <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">j√°</a> foi <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">usado</a> [ <a href="https://habr.com/ru/post/472552/">tradu√ß√£o</a> em Habr√©] por uma postagem escrita h√° menos de um m√™s.  O n√∫mero de processadores bloqueados √© diferente e o ciclo √© um pouco mais longo, mas, na verdade, tudo isso faz voc√™ experimentar o d√©j√† vu.  Portanto, enquanto explico o novo problema encontrado, queria refletir sobre <em>por que isso acontece o tempo todo</em> . <br><br><h2>  Por que isso est√° acontecendo? </h2><br>  Grosso modo, tais problemas surgem como resultado de uma observa√ß√£o que chamarei <em>de Primeira Lei de Computa√ß√£o de Dawson:</em> <a href="https://twitter.com/BruceDawson0xB/status/1120381406700429312" rel="nofollow">O (n <sup>2</sup> ) √© um √≠m√£ para algoritmos que n√£o escalam bem</a> : s√£o r√°pidos o suficiente para entrar em produ√ß√£o, mas lentos o suficiente para estragar tudo, quando eles chegarem l√°. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/017/fb8/bea017fb89b90af6566d8ad77298efb9.png"></div><br>  <i>O (n <sup>2</sup> ) em a√ß√£o - dados extra√≠dos do meu caso</i> <br><a name="habracut"></a><br>  O que est√° havendo?  O desenvolvedor escreve o c√≥digo e usa o algoritmo O (n <sup>2</sup> ).  Talvez ele n√£o perceba isso, ou o algoritmo se torne O (n <sup>2</sup> ) <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">devido a um bug</a> , ou o desenvolvedor sabe que ele √© O (n <sup>2</sup> ), mas ele acha que isso nunca ser√° importante.  Em condi√ß√µes de laborat√≥rio, a velocidade do c√≥digo √© aceit√°vel e aceit√°vel para a maioria dos usu√°rios no mundo real, mas algu√©m cria <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">7.000 processos</a> com o App Verifier ativado ou cria um <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">arquivo bin√°rio com 180.000 elementos CFG</a> ou coleta uma DLL t√£o grande que √© <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1064219/ltcg-linking-of-chromes-pdf-dll-spends-60-of-time-in-c2-dll-ssrfree" rel="nofollow">constantemente uma lista vinculada √∫nica √© examinada</a> , o que leva todo o processador.  Ao trabalhar no tempo de inicializa√ß√£o do mecanismo Valve Source 2, encontrei <em>muitos</em> algoritmos O (n <sup>2</sup> ), cada um deles acrescentando cerca de 30 segundos ao tempo de inicializa√ß√£o do mecanismo, ou seja, esse problema ocorre com desenvolvedores muito diferentes. <br><br>  <em>O (n <sup>2</sup> ) √© um √≠m√£ para algoritmos que n√£o escalam bem: eles s√£o r√°pidos o suficiente para entrar em produ√ß√£o, mas lentos o suficiente para estragar tudo quando chegam l√°.</em> <br><br>  Exatamente. <br><br>  Por exemplo, a <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">cria√ß√£o dos nomes dos arquivos de log do App Verifier √© realizada em tempo linear</a> para cada processo em execu√ß√£o, e isso √© normal at√© voc√™ perceber que isso leva a O (n <sup>2</sup> ) se muitos processos estiverem em execu√ß√£o.  √Äs vezes, nem √© √≥bvio que existem loops aninhados, ou que <em>formalmente</em> n√£o √© O (n <sup>2</sup> ), ou n√£o √© √≥bvio que os loops podem correr por tanto tempo que podem afetar significativamente a velocidade ... <br><br>  Portanto, considere esta oportunidade, pense ao escrever c√≥digo, monitore como o desempenho √© dimensionado sob cargas pesadas e examine se√ß√µes suspeitas de c√≥digo ao criar um perfil dessas cargas pesadas.  Ou deixe comigo para que eu possa procur√°-los e escrever artigos no meu blog. <br><br><h2>  Vamos voltar √†s nossas reclama√ß√µes habituais </h2><br>  Como sempre, trabalhei na minha empresa trabalhando em minha esta√ß√£o de trabalho desatualizada, mas ainda poderosa, com 48 processadores l√≥gicos e 96 GB de RAM.  Eu introduzi o <em>ninja chrome</em> para criar o Chromium, mas ... nada aconteceu.  Olhei e esperei vinte segundos, mas a montagem nunca come√ßou.  Ent√£o, √© claro, mudei para o <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/" rel="nofollow"><em>UIforETW</em></a> para registrar o rastreamento <a href="https://randomascii.wordpress.com/2015/09/24/etw-central/" rel="nofollow"><em>ETW</em></a> .  Mais precisamente, tentei faz√™-lo.  Tentando iniciar a grava√ß√£o de rastreamento, o <em>UIforETW congela</em> .  Pela primeira vez no meu consult√≥rio, um bug usou medidas de prote√ß√£o para me impedir de explor√°-lo! <br><br>  Ap√≥s um ou dois minutos, a montagem do Chromium come√ßou e o <em>UIforETW</em> iniciou o rastreamento, mas come√ßou tarde demais e eu n√£o tinha as menores informa√ß√µes sobre o que aconteceu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/485/76e/b86/48576eb86c46f3254d1b891d180cc25e.png"></div><br>  <i>Op√ß√µes do UIforETW com rastreamento de buffer circular selecionado</i> <br><br>  Quando a mesma coisa aconteceu alguns dias depois, o <em>UIforETW</em> novamente n√£o conseguiu fazer nada.  Dessa vez, deixei o rastreamento para trabalhar em buffers de mem√≥ria circular, para estar preparado para o fato de que o travamento ocorreria pela terceira vez.  No entanto, isso reduziu bastante a velocidade das minhas ferramentas de constru√ß√£o, ent√£o, depois de algumas horas, desisti. <br><br>  Ent√£o essa situa√ß√£o se repetiu <em>novamente</em> .  Dessa vez, executei a ferramenta de <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>registro de</em></a> rastreamento ETW criada pela Microsoft - <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>wprui</em></a> e pude iniciar a grava√ß√£o.  Cerca de 40 segundos depois, a montagem come√ßou a funcionar e eu tenho um rastro! <br><br><h2>  Posso iniciar a investiga√ß√£o agora? </h2><br>  Anteriormente, notei no "Gerenciador de tarefas" que o <em>WinMgmt.exe</em> estava <em>sendo executado</em> durante esses <em>congelamentos</em> .  Observando os dados de Uso da CPU (Preciso) no WPA, eu estava convencido de que, ap√≥s mais de quarenta segundos, durante os quais o <em>WinMgmt.exe</em> era quase o √∫nico processo de trabalho, minha m√°quina ganhou vida depois que o <em>WinMgmt.exe foi desligado</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02a/cd4/35d/02acd435d1b3dec571ae9ebb5b56b67a.png"></div><br>  <i>Aguardamos o despertar dos processos ap√≥s a conclus√£o do WinMgmt.exe</i> <br><br>  Tudo isso √© bastante suspeito, mas meus s√°bios leitores sabem que "depois" n√£o significa "devido a" e exigir√° prova. <br><br>  Como na <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">√∫ltima vez</a> , aproximei o momento de desbloqueio no gr√°fico, classificando as altern√¢ncias de contexto por <em>Hora</em> da altern√¢ncia e procurando a primeira altern√¢ncia com um valor longo <em>desde o √∫ltimo tempo</em> (indicando o per√≠odo de tempo durante o qual o encadeamento n√£o foi executado).  Tendo perdido uma d√∫zia de threads que eram apenas tempos de inatividade curtos, encontrei o primeiro de muitos que esperou 41,57 segundos.  O encadeamento adormecido n√£o <em>ativou</em> o <em>WinMgmt.exe</em> , mas rapidamente descobri que ele acordou com o encadeamento que despertou o <em>WinMgmt.exe</em> uma fra√ß√£o de milissegundo antes. <br><br><blockquote>  Para obter uma explica√ß√£o dos gr√°ficos de uso da CPU (preciso) e dos conceitos de thread de prepara√ß√£o / novo segmento, consulte <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/" rel="nofollow">este tutorial</a> ou <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">esta documenta√ß√£o</a> . </blockquote><br>  Na captura de tela com os dados de troca de conte√∫do, a linha 17 cont√©m o fluxo <em>72.748 (WinMgmt.exe)</em> , que ativa o fluxo <em>74.156 (svchost.exe).</em>  Em seguida, na linha 19, o segmento <em>74.156 (svchost.exe)</em> ativa o segmento <em>58.704 (svchost.exe)</em> , que estava aguardando 41.57 segundos.  Este √© o primeiro fio que acorda ap√≥s um longo sono e a partir disso continua a cadeia de ativa√ß√£o dos fluxos.  Os encadeamentos que acabaram de ser ativados podem ser vistos na coluna <em>Novo ID do Encadeamento</em> , depois des√ßa algumas linhas e veja-os na coluna <em>Id do Encadeamento de Leitura</em> , ativando outro encadeamento.  Os nomes e os IDs do processo ajudam a entender o contexto.  A linha 17 est√° associada √†s linhas 18 e 19, a linha 19 est√° associada ao 20, que est√° associada √† linha 23, que est√° associada √† linha 27 e assim por diante;  cada segmento √© ativado pelo segmento anterior na cadeia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png"></div><br>  <i>O monstro desperta - longos fios ociosos ganham vida</i> <br><br>  41,57 √© muito tempo para bloquear um encadeamento, mas, na realidade, centenas de encadeamentos foram bloqueados e bloqueados por <em>muito</em> mais tempo.  O √∫nico motivo pelo qual o valor <em>Tempo desde o √∫ltimo</em> √© de cerca de 41,5 segundos √© porque a dura√ß√£o do rastreamento antes da interrup√ß√£o foi resolvida. <br><br>  Parece que os resultados s√£o consistentes com a teoria de que o problema est√° no <em>WinMgmt.exe</em> , mas n√£o o provam.  Minha confian√ßa aumentou quando olhei para <em>svchost.exe (3024)</em> em <em>Trace-&gt; System Configuration-&gt; Services</em> e descobri que √© um servi√ßo <em>Winmgmt</em> , mas ainda precisava de mais certeza. <br><br>  Tendo vasculhado um pouco mais (vagando para frente e para tr√°s no tempo), decidi que as intera√ß√µes s√£o muito complicadas para analis√°-las em detalhes, especialmente sem <a href="https://randomascii.wordpress.com/2015/10/26/thread-naming-in-windows-time-for-something-better/" rel="nofollow">nomes de fluxos</a> que possam sugerir o que 25 threads diferentes no <em>svchost.exe (3024)</em> est√£o fazendo. <br><br><h2>  Prova! </h2><br>  Decidi abordar a <em>prova de</em> culpa do <em>WinMgmt.exe de maneira</em> diferente.  Talvez valesse a pena come√ßar com isso, mas seria muito simples.  Peguei a linha de comando <em>WinMgmt.exe</em> da tabela <em>Processes</em> no WPA e a iniciei manualmente.  O comando tem o formato: <br><br><blockquote>  winmgmt.exe / Checkerrepository </blockquote><br>  e levou cerca de cinco minutos para ser conclu√≠do.  Enquanto funcionava (e eu tinha muito tempo), descobri que n√£o era poss√≠vel iniciar o rastreamento ETW no <em>UIforETW</em> .  Essa evid√™ncia era melhor do que qualquer an√°lise intricada que eu pudesse fazer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/c6f/d64/1a0c6fd64820226eddd120b5e9ab2ab7.png"></div><br>  <i>Configura√ß√£o para exibir apenas threads inativos h√° muito tempo</i> <br><br>  Em seguida, executei a reprodu√ß√£o novamente com o rastreamento j√° em execu√ß√£o;  Ap√≥s analisar o rastreamento, descobri mais de <em>cem</em> processos cujos threads foram bloqueados por mais de <em>cinco minutos!</em> <br><br><h2>  E novamente ao ponto ... </h2><br>  Por h√°bito, olhei novamente para os dados de Uso da CPU (Amostrado) para ver em que <em>WinMgmt.exe estava</em> perdendo tempo.  Eu rapidamente descobri que 96,5% das amostras estavam no <em>repdrvfs.dll! CPageCache :: Read ()</em> , chamado em quatro pilhas diferentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/7d9/5f1/5447d95f1b431681cdd83ad42df7e731.png"></div><br>  <i>Quatro caminhos que me levaram ao CPageCache :: Read</i> <br><br>  Uma √°rvore de pilhas completas para esta fun√ß√£o √© mostrada aqui, principalmente para pessoas da Microsoft que desejam pesquisar esse problema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e6/6b3/519/0e66b35191db016e98ded6eb08445569.png"></div><br>  <i>Pilhas completas que levam ao CPageCache :: Leia de tr√™s maneiras</i> <br><br>  Adicionei uma coluna de endere√ßo e descobri que 95,3% das amostras estavam em um ciclo de nove instru√ß√µes (as amostras sempre ca√≠am em apenas sete das nove instru√ß√µes (se voc√™ quiser saber o porqu√™, veja <a href="https://travisdowns.github.io/blog/2019/08/20/interrupts.html" rel="nofollow">aqui</a> ), mas o depurador mostrou o tamanho completo do ciclo) : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/8e6/04a/ecf8e604adbd110fdfaf77bb87dd378a.png"></div><br>  <i>Amostras por endere√ßo - sete endere√ßos muito "quentes"</i> <br><br>  Em seguida, iniciei o <em>winmgmt.exe / verifique o reposit√≥rio</em> manualmente e, ao <em>mesmo tempo</em> , <a href="https://randomascii.wordpress.com/2016/11/27/cpu-performance-counters-on-windows/" rel="nofollow">coletei dados do contador da CPU sobre as instru√ß√µes de ramifica√ß√£o que estavam sendo executadas</a> .  A partir disso, pude descobrir quantas vezes o loop foi executado.  Provavelmente isso n√£o era necess√°rio, mas eu queria ter certeza de que o loop fosse executado muitas vezes e n√£o fosse executado lentamente (por algum motivo).  Eu pensei que era muito legal poder fazer isso simplesmente, basta fazer uma <a href="" rel="nofollow">pequena altera√ß√£o</a> no arquivo em lotes.  Descobri que o <em>WinMgmt.exe</em> executava aproximadamente uma instru√ß√£o de ramifica√ß√£o por ciclo, ou seja, o ciclo (que, como eu j√° sabia, consumia a maior parte do tempo da CPU) era extremamente r√°pido e a desacelera√ß√£o se devia ao fato de ele ter rodado centenas de milh√µes vezes. <br><br><h2>  Atraso do Xperf </h2><br>  Por uma quest√£o de meticulosidade, decidi ver por que o <em>UIforETW</em> n√£o p√¥de iniciar o rastreamento durante esse incidente.  Aconteceu que o <em>UIforETW estava</em> executando o <em>xperf</em> , mas o <em>xperf ficou</em> inativo por 41,5 segundos (na verdade mais longo) nesta pilha de chamadas: <br><br><blockquote>  xperf.exe! wmain <br>  xperf.exe! CStopTrace :: Execute <br>  perfctrl.dll! LoggingSession :: EnumLoggers <br>  perfctrl.dll! LoggingSession :: LoggingSession <br>  perfctrl.dll! LoggingSession :: CreateProviderList <br>  perfctrl.dll! GetProviderInfoCache <br>  perfctrl.dll! CProviderInfoCache :: CProviderInfoCache <br>  tdh.dll! TdhfEnumerateProviders <br>  tdh.dll! TdhpWbemConnect <br>  wbemprox.dll! CLocator :: ConnectServer <br>  wbemprox.dll! CDCOMTrans :: DoActualConnection </blockquote><br>  Em resumo, o <em>xperf</em> √© chamado pelo <em>Wbem</em> e, portanto, √© bloqueado por esse problema.  <em>O xperf</em> tenta interromper o rastreamento antes de inici√°-lo, porque adicionei esse comportamento para tornar o <a href="https://github.com/google/UIforETW/commit/092fa4d3c30137eca658a86d58fc8230ced56c7c" rel="nofollow">in√≠cio do rastreamento mais tolerante a falhas</a> .  Suspeito que ainda ocorra um travamento, mas n√£o tenho certeza. <br><br><h2>  Criamos gr√°ficos de complexidade computacional </h2><br>  Percebi que o <em>WinMgmt.exe</em> verifica o <em>diret√≥rio</em> <em>c: \ windows \ System32 \ wbem \ Repository</em> , que √© de 1,9 GB na minha m√°quina, ent√£o perguntei no trabalho e no Twitter para saber quanto esse diret√≥rio leva para obter pontos de dados.  Tamb√©m pedi √†s pessoas para corrigir o tempo de execu√ß√£o de <em>winmgmt.exe / verifique o reposit√≥rio</em> e comecei a agendar.  Embora esses testes tenham sido realizados em m√°quinas completamente diferentes com diferentes velocidades de CPU, o gr√°fico ficou bem claro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/dd8/23d/539dd823d7fb9b33df39dc61f9e183dd.png"></div><br>  <i>A rela√ß√£o entre a raiz quadrada do tempo e o tamanho do reposit√≥rio</i> <br><br>  Este gr√°fico da propor√ß√£o entre sqrt (tempo) e tamanho do reposit√≥rio √© incrivelmente ideal para dados recebidos de seis m√°quinas diferentes e, no entanto, √© real.  Obviamente, a fun√ß√£o <em>VerifyRepository</em> tem desempenho O (n <sup>2</sup> ).  Se n for o tamanho do diret√≥rio Repository em <a href="https://randomascii.wordpress.com/2016/02/13/base-ten-for-almost-everything/" rel="nofollow">GB</a> , o <em>VerifyRepository</em> levar√° cerca de 1,6 * n <sup>2</sup> minutos.  Essa √© uma boa estimativa aproximada para todos os valores - de uma fra√ß√£o de segundo a dez minutos. <br><br><h2>  Relev√¢ncia </h2><br>  Ou tenho sorte ou sou apenas observador, porque por algumas semanas ningu√©m mais encontrou esse problema - pensei que coisas estranhas estavam acontecendo com meu carro.  Mas de repente comecei a ouvir queixas suspeitamente semelhantes de colegas.  Um deles tinha um reposit√≥rio de 2,6 GB, que levou dez minutos para verificar.  O problema afetou alguns de nossos desenvolvedores de <a href="https://en.wikipedia.org/wiki/Continuous_integration" rel="nofollow">IC</a> e, em graus diferentes, outras pessoas.  Meus colegas geralmente sabem que, em caso de problemas com o desempenho de m√°quinas Windows, preciso dizer isso para mim, no entanto, provavelmente existem muitos outros funcion√°rios do Google trabalhando no Windows que s√£o impedidos por esse bug, mas eles n√£o percebem isso. <br><br>  Felizmente, eu j√° comecei a trabalhar com nosso departamento de TI.  Encontrei o script que lan√ßou o <em>WinMgmt</em> e descobri que ele √© executado a cada hora.  Isso significava que minha m√°quina estava <em>executando o WinMgmt.exe / verifique o reposit√≥rio</em> 10% das vezes e alguns de meus colegas tinham mais de 16% das vezes.  H√° uma probabilidade bastante alta de obter um atraso de dez minutos antes da montagem. <br><br>  Quando os relat√≥rios come√ßaram a chegar, a corre√ß√£o j√° estava a caminho da produ√ß√£o.  O script era opcional e certamente n√£o valeu os problemas que causou, portanto a corre√ß√£o foi desativar a chamada. <br><br><h2>  Sum√°rio </h2><br>  <em>O winmgmt.exe / verificarepository</em> cont√©m um ciclo de nove instru√ß√µes, cujo n√∫mero de itera√ß√µes de execu√ß√£o √© proporcional ao quadrado do tamanho do <em>reposit√≥rio wbem</em> .  Por esse motivo, a execu√ß√£o do comando pode levar at√© dez minutos, embora na realidade deva ser executada em apenas alguns segundos.  Isso √© ruim em si mesmo. <br><br>  Pior ainda, a equipe executa um bloqueio WMI ( <a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page" rel="nofollow">Windows Management Instrumentation</a> ) durante sua opera√ß√£o; portanto, qualquer processo que execute opera√ß√µes WMI ser√° congelado. <br><br><h2>  Enigmas incr√≠veis </h2><br>  O script que <em>executava o winmgmt.exe / verifique o reposit√≥rio a</em> cada hora fazia isso por muitos anos, mas o comportamento problem√°tico come√ßou a aparecer apenas de um a dois meses atr√°s.  Presumivelmente, isso significa que o reposit√≥rio wbem recentemente se tornou muito maior.  Atrasos de 0,5 GB s√£o facilmente ignorados, mas a partir de 1,0 GB e acima eles j√° podem ser pesados.  Conforme <a href="https://twitter.com/itoleck/status/1192647636085592069" rel="nofollow">sugerido no Twitter,</a> executei <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings" rel="nofollow">strings.exe</a> para o arquivo objects.data.  Muitas das strings mais comuns cont√™m polmkr no nome, mas n√£o sei o que isso significa. <br><br>  <a href="https://twitter.com/BruceDawson0xB/status/1189979046135750657" rel="nofollow">Publiquei um relat√≥rio de bug no Twitter</a> e, a princ√≠pio, causou <a href="https://twitter.com/djammmer/status/1192634563421495297" rel="nofollow">algum movimento da equipe do WMI</a> , mas depois parei de receber respostas, ent√£o n√£o sei qual √© a situa√ß√£o agora. <br><br>  Gostaria de ver uma corre√ß√£o para o problema de desempenho e gostaria que nosso departamento de TI pudesse encontrar e corrigir o problema que torna nossos reposit√≥rios wbem t√£o grandes.  Mas, por enquanto, o departamento de TI prometeu n√£o executar o comando / Checkerrepository a cada hora a mais, o que deve nos ajudar a evitar os piores sintomas. <br><br><h2>  Refer√™ncias </h2><br><ul><li>  Uma lista geral de tutoriais, investiga√ß√µes e documenta√ß√£o da ETW est√° dispon√≠vel aqui: <a href="https://tinyurl.com/etwcentral" rel="nofollow">https://tinyurl.com/etwcentral</a> </li><li>  O tutorial Uso da CPU (Amostrado) (para descobrir em que tempo da CPU √© gasto) est√° <a href="https://randomascii.wordpress.com/2013/04/23/xperf-for-excess-cpu-consumption-wpa-edition/" rel="nofollow">aqui</a> e a documenta√ß√£o est√° <a href="https://randomascii.wordpress.com/2012/05/08/the-lost-xperf-documentationcpu-sampling/" rel="nofollow">aqui.</a> </li><li>  O tutorial Uso da CPU (Preciso) (para encontrar raz√µes pelas quais os threads n√£o podem ser executados) est√° <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/" rel="nofollow">aqui</a> e a documenta√ß√£o est√° <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">aqui.</a> </li><li>  Os links para artigos individuais s√£o fornecidos no corpo da postagem. Voc√™ tamb√©m pode encontr√°-los na minha categoria <a href="https://randomascii.wordpress.com/category/investigative-reporting/" rel="nofollow">Investigar relat√≥rios.</a> </li><li>  Outras hist√≥rias sobre algoritmos de O (n <sup>2</sup> ) podem ser lidas em <a href="https://accidentallyquadratic.tumblr.com/" rel="nofollow">Acidentalmente Quadr√°tico</a> </li></ul><br>  Uma discuss√£o do artigo no Reddit est√° <a href="https://www.reddit.com/r/programming/comments/e87dpb/on2_again_now_in_wmi/" rel="nofollow">aqui</a> , uma discuss√£o sobre not√≠cias de hackers est√° <a href="https://news.ycombinator.com/item%3Fid%3D21743424" rel="nofollow">aqui</a> , uma discuss√£o no Twitter est√° <a href="https://twitter.com/BruceDawson0xB/status/1203905010716643328" rel="nofollow">aqui</a> e <a href="https://twitter.com/BruceDawson0xB/status/1203905010716643328" rel="nofollow">,</a> possivelmente, <a href="https://twitter.com/BruceDawson0xB/status/1203922370957721600" rel="nofollow">aqui</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479498/">https://habr.com/ru/post/pt479498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479482/index.html">SARIF SDK e seus erros</a></li>
<li><a href="../pt479486/index.html">Programa√ß√£o heterog√™nea e oneAPI Toolkit. Palestra improvisada de especialistas da Intel responde √†s suas perguntas</a></li>
<li><a href="../pt479488/index.html">De um laptop - um servidor dom√©stico com energia redundante ao roteador Mikrotik</a></li>
<li><a href="../pt479492/index.html">Computa√ß√£o sem servidor baseada no OpenWhisk, parte 3</a></li>
<li><a href="../pt479496/index.html">Analisando tarefas WTF em JavaScript</a></li>
<li><a href="../pt479502/index.html">Como sobreviver √† era glacial mais severa da hist√≥ria da Terra?</a></li>
<li><a href="../pt479504/index.html">Criar um Thin Client RDP baseado em Raspberry Pi</a></li>
<li><a href="../pt479508/index.html">Antipadr√µes do PostgreSQL: JOINs e ORs prejudiciais</a></li>
<li><a href="../pt479510/index.html">Revis√£o do PocketBook X - um enorme leitor de 10,3 polegadas com uma tela E Ink Carta Mobius e uma caixa de metal</a></li>
<li><a href="../pt479512/index.html">MVCC no PostgreSQL-4. Instant√¢neos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>