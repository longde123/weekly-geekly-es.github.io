<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥇 🧑🏼 👩🏻‍⚕️ 实验室：在Linux上配置LVM和RAID 🎿 🤚🏿 🙇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="一个小题外话：这是综合的。 


 这里描述的某些任务可以轻松完成，但是由于l / r的任务是要熟悉raid，lvm功能，因此某些操作是人为地复杂的。 
 执行l \ r的工具要求： 


- 虚拟化工具（例如Virtualbox） 
- Linux安装映像，例如Debian9 
- Interne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>实验室：在Linux上配置LVM和RAID</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450896/"><p> 一个小题外话：这是综合的。 </p><br><p> 这里描述的某些任务可以轻松完成，但是由于l / r的任务是要熟悉raid，lvm功能，因此某些操作是人为地复杂的。 </p><br><h2 id="trebovaniya-k-instrumentam-dlya-vypolneniya-lr"> 执行l \ r的工具要求： </h2><br><ul><li> 虚拟化工具（例如Virtualbox） </li><li>  Linux安装映像，例如<a href="">Debian9</a> </li><li>  Internet可供下载多个软件包 </li><li> 通过ssh连接到已安装的VM（可选） </li></ul><br><h2 id="vnimanie"> 注意事项 </h2><br><p> 这项实验室工作与诸如数据安全性之类的微妙问题相关联。在这个区域中，由于最小的错误（一个额外的字母或数字），您可以丢失所有数据。 </p><br><p> 由于您正在做实验室工作，因此您没有危险，除非您必须重新开始。 </p><br><p> 在现实生活中，所有事情都更加严重，因此您应该非常仔细地输入磁盘的名称，了解当前命令正在执行的操作以及使用的磁盘。 </p><a name="habracut"></a><br><p> 第二个重点是磁盘和分区的命名：根据情况，磁盘号可能与实验室命令中显示的值不同。 <br> 因此，例如，如果从阵列中删除sda驱动器，然后添加新驱动器，则新驱动器将以sda名称显示在系统上。 如果在添加新磁盘之前重新引导，则新磁盘将命名为sdb，而旧磁盘将命名为sda </p><br><p> 实验室工作应该在超级用户（root）下完成，因为大多数命令都需要提升的特权，而通过sudo不断提升特权是没有意义的。 </p><br><h2 id="materialy-dlya-izucheniya"> 学习资料 </h2><br><ul><li> 磁盘阵列 </li><li>  LVM </li><li>  Linux磁盘命名 </li><li> 什么是节 </li><li> 什么是分区表及其存储在哪里 </li><li> 什么是g </li></ul><br><h2 id="ispolzuemye-utility"> 实用工具 </h2><br><ol><li> 查看磁盘信息： <br><ul><li>  lsblk -o名称，大小，FSTYPE，TYPE，MOUNTPOINT </li><li>  fdisk -l </li></ul></li><li> 查看信息并使用LVM <br><ul><li> 聚苯乙烯 </li><li>  pvextend </li><li>  pvcreate </li><li> 大小 </li><li>  vgs </li><li>  vgreduce </li><li>  lvs </li><li>  lvextend </li></ul></li><li> 查看信息并使用RAID： <br><ul><li>  cat / proc / mdstat </li><li>  mdadm </li></ul></li><li> 挂载点： <br><ul><li> 坐骑 </li><li> 数量 </li><li> 猫/等/ fstab </li><li> 猫/等/ mtab </li></ul></li><li> 重新分区磁盘： <br><ul><li>  fdisk /开发/ XXX </li></ul></li><li> 复制部分： <br><ul><li>  dd if = / dev / xxx of = / dev / yyy </li></ul></li><li> 使用分区表： <br><ul><li> 零件 </li><li> 磁盘 </li><li>  mkfs.ext4 </li></ul></li><li> 使用引导程序： <br><ul><li>  grub-install / dev / XXX </li><li> 更新grub </li></ul></li><li> 杂项 <br><ul><li>  lsof </li><li> 贴切 </li><li> 同步 </li></ul></li></ol><br><h2 id="laboratornaya-rabota-sostoit-iz-3-h-chastey"> 实验室工作包括3个部分： </h2><br><ul><li> 使用lvm和raid配置运行状况良好的系统。 </li><li> 模拟其中一个驱动器的故障。 </li><li> 快速更换磁盘，并添加新磁盘和分区传输。 </li></ul><br><h2 id="zadanie-1-ustanovka-os-i-nastroyka-lvm-raid"> 任务1（安装操作系统并配置LVM，RAID） </h2><br><ol><li><p> 创建具有以下功能的新虚拟机： </p><br><ul><li>  1 GB内存 </li><li>  1个CPU </li><li>  2个硬盘（将其命名为ssd1，ssd2并分配相同的大小，请选中热插拔和ssd框） </li><li> 在4个端口上配置的SATA控制器： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/6f5/be6/18f6f5be6afbc13138abc3dfe960813b.png" alt="选择ssd磁盘"></li></ul><br></li><li><p> 开始安装Linux并选择硬盘驱动器，请执行以下操作： </p><br><ul><li> 分区方法：手动，之后应看到下图： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/77a/eb5/3a1/77aeb53a1de2bc7b91d1396dc9b4148e.png" alt="分区磁盘"></li><li> 在/ boot下设置一个单独的分区：选择第一个磁盘并在其上创建一个新的分区表： <br><ul><li> 分区大小：512M </li><li> 挂载点：/开机 </li></ul></li><li> 重复第二张磁盘的设置，但是由于您无法同时进行两次挂载/引导，因此选择挂载点：无，最后得到以下内容（带有边框的图片，重做懒惰）： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3db/2f0/e48/3db2f0e48423f182016bde06c39dfb8d.png" alt="分区磁盘"></li><li>  RAID设置： </li><li> 选择第一个磁盘上的可用空间，然后将RAID的物理卷配置为分区类型。 </li><li> 选择“完成设置分区” </li><li> 对第二张磁盘重复完全相同的设置，结果如下： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93f/37c/ec3/93f37cec319d628a3267f94d138145e7.png" alt="分区磁盘"></li><li> 选择“配置软件RAID” <br><ul><li> 创建MD设备 </li><li> 软件RAID设备类型：选择镜像阵列 </li><li>  RAID XXXX阵列的活动设备：选择两个驱动器 </li><li> 备用设备：默认为0 </li><li>  RAID XX阵列的活动设备：选择在raid下创建的分区 </li><li> 完成 </li></ul></li><li> 最后，您应该得到以下图片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a7/9b0/3f5/7a79b03f556925d1fd53ccc4ca77b494.png" alt="分区磁盘"></li><li>  LVM设置：选择配置逻辑卷管理器 </li><li> 保留当前分区布局并配置LVM：是 </li><li> 创建卷组 </li><li> 卷组名称：系统 </li><li> 新卷组的​​设备：选择创建的RAID </li><li> 创建逻辑卷 <br><ul><li> 逻辑卷名称：root </li><li> 逻辑卷大小：磁盘大小的2 \ 5 </li></ul></li><li> 创建逻辑卷 <br><ul><li> 逻辑卷名称：var </li><li> 逻辑卷大小：磁盘大小的2 \ 5 </li></ul></li><li> 创建逻辑卷 <br><ul><li> 逻辑卷名称：日志 </li><li> 逻辑卷大小：磁盘大小的1 \ 5 </li></ul></li><li> 选择显示配置详细信息，您应该得到以下图片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/8dd/11f/0b88dd11f9372dbf8e53a6727fc69b27.png" alt="分区磁盘"></li><li> 完成LVM配置后，您应该看到以下内容： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/9d4/00d/72b9d400d9b83392c759b7aeb3e9d573.png" alt="分区磁盘"></li><li> 分区：依次选择在LVM中创建的每个卷并对其进行分区，例如，对于root这样： <br><ul><li> 用作：ext4 </li><li> 挂载点：/ </li></ul></li><li> 标记根分区的结果应如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/225/61e/0be/22561e0be2cd905e0948a63ae3460461.png" alt="分区磁盘"></li><li> 通过选择适当的安装点（手动输入/ var和/ var / log）对var和log重复标记操作，得到以下结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/58c/756/5da58c756fd8d205a93ebfd49acc396f.png" alt="分区磁盘"></li><li> 选择完成分区 </li><li> 系统将询问您一些问题，您仍然有一个已卸载的分区，并且未配置交换。 这两个问题均应否定回答。 </li><li> 最终结果应如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/117/381/a61/117381a61b766df3c89d2646baa2b33d.png" alt="分区磁盘"></li></ul><br></li><li><p> 通过在第一台设备（sda）上安装grub来完成操作系统的安装并引导系统。 </p><br></li><li><p> 将/引导分区的内容从sda（ssd1）驱动器复制到sdb（ssd2）驱动器 </p><br><pre><code class="plaintext hljs">dd if=/dev/sda1 of=/dev/sdb1</code> </pre> <br></li><li><p> 在第二台设备上安装grub： </p><br><ul><li><p> 查看系统中的驱动器： </p><br><pre> <code class="plaintext hljs">fdisk -l lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br></li><li> 列出上一个命令发布给您的所有磁盘，并描述它是哪种磁盘。 </li><li><p> 找到未安装grub的驱动器，然后完成此安装： </p><br><pre> <code class="plaintext hljs">grub-install /dev/sdb</code> </pre> <br></li><li> 使用cat / proc / mdstat查看当前团队，并写下您看到的内容。 </li><li> 查看命令的输出：pvs，vgs，lvs，安装并写下您所看到的内容。 </li></ul><br></li></ol><br><p> 用自己的语言描述完成任务后您做了什么以及得到了什么结果。 </p><br><p> 完成此任务后，建议您使用虚拟机备份文件夹或创建一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无用信息框</a> 。 </p><br><p> 结果：具有ssd1，ssd2磁盘的虚拟机。 </p><br><h2 id="zadanie-2-emulyaciya-otkaza-odnogo-iz-diskov"> 任务2（模拟其中一个驱动器的故障） </h2><br><ol><li> 如果选中了热插拔复选框，则可以即时删除磁盘： <br><ul><li> 在计算机属性中删除ssd1驱动器。 </li><li> 找到虚拟机文件的存储目录，然后删除ssd1.vmdk。 </li></ul></li><li> 确保您的虚拟机仍在运行。 </li><li> 重新启动虚拟机，并确保它仍然可以工作 </li><li> 检查RAID阵列的状态： <code>cat /proc/mdstat</code> </li><li> 在VM接口中添加相同大小的新磁盘，并将其命名为ssd3。 </li><li> 执行操作： <br><ul><li> 使用<code>fdisk -l</code>查看进入系统的新磁盘 </li><li> 将分区表从旧磁盘复制到新磁盘： <code>sfdisk -d /dev/XXXX | sfdisk /dev/YYY</code> <code>sfdisk -d /dev/XXXX | sfdisk /dev/YYY</code> </li><li> 使用<code>fdisk -l</code>查看结果 </li><li> 将一个新磁盘添加到raid数组： <code>mdadm --manage /dev/md0 --add /dev/YYY</code> </li><li> 查看结果： <code>cat /proc/mdstat</code> 。 您应该看到同步已经开始。 </li></ul></li><li><p> 现在，您需要手动同步不属于RAID的分区。 为此，我们将使用dd实用程序，将其从“活动”磁盘复制到您最近安装的新磁盘： </p><br><pre> <code class="plaintext hljs">dd if=/dev/XXX of=/dev/YYY</code> </pre> <br></li><li> 同步完成后，在新磁盘上安装grub。 </li><li> 重新启动VM，以确保一切正常。 </li></ol><br><p> 用自己的语言描述完成任务后您做了什么以及得到了什么结果。 </p><br><p>  <strong>结果：</strong>卸下了ssd1驱动器，保存了ssd2驱动器，添加了ssd3驱动器。 </p><br><h2 id="zadanie-3-dobavlenie-novyh-diskov-i-perenos-razdela"> 任务3（添加新磁盘和分区） </h2><br><p> 这是所有提出的最困难和最艰巨的任务。 仔细检查您在做什么以及使用哪些磁盘和分区。 建议您在执行之前制作一份副本。 无论任务2是什么，此任务都可以在任务1之后执行，并根据磁盘名称进行调整。 </p><br><p> 该实验室分配的第二部分应进入与完成第一部分后完全相同的状态。 </p><br><p> 为了使您更轻松地工作，我建议您不要从主机上物理删除磁盘，而只是在计算机的属性中断开它们的连接。 从VM中的OS的角度来看，这看起来完全相同，但是在这种情况下，可以将驱动器连接回去，并通过回滚几个点来继续工作（以防万一）。 例如，您可能执行不正确或忘记将/ boot分区复制到新磁盘。 我只能建议您仔细检查您正在使用的磁盘和分区，甚至更好的是，在一张纸上写下磁盘，分区和“物理”磁盘编号的对应关系。  <code>lsblk</code>命令绘制一棵美丽且易于理解的树，并尽可能多地使用它来分析您已完成的工作和需要完成的工作。 </p><br><p> 故事... </p><br><p> 想象一下，您的服务器在2个ssd磁盘上工作了很长时间，突然之间... </p><br><ol><li><p> 通过从VM属性中删除磁盘并重新引导来模拟ssd2磁盘故障。 </p><br></li><li><p> 查看磁盘和RAID的当前状态： </p><br><pre> <code class="plaintext hljs">cat /proc/mdstat fdisk -l lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br></li><li><p> 您很幸运-当局允许购买几张新光盘： </p><br><p>  2个SATA大容量卷，用于将日志部分移动到单独的磁盘上的长期任务。  2个SSD替换死者，以及替换仍在运行的SSD。 </p><br><p> 请记住，服务器的存储篮仅支持安装4个驱动器。 同时，因此您无法一次添加所有磁盘。 </p><br><p> 选择的HDD的容量是SSD的2倍。 <br>  SSD的容量选择为以前SSD的1.25倍。 </p><br></li><li><p> 添加一个新的ssd驱动器，将其命名为ssd4，并在添加后检查发生了什么： </p><br><pre> <code class="plaintext hljs">fdisk -l lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br></li><li><p> 首先，您应该注意旧磁盘数据的安全性。 这次我们将使用LVM传输数据： </p><br><ul><li><p> 首先，您需要将文件表从旧磁盘复制到新磁盘： </p><br><pre> <code class="plaintext hljs">sfdisk -d /dev/XXX | sfdisk /dev/YYY</code> </pre> <br><p> 替换正确的磁盘而不是x，y，然后弄清楚此命令的作用。 </p><br></li><li> 运行lsblk -o NAME，SIZE，FSTYPE，TYPE，MOUNTPOINT，并将其输出与上一个调用进行比较。 有什么变化？ </li><li><p> 使用dd命令将/ boot数据复制到新磁盘： </p><br><pre> <code class="plaintext hljs">dd if=/dev/XXX of=/dev/YYY</code> </pre> <br></li><li><p> 如果/ boot仍安装在旧驱动器上，则应将其安装在活动驱动器上： </p><br><pre> <code class="bash hljs">mount | grep boot <span class="hljs-comment"><span class="hljs-comment">#     lsblk #           ,     umount /boot #  /boot mount -a #      /etc/fstab. #      /dev/sda,        </span></span></code> </pre> <br></li><li><p> 在新的ssd驱动器上安装引导程序： </p><br><pre> <code class="plaintext hljs">grub-install /dev/YYY</code> </pre> <br><p> 我们为什么要执行此操作？ </p><br></li><li><p> 创建一个新的RAID阵列，其中仅包含一个新的ssd驱动器： </p><br><pre> <code class="plaintext hljs">mdadm --create --verbose /dev/md63 --level=1 --raid-devices=1 /dev/YYY</code> </pre> <br><p> 如果没有指定特殊键，以上命令将无法使用，请阅读帮助并将其添加到命令中。 </p><br></li><li> 使用cat / proc / mdstat命令来验证操作结果。 有什么变化？ </li><li> 运行lsblk -o NAME，SIZE，FSTYPE，TYPE，MOUNTPOINT，并将其输出与上一个调用进行比较。 有什么变化？ </li></ul><br></li><li><p> 下一步是配置LVM </p><br><ul><li> 运行pvs命令以查看有关当前物理卷的信息。 </li><li><p> 通过在其中包含先前创建的RAID阵列来创建新的物理卷： </p><br><pre> <code class="plaintext hljs">pvcreate /dev/md63</code> </pre> <br></li><li> 运行lsblk -o NAME，SIZE，FSTYPE，TYPE，MOUNTPOINT，并将其输出与上一个调用进行比较。 有什么变化？ </li><li> 再次运行pvs命令。 有什么变化？ </li><li><p> 使用以下命令增加卷组系统的大小： </p><br><pre> <code class="plaintext hljs">vgextend system /dev/md63</code> </pre> <br></li><li><p> 运行命令并写下您看到的内容和更改的内容。 </p><br><pre> <code class="plaintext hljs">vgdisplay system -v pvs vgs lvs -a -o+devices</code> </pre> <br><p>  LV var，日志，root现在在哪个物理磁盘上？ </p><br></li><li><p> 通过替换正确的设备名称，将数据从旧驱动器移动到新驱动器。 </p><br><pre> <code class="plaintext hljs">pvmove -i 10 -n /dev/system/root /dev/md0 /dev/md63</code> </pre> <br><p> 对所有逻辑卷重复该操作。 </p><br></li><li><p> 运行命令并写下您看到的内容和更改的内容。 </p><br><pre> <code class="plaintext hljs">vgdisplay system -v pvs vgs lvs -a -o+devices lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br></li><li><p> 通过移除旧团队来更改我们的VG。 替换正确的团队名称。 </p><br><pre> <code class="plaintext hljs">vgreduce system /dev/md0</code> </pre> <br></li><li><p> 运行命令并写下您看到的内容和更改的内容。 </p><br><pre> <code class="plaintext hljs">lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT pvs vgs</code> </pre> <br></li><li> 为了使图片美观，请重新安装/引导到第二个ssd驱动器（ssd4），然后运行lsblk。 因此，ssd3磁盘上不应安装任何东西。 仔细检查/ boot分区是否为空！  <code>ls /boot</code>应该显示几个文件和文件夹。 检查此部分中存储的内容，并记下哪个文件/目录负责什么。 </li></ul><br></li><li><p> 取出ssd3磁盘并根据上述TK添加ssd5，hdd1，hdd2，最终得到： </p><br><ul><li>  ssd4-第一个新的ssd </li><li>  ssd5-第二个新的ssd </li><li>  hdd1-第一个新硬盘 </li><li>  HDD2-第二个新HDD </li></ul><br></li><li><p> 检查添加磁盘后发生了什么： </p><br><pre> <code class="plaintext hljs">fdisk -l lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br></li><li><p> 让我们还原主要的raid数组： </p><br><ul><li><p> 复制分区表，替换正确的磁盘： </p><br><pre> <code class="plaintext hljs">sfdisk -d /dev/XXX | sfdisk /dev/YYY</code> </pre> <br></li><li><p> 请注意，当我们从旧磁盘复制分区表时，事实证明新大小不会占用整个硬盘空间。 因此，很快我们将需要调整此部分的大小并扩展raid。 通过输入以下命令亲自查看： </p><br><pre> <code class="plaintext hljs">lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br></li></ul><br></li><li><p> 将/ boot引导分区从ssd4复制到ssd5： </p><br><pre> <code class="plaintext hljs">dd if=/dev/XXX of=/dev/YYY</code> </pre> <br></li><li><p> 在新磁盘（ssd5）上安装grub。 </p><br></li><li><p> 更改ssd5驱动器的第二个分区的大小。 </p><br><ul><li><p> 运行该实用程序以处理磁盘布局： </p><br><pre> <code class="plaintext hljs">fdisk /dev/XXX</code> </pre> <br></li><li> 输入d键以删除现有分区（选择2）。 </li><li> 输入n键创建一个新分区。 </li><li> 输入键p以指示主分区的类型。 </li><li> 输入密钥2，以便新分区具有第二个数字。 </li><li> 第一个扇区：按Enter键以接受自动计算的部分起始尺寸。 </li><li> 最后一个扇区：按Enter键以接受自动计算的末端尺寸。 </li><li> 输入l键以查看所有可能的分区类型的列表，并在其中找到Linux raid auto。 </li><li> 输入键t更改创建的分区的类型（2），然后输入在上一步中找到的数字。 </li><li> 输入w键将更改写入磁盘。 </li></ul><br></li><li><p> 重新读取分区表并检查结果： </p><br><pre> <code class="plaintext hljs">partx -u /dev/XXX lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br><ul><li><p> 将新磁盘添加到当前RAID阵列（不要忘记替换正确的磁盘）： </p><br><pre> <code class="plaintext hljs">mdadm --manage /dev/md63 --add /dev/sda2</code> </pre> <br></li><li><p> 我们将阵列中的磁盘数扩展为2个： </p><br><pre> <code class="plaintext hljs">mdadm --grow /dev/md63 --raid-devices=2</code> </pre> <br></li><li><p> 看一下结果：我们标记了2个数组，但是此数组中包含的两个部分的大小都不同： </p><br><pre> <code class="plaintext hljs">lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br></li></ul><br></li><li><p> 增加ssd4磁盘上分区的大小 </p><br><ul><li><p> 运行该实用程序以处理磁盘布局： </p><br><pre> <code class="plaintext hljs">fdisk /dev/XXX</code> </pre> <br></li><li> 输入d键以删除现有分区（选择2）。 </li><li> 输入n键创建一个新分区。 </li><li> 输入键p以指示主分区的类型。 </li><li> 输入密钥2，以便新分区具有第二个数字。 </li><li> 第一个扇区：按Enter键以接受自动计算的部分起始尺寸。 </li><li> 最后一个扇区：按Enter键以接受自动计算的末端尺寸。 </li><li> 在标记的最后，选择“否”以保留该部分属于数组的签名。 </li><li> 输入w键将更改写入磁盘。 </li></ul><br></li><li><p> 我们重新读取分区表并检查结果。 </p><br><pre> <code class="plaintext hljs">partx -u /dev/XXX lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT</code> </pre> <br><p> 请注意，现在sda2，sdc2分区大于RAID设备的大小。 </p><br></li><li><p> 现在，可以扩大团队规模： </p><br><pre> <code class="bash hljs">mdadm --grow /dev/md63 --size=max lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT <span class="hljs-comment"><span class="hljs-comment"># check result</span></span></code> </pre> <br><p> 浏览lsblk并写下已更改的内容。 </p><br></li><li><p> 但是，即使我们更改了raid的大小，vg root，var，log本身的大小也没有改变。 </p><br><ul><li><p> 看一下PV的大小是多少： </p><br><pre> <code class="bash hljs">pvs</code> </pre> <br></li><li><p> 扩大我们的光伏发电规模： </p><br><pre> <code class="bash hljs">pvresize /dev/md63</code> </pre> <br></li><li><p> 看一下PV的大小是多少： </p><br><pre> <code class="bash hljs">pvs</code> </pre> <br></li></ul><br></li><li><p> 添加新出现的地方VG var，root： </p><br><pre> <code class="bash hljs">lvs <span class="hljs-comment"><span class="hljs-comment">#     lvextend -l +50%FREE /dev/system/root lvextend -l +100%FREE /dev/system/var lvs #   </span></span></code> </pre> <br><p> 至此，您已经完成了将主阵列迁移到新磁盘的操作。 使用ssd1，ssd2完成。 </p><br></li><li><p> 我们的下一个任务是将/ var / log移至新驱动器，为此，我们将在hdd驱动器上创建一个新的阵列和lvm。 </p><br><ul><li><p> 我们来看一下新硬盘驱动器的名称： </p><br><pre> <code class="bash hljs">fdisk -l</code> </pre> <br></li><li><p> 创建一个RAID数组： </p><br><pre> <code class="bash hljs">mdadm --create /dev/md127 --level=1 --raid-devices=2 /dev/sdc /dev/sdd</code> </pre> <br></li><li><p> 从大型磁盘的RAID中创建新的PV： </p><br><pre> <code class="bash hljs">pvcreate data /dev/md127</code> </pre> <br></li><li><p> 在此PV中，创建一个名为data的组： </p><br><pre> <code class="bash hljs">vgcreate data /dev/md127</code> </pre> <br></li><li><p> 创建一个具有所有可用空间大小的逻辑卷，并将其称为val_log： </p><br><pre> <code class="bash hljs">lvcreate -l 100%FREE -n var_log data <span class="hljs-comment"><span class="hljs-comment"># lvs #  </span></span></code> </pre> <br></li><li><p> 在ext4中格式化创建的分区： </p><br><pre> <code class="bash hljs">mkfs.ext4 /dev/mapper/data-var_log</code> </pre> <br></li><li><p> 让我们看看结果： </p><br><pre> <code class="bash hljs">lsblk</code> </pre> <br></li></ul><br></li><li><p> 将日志数据从旧部分传输到新部分 </p><br><ul><li><p> 我们将安装一个临时的新日志存储： </p><br><pre> <code class="plaintext hljs">mount /dev/mapper/data-var_log /mnt</code> </pre> <br></li><li><p> 让我们同步这些部分： </p><br><pre> <code class="bash hljs">apt install rsync rsync -avzr /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/ /mnt/</code> </pre> <br></li><li><p> 使用/ var /立即找出正在运行的进程： </p><br><pre> <code class="bash hljs">apt install lsof lsof | grep <span class="hljs-string"><span class="hljs-string">'/var/log'</span></span></code> </pre> <br></li><li><p> 我们停止以下过程： </p><br><pre> <code class="bash hljs">systemctl stop rsyslog.service syslog.socket</code> </pre> <br></li><li><p> 我们将对分区（自上次同步以来可能已更改的数据）执行最终同步： </p><br><pre> <code class="bash hljs">rsync -avzr /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/ /mnt/</code> </pre> <br></li><li><p> 交换部分： </p><br><pre> <code class="bash hljs">umount /mnt umount /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> mount /dev/mapper/data-var_log /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span></code> </pre> <br></li><li><p> 检查发生了什么： </p><br><pre> <code class="bash hljs">lsblk</code> </pre> <br></li></ul><br></li><li><p> 编辑/ etc / fstab </p><br><p>  fstab-一个文件，其中根据启动时将挂载的分区写入规则。 我们的任务是找到安装/ var / log的行，并将<code>system-log</code>设备固定为<code>data-var_log</code> 。 </p><br></li><li><p> 在此阶段最重要的事情是记住要更改分区表（例如，ext4）。 由于无论我们如何更改各种raid，lvm-在通知分区上的文件系统分区大小已更改之前，我们将无法使用新空间。 使用<code>resize2fs</code>命令更改FS。 </p><br></li><li><p> 最终和弦 </p><br><ul><li> 让我们重启。 如果一切操作正确，您将再次在操作系统中找到自己（这是确保一切正常的必要步骤。除自检外，此步骤没有任何意义） </li><li><p> 检查我们想要做的所有事情是否真的完成了： </p><br><pre> <code class="bash hljs">pvs lvs vgs lsblk cat /proc/mdstat</code> </pre> <br></li></ul><br></li><li><p>  [可选]按照步骤 </p><br><ul><li> 在启动时按F12指示不同的磁盘来重新启动，以确保您可以从任何ssd磁盘启动，因此我们不怕其中一个失败。 </li><li><p> 现在，您在VG系统中有了不必要的LV日志。 在root或var之间分配此空间，但不要使用100％FREE构造，而是使用-L开关用手指定大小： </p><br><pre> <code class="bash hljs">-L 500M</code> </pre> <br></li><li> 解决以下问题：/引导位于两个没有同步的分区上，您不需要以正确的方式执行此操作，此处将其作为示例添加。 不要忘记将/ boot的内容复制到某个地方。 </li><li> 创建一个新的raid，并在其中包含sda1，sda2。 </li><li> 将这些分区包括在您现有的RAID中，并基本上进行RAID的恢复/引导，但不再安装它。 </li></ul><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450896/">https://habr.com/ru/post/zh-CN450896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450886/index.html">背景：氢能汽车如何工作以及何时出现在道路上</a></li>
<li><a href="../zh-CN450888/index.html">斯威夫特：灵异筛</a></li>
<li><a href="../zh-CN450890/index.html">Google I / O新闻2019：Pixel 3a，Android Q，Kotlin等</a></li>
<li><a href="../zh-CN450892/index.html">存储速度适合etcd吗？ 询问</a></li>
<li><a href="../zh-CN450894/index.html">关于最小的天线</a></li>
<li><a href="../zh-CN450898/index.html">在多个屏幕上进行界面开发。 使用AI的步骤</a></li>
<li><a href="../zh-CN450902/index.html">想要忠诚的员工-从自己开始</a></li>
<li><a href="../zh-CN450904/index.html">将dockerized ASP.NET Core应用程序部署到Heroku的实用性</a></li>
<li><a href="../zh-CN450906/index.html">如何开始生菜</a></li>
<li><a href="../zh-CN450908/index.html">星号黑名单网络</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>