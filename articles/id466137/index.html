<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüë¶ üì¥ ü¶î System.IO. Pipelines - alat yang sedikit dikenal bagi pecinta kinerja tinggi ü§öüèº üíÖüèæ üë©üèª‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo pembaca. Sudah cukup banyak waktu berlalu sejak rilis .NET Core 2.1. Dan inovasi keren seperti Span dan Memori sudah banyak dikenal, Anda dapat m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO. Pipelines - alat yang sedikit dikenal bagi pecinta kinerja tinggi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466137/">  Halo pembaca.  Sudah cukup banyak waktu berlalu sejak rilis .NET Core 2.1.  Dan inovasi keren seperti Span dan Memori sudah banyak dikenal, Anda dapat membaca, melihat, dan mendengar banyak tentangnya.  Namun, sayangnya, perpustakaan bernama System.IO. Pipeslines tidak menerima perhatian yang sama.  Hampir semua yang ada pada topik ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu-satunya posting</a> yang telah diterjemahkan dan disalin pada banyak sumber.  Seharusnya ada lebih banyak informasi tentang teknologi itu untuk melihatnya dari sudut yang berbeda. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Jadi, perpustakaan ini bertujuan untuk mempercepat pemrosesan data streaming.  Awalnya dibuat dan digunakan oleh tim pengembangan Kestrel (server web lintas-platform untuk ASP.NET Core), tetapi saat ini tersedia untuk manusia melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket nuget</a> . <br><br>  Sebelum kita mempelajari topik ini, kita dapat membayangkan mekanisme perpustakaan sebagai analog MemoryStream yang ditingkatkan.  Masalah dengan MemoryStream asli adalah jumlah salinan yang berlebihan, yang jelas jika Anda ingat bahwa array byte pribadi digunakan di dalam MemoryStream sebagai buffer.  Misalnya, dalam metode <a href="">Baca</a> dan <a href="">Tulis,</a> Anda dapat dengan jelas melihat penyalinan data.  Jadi, untuk objek yang ingin kita tulis ke aliran, salinan akan dibuat di buffer internal, dan selama membaca, salinan salinan internal akan dikembalikan ke konsumen.  Sepertinya ini bukan penggunaan memori yang paling rasional. <br><br>  System.IO.Pipelines tidak bertujuan untuk mengganti semua stream, ini adalah alat tambahan dalam gudang pengembang yang menulis kode kinerja tinggi.  Saya menyarankan agar Anda membiasakan diri dengan metode dan kelas dasar, melihat detail implementasi mereka dan menganalisis contoh-contoh dasar. <br><br>  Mari kita mulai dengan detail internal dan implementasi, pada saat yang sama melihat fragmen kode sederhana.  Setelah itu, akan menjadi jelas bagaimana cara kerjanya dan bagaimana seharusnya digunakan.  Ketika bekerja dengan System.IO.Pipelines, perlu diingat bahwa konsep dasarnya adalah bahwa semua operasi baca-tulis harus dilakukan tanpa alokasi tambahan.  Tetapi beberapa metode yang menarik pada pandangan pertama bertentangan dengan aturan ini.  Dengan demikian, kode yang Anda coba percepat dengan susah payah mulai mengalokasikan memori untuk data baru dan baru, memuat pengumpul sampah. <br><br>  Internal perpustakaan menggunakan kemungkinan terluas dari versi terbaru bahasa dan runtime - Rentang, Memori, kumpulan objek, ValueTask, dan sebagainya.  Layak untuk melihat setidaknya di sana untuk contoh yang bagus menggunakan fitur-fitur ini dalam produksi. <br><br>  Pada suatu waktu, beberapa pengembang tidak puas dengan implementasi stream di C #, karena satu kelas digunakan untuk membaca dan menulis.  Tetapi seperti yang mereka katakan, Anda tidak dapat membuang metode dari kelas.  Bahkan jika streaming tidak mendukung membaca / menulis / mencari, properti CanRead, CanWrite dan CanSeek digunakan.  Itu terlihat seperti tongkat kecil.  Tetapi sekarang segalanya menjadi berbeda. <br><br>  Untuk bekerja dengan jalur pipa, 2 kelas digunakan: <a href="">PipeWriter</a> dan <a href="">PipeReader</a> .  Kelas-kelas ini berisi sekitar 50 baris kode dan fasad pseudo (bukan yang paling klasik dari inkarnasinya, karena mereka menyembunyikan satu kelas, tidak banyak) untuk <a href="">pipa</a> kelas, yang berisi semua logika dasar untuk bekerja dengan data.  Kelas ini berisi 5 anggota publik: 2 konstruktor, 2 properti get-only - Reader dan Writer, metode Reset (), yang me-reset bidang internal ke keadaan awal mereka sehingga kelas dapat digunakan kembali.  Metode yang tersisa untuk pekerjaan internal dan disebut menggunakan pseudo-fasad. <br><br><h2>  Mari kita mulai dengan kelas pipa </h2><br>  Instance class menempati 320 byte, yang cukup banyak (hampir sepertiga dari satu kilobyte, 2 objek seperti itu tidak bisa muat dalam memori Manchester Mark I).  Jadi mengalokasikan sejumlah besar instance itu adalah ide yang buruk.  Selain itu, objek ini dimaksudkan untuk penggunaan jangka panjang.  Menggunakan kumpulan juga membuat argumen untuk pernyataan ini.  Objek yang digunakan di pool akan hidup selamanya (untuk implementasi pool standar). <br>  Perhatikan bahwa kelas ditandai sebagai tersegel dan aman bagi thread - banyak bagian kode merupakan bagian penting dan dibungkus dengan kunci. <br><br>  Untuk mulai menggunakan kelas ini, Anda harus membuat turunan dari kelas Pipa dan mendapatkan objek PipeReader dan PipeWriter menggunakan properti yang disebutkan. <br><br><div class="spoiler">  <b class="spoiler_title">Inisialisasi sederhana</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Pertimbangkan metode untuk bekerja dengan pipa: <br>  Menulis dengan PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Lengkap, CancelPendingFlush, OnReaderCompleted. <br><br>  Membaca dengan PipeReader - AdvanceTo, ReadAsync, TryRead, Lengkap, CancelPendingRead, OnWriterCompleted. <br><br>  Sebagaimana dinyatakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting yang disebutkan</a> , kelas menggunakan daftar buffer yang terhubung secara tunggal.  Tapi, jelas, mereka tidak ditransfer antara PipeReader dan PipeWriter - semua logika ada dalam satu kelas.  Daftar ini digunakan untuk membaca dan menulis.  Selain itu, data yang dikembalikan disimpan dalam daftar ini (jadi tidak ada penyalinan yang dilakukan). <br><br>  Juga, ada objek yang menunjukkan awal data untuk dibaca (ReadHead dan indeks), akhir data untuk membaca (ReadTail dan indeks) dan awal ruang untuk menulis (WriteHead dan jumlah byte buffered yang ditulis).  Di sini, ReadHead, ReadTail, dan WriteHead adalah anggota khusus (segmen) dari daftar internal segmen, dan indeks menunjukkan posisi tertentu dalam segmen tersebut.  Dengan demikian, rekaman dapat dimulai dari tengah segmen, menangkap satu segmen berikutnya secara keseluruhan dan berakhir di tengah segmen ketiga.  Pointer ini dipindahkan dengan berbagai metode. <br><br><h2>  Memulai dengan metode PipeWriter </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (Sumber ReadOnlyMemory &lt;byte&gt;, pembatalanToken cancellationToken)</a> </h3><br>  Itu disebutkan menarik pada metode pandangan pertama.  Ini memiliki tanda tangan yang sangat cocok dan modis - menerima ReadOnlyMemory, asinkron.  Dan banyak yang mungkin tergoda, terutama mengingat bahwa Rentang dan Memori begitu cepat dan keren.  Tapi jangan menyanjung diri sendiri.  Semua yang dilakukan metode ini adalah menyalin ReadOnlyMemory yang diteruskan ke daftar internal.  Dan dengan "menyalin" berarti panggilan ke metode CopyTo (), dan tidak hanya menyalin objek itu sendiri.  Semua data yang ingin kami rekam akan disalin, sehingga memuat memori.  Metode ini harus disebutkan hanya untuk memastikan bahwa lebih baik tidak menggunakannya.  Ya, dan mungkin untuk beberapa situasi yang jarang, perilaku ini sesuai. <br>  Tubuh metode adalah bagian penting, akses ke sana disinkronkan melalui monitor. <br><br>  Maka timbul pertanyaan, bagaimana menulis sesuatu, jika tidak melalui metode yang paling jelas dan hanya cocok <br><br><h3>  # 2 <a href="">Memori &lt;byte&gt; GetMemory (int sizeHint)</a> </h3><br>  Metode ini mengambil satu parameter dari tipe integer.  Di dalamnya, kita harus menunjukkan berapa banyak byte yang ingin kita tulis ke pipeline (berapa ukuran buffer yang kita inginkan).  Metode ini memeriksa apakah ada cukup ruang untuk menulis dalam fragmen memori saat ini yang disimpan dalam _writingHeadMemory.  Jika cukup, _writingHeadMemory dikembalikan sebagai Memori.  Kalau tidak, untuk data yang ditulis ke buffer, tetapi metode FlushAsync tidak dipanggil, dipanggil dan BufferSegment lain dialokasikan, yang terhubung ke yang sebelumnya (berikut adalah daftar internal kami).  Jika _writingHeadMemory adalah nol, ini diinisialisasi dengan BufferSegment baru.  Dan alokasi buffer adalah bagian kritis dan dilakukan di bawah kunci. <br><br>  Saya sarankan untuk melihat contoh seperti itu.  Pada pandangan pertama, sepertinya kompiler (atau runtime) telah memperdaya iblis. <br><br><div class="spoiler">  <b class="spoiler_title">Iblis</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048 or 4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Tetapi segala sesuatu dalam contoh ini dapat dimengerti dan sederhana. <br>  Saat membuat turunan Pipa, kita bisa meneruskan objek <a href="">PipeOptions</a> ke dalam konstruktor dengan opsi untuk membuat. <br><br>  PipeOptions memiliki bidang ukuran segmen minimum default.  Belum lama ini, itu adalah 2048, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit ini</a> telah memperbarui nilai ini ke 4096. Pada saat penulisan artikel ini, versi 4096 berada dalam paket prugelease nuget, versi rilis terakhir memiliki nilai 2048. Ini menjelaskan contoh perilaku pertama.  Jika Anda kritis dalam menggunakan ukuran yang lebih kecil untuk buffer default, Anda dapat menentukannya dalam contoh tipe PipeOptions. <br><br>  Tetapi dalam contoh kedua, di mana ukuran minimum ditentukan, panjangnya tidak cocok.  Dan ini terjadi karena pembuatan BufferSegment baru terjadi menggunakan kumpulan.  Salah satu opsi di PipeOptions adalah kumpulan memori.  Setelah itu, kumpulan yang ditentukan akan digunakan untuk membuat segmen baru.  Jika Anda tidak menentukan kumpulan memori, ArrayPool default akan digunakan, yang, seperti yang Anda ketahui, memiliki beberapa ember untuk berbagai ukuran array (masing-masing berikutnya 2 kali lebih besar dari yang sebelumnya) dan ketika diminta untuk tertentu ukuran, itu mencari ember dengan array ukuran yang sesuai (yaitu, yang terdekat lebih besar atau sama).  Dengan demikian, buffer baru hampir pasti akan lebih besar dari yang Anda minta.  Ukuran array minimum di ArrayPool default (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) adalah 16. Tapi jangan khawatir, ini adalah kumpulan array.  Karenanya, dalam sebagian besar kasus, array tidak memberikan tekanan pada pengumpul sampah dan akan digunakan kembali nanti. <br><br><h3>  # 2.5 <a href="">Rentang &lt;byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Ini bekerja sama, memberikan Rentang dari Memori. <br><br>  Jadi GetMemory () atau GetSpan () adalah metode utama untuk menulis.  Mereka memberi kita objek yang bisa kita tulis.  Untuk melakukan ini, kita tidak perlu mengalokasikan memori untuk array nilai baru, kita dapat menulis langsung ke dalam pipa.  Yang mana yang akan digunakan terutama tergantung pada API yang Anda gunakan dan metode asinkron.  Namun, mengingat hal di atas, muncul pertanyaan.  Bagaimana pembaca tahu berapa banyak yang kami tulis?  Jika kami selalu menggunakan implementasi spesifik pool, yang memberikan array dengan ukuran yang persis sama seperti yang diminta, maka pembaca dapat membaca seluruh buffer sekaligus.  Namun, seperti yang telah kami katakan, kami dialokasikan buffer dengan probabilitas tinggi dari ukuran yang lebih besar.  Ini mengarah ke metode berikut yang diperlukan untuk operasi. <br><br><h3>  # 3 <a href="">void Advance (int byte)</a> </h3><br>  Metode yang sangat sederhana.  Dibutuhkan jumlah byte yang ditulis sebagai argumen.  Mereka menambah penghitung internal - _unflushedBytes dan _writingHeadBytesBuffered, yang namanya berbicara sendiri.  Ini juga memotong (irisan) _writingHeadMemory persis ke jumlah byte yang ditulis (menggunakan metode Slice).  Oleh karena itu, setelah memanggil metode ini, Anda perlu meminta blok memori baru dalam bentuk Memori atau Rentang, Anda tidak dapat menulis ke yang sebelumnya.  Dan seluruh tubuh metode adalah bagian penting dan berjalan di bawah kunci. <br><br>  Tampaknya setelah ini pembaca dapat menerima data.  Tapi satu langkah lagi diperlukan. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (Pembatalan Pembatalan dibatalkan)</a> </h3><br>  Metode ini dipanggil setelah kami menulis data yang diperlukan ke Memori yang diterima (GetMemory) dan menunjukkan seberapa banyak kami menulis di sana (Lanjutan).  Metode mengembalikan ValueTask, namun tidak asinkron (tidak seperti StreamPipeWriter turunannya).  ValueTask adalah tipe khusus (readonly struct) yang digunakan dalam kasus ketika sebagian besar panggilan tidak akan sinkron, itu semua data yang diperlukan akan tersedia pada saat panggilannya dan metode ini akan berakhir secara sinkron.  Di dalamnya sendiri berisi data atau Tugas (kalau-kalau tidak bekerja secara serempak).  Itu tergantung pada properti _writerAwaitable.IsCompleted.  Jika kita mencari apa yang mengubah keadaan _writerAwaitable ini, kita akan melihat bahwa ini terjadi jika jumlah data yang tidak dikonsumsi (ini tidak persis sama dengan data yang tidak diperiksa akan dijelaskan nanti) melebihi ambang tertentu (_pauseWriterThreshold).  Nilai default adalah 16 ukuran segmen.  Jika diinginkan, nilainya dapat diubah di PipeOptions.  Selain itu, metode ini memulai kelanjutan dari metode ReadAsync, jika ada yang diblokir. <br><br>  Mengembalikan FlushResult yang mengandung 2 properti - IsCanceled dan IsCompleted.  IsCanceled menunjukkan apakah Flush telah dibatalkan (CancelPendingFlush () panggilan).  IsCompleted menunjukkan apakah PipeReader telah menyelesaikan (dengan memanggil metode Complete () atau CompleteAsync ()). <br>  Bagian utama dari metode ini dilakukan di bawah kunci. <br><br>  Metode lain PipeWriter tidak menarik dari sudut pandang implementasi dan digunakan lebih jarang, oleh karena itu hanya deskripsi singkat yang akan diberikan. <br><br><h3>  # 5 batal Selesai (Pengecualian pengecualian = null) atau ValueTask CompleteAsync (Pengecualian pengecualian = null) </h3><br>  Pipa tanda ditutup untuk penulisan.  Pengecualian akan dilemparkan ketika mencoba menggunakan metode tulis setelah selesai.  Jika PipeReader telah selesai, seluruh instance Pipe juga selesai.  Sebagian besar pekerjaan dilakukan di bawah kunci. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Seperti namanya, ini membatalkan operasi FlushAsync () saat ini.  Ada kunci. <br><br><h3>  # 7 void OnReaderCompleted (Tindakan &lt;Pengecualian, objek&gt; panggilan balik, status objek) </h3><br>  Menjalankan delegasi yang lulus ketika pembaca selesai.  Ada juga kunci. <br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> saat ini tertulis bahwa metode ini mungkin tidak dipanggil pada beberapa implementasi PipeWriter dan akan dihapus di masa depan.  Karena itu, Anda tidak boleh mengikat logika dengan metode ini. <br><br><h2>  Sudah waktunya untuk PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (token PembatalanToken)</a> </h3><br>  Di sini, seperti di FlushAsync (), ValueTask dikembalikan, yang mengisyaratkan bahwa metode ini kebanyakan sinkron, tetapi tidak selalu.  Tergantung pada kondisi _readerAwaitable.  Seperti halnya FlushAsync, Anda perlu mengetahui kapan _readerAwaitable disetel menjadi tidak lengkap.  Ini terjadi ketika PipeReader telah membaca semuanya dari daftar internal (atau itu berisi data yang ditandai sebagai diperiksa dan Anda memerlukan lebih banyak data untuk melanjutkan).  Yang, sebenarnya, sudah jelas.  Dengan demikian, kita dapat menyimpulkan bahwa diinginkan untuk menyempurnakan Pipa untuk pekerjaan Anda, untuk mengatur semua pilihannya secara bijaksana, berdasarkan statistik yang diidentifikasi secara empiris.  Konfigurasi yang tepat akan mengurangi kemungkinan cabang eksekusi asinkron dan akan memungkinkan pemrosesan data yang lebih efisien.  Hampir semua kode di seluruh metode dikelilingi oleh kunci. <br><br>  Mengembalikan <a href="">ReadResult yang</a> misterius.  Bahkan, itu hanya buffer + bendera yang menunjukkan status operasi (IsCanceled - apakah ReadAsync dibatalkan dan IsCompleted menunjukkan apakah PipeWriter ditutup).  IsCompleted adalah nilai yang menunjukkan apakah metode PipeWriter Complete () atau CompleteAsync () dipanggil.  Jika metode ini dipanggil dengan pengecualian yang dilewati, maka itu akan dibuang ketika mencoba membaca. <br><br>  Dan lagi, buffer memiliki tipe misterius - <a href="">ReadOnlySequence</a> .  Ini, pada gilirannya, adalah objek untuk isi segmen <a href="">(ReadOnlySequenceSegment)</a> dari awal dan akhir + awal dan akhir indeks di dalam segmen yang sesuai.  Yang sebenarnya menyerupai struktur kelas Pipe itu sendiri.  Omong-omong, BufferSegment diwarisi dari ReadOnlySequenceSegment, yang mengisyaratkan bahwa BufferSegment digunakan dalam urutan ini.  Berkat ini, Anda bisa menyingkirkan alokasi memori yang tidak perlu untuk transfer data dari penulis ke pembaca. <br>  ReadOnlySpan dapat diperoleh dari buffer untuk diproses lebih lanjut.  Untuk melengkapi gambar, Anda dapat memeriksa apakah buffer berisi satu ReadOnlySpan.  Jika mengandung, kita tidak perlu mengulangi koleksi dari satu elemen dan kita bisa mendapatkannya menggunakan properti First.  Jika tidak, perlu untuk membahas semua segmen di buffer dan memproses ReadOnlySpan masing-masing. <br><br>  Topik diskusi - di kelas ReadOnlySequence, tipe referensi nullable secara aktif digunakan dan ada goto (bukan untuk deep loop nesting dan bukan dalam kode yang dihasilkan) - khususnya, di <a href="">sini</a> . <br><br>  Setelah diproses, Anda perlu memberi sinyal instance Pipa yang kami baca datanya. <br><br><h3>  # 2 <a href="">bool TryRead (hasil ReadResult)</a> </h3><br>  Versi sinkron.  Memungkinkan Anda mendapatkan hasilnya jika itu ada.  Jika tidak, tidak seperti ReadAsync, ia tidak memblokir dan mengembalikan false.  Kode metode ini juga ada di kunci. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition dikonsumsi, SequencePosition diperiksa)</a> </h3><br>  Dalam metode ini, Anda dapat menentukan berapa banyak byte yang kami periksa dan konsumsi.  Data yang telah diperiksa tetapi tidak dikonsumsi akan dikembalikan saat berikutnya dibaca.  Fitur ini mungkin tampak aneh pada pandangan pertama, tetapi ketika memproses aliran byte jarang diperlukan untuk memproses setiap byte secara individual.  Biasanya data dipertukarkan menggunakan pesan.  Suatu situasi dapat muncul bahwa pembaca, ketika membaca, menerima satu pesan utuh dan bagian dari pesan kedua.  Keseluruhan harus diproses, dan bagian yang kedua harus dibiarkan untuk masa depan sehingga ia datang bersama dengan bagian yang tersisa.  Metode AdvanceTo mengambil SequencePosition, yang sebenarnya merupakan indeks segmen +.  Saat memproses semua yang telah dibaca ReadAsync, Anda dapat menentukan buffer.End.  Jika tidak, Anda harus secara eksplisit membuat posisi, menunjukkan segmen dan indeks tempat pemrosesan dihentikan.  Kunci ada di bawah kap. <br>  Juga, jika jumlah informasi yang tidak dikonsumsi kurang dari ambang yang ditentukan (_resumeWriterThreshold), itu mulai kelanjutan PipeWriter jika diblokir.  Secara default, ambang ini adalah 8 volume segmen (setengah dari ambang batas pemblokiran). <br><br><h3>  Kekosongan # 4 Lengkap (Pengecualian pengecualian = nol) </h3><br>  Menyelesaikan PipeReader.  Jika PipeWriter selesai pada titik ini, maka seluruh instance Pipe selesai.  Kunci di dalam. <br><br><h3>  # 5 batal CancelPendingRead () </h3><br>  Memungkinkan Anda membatalkan pembacaan yang saat ini dalam status tertunda.  Kunci <br><br><h3>  # 6 void OnWriterCompleted (Tindakan &lt;Pengecualian, objek&gt; panggilan balik, status objek) </h3><br>  Memungkinkan Anda menentukan delegasi yang akan dieksekusi setelah menyelesaikan PipeWriter. <br>  Seperti metode serupa PipeWriter, dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> ada tag yang sama yang akan dihapus.  Kunci ada di bawah kap. <br><br><h2>  Contoh </h2><br>  Daftar di bawah ini menunjukkan contoh bekerja dengan pipa. <br>  Sejak diperkenalkannya .NET Core Span dan Memory, banyak kelas untuk bekerja dengan data telah ditambah dengan kelebihan menggunakan jenis ini.  Jadi skema interaksi umum akan kurang lebih sama.  Dalam contoh saya, saya menggunakan pipa untuk bekerja dengan pipa (saya suka kata-kata serupa) - objek OS untuk komunikasi antarproses.  API pipa baru saja diperluas untuk membaca data dalam Rentang dan Memori.  Versi asinkron menggunakan Memori, karena metode asinkron akan dikonversikan ke metode templat menggunakan mesin keadaan terhingga yang dihasilkan secara otomatis, di mana semua variabel lokal dan parameter metode disimpan, dan karena Span adalah ref readonly struct, itu tidak dapat ditempatkan di heap, masing-masing, menggunakan Span dalam metode asinkron tidak mungkin.  Tetapi ada juga versi sinkron dari metode yang memungkinkan Anda untuk menggunakan Span.  Dalam contoh saya, saya mencoba keduanya dan ternyata versi sinkron dalam situasi ini menunjukkan dirinya lebih baik.  Saat menggunakannya, pengumpulan sampah lebih sedikit, dan pemrosesan data lebih cepat.  Tapi ini hanya karena ada banyak data di dalam pipa (data selalu tersedia).  Dalam situasi di mana agaknya tidak akan ada data pada saat mengajukan aplikasi untuk batch berikutnya, Anda harus menggunakan versi asinkron agar tidak membebani prosesor idle. <br>  Contohnya memiliki komentar yang menjelaskan beberapa poin.  Saya menarik perhatian Anda pada fakta bahwa terlepas dari kenyataan bahwa fragmen program yang bertanggung jawab untuk membaca dari pipa dan pemrosesan dipisahkan, ketika menulis ke file, data tersebut dibaca persis dari tempat di mana itu ditulis ketika membaca dari pipa. <br><br><div class="spoiler">  <b class="spoiler_title">Evolusi bertahun-tahun demi fitur yang kuat - asinkron utama</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Penulis pipepata</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ when working with the asynchronous method, use Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ asynchronous reading from a named pipe in Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ there can be any operation to obtain data - from reading from a file to random generation. //int readBytes = await _namedPipe.ReadAsync(buffer, token); // synchronous reading from the named pipe to the requested from PipeWriter Span // there can be any operation to obtain data - from reading from a file to random generation. int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); // if there was nothing in the channel, release the thread for half a second and try again // in other cases we can break the loop, it's just example if (readBytes == 0) { await Task.Delay(500, token); continue; } // specify the amount of bytes read from the pipe _pipeWriter.Advance(readBytes); // flush data to make them available PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); // if PipeReader has been completed, it no longer needs to write data // PS this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeWriter to complete the entire instance of pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dataprocessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">// reading data from a pipe instance ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; // We perform calculations with the data obtained. await _bytesProcessor.ProcessBytesAsync(buffer, token); // indicate to which position the data was processed. In this case, everything is written to the file. // in situations where not all data has been processed, you need to create a position manually using the buffer and index // in this situation, IBytesProcessor.ProcessBytesAsync can be supplemented by returning this position _pipeReader.AdvanceTo(buffer.End); // if PipeWriter has been completed, reading is no longer necessary // this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeReader to complete the entire instance of pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Prosesor byte</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Let's imagine that in this class there is a normal constructor and IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466137/">https://habr.com/ru/post/id466137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466121/index.html">Pembuatan suara pada mikrokontroler AVR menggunakan metode wavetable dengan dukungan polifoni</a></li>
<li><a href="../id466123/index.html">Pertumbuhan. Berat Tiga tetangga</a></li>
<li><a href="../id466127/index.html">Kola NPP atau berdiri di reaktor</a></li>
<li><a href="../id466129/index.html">Efisiensi transportasi dengan bensin, baterai dan hidrogen</a></li>
<li><a href="../id466135/index.html">Megapack: bagaimana pengembang Factorio berhasil memecahkan masalah dengan 200 pemain multipemain</a></li>
<li><a href="../id466139/index.html">Teknologi yang diterapkan pada reruntuhan demam blockchain atau manfaat praktis dari alokasi sumber daya</a></li>
<li><a href="../id466143/index.html">Bagaimana kami membuat kode kardus atau versi Awal dari game papan Golem Battle</a></li>
<li><a href="../id466147/index.html">Manajer Tampilan Data Reaktif. Pendahuluan</a></li>
<li><a href="../id466149/index.html">Membuat simbol konektor dengan teks "dinamis" di OrCAD</a></li>
<li><a href="../id466151/index.html">Investigasi: program aneh dalam Daftar perangkat lunak domestik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>