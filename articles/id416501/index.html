<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🏫 🎦 ✋🏽 Tulis saya server GraphQL di C # 🛷 🙏 🤽🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entah bagaimana saya mendapat beberapa hari libur, dan saya membuat sketsa server GraphQL ke platform Docsvision kami. Di bawah ini saya akan memberi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tulis saya server GraphQL di C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/docsvision/blog/416501/"><p>  Entah bagaimana saya mendapat beberapa hari libur, dan saya membuat sketsa server GraphQL ke platform Docsvision kami.  Di bawah ini saya akan memberi tahu Anda bagaimana hasilnya. </p><br><p><img src="https://habrastorage.org/webt/ol/gu/2p/olgu2pfxvycejlhj4z_o5o0q9ru.jpeg" alt="Poster - atas perintah"></p><a name="habracut"></a><br><h4 id="chto-za-platforma-docsvision">  Apa itu platform Docsvision </h4><br><p> Platform Docsvision mencakup banyak alat berbeda untuk membangun sistem alur kerja, tetapi komponen utamanya adalah seperti ORM.  Ada editor metadata di mana Anda bisa menggambarkan struktur bidang kartu.  Mungkin ada bagian struktural, pengumpulan dan pohon, yang, apalagi, dapat disarangkan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara umum, semuanya rumit</a> .  Database dihasilkan oleh metadata, dan kemudian Anda bisa bekerja dengannya melalui beberapa C # API.  Singkatnya - opsi ideal untuk membangun server GraphQL. </p><br><h4 id="kakie-est-varianty">  Apa saja opsinya </h4><br><p>  Jujur saja, tidak banyak pilihan dan mereka biasa-biasa saja.  Saya berhasil menemukan hanya dua perpustakaan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">graphql-dotnet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">graphql-net</a> </li></ul><br><p>  UPD: dalam komentar mereka menyarankan bahwa masih ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hotchocolate</a> . </p><br><p>  Pada README, pada awalnya saya menyukai yang kedua, dan saya bahkan mulai melakukan sesuatu dengannya.  Tapi dia segera mengetahui bahwa API-nya terlalu buruk, dan dia tidak bisa mengatasi tugas menghasilkan skema metadata.  Namun, tampaknya sudah ditinggalkan (komitmen terakhir setahun yang lalu). </p><br><p> API <code>graphql-dotnet</code> cukup fleksibel, tetapi pada saat yang sama sangat didokumentasikan, membingungkan, dan tidak intuitif.  Untuk memahami cara bekerja dengannya, saya harus melihat kode sumber ... Benar, saya bekerja dengan versi <code>0.16</code> , sementara sekarang yang terakhir adalah <code>0.17.3</code> , dan 7 versi beta <code>2.0</code> telah dirilis.  Jadi saya minta maaf jika bahannya agak ketinggalan jaman. </p><br><p>  Saya juga harus menyebutkan bahwa perpustakaan datang dengan rakitan yang tidak ditandatangani.  Saya harus membangunnya kembali dari sumber secara manual untuk menggunakannya dalam aplikasi ASP.NET kami dengan rakitan yang ditandatangani. </p><br><h4 id="struktura-graphql-servera">  Struktur server GraphQL </h4><br><p>  Jika Anda tidak terbiasa dengan GraphQL, Anda dapat mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github explorer</a> .  Sebuah rahasia kecil - Anda dapat menekan Ctrl + space untuk mendapatkan pelengkapan otomatis.  Bagian klien tidak lebih dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GraphiQL</a> , yang dapat dengan mudah dipasangkan ke server Anda.  Ambil saja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">index.html</a> , tambahkan skrip dari paket npm, dan ubah url di fungsi graphQLFetcher ke alamat server Anda - hanya itu, Anda dapat memainkannya. </p><br><p>  Pertimbangkan permintaan sederhana: </p><br><pre> <code class="hljs pgsql">query { viewer { <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, company } }</code> </pre> <br><p>  Di sini kita melihat seperangkat bidang - viewer, di dalamnya masuk, perusahaan.  Tugas kita, seperti backend GraphQL, adalah untuk membangun di server beberapa "skema" di mana semua bidang ini akan diproses.  Bahkan, kita hanya perlu membuat struktur objek layanan yang sesuai dengan deskripsi bidang, dan mendefinisikan fungsi panggil balik untuk menghitung nilai. </p><br><p>  Skema ini dapat dibuat secara otomatis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berdasarkan kelas C #</a> , tetapi kita akan melalui hardcore - kita akan melakukan segalanya dengan tangan kita.  Tapi ini bukan karena saya orang yang gagah, hanya menghasilkan skema berbasis metadata adalah skrip non-standar di graphql-dotnet yang tidak didukung oleh dokumentasi resmi.  Jadi, kami menggali sedikit di perutnya, di daerah tanpa dokumen. </p><br><p>  Setelah membuat skema, tetap bagi kami untuk mengirimkan string permintaan (dan parameter) dari klien ke server dengan cara yang mudah (tidak masalah bagaimana GET, POST, SignalR, TCP ...), dan memberi makan mesinnya bersama dengan skema.  Mesin akan memuntahkan objek dengan hasil yang kita ubah menjadi JSON dan mengembalikannya ke klien.  Ini terlihat seperti ini untuk saya: </p><br><pre> <code class="hljs pgsql"> //  ,        var schema = GraphQlService.GetCardsSchema(sessionContext); //    (  ) var executer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DocumentExecuter(); //   ,  var dict = await executer.ExecuteAsync(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>, sessionContext, request.Query, request.MethodName).ConfigureAwait(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); // -   :) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dict.Errors != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; dict.Errors.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> InvalidOperationException(dict.Errors.First().Message); } //    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Json</span></span>(dict.Data);</code> </pre> <br><p>  Anda dapat memperhatikan <code>sessionContext</code> .  Ini adalah objek khusus Documents kami yang melaluinya platform diakses.  Saat membuat skema, kami selalu bekerja dengan konteks tertentu, tetapi lebih pada nanti. </p><br><h4 id="generaciya-shemy">  Generasi sirkuit </h4><br><p>  Semuanya dimulai dengan cara yang menyentuh: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span> schema = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span>();</code> </pre> <br><p>  Sayangnya, disinilah kode sederhana berakhir.  Untuk menambahkan bidang ke skema, kita perlu: </p><br><ol><li>  Jelaskan tipenya - buat ObjectGraphType, StringGraphType, BooleanGraphType, IdGraphType, IntGraphType, DateGraphType atau objek FloatGraphType. </li><li>  Jelaskan bidang itu sendiri (nama, penangan) - buat objek GraphQL.Types.FieldType </li></ol><br><p>  Mari kita coba gambarkan permintaan sederhana yang saya kutip di atas.  Dalam permintaan, kami memiliki satu penampil lapangan.  Untuk menambahkannya ke kueri, Anda harus terlebih dahulu menjelaskan tipenya.  Jenisnya sederhana - sebuah objek, dengan dua bidang string - login dan perusahaan.  Kami menggambarkan bidang login: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQL.Types.FieldType(); loginField.Name = <span class="hljs-string"><span class="hljs-string">"login"</span></span>; loginField.ResolvedType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringGraphType(); loginField.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>); loginField.Resolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyViewerLoginResolver(); <span class="hljs-comment"><span class="hljs-comment">// ... class MyViewerLoginResolver : GraphQL.Resolvers.IFieldResolver { public object Resolve(ResolveFieldContext context) { // ,       -   UserInfo //      viewer return (context.Source as UserInfo).AccountName; } }</span></span></code> </pre> <br><p>  Kami membuat objek companyField dengan cara yang sama - luar biasa, kami siap menjelaskan jenis bidang pemirsa. </p><br><pre> <code class="hljs pgsql">ObjectGraphType&lt;UserInfo&gt; viewerType = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ObjectGraphType&lt;UserInfo&gt;(); viewerType.Name = "Viewer"; viewerType.AddField(loginField); viewerType.AddField(companyField);</code> </pre> <br><p>  Ada tipe, sekarang kita bisa menggambarkan bidang pemirsa itu sendiri: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewerField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQL.Types.FieldType(); viewerField.Name = <span class="hljs-string"><span class="hljs-string">"viewer"</span></span>; viewerField.ResolvedType = viewerType; viewerField.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(UserInfo); viewerField.Resolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyViewerResolver(); <span class="hljs-comment"><span class="hljs-comment">// ... class MyViewerResolver : GraphQL.Resolvers.IFieldResolver { public object Resolve(ResolveFieldContext context) { //     sessionContext   ? // ,         (login  company) return (context.Source as SessionContext).UserInfo; } }</span></span></code> </pre> <br><p>  Nah, dan sentuhan terakhir, tambahkan bidang kami ke jenis kueri: </p><br><pre> <code class="hljs erlang">var <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type = new ObjectGraphType(); <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type.AddField(viewerField); schema.Query = <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type;</code> </pre> <br><p>  Itu saja, skema kami sudah siap. </p><br><h4 id="kollekcii-peydzhinaciya-obrabotka-parametrov">  Koleksi, pagination, pemrosesan parameter </h4><br><p>  Jika bidang mengembalikan bukan satu objek, tetapi koleksi, maka Anda perlu menentukan ini secara eksplisit.  Untuk melakukan ini, cukup bungkus tipe properti dalam instance dari kelas ListGraphType.  Misalkan jika pemirsa mengembalikan koleksi, kami hanya akan menulis ini: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  ( ) viewerField.ResolvedType = viewerType; //  () viewerField.ResolvedType = new ListGraphType(viewerType);</span></span></code> </pre> <br><p>  Dengan demikian, dalam resolver MyViewerResolver maka akan diperlukan untuk mengembalikan daftar. </p><br><p>  Saat bidang koleksi muncul, penting untuk segera menangani paging.  Tidak ada mekanisme siap pakai di sini, semuanya dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melalui parameter</a> .  Anda dapat melihat contoh penggunaan parameter pada contoh di atas (cardDocument memiliki parameter id).  Mari kita tambahkan parameter seperti itu ke pemirsa: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArgument = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryArgument(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IdGraphType)); idArgument.Name = <span class="hljs-string"><span class="hljs-string">"id"</span></span>; idArgument.ResolvedType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IdGraphType(); idArgument.DefaultValue = Guid.Empty; viewerField.Arguments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryArguments(idArgument);</code> </pre> <br><p>  Maka Anda bisa mendapatkan nilai parameter di resolver seperti ini: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resolve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ResolveFieldContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArgStr = context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(idArgStr);</code> </pre> <br><p>  GraphQL diketik sehingga Guid, tentu saja, tidak dapat menguraikan.  Oh well, itu tidak sulit bagi kami. </p><br><h4 id="zapros-kartochek-docsvision">  Permintaan Kartu Docsvision </h4><br><p>  Dalam implementasi GrapqhQL untuk platform Docsvision, saya hanya perlu membaca kode metadata ( <code>sessionContext.Session.CardManager.CardTypes</code> ), dan untuk semua kartu dan bagian-bagiannya, saya secara otomatis membuat objek dengan resolusi yang sesuai.  Hasilnya kira-kira seperti ini: </p><br><pre> <code class="hljs objectivec">query { cardDocument(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-string"><span class="hljs-string">"{AF652E55-7BCF-E711-8308-54A05079B7BF}"</span></span>) { mainInfo { name instanceID } } }</code> </pre> <br><p>  Di sini cardDocument adalah jenis kartu, mainInfo adalah nama bagian di dalamnya, nama dan instanceID adalah bidang di bagian tersebut.  Penyelesai yang sesuai untuk kartu, bagian, dan bidang menggunakan API CardManager sebagai berikut: </p><br><pre> <code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CardDataResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { public object Resolve</span></span></span></span>(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sessionContext = (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SessionContext); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sessionContext.Session.CardManager.GetCardData(idArg); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { CardSection section; public SectionFieldResolver</span></span></span></span>(CardSection section) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.section = section; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Resolve(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skipArg = (int?)context.Arguments?[<span class="hljs-string"><span class="hljs-string">"skip"</span></span>] ?? <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> takeArg = (int?)context.Arguments?[<span class="hljs-string"><span class="hljs-string">"take"</span></span>] ?? <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sectionData = (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CardData).Sections[section.Id]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idArg == Guid.Empty ? sectionData.GetAllRows().Skip(skipArg).Take(takeArg) : new List&lt;RowData&gt; { sectionData.GetRow(idArg) }; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RowFieldResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { Field field; public RowFieldResolver</span></span></span></span>(Field field) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field = field; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Resolve(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RowData)[field.Alias]; } }</code> </pre> <br><p>  Tentu saja, di sini Anda hanya dapat meminta kartu melalui id, tetapi mudah untuk membuat skema dengan cara yang sama untuk mengakses laporan, layanan, dan hal-hal lain yang canggih.  Dengan API ini, Anda bisa mendapatkan data apa pun dari basis data Docsvision hanya dengan menulis JavaScript yang sesuai - sangat mudah untuk menulis skrip dan ekstensi Anda sendiri. </p><br><h4 id="zaklyuchenie">  Kesimpulan </h4><br><p>  Dengan GrapqhQL di .NET, semuanya tidak mudah.  Ada satu perpustakaan yang agak hidup, tanpa vendor yang andal dan dengan masa depan yang tidak dapat dipahami, API yang tidak stabil dan aneh, yang tidak diketahui bagaimana berperilaku di bawah beban dan seberapa stabilnya.  Tetapi kami memiliki apa yang kami miliki, tampaknya berhasil, tetapi kekurangan dalam dokumentasi dan sisanya diimbangi oleh keterbukaan kode sumber. </p><br><p>  Apa yang saya jelaskan dalam artikel ini adalah API yang semakin tidak berdokumen, yang saya eksplorasi dengan mengetik dan mempelajari sumbernya.  Hanya saja para penulis perpustakaan tidak berpikir bahwa seseorang akan perlu membuat sirkuit secara otomatis - yah, apa yang bisa Anda lakukan, ini adalah open source. </p><br><p>  Itu ditulis sepanjang akhir pekan ini, dan dengan sendirinya, sejauh ini tidak lebih dari sebuah prototipe.  Dalam paket Docsvision standar, ini mungkin muncul, tetapi ketika - masih sulit untuk mengatakan.  Namun, jika Anda menyukai gagasan mengakses database Docsvision langsung dari JavaScrpit tanpa menulis ekstensi server, tulis.  Semakin tinggi minat dari mitra, semakin banyak perhatian yang akan kami curahkan untuk ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416501/">https://habr.com/ru/post/id416501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416489/index.html">Kehidupan Extraterrestrial: Mengoreksi Persamaan Drake dan Filter Hebat</a></li>
<li><a href="../id416491/index.html">Activiti - Mesin proses bisnis</a></li>
<li><a href="../id416493/index.html">Luncurkan SIIG MiniSys S286</a></li>
<li><a href="../id416495/index.html">SamsPcbGuide Bagian 6: Tracing Signal Lines. Model Kehilangan dan Crosstalk</a></li>
<li><a href="../id416497/index.html">Contoh menghitung reaksi sinyal menggunakan transformasi Fourier di MATLAB</a></li>
<li><a href="../id416505/index.html">Kami menulis setumpuk mesin virtual di Rust'e</a></li>
<li><a href="../id416507/index.html">Cara memeriksa keandalan pusat data: 3 poin utama yang perlu Anda perhatikan</a></li>
<li><a href="../id416511/index.html">Kesalahan paling umum dalam kode Bereaksi yang Anda (mungkin) buat</a></li>
<li><a href="../id416513/index.html">Intisari materi menarik untuk pengembang seluler # 260 (2 Juli - 8 Juli)</a></li>
<li><a href="../id416515/index.html">Beri peringkat artikel untuk ditambahkan ke favorit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>