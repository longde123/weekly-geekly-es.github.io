<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦓 👩🏽‍🔬 🏇🏼 RISC-V dari awal 💃🏼 🥟 🤽🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, kami mengeksplorasi berbagai konsep tingkat rendah (kompilasi dan tata letak, runtime primitif, assembler, dan banyak lagi) melalui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RISC-V dari awal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454208/">  Dalam artikel ini, kami mengeksplorasi berbagai konsep tingkat rendah (kompilasi dan tata letak, runtime primitif, assembler, dan banyak lagi) melalui prisma arsitektur RISC-V dan ekosistemnya.  Saya sendiri seorang pengembang web, saya tidak melakukan apa pun di tempat kerja, tapi ini sangat menarik bagi saya, dari sinilah artikel itu berasal!  Bergabunglah dengan saya dalam perjalanan yang sibuk ini ke kedalaman kekacauan tingkat rendah. <br><br>  Pertama, mari kita bicara sedikit tentang RISC-V dan pentingnya arsitektur ini, mengatur toolchain RISC-V dan menjalankan program C sederhana pada perangkat keras RISC-V yang ditiru. <br><a name="habracut"></a><br><h1>  Isi </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu RISC-V?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengkonfigurasi Alat QEMU dan RISC-V</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hai RISC-V!</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendekatan naif</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengangkat tirai -v</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cari tumpukan kami</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata letak</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hentikan itu!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><s>Hammertime!</s></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Runtime!</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Debug tapi sekarang nyata</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa selanjutnya</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opsional</a> </li></ol><br><a name="1"></a><h1>  Apa itu RISC-V? </h1><br>  RISC-V adalah arsitektur set instruksi gratis.  Proyek ini berasal dari University of California di Berkeley pada 2010.  Peran penting dalam keberhasilannya dimainkan oleh keterbukaan kode dan kebebasan penggunaan, yang sangat berbeda dari banyak arsitektur lainnya.  Ambil ARM: untuk membuat prosesor yang kompatibel, Anda harus membayar uang muka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">$ 1 juta hingga $ 10 juta, dan juga membayar royalti 0,5−2% dari penjualan</a> .  Model yang bebas dan terbuka menjadikan RISC-V pilihan yang menarik bagi banyak orang, termasuk untuk pemula yang tidak dapat membayar lisensi untuk ARM atau prosesor lain, untuk peneliti akademis dan (jelas) untuk komunitas sumber terbuka. <br><br>  Pertumbuhan cepat dalam popularitas RISC-V tidak luput dari perhatian.  ARM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meluncurkan situs</a> yang mencoba (agak tidak berhasil) untuk menyoroti dugaan manfaat ARM dibandingkan RISC-V (situs tersebut sudah ditutup).  Proyek RISC-V didukung oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak perusahaan besar</a> , termasuk Google, Nvidia dan Western Digital. <br><br><a name="2"></a><h1>  Mengkonfigurasi Alat QEMU dan RISC-V </h1><br>  Kami tidak dapat menjalankan kode pada prosesor RISC-V sampai kami mengatur lingkungan.  Untungnya, ini tidak memerlukan prosesor fisik RISC-V, sebagai gantinya, kami mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qemu</a> .  Ikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi untuk</a> menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem operasi Anda</a> .  Saya memiliki MacOS, jadi cukup masukkan satu perintah: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># also available via MacPorts - `sudo port install qemu` brew install qemu</span></span></code> </pre> <br>  Dengan mudah, <code>qemu</code> hadir dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa mesin siap-pakai</a> (lihat opsi <code>qemu-system-riscv32 -machine</code> ). <br><br>  Selanjutnya, instal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenOCD</a> untuk alat RISC-V dan RISC-V. <br><br>  Unduh perangkat RISC-V OpenOCD dan RISC-V yang sudah jadi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br>  Kami mengekstrak file ke direktori mana pun, saya memilikinya <code>~/usys/riscv</code> .  Ingat untuk digunakan di masa depan. <br><br><pre> <code class="bash hljs">mkdir -p ~/usys/riscv <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Downloads cp openocd-&lt;date&gt;-&lt;platform&gt;.tar.gz ~/usys/riscv cp riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;platform&gt;.tar.gz ~/usys/riscv <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/usys/riscv tar -xvf openocd-&lt;date&gt;-&lt;platform&gt;.tar.gz tar -xvf riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;platform&gt;.tar.gz</code> </pre> <br>  Tetapkan variabel lingkungan <code>RISCV_OPENOCD_PATH</code> dan <code>RISCV_PATH</code> sehingga program lain dapat menemukan rantai alat kami.  Ini mungkin terlihat berbeda tergantung pada OS dan shell: Saya menambahkan path ke file <code>~/.zshenv</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># I put these two exports directly in my ~/.zshenv file - you may have to do something else. export RISCV_OPENOCD_PATH="$HOME/usys/riscv/openocd-&lt;date&gt;-&lt;version&gt;" export RISCV_PATH="$HOME/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;" # Reload .zshenv with our new environment variables. Restarting your shell will have a similar effect. source ~/.zshenv</span></span></code> </pre> <br>  Buat tautan simbolis di <code>/usr/local/bin</code> untuk file yang dapat dieksekusi ini sehingga Anda dapat menjalankannya kapan saja tanpa menentukan path lengkap ke <code>~/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;/bin/riscv64-unknown-elf-gcc</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Symbolically link our gcc executable into /usr/local/bin. Repeat this process for any other executables you want to quickly access. ln -s ~/usys/riscv/riscv64-unknown-elf-gcc-8.2.0-&lt;date&gt;-&lt;version&gt;/bin/riscv64-unknown-elf-gcc /usr/local/bin</span></span></code> </pre> <br>  Dan voila, kami memiliki toolkit RISC-V yang berfungsi!  Semua executable kami, seperti <code>riscv64-unknown-elf-gcc</code> , <code>riscv64-unknown-elf-gdb</code> , <code>riscv64-unknown-elf-ld</code> dan lainnya, ada di <code>~/usys/riscv/riscv64-unknown-elf-gcc-&lt;date&gt;-&lt;version&gt;/bin/</code> . <br><br><a name="3"></a><h1>  Hai RISC-V! </h1><br>  <i>26 Mei 2019 Tambalan:</i> <i><br><br></i>  <i>Sayangnya, karena bug di RISC-V QEMU, program 'hello world' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebebasan-e-sdk</a> di QEMU tidak lagi berfungsi.</i>  <i>Sebuah tambalan telah dirilis untuk mengatasi masalah ini, tetapi untuk saat ini, lewati bagian ini.</i>  <i>Program ini tidak akan diperlukan di bagian artikel selanjutnya.</i>  <i>Saya melacak situasi dan memperbarui artikel setelah memperbaiki bug.</i> <i><br><br></i>  <i>Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar ini</a> untuk informasi lebih lanjut.</i> <br><br>  Dengan alat yang disiapkan, mari kita jalankan program RISC-V sederhana.  Mari kita mulai dengan mengkloning repositori SiFive <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">freedom-e-sdk</a> : <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/wherever/you/want/to/<span class="hljs-built_in"><span class="hljs-built_in">clone</span></span>/this git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --recursive https://github.com/sifive/freedom<span class="hljs-_"><span class="hljs-_">-e</span></span>-sdk.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> freedom<span class="hljs-_"><span class="hljs-_">-e</span></span>-sdk</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Secara tradisi</a> , mari kita mulai dengan program 'Hello, world' dari repositori <code>freedom-e-sdk</code> .  Kami menggunakan <code>Makefile</code> siap pakai yang mereka sediakan untuk mengkompilasi program ini dalam mode debug: <br><br><pre> <code class="bash hljs">make PROGRAM=hello TARGET=sifive-hifive1 CONFIGURATION=debug software</code> </pre> <br>  Dan jalankan di QEMU: <br><br><pre> <code class="bash hljs">qemu-system-riscv32 -nographic -machine sifive_e -kernel software/hello/debug/hello.elf Hello, World!</code> </pre> <br>  Ini awal yang bagus.  Anda dapat menjalankan contoh lain dari <code>freedom-e-sdk</code> .  Setelah itu, kita akan menulis dan mencoba men-debug program kita sendiri di C. <br><br><h1>  Pendekatan naif </h1><br>  Mari kita mulai dengan program sederhana yang menambahkan dua angka tanpa batas. <br><br><pre> <code class="cpp hljs">cat add.<span class="hljs-function"><span class="hljs-function">c </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Kami ingin menjalankan program ini, dan hal pertama yang kami perlukan untuk mengkompilasinya untuk prosesor RISC-V. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -O0 to disable all optimizations. Without this, GCC might optimize # away our infinite addition since the result 'c' is never used. # -g to tell GCC to preserve debug info in our executable. riscv64-unknown-elf-gcc add.c -O0 -g</span></span></code> </pre> <br>  Ini menciptakan file <code>a.out</code> , yang <code>gcc</code> default ke file yang dapat dieksekusi.  Sekarang jalankan file ini di <code>qemu</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -machine tells QEMU which among our list of available machines we want to # run our executable against. Run qemu-system-riscv64 -machine help to list # all available machines. # -m is the amount of memory to allocate to our virtual machine. # -gdb tcp::1234 tells QEMU to also start a GDB server on localhost:1234 where # TCP is the means of communication. # -kernel tells QEMU what we're looking to run, even if our executable isn't # exactly a "kernel". qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -kernel a.out</span></span></code> </pre> <br>  Kami memilih mesin <code>virt</code> yang <code>riscv-qemu</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awalnya datang</a> <code>riscv-qemu</code> . <br><br>  Sekarang program kami berjalan di dalam QEMU dengan server GDB di <code>localhost:1234</code> , kami terhubung dengan klien RISC-V GDB dari terminal terpisah: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># --tui gives us a (t)extual (ui) for our GDB session. # While we can start GDB without any arguments, specifying 'a.out' tells GDB # to load debug symbols from that file for the newly created session. riscv64-unknown-elf-gdb --tui a.out</span></span></code> </pre> <br>  Dan kita berada di dalam GDB! <br><br><pre>  GDB ini dikonfigurasi sebagai "--host = x86_64-apple-darwin17.7.0 --target = riscv64-unknown-elf".  │
 Ketik "tampilkan konfigurasi" untuk detail konfigurasi.  │
 Untuk instruksi pelaporan bug, silakan lihat: │
 &lt;http://www.gnu.org/software/gdb/bugs/&gt;.  │
 Temukan manual GDB dan sumber dokumentasi lainnya secara online di: │
     &lt;http://www.gnu.org/software/gdb/documentation/&gt;.  │
                                                                                                       │
 Untuk bantuan, ketik "bantuan".  │
 Ketik "kata yang tepat" untuk mencari perintah yang terkait dengan "kata" ... │
 Membaca simbol dari a.out ... │
 (gdb) </pre><br>  Kita dapat mencoba menjalankan <code>run</code> atau <code>start</code> perintah untuk file yang dapat dieksekusi <code>a.out</code> di GDB, tetapi saat ini ini tidak akan berfungsi karena alasan yang jelas.  Kami mengkompilasi program sebagai <code>riscv64-unknown-elf-gcc</code> , sehingga host harus dijalankan pada arsitektur <code>riscv64</code> . <br><br>  Tapi ada jalan keluar!  Situasi ini adalah salah satu alasan utama untuk keberadaan model klien-server GDB.  Kita dapat mengambil file executable <code>riscv64-unknown-elf-gdb</code> dan alih-alih meluncurkannya pada host tentukan beberapa target jarak jauh (server GDB).  Seperti yang Anda ingat, kami baru saja memulai <code>riscv-qemu</code> dan memberitahu kami untuk memulai server GDB di <code>localhost:1234</code> .  Cukup sambungkan ke server ini: <br><br><pre>  (gdb) target jarak jauh: 1234 │
 Remote debugging menggunakan: 1234 </pre><br>  Sekarang Anda dapat mengatur beberapa breakpoints: <br><br><pre> <code class="bash hljs">(gdb) b main Breakpoint 1 at 0x1018e: file add.c, line 2. (gdb) b 5 <span class="hljs-comment"><span class="hljs-comment"># this is the line within the forever-while loop. int c = a + b; Breakpoint 2 at 0x1019a: file add.c, line 5.</span></span></code> </pre> <br>  Dan akhirnya, tentukan GDB <code>continue</code> (disingkat perintah <code>c</code> ) sampai kita mencapai breakpoint: <br><br><pre> <code class="bash hljs">(gdb) c Continuing.</code> </pre> <br>  Anda akan segera menyadari bahwa prosesnya tidak berakhir dengan cara apa pun.  Ini aneh ... bukankah kita harus segera mencapai breakpoint <code>b 5</code> ?  Apa yang terjadi <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a53/834/210/a538342106336ef7ed1b8f9e53a47f48.png"><br><br>  Di sini Anda dapat melihat beberapa masalah: <br><br><ol><li>  UI teks tidak dapat menemukan sumbernya.  Antarmuka harus menampilkan kode kami dan breakpoints terdekat. <br></li><li>  GDB tidak melihat garis eksekusi saat ini ( <code>L??</code> ) dan menampilkan penghitung 0x0 ( <code>PC: 0x0</code> ). <br></li><li>  Beberapa teks di baris input, yang secara keseluruhan terlihat seperti ini: <code>0x0000000000000000 in ?? ()</code> <code>0x0000000000000000 in ?? ()</code> </li></ol><br>  Dikombinasikan dengan fakta bahwa kami tidak dapat mencapai breakpoint, indikator-indikator ini menunjukkan: kami melakukan <i>sesuatu yang</i> salah.  Tapi apa? <br><br><a name="5"></a><h1>  Mengangkat tirai -v </h1><br>  Untuk memahami apa yang terjadi, Anda perlu mengambil langkah mundur dan berbicara tentang bagaimana sebenarnya program C kami di bawah tenda bekerja.  Fungsi <code>main</code> melakukan penambahan sederhana, tetapi apakah itu sebenarnya?  Mengapa harus disebut <code>main</code> , bukan <code>origin</code> atau <code>begin</code> ?  Menurut konvensi, semua file yang dapat dieksekusi mulai dieksekusi dengan fungsi <code>main</code> , tetapi sihir apa yang menyediakan perilaku ini? <br><br>  Untuk menjawab pertanyaan-pertanyaan ini, mari kita ulangi tim GCC kami dengan flag <code>-v</code> untuk mendapatkan hasil yang lebih rinci tentang apa yang sebenarnya terjadi. <br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gcc add.c -O0 -g -v</code> </pre> <br>  Outputnya besar, jadi kami tidak akan melihat seluruh daftar.  Penting untuk dicatat bahwa meskipun GCC secara resmi adalah kompiler, GCC juga merupakan default untuk kompilasi (untuk membatasi diri pada kompilasi dan perakitan, Anda harus menentukan flag <code>-c</code> ).  Mengapa ini penting?  Nah, lihat cuplikan dari output terperinci <code>gcc</code> : <br><br><pre>  # Perintah `gcc -v` aktual menghasilkan path lengkap, tetapi cukup
 # panjang, jadi anggaplah variabel-variabel ini ada.
 # $ RV_GCC_BIN_PATH = / Pengguna / twilcock / usys / riscv / riscv64-unknown-elf-gcc- &lt;tanggal&gt; - &lt;version&gt; / bin /
 # $ RV_GCC_LIB_PATH = $ RV_GCC_BIN_PATH /../ lib / gcc / riscv64-unknown-elf / 8.2.0<font></font>
<font></font>
 $ RV_GCC_BIN_PATH /../ libexec / gcc / riscv64-unknown-elf / 8.2.0 / collect2 \
   ... terpotong ... 
   $ RV_GCC_LIB_PATH /../../../../ riscv64-unknown-elf / lib / rv64imafdc / lp64d / crt0.o \ 
   $ RV_GCC_LIB_PATH / riscv64-unknown-elf / 8.2.0 / rv64imafdc / lp64d / crtbegin.o \
   -lgcc - mulai-grup -lc -lgloss --end-grup -lgcc \ 
   $ RV_GCC_LIB_PATH / rv64imafdc / lp64d / crtend.o
   ... terpotong ...
 COLLECT_GCC_OPTIONS = '- O0' '-g' '-v' '-march = rv64imafdc' '-mabi = lp64d' </pre><br>  Saya mengerti bahwa meskipun dalam bentuk singkat ini banyak, jadi izinkan saya menjelaskannya.  Pada baris pertama, <code>gcc</code> menjalankan program <code>collect2</code> , meneruskan argumen <code>crt0.o</code> , <code>crtbegin.o</code> dan <code>crtend.o</code> , <code>-lgcc</code> dan <code>--start-group</code> flag.  Deskripsi collect2 dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> : singkatnya, collect2 mengatur berbagai fungsi inisialisasi saat startup, membuat tata letak dalam satu atau lebih lintasan. <br><br>  Dengan demikian, GCC mengkompilasi beberapa file <code>crt</code> dengan kode kami.  Seperti yang bisa Anda tebak, <code>crt</code> berarti 'C runtime'.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> dijelaskan secara rinci apa <code>crt</code> dimaksudkan untuk setiap <code>crt</code> , tetapi kami tertarik pada <code>crt0</code> , yang melakukan satu hal penting: <br><br><blockquote>  <i>"Objek [crt0] ini diharapkan mengandung karakter <code>_start</code> , yang menunjukkan bootstrap program."</i> </blockquote><br>  Inti dari "bootstrap" tergantung pada platform, tetapi biasanya melibatkan tugas-tugas penting seperti mengatur bingkai stack, meneruskan argumen baris perintah, dan memanggil <code>main</code> .  Ya, kami <i>akhirnya</i> menemukan jawaban untuk pertanyaan: <code>_start</code> memanggil fungsi utama kami! <br><br><a name="6"></a><h1>  Cari tumpukan kami </h1><br>  Kami memecahkan satu teka-teki, tetapi bagaimana hal ini membawa kami lebih dekat ke tujuan semula - untuk menjalankan program C sederhana di <code>gdb</code> ?  Masih untuk menyelesaikan beberapa masalah: yang pertama terkait dengan bagaimana <code>crt0</code> mengkonfigurasi stack kita. <br><br>  Seperti yang kita lihat di atas, <code>gcc</code> default untuk <code>crt0</code> .  Parameter default dipilih berdasarkan beberapa faktor: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Triplet target</a> sesuai dengan struktur <code>machine-vendor-operatingsystem</code> .  Kami memilikinya <code>riscv64-unknown-elf</code> <br></li><li>  Arsitektur Target, <code>rv64imafdc</code> <br></li><li>  Target ABI, <code>lp64d</code> </li></ul><br>  Biasanya semuanya berfungsi dengan baik, tetapi tidak untuk setiap prosesor RISC-V.  Seperti disebutkan sebelumnya, salah satu tugas <code>crt0</code> adalah mengkonfigurasi stack.  Tapi dia tidak tahu di mana tepatnya tumpukan seharusnya untuk CPU kita ( <code>-machine</code> )?  Dia tidak bisa melakukannya tanpa bantuan kita. <br><br>  Dalam <code>qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -kernel a.out</code> kami menggunakan mesin <code>virt</code> .  Untungnya, <code>qemu</code> memudahkan untuk membuang informasi mesin ke dump <code>dtb</code> (device tree blob). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Go to the ~/usys/riscv folder we created before and create a new dir # for our machine information. cd ~/usys/riscv &amp;&amp; mkdir machines cd machines # Use qemu to dump info about the 'virt' machine in dtb (device tree blob) # format. # The data in this file represents hardware components of a given # machine / device / board. qemu-system-riscv64 -machine virt -machine dumpdtb=riscv64-virt.dtb</span></span></code> </pre> <br>  Data dtb sulit dibaca karena pada dasarnya format biner, tetapi ada utilitas baris perintah <code>dtc</code> (kompilator hierarki perangkat) yang dapat mengonversi file menjadi sesuatu yang lebih mudah dibaca. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># I'm running MacOS, so I use Homebrew to install this. If you're # running another OS you may need to do something else. brew install dtc # Convert our .dtb into a human-readable .dts (device tree source) file. dtc -I dtb -O dts -o riscv64-virt.dts riscv64-virt.dtb</span></span></code> </pre> <br>  File outputnya adalah <code>riscv64-virt.dts</code> , di mana kita melihat banyak informasi menarik tentang <code>virt</code> : jumlah core prosesor yang tersedia, lokasi memori berbagai perangkat periferal, seperti UART, lokasi memori internal (RAM).  Tumpukan harus ada di memori ini, jadi cari dengan <code>grep</code> : <br><br><pre> <code class="bash hljs">grep memory riscv64-virt.dts -A 3 memory@80000000 { device_type = <span class="hljs-string"><span class="hljs-string">"memory"</span></span>; reg = &lt;0x00 0x80000000 0x00 0x8000000&gt;; };</code> </pre> <br>  Seperti yang Anda lihat, simpul ini memiliki 'memori' yang ditentukan sebagai <code>device_type</code> .  Rupanya, kami menemukan apa yang kami cari.  Dengan nilai-nilai di dalam <code>reg = &lt;...&gt; ;</code>  Anda dapat menentukan di mana bank memori dimulai dan berapa panjangnya. <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi devicetree, kita</a> melihat bahwa sintaks <code>reg</code> adalah jumlah pasangan <code>(base_address, length)</code> .  Namun, ada empat arti di dalam <code>reg</code> .  Aneh, bukankah dua nilai cukup untuk satu bank memori? <br><br>  Sekali lagi, dari spesifikasi devicetree (mencari properti <code>reg</code> ) kami menemukan bahwa jumlah sel <code>&lt;u32&gt;</code> untuk menentukan alamat dan panjangnya ditentukan oleh properti <code>#address-cells</code> dan <code>#size-cells</code> dalam node induk (atau dalam node itu sendiri).  Nilai-nilai ini tidak ditentukan dalam simpul memori kami, dan simpul memori induk hanyalah akar dari file.  Mari kita lihat nilai-nilai ini: <br><br><pre> <code class="plaintext hljs">head -n8 riscv64-virt.dts /dts-v1/; / { #address-cells = &lt;0x02&gt;; #size-cells = &lt;0x02&gt;; compatible = "riscv-virtio"; model = "riscv-virtio,qemu";</code> </pre> <br>  Ternyata alamat dan panjangnya membutuhkan dua nilai 32-bit.  Ini berarti bahwa dengan <code>reg = &lt;0x00 0x80000000 0x00 0x8000000&gt;;</code>  memori kita dimulai <code> 0x00 + 0x80000000 (0x80000000)</code> dan menempati <code>0x00 + 0x8000000 (0x8000000)</code> byte, yaitu berakhir pada <code>0x88000000</code> , yang sesuai dengan 128 megabyte. <br><br><a name="7"></a><h1>  Tata letak </h1><br>  Menggunakan <code>qemu</code> dan <code>dtc</code> kami menemukan alamat RAM di mesin virtual virt.  Kita juga tahu bahwa <code>gcc</code> menyusun <code>crt0</code> secara default, tanpa mengkonfigurasi stack seperti yang kita butuhkan.  Tetapi bagaimana cara menggunakan informasi ini untuk akhirnya menjalankan dan men-debug program? <br><br>  Karena <code>crt0</code> tidak sesuai dengan kita, ada satu opsi yang jelas: tulis kode Anda sendiri, lalu susun dengan file objek yang kami peroleh setelah mengkompilasi program sederhana kami.  <code>crt0</code> kami perlu tahu di mana bagian atas tumpukan dimulai untuk menginisialisasi dengan benar.  Kami dapat <code>crt0</code> nilai <code>0x80000000</code> langsung ke <code>crt0</code> , tetapi ini bukan solusi yang sangat cocok, dengan mempertimbangkan perubahan akun yang mungkin diperlukan di masa mendatang.  Bagaimana jika kita ingin menggunakan CPU lain, seperti <code>sifive_e</code> , dengan karakteristik berbeda di emulator? <br><br>  Untungnya, kita bukan orang pertama yang mengajukan pertanyaan ini, dan solusi yang baik sudah ada.  GNU <code>ld</code> linker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memungkinkan Anda untuk menentukan karakter yang</a> tersedia dari <code>crt0</code> kami.  Kita dapat mendefinisikan simbol <code>__stack_top</code> cocok untuk prosesor yang berbeda. <br><br>  Alih-alih menulis file tautan Anda sendiri dari awal, masuk akal untuk mengambil skrip default dengan <code>ld</code> dan memodifikasinya sedikit untuk mendukung karakter tambahan.  Apa itu skrip tautan?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://www.scoberlin.de/content/media/">Berikut ini deskripsi yang bagus</a> : <br><br><blockquote>  <i>Tujuan utama skrip linker adalah untuk menggambarkan bagaimana bagian file dicocokkan dalam input dan output, dan untuk mengontrol tata letak memori dari file output.</i> </blockquote><br>  Mengetahui hal ini, mari salin skrip <code>riscv64-unknown-elf-ld</code> default <code>riscv64-unknown-elf-ld</code> ke file baru: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/usys/riscv <span class="hljs-comment"><span class="hljs-comment"># Make a new dir for custom linker scripts out RISC-V CPUs may require. mkdir ld &amp;&amp; cd ld # Copy the default linker script into riscv64-virt.ld riscv64-unknown-elf-ld --verbose &gt; riscv64-virt.ld</span></span></code> </pre> <br>  File ini memiliki <i>banyak</i> informasi menarik, lebih dari yang bisa kita bahas dalam artikel ini.  Output terperinci dengan <code>--Verbose</code> mencakup informasi tentang versi <code>ld</code> , arsitektur yang didukung, dan banyak lagi.  Ini semua baik untuk diketahui, tetapi sintaks seperti itu tidak dapat diterima dalam skrip tautan, jadi buka editor teks dan hapus semua yang tidak perlu dari file. <br><br><pre>  vim riscv64-virt.ld<font></font>
<font></font>
 # Hapus semua yang di atas dan termasuk baris =============
 GNU ld (GNU Binutils) 2.32
   Emulasi yang didukung:
    elf64lriscv
    elf32lriscv
 menggunakan skrip tautan internal:
 ===================================================
 / * Script untuk -z combreloc: menggabungkan dan mengurutkan bagian reloc * /
 / * Hak Cipta (C) 2014-2019 Free Software Foundation, Inc.
    Menyalin dan mendistribusikan skrip ini, dengan atau tanpa modifikasi,
    diizinkan dalam media apa pun tanpa royalti dengan ketentuan hak cipta
    pemberitahuan dan pemberitahuan ini dilestarikan.  * /
 OUTPUT_FORMAT ("elf64-littleriscv", "elf64-littleriscv",
	       "elf64-littleriscv")
 ... sisa skrip tautan ... </pre><br>  Setelah itu, jalankan perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MEMORY</a> untuk secara manual menentukan di mana <code>__stack_top</code> akan berada.  Temukan baris yang dimulai dengan <code>OUTPUT_ARCH(riscv)</code> , harus berada di bagian atas file, dan tambahkan perintah <code>MEMORY</code> di bawahnya: <br><br><pre> <code class="plaintext hljs">OUTPUT_ARCH(riscv) /* &gt;&gt;&gt; Our addition. &lt;&lt;&lt; */ MEMORY { /* qemu-system-risc64 virt machine */ RAM (rwx) : ORIGIN = 0x80000000, LENGTH = 128M } /* &gt;&gt;&gt; End of our addition. &lt;&lt;&lt; */ ENTRY(_start)</code> </pre> <br>  Kami membuat blok memori yang disebut <code>RAM</code> , yang memungkinkan pembacaan ( <code>r</code> ), penulisan ( <code>w</code> ), dan penyimpanan kode yang dapat dieksekusi ( <code>x</code> ) diizinkan. <br><br>  Hebat, kami telah mendefinisikan tata letak memori yang sesuai dengan spesifikasi mesin RISC-V kami yang hebat.  Sekarang kamu bisa menggunakannya.  Kami ingin meletakkan tumpukan kami di memori. <br><br>  Anda perlu mendefinisikan karakter <code>__stack_top</code> .  Buka skrip <code>riscv64-virt.ld</code> ( <code>riscv64-virt.ld</code> ) dalam editor teks dan tambahkan beberapa baris: <br><br><pre> <code class="plaintext hljs">SECTIONS { /* Read-only sections, merged into text segment: */ PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x10000)); . = SEGMENT_START("text-segment", 0x10000) + SIZEOF_HEADERS; /* &gt;&gt;&gt; Our addition. &lt;&lt;&lt; */ PROVIDE(__stack_top = ORIGIN(RAM) + LENGTH(RAM)); /* &gt;&gt;&gt; End of our addition. &lt;&lt;&lt; */ .interp : { *(.interp) } .note.gnu.build-id : { *(.note.gnu.build-id) }</code> </pre> <br>  Seperti yang Anda lihat, kami mendefinisikan <code>__stack_top</code> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perintah</a> <code>__stack_top</code> .  Simbol akan dapat diakses dari program apa pun yang terkait dengan skrip ini (dengan asumsi bahwa program itu sendiri tidak akan menentukan sesuatu dengan nama <code>__stack_top</code> ).  Set <code>__stack_top</code> ke <code>ORIGIN(RAM)</code> .  Kita tahu bahwa nilai ini adalah <code>0x80000000</code> plus <code>LENGTH(RAM)</code> , yaitu 128 megabytes ( <code>0x8000000</code> bytes).  Ini berarti <code>__stack_top</code> kami disetel ke <code>0x88000000</code> . <br><br>  Untuk singkatnya, saya tidak akan mencantumkan seluruh file tautan di <a href="">sini</a> , Anda dapat melihatnya di <a href="">sini</a> . <br><br><a name="8"></a><h1>  Hentikan itu!  <s>Hammertime!</s>  Runtime! </h1><br>  Sekarang kita memiliki semua yang kita butuhkan untuk membuat runtime C. Kita sendiri. Sebenarnya, ini adalah tugas yang cukup sederhana, di sini adalah seluruh file <code>crt0.s</code> : <br><br><pre> <code class="plaintext hljs">.section .init, "ax" .global _start _start: .cfi_startproc .cfi_undefined ra .option push .option norelax la gp, __global_pointer$ .option pop la sp, __stack_top add s0, sp, zero jal zero, main .cfi_endproc .end</code> </pre> <br>  Segera menarik sejumlah besar garis yang dimulai dengan titik.  Ini adalah file untuk assembler <code>as</code> .  Garis dengan titik-titik disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arahan assembler</a> : mereka memberikan informasi untuk assembler.  Ini bukan kode yang dapat dieksekusi, seperti instruksi assembler RISC-V seperti <code>jal</code> dan <code>add</code> . <br><br>  Mari kita pergi melalui file baris demi baris.  Kami akan bekerja dengan berbagai register RISC-V standar, jadi lihat <a href="">tabel ini</a> , yang mencakup semua register dan tujuannya. <br><br><pre> <code class="plaintext hljs">.section .init, "ax"</code> </pre> <br>  Seperti ditunjukkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual assembler GNU 'sebagai'</a> , baris ini memberitahu assembler untuk memasukkan kode berikut ke dalam bagian <code>.init</code> , yang dialokasikan ( <code>a</code> ) dan dapat dieksekusi ( <code>x</code> ).  Bagian ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konvensi umum</a> lainnya untuk menjalankan kode dalam sistem operasi.  Kami bekerja pada perangkat keras murni tanpa OS, jadi dalam kasus kami, instruksi seperti itu mungkin tidak mutlak diperlukan, tetapi bagaimanapun juga ini adalah praktik yang baik. <br><br><pre> <code class="plaintext hljs">.global _start _start:</code> </pre> <br>  <code>.global</code> membuat karakter berikut tersedia untuk <code>ld</code> .  Tanpa ini, tautan tidak akan berfungsi, karena perintah <code>ENTRY(_start)</code> di skrip tautan menunjuk ke simbol <code>_start</code> sebagai titik masuk ke file yang dapat dieksekusi.  Baris berikutnya memberi tahu assembler bahwa kita mulai mendefinisikan karakter <code>_start</code> . <br><br><pre> <code class="plaintext hljs">_start: .cfi_startproc .cfi_undefined ra ...other stuff... .cfi_endproc</code> </pre> <br>  Arahan <code>.cfi</code> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memberi tahu Anda</a> tentang struktur bingkai dan cara menanganinya.  <code>.cfi_startproc</code> dan <code>.cfi_endproc</code> memberi sinyal awal dan akhir fungsi, dan <code>.cfi_undefined ra</code> memberi tahu assembler bahwa <code>ra</code> register <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak boleh dikembalikan</a> ke nilai apa pun yang dikandungnya sebelum <code>_start</code> . <br><br><pre> <code class="plaintext hljs">.option push .option norelax la gp, __global_pointer$ .option pop</code> </pre> <br>  Arahan <code>.option</code> ini mengubah perilaku assembler sesuai dengan kode ketika Anda perlu menerapkan serangkaian opsi tertentu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah</a> uraian terperinci tentang mengapa penggunaan <code>.option</code> di segmen ini penting: <br><br><blockquote>  <i>... karena kita mungkin mengendurkan pengalamatan urutan ke urutan yang lebih pendek relatif terhadap GP, pemuatan awal GP tidak boleh dilemahkan dan harus seperti ini:</i> <i><br><br></i> <pre> <code class="plaintext hljs">.option push .option norelax la gp, __global_pointer$ .option pop</code> </pre> <br>  sehingga setelah relaksasi Anda mendapatkan kode berikut: <br><br><pre> <code class="plaintext hljs">auipc gp, %pcrel_hi(__global_pointer$) addi gp, gp, %pcrel_lo(__global_pointer$)</code> </pre> <br>  bukannya sederhana: <br><br><pre> <code class="plaintext hljs">addi gp, gp, 0</code> </pre> </blockquote><br>  Dan sekarang bagian terakhir dari <code>crt0.s</code> kami: <br><br><pre> <code class="plaintext hljs">_start: ...other stuff... la sp, __stack_top add s0, sp, zero jal zero, main .cfi_endproc .end</code> </pre> <br>  Di sini kita akhirnya dapat menggunakan simbol <code>__stack_top</code> , yang telah kami kerjakan dengan susah payah untuk dibuat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The pseudo-instructions</a> <code>la</code> (memuat alamat) memuat nilai <code>__stack_top</code> ke register <code>sp</code> (stack pointer), mengaturnya untuk digunakan di seluruh program. <br><br>  Kemudian <code>add s0, sp, zero</code> menambahkan nilai register <code>sp</code> dan <code>zero</code> (yang sebenarnya merupakan register <code>x0</code> dengan referensi sulit ke 0) dan menempatkan hasilnya di register <code>s0</code> .  Ini adalah <a href="">register khusus</a> yang tidak biasa dalam beberapa hal.  Pertama, ini adalah "register persisten", yaitu disimpan ketika fungsi memanggil.  Kedua, <code>s0</code> terkadang bertindak sebagai frame pointer, yang memberi setiap fungsi panggilan ruang kecil di stack untuk menyimpan parameter yang dilewatkan ke fungsi ini.  Cara kerja pemanggilan fungsi dengan stack dan frame pointer adalah topik yang sangat menarik yang dapat Anda gunakan dengan mudah untuk artikel terpisah, tetapi untuk sekarang, ketahuilah bahwa dalam runtime kami, penting untuk menginisialisasi penunjuk bingkai <code>s0</code> . <br><br>  Selanjutnya kita melihat <code>jal zero, main</code> pernyataan <code>jal zero, main</code> .  Di sini, <code>jal</code> adalah singkatan dari Jump And Link.  Instruksi mengharapkan operan dalam bentuk <code>jal rd (destination register), offset_address</code> .  Secara fungsional, <code>jal</code> menulis nilai instruksi berikutnya (register <code>pc</code> plus empat) ke <code>rd</code> , dan kemudian mengatur register <code>pc</code> ke nilai <code>pc</code> saat ini ditambah alamat offset dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi tanda</a> , secara efektif “memanggil” alamat ini. <br><br>  Seperti disebutkan di atas, <code>x0</code> terikat erat dengan nilai literal 0, dan menulis padanya tidak berguna.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, mungkin aneh jika kita menggunakan register sebagai register tujuan </font></font><code>zero</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang ditafsirkan oleh perakit RISC-V sebagai register </font></font><code>x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Bagaimanapun, ini berarti transisi tanpa syarat ke </font></font><code>offset_address</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mengapa melakukan ini, karena di arsitektur lain ada instruksi eksplisit untuk transisi tanpa syarat? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola aneh </font></font><code>jal zero, offset_address</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini sebenarnya optimasi cerdas. Dukungan untuk setiap instruksi baru berarti peningkatan dan, akibatnya, kenaikan biaya prosesor. Karena itu, semakin sederhana ISA, semakin baik. Alih-alih mencemari ruang instruksi dengan dua instruksi </font></font><code>jal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>unconditional jump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, arsitektur RISC-V hanya mendukung </font></font><code>jal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan lompatan tanpa syarat didukung melalui </font></font><code>jal zero, main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RISC-V memiliki banyak optimasi seperti itu, sebagian besar mengambil bentuk yang disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruksi semu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Perakit tahu cara menerjemahkannya ke instruksi perangkat keras yang nyata. </font><font style="vertical-align: inherit;">Misalnya, </font></font><code>j offset_address</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perakit RISC-V menerjemahkan instruksi </font><font style="vertical-align: inherit;">semu </font><font style="vertical-align: inherit;">untuk lompatan </font><font style="vertical-align: inherit;">tanpa syarat </font></font><code>jal zero, offset_address</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk daftar lengkap </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruksi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pseudo yang didukung secara resmi </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> lihat </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">spesifikasi RISC-V (versi 2.2)</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="plaintext hljs">_start: ...other stuff... jal zero, main .cfi_endproc .end</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baris terakhir kami adalah direktif assembler </font></font><code>.end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang hanya menandai akhir file.</font></font><br><br><a name="9"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debug tapi sekarang nyata </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencoba men-debug program C sederhana pada prosesor RISC-V, kami memecahkan banyak masalah. </font><font style="vertical-align: inherit;">Pertama, menggunakan </font></font><code>qemu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>dtc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menemukan memori kita di mesin virtual </font></font><code>virt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RISC-V. </font><font style="vertical-align: inherit;">Kemudian kami menggunakan informasi ini untuk secara manual mengontrol alokasi memori dalam versi kami dari skrip default tautan </font></font><code>riscv64-unknown-elf-ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang memungkinkan kami untuk menentukan simbol secara akurat </font></font><code>__stack_top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian kami menggunakan simbol ini dalam versi kami sendiri </font></font><code>crt0.s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang mengatur tumpukan kami dan petunjuk global, dan akhirnya disebut fungsi </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sekarang Anda dapat mencapai tujuan Anda dan mulai men-debug program sederhana kami di GDB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingat di sini adalah program C itu sendiri:</font></font><br><br><pre> <code class="cpp hljs">cat add.<span class="hljs-function"><span class="hljs-function">c </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompilasi dan penautan: </font></font><br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gcc -g -ffreestanding -O0 -Wl,--gc-sections -nostartfiles -nostdlib -nodefaultlibs -Wl,-T,riscv64-virt.ld crt0.s add.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kami menunjukkan lebih banyak bendera daripada yang terakhir, jadi mari kita lihat yang belum kami uraikan sebelumnya. </font></font><br><br> <code>-ffreestanding</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memberitahu kompiler bahwa perpustakaan standar mungkin tidak ada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jadi tidak perlu membuat asumsi tentang keberadaan wajibnya. Parameter ini tidak diperlukan ketika memulai aplikasi pada host-nya (dalam sistem operasi), tetapi dalam hal ini tidak, oleh karena itu penting untuk menginformasikan kepada kompiler informasi ini. </font></font><br><br> <code>-Wl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Daftar bendera yang dipisahkan koma untuk dilewati ke tautan ( </font></font><code>ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Di sini, ini </font></font><code>--gc-sections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berarti “bagian pengumpulan sampah”, dan </font></font><code>ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperintahkan untuk menghapus bagian yang tidak digunakan setelah menautkan. Tandai </font></font><code>-nostartfiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>-nostdlib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>-nodefaultlibs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beri tahu penghubung untuk tidak memproses file startup sistem standar (misalnya, default</font></font><code>crt0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), implementasi standar stdlib sistem dan pustaka terkait standar sistem standar. </font><font style="vertical-align: inherit;">Kami memiliki skrip </font></font><code>crt0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tautan </font><font style="vertical-align: inherit;">kami sendiri </font><font style="vertical-align: inherit;">, jadi penting untuk meneruskan bendera ini sehingga nilai default tidak bertentangan dengan preferensi pengguna kami. </font></font><br><br> <code>-T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan jalur ke skrip linker kami, yang sederhana dalam kasus kami </font></font><code>riscv64-virt.ld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Akhirnya, kami menentukan file yang ingin dikompilasi, dikompilasi, dan dikomposisikan: </font></font><code>crt0.s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>add.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seperti sebelumnya, hasilnya adalah file yang lengkap dan siap dijalankan yang disebut </font></font><code>a.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang jalankan executable baru kami yang sangat baru di </font></font><code>qemu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -S freezes execution of our executable (-kernel) until we explicitly tell # it to start with a 'continue' or 'c' from our gdb client qemu-system-riscv64 -machine virt -m 128M -gdb tcp::1234 -S -kernel a.out</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang jalankan </font></font><code>gdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ingat untuk memuat simbol debugging untuk </font></font><code>a.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tentukan dengan argumen terakhir:</font></font><br><br><pre> <code class="bash hljs">riscv64-unknown-elf-gdb --tui a.out GNU gdb (GDB) 8.2.90.20190228-git Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type <span class="hljs-string"><span class="hljs-string">"show copying"</span></span> and <span class="hljs-string"><span class="hljs-string">"show warranty"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. This GDB was configured as <span class="hljs-string"><span class="hljs-string">"--host=x86_64-apple-darwin17.7.0 --target=riscv64-unknown-elf"</span></span>. Type <span class="hljs-string"><span class="hljs-string">"show configuration"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">"help"</span></span>. Type <span class="hljs-string"><span class="hljs-string">"apropos word"</span></span> to search <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commands related to <span class="hljs-string"><span class="hljs-string">"word"</span></span>... Reading symbols from a.out... (gdb)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian hubungkan klien kami </font></font><code>gdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke server </font></font><code>gdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang kami luncurkan sebagai bagian dari perintah </font></font><code>qemu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="bash hljs">(gdb) target remote :1234 │ Remote debugging using :1234</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atur breakpoint di main: </font></font><br><br><pre> <code class="bash hljs">(gdb) b main Breakpoint 1 at 0x8000001e: file add.c, line 2.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan mulai programnya: </font></font><br><br><pre> <code class="bash hljs">(gdb) c Continuing. Breakpoint 1, main () at add.c:2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari output yang diberikan, jelas bahwa kita berhasil mencapai breakpoint di jalur 2! </font><font style="vertical-align: inherit;">Hal ini terbukti dalam antarmuka teks, akhirnya, kita memiliki garis yang tepat </font></font><code>L</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nilai </font></font><code>PC:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang sama </font></font><code>L2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>PC:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>0x8000001e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika Anda melakukan semuanya seperti pada artikel, maka hasilnya akan seperti ini: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd8/aa9/78d/bd8aa978df4289f584b5c422cdb6e44c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai sekarang, Anda dapat menggunakannya </font></font><code>gdb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti biasa: </font></font><code>-s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk pergi ke instruksi berikutnya, </font></font><code>info all-registers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memeriksa nilai-nilai di dalam register ketika program berjalan, dll. Percobaan untuk kesenangan Anda ... kami, tentu saja , banyak bekerja untuk ini!</font></font><br><br><a name="10"></a><h1>  Apa selanjutnya </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hari ini kami telah mencapai banyak hal dan, saya harap, telah belajar banyak! Saya tidak pernah memiliki rencana formal untuk ini dan artikel-artikel berikutnya, saya hanya mengikuti apa yang paling menarik bagi saya setiap saat. Karenanya, saya tidak yakin apa yang akan terjadi selanjutnya. Saya terutama menyukai perendaman mendalam dalam instruksi </font></font><code>jal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi mungkin di artikel berikutnya kita akan mengambil sebagai dasar pengetahuan yang diperoleh di sini, tetapi menggantinya dengan </font></font><code>add.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa program di assembler RISC-V murni. Jika Anda memiliki sesuatu yang spesifik yang ingin Anda lihat atau memiliki pertanyaan, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buka tiket</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih sudah membaca! Saya berharap bertemu di artikel selanjutnya!</font></font><br><br><a name="11"></a><h1>  Opsional </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menyukai artikel ini dan ingin tahu lebih banyak, lihat presentasi Matt Godbolt berjudul </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Bits Between Bits: Bagaimana Kita Menjadi Main ()"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari konferensi CppCon2018. </font><font style="vertical-align: inherit;">Dia mendekati topik sedikit berbeda dari kita di sini. </font><font style="vertical-align: inherit;">Kuliah yang sangat bagus, buktikan sendiri!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454208/">https://habr.com/ru/post/id454208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454190/index.html">Apa yang tidak perlu Anda lakukan jika ponsel Anda dicuri</a></li>
<li><a href="../id454196/index.html">Pencetakan 3D elektronik menggunakan contoh drone: kabel dan papan tidak lagi diperlukan</a></li>
<li><a href="../id454198/index.html">Membuat proyek multi-modul Gradle SpringBoot + Angular di IDEA</a></li>
<li><a href="../id454204/index.html">Perayapan perilaku bukan obat mujarab?</a></li>
<li><a href="../id454206/index.html">PHDays 9: Parsing AI CTF</a></li>
<li><a href="../id454210/index.html">Enchantjs terlupakan + 1C-Bitrix baru = Game untuk motivasi pelanggan</a></li>
<li><a href="../id454214/index.html">Saya benci hampir semua perangkat lunak</a></li>
<li><a href="../id454216/index.html">Bukti yang ditemukan bahwa semua perubahan adalah campuran urutan dan peluang</a></li>
<li><a href="../id454220/index.html">Termometer dua digit</a></li>
<li><a href="../id454222/index.html">Mutakhirkan subsistem disk server lama dengan bus PCIe 1.0 - 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>