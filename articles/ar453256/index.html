<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♠️ 🖍️ 🤛🏿 SObjectizer-5.6.0: تقطع مباشرة لتنمو أكثر 🔭 🚶🏿 👰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في اليوم الثالث ، أصبح إصدار جديد من SObjectizer متوفرًا : 5.6.0 . السمة الرئيسية هي رفض التوافق مع الفرع السابق المستقر 5.5 ، والذي ظل يتطور بثبات عل...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SObjectizer-5.6.0: تقطع مباشرة لتنمو أكثر</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453256/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/vp/ah/jx/vpahjx-dkpsauwtfzyeiktnsfp4.jpeg"></p><br><p style=";text-align:right;direction:rtl">  في اليوم الثالث ، أصبح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">إصدار جديد من SObjectizer</a> متوفرًا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">: 5.6.0</a> .  السمة الرئيسية هي رفض التوافق مع الفرع السابق المستقر 5.5 ، والذي ظل يتطور بثبات على مدار أربع سنوات ونصف. </p><br><p style=";text-align:right;direction:rtl">  ظلت المبادئ الأساسية لتشغيل SObjectizer-5 كما هي.  الاتصالات والوكلاء والتعاون والمرسلين لا تزال معنا.  لكن شيئا ما تغير بشكل خطير ، تم إلقاء شيء بشكل عام.  لذلك ، فقط أخذ SO-5.6.0 وإعادة ترجمة التعليمات البرمجية الخاصة بك سوف تفشل.  يجب إعادة كتابة شيء ما.  قد يلزم إعادة تصميم شيء ما. </p><br><p style=";text-align:right;direction:rtl">  لماذا اعتنى بالتوافق لعدة سنوات ، ثم قررنا أن نكسر كل شيء؟  وما الذي كسر أكثر شمولاً؟ </p><br><p style=";text-align:right;direction:rtl">  سأحاول التحدث عن هذا في هذه المقالة. </p><br><h1 id="zachem-voobsche-potrebovalos-chto-to-lomat" style=";text-align:right;direction:rtl">  لماذا تحتاج لكسر شيء ما؟ </h1><br><p style=";text-align:right;direction:rtl">  الأمر بهذه البساطة. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  استوعبت SObjectizer-5.5 أثناء تطويرها العديد من الأشياء المختلفة والمتنوعة التي لم تكن مخططة في الأصل ، ونتيجة لذلك ، فقد شكلت الكثير من العكازات والدعائم في الداخل.  مع كل إصدار جديد ، أصبح إضافة شيء جديد إلى SO-5.5 أصعب وأصعب.  وأخيرا ، على السؤال "لماذا نحتاج كل هذا؟"  لم يتم العثور على إجابة مناسبة. </p><br><p style=";text-align:right;direction:rtl">  وبالتالي فإن السبب الأول هو إعادة تعقيد حوصرات SObjectizer. </p><br><p style=";text-align:right;direction:rtl">  السبب الثاني هو أننا تعبنا بغباء من التركيز على المجمعين C ++ القديمة.  بدأ فرع 5.5 في عام 2014 ، عندما كان لدينا ، إذا لم أكن مخطئًا ، gcc-4.8 و MSVS2013.  وعلى هذا المستوى ، ما زلنا نواصل الحفاظ على حاجز متطلبات مستوى الدعم لمعيار C ++. </p><br><p style=";text-align:right;direction:rtl">  في البداية ، كان لدينا "مصلحة أنانية" في هذا.  بالإضافة إلى ذلك ، نظرنا لبعض الوقت إلى المتطلبات المنخفضة لجودة الدعم لمعيار C ++ باعتبارها "ميزتنا التنافسية". </p><br><p style=";text-align:right;direction:rtl">  ولكن الوقت يمضي ، "المصلحة الأنانية" قد انتهت.  بعض الفوائد من هذه "الميزة التنافسية" غير مرئية.  ربما سيكونون كذلك ، إذا عملنا مع C ++ 98 على الإطلاق ، فسنكون مهتمين بالمشروع الدموي.  لكن المشروع الدموي في مثل هؤلاء ، من حيث المبدأ ، ليست مهتمة.  لذلك ، فقد تقرر التوقف عن الحد من أنفسنا واتخاذ شيء أعذب.  لذلك أخذنا المستقر الجديد في الوقت الحالي: C ++ 17. </p><br><p style=";text-align:right;direction:rtl">  من الواضح ، لن يحب الجميع هذا الحل ، بعد كل شيء ، بالنسبة للعديد من C ++ 17 ، هذه الآن ميزة رائدة لا يمكن الوصول إليها ، والتي لا تزال بعيدة جدًا. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، قررنا مثل هذا الخطر.  ومع ذلك ، فإن عملية الترويج لـ SObjectizer لا تسير بسرعة ، لذلك عندما يصبح SObjectizer أكثر أو أقل انتشارًا في الطلب ، لن يكون C ++ 17 "حافة رائدة".  بدلاً من ذلك ، سيتم التعامل معها كما هي الآن في C ++ 11. </p><br><p style=";text-align:right;direction:rtl">  بشكل عام ، بدلاً من الاستمرار في إنشاء عكازات باستخدام مجموعة فرعية من C ++ 11 ، قررنا إعادة تشكيل الأجزاء الداخلية من SObjectizer بشكل جدي باستخدام C ++ 17.  لبناء قاعدة يمكن أن يتطور عليها SObjectizer تدريجياً خلال السنوات الأربع أو الخمس القادمة. </p><br><h1 id="chto-serezno-pomenyalos-v-sobjectizer-56" style=";text-align:right;direction:rtl">  ما الذي تغير بشكل خطير في SObjectizer-5.6؟ </h1><br><p style=";text-align:right;direction:rtl">  الآن ، دعنا ننتقل لفترة وجيزة إلى بعض التغييرات الأكثر لفتا للنظر. </p><br><h2 id="u-kooperaciy-agentov-bolshe-net-strokovyh-imen" style=";text-align:right;direction:rtl">  لم يعد التعاون بين الوكلاء أسماء سلسلة </h2><br><h3 id="problema" style=";text-align:right;direction:rtl">  المشكلة </h3><br><p style=";text-align:right;direction:rtl">  منذ البداية ، طالب SObjectizer-5 بأن يكون لكل تعاون اسم سلسلة فريد خاص به.  تم توريث هذه الميزة من SObjectizer الخامس من SObjectizer السابق ، الرابع. </p><br><p style=";text-align:right;direction:rtl">  وفقا لذلك ، SObjectizer اللازمة لتخزين أسماء التعاون المسجلة.  تحقق تفردهم في التسجيل.  ابحث عن التعاون بالاسم أثناء إلغاء التسجيل ، إلخ ، إلخ. </p><br><p style=";text-align:right;direction:rtl">  منذ الإصدارات الأولى ، تم استخدام مخطط بسيط في SObjectzer-5: قاموس واحد للتعاون المسجلة المحمي بواسطة mutex.  عند تسجيل التعاون ، يتم التقاط كائن المزامنة (mutex) ، وتفرد اسم التعاون ، ووجود أحد الوالدين ، إلخ.  بعد التدقيق ، يتم تعديل القاموس ، وبعد ذلك يتم تحرير كائن المزامنة.  هذا يعني أنه في نفس الوقت الذي يبدأ فيه تسجيل / إلغاء تسجيل العديد من التعاونيات في وقت واحد ، ثم في بعض النقاط سوف تتوقف وتنتظر حتى تكتمل إحدى العمليات مع القاموس التعاوني.  وبسبب هذا ، لم تكن العمليات التعاونية جيدة. </p><br><p style=";text-align:right;direction:rtl">  هذا ما أردت أن أتخلص منه من أجل تحسين الوضع بسرعة تسجيل التعاون. </p><br><h3 id="reshenie" style=";text-align:right;direction:rtl">  قرار </h3><br><p style=";text-align:right;direction:rtl">  تم النظر في طريقتين رئيسيتين لحل هذه المشكلة. </p><br><p style=";text-align:right;direction:rtl">  أولاً ، تخزين أسماء السلسلة ، ولكن تغيير طريقة تخزين القاموس بحيث يمكن توسيع نطاق عملية تسجيل التعاون.  على سبيل المثال ، مشاركة القاموس ، أي  تقسيمها إلى عدة قطع ، كل منها سيكون محميًا بواسطة كائن المزامنة الخاص به. </p><br><p style=";text-align:right;direction:rtl">  ثانياً ، رفض كامل لأسماء السلسلة واستخدام بعض المعرفات المعينة بواسطة SObjectizer. </p><br><p style=";text-align:right;direction:rtl"> نتيجة لذلك ، اخترنا الطريقة الثانية وتخلينا تمامًا عن تسمية التعاونيات.  الآن في SObjectizer ، يوجد شيء مثل <code>coop_handle</code> ، أي  مؤشر يتم إخفاء محتوياته عن المستخدم ، ولكن يمكن مقارنته مع <code>std::weak_ptr</code> . </p><br><p style=";text-align:right;direction:rtl">  إرجاع <code>coop_handle</code> عند تسجيل التعاون: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    .</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  يجب استخدام هذا المقبض لإلغاء تسجيل التعاون: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    . ... // - . // ,     . //       . env.deregister_coop(coop_id, ...);</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  أيضًا ، يجب استخدام هذا المقبض عند إنشاء علاقة بين الوالدين والطفل: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . auto parent = env.make_coop(); ... //  parent . auto parent_id = env.register_coop(std::move(parent)); //  . ... //      ,    . auto child = env.make_coop(parent_id); ...</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  كما تم تغيير هيكل مستودع التعاون داخل بيئة SObjectizer بشكل كبير.  إذا كان قبل الإصدار 5.5 ضمنيًا قاموسًا مشتركًا واحدًا ، فكل تعاون الآن هو مستودع للروابط الخاصة بالتعاونيات الفرعية.  أي  تشكل التعاونيات شجرة ذات جذر في تعاونية جذر خاصة مخفية عن المستخدم. </p><br><p style=";text-align:right;direction:rtl">  مثل هذا الهيكل يجعل من الممكن توسيع نطاق عمليات <code>register_coop</code> و <code>deregister_coop</code> بشكل أفضل: لا يحدث الحظر المتبادل للعمليات الموازية إلا إذا كان كلاهما ينتمي إلى نفس التعاون الأبوي.  للتوضيح ، إليك نتيجة لإطلاق <a href="" rel="nofollow">معيار خاص</a> يقيس أداء العمليات بالتعاون مع جهاز الكمبيوتر المحمول القديم الخاص بي مع Ubuntu 16.04 و GCC-7.3: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 15.69s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p style=";text-align:right;direction:rtl">  أي  الإصدار 5.6.0 تعاملت مع ما يقرب من 2M التعاون في ~ 15.5 ثانية. </p><br><p style=";text-align:right;direction:rtl">  وإليكم الإصدار 5.5.24.4 ، آخر فرع 5.5 في الوقت الحالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 46.856s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p style=";text-align:right;direction:rtl">  نفس السيناريو ، ولكن النتيجة أسوأ ثلاث مرات. </p><br><h2 id="ostalsya-vsego-odin-vid-dispetcherov" style=";text-align:right;direction:rtl">  هناك نوع واحد فقط من المرسلين اليسار </h2><br><p style=";text-align:right;direction:rtl">  المرسلون أحد أحجار الزاوية في SObjectizer.  إن المرسلين هم الذين يحددون مكان وكيفية قيام الوكلاء بمعالجة رسائلهم.  لذلك ، دون فكرة المرسلين ، ربما لن يكون هناك SObjectizer. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، فإن المرسلين أنفسهم قد تطوروا وتطوروا وتطوروا مسبقًا إلى درجة أنه لم يكن من الصعب علينا أن نرسل مرسلًا جديدًا لـ SObjectizer-5.5.  لكن مزعجة للغاية.  ومع ذلك ، دعنا نأخذها بالترتيب. </p><br><p style=";text-align:right;direction:rtl">  في البداية ، يمكن إنشاء جميع المرسلين الذين يحتاجهم التطبيق فقط في بداية SObjectizer: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span> }, <span class="hljs-comment"><span class="hljs-comment">//    SObjectizer-. []( so_5::environment_params_t &amp; params ) { p.add_named_dispatcher("active_obj", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("shutdowner", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("groups", so_5::disp::active_group::create_disp()); ... } );</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  لم أقم بإنشاء المدير الضروري قبل البداية - كل شيء ، إنه خطأي ، لا يمكنك تغيير أي شيء. </p><br><p style=";text-align:right;direction:rtl">  من الواضح أن هذا غير مريح ومع توسيع سيناريوهات الاستخدام لـ SObjectizer ، كان من الضروري حل هذه المشكلة.  لذلك ، <code>add_dispatcher_if_not_exists</code> طريقة <code>add_dispatcher_if_not_exists</code> ، والتي تحقق من وجود المرسل ، وإذا لم يكن هناك أي شيء ، يُسمح بإنشاء مثيل جديد: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  وكانت هذه المرسلات تسمى العامة.  كان للمرسلين العامين أسماء فريدة.  وباستخدام هذه الأسماء ، تم ربط العملاء بالمرسلين: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); //         //    . auto coop = env.create_coop( "ping_pong", //     extra_dispatcher. so_5::disp::active_obj::create_disp_binder( "extra_dispatcher" ) ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  لكن المرسلين العامين لديهم ميزة واحدة غير سارة.  بدأوا العمل فور إضافتهم إلى SObjectizer Environment واستمروا في العمل حتى أكملت SObjectizer Environment عملها. </p><br><p style=";text-align:right;direction:rtl">  مرة أخرى ، مع مرور الوقت ، بدأت تتدخل.  كان من الضروري التأكد من إمكانية إضافة المرسلين حسب الحاجة وأن المرسلين الذين أصبحوا غير ضروريين قد تم حذفهم تلقائيًا. </p><br><p style=";text-align:right;direction:rtl">  لذلك كان هناك المرسلون "الخاصون".  هؤلاء المرسلون لم يكن لديهم أسماء وعاشوا طالما كانت هناك إشارات إليهم.  يمكن إنشاء المرسلين الخاصين في أي وقت بعد بدء تشغيل بيئة SObjectizer ، فقد تم تدميرهم تلقائيًا. </p><br><p style=";text-align:right;direction:rtl">  بشكل عام ، تبين أن المرسلين الخاصين حلقة ناجحة جدًا في تطور المرسلين ، لكن العمل معهم كان مختلفًا جدًا عن العمل مع المرسلين العامين: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::create_private_disp(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp-&gt;binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  أكثر المرسلين القطاعين العام والخاص اختلفت في التنفيذ.  لذلك ، من أجل عدم تكرار الشفرة والكتابة بشكل منفصل المرسل العام والخاص بشكل منفصل من نفس النوع ، اضطررت إلى استخدام إنشاءات معقدة إلى حد ما مع القوالب والميراث. </p><br><p style=";text-align:right;direction:rtl">  ونتيجة لذلك ، تعبت من مرافقة كل هذا التنوع ، وفي SObjectizer-5.6 لم يتبق سوى نوع واحد من المرسلين.  في الواقع ، هذا هو التناظرية من المرسلين خاصة.  ولكن فقط دون ذكر صريح لكلمة "خاص".  حتى الآن سيتم كتابة الجزء الموضح أعلاه على النحو التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::make_dispatcher(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp.binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><h2 id="ostalis-tolko-svobodnye-funkcii-send-send_delayed-i-send_periodic" style=";text-align:right;direction:rtl">  لا يوجد سوى وظائف مجانية للإرسال ، send_delayed و send_periodic left </h2><br><p style=";text-align:right;direction:rtl">  يعد تطوير واجهة برمجة التطبيقات لإرسال الرسائل إلى SObjectizer هو المثال الأكثر وضوحًا على كيفية تغيير SObjectizer مع تحسن دعم C ++ 11 في المترجمات المتاحة لنا. </p><br><p style=";text-align:right;direction:rtl">  أولاً ، تم إرسال رسائل مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">mbox-&gt;deliver_message(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...));</code> </pre> <br><p style=";text-align:right;direction:rtl">  أو ، إذا اتبعت "توصيات أفضل مربي الكلاب" (ج): </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;my_message&gt; msg(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...)); mbox-&gt;deliver_message(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg));</code> </pre> <br><p style=";text-align:right;direction:rtl">  ومع ذلك ، فقد وصلنا إلى المجمعين التابعين لنا مع دعم لقوالب varadic وظهرت وظائف الإرسال.  أصبح من الممكن أن تكتب مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">send&lt;my_message&gt;(target, ...);</code> </pre> <br><p style=";text-align:right;direction:rtl">  صحيح ، لقد استغرق الأمر وقتًا أطول لعائلة بأكملها <code>send_to_agent</code> من <code>send</code> بسيط ، بما في ذلك <code>send_to_agent</code> ، <code>send_delayed_to_agent</code> ، إلخ.  وبعد ذلك ، لجعل هذه العائلة أضيق نطاقًا من المجموعة المألوفة <code>send</code> ، <code>send_delayed</code> <code>send_periodic</code> . </p><br><p style=";text-align:right;direction:rtl">  ولكن على الرغم من حقيقة أن مجموعة وظائف الإرسال قد تم تشكيلها منذ فترة طويلة وكانت الطريقة الموصى بها لإرسال الرسائل لعدة سنوات ، فإن الأساليب القديمة مثل <code>deliver_message</code> و <code>single_timer</code> و <code>single_timer</code> كانت متاحة للمستخدم. </p><br><p style=";text-align:right;direction:rtl">  ولكن في الإصدار 5.6.0 ، لم يتم حفظ <code>send_periodic</code> وظائف <code>send</code> المجاني و <code>send_delayed</code> و <code>send_periodic</code> في واجهة برمجة تطبيقات SObjectizer العامة.  تم حذف كل شيء آخر تمامًا أو نقله إلى مساحات أسماء SObjectizer الداخلية. </p><br><p style=";text-align:right;direction:rtl">  لذا في SObjectizer-5.6 ، أصبحت واجهة إرسال الرسائل أخيرًا كما لو كانت لدينا برامج ترجمة مع دعم C ++ 11 عادي من البداية.  حسنًا ، بالإضافة إلى ذلك ، إذا كان لدينا خبرة في استخدام C ++ 11 العادي جدًا. </p><br><h2 id="edinyy-format-send_delayed-i-send_periodic" style=";text-align:right;direction:rtl">  تنسيق واحد send_delayed و send_periodic </h2><br><p style=";text-align:right;direction:rtl">  مع <code>send_delayed</code> و <code>send_periodic</code> في الإصدارات السابقة من SObjectizer ، كان هناك حادث آخر. </p><br><p style=";text-align:right;direction:rtl">  لاستخدام المؤقت ، يجب أن يكون لديك حق الوصول إلى SObjectizer Environment.  داخل الوكيل يوجد رابط إلى بيئة SObjectizer.  وداخل mchain هناك مثل هذا الرابط.  ولكن داخل mbox لم تكن هناك.  لذلك ، إذا تم إرسال رسالة معلقة إلى وكيل أو إلى mchain ، فإن المكالمة <code>send_delayed</code> كالتالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...);</code> </pre> <br><p style=";text-align:right;direction:rtl">  بالنسبة لحالة mbox ، كان علينا أن نأخذ رابطًا إلى SObjectizer Environment من مكان آخر: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">send_delayed&lt;my_message&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;so_environment(), target_mbox, pause, ...);</code> </pre> <br><p style=";text-align:right;direction:rtl">  هذه الميزة من <code>send_delayed</code> و <code>send_periodic</code> كانت منشقة بسيطة.  وهو ليس الكثير من التدخل ، ولكن مزعج جدا.  وكل ذلك لأننا في البداية لم نبدأ في تخزين الرابط إلى SObjectizer Environment في mbox-ahs. </p><br><p style=";text-align:right;direction:rtl">  كان انتهاك التوافق مع الإصدارات السابقة سببًا جيدًا للتخلص من هذا الشظية. </p><br><p style=";text-align:right;direction:rtl">  يمكنك الآن معرفة بيئة SObjectizer من mbox التي تم إنشاؤها من أجلها.  وهذا جعل من الممكن استخدام <code>send_periodic</code> و <code>send_periodic</code> لأي نوع من مستلم رسالة المؤقت: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...); send_delayed&lt;my_message&gt;(target_mbox, pause, ...);</code> </pre> <br><p style=";text-align:right;direction:rtl">  بالمعنى الحرفي ، "تافه ، ولكن لطيفة". </p><br><h2 id="net-bolshe-ad-hoc-agentov" style=";text-align:right;direction:rtl">  لا مزيد من الوكلاء المخصصين </h2><br><p style=";text-align:right;direction:rtl">  كما يقول المثل ، "كل حادث له اسم أول واسم الأوسط واسم العائلة".  في حالة الوكلاء المخصصين ، هذا هو الاسم الأول والاسم الأوسط والاسم الأخير :( </p><br><p style=";text-align:right;direction:rtl">  النقطة هي هذا.  عندما بدأنا نتحدث عن SObjectizer-5 في الأماكن العامة ، سمعنا الكثير من اللوم على لفظ الشفرة لأمثلة SObjectizer.  وشخصيا ، بدا لي هذا الفعل اللفظي مشكلة خطيرة أحتاج إلى التعامل معها بجدية. </p><br><p style=";text-align:right;direction:rtl">  أحد مصادر الفعل هو الحاجة إلى أن يرث الوكلاء من <code>agent_t</code> النوع الأساسي الخاص.  ومن هذا ، يبدو أنه لا يوجد مفر.  أم لا؟ </p><br><p style=";text-align:right;direction:rtl">  لذلك كان هناك وكلاء مخصصون ، أي  الوكلاء ، من أجل تحديد أنه لم يكن من الضروري كتابة فصل منفصل ، كان يكفي فقط تعيين رد الفعل على الرسائل في شكل وظائف lambda.  على سبيل المثال ، يمكن كتابة مثال ping-pong الكلاسيكي على العوامل المخصصة مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pinger = coop-&gt;define_agent(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ponger = coop-&gt;define_agent(); pinger .on_start( [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ) .event&lt; msg_pong &gt;( pinger, [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ); ponger .event&lt; msg_ping &gt;( ponger, [pinger]{ so_5::send&lt; msg_pong &gt;( pinger ); } );</code> </pre> <br><p style=";text-align:right;direction:rtl">  أي  لا الطبقات الخاصة بهم.  نحن فقط نطلق على <code>define_agent()</code> التعاون ونحصل على نوع من كائن الوكيل ، والذي يمكنك الاشتراك في الرسائل الواردة. </p><br><p style=";text-align:right;direction:rtl">  لذلك في SObjectizer-5 كان هناك فصل إلى وكلاء العادية والمخصصة. </p><br><p style=";text-align:right;direction:rtl">  التي لم تجلب أي مكافآت واضحة ، إلا أن تكاليف العمالة الإضافية لمرافقة مثل هذا الفصل.  ومع مرور الوقت ، أصبح من الواضح أن العملاء المخصصين يشبهون حقيبة بدون مقبض: من الصعب حملها ومن المؤسف أن تتركها.  ولكن أثناء العمل على SObjectizer-5.6 ، فقد تقرر إنهاء الخدمة. </p><br><p style=";text-align:right;direction:rtl">  في الوقت نفسه ، تم تعلم درس آخر ، وربما أكثر أهمية: في أي مناقشة عامة للأداة على الإنترنت ، سيشارك عدد كبير من الناس غير مبالين بماهية الأداة ، ولماذا هناك حاجة إليها ، ولماذا من المفترض أن تستخدم ، وما إلى ذلك.  من المهم بالنسبة لهم ببساطة التعبير عن رأيهم القوي.  في قسم اللغة الروسية من الإنترنت ، بالإضافة إلى ذلك ، لا يزال من المهم للغاية أن ننقل لمطوري الأداة كيف أنهم أغبياء وغير متعلمين ، ومدى عدم الحاجة إلى نتيجة عملهم. </p><br><p style=";text-align:right;direction:rtl">  لذلك ، يجب أن تكون حذرا للغاية في ما قيل لك.  ويمكنك الاستماع (ثم بعناية) فقط إلى ما يقال هنا في هذا السياق: "لقد حاولت أن أفعل هذا على الآلة الخاصة بك ولا أحب مقدار الكود الذي حصلت عليه هنا."  حتى هذه الرغبات يجب أن تعامل بعناية فائقة: "سأأخذ تطويرك إذا كان الأمر أسهل هنا وهنا." </p><br><p style=";text-align:right;direction:rtl">  لسوء الحظ ، فإن مهارة "التصفية" التي قالها "المهنئين" على الإنترنت قبل حوالي خمس سنوات كانت أقل بكثير من الآن.  وبالتالي ، مثل هذه التجربة المحددة كوكلاء مخصصين في SObjectizer. </p><br><h2 id="sobjectizer-56-bolshe-ne-podderzhivaet-sinhronnogo-vzaimodeystviya-agentov" style=";text-align:right;direction:rtl">  لم يعد SObjectizer-5.6 يدعم تفاعل العامل المتزامن </h2><br><p style=";text-align:right;direction:rtl">  موضوع التفاعل المتزامن بين الوكلاء قديم جدًا ومؤلِّم. </p><br><p style=";text-align:right;direction:rtl">  بدأت في أيام SObjectizer-4.  وفي SObjectizer-5 تابع.  حتى الآن ، وأخيرا ، ما يسمى  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">طلبات الخدمة</a> .  التي في البداية ، باعتراف الجميع ، كانت مخيفة مثل الموت.  ولكن بعد ذلك تمكنت من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">منحهم نظرة أكثر أو أقل لائق</a> . </p><br><p style=";text-align:right;direction:rtl">  ولكن تبين أن هذا هو الحال عندما خرج أول فطيرة متكتلة :( </p><br><p style=";text-align:right;direction:rtl">  داخل SObjectizer ، اضطررت إلى تنفيذ تسليم الرسائل العادية ومعالجتها بطريقة واحدة ، وتسليم الطلبات المتزامنة ومعالجتها بطريقة أخرى.  من المحزن بشكل خاص أن هذه الميزات يجب أن تؤخذ في الاعتبار ، بما في ذلك عند تطبيق mbox-s الخاصة بك. </p><br><p style=";text-align:right;direction:rtl">  وبعد إضافة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وظائف رسائل المغلف</a> إلى SObjectizer ، أصبح من الضروري النظر بشكل أكثر تكرارا وبصورة أكثر شمولية في الاختلافات بين الرسائل العادية والطلبات المتزامنة. </p><br><p style=";text-align:right;direction:rtl">  بشكل عام ، مع وجود طلبات متزامنة أثناء صيانة / تطوير SObjectizer ، كان هناك الكثير من الصداع.  لدرجة أنه في البداية كانت هناك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">رغبة ملموسة للتخلص من هذه الطلبات المتزامنة للغاية</a> .  ثم تحقق هذه الرغبة. </p><br><p style=";text-align:right;direction:rtl">  وهكذا في SObjectizer-5.6 ، يمكن للوكلاء التفاعل مرة أخرى فقط من خلال الرسائل غير المتزامنة. </p><br><p style=";text-align:right;direction:rtl">  ونظرًا لأنه في بعض الأحيان لا تزال هناك حاجة إلى تفاعل متزامن ، تم تقديم دعم لهذا النوع من التفاعل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">إلى مشروع so5extra المصاحب</a> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    "-". using my_request_reply = so_5::extra::sync::request_reply_t&lt;my_request, my_reply&gt;; ... //  ,    . class request_handler final : public so_5::agent_t { ... //  .      . void on_request(typename my_request_reply::request_mhood_t cmd) { ... //  . //      cmd-&gt;request(). //   . cmd-&gt;make_reply(...); //      my_reply. } ... void so_define_agent() override { //       . so_subscribe_self().event(&amp;request_handler::on_request); } }; ... //     . so_5::mbox_t handler_mbox = ...; //        15s. //    ,    . my_reply reply = my_request_reply::ask_value(handler_mbox, 15s, ...); //       my_request.</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  أي  يختلف العمل الآن مع الطلبات المتزامنة اختلافًا أساسيًا في أن معالج الطلب لا يُرجع قيمة من أسلوب المعالج ، كما كان من قبل.  بدلاً من ذلك ، يتم <code>make_reply</code> الأسلوب <code>make_reply</code> . </p><br><p style=";text-align:right;direction:rtl">  يعد التطبيق الجديد جيدًا حيث يتم إرسال كل من الطلب والاستجابة داخل SObjectizer مثل الرسائل غير المتزامنة العادية.  في الواقع ، يعد <code>make_reply</code> أكثر تحديدًا <code>send</code> . </p><br><p style=";text-align:right;direction:rtl">  والأهم من ذلك أن التطبيق الجديد سمح لنا بالحصول على وظائف لم يكن من الممكن الوصول إليها من قبل: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يمكن الآن حفظ و / أو إعادة توجيه الطلبات المتزامنة (مثل <code>request_reply_t&lt;Request, Reply&gt;</code> كائنات <code>request_reply_t&lt;Request, Reply&gt;</code> ) إلى معالجات أخرى.  ما الذي يجعل من الممكن تنفيذ مخططات موازنة التحميل المختلفة ؛ </li><li style=";text-align:right;direction:rtl">  يمكنك جعل الرد على الطلب يأتي في mbox منتظم للوكيل الذي يبدأ الطلب.  وسيعالج الوكيل الأولي الاستجابة بالطريقة المعتادة ، مثل أي رسالة أخرى ؛ </li><li style=";text-align:right;direction:rtl">  يمكنك إرسال عدة طلبات إلى مستلمين مختلفين في آن واحد ، ثم تحليل الردود الواردة منهم بالترتيب الذي تم استلامه: </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> first_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;first_request, first_reply&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> second_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;second_request, second_reply&gt;; <span class="hljs-comment"><span class="hljs-comment">//         . auto reply_ch = create_mchain(env); //     . first_dialog::initiate_with_custom_reply_to( one_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); second_dialog::initiate_with_custom_reply_to( another_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); //    . receive(from(reply_ch).handle_n(2).empty_timeout(15s), [](typename first_dialog::reply_mhood_t cmd) {...}, [](typename second_dialog::reply_mhood_t cmd) {...});</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  لذلك ، يمكننا القول أنه مع التفاعل المتزامن في SObjectizer ، حدث ما يلي: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لوقت طويل ذُبح لأسباب أيديولوجية ؛ </li><li style=";text-align:right;direction:rtl">  ثم تمت إضافته واتضح أنه في بعض الأحيان يكون هذا التفاعل مفيدًا ؛ </li><li style=";text-align:right;direction:rtl">  لكن التجربة أظهرت أن التنفيذ الأول ليس ناجحًا جدًا ؛ </li><li style=";text-align:right;direction:rtl">  تم إلقاء التنفيذ القديم بالكامل ، واقترح تنفيذ جديد في المقابل. </li></ul><br><p style=";text-align:right;direction:rtl">  لقد عملوا على أخطائهم ، بشكل عام. </p><br><h1 id="zaklyuchenie" style=";text-align:right;direction:rtl">  استنتاج </h1><br><p style=";text-align:right;direction:rtl">  تحدثت هذه المقالة ، باختصار شديد ، عن العديد من التغييرات في SObjectizer-5.6.0 والأسباب الكامنة وراء هذه التغييرات. </p><br><p style=";text-align:right;direction:rtl">  يمكن العثور على قائمة أكثر اكتمالا من التغييرات <a href="" rel="nofollow">هنا</a> . </p><br><p style=";text-align:right;direction:rtl">  في الختام ، أريد أن أقدم أولئك الذين لم يجربوا برنامج SObjectizer حتى الآن ، خذوه وجربه.  وشاركنا مشاعرك: ما أعجبك وما لم يعجبك وما كان مفقودًا. </p><br><p style=";text-align:right;direction:rtl">  نستمع بعناية لجميع التعليقات / الاقتراحات البناءة.  علاوة على ذلك ، في السنوات الأخيرة ، يتم تضمين ما يحتاجه شخص ما فقط في SObjectizer.  لذلك إذا لم تخبرنا بما تريده في SObjectizer ، فلن يظهر هذا.  وإذا قلت لي ، فمن يعرف ... ؛) </p><br><p style=";text-align:right;direction:rtl">  المشروع الآن يعيش ويتطور <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">هنا</a> .  بالنسبة لأولئك الذين اعتادوا على استخدام GitHub فقط ، هناك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">مرآة GitHub</a> .  هذه المرآة جديدة تمامًا ، لذا يمكنك تجاهل قلة النجوم. </p><br><p style=";text-align:right;direction:rtl">  PS.  يمكنك متابعة أخبار SObjectizer ذات الصلة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">في مجموعة Google هذه</a> .  هناك يمكنك إثارة القضايا المتعلقة SObjectizer. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar453256/">https://habr.com/ru/post/ar453256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar453242/index.html">ملعب للأحداث الصيفية</a></li>
<li><a href="../ar453246/index.html">ERP - نظام التدهور المستمر</a></li>
<li><a href="../ar453248/index.html">بعثة أرتيميس القمرية - إنتاج العنصر الرئيسي لمحطة القمر المدارية القمرية المدارية</a></li>
<li><a href="../ar453252/index.html">كيف فعلنا برنامج نادي Sportmaster</a></li>
<li><a href="../ar453254/index.html">حول رمز GOST ، Grasshopper ، SBox والبذور المفقودة</a></li>
<li><a href="../ar453258/index.html">عمل دواسة تردد باستخدام رقائق PT2399 (الجزء 1)</a></li>
<li><a href="../ar453260/index.html">ميزات إعداد DPI</a></li>
<li><a href="../ar453262/index.html">أين يتم تخزين الثوابت على متحكم CortexM (باستخدام برنامج التحويل البرمجي C ++ IAR كمثال)</a></li>
<li><a href="../ar453264/index.html">تي شيرت Virtuali-tee: "تي شيرت طبي" لا يغطى ولكنه يكشف</a></li>
<li><a href="../ar453272/index.html">رعاة جيثب: طريقة جديدة للمساهمة في المصادر المفتوحة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>