<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏾 🥈 💥 Dependência do desempenho do código no contexto da declaração de variáveis ​​em JavaScript 👩‍👩‍👦‍👦 ⬇️ 🚫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inicialmente, este artigo foi concebido como uma pequena referência para seu próprio uso e, em geral, não foi planejado para ser um artigo, no entanto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dependência do desempenho do código no contexto da declaração de variáveis ​​em JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469523/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cx/hu/udcxhuvjpmyigj19lmdrz8ojyja.jpeg"></div><br>  Inicialmente, este artigo foi concebido como uma pequena referência para seu próprio uso e, em geral, não foi planejado para ser um artigo, no entanto, durante o processo de medição, surgiram alguns recursos interessantes na implementação da arquitetura <i><b>JavaScript</b></i> , que afetam fortemente o desempenho do código final em alguns casos.  Sugiro que você se familiarize com os resultados obtidos, examinando incidentalmente também alguns tópicos relacionados: loops, ambiente (contexto de execução) e blocos. <br><br><a name="habracut"></a>  No final do meu artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“Usando declarações de variáveis ​​let e recursos dos fechamentos resultantes de JavaScript”,</a> toquei brevemente na comparação de desempenho das declarações de variáveis <i><b>let (LexicalDeclaration)</b></i> e <i><b>var (VarDeclaredNames)</b></i> em loops.  Para comparação, usamos o tempo de execução da classificação manual (sem a ajuda de <i><b>Array.prototype.sort ()</b></i> ), um dos métodos mais simples é a seleção por seleção, pois com um comprimento de matriz de 100.000, obtivemos pouco mais de 5 bilhões.  iterações em dois ciclos (externo e aninhado) e esse valor deve permitir uma estimativa adequada no final. <br><br>  Para <i><b>var,</b></i> ele estava classificando a visualização: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 9.082 . //   Chrome: 10.783 .</span></span></code> </pre> <br>  E por <i><b>deixar</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.261 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  Ao ver esses números, ao que parece, pode-se argumentar inequivocamente que <i><b>os</b></i> anúncios ultrapassam completamente a velocidade.  Mas, além dessa conclusão, a questão permaneceu no ar: o que acontecerá se colocarmos <i><b>as</b></i> declarações de fora de loops? <br><br>  Mas, antes de fazer isso, você precisa se aprofundar no trabalho do loop <i><b>for</b></i> , guiado pela especificação atual do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><i>ECMAScript 2019 (ECMA-262)</i></a> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>Runtime Semantics: LabelledEvaluation With parameter labelSet. IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Expression;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the first Expression is present, then a. Let exprRef be the result of evaluating the first Expression. b. Perform ? GetValue(exprRef). <span class="hljs-number"><span class="hljs-number">2</span></span>. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(varVariableDeclarationList;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let varDcl be the result of evaluating VariableDeclarationList. <span class="hljs-number"><span class="hljs-number">2</span></span>. ReturnIfAbrupt(varDcl). <span class="hljs-number"><span class="hljs-number">3</span></span>. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(LexicalDeclarationExpression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let oldEnv be the running execution context's LexicalEnvironment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let loopEnv be NewDeclarativeEnvironment(oldEnv). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let loopEnvRec be loopEnv's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">5</span></span>. Let boundNames be the BoundNames of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of boundNames, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is true, then i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true). b. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, i. Perform ! loopEnvRec.CreateMutableBinding(dn, false). <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to loopEnv. <span class="hljs-number"><span class="hljs-number">8</span></span>. Let forDcl be the result of evaluating LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">9</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> forDcl is an abrupt completion, then a. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. b. Return Completion(forDcl). <span class="hljs-number"><span class="hljs-number">10</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ». <span class="hljs-number"><span class="hljs-number">11</span></span>. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet). <span class="hljs-number"><span class="hljs-number">12</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. <span class="hljs-number"><span class="hljs-number">13</span></span>. Return Completion(bodyResult).</code> </pre>  <i>note: dois pontos após IterationStatements, na fonte não são enquadrados por apóstrofos - são adicionados aqui para que não haja formatação automática que estrague a legibilidade do texto.</i> <br><br>  Aqui, como vemos, há três opções para chamar e mais trabalho do loop <i><b>for</b></i> : <br><ul><li>  com a <i>instrução for (Expression; Expression; Expression)</i> <br>  <i><b>ForBodyEvaluation</b> (a segunda Expressão, a terceira Expressão, Instrução, "", labelSet)</i> . </li><li>  com <i><b>a</b> instrução <b>for</b> (varVariableDeclarationList; Expression; Expression)</i> <br>  <i><b>ForBodyEvaluation</b> (a primeira Expressão, a segunda Expressão, Instrução, "", labelSet).</i> </li><li>  <i>Instrução</i> at <i><b>for</b> (LexicalDeclarationExpression; Expression)</i> <br>  <i><b>ForBodyEvaluation</b> (a primeira Expressão, a segunda Expressão, Instrução, perIterationLets, labelSet)</i> </li></ul><br>  Na última, terceira variante, ao contrário dos dois primeiros, o quarto parâmetro não está vazio - <i><b>perIterationLets</b></i> - essas são, na verdade, as mesmas declarações de declaração no primeiro parâmetro passado para o loop <i><b>for</b></i> .  Eles são especificados no parágrafo 10: <br>  <i>- Se <b>isConst</b> for <b>false</b> , permita que <b>perIterationLets</b> seja boundNames;</i>  <i>caso contrário, deixe perIterationLets ser "".</i> <br>  Se uma constante foi passada para <i><b>for</b></i> , mas não uma variável, o parâmetro <i><b>perIterationLets</b></i> ficará vazio. <br><br>  Além disso, na terceira opção, é necessário prestar atenção ao parágrafo 2: <br>  <i>- Deixe loopEnv ser <b>NewDeclarativeEnvironment</b> (oldEnv).</i> <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">8</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>NewDeclarativeEnvironment ( E ) When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the following steps are performed: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let env be a new Lexical Environment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let envRec be a new declarative Environment Record containing no bindings. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> env's EnvironmentRecord to envRec. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the outer lexical environment reference of env to E. <span class="hljs-number"><span class="hljs-number">5</span></span>. Return env.</code> </pre> <br>  Aqui, como o parâmetro <i><b>E</b></i> , o ambiente do qual o loop <i><b>for</b></i> foi chamado (global, qualquer função etc.) é obtido, e um novo ambiente é criado para executar o loop <i><b>for</b></i> com referência ao ambiente externo que o criou (ponto 4).  Estamos interessados ​​nesse fato devido ao fato de o ambiente ser um contexto de execução. <br><br>  E lembramos que as declarações de variáveis <i><b>let</b></i> e <i><b>const</b></i> estão contextualmente ligadas ao bloco em que são declaradas. <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">14</span></span>Runtime Semantics: BlockDeclarationInstantiation ( code, env ) Note When a Block or CaseBlock is evaluated a new declarative Environment Record is created and bindings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each block scoped variable, constant, function, or class declared <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the block are instantiated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the Environment Record. BlockDeclarationInstantiation is performed as follows using arguments code and env. code is the Parse Node corresponding to the body of the block. env is the Lexical Environment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> which bindings are to be created. <span class="hljs-number"><span class="hljs-number">1</span></span>. Let envRec be env's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: envRec is a declarative Environment Record. <span class="hljs-number"><span class="hljs-number">3</span></span>. Let declarations be the LexicallyScopedDeclarations of code. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> declarations, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of the BoundNames of d, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> IsConstantDeclaration of d is true, then <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateImmutableBinding(dn, true). ii. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateMutableBinding(dn, false). b. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then i. Let fn be the sole element of the BoundNames of d. ii. Let fo be the result of performing InstantiateFunctionObject <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d with argument env. iii. Perform envRec.InitializeBinding(fn, fo).</code> </pre> <br>  note: como nas duas primeiras variantes de chamada do loop <i><b>for</b></i> não havia tais declarações, não havia necessidade de criar um novo ambiente para elas. <br><br>  Vamos além e consideramos o que <i><b>é a ForBodyEvaluation</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">8</span></span>Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet ) The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and labelSet is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let V be undefined. <span class="hljs-number"><span class="hljs-number">2</span></span>. Perform ? CreatePerIterationEnvironment(perIterationBindings). <span class="hljs-number"><span class="hljs-number">3</span></span>. Repeat, a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> test is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let testRef be the result of evaluating test. ii. Let testValue be ? GetValue(testRef). iii. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> ToBoolean(testValue) is false, return NormalCompletion(V). b. Let result be the result of evaluating stmt. c. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)). d. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> result.[[Value]] is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> V to result.[[Value]]. e. Perform ? CreatePerIterationEnvironment(perIterationBindings). f. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> increment is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let incRef be the result of evaluating increment. ii. Perform ? GetValue(incRef).</code> </pre> <br>  O que você deve primeiro prestar atenção: <br><ul><li>  descrição dos parâmetros recebidos: <br><ul><li>  <i><b>teste</b></i> : expressão verificada quanto à verdade antes da próxima iteração do corpo do loop (por exemplo: <i><b>i &lt;len</b></i> ); </li><li>  <i><b>incremento</b></i> : expressão avaliada no início de cada nova iteração (exceto a primeira) (por exemplo: <i><b>i ++</b></i> ); </li><li>  <i><b>stmt</b></i> : corpo do laço </li><li>  <i><b>perIterationBindings</b></i> : variáveis ​​declaradas com <i><b>let</b></i> no primeiro <i><b>para o</b></i> parâmetro (por exemplo: <i><b>let i = 0 || let i || let i, j</b></i> ); </li><li>  <i><b>labelSet</b></i> : rótulo do loop; </li></ul></li><li>  ponto 2: aqui, se o parâmetro não vazio <i><b>perIterationBindings for passado</b></i> , um segundo ambiente será criado para executar a passagem inicial do loop; </li><li>  parágrafo 3.a: verificação de uma determinada condição para continuar a execução do ciclo; </li><li>  cláusula 3.b: execução do corpo do ciclo; </li><li>  ponto 3.e: criando um novo ambiente. </li></ul><br>  Bem, e, diretamente, o algoritmo para criar ambientes internos do loop <i><b>for</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span>Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings ) <span class="hljs-number"><span class="hljs-number">1</span></span>. The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> perIterationBindings has any elements, then a. Let lastIterationEnv be the running execution context's LexicalEnvironment. b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord. c. Let outer be lastIterationEnv's outer environment reference. d. Assert: outer is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> null. e. Let thisIterationEnv be NewDeclarativeEnvironment(outer). f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord. g. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element bn of perIterationBindings, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false). ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true). iii. Perform thisIterationEnvRec.InitializeBinding(bn, lastValue). h. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to thisIterationEnv. <span class="hljs-number"><span class="hljs-number">2</span></span>. Return undefined.</code> </pre> <br>  Como podemos ver, o primeiro parágrafo verifica a presença de quaisquer elementos no parâmetro passado, e o parágrafo 1 só é executado se houver anúncios de <i><b>permissão</b></i> .  Todos os novos ambientes são criados com referência ao mesmo contexto externo e recebem os valores mais recentes da iteração anterior (ambiente de trabalho anterior) como novas ligações de variáveis <i><b>let</b></i> . <br><br>  Como exemplo, considere uma expressão semelhante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { arr.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  E aqui está como ele pode ser decomposto sem o uso <i><b>de</b></i> (com uma certa quantidade de convencionalidade): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-comment"><span class="hljs-comment">//    { let i = 0; //     for } //   ,   { let i = 0; //    i    if (i &lt; 3) arr.push(i); } //    { let i = 0; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 1; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 2; //    i    i++; if (i &lt; 3) arr.push(i); } console.log(arr); // Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  De fato, chegamos à conclusão de que, para cada contexto, e aqui temos cinco deles, fazemos novas ligações para variáveis <i><b>let</b></i> declaradas como o primeiro parâmetro em (importante: isso não se aplica a <i><b>deixar</b></i> declarações diretamente no corpo do loop). <br><br>  Veja como, por exemplo, esse loop será exibido ao usar <i><b>var</b></i> quando não houver ligações adicionais: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  E podemos chegar a uma conclusão aparentemente lógica de que, se durante a execução de nossos loops, não for necessário criar ligações separadas para cada iteração ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais sobre situações nas quais isso, pelo contrário, pode fazer sentido</a> ), devemos fazer a declaração de variáveis ​​incrementais antes com um loop <i><b>for</b></i> , que deve nos impedir de criar e excluir um grande número de contextos e, em teoria, melhorar o desempenho. <br><br>  Vamos tentar fazer isso, usando a mesma classificação de uma matriz de 100.000 elementos como exemplo, e por uma questão de beleza, também definimos todas as outras variáveis ​​antes <i><b>para</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 34.246 . //   Chrome: 10.803 .</span></span></code> </pre> <br>  Resultado inesperado ... Exatamente o oposto do esperado, para ser preciso.  O rebaixamento do <i><b>Firefox</b></i> neste teste é particularmente impressionante. <br><br>  Ok  Isso não funcionou, vamos retornar a declaração das variáveis <i><b>iej de</b></i> volta aos parâmetros dos ciclos correspondentes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 6.575 . //   Chrome: 6.749 .</span></span></code> </pre> <br>  Hum.  Parece que, tecnicamente, a única diferença entre o último exemplo e o exemplo no início do artigo são as declarações feitas das variáveis <i><b>min, mini</b></i> e <i><b>len</b></i> fora do loop <i><b>for</b></i> e, embora a diferença ainda seja contextual, não é de particular interesse para nós agora e, além disso, nos livramos da necessidade de declarar essas variáveis ​​99.999 vezes no corpo do ciclo de nível superior, o que, teoricamente, deveria aumentar a produtividade em vez de reduzi-la em mais de um segundo. <br><br>  Ou seja, acontece que, de alguma forma, trabalhar com variáveis ​​declaradas no parâmetro ou no corpo do loop <i><b>for</b></i> acontece muito mais rapidamente do que fora dele. <br><br>  Porém, não parecemos ver nenhuma instrução “turbo” na especificação do loop <i><b>for</b></i> que poderia nos levar a essa ideia.  Portanto, não são os detalhes específicos do trabalho do loop <i><b>for</b></i> , mas outra coisa ... Por exemplo, os recursos das declarações <i><b>let</b></i> : qual é o principal recurso que distingue <i><b>let</b></i> de <i><b>var</b></i> ?  Contexto de execução de bloco!  E em nossos dois últimos exemplos, usamos anúncios fora do bloco.  Mas, e se, em vez de retornar essas declarações <i><b>para,</b></i> apenas selecionarmos um bloco separado para elas? <br><br><pre> <code class="javascript hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.405 .</span></span></code> </pre> <br>  Voila!  Acontece que o problema foi que <i><b>os</b></i> anúncios ocorreram em um contexto global e, assim que alocamos um bloco separado para eles, todos os problemas desapareceram ali. <br><br>  E aqui seria bom recordar outra maneira, ligeiramente imerecida, de declarar variáveis ​​- <i><b>var</b></i> . <br><br>  No exemplo no início do artigo, o tempo de classificação usando <i><b>var</b></i> mostrou um resultado extremamente deplorável em relação ao <i><b>let</b></i> .  Mas, se você der uma olhada mais de perto neste exemplo, poderá descobrir que, como <i><b>var</b></i> não tinha ligações de blocos variáveis, o contexto real das variáveis ​​era global.  E nós, no exemplo do <i><b>let</b></i> , já descobrimos como isso pode afetar o desempenho (e, o que é típico, ao usar o <i><b>let</b></i> , o rebaixamento da velocidade se mostrou mais forte do que no caso do <i><b>var</b></i> , especialmente no <i><b>Firefox</b></i> ).  Portanto, para ser justo, executaremos um exemplo com <i><b>var</b></i> criando um novo contexto para variáveis: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.255 . //   Chrome: 5.411 .</span></span></code> </pre> <br>  E obtivemos o resultado quase idêntico ao que estava ao usar <i><b>let</b></i> . <br><br>  Por fim, vamos verificar se a desaceleração ocorre lendo a variável global sem alterar seu valor. <br><br>  <i><b>deixar</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  <i><b>var</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> len = arr.length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.258 . //   Chrome: 5.439 .</span></span></code> </pre> <br>  Os resultados indicam que a leitura da variável global não afetou o tempo de execução. <br><br><h3>  Resumir </h3><br><ol><li>  Mudar variáveis ​​globais é muito mais lento que mudar as locais.  Levando isso em conta, é possível otimizar o código em situações apropriadas criando um bloco ou função separada, inclusive para declarar variáveis, em vez de executar parte do código em um contexto global.  Sim, em quase todos os livros didáticos, você pode encontrar recomendações para fazer o menor número possível de ligações globais, mas geralmente apenas um entupimento do espaço para nome global é indicado como motivo, e não uma palavra sobre possíveis problemas de desempenho. </li><li>  Apesar do fato de que a execução de loops com uma declaração <i><b>let</b></i> no primeiro parâmetro <i><b>for</b></i> criar um grande número de ambientes, isso quase não afeta o desempenho, ao contrário das situações em que as declarações são retiradas do bloco.  No entanto, não se deve excluir a possibilidade da existência de situações exóticas quando esse fator afetará a produtividade de maneira mais significativa. </li><li>  O desempenho das variáveis <i><b>var</b></i> ainda não é inferior ao das variáveis <i><b>let</b></i> , no entanto, não as excede (novamente, no caso geral), o que nos leva à próxima conclusão de que não há razão para usar as declarações <i><b>var</b></i> , exceto para fins de compatibilidade.  No entanto, se você precisar manipular variáveis ​​globais alterando seus valores, a variante <i><b>var</b></i> será preferível em termos de desempenho (pelo menos por enquanto, se, em particular, for assumido que o script também possa ser executado no mecanismo Gecko). </li></ol><br><h4>  Referências </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">ECMAScript 2019 (ECMA-262)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando declarações let de variáveis ​​e recursos dos fechamentos resultantes em JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469523/">https://habr.com/ru/post/pt469523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469505/index.html">3 maneiras práticas de levar negócios para mercados estrangeiros: abordagens e técnicas de empresas reais</a></li>
<li><a href="../pt469507/index.html">Terceira vulnerabilidade do Steam Windows Client, mas não 0 dia</a></li>
<li><a href="../pt469509/index.html">Esquemas angulares, ou como eu escrevi meu modelo para cli angular</a></li>
<li><a href="../pt469515/index.html">Preparando o Aplicativo para Istio</a></li>
<li><a href="../pt469521/index.html">Comprei uma moto para andar, para não cair</a></li>
<li><a href="../pt469525/index.html">Sistema de controle automatizado para uma escavadeira de mineração</a></li>
<li><a href="../pt469527/index.html">O interfone é um ouvido espião?</a></li>
<li><a href="../pt469529/index.html">A renderização de texto odeia você</a></li>
<li><a href="../pt469531/index.html">"Comparar linguagens de programação em uma base de pior a pior é uma ocupação completamente idiota."</a></li>
<li><a href="../pt469533/index.html">Problemas e ameaças da identificação biométrica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>