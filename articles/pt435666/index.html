<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÄ üîª üèòÔ∏è Dessincroniza√ß√£o ass√≠ncrona: antipadr√µes no trabalho com async / waitit no .NET üåæ üëáüèæ üèá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qual de n√≥s n√£o corta a relva? Encontro regularmente erros no c√≥digo ass√≠ncrono e os fa√ßo sozinho. Para parar esta roda do Samsara, estou compartilhan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dessincroniza√ß√£o ass√≠ncrona: antipadr√µes no trabalho com async / waitit no .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/435666/"><p>  Qual de n√≥s n√£o corta a relva?  Encontro regularmente erros no c√≥digo ass√≠ncrono e os fa√ßo sozinho.  Para parar esta roda do Samsara, estou compartilhando com voc√™s os batentes mais t√≠picos daqueles que √†s vezes s√£o bastante dif√≠ceis de entender e consertar. </p><br><img src="https://habrastorage.org/webt/os/oz/lt/osozltujeowuulzfvdaxvehuvpg.png"><br><a name="habracut"></a><br><blockquote>  Este texto √© inspirado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog de Stephen Clary</a> , um homem que sabe tudo sobre competitividade, assincronia, multithreading e outras palavras assustadoras.  Ele √© o autor do livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Concurrency in C # Cookbook</a> , que coletou um grande n√∫mero de padr√µes para trabalhar com a concorr√™ncia. </blockquote><br><h2>  Impasse ass√≠ncrono cl√°ssico </h2><br><p>  Para entender o impasse ass√≠ncrono, vale a pena descobrir qual thread executa o m√©todo invocado usando a palavra-chave wait. </p><br><p>  Primeiro, o m√©todo ir√° mergulhar na cadeia de chamadas de m√©todos ass√≠ncronos at√© encontrar uma fonte de assincronia.  Como exatamente a origem da assincronia √© implementada √© um t√≥pico que est√° al√©m do escopo deste artigo.  Agora, por simplicidade, assumimos que esta √© uma opera√ß√£o que n√£o requer um fluxo de trabalho enquanto aguarda seu resultado, por exemplo, uma solicita√ß√£o de banco de dados ou HTTP.  O in√≠cio s√≠ncrono de uma opera√ß√£o desse tipo significa que, enquanto espera pelo resultado no sistema, haver√° pelo menos um encadeamento adormecido que consome recursos, mas n√£o realiza nenhum trabalho √∫til. </p><br><p> Em uma chamada ass√≠ncrona, meio que interrompemos o fluxo de execu√ß√£o dos comandos no ‚Äúantes‚Äù e ‚Äúdepois‚Äù da opera√ß√£o ass√≠ncrona, e no .NET n√£o h√° garantias de que o c√≥digo que est√° aguardando seja executado no mesmo encadeamento que o c√≥digo anterior.  Na maioria dos casos, isso n√£o √© necess√°rio, mas o que fazer quando esse comportamento √© vital para o programa funcionar?  Precisa usar <code>SynchronizationContext</code> .  Este √© um mecanismo que permite impor certas restri√ß√µes nos segmentos em que o c√≥digo √© executado.  Em seguida, trataremos de dois contextos de sincroniza√ß√£o ( <code>WindowsFormsSynchronizationContext</code> e <code>AspNetSynchronizationContext</code> ), mas Alex Davis escreve em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seu livro</a> que existem cerca de uma d√∫zia deles no .NET.  Sobre o <code>SynchronizationContext</code> bem escrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui, o</a> autor implementou o seu pr√≥prio, pelo qual ele tem um grande respeito. </p><br><p>  Portanto, assim que o c√≥digo chega √† origem da assincronia, ele salva o contexto de sincroniza√ß√£o, que estava na propriedade est√°tica do thread de <code>SynchronizationContext.Current</code> , a opera√ß√£o ass√≠ncrona inicia e libera o thread atual.  Em outras palavras, enquanto aguardamos a conclus√£o da opera√ß√£o ass√≠ncrona, n√£o bloqueamos um √∫nico encadeamento e esse √© o principal lucro da opera√ß√£o ass√≠ncrona em compara√ß√£o com a s√≠ncrona.  Ap√≥s concluir a opera√ß√£o ass√≠ncrona, devemos seguir as instru√ß√µes localizadas ap√≥s a fonte ass√≠ncrona e, aqui, para decidir em qual encadeamento executar o c√≥digo ap√≥s a opera√ß√£o ass√≠ncrona, precisamos consultar o contexto de sincroniza√ß√£o salvo anteriormente.  Como ele diz, faremos isso.  Ele lhe dir√° para executar no mesmo encadeamento que o c√≥digo antes de aguardar - n√≥s executaremos no mesmo encadeamento, n√£o diremos - pegaremos o primeiro encadeamento do pool. </p><br><p>  Mas e se, nesse caso em particular, for importante para n√≥s que o c√≥digo ap√≥s a espera seja executado em qualquer encadeamento livre do pool de encadeamentos?  Voc√™ precisa usar o mantra <code>ConfigureAwait(false)</code> .  O valor falso passado para o par√¢metro <code>continueOnCapturedContext</code> informa ao sistema que qualquer encadeamento do pool pode ser usado.  E o que acontece se, no momento da execu√ß√£o do m√©todo com aguardar, n√£o havia contexto de sincroniza√ß√£o ( <code>SynchronizationContext.Current == null</code> ), como por exemplo, em um aplicativo de console.  Nesse caso, n√£o temos restri√ß√µes no encadeamento no qual o c√≥digo deve ser executado depois de aguardar, e o sistema pegar√° o primeiro encadeamento que vier do pool, como no caso de <code>ConfigureAwait(false)</code> . </p><br><p>  Ent√£o, o que √© um impasse ass√≠ncrono? </p><br><h4>  Impasse no WPF e WinForms </h4><br><p>  A diferen√ßa entre os aplicativos WPF e WinForms √© o pr√≥prio contexto de sincroniza√ß√£o.  O contexto de sincroniza√ß√£o do WPF e do WinForms possui um thread especial - o thread da interface do usu√°rio.  H√° um encadeamento da interface do usu√°rio por <code>SynchronizationContext</code> e somente desse encadeamento pode interagir com os elementos da interface do usu√°rio.  Por padr√£o, o c√≥digo que come√ßou a funcionar no encadeamento da interface do usu√°rio continua a opera√ß√£o ap√≥s uma opera√ß√£o ass√≠ncrona. </p><br>  Agora vamos ver um exemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br>  O que acontece quando voc√™ chama <code>StartWork().Wait()</code> : <br><br><ol><li>  O thread de chamada (e este √© o thread da interface do usu√°rio) ir√° para o m√©todo <code>StartWork</code> e <code>StartWork</code> para a <code>await Task.Delay(100)</code> . </li><li>  O thread da interface do usu√°rio iniciar√° a <code>Task.Delay(100)</code> ass√≠ncrona <code>Task.Delay(100)</code> e retornar√° o controle ao m√©todo <code>Button_Click</code> , e o m√©todo <code>Wait()</code> da classe <code>Task</code> estar√° esperando por ele.  Quando o m√©todo <code>Wait()</code> √© chamado, o encadeamento da interface do usu√°rio ser√° bloqueado at√© o final da opera√ß√£o ass√≠ncrona, e esperamos que, assim que conclu√≠do, o encadeamento da interface do usu√°rio inicie imediatamente a execu√ß√£o e v√° al√©m no c√≥digo, no entanto, nem tudo ser√° assim. </li><li>  Assim que <code>Task.Delay(100)</code> conclu√≠do, o thread da interface do usu√°rio precisar√° primeiro continuar executando o m√©todo <code>StartWork()</code> e, para isso, precisa exatamente do thread no qual a execu√ß√£o foi iniciada.  Mas o encadeamento da interface do usu√°rio agora est√° aguardando o resultado da opera√ß√£o. </li><li>  <code>StartWork()</code> : <code>StartWork()</code> n√£o pode continuar a execu√ß√£o e retornar o resultado, e <code>Button_Click</code> est√° aguardando o mesmo resultado e, devido ao fato de a execu√ß√£o ter iniciado no encadeamento da interface com o usu√°rio, o aplicativo simplesmente trava sem chance de continuar trabalhando. </li></ol><br>  Essa situa√ß√£o pode ser tratada simplesmente alterando a chamada para <code>Task.Delay(100)</code> para <code>Task.Delay(100).ConfigureAwait(false)</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br><p>  Esse c√≥digo funcionar√° sem conflitos, pois agora um segmento do pool pode ser usado para concluir o m√©todo <code>StartWork()</code> , em vez de um segmento da interface do usu√°rio bloqueado.  Stephen Clary recomenda usar o <code>ConfigureAwait(false)</code> em todos os "m√©todos de biblioteca" em seu blog, mas enfatiza especificamente que o uso do <code>ConfigureAwait(false)</code> para tratar impasses n√£o √© uma boa pr√°tica.  Em vez disso, ele aconselha N√ÉO usar m√©todos de bloqueio como <code>Wait()</code> , <code>Result</code> , <code>GetAwaiter().GetResult()</code> e <code>GetAwaiter().GetResult()</code> todos os m√©todos para usar async / waitit, se poss√≠vel (o princ√≠pio chamado princ√≠pio ass√≠ncrono). </p><br><h4>  Impasse no ASP.NET </h4><br><p>  O ASP.NET tamb√©m possui um contexto de sincroniza√ß√£o, mas possui limita√ß√µes um pouco diferentes.  Ele permite que voc√™ use apenas um encadeamento por solicita√ß√£o por vez e tamb√©m exige que o c√≥digo ap√≥s aguardar seja executado no mesmo encadeamento que o c√≥digo antes de aguardar. </p><br>  Um exemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HomeController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deadlock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartWork().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the code following await"</span></span>; } }</code> </pre><br><p>  Esse c√≥digo tamb√©m causar√° um impasse, uma vez que, no momento da chamada para <code>StartWork().Wait()</code> √∫nico thread permitido ser√° bloqueado e aguardar√° a <code>StartWork()</code> opera√ß√£o <code>StartWork()</code> e nunca ser√° encerrada, pois o segmento em que a execu√ß√£o deve continuar est√° ocupado esperando. </p><br><p>  Tudo isso √© corrigido pelo mesmo <code>ConfigureAwait(false)</code> . </p><br><h4>  Impasse no ASP.NET Core (na verdade n√£o) </h4><br><p>  Agora vamos tentar executar o c√≥digo do exemplo para o ASP.NET no projeto para o ASP.NET Core.  Se fizermos isso, veremos que n√£o haver√° impasse.  Isso ocorre porque o ASP.NET Core <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o possui um contexto de sincroniza√ß√£o</a> .  √ìtimo!  E agora voc√™ pode cobrir o c√≥digo bloqueando chamadas e n√£o ter medo de conflitos?  Estritamente falando, sim, mas lembre-se de que isso faz com que o thread adorme√ßa enquanto aguarda, ou seja, o thread consome recursos, mas n√£o realiza nenhum trabalho √∫til. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/qe/hc/pvqehcevrmzzqhylr7vtedbqwtc.png"></div><br><br><p></p><blockquote>  <b>Lembre-se de que o uso de chamadas de bloqueio elimina todas as vantagens da programa√ß√£o ass√≠ncrona, transformando-a em s√≠ncrona</b> .  Sim, √†s vezes sem usar <code>Wait()</code> , n√£o funcionar√° para escrever um programa, mas o motivo deve ser s√©rio. </blockquote><br><h2>  Uso incorreto de Task.Run () </h2><br><p>  O m√©todo <code>Task.Run()</code> foi criado para iniciar opera√ß√µes em um novo thread.  Como conv√©m a um m√©todo escrito em um padr√£o TAP, ele retorna <code>Task</code> ou <code>Task&lt;T&gt;</code> e as pessoas que encontram primeiro async / wait t√™m um grande desejo de quebrar o c√≥digo s√≠ncrono em <code>Task.Run()</code> e sacrificar o resultado desse m√©todo.  O c√≥digo parecia se tornar ass√≠ncrono, mas, na verdade, nada mudou.  Vamos ver o que acontece com esse uso do <code>Task.Run()</code> . </p><br>  Um exemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteOperation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Before: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside before sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside after sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"After: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  O resultado desse c√≥digo ser√°: <br><br><pre> <code class="plaintext hljs">Before: 1 Inside before sleep: 3 Inside after sleep: 3 After: 3</code> </pre><br><p>  Aqui <code>Thread.Sleep(1000)</code> √© algum tipo de opera√ß√£o s√≠ncrona que requer que um thread seja conclu√≠do.  Suponha que desejemos tornar nossa solu√ß√£o ass√≠ncrona e, para que essa opera√ß√£o possa ser sacrificada, envolvemos-a em <code>Task.Run()</code> . </p><br><p>  Assim que o c√≥digo atinge o m√©todo <code>Task.Run()</code> , outro thread √© retirado do pool de threads e o c√≥digo que passamos para <code>Task.Run()</code> √© executado nele.  O thread antigo, como conv√©m a um thread decente, retorna ao pool e espera que seja chamado novamente para fazer o trabalho.  O novo encadeamento executa o c√≥digo transmitido, alcan√ßa a opera√ß√£o s√≠ncrona, executa de forma s√≠ncrona (espera at√© que a opera√ß√£o seja conclu√≠da) e avan√ßa mais no c√≥digo.  Em outras palavras, a opera√ß√£o permaneceu s√≠ncrona: n√≥s, como antes, usamos o fluxo durante a execu√ß√£o da opera√ß√£o s√≠ncrona.  A √∫nica diferen√ßa √© que passamos um tempo alternando contextos ao chamar <code>Task.Run()</code> e retornar a <code>ExecuteOperation()</code> .  Tudo ficou um pouco pior. </p><br><p>  Deve-se entender que, apesar do fato de que nas linhas <code>Inside after sleep: 3</code> e <code>After: 3</code> , vemos o mesmo ID do fluxo, o contexto de execu√ß√£o √© completamente diferente nesses locais.  O ASP.NET √© simplesmente mais inteligente do que n√≥s e tenta economizar recursos ao alternar o contexto do c√≥digo dentro de <code>Task.Run()</code> para o c√≥digo externo.  Aqui ele decidiu n√£o mudar pelo menos o fluxo de execu√ß√£o. </p><br><p>  Nesses casos, n√£o faz sentido usar <code>Task.Run()</code> .  Em vez disso, Clary <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recomenda</a> tornar todas as opera√ß√µes ass√≠ncronas, ou seja, no nosso caso, substituir <code>Thread.Sleep(1000)</code> por <code>Task.Delay(1000)</code> , mas isso, √© claro, nem sempre √© poss√≠vel.  O que fazer nos casos em que usamos bibliotecas de terceiros que n√£o podemos ou n√£o queremos reescrever e tornar ass√≠ncronas at√© o fim, mas por um motivo ou outro, precisamos do m√©todo ass√≠ncrono?  √â melhor usar <code>Task.FromResult()</code> para <code>Task.FromResult()</code> o resultado dos m√©todos do fornecedor na tarefa.  Obviamente, isso n√£o tornar√° o c√≥digo ass√≠ncrono, mas pelo menos economizaremos na altern√¢ncia de contexto. </p><br><p></p><blockquote>  <b>Por que ent√£o usar Task.Run ()?</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A resposta √© simples:</a> para opera√ß√µes ligadas √† CPU, quando voc√™ precisa manter a capacidade de resposta da interface do usu√°rio ou paralelizar os c√°lculos.  Deve-se dizer aqui que as opera√ß√µes ligadas √† CPU s√£o de natureza s√≠ncrona.  Foi para iniciar opera√ß√µes s√≠ncronas em um estilo ass√≠ncrono que <code>Task.Run()</code> foi inventado. </blockquote><br><h2>  Uso indevido de v√°cuo ass√≠ncrono </h2><br>  A capacidade de escrever m√©todos ass√≠ncronos que retornam <code>void</code> foi adicionada para gravar manipuladores de eventos ass√≠ncronos.  Vamos ver por que eles podem causar confus√£o se forem usados ‚Äã‚Äãpara outros fins: <br><br><ol><li>  Voc√™ n√£o pode esperar pelo resultado. </li><li>  N√£o h√° suporte para manipula√ß√£o de exce√ß√£o atrav√©s de try-catch. </li><li>  √â imposs√≠vel combinar chamadas atrav√©s de <code>Task.WhenAll()</code> , <code>Task.WhenAny()</code> e outros m√©todos semelhantes. </li></ol><br><p>  De todas essas raz√µes, o ponto mais interessante √© o tratamento de exce√ß√µes.  O fato √© que, nos m√©todos ass√≠ncronos que retornam <code>Task</code> ou <code>Task&lt;T&gt;</code> , as exce√ß√µes s√£o capturadas e agrupadas em um objeto <code>Task</code> , que ser√° passado para o m√©todo de chamada.  Em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seu artigo para o MSDN,</a> Clary escreve que, como n√£o h√° valor de retorno nos m√©todos async-void, n√£o h√° nada para incluir exce√ß√µes e elas s√£o lan√ßadas diretamente no contexto da sincroniza√ß√£o.  O resultado √© uma exce√ß√£o n√£o tratada devido √† falha do processo, tendo tempo para, talvez, gravar um erro no console.  Voc√™ pode obter e reservar essas exce√ß√µes assinando o evento <code>AppDomain.UnhandledException</code> , mas n√£o poder√° parar a falha do processo, mesmo no manipulador deste evento.  Esse comportamento √© t√≠pico apenas para o manipulador de eventos, mas n√£o para o m√©todo usual, do qual esperamos a possibilidade de manipula√ß√£o de exce√ß√£o padr√£o por meio de try-catch. </p><br>  Por exemplo, se voc√™ escrever assim em um aplicativo ASP.NET Core, o processo certamente cair√°: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowInAsyncVoid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ThrowAsynchronously(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowAsynchronously</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Obviously, something happened"</span></span>); }</code> </pre><br><p>  Mas vale a pena alterar o tipo de retorno do m√©todo <code>ThrowAsynchronously</code> para <code>Task</code> (sem adicionar a palavra-chave <code>ThrowAsynchronously</code> ) e a exce√ß√£o ser√° capturada pelo manipulador de erros padr√£o do ASP.NET Core, e o processo continuar√° ativo, apesar da execu√ß√£o. </p><br><p></p><blockquote>  <b>Tenha cuidado com os m√©todos ass√≠ncronos</b> - eles podem colocar voc√™ no processo. </blockquote><br><h2>  aguardar em um m√©todo de linha √∫nica </h2><br><p>  O √∫ltimo antipadr√£o n√£o √© t√£o assustador quanto os anteriores.  A conclus√£o √© que n√£o faz sentido usar async / waitit em m√©todos que, por exemplo, simplesmente encaminham o resultado de outro m√©todo ass√≠ncrono, com a poss√≠vel exce√ß√£o de usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wait em uso</a> . </p><br>  Em vez deste c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br>  seria inteiramente poss√≠vel (e preferencialmente) escrever: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><p>  Por que isso funciona?  Porque a palavra-chave wait pode ser aplicada a objetos do tipo Tarefa e n√£o a m√©todos marcados com a palavra-chave ass√≠ncrona.  Por sua vez, a palavra-chave async diz ao compilador que esse m√©todo precisa ser implantado em uma m√°quina de estado e agrupa todos os valores de retorno em uma <code>Task</code> (ou em outro objeto semelhante a uma tarefa). </p><br><p>  Em outras palavras, o resultado da primeira vers√£o do m√©todo √© <code>Task</code> , que ser√° <code>Completed</code> assim que a espera por <code>Task.Delay(1000)</code> terminar, e o resultado da segunda vers√£o do m√©todo for <code>Task</code> , retornado pelo pr√≥prio <code>Task.Delay(1000)</code> , que ser√° <code>Completed</code> assim que os milissegundos passarem . </p><br><p>  Como voc√™ pode ver, ambas as vers√µes s√£o equivalentes, mas, ao mesmo tempo, a primeira requer muito mais recursos para criar um "kit corporal" ass√≠ncrono. </p><br><p></p><blockquote>  Alex Davis escreve que o <b>custo de chamar diretamente o m√©todo ass√≠ncrono pode ser dez vezes o custo de chamar o m√©todo s√≠ncrono</b> , portanto, h√° algo a ser tentado. </blockquote><br><br>  <b>UPD:</b> <br>  Como os coment√°rios apontam corretamente, a observa√ß√£o ass√≠ncrona / aguardada a partir de m√©todos de linha √∫nica leva a efeitos colaterais negativos.  Por exemplo, ao lan√ßar uma exce√ß√£o, o m√©todo que lan√ßa a Tarefa para cima n√£o ser√° vis√≠vel na pilha.  Portanto, a <b>remo√ß√£o de padr√µes n√£o √© recomendada por padr√£o</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O post de Clary</a> com a an√°lise. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435666/">https://habr.com/ru/post/pt435666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435652/index.html">Como n√£o senhas em scripts Python</a></li>
<li><a href="../pt435654/index.html">Armadilhas das propriedades CSS personalizadas</a></li>
<li><a href="../pt435656/index.html">Scooter Rolls Royce - Ninebot KickScooter ES4 da Segway</a></li>
<li><a href="../pt435662/index.html">‚ÄúConfiabilidade e confiabilidade como no Google‚Äù - e n√£o apenas: tradu√ß√£o do artigo ‚ÄúC√°lculo da confiabilidade do servi√ßo‚Äù</a></li>
<li><a href="../pt435664/index.html">Falsifica√ß√£o do mecanismo de pesquisa do Google</a></li>
<li><a href="../pt435668/index.html">Outra lei da primavera: o deputado prop√¥s permitir √† pol√≠cia rastrear a localiza√ß√£o de crian√ßas usando geolocaliza√ß√£o</a></li>
<li><a href="../pt435670/index.html">Algoritmo supremo - distribui√ß√£o de algoritmos por n√≠vel de dificuldade</a></li>
<li><a href="../pt435672/index.html">Como treinar novamente em business intelligence</a></li>
<li><a href="../pt435678/index.html">N√£o confie em informa√ß√µes de mem√≥ria no Gerenciador de tarefas</a></li>
<li><a href="../pt435680/index.html">AWS mostrou dedo m√©dio de c√≥digo aberto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>