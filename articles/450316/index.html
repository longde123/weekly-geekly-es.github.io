<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📁 🧙 🚁 TDD: una metodología de desarrollo que cambió mi vida 🌃 🤟🏻 👢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A las 7:15 a.m. Nuestro soporte técnico está inundado de trabajo. Good Morning America acaba de hablar de nosotros y muchos de los que visitan nuestro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TDD: una metodología de desarrollo que cambió mi vida</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/450316/">  A las 7:15 a.m.  Nuestro soporte técnico está inundado de trabajo.  Good Morning America acaba de hablar de nosotros y muchos de los que visitan nuestro sitio por primera vez han encontrado errores. <br><br>  Tenemos mucha prisa.  Nosotros, ahora mismo, antes de perder la oportunidad de convertir a los visitantes del recurso en nuevos usuarios, vamos a implementar el fixpack.  Uno de los desarrolladores preparó algo.  Él piensa que esto ayudará a hacer frente al problema.  Colocamos un enlace a la versión actualizada del programa, que aún no ha entrado en producción, al chat de la empresa, y pedimos a todos que lo prueben.  Funciona! <br><br>  Nuestros heroicos ingenieros ejecutan scripts para implementar los sistemas y después de unos minutos la actualización entra en batalla.  De repente, el número de llamadas de soporte técnico se duplica.  Nuestra solución urgente rompió algo, los desarrolladores se llevaron la culpa y los ingenieros hicieron retroceder el sistema a su estado anterior en ese momento. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/715/f8a/020/715f8a020e1adfe61cb65c6b6bccb191.jpg" alt="imagen"></a> <br><br>  El autor del material, cuya traducción publicamos hoy, cree que todo esto podría haberse evitado gracias a TDD. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¿Por qué estoy usando TDD?</font> </h2><br>  No he estado en situaciones como esta durante mucho tiempo.  Y no es que los desarrolladores hayan dejado de cometer errores.  El hecho es que durante muchos años, en todos los equipos que dirigí e influí, se aplicó la metodología TDD.  Los errores, por supuesto, aún ocurren, pero la penetración en la producción de problemas que pueden "derribar" el proyecto ha disminuido a casi cero, a pesar de que la frecuencia de las actualizaciones de software y el número de tareas que deben resolverse durante la actualización han crecido exponencialmente desde entonces. cuando sucedió algo de lo que hablé al principio. <br><br>  Cuando alguien me pregunta por qué debería ponerse en contacto con TDD, le cuento esta historia y puedo recordar una docena más de casos similares.  Una de las razones más importantes por las que cambié a TDD es que esta metodología <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mejora la</a> cobertura de las pruebas con código, lo que conduce a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">40-80% menos de errores</a> en la producción.  Esto es lo que más me gusta de TDD.  Esto quita una montaña de problemas de los hombros de los desarrolladores. <br><br>  Además, vale la pena señalar que TDD salva a los desarrolladores del temor de realizar cambios en el código. <br><br>  En los proyectos en los que participo, conjuntos de módulos automáticos y pruebas funcionales casi a diario evitan que el código entre en producción, lo que puede interrumpir seriamente el trabajo de estos proyectos.  Por ejemplo, ahora estoy mirando 10 actualizaciones automáticas de la biblioteca realizadas la semana pasada, de modo que antes de lanzarlas sin usar TDD, me temo que podrían arruinar algo. <br><br>  Todas estas actualizaciones se integraron automáticamente en el código y ya se usan en producción.  No revisé ninguno de ellos manualmente, y no me preocupé en absoluto de que pudieran tener un efecto negativo en el proyecto.  Al mismo tiempo, para dar este ejemplo, no tuve que pensar mucho.  Acabo de abrir GitHub, miré fusiones recientes y vi de lo que estaba hablando.  La tarea que anteriormente se resolvió manualmente (o, lo que es peor, el problema que se ignoró) ahora es un proceso en segundo plano automatizado.  Puede intentar hacer algo similar sin una buena cobertura de código con las pruebas, pero no recomendaría hacerlo. <br><br><h2>  <font color="#3AC1EF">¿Qué es TDD?</font> </h2><br>  TDD son las siglas de Test Driven Development.  El proceso implementado al aplicar esta metodología es muy simple: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6e/b62/856/b6eb62856a3b14b0c661e94ed12cc6b8.png"></div><br>  <i><font color="#999999">Las pruebas detectan errores, las pruebas se completan con éxito, se realiza la refactorización</font></i> <br><br>  Estos son los principios básicos para usar TDD: <br><br><ol><li>  Antes de escribir un código de implementación para alguna característica, escriben una prueba que le permite verificar si este futuro código de implementación funciona o no.  Antes de continuar con el siguiente paso, se inicia la prueba y está convencido de que arroja un error.  Gracias a esto, puede estar seguro de que la prueba no produce resultados falsos positivos, es un tipo de prueba de las pruebas mismas. </li><li>  Crean una implementación de la oportunidad y aseguran que pase la prueba con éxito. </li><li>  Realice, si es necesario, la refactorización de código.  La refactorización, en presencia de una prueba que puede indicarle al desarrollador si el sistema está funcionando correcta o incorrectamente, le da confianza al desarrollador en sus acciones. </li></ol><br><h2>  <font color="#3AC1EF">¿Cómo puede TDD ayudar a ahorrar el tiempo necesario para desarrollar programas?</font> </h2><br>  A primera vista, podría parecer que escribir pruebas significa un aumento significativo en la cantidad de código del proyecto, y que todo esto lleva a los desarrolladores mucho tiempo extra.  En mi caso, al principio, todo era solo eso, y traté de comprender cómo, en principio, es posible escribir código comprobable y cómo agregar pruebas al código que ya se ha escrito. <br><br>  TDD se caracteriza por una cierta curva de aprendizaje, y mientras un principiante sube por esta curva, el tiempo requerido para el desarrollo puede aumentar en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">15-35%</a> .  A menudo esto es exactamente lo que sucede.  Pero en algún lugar unos 2 años después del inicio del uso de TDD, algo increíble comienza a suceder.  A saber, por ejemplo, comencé, con la redacción preliminar de pruebas unitarias, programando más rápido que antes cuando no se usaba TDD. <br><br>  Hace unos años, implementé, en el sistema del cliente, la capacidad de trabajar con fragmentos de un videoclip.  Es decir, el punto era que sería posible permitir al usuario indicar el comienzo y el final del fragmento de grabación, y recibir un enlace al mismo, lo que permitiría referirse a un lugar específico en el clip, y no a todo este clip. <br><br>  No trabajé  El jugador llegó al final del fragmento y continuó jugando, pero no tenía idea de por qué era así. <br><br>  Pensé que el problema estaba conectando incorrectamente los oyentes de eventos.  Mi código se parecía a esto: <br><br><pre><code class="plaintext hljs">video.addEventListener('timeupdate', () =&gt; {  if (video.currentTime &gt;= clip.stopTime) {    video.pause();  } });</code> </pre> <br>  El proceso para encontrar el problema se veía así: hacer cambios, compilar, reiniciar, hacer clic, esperar ... Esta secuencia de acciones se repitió una y otra vez. <br><br>  Para verificar cada uno de los cambios introducidos en el proyecto, me llevó casi un minuto gastarlo, y experimenté una increíble cantidad de opciones para resolver el problema (la mayoría de ellos 2-3 veces). <br><br>  ¿Tal vez cometí un error en la palabra clave <code>timeupdate</code> ?  ¿Entendí las características de trabajar con la API correctamente?  ¿La llamada <code>video.pause()</code> ?  Realicé cambios en el código, agregué <code>console.log()</code> , volví al navegador, hice clic en el botón <code></code> , hice clic en la posición ubicada al final del fragmento seleccionado y luego esperé pacientemente hasta que el clip se reproduzca por completo.  Iniciar sesión dentro de la construcción <code>if</code> no condujo a nada.  Parecía una pista sobre un posible problema.  Copié la palabra <code>timeupdate</code> de la documentación de la API para estar absolutamente seguro de que no cometí un error al ingresarla.  Vuelvo a cargar la página, hago clic de nuevo, espero de nuevo.  Y nuevamente, el programa se niega a funcionar correctamente. <br><br>  Finalmente puse <code>console.log()</code> fuera del bloque <code>if</code> .  "No ayudará", pensé.  Al final, la <code>if</code> era tan simple que simplemente no tenía idea de cómo escribirla incorrectamente.  Pero iniciar sesión en este caso funcionó.  Me atraganté con el café.  "¿Qué demonios es eso?"  Pensé <br><blockquote>  Ley de depuración de Murphy.  El lugar del programa que nunca probó, ya que creía firmemente que no podía contener errores, será exactamente el lugar donde encontrará un error después de que, una vez agotado, realice cambios en este lugar solo porque que ya han intentado todo lo que se les ocurrió. </blockquote><br>  Establecí un punto de interrupción en el programa para entender lo que está sucediendo.  <code>clip.stopTime</code> el significado de <code>clip.stopTime</code> .  Para mi sorpresa, no estaba <code>undefined</code> .  Por qué  Miré el código nuevamente.  Cuando el usuario selecciona la hora de finalización del fragmento, el programa coloca el marcador para el final del fragmento en el lugar correcto, pero no establece el valor de <code>clip.stopTime</code> .  "Soy un idiota increíble", pensé, "no se me debe permitir entrar a las computadoras hasta el final de mi vida". <br><br>  No me olvidé de esto y años después.  Y todo, gracias a la sensación que experimenté, aún encontrando un error.  Probablemente sabes de lo que estoy hablando.  Con todo esto sucedió.  Y, tal vez, todos podrán reconocerse en este meme. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/703/e2d/01c/703e2d01c140fba62e25914e340bad97.png"></div><br>  <i><font color="#999999">Así es como me veo cuando programo</font></i> <br><br>  Si escribiera ese programa hoy, comenzaría a trabajar de esta manera: <br><br><pre> <code class="plaintext hljs">describe('clipReducer/setClipStopTime', async assert =&gt; { const stopTime = 5; const clipState = {   startTime: 2,   stopTime: Infinity }; assert({   given: 'clip stop time',   should: 'set clip stop time in state',   actual: clipReducer(clipState, setClipStopTime(stopTime)),   expected: { ...clipState, stopTime } }); });</code> </pre> <br>  Existe la sensación de que hay mucho más código que en esta línea: <br><br><pre> <code class="plaintext hljs">clip.stopTime = video.currentTime</code> </pre> <br>  Pero ese es el punto.  Este código actúa como una especificación.  Esto es documentación y prueba de que el código funciona como lo requiere esta documentación.  Y, dado que esta documentación existe, si cambio el orden de trabajo con el marcador por el tiempo de finalización de un fragmento, no tengo que preocuparme si durante la introducción de estos cambios violé la operación correcta con el tiempo de finalización del clip. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí</a> , por cierto, hay material útil para escribir pruebas unitarias, el mismo que acabamos de ver. <br><br>  El punto no es cuánto tiempo lleva ingresar este código.  El punto es cuánto tiempo lleva depurar si algo sale mal.  Si el código es incorrecto, la prueba dará un excelente informe de error.  Inmediatamente sabré que el problema no es el controlador de eventos.  <code>setClipStopTime()</code> que es en <code>setClipStopTime()</code> o en <code>clipReducer()</code> , donde se implementa un cambio de estado.  Gracias a la prueba, sabría qué funciones realiza el código, qué muestra realmente y qué se espera de él.  Y, lo que es más importante, mi colega tendrá el mismo conocimiento, quien, seis meses después de que escribí el código, introducirá nuevas características en él. <br><br>  Al comenzar un nuevo proyecto, yo, como una de las primeras cosas, configuro un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">script de observación</a> que ejecuta automáticamente pruebas unitarias cada vez que se cambia un determinado archivo.  A menudo programo usando dos monitores.  En uno de ellos, se abre la consola del desarrollador, en la que se muestran los resultados de dicho script, en el otro, se muestra la interfaz del entorno en el que escribo el código.  Cuando realizo un cambio en el código, generalmente, en 3 segundos, averiguo si el cambio funcionó o no. <br><br>  Para mí, TDD es mucho más que un seguro.  Esta es la capacidad de recibir de manera constante y rápida, en tiempo real, información sobre el estado de mi código.  Recompensa instantánea en forma de pruebas aprobadas o un informe instantáneo de errores en caso de que haya hecho algo mal. <br><br><h2>  <font color="#3AC1EF">¿Cómo me enseñó la metodología TDD a escribir mejor código?</font> </h2><br>  Me gustaría hacer una admisión, incluso admitir que es vergonzoso: no tenía idea de cómo crear aplicaciones antes de aprender TDD y pruebas unitarias.  No puedo imaginar cómo me contrataron, pero después de entrevistar a cientos de desarrolladores, puedo decir con confianza que muchos programadores se encuentran en una situación similar.  La metodología TDD me ha enseñado casi todo lo que sé sobre la descomposición eficiente y la composición de componentes de software (me refiero a módulos, funciones, objetos, componentes de interfaz de usuario, etc.). <br><br>  La razón de esto es que las pruebas unitarias obligan al programador a probar componentes aislados uno del otro y de los subsistemas de E / S.  Si el módulo se proporciona con algunos datos de entrada, debe proporcionar ciertos datos de salida previamente conocidos.  Si no lo hace, la prueba falla.  Si lo hace, la prueba tiene éxito.  El punto aquí es que el módulo debería funcionar independientemente del resto de la aplicación.  Si está probando la lógica del estado, debería poder hacerlo sin mostrar nada en la pantalla o guardar nada en la base de datos.  Si está probando la formación de la interfaz de usuario, debería poder probarla sin tener que cargar la página en un navegador o acceder a los recursos de la red. <br><br>  Entre otras cosas, la metodología TDD me enseñó que la vida se vuelve mucho más fácil si se lucha por el minimalismo al desarrollar componentes de interfaz de usuario.  Además, la lógica empresarial y los efectos secundarios deben aislarse de la interfaz de usuario.  Desde un punto de vista práctico, esto significa que si usa un marco de interfaz de usuario basado en componentes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">React</a> o Angular, puede ser aconsejable crear componentes de presentación que sean responsables de mostrar algo en la pantalla y componentes del contenedor que no están conectados entre sí son mixtos <br><br>  Un componente de presentación que recibe ciertas propiedades siempre genera el mismo resultado.  Dichos componentes se pueden verificar fácilmente mediante pruebas unitarias.  Esto le permite averiguar si el componente funciona correctamente con las propiedades y si cierta lógica condicional utilizada en la formación de la interfaz es correcta.  Por ejemplo, es posible que el componente que forma la lista no muestre nada más que una invitación para agregar un nuevo elemento a la lista si la lista está vacía. <br><br>  Conocía el principio de separación de responsabilidades mucho antes de dominar TDD, pero no sabía cómo compartir la responsabilidad entre diferentes entidades. <br><br>  Las pruebas unitarias me permitieron estudiar el uso de mokas para probar algo, y luego descubrí que burlarse es una señal de que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algo podría estar mal con el código</a> .  Me sorprendió y cambió por completo mi enfoque de la composición del software. <br><br>  Todo el desarrollo de software es una composición: el proceso de dividir problemas grandes en muchos problemas pequeños y fáciles de resolver, y luego crear soluciones para estos problemas que forman la aplicación.  Tuxing por el bien de las pruebas unitarias indica que las unidades atómicas de la composición no son, de hecho, atómicas.  Estudiar cómo deshacerse de mok sin afectar la cobertura del código mediante pruebas me permitió aprender a identificar las innumerables razones ocultas de la fuerte conexión de las entidades. <br><br>  Esto me permitió, como desarrollador, crecer profesionalmente.  Esto me enseñó a escribir código mucho más simple que es más fácil de extender, mantener y escalar.  Esto se aplica a la complejidad del código en sí y a la organización de su trabajo en grandes sistemas distribuidos, como las infraestructuras de la nube. <br><br><h2>  <font color="#3AC1EF">¿Cómo TDD ahorra tiempo al equipo?</font> </h2><br>  Ya he dicho que TDD, en primer lugar, conduce a una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mejor</a> cobertura del código con las pruebas.  La razón de esto es que no comenzamos a escribir código para implementar alguna característica hasta que escribimos una prueba que verifica el funcionamiento correcto de este código futuro.  Primero escribimos una prueba.  Luego permitimos que termine con un error.  Luego escribimos el código para implementar la oportunidad.  Estamos probando el código, recibimos un mensaje de error, logramos la aprobación correcta de las pruebas, realizamos la refactorización y repetimos este proceso. <br><br>  Este proceso le permite crear una "cerca" a través de la cual solo unos pocos errores pueden "saltar".  Esta protección contra errores tiene un efecto sorprendente en todo el equipo de desarrollo.  Alivia el miedo al equipo de fusión. <br><br>  El alto nivel de cobertura del código con pruebas permite al equipo deshacerse del deseo de controlar manualmente cualquier cambio, incluso pequeño, en la base del código.  Los cambios de código se convierten en una parte natural del flujo de trabajo. <br><br>  Deshacerse del miedo a hacer cambios en el código se asemeja al desenfoque de cierta máquina.  Si esto no se hace, la máquina finalmente se detendrá, hasta que se lubrique y se reinicie. <br><br>  Sin este temor, el proceso de trabajar en programas es mucho más tranquilo que antes.  Las solicitudes de extracción no se retrasan hasta el final.  El sistema CI / CD ejecutará las pruebas y, si las pruebas fallan, detendrá el proceso de realizar cambios en el código del proyecto.  Al mismo tiempo, los mensajes de error y la información sobre exactamente dónde ocurrieron serán muy difíciles de no notar. <br><br>  Este es todo el punto. <br><br>  <b>Estimados lectores!</b>  ¿Utiliza TDD cuando trabaja en sus proyectos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450316/">https://habr.com/ru/post/450316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450304/index.html">Carapuzik montando una hormiga: 100 millones de años de mirmeofilia</a></li>
<li><a href="../450308/index.html">GPU Ray Tracing en Unity - Parte 3</a></li>
<li><a href="../450310/index.html">Cómo funciona Philips VideoWRITER. Primeras imágenes de hierro, luego un poco de tedio.</a></li>
<li><a href="../450312/index.html">Docker Compose Starter Guide</a></li>
<li><a href="../450314/index.html">TensorFlow para principiantes. Parte 1: información general, instalación de la biblioteca</a></li>
<li><a href="../450318/index.html">Diseñar patrones en el desarrollo moderno de JavaScript</a></li>
<li><a href="../450320/index.html">Los juegos cuánticos simples revelan la máxima complejidad del universo</a></li>
<li><a href="../450322/index.html">¿Por qué necesitamos tantos mensajeros?</a></li>
<li><a href="../450324/index.html">Cómo el sistema de seguimiento de productividad despide automáticamente a los empleados de Amazon</a></li>
<li><a href="../450330/index.html">Elegir una escuela cuando te mudas a los EE. UU.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>