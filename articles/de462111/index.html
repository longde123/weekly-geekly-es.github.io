<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍✈️ 👩🏼‍🌾 🐖 Wie wir mehrere Zeitreihendatenbanken getestet haben ⬜️ ⛵️ 🛀🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Jahren haben sich Zeitreihendatenbanken von einer merkwürdigen Sache (hoch spezialisiert auf offene Überwachungssysteme (und an bestimm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir mehrere Zeitreihendatenbanken getestet haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/462111/"><img src="https://habrastorage.org/webt/u_/ty/r0/u_tyr0djrlkmaz-swo9flhddymo.jpeg"><br><br>  In den letzten Jahren haben sich Zeitreihendatenbanken von einer merkwürdigen Sache (hoch spezialisiert auf offene Überwachungssysteme (und an bestimmte Lösungen gebunden) oder Big-Data-Projekte) zu einem „Konsumgüter“ entwickelt.  Auf dem Gebiet der Russischen Föderation gilt Yandex und ClickHouse ein besonderer Dank dafür.  Wenn Sie bis zu diesem Zeitpunkt eine große Menge von Zeitreihendaten speichern mussten, mussten Sie entweder die Notwendigkeit akzeptieren, einen monströsen Hadoop-Stapel zu erstellen und ihn zu begleiten, oder mit systemspezifischen Protokollen kommunizieren. <br><br>  Es könnte den Anschein haben, dass ein Artikel, über den TSDB verwendet werden sollte, 2019 nur aus einem Satz bestehen wird: „Verwenden Sie einfach ClickHouse“.  Aber ... es gibt Nuancen. <br><br>  In der Tat entwickelt sich ClickHouse aktiv weiter, die Benutzerbasis wächst und der Support ist sehr aktiv. Sind wir jedoch zu Geiseln des öffentlichen Erfolgs von ClickHouse geworden, der andere, möglicherweise effektivere / zuverlässigere Lösungen überschattet hat? <br><br>  Anfang letzten Jahres haben wir mit der Verarbeitung unseres eigenen Überwachungssystems begonnen. Dabei stellte sich die Frage nach der Auswahl der geeigneten Datenbank zum Speichern von Daten.  Ich möchte hier über die Geschichte dieser Wahl erzählen. <br><a name="habracut"></a><br><h4>  Erklärung des Problems </h4><br>  Zunächst das notwendige Vorwort.  Warum brauchen wir ein eigenes Überwachungssystem und wie wurde es eingerichtet? <br><br>  Wir haben 2008 mit der Bereitstellung von Support-Services begonnen, und bis 2010 wurde klar, dass es schwierig war, Daten zu Prozessen in der Client-Infrastruktur mit den damals existierenden Lösungen zu aggregieren (wir sprechen über, Gott vergebe mir, Cacti, Zabbix und die Entstehenden Graphit). <br><br>  Unsere Hauptanforderungen waren: <br><br><ul><li>  Unterstützung (zu dieser Zeit - Dutzende und in Zukunft - Hunderte) von Kunden innerhalb desselben Systems und gleichzeitig das Vorhandensein eines zentralisierten Alarmverwaltungssystems; </li><li>  Flexibilität bei der Verwaltung des Warnsystems (Eskalation von Warnungen zwischen Teilnehmern, Zeitplanabrechnung, Wissensdatenbank); </li><li>  die Möglichkeit einer tiefen Detaillierung von Grafiken (Zabbix zeichnete zu dieser Zeit Grafiken in Form von Bildern); </li><li>  Langzeitspeicherung einer großen Datenmenge (ein Jahr oder länger) und die Möglichkeit, diese schnell auszuwählen. </li></ul><br>  In diesem Artikel interessieren wir uns für den letzten Punkt. <br><br>  Apropos Lagerung: Die Anforderungen waren wie folgt: <br><br><ul><li>  Das System sollte schnell funktionieren. </li><li>  Es ist wünschenswert, dass das System über eine SQL-Schnittstelle verfügt. </li><li> Das System muss stabil sein und eine aktive Benutzerbasis und Unterstützung haben (sobald wir die Notwendigkeit hatten, Systeme wie beispielsweise MemcacheDB, die wir nicht mehr entwickelt haben, oder den verteilten Speicher MooseFS zu unterstützen, dessen Bugtracker auf Chinesisch durchgeführt wurde: Wiederholung dieser Geschichte für unser Projekt wollte nicht); </li><li>  Korrespondenz mit dem CAP-Theorem: Konsistenz (erforderlich) - Die Daten müssen relevant sein. Wir möchten nicht, dass das Benachrichtigungsverwaltungssystem keine neuen Daten erhält und Warnungen über das Nichtankommen von Daten für alle Projekte ausgibt.  Partitionstoleranz (notwendig) - Wir möchten keine Split-Brain-Systeme erhalten.  Verfügbarkeit (nicht kritisch, bei einem aktiven Replikat) - Wir können im Falle eines Unfalls selbst mit einem Code zum Backup-System wechseln. </li></ul><br>  Seltsamerweise war MySQL damals die perfekte Lösung für uns.  Unsere Datenstruktur war äußerst einfach: Server-ID, Zähler-ID, Zeitstempel und Wert;  Die schnelle Abtastung heißer Daten wurde durch einen großen Pufferpool bereitgestellt, und die Abtastung historischer Daten wurde durch SSD bereitgestellt. <br><br><img src="https://habrastorage.org/webt/ii/cd/es/iicdesd_tmiqwygfha8r4bepjgg.png"><br><br>  Auf diese Weise haben wir eine Stichprobe von neuen zweiwöchigen Daten mit einer Detaillierung von bis zu einer Sekunde 200 ms vor dem vollständigen Rendern der Daten erzielt und einige Zeit in diesem System gelebt. <br><br>  In der Zwischenzeit verging die Zeit und die Datenmenge wuchs.  Bis 2016 erreichte das Datenvolumen mehrere zehn Terabyte, was im Hinblick auf den geleasten SSD-Speicher einen erheblichen Aufwand darstellte. <br><br>  Zu diesem Zeitpunkt verbreiteten sich Säulendatenbanken aktiv, worüber wir uns aktiv Gedanken machten: In Säulendatenbanken werden Daten, wie Sie verstehen, in Spalten gespeichert, und wenn Sie sich unsere Daten ansehen, ist es leicht, eine große Anzahl von Takes zu erkennen, die dies sein könnten Wenn Sie eine Spaltendatenbank verwenden, komprimieren Sie mit Komprimierung. <br><br><img src="https://habrastorage.org/webt/zm/gu/x3/zmgux307lo7r3i7s9uykpgozadm.png"><br><br>  Das Schlüsselsystem für die Arbeit des Unternehmens funktionierte jedoch weiterhin stabil, und ich wollte nicht mit dem Übergang zu etwas anderem experimentieren. <br><br>  2017, auf der Percona Live-Konferenz in San Jose, wahrscheinlich zum ersten Mal, dass sich die Clickhouse-Entwickler bekannt gaben.  Auf den ersten Blick war das System produktionsbereit (Yandex.Metrica ist eine harte Produktion), der Support war schnell und einfach, und vor allem war die Bedienung einfach.  Seit 2018 haben wir den Übergangsprozess gestartet.  Zu diesem Zeitpunkt gab es jedoch viele „erwachsene“ und bewährte TSDB-Systeme, und wir beschlossen, viel Zeit zuzuweisen und Alternativen zu vergleichen, um sicherzustellen, dass es keine alternativen Clickhouse-Lösungen gemäß unseren Anforderungen gab. <br><br>  Zusätzlich zu den bereits angegebenen Lagerungsanforderungen erschienen neue: <br><br><ul><li>  Das neue System sollte mindestens die gleiche Leistung wie MySQL bei gleicher Eisenmenge bieten. </li><li>  Die Lagerung des neuen Systems sollte deutlich weniger Platz beanspruchen. </li><li>  DBMS sollte immer noch einfach zu verwalten sein. </li><li>  Ich wollte die Anwendung beim Ändern des DBMS minimieren. </li></ul><br><h4>  Welche Systeme haben wir in Betracht gezogen? </h4><br>  <b><u>Apache Hive / Apache Impala</u></b> <br>  Alter ramponierter Hadoop-Stapel.  Tatsächlich ist dies eine SQL-Schnittstelle, die auf dem Speichern von Daten in nativen Formaten in HDFS basiert. <br><br>  Vorteile. <br><br><ul><li>  Bei stabilem Betrieb ist es sehr einfach, die Daten zu skalieren. </li><li>  Es gibt Spaltenlösungen für die Datenspeicherung (weniger Speicherplatz). </li><li>  Sehr schnelle Ausführung paralleler Aufgaben bei Vorhandensein von Ressourcen. </li></ul><br>  Nachteile <br><br><ul><li>  Dies ist ein Hadoop, und es ist schwierig zu bedienen.  Wenn wir nicht bereit sind, eine vorgefertigte Lösung in der Cloud zu übernehmen (und wir sind nicht bereit für die Kosten), muss der gesamte Stapel von den Administratoren zusammengestellt und unterstützt werden, aber das möchte ich wirklich nicht. </li><li>  Daten werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sehr schnell</a> aggregiert. </li></ul><br>  Allerdings: <br><br><img src="https://habrastorage.org/webt/zi/nv/qx/zinvqxvmxc43df-hd4xjqwprtmi.png"><br><br>  Die Geschwindigkeit wird durch Skalieren der Anzahl der Computerserver erreicht.  Einfach ausgedrückt, wenn wir ein großes Unternehmen sind, das sich mit Analytik und Geschäft befasst, ist es von entscheidender Bedeutung, Informationen so schnell wie möglich zu aggregieren (selbst auf Kosten einer großen Anzahl von Computerressourcen) - dies kann unsere Wahl sein.  Aber wir waren nicht bereit, den Eisenpark zu vervielfachen, um die Aufgaben zu beschleunigen. <br><br>  <b><u>Druide / Pinot</u></b> <br><br>  Schon viel mehr über TSDB speziell, aber nochmal - Hadoop-Stack. <br><br>  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">großartigen Artikel, in dem die Vor- und Nachteile von Druid und Pinot im Vergleich zu ClickHouse verglichen werden</a> . <br><br>  In wenigen Worten: Druide / Pinot sehen in Fällen besser aus als Clickhouse, in denen: <br><br><ul><li>  Sie haben eine heterogene Natur der Daten (in unserem Fall erfassen wir nur Zeitreihen von Servermetriken, und tatsächlich ist dies eine Tabelle. Es kann aber auch andere Fälle geben: Gerätezeitreihen, wirtschaftliche Zeitreihen usw. - jede mit ihrer eigenen Struktur, die aggregiert und verarbeitet werden müssen). </li><li>  Darüber hinaus gibt es viele dieser Daten. </li><li>  Tabellen und Daten mit Zeitreihen werden angezeigt und ausgeblendet (dh es wurde eine Art Datensatz eingegeben, der analysiert und gelöscht wurde). </li><li>  Es gibt kein klares Kriterium, nach dem Daten partitioniert werden können. </li></ul><br>  In entgegengesetzten Fällen zeigt sich ClickHouse besser, und dies ist unser Fall. <br><br>  <b><u>Clickhouse</u></b> <br><br><ul><li>  SQL-ähnlich. </li><li>  Einfach zu verwalten. </li><li>  Die Leute sagen, dass es funktioniert. </li></ul><br>  Es fällt in die engere Auswahl der Tests. <br><br>  <b><u>Influxdb</u></b> <br><br>  Ausländische Alternative zu ClickHouse.  Von den Minuspunkten: Hochverfügbarkeit ist nur in der kommerziellen Version vorhanden, muss aber verglichen werden. <br><br>  Es fällt in die engere Auswahl der Tests. <br><br>  <b><u>Cassandra</u></b> <br><br>  Einerseits wissen wir, dass es zum Speichern metrischer Zeitreihen von Überwachungssystemen wie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SignalFX</a> oder OkMeter verwendet wird.  Es gibt jedoch Besonderheiten. <br><br>  Cassandra ist keine Spaltendatenbank im üblichen Sinne.  Es sieht eher wie ein Kleinbuchstabe aus, aber jede Zeile kann eine andere Anzahl von Spalten haben, wodurch es einfach ist, eine Spaltendarstellung zu organisieren.  In diesem Sinne ist es klar, dass Sie mit einem Limit von 2 Milliarden Spalten einige Daten in den Spalten speichern können (ja, dieselbe Zeitreihe).  In MySQL gibt es beispielsweise eine Begrenzung für 4096 Spalten, und es ist leicht, auf einen Fehler mit Code 1117 zu stoßen, wenn Sie versuchen, dasselbe zu tun. <br><br>  Die Cassandra-Engine konzentriert sich auf das Speichern großer Datenmengen in einem verteilten System ohne Assistenten, und im obigen CAP-Theorem geht es bei Cassandra mehr um AP, dh um die Zugänglichkeit von Daten und den Widerstand gegen Partitionierung.  Daher kann dieses Tool großartig sein, wenn Sie nur in diese Datenbank schreiben und selten daraus lesen müssen.  Und hier ist es logisch, Cassandra als "kalten" Speicher zu verwenden.  Das heißt, als langfristig zuverlässiger Ort zum Speichern großer Mengen historischer Daten, die selten benötigt werden, aber bei Bedarf abgerufen werden können.  Der Vollständigkeit halber werden wir es dennoch testen.  Wie ich bereits sagte, besteht jedoch kein Wunsch, den Code für die ausgewählte DB-Lösung aktiv neu zu schreiben. Daher werden wir ihn etwas eingeschränkt testen - ohne die Datenbankstruktur an die Besonderheiten von Cassandra anzupassen. <br><br>  <b><u>Prometheus</u></b> <br><br>  Aus Interesse haben wir uns entschlossen, die Leistung des Prometheus-Stores zu testen - nur um zu verstehen, ob und wie viel wir schneller als aktuelle Lösungen oder langsamer sind. <br><br><h4>  Methodik und Testergebnisse </h4><br>  Daher haben wir 5 Datenbanken in den folgenden 6 Konfigurationen getestet: ClickHouse (1 Knoten), ClickHouse (verteilte Tabelle mit 3 Knoten), InfluxDB, MySQL 8, Cassandra (3 Knoten) und Prometheus.  Der Testplan lautet wie folgt: <br><br><ol><li>  Geben Sie die historischen Daten für die Woche ein (840 Millionen Werte pro Tag; 208.000 Metriken). </li><li>  eine Aufzeichnungslast erzeugen (6 Lastmodi wurden berücksichtigt, siehe unten); </li><li>  Parallel zur Aufzeichnung erstellen wir regelmäßig Stichproben, die die Anforderungen eines Benutzers emulieren, der mit Diagrammen arbeitet.  Um die Sache nicht zu kompliziert zu machen, haben wir Daten mit 10 Metriken (genauso viele davon im CPU-Diagramm) pro Woche ausgewählt. </li></ol><br>  Wir laden, indem wir das Verhalten unseres Überwachungsagenten emulieren, der alle 15 Sekunden Werte an jede Metrik sendet.  In diesem Fall sind wir daran interessiert zu variieren: <br><br><ul><li>  Gesamtzahl der Metriken, in die Daten geschrieben werden; </li><li>  Intervall des Sendens von Werten in einer Metrik; </li><li>  Chargengröße. </li></ul><br>  Über die Größe der Charge.  Da fast nicht empfohlen wird, fast alle unsere experimentellen Basen mit einzelnen Einfügungen zu laden, benötigen wir ein Relais, das eingehende Metriken sammelt, sie so weit wie möglich gruppiert und sie mit einer Paketeinfügung in die Basis schreibt. <br><br>  Stellen Sie sich zum besseren Verständnis der späteren Interpretation der empfangenen Daten vor, dass wir nicht nur eine Reihe von Metriken senden, sondern die Metriken in Servern organisiert sind - 125 Metriken pro Server.  Hier ist der Server nur eine virtuelle Entität - nur um zu verstehen, dass beispielsweise 10.000 Metriken ungefähr 80 Servern entsprechen. <br><br>  Und so, unter Berücksichtigung all dessen, unsere 6 Aufzeichnungslademodi der Basis: <br><br><img src="https://habrastorage.org/webt/lr/li/oo/lrlioosoevoybfuw4--rsftdugi.jpeg"><br><br>  Es gibt zwei Punkte.  Erstens haben sich für Cassandra solche Chargengrößen als zu groß herausgestellt, dort haben wir Werte von 50 oder 100 verwendet. Und zweitens, da der Prometeus streng im Pull-Modus arbeitet, d.h.  Er geht und sammelt Daten aus metrischen Quellen (und selbst Pushgateway ändert trotz des Namens die Situation nicht grundlegend). Die entsprechenden Lasten wurden mithilfe einer Kombination statischer Konfigurationen implementiert. <br><br>  Die Testergebnisse sind wie folgt: <br><br><img src="https://habrastorage.org/webt/0r/sz/vc/0rszvcd_aeoiqwlrixsgw0tauti.jpeg"><br><br><img src="https://habrastorage.org/webt/3r/gy/2g/3rgy2guskcodctly7nevknbygss.jpeg"><br><br><img src="https://habrastorage.org/webt/v8/mg/tm/v8mgtm0ytjkjkneal1mjcvw5n8w.jpeg"><br><br>  <b>Was erwähnenswert ist</b> : fantastisch schnelle Samples von Prometheus, furchtbar langsame Samples von Cassandra, unannehmbar langsame Samples von InfluxDB;  ClickHouse hat in Bezug auf die Aufnahmegeschwindigkeit gewonnen, und Prometheus nimmt nicht am Wettbewerb teil, da es in sich selbst einfügt und wir nichts messen. <br><br>  <u><b>Als Ergebnis</b></u> : ClickHouse und InfluxDB haben sich am besten gezeigt, aber ein Cluster von Influx kann nur auf der Basis der Enterprise-Version erstellt werden, die Geld kostet, und ClickHouse kostet nichts und wird in Russland hergestellt.  Es ist logisch, dass in den USA die Wahl wahrscheinlich zugunsten von inInfluxDB und in unserem Fall zugunsten von ClickHouse getroffen wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462111/">https://habr.com/ru/post/de462111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462095/index.html">Arbeiten mit Licht und Optik: Wie man eine Karriere an der Universität beginnt - die Erfahrung von Absolventen von vier spezialisierten Masterstudiengängen</a></li>
<li><a href="../de462097/index.html">Hellgrüne Tour</a></li>
<li><a href="../de462101/index.html">Bericht vom Java Virtual Machine Language Summit 2019</a></li>
<li><a href="../de462107/index.html">Kostenloser Marathon „Big Data und Superhelden: Ihre erste Erfahrung in der Datenanalyse“</a></li>
<li><a href="../de462109/index.html">Fast unsichtbar sehen, auch in Farbe: Eine Technik zur Visualisierung von Objekten durch einen Diffusor</a></li>
<li><a href="../de462113/index.html">Schuldlose Umgebung: Niemand sollte Qualitätscode schreiben</a></li>
<li><a href="../de462115/index.html">Passen Sie den Sternenhimmel in WebGL in 1009 Byte JavaScript an</a></li>
<li><a href="../de462117/index.html">Wie kann der Wert der Produkt-Backlog-Pflege maximiert werden?</a></li>
<li><a href="../de462119/index.html">Delta Smart City Solutions: Haben Sie sich jemals gefragt, wie grün ein Kino sein kann?</a></li>
<li><a href="../de462121/index.html">Funktionale Swift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>