<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📂 ✈️ 💶 Deducción de argumento de plantilla de clase 🧝🏿 ☣️ 🐌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El estándar C ++ 17 agregó una nueva característica al lenguaje: Deducción de argumentos de plantilla de clase (CTAD) . Junto con las nuevas caracterí...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deducción de argumento de plantilla de clase</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461963/"><p><img src="https://habrastorage.org/webt/od/-t/zm/od-tzmtj9pxbfzw-hrpd7ml2gpw.jpeg"></p><br><p>  El estándar C ++ 17 agregó una nueva característica al lenguaje: <strong>Deducción de argumentos de plantilla de clase (CTAD)</strong> .  Junto con las nuevas características en C ++, tradicionalmente se agregaron nuevas formas de fotografiar sus propias extremidades.  En este artículo entenderemos qué es CTAD, para qué se utiliza, cómo simplifica la vida y qué escollos contiene. </p><a name="habracut"></a><br><h2 id="nachnyom-izdaleka">  Empecemos desde lejos </h2><br><p>  Recuerde de qué se trata la <em>deducción de argumentos de plantilla</em> y para qué sirve.  Si se siente lo suficientemente seguro con las plantillas de C ++, puede omitir esta sección y pasar inmediatamente a la siguiente. </p><br><p>  Antes de C ++ 17, la salida de los parámetros de plantilla se aplicaba solo a las plantillas de función.  Al crear una instancia de una plantilla de función, no puede especificar explícitamente aquellos argumentos de plantilla que se pueden inferir de los tipos de argumentos de la función real.  Las reglas para deducir son bastante complicadas, están <strong>cubiertas</strong> en toda la sección <strong>17.9.2</strong> de la Norma <strong>[temp.deduct]</strong> (en adelante, me refiero a la versión disponible gratuitamente del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">borrador de Norma</a> ; en versiones futuras, la numeración de la sección puede cambiar, por lo que recomiendo buscar por el código mnemónico especificado en corchetes). </p><br><p> No analizaremos en detalle todas las complejidades de estas reglas; solo las necesitan los desarrolladores de compiladores.  Para un uso práctico, es suficiente recordar una regla simple: el compilador puede derivar independientemente los argumentos de la plantilla de función, si esto se puede hacer sin ambigüedades en función de la información disponible.  Cuando se derivan tipos de parámetros de plantilla, las transformaciones estándar se aplican como cuando se llama a una función regular ( <em>const se</em> descarta de los tipos literales, las matrices se reducen a punteros, las referencias de función se reducen a punteros de función, etc.). </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } int some_func(double d) { return static_cast&lt;int&gt;(d); } int main() { const int i = 123; func(i); // func&lt;int&gt; char arr[] = "Some text"; func(arr); // func&lt;char *&gt; func(some_func); // func&lt;int (*)(double)&gt; return 0; }</span></span></code> </pre> <br><p>  Todo esto simplifica el uso de plantillas de funciones, pero, por desgracia, es completamente inaplicable a las plantillas de clase.  Al crear instancias de plantillas de clase, todos los parámetros de plantilla no predeterminados tenían que especificarse explícitamente.  Debido a esta propiedad desagradable, una familia completa de funciones gratuitas con el prefijo <em>make_</em> apareció en la biblioteca estándar: <em>make_unique</em> , <em>make_shared</em> , <em>make_pair</em> , <em>make_tuple</em> , etc. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  auto tup1 = std::tuple&lt;int, char, double&gt;(123, 'a', 40.0); //   auto tup2 = std::make_tuple(123, 'a', 40.0);</span></span></code> </pre> <br><h2 id="novoe-v-c17">  Nuevo en C ++ 17 </h2><br><p>  En el nuevo estándar, por analogía con los parámetros de las plantillas de función, los parámetros de las plantillas de clase se derivan de los argumentos de los constructores llamados: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">pair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">45.67</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// std::pair&lt;bool, double&gt; std::tuple tup(123, 'a', 40.0); // std::tuple&lt;int, char, double&gt; std::less l; // std::less&lt;void&gt;,     std::less&lt;&gt; l template &lt;typename T&gt; struct A { A(T,T); }; auto y = new A{1, 2}; //  A&lt;int&gt; auto lck = std::lock_guard(mtx); // std::lock_guard&lt;std::mutex&gt; std::copy_n(vi1, 3, std::back_insert_iterator(vi2)); //       template &lt;typename T&gt; struct F { F(T); } std::for_each(vi.begin(), vi.end(), Foo([&amp;](int i) {...})); // F&lt;lambda&gt;</span></span></code> </pre> <br><p>  Inmediatamente vale la pena mencionar las restricciones de CTAD que se aplican en el momento de C ++ 17 (tal vez estas restricciones se eliminarán en futuras versiones del Estándar): </p><br><ul><li>  CTAD no funciona con alias de plantilla: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> X&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PairIntX = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, X&gt;; PairIntX p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><ul><li>  CTAD no permite la salida parcial de argumentos (cómo funciona esto para la <em>deducción</em> regular de <em>argumentos de plantilla</em> ): </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK std::pair&lt;double&gt; q{1, 5}; // ,   std::pair&lt;double, int&gt; r{1, 5}; // OK</span></span></code> </pre> <br><p>  Además, el compilador no podrá inferir tipos de parámetros de plantilla que no estén explícitamente relacionados con los tipos de argumentos de constructor.  El ejemplo más simple es un constructor de contenedores que acepta un par de iteradores: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyVector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; MyVector(It from, It to); }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; dv = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">7.0</span></span>}; MyVector v2{dv.begin(), dv.end()}; <span class="hljs-comment"><span class="hljs-comment">//     T   It</span></span></code> </pre> <br><p>  El tipo <em>No está</em> directamente relacionado con <em>T</em> , aunque los desarrolladores sabemos exactamente cómo obtenerlo.  Para decirle al compilador cómo generar tipos directamente no relacionados, apareció una nueva construcción de lenguaje en C ++ 17, la <em>guía de deducción</em> , que discutiremos en la siguiente sección. </p><br><h2 id="deduction-guides">  Guías de dedicación </h2><br><p>  Para el ejemplo anterior, la <em>guía de deducción</em> se vería así: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; MyVector(It, It) -&gt; MyVector&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator_traits&lt;It&gt;::value_type&gt;;</code> </pre> <br><p>  Aquí le decimos al compilador que para un constructor con dos parámetros del mismo tipo, puede determinar el tipo de <em>T</em> utilizando la construcción <code>std::iterator_traits&lt;It&gt;::value_type</code> .  Tenga en cuenta que las <em>guías de deducción</em> están fuera de la definición de clase, esto le permite personalizar el comportamiento de las clases externas, incluidas las clases de la Biblioteca estándar de C ++. </p><br><p>  Una descripción formal de la sintaxis de las <em>guías</em> de <em>deducción se</em> da en C ++ Standard 17 en la sección <strong>17.10 [temp.deduct.guide]</strong> : </p><br><pre> <code class="cpp hljs">[<span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>-name (parameter-declaration-clause) -&gt; simple-<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>-id;</code> </pre> <br><p>  La palabra clave <strong>explícita</strong> antes de la <em>guía de deducción</em> prohíbe usarla con <em>copy-list-initialization</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(It, It)</span></span></span><span class="hljs-function"> -&gt; MyVector&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::iterator_traits&lt;It&gt;::value_type&gt;</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; dv = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">7.0</span></span>}; MyVector v2{dv.begin(), dv.end()}; <span class="hljs-comment"><span class="hljs-comment">//  MyVector v3 = {dv.begin(), dv.end()}; //  </span></span></code> </pre> <br><p>  Por cierto, la <em>guía de deducción</em> no tiene que ser una plantilla: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> S(T); }; S(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*) -&gt; S&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;; S s{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// S&lt;std::string&gt;</span></span></code> </pre> <br><h2 id="podrobnyy-algoritm-raboty-ctad">  Algoritmo CTAD detallado </h2><br><p>  Las reglas formales para derivar argumentos de plantilla de clase se describen en detalle en la cláusula <strong>16.3.1.8 [over.match.class.deduct] de</strong> C ++ Standard 17.  Intentemos resolverlos. </p><br><p>  Entonces, tenemos una plantilla tipo <em>C</em> para la cual se aplica CTAD.  Para elegir qué constructor y con qué parámetros llamar, para <em>C</em> , se forman muchas funciones de plantilla de acuerdo con las siguientes reglas: </p><br><ul><li>  Para cada constructor <em>Ci</em> , se genera una función ficticia de plantilla <em>Fi</em> .  <em>Los</em> parámetros de la plantilla <em>Fi</em> son parámetros <em>C</em> , seguidos de los parámetros de la plantilla <em>Ci</em> (si los hay), incluidos los parámetros con valores predeterminados.  Los tipos de parámetros de la función <em>Fi</em> corresponden a los tipos de parámetros del constructor <em>Ci</em> .  Devuelve una función ficticia <em>Fi</em> tipo <em>C</em> con argumentos que coinciden con los parámetros de la plantilla <em>C.</em> </li></ul><br><p>  Pseudocódigo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> W = A&gt; C(V, W); }; <span class="hljs-comment"><span class="hljs-comment">//    template &lt;typename T, typename U, typename V, typename W = A&gt; C&lt;T, U&gt; Fi(V, W);</span></span></code> </pre> <br><ul><li>  Si el tipo <em>C</em> no <em>está</em> definido, o no se especifican constructores, las reglas anteriores se aplican al constructor hipotético <em>C ()</em> . </li><li>  Se genera una función ficticia adicional para el constructor <em>C ©</em> , incluso se le ocurrió un nombre especial: <em>candidato de deducción de copia</em> . </li><li>  Para cada <em>guía de deducción</em> , también se genera una función ficticia <em>Fi</em> con parámetros de plantilla y argumentos de la <em>guía de deducción</em> y un valor de retorno correspondiente al tipo a la derecha de -&gt; en la <em>guía de deducción</em> (en la definición formal se llama <em>simple-template-id</em> ). </li></ul><br><p>  Pseudocódigo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; C(T, V) -&gt; C&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DT&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DT&lt;V&gt;&gt;; <span class="hljs-comment"><span class="hljs-comment">//    template &lt;typename T, typename V&gt; C&lt;typename DT&lt;T&gt;, typename DT&lt;V&gt;&gt; Fi(T,V);</span></span></code> </pre> <br><p>  Además, para el conjunto resultante de funciones ficticias <em>Fi</em> , se aplican las reglas habituales para generar parámetros de plantilla y resolución de sobrecarga con una excepción: cuando se llama a una función ficticia con una lista de inicialización que consta de un único parámetro de tipo <em>cv U</em> , donde <em>U</em> es la especialización <em>C</em> o un tipo heredado de la especialización <em>C</em> (por si acaso, aclararé que <em>cv == const volátil</em> ; dicho registro significa que los tipos <em>U</em> , <em>const U</em> , <em>volátil U</em> y <em>const volátil U</em> se tratan de la misma manera), la regla que da prioridad al constructor <code>C(std::initializer_list&lt;&gt;)</code> (se omite para detalles del <em>inicio</em> de la <em>lista</em>  <em>La</em> localización se puede encontrar en la cláusula <strong>16.3.1.7 [over.match.list] de</strong> C ++ Standard 17).  Un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v1{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// std::vector&lt;int&gt; std::vector v2{v1}; // std::vector&lt;int&gt;,   std::vector&lt;std::vector&lt;int&gt;&gt;</span></span></code> </pre> <br><p>  Finalmente, si fue posible elegir la única función ficticia más adecuada, se selecciona el constructor correspondiente o la <em>guía de deducción</em> .  Si no hay otros adecuados, o si hay varios igualmente adecuados, el compilador informa un error. </p><br><h2 id="podvodnye-kamni">  Trampas </h2><br><p>  CTAD se usa para inicializar objetos, y la inicialización es tradicionalmente una parte muy confusa del lenguaje C ++.  Con la adición de <em>una inicialización uniforme</em> en C ++ 11, las formas de dispararle la pierna solo han aumentado.  Ahora puede llamar al constructor para un objeto con corchetes redondos y rizados.  En muchos casos, ambas opciones funcionan igual, pero no siempre: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v1{<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// [8, 15] std::vector v2(8, 15); // [15, 15, … 15] (8 ) std::vector v3{8}; // [8] std::vector v4(8); //  </span></span></code> </pre> <br><p>  Hasta ahora, todo parece ser bastante lógico: <em>v1</em> y <em>v3</em> llaman al constructor que toma <code>std::initializer_list&lt;int&gt;</code> , int se infiere de los parámetros;  <em>v4</em> no puede encontrar un constructor que tome solo un parámetro de tipo <em>int</em> .  Pero estas siguen siendo flores, bayas en frente: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v5{<span class="hljs-string"><span class="hljs-string">"hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// [“hi”, “world”] std::vector v6("hi", "world"); // ??</span></span></code> </pre> <br><p>  <em>v5</em> , como se esperaba, será del tipo <code>std::vector&lt;const char*&gt;</code> y se inicializará con dos elementos, pero la siguiente línea hace algo completamente diferente.  Para un vector, solo hay un constructor que toma dos parámetros del mismo tipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alloc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class">() );</span></span></code> </pre> <br><p>  Gracias a la <em>guía de deducción</em> de <code>std::vector</code> "hi" y "world" se tratarán como iteradores, y todos los elementos que se encuentren "entre" se agregarán a un vector de tipo <code>std::vector&lt;char&gt;</code> .  Si tenemos suerte y estas dos constantes de cadena están en la memoria en una fila, entonces tres elementos caerán en el vector: 'h', 'i', '\ x00', pero, muy probablemente, dicho código conducirá a una violación de la protección de la memoria y al bloqueo del programa. </p><br><h2 id="ispolzuemye-materialy">  Materiales utilizados </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proyecto de Norma C ++ 17</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CTAD</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CppCon 2018: Stephan T. Lavavej "Deducción del argumento de plantilla de clase para todos"</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461963/">https://habr.com/ru/post/461963/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461941/index.html">Masajearlo</a></li>
<li><a href="../461945/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI para agosto de 2019</a></li>
<li><a href="../461949/index.html">AppCode 2019.2: Swift 5.1, análisis de cobertura de código por pruebas, visualización de código desmontado y más</a></li>
<li><a href="../461951/index.html">Complemento Veeam para copia de seguridad y recuperación de bases de datos SAP HANA</a></li>
<li><a href="../461955/index.html">Intercambiar tokens o cómo fortalecer la cartera de cifrado en 2019</a></li>
<li><a href="../461965/index.html">Aplicación web MVC sin frameworks y servlets</a></li>
<li><a href="../461967/index.html">Antigüedades: grabadora funcional</a></li>
<li><a href="../461971/index.html">El poder de Oracle SQL</a></li>
<li><a href="../461973/index.html">Prueba de manejo Audi e-tron</a></li>
<li><a href="../461975/index.html">Nuestro servicio es peligroso y difícil, o Zyxel ATP500</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>