<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔑 🚬 🔑 Konsol permainan DIY do-it-yourself 🏬 👎🏿 🖋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting ini adalah pengantar untuk konsol video konsol "buatan sendiri" proyek saya yang dibuat dari awal. Saya terinspirasi oleh konsol retro dan sam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konsol permainan DIY do-it-yourself</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444006/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0b1/45a/7c0/0b145a7c0f4c0821cdb77654ef2a8cd3.jpg" alt="gambar"></p><br><p>  Posting ini adalah pengantar untuk konsol video konsol "buatan sendiri" proyek saya yang dibuat dari awal.  Saya terinspirasi oleh konsol retro dan sampel modern, tapi saya punya arsitektur sendiri.  Teman-teman saya terus-menerus mengatakan kepada saya bahwa saya harus berbicara tentang proyek saya, dan tidak melakukan semuanya secara eksklusif "untuk diri saya", jadi di sini saya menerbitkan posting ini. </p><a name="habracut"></a><br><p>  <strong>Perhatian, ini adalah terjemahan</strong> </p><br><h1 id="kak-vsyo-nachalos">  Bagaimana semuanya dimulai </h1><br><p>  Nama saya Sergio Vieira, saya dibesarkan di Portugal pada tahun 80-an dan 90-an, saya memiliki nostalgia panjang untuk game retro, terutama untuk konsol generasi ketiga dan keempat. </p><br><p>  Beberapa tahun yang lalu, saya memutuskan untuk lebih memahami elektronik dan mencoba membuat awalan saya sendiri. </p><br><p>  Secara profesi, saya seorang programmer dan tidak memiliki pengalaman sebagai insinyur elektronik, kecuali untuk (dan tidak boleh dianggap) upgrade independen destkop saya. </p><br><p>  Meskipun saya tidak memiliki pengalaman, saya berkata pada diri sendiri “mengapa tidak?”, Saya membeli beberapa buku, beberapa peralatan elektronik dan mulai belajar berdasarkan perasaan saya tentang apa yang layak dipelajari. </p><br><p>  Saya ingin membuat awalan yang mirip dengan yang menyebabkan saya merasa nostalgia, saya ingin sesuatu antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NES</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Super Nintendo</a> , atau mungkin antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sega Master System</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mega Drive</a> . </p><br><p>  Konsol ini memiliki CPU, chip video asli (mereka tidak disebut GPU saat itu) dan chip audio, kadang-kadang built-in, dan kadang-kadang eksternal. </p><br><p>  Gim-gim tersebut didistribusikan pada kartrid, yang pada umumnya adalah perpanjangan dari besi, kadang-kadang hanya chip ROM, dan kadang-kadang memiliki komponen tambahan. </p><br><p>  Rencana awal adalah membuat awalan dengan karakteristik berikut: </p><br><ul><li>  Tanpa emulasi, permainan dan program harus bekerja pada perangkat keras nyata, tidak harus sama dengan waktu itu, tetapi cukup cepat untuk tugas itu, dan tidak lebih. </li><li>  Dengan CPU retro nyata. </li><li>  Dengan output TV analog. </li><li>  Dengan suara </li><li>  Dengan dukungan pengontrol ganda </li><li>  Menggulir becks dan animasi sprite </li><li>  Dengan fitur untuk mendukung game platform seperti Mario, dan tentu saja segala macam game lainnya. </li><li>  Dengan mengunduh game dan program dari kartu SD. </li></ul><br><p>  Mengapa kartu SD, dan bukan kartrid, well, pada dasarnya itu jauh lebih praktis, Anda dapat menyalinnya dari komputer Anda.  Dan kartrid berarti, pertama, lebih banyak zat besi di kotak set-top, dan kedua, untuk menghasilkan zat besi untuk setiap program. </p><br><h1 id="proizvodstvo">  Produksi </h1><br><h2 id="video-signal">  Sinyal video </h2><br><p>  Hal pertama yang saya lakukan adalah menghasilkan sinyal video. </p><br><p>  Setiap konsol dari periode yang saya ambil sebagai sampel memiliki berbagai chip grafis berpemilik, yang berarti bahwa mereka semua memiliki spesifikasi yang berbeda. <br>  Untuk alasan ini, saya tidak ingin menggunakan chip grafis yang sudah jadi, saya ingin konsol saya memiliki spesifikasi grafis yang unik.  Dan karena saya tidak dapat membuat chip grafis saya sendiri, dan pada saat itu saya masih tidak dapat menggunakan FPGA, saya memutuskan untuk membatasi diri pada generasi yang dihasilkan oleh perangkat lunak dari sinyal grafis menggunakan mikrokontroler 8-bit, 20 megahertz. </p><br><p>  Ini tidak terlalu banyak, dan hanya solusi yang cukup kuat untuk grafik tingkat yang saya tertarik. </p><br><p>  Jadi, saya mulai menggunakan mikrokontroler Atmega644 pada kemurnian 20 MHz untuk menghasilkan sinyal video <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PAL</a> untuk TV.  Saya harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bit-beat</a> protokol PAL karena chip itu sendiri tidak tahu bagaimana cara melakukannya. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/8ee/74d/d7b8ee74dbd4c844e65f2a1766e33a0a.jpg" alt="imageVPU Test 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/96b/d85/e5c/96bd85e5c323152604a68bb3c8341f69.jpg" alt="imageVPU Test 2"></p><br><p>  Mikrokontroler menghasilkan warna 8-bit (RGB332, 3 bit merah, 3 bit hijau dan 2 biru) dan DAC pasif mengubah semuanya menjadi RGB.  Untungnya di Portugal, hampir semua TV dilengkapi dengan konektor SCART dan mereka mendukung input RGB. </p><br><h2 id="pravilnaya-graficheskaya-podsistema">  Subsistem grafik yang benar </h2><br><p>  Karena mikrokontroler cukup kuat, dan saya memutuskan untuk menggunakannya secara eksklusif untuk menghasilkan sinyal video (saya menyebutnya VPU - Video Processing Unit), saya memutuskan untuk mengatur buffer ganda pada saat yang sama. </p><br><p>  Ternyata mikrokontroler kedua (PPU, Picture Processing Unit, chip Atmega1284 juga pada 20 MHz) menghasilkan gambar dalam chip RAM 1 (saya menyebutnya VRAM1), dan yang pertama mengirim isi chip kedua (VRAM2) ke TV pada saat yang sama. </p><br><p>  Setelah satu frame, dan dua frame dalam sistem PAL adalah 1/25 detik, VPU mengganti VRAM dan mereka bertukar, PPU menghasilkan gambar dalam VRAM2, dan VPU membuang VRAM1 ke output TV. </p><br><p>  Kartu video ternyata sangat rumit karena saya harus menggunakan perangkat keras eksternal sehingga kedua mikrokontroler dapat menggunakan kedua modul memori dan untuk mempercepat akses ke RAM, karena juga memiliki bit-banging, jadi saya harus menambahkan chip seri 74 sebagai penghitung, pemilih jalur, transceiver, dll. . </p><br><p>  Firmware untuk VPU dan PPU juga ternyata tidak praktis karena saya harus menulis banyak kode untuk mendapatkan kecepatan maksimum dari grafik.  Pada awalnya semuanya ditulis dalam assembler, kemudian sebagian ditulis ulang dalam C. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a2/43d/c87/7a243dc873ceaf16fe0e2d183d388dd1.jpg" alt="imageVideo Board 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a9/c59/cca/2a9c59cca5b2d64f25abdfd2f59912e5.jpg" alt="imageVideo Board 2"></p><br><p>  Akibatnya, PPU menghasilkan gambar 224x192 piksel, yang kemudian dikirim ke TV melalui VPU.  Anda mungkin menemukan resolusi rendah, tetapi sebenarnya hampir sebanyak konsol waktu itu sebenarnya, biasanya 256x224.  Resolusi yang sedikit lebih rendah, tetapi memungkinkan saya untuk menambahkan lebih banyak fitur yang dikelola sistem untuk menghitung dalam satu bingkai. </p><br><p>  Seperti di masa lalu, PPU memiliki mekanik kaku sendiri yang harus Anda dapat gunakan.  Backing (backing) diberikan dari 8x8 karakter piksel, juga disebut ubin.  Ternyata ukuran latar belakang adalah 28x24 ubin. </p><br><p>  Agar backing dapat menggulir dengan lancar, pixel demi pixel, saya melakukannya sehingga ada 4 layar virtual, masing-masing 28x24 ubin yang masuk dalam memori secara berurutan dan dililit satu sama lain, dalam gambar itu lebih jelas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/666/41c/c14/66641cc14e799a0e4269d4b130490465.png" alt="imageBackground"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/500/971/e16/500971e169f1364520eb5004529cca3e.png" alt="imageVirtual Background"></p><br><p>  Di atas latar belakang, PPU dapat membuat 64 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sprite</a> yang dapat 8 atau 16 piksel tinggi atau lebar, yaitu, 1, 2 atau 4 ubin dan juga dapat membalik secara horizontal dan / atau vertikal. </p><br><p>  Di atas bagian belakang, Anda juga dapat membuat overlay dengan ukuran satu buffer 28x6 ubin, ini dimaksudkan untuk merender HUD, skor agar tidak mengganggu sprite utama dan pengguliran bagian belakang. </p><br><p>  Salah satu fitur "lanjutan" adalah bahwa backing dapat digulir tidak sepenuhnya, tetapi setiap baris secara terpisah, yang memungkinkan segala macam efek menarik seperti layar terbagi atau hampir- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paralaks</a> . </p><br><p>  Ada juga tabel atribut yang memungkinkan Anda untuk mengatur setiap ubin ke nilai dari 0 hingga 3, dan kemudian Anda bisa menentukan halaman ubin untuk semua ubin dengan satu atribut atau menambah nilai simbolisnya.  Ini nyaman ketika ada bagian cadangan yang perlu diubah secara teratur dan CPU tidak harus menghitung setiap ubin secara individual, cukup untuk hanya mengatakan sesuatu seperti: "semua ubin dengan atribut 1, menambah nilai numerik karakter Anda sebesar 2", hal-hal seperti itu dapat diimplementasikan dengan teknik yang berbeda amati, misalnya, di ubin petak di Mario di mana tanda tanya dianimasikan atau di permainan di mana ada air terjun di mana semua ubin terus berubah menciptakan efek air jatuh. </p><br><h2 id="cpu">  CPU </h2><br><p>  Ketika kartu video saya berfungsi, saya mulai bekerja dengan CPU sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zilog 80</a> untuk set-top box saya. </p><br><p>  Salah satu alasan mengapa Z80 dipilih, selain fakta bahwa itu adalah CPU retro yang keren, adalah kemampuannya untuk mengatasi dua ruang 16-bit, satu untuk memori dan yang kedua untuk port I / O, tidak kalah legendaris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6502</a> , misalnya, tidak dapat , itu hanya dapat mengatasi ruang 16 bit, dan Anda harus memetakannya ke dalam memori serta berbagai perangkat eksternal, video, audio, joystick, generator nomor acak perangkat keras, dll.  Lebih mudah memiliki dua ruang alamat, satu sepenuhnya diberikan hingga 64 kilobyte kode dan data dalam memori dan yang kedua untuk akses ke perangkat eksternal. </p><br><p>  Pertama, saya menghubungkan CPU ke EEPROM di mana program pengujian saya berada dan juga menghubungkannya melalui ruang I / O ke mikrokontroler yang saya instal sehingga saya bisa berkomunikasi dengan komputer saya melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RS232</a> dan memantau bagaimana CPU dan segala sesuatu bekerja.  Mikrokontroler Atmega324 ini berjalan pada 20 MHz yang saya sebut unit mikrokontroler input / output IO MCU, bertanggung jawab untuk mengontrol akses ke pengendali game (joystick), pembaca kartu SD, keyboard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PS / 2</a> dan komunikator melalui RS232. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0e9/3fa/89a/0e93fa89aa467f7d400b032ba4932c1c.jpg" alt="imageCPU Dewan 1"></p><br><p>  CPU terhubung ke chip memori 128 kilobyte, yang mana hanya 56 kilobyte yang tersedia, ini tentu saja tidak masuk akal, tetapi saya hanya bisa mendapatkan 128 atau 32 kilobyte chip.  Ternyata memori tersebut terdiri dari 8 kilobyte ROM dan 56 kilobyte RAM. </p><br><p>  Setelah itu, saya memperbarui firmware IO MCU menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan ini</a> dan saya mendapat dukungan untuk pembaca kartu SD. </p><br><p>  Sekarang CPU dapat menelusuri direktori, melihat apa yang ada di dalamnya, membuka dan membaca file.  Semua ini dilakukan dengan menulis dan membaca ke alamat tertentu di ruang I / O. </p><br><h2 id="podklyuchenie-cpu-k-ppu">  Hubungkan CPU ke PPU </h2><br><p>  Hal berikutnya yang saya lakukan adalah koneksi antara CPU dan PPU.  Untuk melakukan ini, saya menerapkan "solusi sederhana" yaitu membeli dual-port RAM, ini adalah chip RAM yang dapat dihubungkan langsung ke dua bus yang berbeda.  Ini memungkinkannya untuk menyingkirkan chip tambahan seperti penyeleksi garis dan, lebih lagi, memungkinkan akses hampir simultan ke memori dari kedua chip.  PPU lain dapat langsung mengakses CPU pada setiap frame dengan mengaktifkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">interupsi yang tidak bisa ditutup-tutupi</a> .  Ternyata CPU menerima interupsi pada setiap frame, yang berguna untuk berbagai tugas pengaturan waktu dan untuk memahami kapan saatnya melakukan pembaruan grafik. </p><br><p>  Setiap bingkai interaksi CPU, PPU dan VPU terjadi sesuai dengan skema berikut: </p><br><ol><li>  PPU menyalin informasi dari memori PPU ke memori internal. </li><li>  PPU mengirimkan sinyal interupsi ke CPU. </li><li>  Pada saat yang sama: <br><ul><li>  CPU melompat ke fungsi interupsi dan mulai memperbarui memori PPU dengan kondisi grafis baru.  Program harus kembali dari interupsi hingga blok berikutnya. </li><li>  PPU membuat gambar berdasarkan informasi yang sebelumnya disalin ke salah satu VRAM. </li><li>  VPU mengirimkan gambar dari VRAM lain ke output TV. </li></ul></li></ol><br><p>  Sekitar waktu yang sama, saya mulai mendukung pengontrol permainan, pada awalnya saya ingin menggunakan pengontrol Nintendo, tetapi soket mereka adalah milik dan umumnya sulit ditemukan, jadi saya memilih pengontrol 6 tombol yang kompatibel dengan Mega Drive / Genesis, mereka memiliki soket DB-9 standar yang mana-mana. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9ed/e06/12a/9ede0612a51808d0d5e92c5765e9f4fd.jpg" alt="imageJoint Board 1"></p><br><h2 id="napisanie-pervoy-nastoyaschey-igry">  Menulis game nyata pertama </h2><br><p>  Pada saat ini, saya sudah memiliki CPU yang mampu mengendalikan PPU, bekerja dengan joystick, membaca kartu SD ... sudah waktunya untuk <a href="">menulis game pertama</a> , tentu saja di assembler Z80, saya butuh beberapa hari dari waktu luang. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2Pcrg1fesBk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="dobavlyaem-dinamicheskuyu-grafiku">  Tambahkan grafik dinamis </h2><br><p>  Semuanya super, saya memiliki konsol permainan sendiri, tetapi ini tidak cukup bagi saya, karena dalam permainan saya harus menggunakan grafik yang dijahit dalam memori PPU dan tidak mungkin untuk menggambar ubin untuk permainan tertentu dan itu hanya dapat diubah dengan memencet ROM.  Saya mulai berpikir tentang cara menambahkan lebih banyak memori sehingga CPU dapat memuat karakter untuk ubin ke dalamnya, dan kemudian PPU kemudian bisa membaca semuanya dari sana dan bagaimana melakukannya lebih mudah karena awalannya ternyata rumit dan besar. </p><br><p>  Dan saya datang dengan yang berikut ini: hanya PPU yang akan memiliki akses ke memori baru ini, dan CPU akan memuat data di sana melalui PPU dan saat proses pemuatan ini sedang berlangsung, memori ini tidak dapat digunakan untuk menggambar, tetapi akan dimungkinkan untuk menggambar dari ROM saat ini. </p><br><p>  Setelah selesai memuat, CPU akan mengalihkan memori ROM internal ke memori baru ini, yang saya sebut Character RAM (CHR-RAM) dan dalam mode ini, PPU akan mulai menggambar grafik yang dinamis, ini mungkin bukan solusi terbaik, tetapi ia bekerja.  Akibatnya, memori baru dipasang 128 kilobyte dan dapat menyimpan 1024 karakter masing-masing 8x8 piksel untuk latar belakang dan jumlah karakter yang sama untuk sprite. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ff8/47a/b6b/ff847ab6b2ae65bd21c0426283d2c6a7.jpg" alt="imageJoint Board 2"></p><br><h2 id="i-nakonec-zvuk">  Dan akhirnya suaranya </h2><br><p>  Tangan mencapai suara terakhir.  Pada awalnya, saya ingin suara seperti apa yang ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Uzebox</a> , yaitu, bahwa mikrokontroler menghasilkan 4 saluran suara PWM. </p><br><p>  Namun, ternyata saya dapat dengan mudah mendapatkan chip vintage dan saya memesan beberapa chip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sintesis FM</a> YM3438, orang-orang ini sepenuhnya kompatibel dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YM2612 yang</a> digunakan dalam Mega Drive / Genesis.  Dengan menginstalnya, Anda bisa mendapatkan Mega Drive musik berkualitas dan efek suara yang dihasilkan oleh mikrokontroler. </p><br><p>  Saya menginstal mikrokontroler lain dan menyebutnya SPU (Sound Processor Unit), ia mengontrol YM3438 dan dapat menghasilkan suara sendiri.  CPU mengontrolnya melalui memori dual-port, kali ini hanya 2 kilobyte. </p><br><p>  Seperti pada unit grafik, unit suara memiliki 128 kilobyte memori untuk menyimpan sampel PCM dan patch suara, CPU memuat data ke dalam memori ini dengan mengakses SPU.  Ternyata CPU memberi tahu SPU untuk mengeksekusi perintah dari memori ini atau memperbarui perintah untuk SPU setiap frame. </p><br><p>  CPU mengontrol empat saluran PWM melalui empat buffer melingkar di memori SPU.  SPU memeriksa buffer ini dan mengeksekusi perintah yang ditulis untuk mereka.  Ada juga satu buffer untuk chip sintesis FM. </p><br><p>  Secara total, seperti pada grafik, interaksi antara CPU dan SPU berjalan sesuai dengan skema: </p><br><ol><li>  SPU menyalin data dari SPU ke memori internal. </li><li>  SPU sedang menunggu interupsi dari PPU (ini untuk sinkronisasi) </li><li>  Pada saat bersamaan <br><ul><li>  CPU memperbarui buffer saluran PWM dan buffer synthesizer FM. </li><li>  SPU menjalankan perintah dalam buffer sesuai dengan data dalam memori internal. </li><li>  Seiring dengan semua ini, SPU memperbarui suara PWM pada frekuensi 16 kilohertz. </li></ul></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d83/946/43e/d8394643e24f2c0771493bfbe1081157.jpg" alt="imageSound Board 1"></p><br><h1 id="chto-vyshlo-v-itoge">  Apa yang keluar pada akhirnya </h1><br><p>  Setelah semua blok siap, beberapa pergi ke papan tempat memotong roti. <br>  Untuk blok CPU, saya dapat mengembangkan dan memesan PCB khusus, saya tidak tahu apakah itu layak untuk modul lain, saya pikir saya benar-benar beruntung PCB saya segera berfungsi. </p><br><p>  Di papan tempat memotong roti sekarang (sejauh ini) hanya ada suara. <br>  Begini tampilannya hari ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b1/41e/828/5b141e82873999d9ce5a327d77770133.jpg" alt="imageConsole 1"></p><br><h2 id="arhitektura">  Arsitektur </h2><br><p>  Diagram menggambarkan komponen di setiap blok dan bagaimana mereka berinteraksi satu sama lain.  Satu-satunya hal yang tidak ditampilkan adalah sinyal dari PPU ke CPU pada setiap frame sebagai interupsi dan sinyal yang sama yang masuk ke SPU. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b3a/9d1/4cbb3a9d121465d904518aceaee47045.png" alt="arsitektur arsitektur"></p><br><ul><li>  CPU: Zilog Z80 pada 10 MHz </li><li>  CPU-ROM: 8KB EEPROM, berisi kode bootloader </li><li>  CPU-RAM: 128KB RAM (tersedia 56KB), kode dan data untuk program / game </li><li>  IO MCU: Atmega324, adalah antarmuka antara CPU dan RS232, keyboard PS / 2, joystick dan sistem file kartu SD </li><li>  PPU-RAM: 4 kilobyte dari memori dual-port, memori antara antara CPU dan PPU </li><li>  CHR-RAM: RAM 128KB, menyimpan ubin dinamis untuk mendukung (substrat) dan sprite (dalam karakter 8x8 piksel). </li><li>  VRAM1, VRAM2: 128KB RAM (43008 benar-benar tersedia), mereka digunakan untuk framebuffer, mereka menulis PPU dan membaca VPU dari mereka. </li><li>  PPU (Picture Processing Unit): Atmega1284, menggambar bingkai ke dalam framebuffer. </li><li>  VPU (Video Processing Unit): Atmega324, membaca framebuffer dan menghasilkan sinyal dan sinkronisasi RGB dan PAL. </li><li>  SPU-RAM: RAM dual-port 2KB, berfungsi sebagai antarmuka antara CPU dan SPU. </li><li>  SNDRAM: 128KB RAM, menyimpan patch PWM, sampel PCM, dan blok instruksi untuk synthesizer FM. </li><li>  YM3438: YM3438, chip sintesis FM. </li><li>  SPU (Sound Processing Unit): Atmega644, menghasilkan suara berdasarkan prinsip modulasi lebar pulsa (PWM) dan mengontrol YM3438. </li></ul><br><h2 id="okonchatelnye-specifikacii">  Spesifikasi akhir </h2><br><p>  <strong>CPU:</strong> </p><br><ul><li>  CPU 8-bit Zilog Z80 pada frekuensi 10Mhz. </li><li>  ROM 8KB untuk bootloader. </li><li>  RAM 56KB. </li></ul><br><p>  <strong>IO:</strong> </p><br><ul><li>  Membaca data dari pembaca kartu SD FAT16 / FAT32. </li><li>  Baca / tulis ke port RS232. </li><li>  2 pengendali game yang kompatibel dengan MegaDrive / Genesis. </li><li>  Keyboard PS2. </li></ul><br><p>  <strong>Video:</strong> </p><br><ul><li>  Resolusi 224x192 piksel. </li><li>  25 frame per detik (setengah FPS dari PAL). </li><li>  256 warna (RGB332). </li><li>  Latar belakang virtual 2x2 (448x384 piksel), dengan pengguliran berbasis dua arah piksel, berdasarkan pada empat halaman layar penuh. </li><li>  64 sprite dengan lebar dan tinggi 8 atau 16 piksel dengan kemungkinan flip vertikal dan horizontal. </li><li>  Latar belakang dan sprite masing-masing terdiri dari karakter 8x8 piksel. </li><li>  Memori video simbolik dari 1024 karakter untuk latar belakang dan 1024 untuk sprite. </li><li>  64 bergulir horizontal independen di sepanjang garis yang ditetapkan </li><li>  8 bergulir vertikal independen di sepanjang garis yang ditetapkan </li><li>  Hamparan 224x48 piksel dengan transparansi tombol warna opsional. </li><li>  Tabel Atribut Latar Belakang. </li><li>  RGB dan PAL komposit melalui konektor SCART. </li></ul><br><p>  <strong>Suara:</strong> </p><br><ul><li>  PWM untuk 8 bit dan 4 saluran, dengan bentuk gelombang bawaan: persegi, sinus, gergaji, derau, dll. </li><li>  Sampel 8-bit, 8 kHz di salah satu saluran PWM. </li><li>  Chip sintesis FM YM3438 sarat dengan instruksi pada frekuensi 50 hertz. </li></ul><br><h1 id="razrabotka-dlya-pristavki">  Pengembangan untuk konsol </h1><br><p>  Bootloader ditulis untuk konsol.  Bootloader ditempatkan di ROM CPU dan dapat memakan waktu hingga 8 kilobyte.  Ini menggunakan 256 byte RAM pertama.  Loader adalah hal pertama yang dijalankan CPU.  Diperlukan untuk menunjukkan program-program yang terletak pada kartu SD. </p><br><p>  Program-program ini dalam file yang berisi kode yang dikompilasi dan mungkin juga mengandung gambar dan suara. </p><br><p>  Setelah memilih program, itu dimuat ke dalam memori CPU, memori CHR dan memori SPU.  Setelah itu kode program dijalankan.  Ukuran maksimum kode yang dimuat ke konsol adalah 56 kilobyte, selain 256 byte pertama, dan tentu saja Anda perlu memperhitungkan ruang untuk tumpukan dan data. <br>  Dan bootloader ini dan program lain yang ditulis untuk konsol ini dibuat dengan cara yang sama seperti yang dijelaskan di bawah ini. </p><br><h2 id="memoryio-mapping">  Pemetaan Memori / IO </h2><br><p>  Yang penting ketika mengembangkan awalan ini adalah memperhitungkan bagaimana CPU mengakses berbagai blok dan mengalokasikan ruang alamat dengan benar untuk input input dan ruang alamat memori. </p><br><p>  CPU mengakses memori akses acak bootloader melalui ruang alamat memori. </p><br><p>  Ruang alamat memori <br><img src="https://habrastorage.org/getpro/habr/post_images/f37/a98/86a/f37a9886acd53a6204b02a3f11b190b6.png" alt="imageMemory Mapping"></p><br><p>  Dan ke PPU-RAM, SPU-RAM dan IO MCU melalui ruang alamat I / O. </p><br><p>  Ruang alamat I / O <br><img src="https://habrastorage.org/getpro/habr/post_images/799/634/0c0/7996340c05682ff9eb4d060e6cc361c1.png" alt="pemetaan imageIO"></p><br><p>  Seperti yang dapat Anda lihat dari tabel, alamat untuk semua perangkat, IO MCU, PPU dan SPU dialokasikan di dalam ruang alamat I / O. </p><br><h2 id="upravlenie-ppu">  Manajemen PPU </h2><br><p>  Dari informasi dalam tabel dapat dilihat bahwa untuk kontrol PPU perlu menulis ke memori PPU yang tersedia di alamat 1000h-1FFFh di ruang alamat I / O. </p><br><p>  Alokasi ruang alamat PPU </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/304/1ca/ab33041ca0ac1a8d427cae75dcb736ff.png" alt="imagePPU Pemetaan"></p><br><p>  Status PPU dapat mengambil nilai-nilai berikut: </p><br><ol><li>  Mode Grafik Tertanam </li><li>  Mode Grafik Dinamis (CHR-RAM) </li><li>  Mode perekaman dalam memori CHR </li><li>  Rekaman selesai, menunggu konfirmasi mode dari CPU </li></ol><br><p>  Di sini, misalnya, bagaimana Anda dapat bekerja dengan sprite: <br>  Awalan dapat menggambar 64 sprite sekaligus.      CPU    -   1004h-1143h (320 ),     5   (5 * 64 = 320): </p><br><ol><li>   ,     : Active, Flipped_X, Flipped_Y, PageBit0, PageBit1, AboveOverlay, Width16, Height16. </li><li>  ,     (  ). </li><li>    (    — ) </li><li>   X </li><li>   Y </li></ol><br><p> ,   ,    Active  1,    X  Y   ,  32/32       ,        . </p><br><p>         . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Misalnya, jika kita perlu menunjukkan angka sprite 10, maka alamatnya adalah 4145 (1004h + (5 x 9)), tulis nilai 1 untuk aktivasi dan koordinat, misalnya, x = 100 dan y = 120, tulis nilai 100 di alamat 4148 dan alamat 4149 nilai 120. </font></font></p><br><h2 id="ispolzuem-assembler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan assembler </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salah satu metode pemrograman untuk konsol adalah assembler. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut adalah contoh cara menunjukkan satu sprite dan menghidupkannya sehingga bergerak dan mendorong tepi layar. </font></font></p><br><pre><code class="plaintext hljs">ORG 2100h PPU_SPRITES: EQU $1004 SPRITE_CHR: EQU 72 SPRITE_COLORKEY: EQU $1F SPRITE_INIT_POS_X: EQU 140 SPRITE_INIT_POS_Y: EQU 124 jp main DS $2166-$ nmi: ;    (NMI) ld bc, PPU_SPRITES + 3 ld a, (sprite_dir) and a, 1 jr z, subX in a, (c) ;  X inc a out (c), a cp 248 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a jp updateY subX: in a, (c) ;  X dec a out (c), a cp 32 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a updateY: inc bc ld a, (sprite_dir) and a, 2 jr z, subY in a, (c) ;  Y inc a out (c), a cp 216 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a jp moveEnd subY: in a, (c) ;  Y dec a out (c), a cp 32 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a moveEnd: ret main: ld bc, PPU_SPRITES ld a, 1 out (c), a ;   0 inc bc ld a, SPRITE_CHR out (c), a ;    0 inc bc ld a, SPRITE_COLORKEY out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_X out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_Y out (c), a ;   Y  0 mainLoop: jp mainLoop sprite_dir: DB 0</code> </pre> <br><p>  <strong><em>Menggunakan bahasa C.</em></strong> </p><br><p>  Anda juga dapat menggunakan bahasa C, untuk ini kita memerlukan kompiler SDCC dan beberapa utilitas tambahan. </p><br><p>  Kode C mungkin lebih lambat, tetapi menulisnya lebih cepat dan lebih mudah. </p><br><p>  Berikut adalah contoh kode yang melakukan hal yang sama dengan kode assembler di atas, ia menggunakan pustaka yang membantu membuat panggilan ke PPU: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;console.h&gt; #define SPRITE_CHR 72 #define SPRITE_COLORKEY 0x1F #define SPRITE_INIT_POS_X 140 #define SPRITE_INIT_POS_Y 124 struct s_sprite sprite = { 1, SPRITE_CHR, SPRITE_COLORKEY, SPRITE_INIT_POS_X, SPRITE_INIT_POS_Y }; uint8_t sprite_dir = 0; void nmi() { if (sprite_dir &amp; 1) { sprite.x++; if (sprite.x == 248) { sprite_dir ^= 1; } } else { sprite.x--; if (sprite.x == 32) { sprite_dir ^= 1; } } if (sprite_dir &amp; 2) { sprite.y++; if (sprite.y == 216) { sprite_dir ^= 2; } } else { sprite.y--; if (sprite.x == 32) { sprite_dir ^= 2; } } set_sprite(0, sprite); } void main() { while(1) { } }</span></span></span></span></code> </pre> <br><h2 id="dinamicheskaya-grafika">  Grafik dinamis </h2><br><p>  (Dalam grafis khusus asli. Perkiraan. Per.) </p><br><p>  Dalam ROM awalan, 1 halaman ubin untuk pencadangan dan halaman lain dari sprite siap pakai dijahit), secara default Anda hanya dapat menggunakan grafik ini, tetapi Anda dapat beralih ke dinamis. </p><br><p>  Tujuan saya adalah agar semua grafik yang diperlukan dalam bentuk biner segera dimuat ke dalam CHR RAM, dan kode dalam bootloader dari ROM dapat melakukan ini.  Untuk melakukan ini, saya membuat beberapa gambar dengan ukuran yang benar dengan berbagai simbol bermanfaat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ed7/636/39c/ed763639cda1cf8ba163c3c30d2f0ec7.png" alt="komponen ubin imageSample"></p><br><p>  Karena memori grafis dinamis terdiri dari 4 halaman dengan 256 karakter masing-masing 8x8 piksel dan 4 halaman karakter yang sama untuk sprite, saya mengonversi gambar ke format PNG, menghapus duplikat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/052/39d/5e9/05239d5e93c3578b8b720eedbc1c9169.png" alt="lembar karakter sampleSample"></p><br><p>  Dan kemudian dia menggunakan alat yang ditulis sendiri untuk menerjemahkan semuanya ke dalam format RGB332 biner dengan blok 8x8. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a4c/8e7/4c6/a4c8e74c68c44e8f0f122002ebb021da.png" alt="baris perintah imageGraphics"></p><br><p>  Sebagai hasilnya, kami memiliki file dengan karakter, di mana semua karakter berjalan berurutan dan masing-masing membutuhkan 64 byte. </p><br><h2 id="zvuk">  Suara </h2><br><p>  Sampel Wave RAW dikonversi menjadi sampel PCM 8-bit 8-kilohertz. </p><br><p>  Tambalan untuk efek suara pada PWM dan musik ditulis dengan instruksi khusus. </p><br><p>  Sedangkan untuk chip sintesis Yamaha YM3438 FM, saya menemukan sebuah program yang disebut DefleMask yang menghasilkan musik PAL-disinkronkan untuk chip Genesis YM2612, yang kompatibel dengan YM3438. </p><br><p>  DefleMask mengekspor musik dalam format VGM dan saya mengonversinya dengan utilitas milik lain ke dalam format biner saya sendiri. </p><br><p>  Semua binari dari ketiga jenis suara digabungkan menjadi satu file biner, yang dapat dibaca oleh bootloader saya dan dimuat ke dalam memori suara RAM SDN. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aee/fb5/fd5/aeefb5fd5918b0653557889b2b00972a.png" alt="baris perintah imageSound"></p><br><h2 id="linkovka-okonchatelnogo-fayla">  Tautan ke file final </h2><br><p>  Kode biner yang dapat dieksekusi, grafik dan suara digabungkan menjadi satu file PRG.  File PRG memiliki header di mana semuanya dijelaskan apakah ada data audio dan grafik, berapa banyak yang mereka tempati dan data itu sendiri. </p><br><p>  File seperti itu dapat ditulis ke kartu SD, dan bootloader konsol mempertimbangkannya dan mengunduh semuanya ke tempat yang sesuai dan meluncurkan kode yang dapat dieksekusi program. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/465/33e/43c/46533e43c8bca14c9cf9c36247b154eb.png" alt="baris perintah imagePRG"></p><br><h2 id="emulyator">  Emulator </h2><br><p>  Saya menulis emulator konsol saya di C ++ menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wxWidgets</a> untuk membuatnya lebih mudah dikembangkan untuk itu. </p><br><p>  CPU ditiru oleh perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libz80</a> . </p><br><p>  Fitur telah ditambahkan ke emulator untuk debugging, saya dapat menghentikannya kapan saja dan melakukan debugging perakitan langkah demi langkah, ada pemetaan ke kode sumber dalam C. jika bahasa ini digunakan untuk permainan. </p><br><p>  Menurut grafik, saya dapat melihat ke dalam memori video, dalam tabel simbol dan dalam memori CHR itu sendiri. </p><br><p>  Berikut adalah contoh program yang berjalan pada emulator dengan alat debugging dihidupkan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/090/b54/70d/090b5470d7476d47c7212452716e9d11.gif" alt="Demo imageEmulator"></p><br><h1 id="demka-programmirovaniya">  Demo pemrograman </h1><br><p>  Video-video ini diambil dengan kamera smartphone yang ditujukan untuk layar CRT TV, saya minta maaf atas kualitas gambar yang tidak sempurna. </p><br><p>  Interpreter BASIC yang dapat diprogram dari keyboard PS / 2, setelah program pertama, saya menunjukkan cara menulis langsung ke memori PPU melalui ruang alamat I / O dengan mengaktifkan dan memindahkan sprite: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2UNjKx4uZGY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Demo gambar, dalam video ini secara program mengunduh 64 16x16 sprite, dengan latar belakang latar belakang dengan pengguliran dinamis dan overlay yang bergerak di bawah dan di atas sprite: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OA0q3_Krgxc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Demo suara menunjukkan kemampuan suara YM3438 dan PWM, data suara dari demo ini dan musik FM dan suara PWM bersama-sama menempati hampir semua memori suara 128 kilobyte yang tersedia. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xDsTGmqxLzM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tetris, hampir secara eksklusif fitur latar belakang, musik pada YM3438, efek suara pada patch PWM digunakan untuk grafik. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E77XZUwKd54" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Proyek ini benar-benar mimpi yang menjadi kenyataan, saya telah mengerjakannya selama beberapa tahun, dengan gangguan, melihat waktu luang saya, saya tidak pernah berpikir bahwa saya akan sejauh ini dalam menciptakan konsol video game retro saya sendiri.  Tentu saja, itu tidak sempurna, saya jelas bukan ahli dalam bidang elektronik, jelas ada terlalu banyak elemen dalam set-top box, dan tidak diragukan lagi seseorang dapat melakukan lebih baik dan mungkin beberapa pembaca hanya memikirkannya. </p><br><p>  Namun tetap saja, dalam proses mengerjakan proyek ini, saya belajar banyak tentang elektronik, konsol game dan desain komputer, bahasa assembly dan hal-hal menarik lainnya, dan yang paling penting saya menerima kepuasan besar dengan bermain game yang saya sendiri tulis pada perangkat keras yang saya kembangkan sendiri dan dikumpulkan. </p><br><p>  Saya punya rencana membuat konsol / komputer dan banyak lagi.  Sebenarnya, saya sudah membuat set-top box baru, hampir siap, dan itu adalah retro set-top box yang disederhanakan berdasarkan papan FPGA dan beberapa komponen tambahan (dalam jumlah yang jauh lebih kecil daripada dalam proyek ini, tentu saja), idenya adalah menjadi jauh lebih murah dan lebih berulang. </p><br><p>  Walaupun saya menulis banyak tentang proyek ini di sini, tidak diragukan lagi banyak yang bisa dibahas, saya hampir tidak menyebutkan bagaimana mesin suara bekerja, bagaimana CPU berinteraksi dengannya, dan ada banyak lagi yang dapat dilakukan tentang sistem grafis dan I / O lainnya serta seluruh konsol akan memberitahu. </p><br><p>  Melihat reaksi para pembaca, saya dapat menulis lebih banyak artikel yang berfokus pada pembaruan, rincian tentang blok awalan individu atau proyek lainnya. </p><br><h2 id="proekty-sayty-kanaly-youtube-kotorye-vdohnovlyali-menya-i-pomogali-mne-s-tehnicheskimi-znaniyami">  Proyek, situs, saluran Youtube yang menginspirasi saya dan membantu saya dengan pengetahuan teknis: </h2><br><p>  Situs / saluran ini tidak hanya menginspirasi, tetapi juga membantu saya menemukan solusi untuk masalah kompleks yang muncul selama pengerjaan proyek ini. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Uzebox</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ben ryves</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Retroleum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Z80.info</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EEVBlog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mekanik game retro</a> </li></ul><br><p>  Terima kasih sudah membaca sampai sini.  :) </p><br><p>  Jika Anda memiliki pertanyaan atau umpan balik, silakan tulis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar di bawah ini</a> (Artikel asli dalam bahasa Inggris di Github. Approx. Per.) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444006/">https://habr.com/ru/post/id444006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443996/index.html">Mengumumkan TypeScript 3.4 RC</a></li>
<li><a href="../id443998/index.html">Rekor dunia baru untuk menghitung jumlah pi: 31,4 triliun karakter</a></li>
<li><a href="../id444000/index.html">Mulai dari mana saat mempekerjakan staf untuk pertama kalinya</a></li>
<li><a href="../id444002/index.html">Asisten suara "netral-jender" pertama di dunia disajikan di SXSW IT Festival</a></li>
<li><a href="../id444004/index.html">CLRium # 5: All-All-All tentang GC dan banyak lagi. Peter dan Moskow</a></li>
<li><a href="../id444010/index.html">Gambar .NET Core Container sekarang Diterbitkan ke Microsoft Container Registry</a></li>
<li><a href="../id444014/index.html">Microsoft Membuka Sekolah Bisnis untuk Mempelajari Strategi, Budaya, dan Tanggung Jawab AI</a></li>
<li><a href="../id444016/index.html">Raih lebih banyak dengan Microsoft Game Stack</a></li>
<li><a href="../id444018/index.html">Bagaimana Satu Perubahan Konfigurasi PostgreSQL Meningkatkan Performa Permintaan Lambat 50 Kali</a></li>
<li><a href="../id444020/index.html">Karting di Uni Soviet: bagaimana hobi pilot Amerika menjadi hobi DIY besar-besaran di Uni Soviet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>