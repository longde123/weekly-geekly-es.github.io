<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèΩ ü§úüèª üëçüèº Gu√≠a de ensamblador X86 para principiantes üàÅ üòÜ üöØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy en d√≠a, rara vez es necesario escribir en ensamblador puro, pero definitivamente lo recomiendo a cualquier persona interesada en la programaci√≥n. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de ensamblador X86 para principiantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423077/"> Hoy en d√≠a, rara vez es necesario escribir en ensamblador puro, pero definitivamente lo recomiendo a cualquier persona interesada en la programaci√≥n.  Ver√° las cosas desde un √°ngulo diferente, y las habilidades ser√°n √∫tiles al depurar c√≥digo en otros idiomas. <br><br>  En este art√≠culo, escribiremos desde cero la calculadora de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notaci√≥n polaca inversa (RPN)</a> en ensamblador puro x86.  Cuando hayamos terminado, podemos usarlo as√≠: <br><br><pre><code class="bash hljs">$ ./calc <span class="hljs-string"><span class="hljs-string">"32+6*"</span></span> <span class="hljs-comment"><span class="hljs-comment"># "(3+2)*6"    30</span></span></code> </pre> <br>  Todo el c√≥digo para el art√≠culo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Est√° muy comentado y puede servir como material educativo para aquellos que ya conocen al ensamblador. <br><br>  ¬°Comencemos escribiendo el programa b√°sico <i>Hello world!</i>  para verificar la configuraci√≥n del entorno.  Luego pasemos a las llamadas del sistema, la pila de llamadas, los marcos de la pila y la convenci√≥n de llamadas x86.  Luego, para practicar, escribiremos algunas funciones b√°sicas en el ensamblador x86 y comenzaremos a escribir una calculadora RPN. <br><a name="habracut"></a><br>  Se supone que el lector tiene cierta experiencia en programaci√≥n en C y conocimientos b√°sicos de arquitectura inform√°tica (por ejemplo, qu√© es un registro de procesador).  Como usaremos Linux, tambi√©n deber√≠as poder usar la l√≠nea de comandos de Linux. <br><br><h1>  Entorno </h1><br>  Como ya se mencion√≥, usamos Linux (64 bits o 32 bits).  El c√≥digo anterior no funciona en Windows o Mac OS X. <br><br>  Para la instalaci√≥n, solo necesita el enlazador GNU <code>ld</code> de <code>binutils</code> , que est√° preinstalado en la mayor√≠a de las distribuciones, y el ensamblador NASM.  En Ubuntu y Debian, puede instalar ambos con un solo comando: <br><br><pre> <code class="bash hljs">$ sudo apt-get install binutils nasm</code> </pre> <br>  Tambi√©n recomendar√≠a tener a mano <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una tabla ASCII</a> . <br><br><h1>  Hola mundo </h1><br>  Para verificar el entorno, guarde el siguiente c√≥digo en el archivo <code>calc.asm</code> : <br><br><pre> <code class="hljs 1c">;   <span class="hljs-built_in"><span class="hljs-built_in"></span></span> _start     ; . global _start ;   .rodata  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> ( <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ) ;   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ,       section .rodata ;     hello_world.   NASM ;   ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  , ;  . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    hello_world: db <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 ;   .text,     section .text _start: mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>   eax (<span class="hljs-number"><span class="hljs-number">0</span></span>x04 = write()) mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span>x1 ;   (<span class="hljs-number"><span class="hljs-number">1</span></span> =  , <span class="hljs-number"><span class="hljs-number">2</span></span> =  ) mov ecx, hello_world ;     mov edx, <span class="hljs-number"><span class="hljs-number">14</span></span> ;   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>  <span class="hljs-number"><span class="hljs-number">0</span></span>x80,   ;     mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x01 ; <span class="hljs-number"><span class="hljs-number">0</span></span>x01 = exit() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80</code> </pre> <br>  Los comentarios explican la estructura general.  Para obtener una lista de registros e instrucciones generales, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a del ensamblador x86 de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Universidad de Virginia</a> .  Con m√°s discusi√≥n sobre las llamadas al sistema, esto ser√° a√∫n m√°s necesario. <br><br>  Los siguientes comandos recopilan el archivo ensamblador en un archivo objeto y luego compilan el archivo ejecutable: <br><br><pre> <code class="bash hljs">$ nasm -f elf_i386 calc.asm -o calc $ ld -m elf_i386 calc.o -o calc</code> </pre> <br>  Despu√©s de comenzar, deber√≠a ver: <br><br><pre> <code class="bash hljs">$ ./calc Hello world!</code> </pre> <br><h3>  Makefile </h3><br>  Esta es una parte opcional, pero puede hacer un <code>Makefile</code> para simplificar la compilaci√≥n y el dise√±o en el futuro.  <code>calc.asm</code> en el mismo directorio que <code>calc.asm</code> : <br><br><pre> <code class="hljs powershell">CFLAGS= <span class="hljs-operator"><span class="hljs-operator">-f</span></span> elf32 LFLAGS= <span class="hljs-literal"><span class="hljs-literal">-m</span></span> elf_i386 all: calc calc: calc.o ld <span class="hljs-variable"><span class="hljs-variable">$</span></span>(LFLAGS) calc.o <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc calc.o: calc.asm nasm <span class="hljs-variable"><span class="hljs-variable">$</span></span>(CFLAGS) calc.asm <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc.o clean: rm <span class="hljs-operator"><span class="hljs-operator">-f</span></span> calc.o calc .INTERMEDIATE: calc.o</code> </pre> <br>  Luego, en lugar de las instrucciones anteriores, simplemente ejecute make. <br><br><h1>  Sistema de llamadas </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las llamadas al sistema Linux le</a> dicen al sistema operativo que haga algo por nosotros.  En este art√≠culo, usamos solo dos llamadas al sistema: <code>write()</code> para escribir una l√≠nea en un archivo o secuencia (en nuestro caso, este es un dispositivo de salida est√°ndar y un error est√°ndar) y <code>exit()</code> para salir del programa: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error_code) error_code -  <span class="hljs-number"><span class="hljs-number">0</span></span>         (  <span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd, char *string, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>) fd ‚Äî  <span class="hljs-number"><span class="hljs-number">1</span></span>   , <span class="hljs-number"><span class="hljs-number">2</span></span>      string ‚Äî      <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> ‚Äî    </code> </pre> <br>  Las llamadas al sistema se configuran almacenando el n√∫mero de llamada del sistema en el registro <code>eax</code> , y luego sus argumentos en <code>ebx</code> , <code>ecx</code> , <code>edx</code> en ese orden.  Puede notar que <code>exit()</code> solo <code>exit()</code> un argumento, en este caso ecx y edx no importan. <br><br><table><tbody><tr><th>  Eax </th><th>  ebx </th><th>  ecx </th><th>  edx </th></tr><tr><td align="center">  N√∫mero de llamada del sistema </td><td align="center">  arg1 </td><td align="center">  arg2 </td><td align="center">  arg3 </td></tr></tbody></table><br><br><h1>  Pila de llamadas </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/2b0/574/ea2/2b0574ea20054a1e428d6f0518a80388.png"><br><br>  Una pila de llamadas es una estructura de datos que almacena informaci√≥n sobre cada llamada a una funci√≥n.  Cada llamada tiene su propia secci√≥n en la pila: el "marco".  Almacena cierta informaci√≥n sobre la llamada actual: las variables locales de esta funci√≥n y la direcci√≥n de retorno (donde debe ir el programa despu√©s de ejecutar la funci√≥n). <br><br>  Inmediatamente noto una cosa no obvia: la pila pierde memoria.  Cuando agrega algo a la parte superior de la pila, se inserta en una direcci√≥n de memoria inferior al elemento anterior.  En otras palabras, a medida que la pila crece, la direcci√≥n de memoria en la parte superior de la pila disminuye.  Para evitar confusiones, siempre te recordar√© este hecho. <br><br>  La instrucci√≥n <code>push</code> algo en la parte superior de la pila, y <code>pop</code> muestra los datos desde all√≠.  Por ejemplo, <code>push </code> asigna un lugar en la parte superior de la pila y coloca el valor del registro <code>eax</code> all√≠, y <code>pop </code> transfiere cualquier dato desde la parte superior de la pila a <code>eax</code> y libera esta √°rea de memoria. <br><br>  El prop√≥sito del registro <code>esp</code> es apuntar a la parte superior de la pila.  Se considera que cualquier dato por encima de <code>esp</code> no llega a la pila, estos son datos basura.  La ejecuci√≥n de una declaraci√≥n <code>push</code> (o <code>pop</code> ) mueve <code>esp</code> .  Puede manipular <code>esp</code> directamente, si presenta un informe de sus acciones. <br><br>  El registro <code>ebp</code> es similar a <code>esp</code> , solo que siempre apunta aproximadamente al centro del marco de la pila actual, inmediatamente antes de las variables locales de la funci√≥n actual (hablaremos de esto m√°s adelante).  Sin embargo, llamar a otra funci√≥n no mueve <code>ebp</code> autom√°ticamente, debe hacerse manualmente cada vez. <br><br><h1>  Convenci√≥n de llamada de arquitectura X86 </h1><br>  En x86, no hay un concepto incorporado de funci√≥n como en los lenguajes de alto nivel.  La <code>goto</code> <code>call</code> <code>goto</code> b√°sicamente solo <code>jmp</code> ( <code>goto</code> ) a otra direcci√≥n de memoria.  Para usar rutinas como funciones en otros lenguajes (que pueden tomar argumentos y devolver datos), debe seguir la convenci√≥n de llamada (hay muchas convenciones, pero usamos CDECL, la convenci√≥n m√°s popular para x86 entre los compiladores C y los programadores de ensamblador).  Tambi√©n asegura que los registros de rutina no se confundan al llamar a otra funci√≥n. <br><br><h3>  Reglas de llamadas </h3><br>  Antes de llamar a la funci√≥n, la persona que llama debe: <br><br><ol><li>  Guarde los registros que la persona que llama debe guardar en la pila.  La funci√≥n llamada puede cambiar algunos registros: para no perder datos, la persona que llama debe guardarlos en la memoria hasta que se coloque en la pila.  Estos son los <code>edx</code> <code>eax</code> , <code>ecx</code> y <code>edx</code> .  Si no utiliza ninguno de ellos, no podr√° guardarlos. </li><li>  Escriba argumentos de funci√≥n en la pila en orden inverso (primer √∫ltimo argumento, primer primer argumento al final).  Este orden asegura que la funci√≥n llamada reciba sus argumentos de la pila en el orden correcto. </li><li>  Llama a la subrutina. </li></ol><br>  Si es posible, la funci√≥n guardar√° el resultado en <code>eax</code> .  Inmediatamente despu√©s de la <code>call</code> persona que llama debe: <br><br><ol><li>  Eliminar argumentos de la funci√≥n de la pila.  Esto generalmente se hace simplemente agregando el n√∫mero de bytes a <code>esp</code> .  No olvide que la pila crece, por lo que para eliminarla debe agregar bytes. </li><li>  Restaure los registros guardados sac√°ndolos de la pila en el orden inverso.  La funci√≥n llamada no cambiar√° ning√∫n otro registro. </li></ol><br>  El siguiente ejemplo demuestra c√≥mo se aplican estas reglas.  Suponga que la funci√≥n <code>_subtract</code> toma dos argumentos enteros (4 bytes) y devuelve el primer argumento menos el segundo.  En la subrutina <code>_mysubroutine</code> llame a <code>_subtract</code> con los argumentos <code>10</code> y <code>2</code> : <br><br><pre> <code class="hljs perl">_mysubroutine: ; ... ;  -  ; ... <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;   (    eax) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ;  ,      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> call _subtract ; eax   <span class="hljs-number"><span class="hljs-number">10</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>=<span class="hljs-number"><span class="hljs-number">8</span></span> add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> ;  <span class="hljs-number"><span class="hljs-number">8</span></span>    (   <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;    <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; ... ;  - ,        eax ; ...</code> </pre> <br><h3>  Reglas de la rutina llamada </h3><br>  Antes de llamar, la subrutina debe: <br><br><ol><li>  Guarde el puntero de registro base <code>ebp</code> del fotograma anterior escribi√©ndolo en la pila. </li><li>  Ajuste <code>ebp</code> del cuadro anterior a actual (valor <code>esp</code> actual). </li><li>  Asigne m√°s espacio en la pila para las variables locales, si es necesario, mueva el puntero <code>esp</code> .  A medida que la pila crece, debe restar la memoria faltante de <code>esp</code> . </li><li>  Guarde los registros de la rutina llamada en la pila.  Estos son <code>ebx</code> , <code>edi</code> y <code>esi</code> .  No es necesario guardar registros que no est√°n planeados para ser cambiados. </li></ol><br>  Pila de llamadas despu√©s del paso 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d15/55e/4c4/d1555e4c4d0851f1f8ddec2b527e4877.png"><br><br>  La pila de llamadas despu√©s del paso 2: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/e1a/9bc/2bae1a9bc4aff273c6badbd5ec94d2c8.png"><br><br>  Pila de llamadas despu√©s del paso 4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c4/4bf/a7b/8c44bfa7bfb67546110925a9606e27cd.png"><br><br>  En estos diagramas, se indica una direcci√≥n de retorno en cada marco de pila.  Se env√≠a autom√°ticamente a la pila mediante una declaraci√≥n de <code>call</code> .  La <code>ret</code> recupera la direcci√≥n desde la parte superior de la pila y salta a ella.  No necesitamos esta instrucci√≥n, solo mostr√© por qu√© las variables locales de la funci√≥n est√°n a 4 bytes por encima de <code>ebp</code> , pero los argumentos de la funci√≥n est√°n a 8 bytes por debajo de <code>ebp</code> . <br><br>  En el √∫ltimo diagrama, tambi√©n puede observar que las variables locales de la funci√≥n siempre comienzan 4 bytes por encima de <code>ebp</code> desde la direcci√≥n <code>ebp-4</code> (resta aqu√≠, porque estamos subiendo la pila), y los argumentos de la funci√≥n siempre comienzan 8 bytes por debajo de <code>ebp</code> desde la direcci√≥n <code>ebp+8</code> (adem√°s, porque nos estamos moviendo hacia abajo en la pila).  Si sigue las reglas de esta convenci√≥n, ser√° as√≠ con las variables y argumentos de cualquier funci√≥n. <br><br>  Cuando la funci√≥n est√° completa y desea regresar, primero debe establecer <code>eax</code> en el valor de retorno de la funci√≥n, si es necesario.  Adem√°s, necesitas: <br><br><ol><li>  Restaura los registros guardados sac√°ndolos de la pila en orden inverso. </li><li>  Libere espacio en la pila asignada por la variable local en el paso 3, si es necesario: simplemente instalando <code>esp</code> en ebp </li><li>  Restaure el puntero base <code>ebp</code> del fotograma anterior <code>ebp</code> de la pila. </li><li>  Regresar con <code>ret</code> </li></ol><br>  Ahora implementamos la funci√≥n <code>_subtract</code> de nuestro ejemplo: <br><br><pre> <code class="hljs perl">_subtract: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp ;      mov ebp, esp ;  ebp ;          ,      ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>   ;  ;   , eax     ;     ,     ;       ,       <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp ;      ret</code> </pre> <br><h3>  Entrada y salida </h3><br>  En el ejemplo anterior, puede observar que la funci√≥n siempre se ejecuta de la misma manera: <code>push ebp</code> , <code>mov ebp</code> , <code>esp</code> y asignaci√≥n de memoria para variables locales.  El conjunto x86 tiene una instrucci√≥n conveniente que hace todo esto: <code>enter ab</code> , donde <code>a</code> es el n√∫mero de bytes que desea asignar para las variables locales, <code>b</code> es el "nivel de anidaci√≥n", que siempre estableceremos en <code>0</code> .  Adem√°s, la funci√≥n siempre termina con las instrucciones <code>pop ebp</code> y <code>mov esp</code> , <code>ebp</code> (aunque solo son necesarias cuando se <code>ebp</code> memoria para variables locales, pero en cualquier caso no da√±an).  Esto tambi√©n se puede reemplazar con una sola declaraci√≥n: <code>leave</code> .  Hacemos cambios: <br><br><pre> <code class="hljs perl">_subtract: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>  ;   ;   , eax     ;     ,     leave ;      ret</code> </pre> <br><h1>  Escribir algunas funciones b√°sicas </h1><br>  Una vez que domine la convenci√≥n de llamadas, puede comenzar a escribir algunas rutinas.  ¬øPor qu√© no generalizar el c√≥digo que muestra "Hola mundo!" Para generar l√≠neas: la funci√≥n <code>_print_msg</code> . <br><br>  Aqu√≠ necesitamos otra funci√≥n <code>_strlen</code> para contar la longitud de la cadena.  En C, podr√≠a verse as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*s != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   length++; s++; } //   return length; }</span></span></code> </pre> <br>  En otras palabras, desde el comienzo de la l√≠nea, agregamos 1 al valor de retorno para cada car√°cter excepto cero.  Tan pronto como se observe el car√°cter nulo, devolveremos el valor acumulado en el bucle.  En el ensamblador, esto tambi√©n es bastante simple: puede usar la funci√≥n <code>_subtract</code> previamente escrita como base: <br><br><pre> <code class="hljs 1c">_strlen: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;   ;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, 0 ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function"> = 0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+8] ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">   ;  </span></span></span></span>)   ecx (   ; ,      ) _strlen_loop_start: ;  ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span> cmp byte [ecx], <span class="hljs-number"><span class="hljs-number">0</span></span> ;       . <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>  (<span class="hljs-number"><span class="hljs-number">4</span></span> ). ;    .    ;     ( <span class="hljs-built_in"><span class="hljs-built_in"></span></span>) je _strlen_loop_end ;  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>     inc eax ;    ,  <span class="hljs-number"><span class="hljs-number">1</span></span>    add ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;       jmp _strlen_loop_start ;      _strlen_loop_end: ;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br>  Ya no est√° mal, ¬øverdad?  Escribir c√≥digo C primero puede ayudar, porque la mayor parte se convierte directamente en ensamblador.  Ahora puede usar esta funci√≥n en <code>_print_msg</code> , donde aplicamos todos los conocimientos adquiridos: <br><br><pre> <code class="hljs perl">_print_msg: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    mov eax, <span class="hljs-number"><span class="hljs-number">0x04</span></span> ; <span class="hljs-number"><span class="hljs-number">0x04</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0x1</span></span> ; <span class="hljs-number"><span class="hljs-number">0x1</span></span> =   mov ecx, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;       , ;   edx   .    _strlen <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;     (    edx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> dword [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   _strlen  _print_msg.  NASM ; ,    ,  , . ;      dword (<span class="hljs-number"><span class="hljs-number">4</span></span> , <span class="hljs-number"><span class="hljs-number">32</span></span> ) call _strlen ; eax     mov edx, eax ;     edx,     add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ;  <span class="hljs-number"><span class="hljs-number">4</span></span>    ( <span class="hljs-number"><span class="hljs-number">4</span></span>-  char*) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;     <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;      _strlen,     <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> leave ret</code> </pre> <br>  Y vea los frutos de nuestro arduo trabajo, utilizando esta funci√≥n en el programa completo "¬°Hola, mundo!". <br><br><pre> <code class="hljs pgsql">_start: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     (    ) push hello_world ;    _print_msg <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  ¬°Lo creas o no, hemos cubierto todos los temas principales necesarios para escribir programas b√°sicos de ensamblador x86!  Ahora tenemos todo el material introductorio y la teor√≠a, por lo que nos concentraremos completamente en el c√≥digo y aplicaremos los conocimientos adquiridos para escribir nuestra calculadora RPN.  Las funciones ser√°n mucho m√°s largas e incluso utilizar√°n algunas variables locales.  Si desea ver de inmediato el programa terminado, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ est√°</a> . <br><br>  Para aquellos de ustedes que no est√°n familiarizados con la notaci√≥n polaca inversa (a veces llamada notaci√≥n polaca inversa o notaci√≥n postfix), aqu√≠ las expresiones se eval√∫an utilizando la pila.  Por lo tanto, debe crear una pila, as√≠ como las <code>_push</code> <code>_pop</code> y <code>_push</code> para manipular esta pila.  Tambi√©n <code>_print_answer</code> funci√≥n <code>_print_answer</code> , que generar√° una representaci√≥n de cadena del resultado num√©rico al final del c√°lculo. <br><br><h1>  Creaci√≥n de pila </h1><br>  Primero, definimos el espacio en memoria para nuestra pila, as√≠ como la variable global <code>stack_size</code> .  Es aconsejable cambiar estas variables para que no entren en la secci√≥n <code>.rodata</code> , sino en <code>.data</code> . <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">section</span></span> .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> stack_size: dd 0 ;   dword (4 )   0 stack: times 256 dd 0 ;   </span></span></code> </pre> <br>  Ahora puede implementar las <code>_pop</code> <code>_push</code> y <code>_pop</code> : <br><br><pre> <code class="hljs powershell">_push: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    push eax push edx mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov edx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>], edx ;    .   ;       dword inc dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;  <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size ;     pop edx pop eax leave ret _pop: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     dec dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov eax, [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>] ;       eax ;     ,     leave ret</code> </pre> <br><h1>  Salida de n√∫mero </h1><br>  <code>_print_answer</code> mucho m√°s complicado: tienes que convertir n√∫meros en cadenas y usar varias otras funciones.  <code>_putc</code> funci√≥n <code>_putc</code> , que genera un car√°cter, la funci√≥n <code>mod</code> para calcular el resto de la divisi√≥n (m√≥dulo) de los dos argumentos y <code>_pow_10</code> para elevar a la potencia de 10. M√°s adelante comprender√° por qu√© son necesarios.  Esto es bastante simple, aqu√≠ est√° el c√≥digo: <br><br><pre> <code class="hljs powershell">_pow_10: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  ecx (  )  ;  mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">10</span></span> (<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>) _pow_10_loop_start: ;  eax  <span class="hljs-number"><span class="hljs-number">10</span></span>,  ecx   <span class="hljs-number"><span class="hljs-number">0</span></span> cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _pow_10_loop_end imul eax, <span class="hljs-number"><span class="hljs-number">10</span></span> sub ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _pow_10_loop_start _pow_10_loop_end: leave ret _mod: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> push ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;   mov eax, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov ebx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">12</span></span>] idiv ebx ;  <span class="hljs-number"><span class="hljs-number">64</span></span>-  [<span class="hljs-type"><span class="hljs-type">edx</span></span>:<span class="hljs-type"><span class="hljs-type">eax</span></span>]  ebx.    ;  <span class="hljs-number"><span class="hljs-number">32</span></span>-  eax,    edx  ; . ;    eax,   edx.  ,  ;       , ;    . mov eax, edx ;     () pop ebx leave ret _putc: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ; write() mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   lea ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   mov edx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 leave ret</code> </pre> <br>  Entonces, ¬øc√≥mo derivamos n√∫meros individuales en un n√∫mero?  Primero, tenga en cuenta que el √∫ltimo d√≠gito del n√∫mero es el resto de la divisi√≥n por 10 (por ejemplo, <code>123 % 10 = 3</code> ), y el siguiente d√≠gito es el resto de la divisi√≥n por 100, dividido por 10 (por ejemplo, <code>(123 % 100)/10 = 2</code> ).  En general, puede encontrar un d√≠gito espec√≠fico de un n√∫mero (de derecha a izquierda) al encontrar <code>( % 10**n) / 10**(n-1)</code> , donde el n√∫mero de unidades ser√° <code>n = 1</code> , el n√∫mero de decenas es <code>n = 2</code> y as√≠ sucesivamente. <br><br>  Con este conocimiento, puede encontrar todos los d√≠gitos de un n√∫mero desde <code>n = 1</code> hasta <code>n = 10</code> (este es el n√∫mero m√°ximo de bits en un entero de 4 bytes con signo).  Pero es mucho m√°s f√°cil ir de izquierda a derecha, por lo que podemos imprimir cada car√°cter tan pronto como lo encontremos y eliminar los ceros en el lado izquierdo.  Por lo tanto, clasificamos los n√∫meros de <code>n = 10</code> a <code>n = 1</code> . <br><br>  En C, el programa se ver√° as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_DIGITS 10 void print_answer(int a) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (a </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 0) { //    putc('-'); //   ¬´¬ª a = -a; //     } int started = 0; for (int i = MAX_DIGITS; i &gt; 0; i--) { int digit = (a % pow_10(i)) / pow_10(i-1); if (digit == 0 &amp;&amp; started == 0) continue; //     started = 1; putc(digit + '0'); } }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora entiendes por qu√© necesitamos estas tres funciones. </font><font style="vertical-align: inherit;">Implementemos esto en ensamblador:</font></font><br><br><pre> <code class="hljs perl">%define MAX_DIGITS <span class="hljs-number"><span class="hljs-number">10</span></span> _print_answer: enter <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-string"><span class="hljs-string">"started"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   <span class="hljs-string"><span class="hljs-string">"a"</span></span> cmp eax, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    ;  jge _print_answer_negate_end ; call putc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0x2d</span></span> ;  <span class="hljs-string"><span class="hljs-string">'-'</span></span> call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax neg eax ;     _print_answer_negate_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ; started = <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, MAX_DIGITS ;  i _print_answer_loop_start: cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _print_answer_loop_end ;  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>  ecx.   ebx   <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C. ;    edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx dec ecx ; i-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;    _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> mov edx, eax ; edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;   i  ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ; end pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call mov ebx, edx ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) imul ebx, <span class="hljs-number"><span class="hljs-number">10</span></span> ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) ;  _mod  (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)),   (eax mod ebx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx ; arg2, ebx = digit = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ; arg1, eax = a call _mod mov ebx, eax ; digit = ebx = a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i+<span class="hljs-number"><span class="hljs-number">1</span></span>), almost there add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   mod ;  ebx ( <span class="hljs-string"><span class="hljs-string">"digit"</span></span> )  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) (edx).    ; ,   idiv     edx, eax.  ; edx   ,    - ;   <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov esi, edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax mov eax, ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv esi ; eax   () mov ebx, eax ; ebx = (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)) / pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> esi ; end division cmp ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  digit == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end cmp byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ;  started == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end jmp _print_answer_loop_continue ; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> _print_answer_trailing_zeroes_check_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span> ; started = <span class="hljs-number"><span class="hljs-number">1</span></span> add ebx, <span class="hljs-number"><span class="hljs-number">0x30</span></span> ; digit + <span class="hljs-string"><span class="hljs-string">'0'</span></span> ;  putc <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   putc _print_answer_loop_continue: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jmp</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_start</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_end</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebx</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Fue una prueba dif√≠cil! </font><font style="vertical-align: inherit;">Espero que los comentarios ayuden a resolverlo. </font><font style="vertical-align: inherit;">Si ahora piensa: "¬øPor qu√© no puede simplemente escribir </font></font><code>printf("%d")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?", Entonces le gustar√° el final del art√≠culo, donde reemplazamos la funci√≥n con eso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos todas las funciones necesarias, queda por implementar la l√≥gica b√°sica </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ¬°y eso es todo!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√°lculo de notaci√≥n polaca inversa </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ya dijimos, la notaci√≥n polaca inversa se calcula utilizando la pila. </font><font style="vertical-align: inherit;">Al leer, el n√∫mero se inserta en la pila, y al leer, el operador se aplica a dos objetos en la parte superior de la pila. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, si queremos calcular </font></font><code>84/3+6*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(esta expresi√≥n tambi√©n se puede escribir en el formulario </font></font><code>6384/+*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), el proceso es el siguiente:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paso </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S√≠mbolo </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apilar antes </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apilar despu√©s </font></font></th></tr><tr><td align="center">  1 </td><td align="center"> <code>8</code> </td> <td align="center"> <code>[]</code> </td> <td align="center"> <code>[8]</code> </td> </tr><tr><td align="center">  2 </td><td align="center"> <code>4</code> </td> <td align="center"> <code>[8]</code> </td> <td align="center"> <code>[8, 4]</code> </td> </tr><tr><td align="center">  3 </td><td align="center"> <code>/</code> </td> <td align="center"> <code>[8, 4]</code> </td> <td align="center"> <code>[2]</code> </td> </tr><tr><td align="center">  4 4 </td><td align="center"> <code>3</code> </td> <td align="center"> <code>[2]</code> </td> <td align="center"> <code>[2, 3]</code> </td> </tr><tr><td align="center">  5 5 </td><td align="center"> <code>+</code> </td> <td align="center"> <code>[2, 3]</code> </td> <td align="center"> <code>[5]</code> </td> </tr><tr><td align="center">  6 6 </td><td align="center"> <code>6</code> </td> <td align="center"> <code>[5]</code> </td> <td align="center"> <code>[5, 6]</code> </td> </tr><tr><td align="center">  7 7 </td><td align="center"> <code>*</code> </td> <td align="center"> <code>[5, 6]</code> </td> <td align="center"> <code>[30]</code> </td> </tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la entrada es una expresi√≥n de postfix v√°lida, al final de los c√°lculos solo queda un elemento en la pila: esta es la respuesta, el resultado de los c√°lculos. </font><font style="vertical-align: inherit;">En nuestro caso, el n√∫mero es 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En ensamblador, debe implementar algo como este c√≥digo en C:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// , 256      int stack_size = 0; int main(int argc, char *argv[]) { char *input = argv[0]; size_t input_length = strlen(input); for (int i = 0; i &lt; input_length; i++) { char c = input[i]; if (c &gt;= '0' &amp;&amp; c &lt;= '9') { //   ‚Äî   push(c - '0'); //          } else { int b = pop(); int a = pop(); if (c == '+') { push(a+b); } else if (c == '-') { push(ab); } else if (c == '*') { push(a*b); } else if (c == '/') { push(a/b); } else { error("Invalid input\n"); exit(1); } } } if (stack_size != 1) { error("Invalid input\n"); exit(1); } print_answer(stack[0]); exit(0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora que tenemos todas las funciones necesarias para implementar esto, comencemos. </font></font><br><br><pre> <code class="hljs perl">_start: ;  _start   ,    . ;   esp    argc ( ),  ; esp+<span class="hljs-number"><span class="hljs-number">4</span></span>   argv. , esp+<span class="hljs-number"><span class="hljs-number">4</span></span>    ; , esp+<span class="hljs-number"><span class="hljs-number">8</span></span> -       mov esi, [esp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ; esi = <span class="hljs-string"><span class="hljs-string">"input"</span></span> = argv[<span class="hljs-number"><span class="hljs-number">0</span></span>] ;  _strlen      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi call _strlen mov ebx, eax ; ebx = input_length add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ; end _strlen call mov ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; ecx = <span class="hljs-string"><span class="hljs-string">"i"</span></span> _main_loop_start: cmp ecx, ebx ;  (i &gt;= input_length) jge _main_loop_end mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> mov dl, [esi + ecx] ;          ; edx.   edx . ; edx =  c = input[i] cmp edx, <span class="hljs-string"><span class="hljs-string">'0'</span></span> jl _check_operator cmp edx, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jg _print_error <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function">, '0' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function"> </span></span>; eax =  c - <span class="hljs-string"><span class="hljs-string">'0'</span></span> (,  ) jmp _push_eax_and_continue _check_operator: ;   _pop    b  edi, a  b -  eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _pop mov edi, eax ; edi = b call _pop ; eax = a <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; end call _pop cmp edx, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jne _subtract add eax, edi ; eax = a+b jmp _push_eax_and_continue _subtract: cmp edx, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jne _multiply <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span></span>; eax = ab jmp _push_eax_and_continue _multiply: cmp edx, <span class="hljs-string"><span class="hljs-string">'*'</span></span> jne _divide imul eax, edi ; eax = a*b jmp _push_eax_and_continue _divide: cmp edx, <span class="hljs-string"><span class="hljs-string">'/'</span></span> jne _print_error <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx ;  edx,      idiv mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv edi ; eax = a/b <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;   eax     _push_eax_and_continue: ;  _push <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;   call _push add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;  call _push inc ecx jmp _main_loop_start _main_loop_end: cmp byte [stack_size], <span class="hljs-number"><span class="hljs-number">1</span></span> ;  (stack_size != <span class="hljs-number"><span class="hljs-number">1</span></span>),   jne _print_error mov eax, [stack] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax call _print_answer ; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> a final newline <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0xA</span></span> call _putc ; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> successfully mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> ;    _print_error: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> error_msg call _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n deber√° agregar una l√≠nea </font></font><code>error_msg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la secci√≥n </font></font><code>.rodata</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs 1c">section .rodata ;     error_msg.  db  NASM ;    ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ; . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    error_msg: db <span class="hljs-string"><span class="hljs-string">"Invalid input"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y hemos terminado! </font><font style="vertical-align: inherit;">Sorprende a todos tus amigos si los tienes. </font><font style="vertical-align: inherit;">Espero que ahora reaccione m√°s c√°lidamente a los lenguajes de alto nivel, especialmente si recuerda que muchos programas antiguos se escribieron completa o casi completamente en ensamblador, por ejemplo, el RollerCoaster Tycoon original. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo el c√≥digo est√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Gracias por leer! </font><font style="vertical-align: inherit;">Puedo continuar si est√°s interesado.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otras acciones </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puede practicar implementando varias funciones adicionales: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Devuelve un mensaje de error en lugar de segfault si el programa no recibe un argumento. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue soporte para espacios adicionales entre operandos y operadores en la entrada. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue soporte para operandos de m√∫ltiples bits. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permitir n√∫meros negativos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reemplace </font></font><code>_strlen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con una funci√≥n de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca C est√°ndar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><code>_print_answer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reemplace con una llamada </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ol><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Materiales adicionales </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La Gu√≠a del ensamblador x86 de la Universidad de Virginia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una descripci√≥n m√°s detallada de muchos de los temas que cubrimos, incluida informaci√≥n adicional sobre todas las instrucciones populares de x86.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´   Intel¬ª</a> .    x86 ‚Äî   ,      .        ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NASM: Intel x86 Instruction Reference</a> ‚Äî       x86. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423077/">https://habr.com/ru/post/es423077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423067/index.html">Python Developer Tools de Microsoft. Empezando</a></li>
<li><a href="../es423069/index.html">Evento especial de Apple, septiembre de 2018 [archivo de traducci√≥n de texto]</a></li>
<li><a href="../es423071/index.html">No tengo miedo de tu NDA</a></li>
<li><a href="../es423073/index.html">Sistema de archivos interplanetarios: hash trivial (identidad), bloque DAG y buffers de protocolo</a></li>
<li><a href="../es423075/index.html">¬øPor qu√© los directores financieros est√°n tan ansiosos por traducir el gasto de capital en TI en funcionamiento?</a></li>
<li><a href="../es423079/index.html">Puntos clave de una entrevista con Elon Musk en Joe Rogan</a></li>
<li><a href="../es423083/index.html">C√≥mo me convert√≠ en desarrollador en ABBYY</a></li>
<li><a href="../es423085/index.html">Ajuste fino del equilibrio de carga</a></li>
<li><a href="../es423087/index.html">No me empujes en el ojo</a></li>
<li><a href="../es423089/index.html">Programadores en MBLT DEV 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>