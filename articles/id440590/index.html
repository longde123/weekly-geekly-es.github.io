<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏿 ↕️ 👴🏽 Di mana kaki-kaki dari Java Memory Model 💃🏿 🔩 🥑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perangkat keras dan kompiler modern siap untuk membalikkan kode kita, jika itu bekerja lebih cepat. Dan produsen mereka dengan hati-hati menyembunyika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Di mana kaki-kaki dari Java Memory Model</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440590/"> Perangkat keras dan kompiler modern siap untuk membalikkan kode kita, jika itu bekerja lebih cepat.  Dan produsen mereka dengan hati-hati menyembunyikan dapur bagian dalam mereka.  Dan semuanya baik-baik saja asalkan kode dieksekusi dalam satu utas. <br><br>  Di lingkungan multi-utas, Anda bisa mengamati hal-hal menarik.  Misalnya, menjalankan instruksi program tidak sesuai urutan yang tertulis dalam kode sumber.  Setuju, tidak menyenangkan untuk menyadari bahwa mengeksekusi kode sumber baris demi baris hanyalah imajinasi kita. <br><br>  Tetapi semua orang sudah menyadari, karena bagaimanapun Anda harus hidup dengannya.  Dan programmer Java bahkan hidup dengan baik.  Karena Java memiliki model memori - Java Memory Model (JMM), yang menyediakan aturan yang cukup sederhana untuk menulis kode multi-utas yang benar. <br><br>  Dan aturan ini cukup untuk sebagian besar program.  Jika Anda tidak mengetahuinya, tetapi menulis atau ingin menulis program multi-utas di Jawa, maka yang terbaik adalah membiasakan diri dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mereka</a> sesegera mungkin.  Dan jika Anda tahu, tetapi Anda tidak memiliki konteks yang cukup atau menarik untuk mengetahui dari mana kaki JMM tumbuh, maka artikel ini dapat membantu Anda. <br><a name="habracut"></a><br><h2>  Dan mengejar abstraksi </h2><br>  Menurut pendapat saya, ada kue, atau, lebih cocok, gunung es.  JMM adalah puncak gunung es.  Gunung es itu sendiri adalah teori pemrograman multi-threaded di bawah air.  Di bawah gunung es adalah Neraka. <br><br><img src="https://habrastorage.org/webt/ub/jg/rf/ubjgrfe8bec3-ix9qgnkik3avoy.png"><br><br>  Gunung es adalah abstraksi, jika bocor, kita pasti akan melihat Neraka.  Meskipun banyak hal menarik terjadi di sana, di artikel ulasan kami tidak akan membahasnya. <br><br>  Dalam artikel ini, saya lebih tertarik dengan topik berikut: <br><br><ul><li>  Teori dan Terminologi </li><li>  Bagaimana teori pemrograman multithreaded tercermin dalam JMM </li><li>  Model Pemrograman yang Kompetitif </li></ul><br>  Teori pemrograman multi-utas memungkinkan Anda untuk keluar dari kerumitan prosesor dan kompiler modern, ini memungkinkan Anda untuk mensimulasikan pelaksanaan program multi-utas dan mempelajari sifat-sifatnya.  Roman Elizarov membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan yang</a> sangat bagus, yang tujuannya adalah untuk memberikan dasar teoretis untuk memahami JMM.  Saya merekomendasikan laporan ini kepada semua orang yang tertarik dengan topik ini. <br><br>  Mengapa penting untuk mengetahui teorinya?  Menurut pendapat saya, saya hanya berharap untuk saya, beberapa programmer berpendapat bahwa JMM adalah komplikasi dari bahasa dan menambal beberapa masalah platform dengan multithreading.  Teori ini menunjukkan bahwa Java tidak menyulitkan, tetapi disederhanakan dan membuat pemrograman multithreaded sangat kompleks. <br><br><h2>  Persaingan dan Konkurensi </h2><br>  Pertama, mari kita lihat terminologinya.  Sayangnya, tidak ada konsensus dalam terminologi - ketika mempelajari materi yang berbeda, Anda mungkin menemukan definisi yang berbeda tentang kompetisi dan konkurensi. <br><br>  Masalahnya adalah bahwa bahkan jika kita sampai pada dasar kebenaran dan menemukan definisi yang tepat dari konsep-konsep ini, masih tidak sebanding dengan harapan bahwa setiap orang akan memiliki makna yang sama dengan konsep-konsep ini.  Anda tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan menemukan</a> ujungnya di sini. <br><br>  Roman Elizarov, dalam sebuah laporan, teori pemrograman paralel untuk praktisi menyarankan bahwa kadang-kadang konsep-konsep ini dicampur.  Pemrograman paralel kadang-kadang dibedakan sebagai konsep umum yang dibagi menjadi kompetitif dan didistribusikan. <br><br>  Tampak bagi saya bahwa dalam konteks JMM Anda masih perlu memisahkan persaingan dan paralelisme, atau lebih tepatnya memahami bahwa ada dua paradigma yang berbeda, tidak peduli bagaimana mereka disebut. <br><br>  Sering dikutip oleh Rob Pike, yang membedakan antara konsep sebagai berikut: <br><br><ul><li>  Persaingan adalah cara untuk secara bersamaan menyelesaikan banyak masalah </li><li>  Concurrency adalah cara untuk melakukan berbagai bagian dari satu tugas. </li></ul><br>  Pendapat Rob Pike bukanlah standar, tetapi menurut pendapat saya, mudah untuk membangunnya untuk mempelajari lebih lanjut masalah ini.  Baca lebih lanjut tentang perbedaannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Kemungkinan besar, pemahaman yang lebih besar tentang masalah ini akan muncul jika kami menyoroti fitur utama dari program yang kompetitif dan paralel.  Ada banyak tanda, pertimbangkan yang paling signifikan. <br><br>  Tanda-tanda kompetisi. <br><br><ul><li>  Adanya beberapa aliran kontrol (mis. Thread di Jawa, coroutine di Kotlin), jika hanya ada satu aliran kontrol, maka tidak ada eksekusi kompetitif </li><li>  Hasil non-deterministik.  Hasilnya tergantung pada peristiwa acak, implementasi, dan bagaimana sinkronisasi dilakukan.  Sekalipun setiap aliran sepenuhnya deterministik, hasil akhirnya akan menjadi non-deterministik </li></ul><br>  Program paralel akan memiliki serangkaian fitur yang berbeda. <br><br><ul><li>  Opsional memiliki banyak aliran kontrol </li><li>  Ini dapat menyebabkan hasil deterministik, misalnya, hasil dari mengalikan setiap elemen array dengan angka tidak akan berubah jika Anda mengalikannya dalam bagian-bagian secara paralel </li></ul><br>  Anehnya, eksekusi paralel dimungkinkan pada aliran kontrol tunggal, dan bahkan pada arsitektur inti tunggal.  Faktanya adalah bahwa paralelisme di tingkat tugas (atau aliran kontrol) yang kita terbiasa bukanlah satu-satunya cara untuk melakukan perhitungan secara paralel. <br><br>  Konkurensi dimungkinkan pada tingkat: <br><br><ul><li>  bit (misalnya, pada mesin 32-bit, penambahan terjadi dalam satu tindakan, memproses semua 4 byte dari nomor 32-bit secara paralel) </li><li>  instruksi (pada satu inti, dalam satu utas, prosesor dapat menjalankan instruksi secara paralel, terlepas dari kenyataan bahwa kode tersebut berurutan) </li><li>  data (ada arsitektur dengan pemrosesan data paralel (Single Instruction Multiple Data) yang dapat mengeksekusi satu instruksi pada set data yang besar) </li><li>  tugas (menyiratkan adanya beberapa prosesor atau inti) </li></ul><br>  Konkurensi pada level instruksi adalah salah satu contoh optimisasi yang terjadi dengan eksekusi kode yang disembunyikan dari programmer. <br><br>  Dijamin bahwa kode yang dioptimalkan akan setara dengan yang asli dalam kerangka satu utas, karena tidak mungkin untuk menulis kode yang memadai dan dapat diprediksi jika tidak melakukan apa yang diinginkan oleh programmer. <br><br>  Tidak semua yang berjalan secara paralel penting bagi JMM.  Eksekusi bersamaan pada tingkat instruksi dalam satu utas tidak dipertimbangkan dalam JMM. <br><br>  Terminologi ini sangat goyah, dengan presentasi oleh Roman Elizarov yang disebut "Teori pemrograman <b>paralel</b> untuk praktisi," meskipun ada lebih banyak tentang pemrograman kompetitif, jika Anda tetap berpegang pada hal di atas. <br><br>  Dalam konteks JMM, dalam artikel saya akan tetap berpegang pada istilah kompetisi, karena kompetisi sering tentang keadaan umum.  Tetapi di sini Anda perlu berhati-hati untuk tidak berpegang pada persyaratan, tetapi pahamilah bahwa ada paradigma yang berbeda. <br><br><h2>  Model dengan kondisi umum: "rotasi operasi" dan "terjadi sebelumnya" </h2><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikelnya,</a> Maurice Herlichi (penulis pemrograman The Art Of Multiprocessor) menulis bahwa sistem kompetitif berisi kumpulan proses sekuensial (dalam karya teoretis artinya sama dengan utas) yang berkomunikasi melalui memori bersama. <br><br>  Model keadaan umum mencakup perhitungan dengan olahpesan, di mana keadaan bersama adalah antrian pesan dan perhitungan dengan memori bersama, di mana kondisi umum adalah struktur dalam memori. <br><br>  Setiap perhitungan dapat disimulasikan. <br><br>  Model ini didasarkan pada mesin negara yang terbatas.  Model ini memfokuskan secara eksklusif pada status bersama dan data lokal dari masing-masing aliran diabaikan sepenuhnya.  Setiap tindakan aliran di atas status bersama adalah fungsi transisi ke kondisi baru. <br><br>  Jadi misalnya, jika 4 utas menulis data ke variabel bersama, maka akan ada 4 fungsi untuk beralih ke status baru.  Manakah dari fungsi-fungsi ini yang akan diterapkan tergantung pada kronologi peristiwa dalam sistem. <br><br>  Perhitungan lewat pesan dimodelkan dengan cara yang sama, hanya fungsi keadaan dan transisi tergantung pada pengiriman atau penerimaan pesan. <br><br>  Jika model tampak rumit bagi Anda, maka dalam contoh ini kami akan memperbaikinya.  Ini sangat sederhana dan intuitif.  Sedemikian rupa sehingga tanpa mengetahui tentang keberadaan model ini, kebanyakan orang masih akan menganalisis program seperti yang disarankan oleh model tersebut. <br><br>  Model seperti ini disebut model <b>kinerja melalui pergantian operasi</b> (nama itu terdengar dalam laporan oleh Roman Elizarov). <br><br>  Ke intuisi dan kealamian, Anda dapat dengan aman menuliskan keunggulan model.  Anda dapat pergi ke alam liar dengan <b>konsistensi</b> kata kunci <b>Sequential</b> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">karya</a> Leslie Lamport. <br><br>  Namun, ada klarifikasi penting tentang model ini.  Model memiliki batasan bahwa semua tindakan pada keadaan bersama harus instan dan pada saat yang sama, tindakan tidak dapat terjadi secara bersamaan.  Mereka mengatakan bahwa sistem seperti itu memiliki <b>urutan linier</b> - semua tindakan dalam sistem dipesan. <br><br>  Dalam praktiknya, ini tidak terjadi.  Operasi tidak terjadi secara instan, tetapi dilakukan dalam suatu interval, pada sistem multi-core, interval ini dapat berpotongan.  Tentu saja, ini tidak berarti bahwa model tersebut tidak berguna dalam praktiknya, Anda hanya perlu membuat kondisi tertentu untuk penggunaannya. <br><br>  Sementara itu, pertimbangkan <b>model</b> lain <b>- "terjadi sebelumnya,"</b> yang tidak berfokus pada negara, tetapi pada set sel memori baca dan tulis selama eksekusi (sejarah) dan hubungan mereka. <br><br>  Model mengatakan bahwa peristiwa dalam aliran yang berbeda tidak instan dan atom, tetapi secara paralel, dan tidak mungkin untuk membangun keteraturan di antara mereka.  Peristiwa (menulis dan membaca data bersama) di aliran pada arsitektur multiprosesor atau multi-core benar-benar terjadi secara paralel.  Tidak ada konsep waktu global dalam sistem, kami tidak dapat memahami kapan satu operasi berakhir dan yang lainnya dimulai. <br><br>  Dalam praktiknya, ini berarti bahwa kita dapat menulis nilai ke variabel di satu utas dan melakukannya, katakan di pagi hari, dan baca nilai dari variabel ini di utas lain di malam hari, dan kita tidak bisa mengatakan bahwa kita akan membaca nilai yang ditulis di pagi hari pasti.  Secara teori, operasi ini dilakukan secara paralel dan tidak jelas kapan satu akan berakhir dan operasi lain akan dimulai. <br><br>  Sulit membayangkan bagaimana ternyata operasi baca-tulis sederhana yang dilakukan pada waktu yang berbeda dalam satu hari terjadi secara bersamaan.  Tetapi jika Anda memikirkannya, itu tidak masalah bagi kami ketika peristiwa menulis dan membaca terjadi, jika kami tidak dapat menjamin bahwa kami akan melihat hasil rekaman. <br><br>  Dan kita benar-benar tidak dapat melihat hasil rekaman, mis.  ke dalam variabel yang nilainya <i>0</i> dalam aliran <i>P,</i> kita menulis <i>1</i> , dan dalam aliran <i>Q</i> kita membaca variabel ini.  Tidak peduli berapa banyak waktu fisik yang berlalu setelah perekaman, kami masih dapat membaca <i>0</i> . <br><br>  <b>Beginilah cara komputer bekerja dan modelnya mencerminkan hal ini.</b> <br><br>  Model ini sepenuhnya abstrak dan membutuhkan visualisasi yang nyaman untuk pekerjaan yang nyaman.  Untuk visualisasi dan hanya untuk itu, model dengan waktu global digunakan, dengan pemesanan yang dalam membuktikan sifat-sifat program, waktu global tidak digunakan.  Dalam visualisasi, setiap peristiwa direpresentasikan sebagai interval dengan awal dan akhir. <br><br>  Acara berlangsung secara paralel, seperti yang kami ketahui.  Tetapi tetap saja, sistem memiliki <b>urutan parsial</b> , karena ada pasangan peristiwa khusus yang memiliki urutan, dalam hal ini mereka mengatakan bahwa peristiwa ini memiliki hubungan "terjadi sebelumnya".  Jika Anda pertama kali mendengar tentang hubungan "terjadi sebelum", maka mungkin mengetahui fakta bahwa hubungan semacam ini mengatur acara tidak akan banyak membantu Anda. <br><br><h2>  Mencoba menganalisis program Java </h2><br>  Kami menganggap beberapa minimum teoretis, mari kita lanjutkan dan pertimbangkan program multi-utas dalam bahasa tertentu - Jawa, dari dua utas dengan status umum yang bisa berubah-ubah. <br><br>  Contoh klasik. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { a = <span class="hljs-number"><span class="hljs-number">0</span></span>; b = <span class="hljs-number"><span class="hljs-number">0</span></span>; x = <span class="hljs-number"><span class="hljs-number">0</span></span>; y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } Thread p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { a = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = b; }); Thread q = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { b = <span class="hljs-number"><span class="hljs-number">1</span></span>; y = a; }); p.start(); q.start(); p.join(); q.join(); System.out.println(<span class="hljs-string"><span class="hljs-string">"x="</span></span> + x + <span class="hljs-string"><span class="hljs-string">", y="</span></span> + y);</code> </pre> <br>  Kita perlu mensimulasikan pelaksanaan program ini dan mendapatkan semua hasil yang mungkin - nilai-nilai variabel x dan y.  Akan ada beberapa hasil, seperti yang kita ingat dari teori, program seperti itu adalah non-deterministik. <br><br>  Bagaimana kita memodelkan?  Saya segera ingin menggunakan model operasi interleaving.  Tetapi model “terjadi sebelumnya” memberi tahu kita bahwa peristiwa dalam satu utas sejajar dengan peristiwa dari utas lain.  Oleh karena itu, model operasi bolak-balik di sini tidak sesuai jika tidak ada hubungan "terjadi sebelumnya" antara operasi. <br><br>  Hasil dari eksekusi setiap utas selalu ditentukan, karena peristiwa dalam satu utas selalu dipesan, pertimbangkan bahwa mereka menerima hubungan "yang terjadi sebelumnya" secara gratis.  Tetapi bagaimana peristiwa dalam aliran yang berbeda bisa mendapatkan hubungan "terjadi sebelum" tidak sepenuhnya jelas.  Tentu saja, hubungan ini diformalkan dalam model, seluruh model ditulis dalam bahasa matematika.  Tetapi apa yang harus dilakukan dengan ini dalam praktiknya, dalam bahasa tertentu, tidak segera dipahami. <br><br>  Apa saja pilihannya? <br><br>  Abaikan kendala dan simulasikan interleaving.  Anda dapat mencobanya, mungkin tidak ada hal buruk yang akan terjadi. <br><br>  Untuk memahami hasil seperti apa yang bisa diperoleh, kami cukup menyebutkan semua varian eksekusi yang mungkin. <br><br>  Semua eksekusi program yang mungkin dapat direpresentasikan sebagai mesin keadaan terbatas. <br><br><img src="https://habrastorage.org/webt/z_/nb/a4/z_nba4dq4_xlfkdvw7vypddxo3s.jpeg"><br><br>  Setiap lingkaran adalah keadaan sistem, dalam kasus kami variabel <i>a, b, x, y</i> .  Fungsi transisi adalah tindakan pada keadaan yang menempatkan sistem dalam keadaan baru.  Karena dua aliran dapat melakukan tindakan pada keadaan umum, akan ada dua transisi dari masing-masing negara.  Lingkaran ganda adalah kondisi akhir dan awal sistem. <br><br>  Secara total, 6 eksekusi berbeda dimungkinkan, yang menghasilkan pasangan nilai x, y: <br> <code>(1, 1), (1, 0), (0, 1) <br></code> <br><img src="https://habrastorage.org/webt/uu/dn/ev/uudnevagixnomxjnrydhfgrph4i.png"><br><br>  Kita dapat menjalankan program dan memeriksa hasilnya.  Sebagaimana layaknya program kompetitif, ia akan memiliki hasil yang tidak deterministik. <br><br>  Untuk menguji program kompetitif, lebih baik menggunakan alat khusus ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> ). <br><br>  Tetapi Anda dapat mencoba menjalankan program beberapa juta kali, atau bahkan lebih baik, menulis siklus yang akan melakukan ini untuk kita. <br><br>  Jika kita menjalankan kode pada arsitektur single-core atau prosesor tunggal, maka kita harus mendapatkan hasil dari set yang kita harapkan.  Model rotasi akan bekerja dengan baik.  Pada arsitektur multi-core, misalnya x86, kita mungkin akan terkejut dengan hasilnya - kita bisa mendapatkan hasilnya (0,0), yang tidak bisa sesuai dengan pemodelan kita. <br><br>  Penjelasan untuk ini dapat ditemukan di Internet dengan kata kunci - <b>pemesanan ulang</b> .  Sekarang penting untuk memahami bahwa <b>pemodelan interleaving benar-benar tidak cocok dalam situasi di mana kita tidak dapat menentukan urutan akses ke keadaan bersama</b> . <br><br><h2>  Teori Pemrograman Kompetitif dan JMM </h2><br>  Saatnya untuk melihat lebih dekat pada hubungan "terjadi sebelumnya" dan bagaimana ia berteman dengan JMM.  Definisi asli dari hubungan "terjadi sebelumnya" dapat ditemukan dalam Waktu, Jam, dan Pemesanan Acara dalam Sistem Terdistribusi. <br><br>  Model memori bahasa membantu dalam penulisan kode kompetitif, karena menentukan operasi mana yang terkait dengan "terjadi sebelumnya".  Daftar operasi tersebut disajikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> di bagian Happens-before Order.  Bahkan, bagian ini menjawab pertanyaan - dalam kondisi apa kita akan melihat hasil rekaman di aliran lain. <br><br>  Ada berbagai pesanan di JMM.  Alexei Shipilev dengan penuh semangat berbicara tentang peraturan di salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporannya</a> . <br><br>  Dalam model waktu global, semua operasi di utas yang sama dalam urutan.  Misalnya, peristiwa menulis dan membaca variabel dapat direpresentasikan sebagai dua interval, maka model menjamin bahwa interval ini tidak akan pernah berpotongan dalam kerangka aliran tunggal.  Di JMM, pesanan ini disebut Program Order ( <i>PO</i> ). <br><br>  <i>PO</i> mengikat tindakan dalam utas tunggal dan tidak mengatakan apa pun tentang urutan eksekusi, ia hanya berbicara tentang urutan dalam kode sumber.  Ini cukup untuk menjamin <b>determinisme untuk setiap aliran secara terpisah</b> .  <i>PO</i> dapat dianggap sebagai data mentah.  <i>PO</i> selalu mudah diatur dalam suatu program - semua operasi (urutan linier) dalam kode sumber dalam satu aliran akan memiliki <i>PO</i> . <br><br>  Dalam contoh kita, kita mendapatkan sesuatu seperti berikut: <br><br>  <code>P: a = 1 PO x = b</code> - menulis ke a dan membaca b memiliki urutan PO <br>  <code>Q: b = 1 PO y = a</code> - tulis ke b dan baca perintah PO has <br><br>  Saya memata-matai bentuk tulisan ini dengan <i>(a, 1) PO r (b): 0.</i> Saya benar-benar berharap tidak ada yang mematenkannya untuk laporan.  Namun, spesifikasinya memiliki bentuk serupa. <br><br>  Tetapi setiap utas secara individual tidak terlalu menarik bagi kami, karena utas memiliki keadaan yang sama, kami lebih tertarik pada interaksi arus.  Yang kami inginkan adalah memastikan bahwa kami akan melihat catatan variabel di utas lainnya. <br><br>  Biarkan saya mengingatkan Anda bahwa ini tidak berhasil bagi kami, karena operasi penulisan dan membaca variabel dalam aliran yang berbeda tidak secara instan (ini adalah segmen yang berpotongan), masing-masing, tidak mungkin untuk menguraikan di mana awal dan akhir operasi. <br><br>  Idenya sederhana - saat ini ketika kita membaca variabel a di aliran <i>Q</i> , catatan variabel yang sama di aliran <i>P</i> mungkin belum berakhir.  Dan tidak peduli berapa banyak waktu fisik yang dibagikan oleh peristiwa ini - nanodetik atau beberapa jam. <br><br>  Untuk memesan acara, kita membutuhkan hubungan "terjadi sebelum".  JMM mendefinisikan hubungan ini.  Spesifikasi memperbaiki urutan dalam satu utas: <br><br>  <i>Jika operasi x dan y berada di utas yang sama dan di <i>PO</i> x pertama kali terjadi, dan kemudian y, maka x terjadi sebelum y.</i> <i><br></i> <br><br>  Ke depan, kita dapat mengatakan bahwa kita dapat mengganti semua <i>PO</i> dengan Happens-before ( <i>HB</i> ): <br><br><pre> <code class="plaintext hljs">P: w(a, 1) HB r(b) Q: w(b, 1) HB r(a)</code> </pre> <br>  Tetapi sekali lagi kita kembali dalam kerangka satu aliran.  <i>HB</i> dimungkinkan antara operasi yang terjadi di utas yang berbeda, untuk menangani kasus ini kami akan berkenalan dengan pesanan lain. <br><br>  Perintah Sinkronisasi ( <i>SO</i> ) - menautkan Tindakan Sinkronisasi ( <i>SA</i> ), daftar lengkap <i>SA</i> diberikan dalam spesifikasi, di bagian 17.4.2.  Tindakan  Inilah beberapa di antaranya: <br><br><ul><li>  Membaca variabel yang tidak stabil </li><li>  Menulis variabel yang tidak stabil </li><li>  Kunci monitor </li><li>  Buka kunci monitor </li></ul><br>  <i>SO</i> menarik bagi kami, karena memiliki properti yang semua bacaan dalam urutan <i>SO</i> melihat entri terakhir di <i>SO</i> .  Dan saya mengingatkan Anda, kami hanya mencapai ini. <br><br>  Di tempat ini, saya akan mengulangi apa yang kita perjuangkan.  Kami memiliki program multithreaded, kami ingin mensimulasikan semua eksekusi yang mungkin dan mendapatkan semua hasil yang bisa diberikan.  Ada model yang memungkinkan ini dilakukan dengan cukup sederhana.  Tetapi mereka mengharuskan semua tindakan pada negara bersama dipesan. <br><br>  Menurut properti <i>SO</i> - jika semua tindakan dalam program ini adalah <i>SA</i> maka kami akan mencapai tujuan kami.  Yaitu  kita dapat mengatur <i>pengubah volatil</i> untuk semua variabel dan kita dapat menggunakan model pergantian.  Jika intuisi memberi tahu Anda bahwa ini tidak sepadan, maka Anda benar sekali.  Dengan tindakan ini, kami hanya melarang mengoptimalkan kode, tentu saja, kadang-kadang ini merupakan pilihan yang baik, tetapi ini jelas bukan kasus umum. <br><br>  Pertimbangkan Synchronize-With Order ( <i>SW</i> ) lain - SO order untuk membuka kunci / kunci tertentu, menulis / membaca pasangan yang mudah menguap.  Tidak masalah apa aliran tindakan ini, yang utama adalah bahwa mereka berada di monitor yang sama, variabel volatil.  <i>SW</i> menyediakan jembatan antara utas. <br><br>  Dan sekarang kita sampai pada urutan yang paling menarik - Terjadi sebelum ( <i>HB</i> ). <br>  <i>HB</i> adalah penutupan transitif dari persatuan <i>SW</i> dan <i>PO</i> .  <i>PO</i> memberikan urutan linier dalam aliran, dan <i>SW</i> menyediakan jembatan antara aliran.  <i>HB bersifat</i> transitif, mis.  jika <br><br><pre> <code class="plaintext hljs">x HB y  y HB z,  x HB z</code> </pre> <br>  Spesifikasi memiliki daftar hubungan <i>HB</i> , Anda dapat membiasakan diri dengan lebih detail, berikut adalah beberapa daftar: <br><br>  Dalam satu utas, operasi apa pun terjadi sebelum operasi apa pun yang mengikutinya dalam kode sumber. <br><br>  Keluar dari blok / metode yang disinkronkan terjadi sebelum memasukkan blok / metode yang disinkronkan pada monitor yang sama. <br><br>  Menulis bidang <i>volatil</i> terjadi sebelum membaca bidang <i>volatil yang</i> sama. <br><br>  Mari kita kembali ke contoh kita: <br><br><pre> <code class="plaintext hljs">P: a = 1 PO x = b Q: b = 1 PO y = a</code> </pre> <br>  Mari kita kembali ke contoh kita dan mencoba menganalisis program, dengan mempertimbangkan pesanan. <br><br>  Analisis program menggunakan JMM didasarkan pada mengedepankan hipotesis dan mengkonfirmasi atau membantahnya. <br><br><img src="https://habrastorage.org/webt/pu/hy/nz/puhynztfclug7afvnbpfht54wsg.png"><br><br>  Kami memulai analisis kami dengan hipotesis bahwa tidak satu pun eksekusi program yang memberikan hasil (0, 0).  Tidak adanya hasil (0, 0) pada semua eksekusi adalah properti yang seharusnya dari program. <br><br>  Kami menguji hipotesis dengan membangun berbagai eksekusi. <br><br>  Saya melihat nomenklatur di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (kadang-kadang muncul alih-alih <code>…</code> kata <code>race</code> dengan panah, Alexey sendiri menggunakan panah dan kata ras dalam laporannya, tetapi memperingatkan bahwa urutan ini bukan di JMM dan menggunakan notasi ini untuk kejelasan). <br><br>  Kami melakukan reservasi kecil. <br><br>  Karena semua tindakan pada variabel umum penting bagi kami, dan dalam contoh, variabel umum adalah <i>a, b, x, y</i> .  Kemudian, misalnya, operasi x = b harus dianggap sebagai r (b) dan w (x, b), dan <code>r(b) HB w(x,b)</code> (berdasarkan <i>PO</i> ).  Tetapi karena variabel x tidak dibaca di mana pun di utas (membaca di cetak di akhir kode tidak menarik, karena setelah operasi gabungan di utas kita akan melihat nilai x), kita tidak dapat mempertimbangkan tindakan w (x, b). <br><br>  Periksa kinerja pertama. <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(b): 0 … w(b, 1) HB r(a): 0</code> </pre> <br>  Dalam aliran <i>Q,</i> kita membaca variabel a, menulis ke variabel ini di aliran <i>P.</i>  Tidak ada urutan antara menulis dan membaca <i>(PO, SW, HB)</i> . <br><br>  Jika variabel ditulis dalam satu utas dan bacaan ada di utas lainnya dan tidak ada hubungan <i>HB</i> antara operasi, maka mereka mengatakan bahwa variabel tersebut dibaca di bawah ras.  Dan di bawah perlombaan menurut JMM kita dapat membaca nilai tercatat terakhir dalam <i>HB</i> , atau nilai lainnya. <br><br>  Performa seperti itu dimungkinkan.  Eksekusi <b>tidak melanggar JMM</b> .  Saat membaca variabel a, Anda dapat melihat nilai apa pun, karena membaca terjadi di bawah perlombaan dan tidak ada jaminan bahwa kami akan melihat tindakan w (a, 1).  Ini tidak berarti bahwa program bekerja dengan benar, itu hanya berarti bahwa hasil seperti itu diharapkan. <br><br>  Tidak masuk akal untuk mempertimbangkan sisa eksekusi, karena <b>hipotesis sudah dihancurkan</b> . <br><br>  JMM mengatakan bahwa jika program tidak memiliki balapan data, maka semua eksekusi dapat dianggap sebagai berurutan.  Mari kita singkirkan ras, untuk ini kita perlu merampingkan operasi baca dan tulis di utas yang berbeda.  Penting untuk dipahami bahwa program multithreaded, berbeda dengan yang berurutan, memiliki beberapa eksekusi.  Dan untuk mengatakan bahwa suatu program memiliki properti apa pun, diharuskan untuk membuktikan bahwa program tersebut memiliki properti ini bukan pada salah satu eksekusi, tetapi pada semua eksekusi. <br><br>  Untuk membuktikan bahwa program ini non-balap, Anda harus melakukan ini untuk semua pertunjukan.  Mari kita coba membuat <i>SA</i> dan tandai variabel a dengan <i>pengubah volatil</i> .  Variabel <i>volatil</i> akan diawali dengan v. <br><br>  Kami mengajukan <b>hipotesis baru</b> .  Jika variabel a dibuat tidak <i>stabil</i> , maka tidak ada eksekusi program yang akan memberikan hasil (0, 0). <br><br><pre> <code class="plaintext hljs">w(va, 1) HB r(b): 0 … w(b, 1) HB r(va): 0</code> </pre> <br>  Eksekusi <b>tidak melanggar JMM</b> .  Membaca dan terjadi dalam lomba.  Setiap ras menghancurkan transitivitas HB. <br><br>  Kami mengajukan <b>hipotesis lain</b> .  Jika variabel b dibuat tidak <i>stabil</i> , maka tidak ada eksekusi program yang akan memberikan hasil (0, 0). <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(vb): 0 … w(vb, 1) HB r(a): 0</code> </pre> <br>  Eksekusi tidak melanggar JMM.  Membaca terjadi di bawah perlombaan. <br><br>  Mari kita <b>menguji hipotesis</b> bahwa jika variabel a dan b <i>volatil</i> , maka tidak ada eksekusi program yang akan memberikan hasil (0, 0). <br><br>  Periksa kinerja pertama. <br><br><pre> <code class="plaintext hljs">w(va, 1) SO r(vb): 0 SO w(vb, 1) SO r(va): 0</code> </pre> <br>  Karena semua tindakan dalam program <i>SA</i> (khusus membaca atau menulis variabel <i>volatil</i> ), kami mendapatkan urutan <i>SO</i> lengkap antara semua tindakan.  Ini berarti bahwa r (va) harus melihat w (va, 1).  <b>Eksekusi</b> ini <b>melanggar JMM</b> . <br><br>  Diperlukan untuk melanjutkan ke eksekusi berikutnya untuk mengkonfirmasi hipotesis.  Tetapi karena akan ada <i>SO</i> untuk eksekusi apa pun, Anda dapat menyimpang dari formalisme - jelas bahwa hasilnya (0, 0) melanggar JMM untuk eksekusi apa pun. <br><br>  Untuk menggunakan model rotasi, Anda perlu menambahkan <i>volatile</i> untuk variabel a dan b.  Program seperti itu akan memberikan hasil (1,1), (1,0) atau (0,1). <br><br>  Pada akhirnya, kita dapat mengatakan bahwa program yang sangat sederhana cukup mudah untuk dianalisis. <br><br>  Tetapi program kompleks dengan sejumlah besar eksekusi dan data bersama sulit dianalisis, karena Anda perlu memeriksa semua eksekusi. <br><br><h2>  Model eksekusi kompetitif lainnya </h2><br>  Mengapa mempertimbangkan model pemrograman kompetitif lainnya? <br><br>  Menggunakan utas dan sinkronisasi primitif dapat menyelesaikan semua masalah.  Ini semua benar, tetapi masalahnya adalah bahwa kita memeriksa contoh dari selusin baris kode, di mana 4 baris kode melakukan pekerjaan yang bermanfaat. <br><br>  Dan di sana kami menjumpai banyak pertanyaan, sampai pada titik bahwa tanpa spesifikasi kami bahkan tidak dapat dengan benar menghitung semua hasil yang mungkin.  Utas dan sinkronisasi primitif adalah hal yang sangat sulit, penggunaannya tentu dibenarkan dalam beberapa kasus.  Pada dasarnya, kasus-kasus ini terkait dengan kinerja. <br><br>  Maaf, saya banyak merujuk ke Elizarov, tetapi apa yang bisa saya lakukan jika seseorang benar-benar memiliki pengalaman di bidang ini.  Jadi, ia memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> indah lainnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> "Jutaan kutipan per detik di Jawa murni," di mana ia mengatakan bahwa keadaan abadi adalah baik, tetapi saya tidak akan menyalin jutaan kutipan saya ke setiap aliran, maaf.  Tetapi tidak semua memiliki jutaan kutipan, banyak tentu saja memiliki tugas yang lebih sederhana.  Apakah ada model pemrograman kompetitif yang membuat Anda melupakan JMM dan masih menulis kode yang aman dan kompetitif? <br><br>  Jika Anda benar-benar tertarik dengan pertanyaan ini, saya sangat merekomendasikan buku Paul Butcher, “Seven Models of Competition in Seven Weeks.  Kami mengungkapkan rahasia arus. "  Sayangnya, tidak mungkin menemukan informasi yang cukup tentang pengarangnya, tetapi buku itu harus membuka mata Anda terhadap paradigma baru.  Sayangnya, saya tidak memiliki pengalaman dengan banyak model kompetisi lain, jadi saya mendapat ulasan dari buku ini. <br><br>  Menjawab pertanyaan di atas.  Sejauh yang saya mengerti, ada model pemrograman kompetitif yang setidaknya dapat sangat mengurangi kebutuhan akan pengetahuan tentang nuansa JMM.  Namun, jika ada keadaan dan aliran yang dapat berubah, maka jangan mengacaukan abstraksi atas mereka, masih akan ada tempat di mana aliran ini harus menyinkronkan akses ke negara.  Pertanyaan lain adalah Anda mungkin tidak perlu menyinkronkan akses sendiri, misalnya kerangka kerja dapat menjawabnya.  Tetapi seperti yang telah kami katakan, cepat atau lambat, abstraksi dapat terjadi. <br><br>  Anda dapat mengecualikan status yang dapat berubah sama sekali.  Dalam dunia pemrograman fungsional, ini adalah praktik normal.  Jika tidak ada struktur yang bisa berubah, maka mungkin tidak akan ada masalah dengan memori bersama menurut definisi.  Ada perwakilan bahasa fungsional di JVM, seperti Clojure.  Clojure adalah bahasa fungsional hibrid, karena masih memungkinkan Anda untuk mengubah struktur data, tetapi menyediakan alat yang lebih efisien dan lebih aman untuk ini. <br><br>  Bahasa fungsional adalah alat yang hebat untuk bekerja dengan kode kompetitif.  Secara pribadi, saya tidak menggunakannya, karena bidang kegiatan saya adalah pengembangan seluler, dan di sana itu tidak umum.  Meskipun pendekatan tertentu dapat diadopsi. <br><br>  Cara lain untuk bekerja dengan data yang bisa berubah adalah untuk mencegah berbagi data.  Aktor adalah model pemrograman seperti itu.  Aktor menyederhanakan pemrograman dengan tidak mengizinkan akses simultan ke data.  Ini dicapai oleh fakta bahwa fungsi yang melakukan pekerjaan pada satu saat dalam waktu dapat bekerja hanya dalam satu utas. <br><br>  Namun, seorang aktor dapat mengubah keadaan internal.  Mengingat bahwa pada saat berikutnya, aktor yang sama dapat dieksekusi di utas lain, ini bisa menjadi masalah.  Masalahnya dapat diselesaikan dengan berbagai cara, dalam bahasa pemrograman seperti Erlang atau Elixir, di mana model aktor merupakan bagian integral dari bahasa, Anda dapat menggunakan rekursi untuk memanggil aktor dengan status baru. <br><br>  Di Jawa, rekursi bisa terlalu mahal.  Namun, di Jawa ada kerangka kerja untuk pekerjaan yang mudah dengan model ini, mungkin yang paling populer adalah Akka.  Pengembang Akka telah mengurus semuanya, Anda dapat pergi ke bagian dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akka dan Java Memory Model</a> dan membaca tentang dua kasus ketika akses ke keadaan bersama dapat terjadi dari utas yang berbeda.  Tetapi yang lebih penting, dokumentasi mengatakan acara mana yang berhubungan dengan "terjadi sebelumnya."  Yaitu  ini berarti bahwa kita dapat mengubah keadaan aktor sebanyak yang kita suka, tetapi ketika kita menerima pesan berikutnya dan mungkin memprosesnya di utas lain, kita dijamin melihat semua perubahan yang dibuat di utas lain. <br><br><h2>  Mengapa model threading begitu populer? </h2><br>  Kami memeriksa dua model pemrograman kompetitif, bahkan ada lebih dari mereka yang membuat pemrograman kompetitif lebih mudah dan lebih aman. <br><br>  Tetapi mengapa kemudian benang dan kunci masih begitu populer? <br><br>  Saya pikir alasannya adalah kesederhanaan dari pendekatan, tentu saja, di satu sisi, mudah untuk membuat banyak kesalahan yang tidak terlihat dengan stream, menembak diri sendiri di kaki, dll.  Tetapi di sisi lain <b>, tidak ada yang rumit dalam arus, terutama jika Anda tidak memikirkan konsekuensinya</b> . <br><br>  Pada satu titik waktu, kernel dapat menjalankan satu instruksi (sebenarnya tidak, concurrency ada di level instruksi, tetapi sekarang tidak masalah), tetapi karena multitasking, bahkan pada mesin single-core, beberapa program dapat dieksekusi secara bersamaan (tentu saja semu secara bersamaan). <br><br>  Agar multitasking dapat berfungsi, Anda membutuhkan kompetisi.  Seperti yang telah kita ketahui, persaingan tidak mungkin terjadi tanpa beberapa aliran manajemen. <br><br>  Menurut Anda, berapa utas program yang berjalan pada prosesor ponsel quad-core harus secepat dan seresponif mungkin? <br><br>  Mungkin ada beberapa lusin.  Sekarang pertanyaannya adalah, mengapa kita membutuhkan begitu banyak utas untuk program yang berjalan pada perangkat keras yang memungkinkan Anda untuk mengeksekusi hanya 2-4 utas sekaligus? <br><br>  Untuk mencoba menjawab pertanyaan ini, anggaplah hanya program kami yang berjalan di perangkat dan tidak ada yang lain.  Bagaimana kita mengelola sumber daya yang disediakan untuk kita? <br><br>  Anda dapat memberikan satu inti untuk antarmuka pengguna, sisanya dari kernel untuk tugas-tugas lain.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika salah satu utas diblokir, misalnya, utas dapat mengakses pengontrol memori dan menunggu jawaban, maka kita akan mendapatkan kernel yang diblokir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teknologi apa yang ada untuk menyelesaikan masalah? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada utas di Jawa, kita dapat membuat banyak utas, dan kemudian utas lain akan dapat melakukan operasi sementara beberapa utas diblokir. Dengan alat seperti utas, kita dapat menyederhanakan hidup kita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan dengan utas tidak gratis, membuat utas biasanya membutuhkan waktu (ditentukan oleh kumpulan utas), memori dialokasikan untuknya, beralih di antara utas adalah operasi yang mahal. Tetapi relatif mudah diprogram dengan mereka, jadi ini adalah teknologi besar yang begitu banyak digunakan dalam bahasa umum, seperti Jawa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java umumnya menyukai stream, tidak perlu membuat untuk setiap aksi stream, ada hal-hal tingkat yang lebih tinggi, seperti Pelaksana, yang memungkinkan Anda untuk bekerja dengan kumpulan dan menulis kode yang lebih skalabel dan fleksibel. Streaming sangat nyaman, Anda dapat membuat permintaan pemblokiran ke jaringan dan menulis hasil pemrosesan pada baris berikutnya. Bahkan jika kita menunggu hasilnya selama beberapa detik, kita masih dapat melakukan tugas-tugas lain, karena sistem operasi akan mengatur distribusi waktu prosesor antar thread. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streaming populer tidak hanya dalam pengembangan backend, dalam pengembangan seluler dianggap cukup normal untuk membuat puluhan streaming sehingga Anda dapat memblokir streaming selama beberapa detik, menunggu data diunduh melalui jaringan atau data dari soket.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahasa seperti Erlang atau Clojure masih niche, dan karena itu model pemrograman kompetitif yang mereka gunakan tidak begitu populer. </font><font style="vertical-align: inherit;">Namun, perkiraan untuk mereka adalah yang paling optimis.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda mengembangkan pada platform JVM, maka Anda harus menerima aturan permainan yang ditunjukkan oleh platform. </font><font style="vertical-align: inherit;">Ini adalah satu-satunya cara untuk menulis kode multithread normal. </font><font style="vertical-align: inherit;">Sangat diinginkan untuk memahami konteks dari segala sesuatu yang terjadi, sehingga akan lebih mudah untuk menerima aturan permainan. </font><font style="vertical-align: inherit;">Bahkan lebih baik untuk melihat-lihat dan berkenalan dengan paradigma lain, meskipun Anda tidak bisa mendapatkan apa pun dari kapal selam, tetapi Anda dapat menemukan pendekatan dan alat baru.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bahan tambahan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mencoba untuk menempatkan teks pada tautan artikel ke sumber dari mana saya mendapatkan informasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, materi JMM mudah ditemukan di Internet. </font><font style="vertical-align: inherit;">Di sini saya akan memposting tautan ke beberapa materi tambahan yang terkait dengan JMM dan mungkin tidak langsung menarik perhatian saya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membaca</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog Alexey Shipilev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Saya tahu apa yang jelas, tapi itu dosa</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog Cheremin Ruslan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dia belum menulis secara aktif akhir-akhir ini, Anda perlu mencari entri lamanya di blog, percayalah itu sepadan - ada sumber</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Gleb Smirnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ada artikel bagus tentang multithreading dan model memori</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditinggalkan, tetapi penggalian arkeologis perlu dilakukan. </font><font style="vertical-align: inherit;">Secara umum, Roman melakukan banyak hal untuk mendidik orang-orang dalam teori pemrograman multithreaded, mencarinya di media.</font></font></li></ul><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah </font><b><font style="vertical-align: inherit;">Podcast</font></b><font style="vertical-align: inherit;"> yang menurut saya sangat menarik. </font><font style="vertical-align: inherit;">Mereka bukan tentang JMM, mereka tentang Neraka, yang terjadi di kelenjar. </font><font style="vertical-align: inherit;">Tapi setelah mendengarkan mereka, saya ingin mencium pencipta JMM, yang telah melindungi kita dari semua ini.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 62</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Away Alexander Titov dan Amir Ayupov, insinyur Intel dan Alexei Markin, programmer dari ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 63</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Away Alexei Markin, Programmer dari ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembekalan: # 107 Climbers Stories</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembekalan: # 154 Nyali - Serangan Tahun Baru</font></font></a> <br></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain pidato dari orang-orang yang disebutkan di atas, perhatikan juga video akademiknya.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pusat Ilmu Komputer - Kuliah 11. Model Memori dan Masalah Visibilitas</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teori dan praktik pemrograman multithreaded</font></font></a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440590/">https://habr.com/ru/post/id440590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440576/index.html">Perubahan penting pada CTE di PostgreSQL 12</a></li>
<li><a href="../id440582/index.html">Apakah mobil listrik ditarik ke bawah perusahaan mobil?</a></li>
<li><a href="../id440584/index.html">Apa yang salah dengan Raspberry Pi</a></li>
<li><a href="../id440586/index.html">Konsensus Eksonum: Cara Kerjanya</a></li>
<li><a href="../id440588/index.html">MIT belajar cara mentransmisikan suara dengan laser</a></li>
<li><a href="../id440592/index.html">Membuat Game AR dengan Vuforia</a></li>
<li><a href="../id440594/index.html">1C dan Yandex. Cloud Compute Cloud. Atas dan ke bawah</a></li>
<li><a href="../id440596/index.html">Flightradar24 - bagaimana cara kerjanya?</a></li>
<li><a href="../id440598/index.html">Penyelidikan InSight Martian berhasil bekerja di Planet Merah</a></li>
<li><a href="../id440600/index.html">Berapa banyak nama domain .com yang tidak digunakan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>