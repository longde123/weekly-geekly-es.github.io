<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈸 🤲🏽 🔂 Kami mengeluarkan perangkat lunak dari mikrokontroler yang dilindungi kata sandi Renesas M16C ⏫ 🐓 😠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya punya teman yang bergerak dalam perbaikan besi otomotif. Dia entah bagaimana membawakan saya mikrokontroler yang disolder dari unit kontrol peman...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mengeluarkan perangkat lunak dari mikrokontroler yang dilindungi kata sandi Renesas M16C</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469085/"><img src="https://habrastorage.org/webt/-f/lc/co/-flcco15l02rsp0smi3ha4ov224.jpeg"><br><br>  Saya punya teman yang bergerak dalam perbaikan besi otomotif.  Dia entah bagaimana membawakan saya mikrokontroler yang disolder dari unit kontrol pemanas otonom.  Dia mengatakan bahwa programmer-nya tidak mengambilnya, dan dia ingin dapat mentransfer firmware bolak-balik, karena  ada banyak balok, di besi mereka sering sama, tetapi unit yang mereka kontrol berbeda.  Dan tampaknya ada blok bukan yang salah, tetapi perangkat lunaknya berbeda dan Anda tidak bisa menggantinya.  Karena tugas itu menarik, saya memutuskan untuk mencari-cari.  Jika topiknya menarik bagi Anda, silakan, di bawah ... <a name="habracut"></a><br><br>  Subjek adalah M306N5FCTFP.  Ini adalah mikrokontroler dari grup M16C / 6N5.  Inti M16C / 60 dikembangkan oleh Mitsubishi, dan sebagai  Sejak 2003, penerus perusahaan ini dalam hal MK adalah Renesas, sekarang mikrokontroler ini dikenal dengan merek ini. <br><br><h4>  Sedikit tentang mikrokontroler itu sendiri </h4><br>  Kerikil adalah mikrokontroler 16-bit dalam paket QFP 100-pin.  Kernel memiliki 1 MB ruang alamat, frekuensi clock 20 MHz untuk kinerja otomotif.  Perangkat periferal juga sangat luas: dua timer 16-bit dan kemungkinan menghasilkan PWM 3-fase untuk mengendalikan motor, segala macam UART, SPI, I2C secara alami, 2 saluran DMA, terdapat pengontrol CAN2.0B bawaan, serta PLL.  Menurut saya itu sangat baik untuk orang tua itu.  Berikut ini adalah bagan ikhtisar dari dokumentasi: <br><br><img src="https://habrastorage.org/webt/mb/we/0z/mbwe0zgfqxwxd2ihcirztjtepqg.png"><br><br>  Karena tugas saya adalah menghapus perangkat lunak, itu juga sangat tertarik pada memori.  MK ini diproduksi dalam dua versi: bertopeng dan Flash.  Saya mendapatkan, seperti yang disebutkan di atas, M306N5FCTFP.  Tentang dia, deskripsi mengatakan sebagai berikut: <br><br><ul><li>  Versi memori flash </li><li>  128 KBytes + 4K (tambahan 4K - yang disebut blok A sebagai hadiah kepada pengguna untuk menyimpan data, tetapi juga dapat menyimpan program) </li><li>  V-ver.  (versi otomotif dengan kisaran + 125 ° C) </li></ul><br><h4>  Cara menarik dari perangkat apa yang diseret pengembang </h4><br>  Wajar jika Anda mulai mencoba mendapatkan sesuatu dari mikrokontroler dengan mempelajari mekanisme yang diintegrasikan oleh pengembang chip untuk tugas pemrograman memori.  Manual menyatakan bahwa pabrikan dengan baik hati menempatkan bootloader di dalam memori untuk kebutuhan pemrograman dalam-rangkaian perangkat. <br><br><img src="https://habrastorage.org/webt/q6/yq/ol/q6yqolkgde-5fd6fdcwm_y6skc8.png"><br><br>  Seperti yang dapat Anda lihat dari gambar di atas, memori dibagi menjadi 2 bagian: area pengguna, dan area bootloader.  Pada yang kedua, bootloader default dimuat dari pabrik, yang dapat menulis, membaca, menghapus memori pengguna dan berkomunikasi melalui antarmuka asinkron, sinkron, atau BISA.  Diindikasikan dapat ditulis ulang untuk Anda sendiri, atau tidak dapat ditulis ulang.  Pada akhirnya, ini mudah diverifikasi dengan mencoba mengetuk bootloader standar setidaknya melalui UART ... Ke depan: produsen pemanas tidak repot-repot dengan bootloader-nya, sehingga Anda dapat menggali lebih jauh ke arah ini.  Segera lakukan pemesanan bahwa masih ada metode pemrograman paralel, tetapi sejak itu  Saya tidak memiliki programmer untuk ini, saya tidak mempertimbangkan opsi ini. <br><br>  Memasuki mode operasi bootloader disediakan oleh kombinasi tertentu pada input CNVSS, P5_0, P5_5 selama pengaturan ulang perangkat keras.  Selanjutnya, tulis utilitas Anda sendiri untuk menyalin isi memori, atau gunakan yang sudah jadi.  Renesas menyediakan utilitas sendiri, yang disebut "M16C Flash Starter," tetapi memiliki fungsi baca yang berkurang.  Itu tidak menyimpan apa yang dibaca ke disk, tetapi membandingkannya dengan file dari disk.  Yaitu  sebenarnya, ini bukan bacaan, tetapi verifikasi.  Namun, ada utilitas gratis Jerman bernama M16C-Flasher, yang dapat membaca firmware.  Secara umum, toolkit awal diambil. <br><br><h4>  Tentang perlindungan baca </h4><br><img src="https://habrastorage.org/webt/oe/zd/-l/oezd-l9m2zan5js3uwr0obomgta.png"><br><br>  Semuanya akan sangat sederhana jika bootloader tidak memberikan perlindungan terhadap akses tidak sah.  Saya hanya akan memberikan terjemahan yang sangat gratis dari manual. <br><br>  <i>Fungsi Verifikasi ID</i> <i><br><br></i>  <i>Digunakan dalam mode pertukaran serial dan CAN.</i>  <i>Pengenal yang dikirimkan oleh programmer dibandingkan dengan pengenal yang direkam dalam memori flash.</i>  <i>Jika pengidentifikasi tidak cocok, perintah yang dikirim oleh programmer tidak diterima.</i>  <i>Namun, jika 4 byte dari vektor reset FFFFFFFFh, pengidentifikasi tidak dibandingkan, yang memungkinkan semua perintah dieksekusi.</i>  <i>Pengenal adalah 7 byte yang disimpan secara berurutan, mulai dari byte pertama, di alamat 0FFFDFh, 0FFFE3h, 0FFFEBh, 0FFFEFh, 0FFFF3h, 0FFFF7h, dan 0FFFFBh.</i> <br><br>  Jadi, untuk mengakses program, Anda perlu mengetahui 7 byte yang dihargai.  Sekali lagi, melihat ke depan, saya terhubung ke MK menggunakan "M16C Flash Starter" yang sama dan memastikan bahwa kombinasi nol dan FF tidak berfungsi dan masalah ini harus dipecahkan entah bagaimana.  Sebuah ide dengan serangan melalui saluran pihak ketiga segera muncul di sini.  Saya sudah mulai berpura-pura menjadi jilbab di kepala saya, yang memungkinkan saya untuk mengukur arus di sirkuit daya, tetapi memutuskan bahwa internet itu besar dan sebagian besar sepeda sudah ditemukan.  Setelah mendorong beberapa pencarian, saya dengan cepat menemukan di hackaday.io proyek Serge 'q3k' Bazanski, berjudul "Reverse engineering Toshiba R100 BIOS".  Dan dalam kerangka kerja proyek ini, penulis pada dasarnya memecahkan masalah yang sama persis: mengekstraksi firmware dari MK M306K9FCLR.  Apalagi - pada saat itu tugasnya sudah berhasil diselesaikan olehnya.  Di satu sisi, saya sedikit kesal - sebuah teka-teki yang menarik tidak diselesaikan oleh saya.  Di sisi lain, tugas berubah dari pencarian kerentanan, menjadi eksploitasi, yang menjanjikan solusi yang jauh lebih cepat. <br><br>  Singkatnya, q3k, dengan logika yang persis sama, memulai penelitian dengan analisis konsumsi saat ini, dalam hal ini itu dalam kondisi yang jauh lebih menguntungkan, karena  dia punya ChipWhisperer, aku masih belum mendapatkan benda ini.  Tapi sejak itu  penyelidikan pertamanya untuk menghapus konsumsi saat ini ternyata tidak sesuai dan dia tidak bisa mengisolasi sesuatu yang berguna dari kebisingan, dia memutuskan untuk mencoba serangan sederhana pada waktu respons.  Faktanya adalah bahwa bootloader menarik output SIBUK selama pelaksanaan perintah untuk memberi tahu tuan rumah bahwa ia sibuk atau siap untuk menjalankan perintah berikutnya.  Menurut asumsi q3k, mengukur waktu dari mentransmisikan bit terakhir dari pengidentifikasi untuk menghapus bendera yang sibuk dapat berfungsi sebagai sumber informasi selama enumerasi.  Saat memeriksa asumsi ini dengan menghitung byte pertama kunci, penyimpangan waktu hanya ditemukan dalam satu kasus - ketika byte pertama sama dengan FFh.  Untuk kenyamanan mengukur waktu, penulis bahkan memperlambat MK dengan mematikan resonator kuarsa dan menerapkan gelombang persegi 666 kHz ke input jam untuk menyederhanakan prosedur pengukuran.  Setelah itu, pengidentifikasi berhasil dipilih dan perangkat lunak diambil. <br><br><h4>  Pancake pertama - garu </h4><br>  Ha!  Saya pikir ... Sekarang saya dengan cepat memusatkan program ke STM32VLDiscovery c STM32F100 saya, yang akan mengirim kode dan mengukur waktu respons, dan memuntahkan hasil pengukuran di terminal.  Karena  Papan tempat memotong roti dengan pengontrol target sebelumnya terhubung ke PC melalui adaptor USB-UART, agar tidak mengubah apa pun di papan tempat memotong roti, kami akan bekerja dalam mode asinkron. <br><br><img src="https://habrastorage.org/webt/4h/j0/ex/4hj0ext4dvwval--yospml-loso.png"><br><br>  Ketika pada bootloader mulai, input CLK1 ditarik ke tanah, ia menyadari bahwa mereka menginginkan komunikasi asinkron darinya.  Itu sebabnya saya menggunakannya - suspender sudah disolder dan saya hanya menghubungkan dua papan dengan kabel: Discovery dan papan tempat memotong roti dengan target M306. <br><br>  <i>Catatan tentang harmonisasi level:</i> <i><br><br></i>  <i>Karena</i>  <i>Karena M16 memiliki level TTL pada terminal, dan STM32 memiliki LVTTL (disederhanakan, lihat datasheet untuk detail), maka pencocokan level diperlukan.</i>  <i>Karena</i>  <i>ini bukan perangkat yang, seperti baterai terkenal, harus bekerja, bekerja dan bekerja, tetapi pada kenyataannya itu menghubungkan sekali di atas meja, maka saya tidak repot-repot dengan penerjemah level: MK lima volt mencerna level output dari STM32, dalam arti 3 volt yang dirasakannya sebagai "1" , output dari M16 diumpankan ke input STM32 toleran 5V sehingga tidak terasa buruk, dan kami tidak lupa untuk meletakkan kaki yang menarik RESET M16 ke mode drain terbuka.</i>  <i>Saya lupa, dan ini + 2 jam untuk celengan waktu yang hilang.</i> <i><br></i>  <i>Minimal ini cukup untuk memahami kelenjar satu sama lain.</i> <br><br>  Logika dari perangkat lunak penyerang adalah sebagai berikut: <br><br><ol><li>  Kami membuat koneksi dengan controller.  Untuk melakukan ini, Anda harus menunggu hingga reset selesai, kemudian mengirimkan 16 karakter nol dengan interval lebih dari 20 ms.  Ini untuk mengetahui algoritma untuk secara otomatis menentukan nilai tukar, karena  antarmuka asinkron, dan MK tidak tahu apa-apa tentang frekuensinya.  Kecepatan awal pemancar harus 9600 baud, pada kecepatan inilah penghitung loader menghitung.  Setelah itu, jika diinginkan, Anda dapat meminta nilai tukar yang berbeda dari lima yang tersedia di kisaran 9600-115200 (walaupun dalam kasus saya loader menolak untuk bekerja pada 115200).  Saya tidak perlu mengubah kecepatan, jadi saya hanya meminta versi bootloader untuk mengontrol sinkronisasi.  Kami melewati FBh, loader merespons dengan garis seperti "VER.1.01". <br></li><li>  Kami mengirim perintah "membuka", yang berisi iterasi kunci saat ini, dan mengukur waktu sampai bendera sibuk dihapus. <br><img src="https://habrastorage.org/webt/wg/qh/ne/wgqhnehwy7ycyxmwenvyx0n2lwk.png"><br>  Perintah ini terdiri dari kode F5h, tiga byte alamat di mana area pengenal dimulai (dalam kasus saya, untuk kernel M16C, 0FFFDFh), panjang (07h), dan pengidentifikasi itu sendiri. <br></li><li>  Kami mengukur waktu antara pengiriman bit terakhir dari pengidentifikasi dan penghapusan bendera yang sibuk. <br></li><li>  Kami meningkatkan byte kunci yang sedang diurutkan (KEY1 pada tahap awal), kami kembali ke langkah 2 hingga kami menyortir semua nilai 255 dari byte saat ini. <br></li><li>  Kami mereset statistik ke terminal (baik, atau kami melakukan analisis "di papan"). <br></li></ol><br>  Untuk berkomunikasi dengan target MK, saya menggunakan USART di STM32, untuk mengukur waktu - timer dalam mode Capture Input.  Satu-satunya hal, untuk kesederhanaan, saya tidak mengukur waktu antara bit terakhir dari kunci dan penghapusan bendera, tetapi antara awal transmisi dan bendera.  Alasannya adalah bahwa bit terakhir bisa berubah, dan dalam mode asinkron tidak ada yang bisa dilampirkan ke input pengambilan.  Pada saat yang sama, UART adalah perangkat keras dan waktu transmisi pada dasarnya identik dan tidak boleh ada kesalahan nyata. <br><br>  Akibatnya, untuk semua nilai, hasilnya identik.  Sama sekali identik.  Frekuensi jam dari timer adalah 24 MHz, masing-masing, resolusi waktu adalah 41,6 ns.  Baiklah, ok, saya mencoba memperlambat target MK.  Tidak ada yang berubah.  Di sini muncul pertanyaan di kepala saya: apa yang saya lakukan salah, seperti yang dilakukan q3k?  Setelah perbandingan, perbedaannya ditemukan: ia menggunakan antarmuka pertukaran sinkron (SPI), dan saya tidak sinkron (UART).  Dan di suatu tempat di sini, saya menarik perhatian pada momen yang saya lewatkan di awal.  Bahkan pada diagram pengkabelan untuk mode bootloader sinkron dan asinkron, output yang siap disebutkan secara berbeda: <br><br><img src="https://habrastorage.org/webt/d0/js/gb/d0jsgbifm7vo1jgbypc70elfoqu.png"><br><br>  Dalam sinkron itu adalah "SIBUK", di asinkron itu adalah "Monitor".  Kami melihat tabel “Fungsi Output dalam Mode I / O Seri Serial”: <br><br><img src="https://habrastorage.org/webt/ja/qk/zh/jaqkzhx4dielaovn5d3n9gykcxo.png"><br>  <i>"Semyon Semenych ..."</i> <br><br>  Sepele, yang awalnya terlewatkan, membawa tempat yang salah.  Sebenarnya, jika dalam mode sinkron ini persis flag bootloader sibuk, maka dalam mode asinkron (yang serial I / O mode 2) hanyalah "tanda bahayanya" untuk menunjukkan operasi.  Mungkin, secara umum, sinyal perangkat keras kesiapan transceiver, dan karenanya keakuratan yang luar biasa. <br><br>  Secara umum, kami menyolder resistor pada pin SCLK dari tanah ke VCC, menyolder kawat di sana, menghubungkan semuanya ke SPI dan memulai ... <br><br><h4>  Sukses! </h4><br><img src="https://habrastorage.org/webt/qh/ce/l1/qhcel11fibxpkxoa8zibgerddgc.png"><br><br>  Dalam mode sinkron, semuanya hampir sama, hanya tidak ada prosedur awal untuk membuat koneksi yang diperlukan, sinkronisasi disederhanakan, dan penangkapan waktu dapat dilakukan lebih akurat.  Jika saya segera memilih mode ini, saya akan menghemat waktu ... Saya sekali lagi tidak menyulitkan dan mengukur waktu dari bit terakhir, tetapi memulai timer sebelum memulai transfer byte terakhir kunci, yaitu.  kita menyalakan timer dan mengirimkannya ke pemancar KEY7 (pada tangkapan layar di atas, dari penganalisa logika, Anda dapat melihat jarak antara kursor. Ini adalah interval waktu yang diukur). <br><br>  Ini lebih dari cukup untuk identifikasi yang sukses.  Berikut adalah penghitungan satu byte: <br><br><img src="https://habrastorage.org/webt/dz/zx/l_/dzzxl_-wct4qfyr0gqpmuaqlos8.png"><br><br>  Pada sumbu x, kami memiliki jumlah jumlah diskrit, pada sumbu y, masing-masing, nilai kunci yang dikirimkan.  Rasio signal-to-noise sedemikian rupa sehingga bahkan tidak ada filter yang diperlukan, sama seperti di sekolah dalam pelajaran informatika: kami menemukan maksimum dalam array dan pergi ke pemilihan byte berikutnya.  6 byte pertama dipilih dengan mudah dan cepat, sedikit lebih sulit dengan yang terakhir: itu hanya penghilang kurang ajar yang tidak bekerja, Anda perlu mengatur ulang "korban" sebelum setiap upaya.  Akibatnya, dibutuhkan sekitar 400 ms untuk setiap upaya, dan pencarian dalam kasus terburuk, di wilayah satu setengah menit.  Tapi ini yang terburuk.  Setelah setiap upaya, kami meminta status dan, segera setelah kami menebak, berhenti.  Pada awalnya, saya biasanya hanya dengan cepat pergi ke pengenal dengan pena, memasukkan output konsol ke excel dan merencanakan grafik, terlebih lagi karena itu adalah tugas satu kali, tetapi untuk artikel saya memutuskan untuk menambahkan iterasi otomatis, demi konsol yang indah ... <br><br><img src="https://habrastorage.org/webt/pd/dj/en/pddjenvq4joplvadcxy3lpd9gu0.png"><br><br>  Tentu saja, jika pengembang menghapus bootloader (diganti dengan miliknya sendiri), itu tidak akan mudah untuk keluar, tetapi dalam elektronik otomotif, MK sering tidak ditutup sama sekali.  Secara khusus, di unit kontrol dari pemanas lain, di mana V850 dari Renesas yang sama dipasang, semuanya diputuskan dengan menyolder sepasang kabel dan menyalin firmware dengan utilitas standar.  Ini adalah seluruh mesin cryptocurrency di dunia ECU.  Rupanya produsen tidak menyukai fenomena tuning chip dan jenis gangguan lainnya ... Meskipun ini seperti perlombaan baju besi dan kerang - kelenjar lebih curam, lebih mahal, tetapi tidak ada pemenang ... <br><br>  Referensi: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.dataman.com/media/datasheet/Renesas/M16C6N5Group.pdf</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://hackaday.io/project/723-reverse-engineering-toshiba-r100-bios/log/51302-ec-firmware-dumped</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://q3k.org/slides-recon-2018.pdf</a> <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469085/">https://habr.com/ru/post/id469085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469071/index.html">Inteligensi Buatan Microsoft menguasai mahjong</a></li>
<li><a href="../id469073/index.html">Derivatif Terpisah atau Ringkasan Cara Menjumlahkan Seri</a></li>
<li><a href="../id469075/index.html">DLR Grokay</a></li>
<li><a href="../id469077/index.html">Kursus Python Baru Microsoft [dalam bahasa Inggris]</a></li>
<li><a href="../id469079/index.html">Python dalam Visual Studio Code: September Extension Extension</a></li>
<li><a href="../id469087/index.html">MVCC di PostgreSQL-2. Fork, file, halaman</a></li>
<li><a href="../id469093/index.html">Perbandingan perpustakaan CLI yang kurang populer dan tidak terlalu: cliff, plac, plumbum, dan lain-lain (bagian 2)</a></li>
<li><a href="../id469095/index.html">ML.NET dan Pembaruan Model Builder Dirilis: Apa yang Baru</a></li>
<li><a href="../id469097/index.html">Server web CentOS 8 dengan php7, node.js dan redis</a></li>
<li><a href="../id469099/index.html">Menguji tugas saat wawancara dengan pengembang - apakah masuk akal?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>