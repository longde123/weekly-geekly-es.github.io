<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍✈️ 🏖️ 🐉 Memahami kode genetik cryptocotic 🐗 👩🏿‍🤝‍👨🏻 👧🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... dan belajar bekerja dengan alat pengembang Ethereum menggunakan contoh nyata. 

 Bagian nol: objek muncul 
 Saya baru saja menyelesaikan kuliah sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami kode genetik cryptocotic</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/409345/">  ... dan belajar bekerja dengan alat pengembang Ethereum menggunakan contoh nyata. <br><br><h3>  Bagian nol: objek muncul </h3><br>  Saya baru saja menyelesaikan kuliah saya tentang kursus pengembangan aplikasi berbasis Ethereum terdesentralisasi dalam Soliditas dalam Bahasa Mandarin.  Saya memberikannya di waktu luang saya untuk meningkatkan tingkat pengetahuan tentang blockchain dan kontrak pintar di antara komunitas pengembang Cina.  Selama bekerja, saya berteman dengan beberapa siswa. <br><br>  Dan tepat di akhir kursus, kami tiba-tiba menemukan diri kami dikelilingi oleh makhluk-makhluk ini: <br><br><img src="https://habrastorage.org/webt/ev/e-/ov/eve-ovga3bt6vx11ichn6jmkufm.png"><br><br>  <i>Gambar dari cryptokitties.co</i> <br><br>  Seperti kebanyakan orang yang mengalami fenomena ini, kami juga tidak bisa menahan cryptocreations lucu ini dan dengan cepat menjadi kecanduan permainan.  Kami suka mengeluarkan kucing baru dan kami bahkan mengganti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode itik dengan metode kripto</a> .  Saya percaya bahwa kecanduan game itu buruk, tetapi tidak dalam kasus ini, karena hasrat untuk membesarkan anak kucing dengan cepat membawa kita pada pertanyaan: <br><br><h3>  Bagaimana kucing crypto tertentu mendapatkan gen mereka? </h3><br>  Kami memutuskan untuk mencurahkan Sabtu malam untuk menemukan jawabannya, dan kami pikir kami berhasil membuat beberapa kemajuan dalam pengembangan perangkat lunak yang memungkinkan kami untuk menentukan mutasi genetik anak kucing kripto yang baru lahir sebelum mereka dilahirkan.  Dengan kata lain, program ini dapat membantu Anda memeriksa dan menentukan waktu yang tepat untuk pembuahan ibu kucing, dan dengan demikian mendapatkan yang paling menarik dari kemungkinan mutasi. <br><br>  Kami menerbitkan materi ini dengan harapan bahwa itu akan melayani semua orang sebagai artikel pengantar untuk berkenalan dengan alat pengembangan Ethereum yang sangat berguna, seperti halnya anak kucing crypto sendiri memungkinkan banyak orang yang tidak terbiasa dengan blockchain untuk bergabung dengan jajaran pengguna cryptocurrency. <a name="habracut"></a><br><br><h3>  Bagian satu: logika tingkat tinggi menghasilkan anak kucing kecil </h3><br>  Pertama-tama, kami bertanya pada diri sendiri: bagaimana kelahiran anak kucing crypto? <br><br>  Untuk menjawab pertanyaan ini, kami menggunakan konduktor blockchain Etherscan yang luar biasa, yang memungkinkan kami melakukan lebih dari sekadar "mempelajari parameter dan isi blok".  Jadi kami menemukan kode sumber untuk kontrak CryptoKittiesCore: <br><br><img src="https://habrastorage.org/webt/co/od/v1/coodv1ao8ns32llhof2bhbpp3h8.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code</a> <br><br>  Harap dicatat bahwa kontrak yang diperluas sebenarnya sedikit berbeda dari yang digunakan dalam program hadiah.  Menurut kode ini, bayi kucing terbentuk dalam dua langkah: 1) induk kucing dibuahi oleh kucing;  2) beberapa saat kemudian, ketika periode pematangan janin berakhir, fungsi kelahiran kembali disebut.  Fungsi ini biasanya dipanggil oleh setan proses tertentu, tetapi, seperti yang akan Anda lihat nanti, untuk mendapatkan mutasi yang menarik, Anda harus memilih dengan benar blok tempat anak kucing Anda dilahirkan. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">giveBirth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 _matronId)</span></span></span><span class="hljs-function"> external whenNotPaused </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256)</span></span></span><span class="hljs-function"> </span></span>{ Kitty storage matron = kitties[_matronId]; <span class="hljs-comment"><span class="hljs-comment">// ,  - . require(matron.birthTime != 0); // ,       ! require(_isReadyToGiveBirth(matron)); //      -. uint256 sireId = matron.siringWithId; Kitty storage sire = kitties[sireId]; // ,         uint16 parentGen = matron.generation; if (sire.generation &gt; matron.generation) { parentGen = sire.generation; } //     . uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);</span></span></code> </pre> <br>  Dalam kode di atas, Anda dapat dengan jelas melihat bahwa gen anak kucing yang baru lahir ditentukan tepat pada saat kelahiran dengan memanggil fungsi mixGenes dari kontrak pintar eksternal genScience.  Fungsi ini membutuhkan tiga parameter: gen ibu, gen ayah dan nomor blok di mana kucing akan siap untuk melahirkan. <br><br>  Anda mungkin akan memiliki pertanyaan logis, mengapa gen tidak ditentukan pada saat pembuahan, seperti halnya di dunia nyata?  Seperti yang akan Anda lihat dalam perjalanan narasi berikutnya, ini memungkinkan Anda untuk membela secara agak elegan dari upaya untuk memprediksi dan mendekripsi gen.  Pendekatan ini menghilangkan kemungkinan prediksi gen kitten 100% akurat sebelum fakta kehamilan kucing-ibu dicatat dalam blockchain.  Dan bahkan jika Anda bisa mengetahui kode pasti yang bertanggung jawab untuk pencampuran gen, ini tidak akan memberi Anda keuntungan apa pun. <br><br>  Meski begitu, pada awalnya kami belum mengetahui hal ini, jadi mari kita lanjutkan.  Sekarang kita perlu mencari tahu alamat kontrak genScience.  Untuk melakukan ini, gunakan MyEtherWallet: <br><br> <a href=""><img src="https://habrastorage.org/webt/nf/fa/yl/nffaylnytgmybdkavya0so0ugmi.png"></a> <br><br>  <i>Alamat Kontrak GeneScience</i> <br><br>  Inilah yang terlihat seperti bytecode kontrak: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">0x60606040526004361061006c5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630d9f5aed81146100715780631597ee441461009f57806354c15b82146100ee57806361a769001461011557806377a74a201461017e575b600080fd5b341561007c57600080fd5b61008d6004356024356044356101cd565b604051908152602001604051809</span></span>........</code> </pre> <br>  Dengan penampilannya, Anda tidak dapat mengatakan bahwa sebagai hasilnya, sesuatu yang lucu seperti anak kucing muncul di semua hal, tetapi kami sangat beruntung bahwa ini adalah alamat publik, dan kami tidak perlu mencarinya di repositori).  Bahkan, kami percaya bahwa itu tidak boleh dibuat begitu mudah diakses.  Jika pengembang benar-benar ingin memastikan alamat kontraknya benar, mereka harus menggunakan fungsi checkScienceAddress, tetapi kami tidak akan diganggu. <br><br><h3>  Bagian dua: runtuhnya hipotesis sederhana </h3><br>  Jadi apa yang ingin kita capai pada akhirnya?  Harus dipahami bahwa kita tidak menetapkan tujuan untuk mengkompilasi bytecode, mengubahnya menjadi kode soliditas yang dapat dibaca manusia.  Kita memerlukan metode yang murah (tanpa perlu membayar untuk transaksi dalam blockchain tempur) untuk menentukan gen anak kucing, asalkan kita tahu siapa orang tuanya.  Ini yang akan kita lakukan. <br><br>  Untuk memulai, mari gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat opcode</a> Etherscan untuk analisis cepat.  Ini terlihat seperti ini: <br><br> <a href=""><img src="https://habrastorage.org/webt/m6/nt/72/m6nt72740bwhn4qz6dlkz0pc6qi.png"></a> <br><br>  <i>Jauh lebih jelas</i> <br><br>  Kami mengikuti aturan emas penguraian kode assembler: kami mulai dengan hipotesis sederhana dan berani tentang perilaku program dan, alih-alih mencoba memahami kerjanya secara keseluruhan, kami fokus pada mengonfirmasi asumsi yang dibuat.  Kami akan membahas bytecode untuk menjawab beberapa pertanyaan: <br><br><ol><li>  Apakah ini menggunakan stempel waktu?  Tidak, karena opcode TIMESTAMP hilang.  Jika ada kecelakaan sederhana di dalamnya, maka sumbernya pasti opcode lain. </li><li>  Apakah hash blok digunakan?  Ya, BLOCKHASH terjadi dua kali.  Oleh karena itu, keacakan, jika ada, dapat muncul dari opcode mereka, tetapi kami belum yakin tentang ini. </li><li>  Apakah ada hash yang digunakan sama sekali?  Ya, ada SHA3.  Namun, tidak jelas apa yang dia lakukan. </li><li>  Apakah pengirim SMS digunakan?  Tidak, karena opcode Penelepon tidak ada.  Oleh karena itu, tidak ada kontrol akses yang diterapkan pada kontrak. </li><li>  Apakah ada kontrak eksternal yang digunakan?  Tidak, tidak ada PANGGILAN opcode. </li><li>  Apakah COINBASE digunakan?  Tidak, dan karenanya kami mengecualikan sumber acak lain yang mungkin. </li></ol><br>  Setelah menerima jawaban untuk pertanyaan-pertanyaan ini, kami mengajukan dan bermaksud menguji hipotesis sederhana: hasil mixGene ditentukan oleh tiga dan hanya tiga parameter input dari fungsi ini.  Jika demikian, maka kita bisa menggunakan kontrak ini secara lokal, terus memanggil fungsi ini dengan parameter yang menarik bagi kita, dan kemudian, mungkin, kita bisa mendapatkan kit gen kitten bahkan sebelum pembuahan induk kucing. <br><br>  Untuk memverifikasi asumsi ini, kami memanggil fungsi mixGene di jaringan utama dengan tiga parameter acak: 1111115, 80, 40 dan mendapatkan beberapa hasil X. Selanjutnya, gunakan bytecode ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">truffle dan testrpc</a> .  Jadi kemalasan kami mengarah pada cara truffle yang agak tidak standar. <br><br><pre> <code class="java hljs">contract GeneScienceSkeleton { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mixGenes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 genes1, uint256 genes2, uint256 targetBlock)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br>  Kita mulai dengan kerangka kontrak, letakkan di struktur folder dari kerangka truffle dan jalankan kompilasi truffle.  Namun, alih-alih secara langsung memindahkan kontrak kosong ini ke testrpc, kami mengganti bytecode kontrak di folder build dengan bytecode yang diperluas secara nyata dan bytecode kontrak genScience.  Ini adalah cara yang tidak biasa namun cepat jika Anda ingin menggunakan kontrak dengan hanya bytecode dan beberapa antarmuka terbuka terbatas untuk pengujian lokal.  Setelah itu, kami langsung memanggil Mixgenes dengan parameter 1111115, 80, 40, dan sayangnya kami mendapatkan kesalahan dengan jawaban kembali sebagai tanggapan.  Ok, lihat lebih dalam.  Seperti yang kita ketahui, tanda tangan dari fungsi mixGene adalah 0x0d9f5aed, jadi kami mengambil pena dan kertas dan melacak eksekusi bytecode, mulai dari titik masuk fungsi ini untuk memperhitungkan perubahan dalam tumpukan dan penyimpanan.  Setelah beberapa JUMP, kami menemukan diri kami di sini: <br><br><pre> <code class="java hljs">[<span class="hljs-number"><span class="hljs-number">497</span></span>] DUP1 [<span class="hljs-number"><span class="hljs-number">498</span></span>] NUMBER [<span class="hljs-number"><span class="hljs-number">499</span></span>] DUP14 [<span class="hljs-number"><span class="hljs-number">500</span></span>] SWAP1 [<span class="hljs-number"><span class="hljs-number">501</span></span>] GT [<span class="hljs-number"><span class="hljs-number">504</span></span>] PUSH2 <span class="hljs-number"><span class="hljs-number">0x01fe</span></span> [<span class="hljs-number"><span class="hljs-number">505</span></span>] JUMPI [<span class="hljs-number"><span class="hljs-number">507</span></span>] PUSH1 <span class="hljs-number"><span class="hljs-number">0x00</span></span> [<span class="hljs-number"><span class="hljs-number">508</span></span>] DUP1 [<span class="hljs-number"><span class="hljs-number">509</span></span>] <span class="hljs-string"><span class="hljs-string">'fd'</span></span>(Unknown Opcode)</code> </pre> <br>  Dilihat oleh isi dari baris-baris ini, jika jumlah blok saat ini kurang dari parameter ketiga, maka revert () dipanggil.  Nah, ini perilaku yang cukup masuk akal: memanggil fungsi nyata dalam game dengan nomor blok dari masa depan tidak mungkin dan ini logis. <br><br>  Verifikasi input ini mudah dielakkan: kami hanya menambang beberapa blok di testrpc dan memanggil fungsi lagi.  Kali ini, fungsi berhasil mengembalikan Y. <br><br>  Namun sayangnya X! = Y <br><br>  Terlalu buruk  Ini berarti bahwa hasil dari eksekusi fungsi tidak hanya bergantung pada parameter input, tetapi juga pada keadaan blockchain dari jaringan utama, yang, tentu saja, berbeda dari keadaan testrpc blockchain palsu. <br><br><h3>  Bagian Tiga: menyingsingkan lengan baju kami dan menggali ke dalam tumpukan </h3><br>  Baiklah  Jadi sekarang saatnya menyingsingkan lengan baju Anda.  Kertas tidak lagi cocok untuk melacak status tumpukan.  Jadi untuk pekerjaan yang lebih serius, kami akan meluncurkan pembongkar EVM yang sangat berguna yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">evmdis</a> . <br><br>  Dibandingkan dengan kertas dan pena, ini adalah langkah maju yang nyata.  Mari kita lanjutkan dengan apa yang kita hentikan di bab terakhir.  Berikut ini adalah kesimpulan yang menggembirakan dengan evmdis: <br><br><pre> <code class="java hljs">............. :label22 # Stack: [@<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x88</span></span> @<span class="hljs-number"><span class="hljs-number">0x85</span></span> @<span class="hljs-number"><span class="hljs-number">0x82</span></span> :label3 @<span class="hljs-number"><span class="hljs-number">0x34</span></span>] <span class="hljs-number"><span class="hljs-number">0x1EB</span></span> PUSH(<span class="hljs-number"><span class="hljs-number">0x0</span></span>) <span class="hljs-number"><span class="hljs-number">0x1ED</span></span> DUP1 <span class="hljs-number"><span class="hljs-number">0x1EE</span></span> DUP1 <span class="hljs-number"><span class="hljs-number">0x1EF</span></span> DUP1 <span class="hljs-number"><span class="hljs-number">0x1F0</span></span> DUP1 <span class="hljs-number"><span class="hljs-number">0x1F1</span></span> DUP1 <span class="hljs-number"><span class="hljs-number">0x1F3</span></span> DUP13 <span class="hljs-number"><span class="hljs-number">0x1F9</span></span> JUMPI(:label23, NUMBER() &gt; POP()) # Stack: [<span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x88</span></span> @<span class="hljs-number"><span class="hljs-number">0x85</span></span> @<span class="hljs-number"><span class="hljs-number">0x82</span></span> :label3 @<span class="hljs-number"><span class="hljs-number">0x34</span></span>] <span class="hljs-number"><span class="hljs-number">0x1FA</span></span> PUSH(<span class="hljs-number"><span class="hljs-number">0x0</span></span>) <span class="hljs-number"><span class="hljs-number">0x1FC</span></span> DUP1 <span class="hljs-number"><span class="hljs-number">0x1FD</span></span> REVERT() :label23 # Stack: [<span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x88</span></span> @<span class="hljs-number"><span class="hljs-number">0x85</span></span> @<span class="hljs-number"><span class="hljs-number">0x82</span></span> :label3 @<span class="hljs-number"><span class="hljs-number">0x34</span></span>] <span class="hljs-number"><span class="hljs-number">0x1FF</span></span> DUP13 <span class="hljs-number"><span class="hljs-number">0x200</span></span> PUSH(BLOCKHASH(POP())) <span class="hljs-number"><span class="hljs-number">0x201</span></span> SWAP11 <span class="hljs-number"><span class="hljs-number">0x202</span></span> POP() <span class="hljs-number"><span class="hljs-number">0x203</span></span> DUP11 <span class="hljs-number"><span class="hljs-number">0x209</span></span> JUMPI(:label25, !!POP()) # Stack: [<span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x200</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x88</span></span> @<span class="hljs-number"><span class="hljs-number">0x85</span></span> @<span class="hljs-number"><span class="hljs-number">0x82</span></span> :label3 @<span class="hljs-number"><span class="hljs-number">0x34</span></span>] <span class="hljs-number"><span class="hljs-number">0x20C</span></span> DUP13 <span class="hljs-number"><span class="hljs-number">0x213</span></span> PUSH((NUMBER() &amp; ~<span class="hljs-number"><span class="hljs-number">0xFF</span></span>) + (POP() &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)) <span class="hljs-number"><span class="hljs-number">0x214</span></span> SWAP13 <span class="hljs-number"><span class="hljs-number">0x215</span></span> POP() <span class="hljs-number"><span class="hljs-number">0x217</span></span> DUP13 <span class="hljs-number"><span class="hljs-number">0x21E</span></span> JUMPI(:label24, !!(POP() &lt; NUMBER())) # Stack: [<span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x200</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x213</span></span> @<span class="hljs-number"><span class="hljs-number">0x85</span></span> @<span class="hljs-number"><span class="hljs-number">0x82</span></span> :label3 @<span class="hljs-number"><span class="hljs-number">0x34</span></span>] <span class="hljs-number"><span class="hljs-number">0x222</span></span> DUP13 <span class="hljs-number"><span class="hljs-number">0x223</span></span> PUSH(POP() - <span class="hljs-number"><span class="hljs-number">0x100</span></span>) <span class="hljs-number"><span class="hljs-number">0x224</span></span> SWAP13 <span class="hljs-number"><span class="hljs-number">0x225</span></span> POP() :label24 # Stack: [<span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x200</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> [@<span class="hljs-number"><span class="hljs-number">0x223</span></span> | @<span class="hljs-number"><span class="hljs-number">0x213</span></span>] @<span class="hljs-number"><span class="hljs-number">0x85</span></span> @<span class="hljs-number"><span class="hljs-number">0x82</span></span> :label3 @<span class="hljs-number"><span class="hljs-number">0x34</span></span>] <span class="hljs-number"><span class="hljs-number">0x227</span></span> DUP13 <span class="hljs-number"><span class="hljs-number">0x228</span></span> PUSH(BLOCKHASH(POP())) <span class="hljs-number"><span class="hljs-number">0x229</span></span> SWAP11 <span class="hljs-number"><span class="hljs-number">0x22A</span></span> POP() :label25 # Stack: [<span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> @<span class="hljs-number"><span class="hljs-number">0x70E</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> [@<span class="hljs-number"><span class="hljs-number">0x200</span></span> | @<span class="hljs-number"><span class="hljs-number">0x228</span></span>] <span class="hljs-number"><span class="hljs-number">0x0</span></span> [@<span class="hljs-number"><span class="hljs-number">0x88</span></span> | @<span class="hljs-number"><span class="hljs-number">0x223</span></span> | @<span class="hljs-number"><span class="hljs-number">0x213</span></span>] @<span class="hljs-number"><span class="hljs-number">0x85</span></span> @<span class="hljs-number"><span class="hljs-number">0x82</span></span> :label3 @<span class="hljs-number"><span class="hljs-number">0x34</span></span>] <span class="hljs-number"><span class="hljs-number">0x22C</span></span> DUP11 <span class="hljs-number"><span class="hljs-number">0x22D</span></span> DUP16 <span class="hljs-number"><span class="hljs-number">0x22E</span></span> DUP16 ...........</code> </pre> <br>  Apa yang benar-benar baik untuk evmdis adalah kegunaannya untuk menganalisis JUMPDEST menjadi label yang tepat, yang tidak dapat ditaksir terlalu tinggi. <br><br>  Jadi, setelah kita melewati persyaratan awal, kita menemukan diri kita pada label 23. Kita melihat DUP13 dan ingat dari bab sebelumnya bahwa angka 13 pada tumpukan adalah parameter ketiga kita.  Jadi kami mencoba untuk mendapatkan BLOCKHASH dari parameter ketiga kami.  Namun, tindakan BLOCKHASH terbatas pada 256 blok.  Inilah sebabnya mengapa diikuti oleh JUMPI (ini adalah if-construct).  Jika kita menerjemahkan logika opcodes ke dalam bahasa pseudo-code, kita mendapatkan sesuatu seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockhash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentBlockNumber - p &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash(p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bhash = blockhash(thrid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bhash == <span class="hljs-number"><span class="hljs-number">0</span></span>) { thirdProjection = (currentBlockNumber &amp; ~<span class="hljs-number"><span class="hljs-number">0xff</span></span>) + (thridParam &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thirdProjection &gt; currentBlockNumber) { thirdProjection -= <span class="hljs-number"><span class="hljs-number">256</span></span>; } thirdParam = thirdProjection; bhash = blockhash(thirdProjection); } label <span class="hljs-number"><span class="hljs-number">25</span></span> and beyond ..... some more stuff related to thirdParam and bhash</code> </pre> <br>  beberapa hal lagi yang terkait dengan thirdParam dan bhash - kode lain yang terkait dengan thirdParam dan blok hash <br><br>  Sekarang kami percaya bahwa kami telah menemukan alasan mengapa hasil kami berbeda dari yang kami amati di jaringan utama.  Lebih penting lagi, kami tampaknya berhasil menemukan sumber peluang.  Yaitu: hash blok dihitung berdasarkan parameter ketiga, atau <i>perkiraan</i> parameter ketiga.  Penting untuk dicatat bahwa dalam tumpukan parameter ketiga juga diganti dengan nomor blok yang diprediksi ini. <br><br>  Jelas, selama eksekusi lokal di luar jaringan utama, kami tidak memiliki opsi sederhana untuk memaksakan pengembalian BLOCKHASH yang cocok dengan nilai-nilai jaringan utama.  Bagaimanapun, karena kita tahu ketiga parameter, kita dapat dengan mudah memonitor jaringan utama dan mendapatkan hash dari blok H untuk parameter ketiga, serta hash dari blok yang diprediksi. <br><br>  Selanjutnya, kita bisa memasukkan hash ini langsung ke kode byte di lingkungan pengujian lokal kita, dan jika semuanya berjalan sesuai rencana, kita akhirnya akan mendapatkan set gen yang benar. <br><br>  Tetapi ada satu tangkapan: DUP13 dan BLOCKHASH hanya 2 byte dalam kode, dan jika kita hanya menggantinya dengan 33 byte PUSH32 0x * hash *, program counter akan sepenuhnya berubah dan kita harus memperbaiki masing-masing JUMP dan JUMPI.  Atau kita harus membuat JUMP di akhir kode dan mengganti instruksi untuk kode yang digunakan, dan seterusnya. <br><br>  Nah, karena kita sudah sejauh ini, kita akan mengendus sedikit lagi.  Karena kita mendorong 32-byte hash non-zero ke if-branch, kondisinya akan selalu benar dan oleh karena itu, segala sesuatu yang ditulis di bagian lain dapat dengan mudah dibuang untuk memberikan ruang bagi hash 32-byte kita.  Secara umum, inilah yang kami lakukan: <br><br> <a href=""><img src="https://habrastorage.org/webt/n1/xx/-x/n1xx-xl6ew1nlx-xjwzkgtk90cs.png"></a> <br><br>  Poin kuncinya adalah karena kita mengabaikan bagian lain dari kondisi, kita perlu mengganti parameter input ketiga dari fungsi mixGene dengan perkiraan parameter ketiga sebelum memanggilnya. <br><br>  Ini ke titik bahwa jika Anda mencoba untuk mendapatkan hasil dari suatu operasi <br>  mixGene (X, Y, Z), di mana currentBlockNumber adalah Z &lt;256, Anda hanya perlu mengganti hash PUSH32 dengan hash dari blok Z. <br>  Namun, jika Anda berniat melakukan hal berikut <br>  mixGene (X, Y, Z), di mana currentBlockNumber adalah Z ≥ 256, Anda harus mengganti hash PUSH32 dengan hash dari blok proj_Z, di mana proj_Z didefinisikan sebagai berikut: <br><br><pre> <code class="java hljs">proj_Z = (currentBlockNumber &amp; ~<span class="hljs-number"><span class="hljs-number">0xff</span></span>) + (Z &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (proj_Z &gt; currentBlockNumber) { proj_Z -= <span class="hljs-number"><span class="hljs-number">256</span></span>; } &lt;b&gt;    Z  proj_Z   ,   mixGene(X, Y, proj_Z).&lt;/b&gt;</code> </pre> <br>  Perhatikan bahwa proj_Z akan tetap tidak berubah dalam rentang blok tertentu.  Misalnya, jika Z &amp; 0xff = 128, maka proj_Z hanya berubah pada setiap blok nol dan 128. <br><br>  Untuk mengkonfirmasi hipotesis ini dan memeriksa apakah ada jebakan di depan, kami mengubah bytecode dan menggunakan utilitas keren lain yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hevm</a> . <br><br> <a href=""><img src="https://habrastorage.org/webt/ey/d5/cx/eyd5cxlyauklees28j70widdisg.png"></a> <br><br>  Jika Anda belum pernah menggunakan hevm, saya sarankan Anda mencobanya.  Alat ini tersedia bersama-sama dengan kerangka kerjanya sendiri, tetapi sebagian besar di set itu harus dicatat hal yang sangat berguna sebagai stack debugger interaktif. <br><br><pre> <code class="java hljs">Usage: hevm exec --code TEXT [--calldata TEXT] [--address ADDR] [--caller ADDR] [--origin ADDR] [--coinbase ADDR] [--value W256] [--gas W256] [--number W256] [--timestamp W256] [--gaslimit W256] [--gasprice W256] [--difficulty W256] [--debug] [--state STRING] Available options: -h,--help</code> </pre> <br>  Di atas adalah opsi peluncuran.  Utilitas ini memungkinkan Anda menentukan berbagai parameter.  Diantaranya adalah --debug, yang memberi Anda kemampuan untuk debug secara interaktif. <br><br>  Jadi, di sini kami telah melakukan beberapa panggilan ke kontrak genScience yang digunakan pada blockchain jaringan utama dan mencatat hasilnya.  Kemudian kami menggunakan hevm untuk menjalankan bytecode kami yang rusak dengan data yang disiapkan dengan mempertimbangkan aturan yang dijelaskan di atas dan ... <br><br>  Hasilnya sama! <br><br><h3>  Bab terakhir: kesimpulan dan kelanjutan kerja (?) </h3><br>  Jadi apa yang bisa kita capai? <br><br>  Dengan menggunakan perangkat lunak hack kami, Anda dapat 100% kemungkinan untuk memprediksi gen 256-bit untuk anak kucing yang baru lahir jika ia lahir dalam kisaran blok [coolDownEndBlock (ketika bayi siap muncul), blok saat ini adalah + 256 (kurang-lebih)].  Anda dapat mempertimbangkan hal ini sebagai berikut: ketika bayi berada di dalam rahim induk kucing, gen-nya bermutasi seiring waktu, karena sumber entropi dalam bentuk hash dari blok coolDownEndBlock yang diprediksi, yang juga berubah seiring waktu.  Oleh karena itu, Anda dapat menggunakan program ini untuk memeriksa bagaimana gen bayi akan terlihat jika itu lahir saat ini.  Dan jika Anda tidak menyukai gen ini, Anda bisa menunggu sekitar 256 blok lagi (rata-rata) dan memeriksa gen baru. <br><br>  Seseorang mungkin mengatakan bahwa ini tidak cukup, karena hanya akurasi prediksi 100% dapat dianggap sebagai peretasan yang ideal bahkan sebelum kehamilan induk-kucing.  Namun, ini tidak mungkin, karena gen anak kucing ditentukan tidak hanya oleh gen orang tuanya, tetapi juga oleh hash yang diprediksi dari blok sebagai faktor mutasi, yang tidak dapat diketahui sebelum pembuahan. <br><br>  Apa yang bisa diperbaiki dan apa nuansa di sini? <br><br>  Kami dengan cepat membahas perubahan yang terjadi pada tumpukan di bagian logis nyata dari kontrak pintar (label 25 dan semuanya setelah itu) dan kami percaya bahwa bagian yang dapat diprediksi dari kode mixGene ini baik untuk diuraikan dan dipelajari.  Kami berharap bahwa hash blok sebagai faktor mutasi juga membawa beberapa signifikansi fisik, membantu, misalnya, menentukan gen mana yang harus dimutasi.  Jika kita berhasil menemukan ini, kita akan mendapatkan gen aslinya, tanpa mutasi.  Ini berguna karena jika Anda tidak memiliki gen sumber yang baik, maka bahkan mutasi terbaik mungkin tidak cukup. <br><br>  Kami juga tidak mengukur korelasi antara gen 256-bit dan sifat-sifat anak kucing (warna mata, jenis ekor, dll.), Tetapi kami percaya bahwa ini sangat mungkin dilakukan dengan bantuan bot berkinerja tinggi dan penggolong sederhana. <br><br>  Dan secara umum, kami sepenuhnya memahami maksud tim pengembangan CryptoKitties untuk menstabilkan mutasi dalam waktu singkat.  Tetapi sisi lain dari pendekatan ini adalah kemampuan untuk melakukan analisis seperti yang kami lakukan. <br><br>  Kami juga ingin mengucapkan terima kasih kepada komunitas ethereum yang luar biasa karena telah mengembangkan alat seperti Etherscan, hevm, evmdis, truffle, testrpc, myetherwallet, dan Solidity.  Ini adalah komunitas yang sangat keren dan kami senang menjadi bagian darinya. <br><br>  Dan akhirnya, kode yang dimodifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/modong/GeneScienceCracked/</a> <br><br>  Ingatlah untuk mengubah $ CONSTBLOCKHASH $ ke hash dari blok yang diperkirakan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="gambar"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id409345/">https://habr.com/ru/post/id409345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id409335/index.html">Para ilmuwan dari Cambridge menciptakan mod untuk Civilization V dengan penerapan skenario untuk pengembangan AI yang kuat</a></li>
<li><a href="../id409337/index.html">Menggunakan VR, AR dan MR dalam simulasi dan pelatihan</a></li>
<li><a href="../id409339/index.html">Tinjauan umum DVR dengan GPS-informator AdvoCam-FD Black-II GPS + GLONASS</a></li>
<li><a href="../id409341/index.html">Pengembangan unit kontrol elektronik untuk mesin cuci Oriole</a></li>
<li><a href="../id409343/index.html">Hadiah Tahun Baru, bagian ketiga: apakah kita berperilaku baik</a></li>
<li><a href="../id409347/index.html">Haven Android App Edward Snowden Melindungi Objek Fisik</a></li>
<li><a href="../id409349/index.html">Apakah Anda memerlukan cangkir "pintar" atau cangkir yang cukup biasa, atau seberapa cepat kopi menjadi dingin</a></li>
<li><a href="../id409351/index.html">Akankah ruang angkasa Rusia meledak pada 2018?</a></li>
<li><a href="../id409355/index.html">Berapa biaya Bitcoin?</a></li>
<li><a href="../id409357/index.html">Stasiun kerja Dell: untuk tugas-tugas kreatif dan produktivitas ekstrem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>