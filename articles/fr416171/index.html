<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèΩ ‚ö°Ô∏è üöé Tests d'interface utilisateur cod√©s Visual Studio: th√©orie et pratique de l'application dans notre entreprise üíò üï∫üèΩ üíÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les tests automatis√©s de l'interface utilisateur sont un sujet dont m√™me les d√©veloppeurs exp√©riment√©s se m√©fient. De plus, la technologie de ces test...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests d'interface utilisateur cod√©s Visual Studio: th√©orie et pratique de l'application dans notre entreprise</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/416171/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/e4d/592/2aee4d592fcaceeb418e5833c067dcbd.png" alt="Image 2"></div><br>  Les tests automatis√©s de l'interface utilisateur sont un sujet dont m√™me les d√©veloppeurs exp√©riment√©s se m√©fient.  De plus, la technologie de ces tests n'est pas quelque chose d'extraordinaire, et dans le cas des tests d'interface utilisateur cod√©s Visual Studio est une extension du syst√®me de test unitaire int√©gr√© Visual Studio Team Test.  Dans cet article, je veux m'attarder sur le sujet des tests d'interface utilisateur en g√©n√©ral, ainsi que sur notre exp√©rience personnelle de l'utilisation des tests d'interface cod√©s Visual Studio dans le travail sur l'analyseur statique PVS-Studio. <br><a name="habracut"></a><br><h2>  Les bases </h2><br>  Tout d'abord, essayons de comprendre pourquoi les tests d'interface utilisateur ne sont pas aussi populaires parmi les d√©veloppeurs que, par exemple, les tests unitaires classiques. <br><br>  Il existe de nombreuses ¬´pyramides de test¬ª sur le r√©seau qui montrent la distribution optimale recommand√©e du nombre de tests sur les couches d'application.  Toutes les pyramides sont similaires et contiennent une id√©e g√©n√©rale: autant de tests que possible doivent √™tre aussi proches que possible du code.  Et vice versa.  Je vais donner un exemple de l'une de ces pyramides, qui contient des recommandations suppl√©mentaires sur le rapport du nombre de tests en pourcentage. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/7b5/b4b/4307b5b4b72a27aade942e0ff1747545.png" alt="Image 4"></div><br>  √Ä la base de la pyramide se trouvent des tests unitaires.  En effet, de tels tests sont plus faciles √† faire au stade du d√©veloppement, et ils seront ex√©cut√©s tr√®s rapidement.  Au sommet de la pyramide, d'autre part, se trouvent des tests d'interface automatis√©s.  Ces tests ne devraient pas √™tre nombreux, car la complexit√© de leur cr√©ation, ainsi que le temps d'ex√©cution, sont assez importants.  De plus, il n'est pas clair √† qui confier la cr√©ation des tests d'interface utilisateur.  En effet, nous parlons essentiellement d'√©muler les actions des utilisateurs.  Tout cela est tr√®s loin du code de l'application, les d√©veloppeurs h√©sitent donc √† faire ce genre de travail.  Et pour effectuer des tests automatis√©s de haute qualit√© des interfaces sans la participation (ou avec une participation minimale) des programmeurs, l'utilisation d'outils payants est requise.  La combinaison de tous ces facteurs conduit souvent au fait que les tests d'interface utilisateur ne font pas du tout, se limitant √† un test manuel unique de nouvelles fonctionnalit√©s.  De plus, les tests d'interface sont extr√™mement co√ªteux non seulement au stade du d√©veloppement, mais √©galement pendant le cycle de vie de l'application.  M√™me un l√©ger changement dans l'interface utilisateur peut entra√Æner des erreurs dans l'ex√©cution de nombreux tests et la n√©cessit√© de les modifier. <br><br>  Je note qu'√† l'heure actuelle, notre syst√®me de test est en g√©n√©ral conforme aux recommandations.  Le nombre de tests GUI automatis√©s (45) repr√©sente environ un dixi√®me du nombre total de tests PVS-Studio.  Dans le m√™me temps, le nombre de tests unitaires n'est pas si important, mais ils sont compl√©t√©s par une multitude d'autres syst√®mes de test: <br><br><ul><li> Tests de performance des analyseurs (C / C ++ / C # / Java), au cours desquels ils v√©rifient un large pool de projets de test sur diff√©rents syst√®mes d'exploitation (Windows, Linux, macOS) et comparent les journaux des nouveaux avertissements avec les r√©f√©rences; </li><li>  Tests de fonctionnalit√©s sp√©cifiques (suivi du lancement des compilateurs, etc.); </li><li>  Tests externes d'applications en ligne de commande; </li><li>  Tests d'assemblage, d'installation et de d√©ploiement corrects; </li><li>  Tests de documentation. </li></ul><br>  Au stade initial de son d√©veloppement, l'analyseur PVS-Studio √©tait une application pour trouver des erreurs lors du portage de code C / C ++ vers une plate-forme 64 bits.  Oui, et il a √©t√© appel√© √† cette √©poque d'une mani√®re diff√©rente, "Viva64".  L'historique du produit se trouve dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment le projet PVS-Studio a commenc√© il y a 10 ans</a> ".  Apr√®s l'int√©gration dans Visual Studio 2005, l'analyseur a acquis une interface utilisateur graphique, essentiellement l'interface de l'IDE Visual Studio lui-m√™me, dans laquelle, apr√®s l'installation du plug-in, un menu suppl√©mentaire est apparu pour acc√©der √† la fonctionnalit√© de l'analyseur.  Le menu √©tait compos√© de deux ou trois plats, il n'y avait donc rien √† tester.  Et Visual Studio √† cette √©poque ne contenait aucun outil int√©gr√© pour tester les interfaces graphiques. <br><br><h2>  Tests et alternatives de l'interface utilisateur cod√©e Visual Studio </h2><br>  Tout a chang√© avec la sortie de Visual Studio 2010, qui a introduit un syst√®me int√©gr√© pour cr√©er des tests d'interface utilisateur: les tests d'interface cod√©s Visual Studio (CUIT).  Bas√© sur le syst√®me de test unitaire Visual Studio Team Test, CUIT a d'abord utilis√© la technologie Microsoft Active Accessibility (MSAA) pour acc√©der aux √©l√©ments de l'interface visuelle.  √Ä l'avenir, la technologie a √©t√© am√©lior√©e et il s'agit actuellement d'un mod√®le d√©velopp√© d'automatisation de l'interface utilisateur pour tester le code UIA (UI Automation).  Il permet au syst√®me de test d'acc√©der √† des champs ouverts (nom d'objet, nom de classe interne de l'objet, √©tat actuel de l'objet, sa place dans la structure hi√©rarchique de l'interface, etc.) des √©l√©ments COM et .NET UI, et le syst√®me vous permet d'√©muler les effets sur ces √©l√©ments via des p√©riph√©riques d'entr√©e standard (souris, clavier).  D√®s la sortie de la bo√Æte, les modes d'enregistrement des actions des utilisateurs lors de l'interaction avec l'interface (similaires aux macros Visual Studio), l'automatisation de la construction d'une ¬´carte d'interface¬ª (propri√©t√©s des contr√¥les, param√®tres de recherche et acc√®s √† ceux-ci), ainsi que la g√©n√©ration automatique du code de contr√¥le, sont pris en charge.  √Ä l'avenir, toutes les informations accumul√©es seront faciles √† modifier et √† maintenir √† jour, ainsi qu'√† personnaliser les s√©quences de test √† votre guise, tout en ayant un minimum de comp√©tences en programmation. <br><br>  De plus, comme je l'ai dit plus t√¥t, maintenant lors de la cr√©ation de tests d'interface utilisateur intelligents complexes, vous pouvez vous passer de comp√©tences en programmation, √† condition d'utiliser des outils payants sp√©cialis√©s.  Eh bien, s'il n'y a aucun d√©sir ou capacit√© d'utiliser des environnements de test propri√©taires, il existe de nombreux produits et frameworks gratuits.  Le syst√®me de tests d'interface utilisateur cod√©s Visual Studio est une solution interm√©diaire qui permet non seulement d'automatiser autant que possible le processus de cr√©ation de tests d'interface utilisateur.  Avec son aide, il est facile de cr√©er des s√©quences de test arbitraires dans les langages de programmation C # ou VB. <br><br>  Tout cela peut r√©duire consid√©rablement le co√ªt de cr√©ation et de maintien de la pertinence des tests GUI.  Le cadre utilis√© est simple √† comprendre et peut en g√©n√©ral √™tre repr√©sent√© sous forme de diagramme. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/b6a/756/10bb6a7561749453f882bfa0c86b9f43.png" alt="Image 1"></div><br>  Parmi les √©l√©ments cl√©s, notons les ¬´adaptateurs d'interface¬ª, qui sont au niveau d'abstraction le plus bas.  Cette couche interagit avec les √©l√©ments finis de l'interface utilisateur et ses capacit√©s peuvent √™tre √©tendues √† l'aide d'adaptateurs suppl√©mentaires.  Ci-dessus, une couche qui masque les technologies d'acc√®s √† l'interface graphique du reste du code, y compris les interfaces d'acc√®s au programme et le code d'application de test r√©el, qui comprend tous les √©l√©ments n√©cessaires pour tester l'automatisation.  La technologie est extensible, chaque niveau peut √™tre compl√©t√© par les √©l√©ments n√©cessaires dans le cadre du cadre. <br><br>  Les principales fonctionnalit√©s de CUIT de Microsoft incluent: <br><br><ul><li>  Test fonctionnel des interfaces utilisateurs.  Applications, applications Web et services classiques bas√©s sur Windows, WPF sont pris en charge </li><li>  G√©n√©ration de code (y compris automatique) en VB / C # </li><li>  Capacit√© √† s'int√©grer dans le processus d'assemblage </li><li>  Lancements locaux ou distants, collecte de rapports </li><li>  Disponibilit√© des s√©quences de test d'enregistrement et de reproduction </li><li>  Bonne extensibilit√© </li></ul><br>  Malgr√© un certain nombre de difficult√©s associ√©es √† CUIT, l'utilisation de cette technologie de test est pr√©f√©r√©e pour un certain nombre de raisons: <br><br><ul><li>  Interaction efficace des d√©veloppeurs et des testeurs au sein d'un m√™me outil et langage de programmation </li><li>  Fonctionnalit√©s suppl√©mentaires de travail avec la ¬´carte d'interface¬ª, permettant l'identification des commandes ¬´√† la vol√©e¬ª, la synchronisation des √©l√©ments et l'ach√®vement des s√©quences de test </li><li>  R√©glage fin du m√©canisme de lecture, qui permet avec des param√®tres de base, tels qu'un d√©lai entre les op√©rations, un d√©lai de recherche d'√©l√©ment, etc., d'utiliser des m√©canismes sp√©cialis√©s dans le code.  Par exemple, verrouiller le thread actuel jusqu'√† ce que le contr√¥le soit activ√© (visualis√©) √† l'aide des <i>m√©thodes</i> <i>WaitForControlExist</i> ou <i>WaitForReady</i> avec l'√©num√©ration <i>WaitForReadyLevel</i> , etc. </li><li>  Possibilit√© de programmer des tests complexes et illimit√©s </li></ul><br>  Je n'entrerai pas plus loin dans les aspects th√©oriques de la technologie des tests d'interface utilisateur cod√©s Visual Studio, ils sont tous d√©taill√©s dans la documentation pertinente.  Vous y trouverez des instructions d√©taill√©es √©tape par √©tape pour cr√©er le test d'interface utilisateur le plus simple bas√© sur ce syst√®me.  Et oui, le syst√®me n'est pas gratuit, vous aurez besoin de Visual Studio Enterprise pour travailler avec. <br><br>  La technologie d√©crite n'est pas la seule sur le march√©.  Il existe de nombreuses autres solutions.  Tous les autres syst√®mes de test d'interface utilisateur peuvent √™tre divis√©s en payants et gratuits.  De plus, le choix d'un syst√®me particulier ne d√©pendra pas toujours de son prix.  Par exemple, la possibilit√© de cr√©er des tests sans avoir besoin de programmation peut √™tre un facteur important, mais en m√™me temps, les tests peuvent ne pas √™tre suffisamment flexibles.  Il est √©galement important de prendre en charge l'environnement de test n√©cessaire - syst√®mes d'exploitation et applications.  Enfin, les fonctionnalit√©s purement sp√©cifiques de l'application et de son interface peuvent influencer le choix.  Voici quelques syst√®mes et technologies populaires pour tester les interfaces graphiques. <br><br>  <i>Pay√©</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TestComplete</a> (SmartBear), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test fonctionnel unifi√©</a> (Micro Focus), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Squish</a> (froglogic), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Outils de test automatis√©</a> (Ranorex), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aubergine fonctionnelle</a> (aubergine), etc. <br><br>  <i>Gratuit</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AutoIt</a> (windows), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Selenium</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Katalon Studio</a> (web, mobile), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sahi</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Robot Framework</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LDTP</a> (Linux Desktop Testing Project), Framework open source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TestStack.White</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UIAutomationVerify,.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que d'automatisation NET Windows</a> , etc. <br><br>  Bien s√ªr, cette liste n'est pas compl√®te.  Cependant, il est √©vident que les syst√®mes gratuits sont g√©n√©ralement ax√©s sur un syst√®me d'exploitation ou une technologie de test sp√©cifique.  La r√®gle g√©n√©rale est que parmi les syst√®mes payants, vous trouverez beaucoup plus rapidement quelque chose qui convient sp√©cifiquement √† vos besoins, le d√©veloppement et la maintenance des tests seront plus faciles et la liste des environnements de test pris en charge est exhaustive. <br><br>  Dans notre cas, il n'y avait pas de probl√®me de choix: avec la sortie de Visual Studio 2010 avec l'ajout de tests d'interface cod√©s, il est devenu possible d'ajouter facilement un ensemble de tests fonctionnels √† notre environnement de test pour tester l'interface utilisateur du plug-in PVS-Studio pour Visual Studio. <br><br><h2>  Tests d'interface utilisateur PVS-Studio </h2><br>  Les tests GUI de notre entreprise sont donc utilis√©s depuis plus de 6 ans.  L'ensemble initial de tests d'interface utilisateur pour Visual Studio 2010 √©tait bas√© sur la seule technologie MSAA (Microsoft Active Accessibility) disponible √† l'√©poque.  Avec la sortie de Visual Studio 2012, la technologie MSAA s'est consid√©rablement d√©velopp√©e et s'appelle d√©sormais UIA (UI Automation).  Il a √©t√© d√©cid√© de continuer √† utiliser l'UIA et de laisser les tests bas√©s sur MSAA pour tester le plug-in pour Visual Studio 2010 (nous prenons en charge et testons les plug-ins pour toutes les versions de Visual Studio, √† partir de Visual Studio 2010). <br><br>  En cons√©quence, nous avons form√© deux ¬´branches¬ª de tests d'interface utilisateur.  De plus, dans le projet de test, ces deux branches ont utilis√© une carte d'interface commune et un code partag√©.  Dans le code, cela ressemblait √† ceci (m√©thode pour r√©initialiser les param√®tres de Visual Studio aux normes avant d'ex√©cuter le test): <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVSSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TestingMode mode)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">#region MSAA Mode </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mode == TestingMode.MSAA) { .... return; } #endregion </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//UIA Mode .... }</span></span></span></span></code> </pre> <br>  Lors de la modification de l'interface du plugin, il √©tait n√©cessaire d'apporter des modifications aux deux branches des tests d'interface utilisateur, et l'ajout de nouvelles fonctionnalit√©s a rendu n√©cessaire la duplication de l'√©l√©ment d'interface dans la carte: c'est-√†-dire, cr√©er deux √©l√©ments diff√©rents pour chacune des technologies MSAA et UIA.  Tout cela a exig√© beaucoup d'efforts non seulement pour cr√©er ou modifier des tests, mais aussi pour maintenir l'environnement de test dans un √©tat stable.  Je m'attarderai sur cet aspect plus en d√©tail. <br><br>  Selon mes observations, la stabilit√© de l'environnement de test lors du test de l'interface graphique est un probl√®me important.  Cela est principalement d√ª √† la forte d√©pendance de ces tests √† de nombreux facteurs externes.  En effet, en fait, les actions de l'utilisateur sont √©mul√©es: appui sur les touches, d√©placement du curseur de la souris, clics de souris, etc.  Il y a beaucoup de choses qui peuvent ¬´mal tourner¬ª.  Par exemple, si pendant le test, quelqu'un interagit avec un clavier connect√© au serveur de test.  De plus, de fa√ßon inattendue, la r√©solution du moniteur peut ne pas √™tre suffisante pour afficher un contr√¥le, et elle ne sera pas trouv√©e par l'environnement de test. <br><br>  En attente: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/57b/2fb/f0757b2fb7075dcfac29b66f81832b69.png" alt="Image 3"></div><br>  R√©alit√©: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/rh/ty/jdrhtyxluox8lhxhab_btiuhjp8.png"></div><br>  Un √©l√©ment de carte d'interface n√©gligemment r√©gl√© (et non trouv√© plus tard) est pratiquement le leader du comportement probl√©matique.  Par exemple, lors de la cr√©ation d'un nouveau contr√¥le, l'assistant de mappage d'interface des tests de l'interface utilisateur cod√©e de Visual Studio utilise les crit√®res de recherche √âgal par d√©faut pour celui-ci.  En d'autres termes, une correspondance exacte des noms de propri√©t√© aux valeurs sp√©cifi√©es est requise.  Cela fonctionne g√©n√©ralement, mais parfois la stabilit√© de l'ex√©cution des tests peut √™tre consid√©rablement am√©lior√©e en utilisant les crit√®res de recherche moins stricts ¬´Contient¬ª au lieu de ¬´√âgal¬ª.  Ceci est juste un exemple de "tweak" que vous pouvez rencontrer lorsque vous travaillez sur des tests d'interface utilisateur. <br><br>  Enfin, certains de vos tests peuvent consister √† effectuer une action et √† attendre un r√©sultat, qui est par exemple associ√© √† l'affichage d'une fen√™tre.  Dans ce cas, au probl√®me de la recherche d'un √©l√©ment, des questions de r√©glage du d√©lai de lecture jusqu'√† l'apparition de la fen√™tre puis de synchronisation du travail seront ajout√©es.  Certains de ces probl√®mes peuvent √™tre r√©solus par des m√©thodes de framework standard ( <i>WaitForControlExist</i> , etc.), tandis que pour d'autres, il sera n√©cessaire d'inventer des algorithmes ing√©nieux. <br><br>  Nous avons rencontr√© un probl√®me similaire en travaillant sur l'un des tests de notre plugin.  Dans ce test, un environnement Visual Studio vide est ouvert en premier, puis une certaine solution de test y est charg√©e, qui est enti√®rement test√©e √† l'aide de PVS-Studio (menu ¬´PVS-Studio¬ª -&gt; ¬´V√©rifier¬ª -&gt; ¬´Solution¬ª).  Le probl√®me √©tait de d√©terminer quand la v√©rification serait termin√©e.  Selon un certain nombre de conditions, la v√©rification peut ne pas toujours prendre le m√™me temps, les d√©lais d'attente simples ne fonctionnent donc pas ici.  En outre, vous ne pouvez pas utiliser les m√©canismes standard pour suspendre le flux de test et attendre l'apparition (ou le masquage) d'un contr√¥le, car il n'y a rien √† attacher.  Pendant la v√©rification, une fen√™tre avec le statut de travail appara√Æt, mais cette fen√™tre peut √™tre masqu√©e, et la v√©rification continuera.  C'est-√†-dire  cette fen√™tre ne peut pas √™tre guid√©e (en plus, elle a le r√©glage ¬´Ne pas fermer une fois l'analyse termin√©e¬ª).  Et je voulais rendre l'algorithme plus g√©n√©ral afin de l'utiliser pour diff√©rents tests li√©s √† la v√©rification des projets et en attendant la fin de ce processus.  Une solution a √©t√© trouv√©e.  Apr√®s le d√©marrage du test et jusqu'√† son ach√®vement, l'√©l√©ment de menu m√™me ¬´PVS-Studio¬ª -&gt; ¬´V√©rifier¬ª -&gt; ¬´Solution¬ª est inactif.  Nous n'avions qu'√† v√©rifier la propri√©t√© ¬´Enabled¬ª de cet √©l√©ment de menu √† un certain intervalle de temps (via l'objet de carte d'interface) et, s'il √©tait constat√© que l'√©l√©ment √©tait devenu actif, consid√©rer le processus de v√©rification de d√©cision comme termin√©. <br><br>  Ainsi, dans le cas des tests d'interface utilisateur, il ne suffit pas de simplement cr√©er des tests.  Un r√©glage subtil et minutieux est requis dans chaque cas.  Il est n√©cessaire de comprendre et de synchroniser la s√©quence compl√®te des actions effectu√©es.  Par exemple, l'√©l√©ment de menu contextuel ne sera pas trouv√© tant que ce menu ne sera pas affich√© √† l'√©cran, etc.  Une pr√©paration minutieuse de l'environnement de test est √©galement requise.  Dans ce cas, vous pouvez compter sur le fonctionnement stable des tests et des r√©sultats ad√©quats. <br><br>  Permettez-moi de vous rappeler que le syst√®me de tests d'interface utilisateur dans notre entreprise se d√©veloppe depuis 2010.  Pendant ce temps, plusieurs dizaines de s√©quences de test ont √©t√© cr√©√©es et de nombreux codes auxiliaires ont √©t√© √©crits.  Des tests d'application autonomes ont √©t√© ajout√©s aux tests de plugin au fil du temps.  √Ä ce stade, l'ancienne branche de test de plug-in pour Visual Studio 2010 avait perdu sa pertinence et a √©t√© abandonn√©e, mais il √©tait tout simplement impossible de supprimer ce code ¬´mort¬ª du projet.  Premi√®rement, comme je l'ai montr√© pr√©c√©demment, le code a √©t√© assez profond√©ment int√©gr√© dans les m√©thodes de test.  Et deuxi√®mement, plus de la moiti√© des √©l√©ments de la carte d'interface existante appartenaient √† l'ancienne technologie MSAA, mais ont √©t√© r√©utilis√©s (au lieu de duplication) dans de nombreux nouveaux tests avec des √©l√©ments UIA (cela est possible en raison de la continuit√© de la technologie).  Dans le m√™me temps, la masse du code g√©n√©r√© automatiquement et du contenu des m√©thodes de test √©tait li√©e aux "anciens" √©l√©ments. <br><br>  √Ä l'automne 2017, il √©tait n√©cessaire d'am√©liorer le syst√®me de tests d'interface utilisateur.  En g√©n√©ral, les tests ont bien fonctionn√©, mais de temps en temps certains tests ont "plant√©" pour des raisons inconnues.  Plus pr√©cis√©ment, la raison √©tait g√©n√©ralement de trouver un contr√¥le.  Dans chaque cas, j'ai d√ª parcourir l'arborescence de la carte d'interface jusqu'√† un √©l√©ment sp√©cifique et v√©rifier ses crit√®res de recherche et d'autres param√®tres.  Parfois, une r√©initialisation logicielle de ces param√®tres a aid√© avant d'ex√©cuter le test.  √âtant donn√© la carte d'interface qui s'est d√©velopp√©e (et √† bien des √©gards, √† bien des √©gards) par la carte d'interface, ainsi que la pr√©sence de code "mort", ce processus a n√©cessit√© des efforts consid√©rables. <br><br>  Depuis quelque temps, la t√¢che ¬´attendait son h√©ros¬ª, jusqu'√† ce qu'elle vienne enfin √† moi. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3b/a0e/940/c3ba0e9405d26985a0519cf66544ca36.png" alt="Image 5"></div><br>  Je ne vous ennuierai pas avec une description des nuances.  Je peux seulement dire que le travail n'a pas √©t√© difficile, mais il a n√©cessit√© beaucoup de pers√©v√©rance et d'attention.  Tout sur tout m'a pris environ deux semaines.  J'ai pass√© la moiti√© de ce temps √† refactoriser le code et les cartes d'interface.  Dans le temps restant, il s'est engag√© dans la stabilisation de l'ex√©cution des tests, qui se r√©sumait essentiellement √† un r√©glage plus fin des crit√®res de recherche des √©l√©ments visuels (modification de la carte d'interface), ainsi qu'√† une certaine optimisation du code. <br><br>  En cons√©quence, nous avons r√©ussi √† r√©duire la taille du code des m√©thodes de test d'environ 30% et le nombre de contr√¥les dans l'arborescence de la carte d'interface a √©t√© divis√© par deux.  Mais surtout, les tests d'interface utilisateur ont commenc√© √† montrer des performances plus stables et n√©cessitent moins d'attention.  Et la chute a commenc√© √† se produire plus souvent pour des raisons de modification de la fonctionnalit√© de l'analyseur ou lors de la d√©tection d'incoh√©rences (erreurs).  En fait, √† ces fins, nous avons besoin d'un syst√®me de tests d'interface utilisateur. <br><br>  Ainsi, √† l'heure actuelle, le syst√®me de tests automatiques de l'interface PVS-Studio pr√©sente les caract√©ristiques de base suivantes: <br><br><ul><li>  Test d'interface utilisateur cod√© Visual Studio </li><li>  45 sc√©narios </li><li>  4 095 lignes de code pour les m√©thodes d'essai </li><li>  19 889 lignes de code g√©n√©r√© automatiquement (√† l'exclusion de la taille du fichier xml pour le stockage des param√®tres de carte d'interface utilisateur) </li><li>  1 heure 34 minutes d'ex√©cution (valeur moyenne en fonction des r√©sultats des 30 derniers d√©marrages) </li><li>  Travailler sur un serveur d√©di√© (ex√©cutant l'utilitaire MSTest.exe) </li><li>  Surveillance des performances et analyse des rapports de performances (Jenkins) </li></ul><br><h2>  Conclusion </h2><br>  En conclusion, je veux donner une liste de crit√®res de r√©ussite pour les tests GUI automatiques, qui est bas√©e sur une analyse de notre exp√©rience avec cette technologie (certains des crit√®res s'appliquent √† d'autres technologies de test, par exemple, les tests unitaires). <br><br>  <i>Outils appropri√©s</i> .  Choisissez l'environnement de cr√©ation et d'ex√©cution de CUIT en fonction des fonctionnalit√©s de votre application, ainsi que de l'environnement de test.  Les solutions payantes n'ont pas toujours de sens, mais elles aident g√©n√©ralement √† r√©soudre un probl√®me tr√®s efficacement. <br><br>  <i>Configuration d'infrastructure de haute qualit√©</i> .  Ne pas enregistrer lors du d√©veloppement d'une carte d'interface.  Simplifiez le travail du framework lors de la recherche d'√©l√©ments en d√©crivant soigneusement toutes leurs propri√©t√©s et en d√©finissant des crit√®res de recherche intelligents.  Faites attention aux possibilit√©s de modifications suppl√©mentaires. <br><br>  <i>Minimisation du travail manuel</i> .  Dans la mesure du possible, assurez-vous d'utiliser des moyens automatiques pour g√©n√©rer du code et enregistrer des s√©quences.  Ainsi, vous acc√©l√©rerez consid√©rablement le d√©veloppement et minimiserez la probabilit√© d'erreurs (il n'est pas toujours facile de trouver la raison du plantage du test d'interface utilisateur, surtout si une erreur est commise dans le code pour travailler avec le framework). <br><br>  <i>Tests intelligents simples et ind√©pendants</i> .  Plus vos tests sont simples, mieux c'est.  Essayez de faire un test distinct pour tester un contr√¥le sp√©cifique ou une situation simul√©e.  Assurez-vous √©galement que les tests sont ind√©pendants les uns des autres.  La chute d'un des tests ne devrait pas affecter l'ensemble du processus. <br><br>  <i>Noms amicaux</i> .  Utilisez des pr√©fixes dans les noms de tests similaires.  De nombreux environnements vous permettent d'ex√©cuter des tests en filtrant par nom.  Utilisez √©galement le regroupement de tests dans la mesure du possible. <br><br>  <i>Ex√©cution isol√©e</i> .  Assurez-vous que les tests sont ex√©cut√©s sur un serveur d√©di√© avec un impact externe minimal.  D√©connectez tous les p√©riph√©riques d'entr√©e utilisateur externes, fournissez la r√©solution d'√©cran n√©cessaire √† votre application ou utilisez un mannequin mat√©riel qui simule une connexion de moniteur haute r√©solution.  Assurez-vous qu'au cours du test, les autres applications qui interagissent, par exemple avec le bureau et affichent les messages, ne sont pas en cours d'ex√©cution.  Il est √©galement n√©cessaire de planifier l'heure de d√©but et de consid√©rer la dur√©e maximale des tests. <br><br>  <i>Analyse des rapports publi√©s</i> .  Fournissez un formulaire simple et clair pour rendre compte des progr√®s.  Utilisez des syst√®mes d'int√©gration continue pour envoyer les tests, ainsi que pour obtenir et analyser rapidement les r√©sultats des tests. <br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tests d'interface utilisateur cod√©s Visual Studio: th√©orie et exp√©rience utilisateur de notre entreprise</a> <br><br><div class="spoiler">  <b class="spoiler_title">Avez-vous lu l'article et avez une question?</b> <div class="spoiler_text">  Souvent, nos articles se posent les m√™mes questions.  Nous avons rassembl√© les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©ponses</a> ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©ponses aux questions des lecteurs d'articles sur PVS-Studio, version 2015</a> .  Veuillez consulter la liste. </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416171/">https://habr.com/ru/post/fr416171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416159/index.html">Comment nous avons √©t√© charg√©s de comparer un h√©risson avec un serpent</a></li>
<li><a href="../fr416161/index.html">10 raisons [de ne pas] utiliser k8s</a></li>
<li><a href="../fr416163/index.html">Apprenez OpenGL. Le√ßon 5.6 - Mappage de parallaxe</a></li>
<li><a href="../fr416167/index.html">Peter Norwig: apprendre la programmation en ... 10 ans</a></li>
<li><a href="../fr416169/index.html">Conteneurs pour adultes (partie 01): un guide pratique de la terminologie</a></li>
<li><a href="../fr416175/index.html">R√©sultats du concours des jeunes d√©veloppeurs d'applications AR Epson Moverio BT-300</a></li>
<li><a href="../fr416177/index.html">Formule de Tupper et impl√©mentation de l'algorithme en Python</a></li>
<li><a href="../fr416179/index.html">Une porte qui nous accueille par son nom et ne s'ouvre qu'aux employ√©s du d√©partement</a></li>
<li><a href="../fr416181/index.html">Modulation d'amplitude sur les doigts</a></li>
<li><a href="../fr416183/index.html">Test des donn√©es: exigences et niveaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>