<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐧 👨‍👨‍👧‍👦 🍾 Wie man Brei aus Microservices kocht 🧝 📵 🤽🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einer der Gründe für die Popularität von Microservices ist die Möglichkeit einer autonomen und unabhängigen Entwicklung. Im Wesentlichen ist die Micro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man Brei aus Microservices kocht</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469001/">  Einer der Gründe für die Popularität von Microservices ist die Möglichkeit einer autonomen und unabhängigen Entwicklung.  Im Wesentlichen ist die Microservice-Architektur der Austausch der Möglichkeit einer autonomen Entwicklung für eine komplexere (im Vergleich zu einem Monolithen) Bereitstellung, Test, Debugging und Überwachung.  Beachten Sie jedoch, dass Microservices die Aufgabentrennung nicht verzeihen.  Wenn die Aufgabentrennung falsch ist, treten bei verschiedenen Diensten häufig abhängige Änderungen auf.  Und dies ist viel schmerzhafter und komplizierter als koordinierte Änderungen im Rahmen verschiedener Module oder Pakete innerhalb des Monolithen.  Konsistente Änderungen an Microservices werden durch das konsistente Layout, die Bereitstellung, das Testen usw. erschwert. <br><br>  Und ich möchte über die verschiedenen Muster und Antimuster der Aufteilung der Zuständigkeiten in Mikrodienste sprechen. <br><a name="habracut"></a><br><h3>  Service Entity als Antipattern </h3><br>  "Service Entity" ist eines der möglichen (Anti) Muster des Designs von Microservice-Architekturen, das zu stark abhängigem Code in verschiedenen Diensten führt und innerhalb von Diensten lose gekoppelt ist. <br><br>  Für die meisten Entwickler scheint es, dass er bei der Auswahl von Diensten nach dem Wesen des Themenbereichs: „Geschäft“, „Person“, „Kunde“, „Auftrag“, „Bild“ den Grundsätzen der alleinigen Verantwortung folgt, und darüber hinaus erscheint dies häufig logisch.  Der Service-Entity-Ansatz kann sich jedoch in ein Antimuster verwandeln.  Dies liegt daran, dass die meisten Funktionen oder Änderungen mehrere Entitäten betreffen und nicht eine.  Infolgedessen kombiniert jeder dieser Services die Logik verschiedener Geschäftsprozesse. <br><br>  Nehmen Sie zum Beispiel einen Online-Shop.  Wir haben uns entschlossen, die Dienstleistungen „Produkt“, „Bestellung“, „Kunde“ hervorzuheben. <br><br>  Welche Änderungen und Dienstleistungen sollte ich vornehmen, um die Lieferung nach Hause hinzuzufügen? <br>  Zum Beispiel können Sie dies tun: <br><br><ul><li>  Fügen Sie im Service "Bestellung" die Lieferadresse, die gewünschte Zeit und den Lieferboten hinzu </li><li>  Fügen Sie im Client-Service eine Liste ausgewählter Lieferadressen für den Client hinzu </li><li>  Fügen Sie im Service „Produkt“ eine Entitätsliste der Waren hinzu </li></ul><br>  Für die Schnittstelle des Lieferanten muss im Bestelldienst eine separate API-Methode erstellt werden, die eine Liste der diesem bestimmten Anbieter zugewiesenen Bestellungen enthält.  Darüber hinaus sind Methoden erforderlich, um Waren aus der Bestellung zu entfernen, die nicht passten oder die der Kunde zum Zeitpunkt der Lieferung abgelehnt hat. <br><br>  Oder welche Änderungen und bei welchen Dienstleistungen muss ich vornehmen, um Rabatte auf den Aktionscode hinzuzufügen? <br>  Zumindest benötigen Sie: <br><br><ul><li>  Fügen Sie dem Bestellservice einen Aktionscode hinzu </li><li>  Fügen Sie im Service "Produkt" hinzu, ob auf den Aktionscode für dieses Produkt Rabatte gelten </li><li>  Fügen Sie im Kundenservice eine Liste der Aktionscodes hinzu, die dem Kunden ausgestellt wurden </li></ul><br>  In der Manageroberfläche ist das Hinzufügen eines personalisierten Aktionscodes zum Kunden eine separate Methode im Kundenservice, die nur für Filialleiter verfügbar ist, dem Kunden jedoch nicht.  Erstellen Sie im Service "Produkt" eine Methode, die eine Liste der Produkte enthält, die vom Aktionscode betroffen sind, damit der Kunde die Auswahl in seiner Benutzeroberfläche erleichtern kann. <br><br>  Die Ursachen für Änderungen im Service können verschiedene Geschäftsprozesse sein - Auswahl und Design, Zahlung und Abrechnung, Lieferung.  Jeder der Problembereiche hat seine eigenen Einschränkungen, Invarianten und Anforderungen für die Bestellung.  Infolgedessen stellt sich heraus, dass wir im „Produkt“ -Dienst Informationen über das Produkt, über Rabatte und Produktbilanzen in Lagern speichern.  Und in der "Bestellung" ist die Logik des Zustellers gespeichert. <br><br>  Mit anderen Worten, eine Änderung der Geschäftslogik, die auf mehrere Dienste verteilt ist, führt zu abhängigen Änderungen in mehreren Diensten.  Gleichzeitig ist in einem Dienst ein Code enthalten, der nicht miteinander verbunden ist. <br><br><h3>  Speicherdienste </h3><br>  Es scheint, dass dieses Problem gelöst werden kann, wenn ein separater "Layer" -Dienst über Entitätsdiensten erstellt wird, der die gesamte Logik kapselt.  Aber normalerweise endet das auch schlecht.  Weil dann Entitätsdienste zu Speicherdiensten werden, d.h.  Die gesamte Geschäftslogik wird mit Ausnahme der Speicherung aus ihnen herausgewaschen. <br><br>  Wenn die Daten in verschiedenen Datenbanken auf verschiedenen Maschinen gespeichert sind, dann wir <br><br><ul><li>  Wir verlieren an Leistung, weil wir Daten nicht direkt aus der Datenbank, sondern über die Serviceschicht bereitstellen </li><li>  Wir verlieren an Flexibilität, da die Service-API normalerweise viel weniger flexibel ist als SQL oder eine andere Abfragesprache </li><li>  Wir verlieren an Flexibilität, weil es schwierig ist, Daten von verschiedenen Diensten zusammenzuführen <br></li></ul><br>  Wenn verschiedene Entitätsdienste Zugriff auf andere Datenbanken haben, erfolgt die Kommunikation zwischen Diensten implizit. Über eine gemeinsame Datenbank ist es nur möglich, Änderungen vorzunehmen, die sich auf eine Änderung des Datenschemas auswirken, nachdem überprüft wurde, dass durch diese Änderung nicht alle anderen Dienste beschädigt werden, die diese Datenbank oder dieses Tablet verwenden . <br><br>  Neben der komplexen Entwicklung werden solche Services zu kritisch und stark ausgelastet. Bei fast jeder Anforderung eines Top-Level-Service müssen Sie mehrere Anforderungen an verschiedene Service-Entitäten stellen. Dies bedeutet, dass die Bearbeitung noch schwieriger wird, um den gestiegenen Anforderungen an Zuverlässigkeit und Leistung gerecht zu werden. <br><br>  Aufgrund solcher Schwierigkeiten bei der Entwicklung und Unterstützung von Entity-Services in ihrer reinen Form sehen Sie selten ein Muster. In der Regel werden Entity-Services zu einem oder zwei zentralen „Microservice-Monolithen“, die sich häufig ändern und die Hauptgeschäftslogik und Placer kleiner Microservices enthalten, bei denen es sich normalerweise um Infrastruktur handelt und kleine, die sich selten ändern. <br><br><h3>  Trennung nach Problembereichen </h3><br>  Veränderungen an sich werden nicht geboren, sie kommen aus einem Problembereich.  Ein Problembereich ist ein Aufgabenbereich, in dem Probleme, die Änderungen im Code erfordern, in einer Sprache unter Verwendung eines Satzes von Konzepten formuliert oder durch Geschäftslogik miteinander verbunden werden.  Dementsprechend gibt es im Rahmen eines Problembereichs höchstwahrscheinlich eine Reihe von Einschränkungen, Invarianten, auf die Sie sich beim Schreiben von Code verlassen können. <br><br>  Die Trennung der Verantwortung von Diensten nach Problembereichen und nicht nach Entitäten führt normalerweise zu einer besser unterstützten und verständlicheren Architektur.  Problembereiche entsprechen meist Geschäftsprozessen.  Für den Online-Shop sind die wahrscheinlichsten Problembereiche "Zahlung und Abrechnung", "Lieferung", "Bestellvorgang". <br><br>  Änderungen, die mehrere Problembereiche gleichzeitig betreffen würden, sind geringer als Änderungen, die mehrere Entitäten betreffen würden. <br><br>  Darüber hinaus können nach Geschäftsprozessen aufgeschlüsselte Services in Zukunft wiederverwendet werden.  Wenn wir beispielsweise neben dem Online-Shop einen weiteren Verkauf von Flugtickets tätigen möchten, können wir den allgemeinen Service „Abrechnung und Zahlung“ wiederverwenden.  Und machen Sie keine anderen ähnlich, sondern spezifisch für den Verkauf von Tickets. <br><br>  Zum Beispiel können wir so in Dienstleistungen unterteilen: <br><br><ul><li>  Eine Dienstleistung oder eine Gruppe von Dienstleistungen „Lieferung“, in der die Arbeitslogik mit der Lieferung eines bestimmten Auftrags, der Organisation der Arbeit der Lieferanten, der Bewertung der Qualität ihrer Arbeit, der mobilen Anwendung des Lieferanten usw. gespeichert wird. </li><li>  Ein Dienst oder eine Gruppe von Diensten „Abrechnung und Zahlung“, in denen die Logik der Arbeit mit Zahlungen, Zahlungskonten für juristische Personen, der Erstellung von Verträgen und Abschlussdokumenten gespeichert wird. </li><li>  Service oder Gruppe von Services „Bestellprozess“, in dem die Logik der Produktauswahl, Katalogisierung, Marken, Warenkorblogik usw. des Kunden gespeichert ist. </li><li>  Service "Autorisierung und Authentifizierung". </li><li>  Es kann sogar sinnvoll sein, den Rabattdienst zu trennen. </li></ul><br>  Um miteinander zu interagieren, können Dienste das Ereignismodell verwenden oder einfache Objekte miteinander austauschen (erholsame API, GRPC usw.).  Es ist zwar erwähnenswert, dass es nicht einfach ist, die Interaktion zwischen solchen Diensten korrekt zu organisieren.  Zumindest hat die Datendezentralisierung irgendwann Probleme mit der Konsistenz (eventuelle Konsistenz) und der Transaktionsfähigkeit (falls dies wichtig ist). <br><br>  Die Dezentralisierung von Daten, der Austausch einfacher Objekte hat Vor- und Nachteile.  Einerseits ermöglicht die Dezentralisierung die unabhängige Entwicklung und den Betrieb mehrerer Dienste.  Andererseits die Kosten für das Speichern von zwei oder drei Kopien von Daten und die Aufrechterhaltung der Konsistenz in verschiedenen Systemen. <br><br>  Im wirklichen Leben passiert oft etwas dazwischen.  Service-Entität mit einem Mindestsatz von Attributen, die von allen Services von Verbrauchern verwendet wird.  Und eine minimale Logikschicht - zum Beispiel ein Statusmodell und Ereignisse in der Warteschlange mit der Benachrichtigung über alle Änderungen in der Entität.  Gleichzeitig behalten Verbraucherdienste immer noch häufig einen „Cache“ von Daten.  Es wird alles Mögliche getan, damit sich an einem solchen Dienst so wenig wie möglich ändert, und dies ist im Prinzip schwierig, da es viele Verbraucher gibt. <br><br>  Gleichzeitig ist es wichtig zu verstehen, dass jede Partition - sowohl nach Entität als auch nach Problembereich - kein Patentrezept ist. Es wird immer Funktionen geben, die abhängige Änderungen in mehreren Diensten erfordern.  Es ist nur so, dass es bei einer Panne viel mehr solche Änderungen geben wird als bei einer anderen.  Die Aufgabe der Entwicklung besteht darin, die Anzahl der abhängigen Änderungen zu minimieren. <br><br>  Eine ideale Aufteilung ist nur möglich, wenn Sie zwei völlig unabhängige Produkte haben.  In jedem Geschäft ist alles mit allem verbunden. Die einzige Frage ist, wie viel damit verbunden ist. <br><br>  Und die Frage ist die Trennung der Verantwortlichkeiten und die Höhe der Hindernisse für Abstraktionen. <br><br><h3>  Design Service API </h3><br>  Das Entwerfen von Schnittstellen innerhalb des Dienstes wiederholt den Verlauf mit der Aufteilung in Dienste nur in kleinerem Maßstab.  Das Ändern der Schnittstelle (nicht nur einer Erweiterung) ist komplex und zeitaufwändig.  In komplexen Anwendungen sollte die Schnittstelle universell genug sein, um keine ständigen Änderungen zu verursachen, und sie sollte spezifisch und spezifisch genug sein, um keine Ausbreitung von Verantwortung und Semantik zu verursachen. <br><br>  Daher müssen Dienstschnittstellen so gestaltet sein, dass ihre Semantik Änderungen widersteht.  Dies ist möglich, wenn sich die Semantik oder der Verantwortungsbereich der Schnittstelle auf die Einschränkungen des Problembereichs stützt. <br><br><h3>  CRUD-Schnittstellen für Services mit komplexer Geschäftslogik </h3><br>  Eine zu breite und unspezifische Schnittstelle trägt entweder zur Erosion der Verantwortung oder zu übermäßiger Komplexität bei. <br><br>  Beispiel: CRUD-API für Dienste mit komplexer Geschäftslogik. Solche Schnittstellen kapseln kein Verhalten.  Sie ermöglichen nicht nur, dass Geschäftslogik in andere Dienste eindringt und die Verantwortung des Dienstes untergräbt, sondern provozieren auch die Verbreitung von Geschäftslogik - Einschränkungen, Invarianten und Methoden für die Arbeit mit Daten sind jetzt in anderen Diensten enthalten.  Interface User Services (APIs) müssen die Logik selbst implementieren. <br><br>  Wenn wir versuchen, ohne die Schnittstelle wesentlich zu ändern, die Geschäftslogik auf den Service zu übertragen, erhalten wir eine zu universelle und zu komplizierte Methode. <br><br>  Zum Beispiel gibt es einen Ticketservice.  Es gibt verschiedene Arten von Tickets.  Jeder Typ hat einen anderen Satz von Feldern und eine etwas andere Validierung.  Das Ticket hat auch ein Statusmodell - eine Zustandsmaschine für den Übergang von einem Status zu einem anderen. <br><br>  Lassen Sie die API folgendermaßen aussehen: POST / PATCH / GET-Methoden, URL /api/v1/tickets/{ticket_idasket.json <br><br>  So können Sie das Ticket aktualisieren <br><br><pre><code class="json hljs">PATCH /api/v<span class="hljs-number"><span class="hljs-number">1</span></span>/tickets/{ticket_id}.json { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bug"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"closed"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> }</code> </pre> <br>  Wenn das Statusmodell vom Ticket abhängt, sind Konflikte der Geschäftslogik möglich.  Ändern Sie zuerst den Status gemäß dem alten Statusmodell und dann den Ticket-Typ.  Oder umgekehrt? <br><br>  Es stellt sich heraus, dass es innerhalb der API-Methode Code gibt, der nicht miteinander verbunden ist - sich ändernde Entitätsfelder, eine Liste verfügbarer Felder, abhängig vom Ticket-Typ, und ein Statusmodell.  Sie ändern sich aus verschiedenen Gründen und es ist sinnvoll, sie nach verschiedenen API-Methoden und -Schnittstellen zu verteilen. <br><br>  Wenn das Ändern eines Felds im Rahmen von API-CRUD-Methoden nicht nur eine Datenänderung ist, sondern eine Operation, die sich auf eine koordinierte Änderung des Status einer Entität bezieht, sollte diese Operation in eine separate Methode übernommen und nicht direkt geändert werden.  Wenn das Ändern einer API ohne Abwärtskompatibilität (für öffentliche APIs) sehr schlecht ist, sollten Sie beim Entwerfen der API sofort darüber nachdenken. <br><br>  Um solche Probleme zu vermeiden, ist es daher besser, die Schnittstellen klein, spezifisch und so problemorientiert wie möglich zu gestalten, als universelle datenzentrierte. <br><br>  Dieses (Anti) Muster ist häufiger charakteristisch für RESTful-Schnittstellen, da standardmäßig nur wenige datenzentrierte „Verben“ von Aktionen zum Erstellen, Löschen, Aktualisieren und Lesen vorhanden sind.  Keine geschäftsspezifischen Entitätsoperationen <br><br>  Was kann getan werden, um RESTful problemorientierter zu machen? <br>  Zunächst können Sie Entitäten Methoden hinzufügen.  Die Schnittstelle wird weniger erholsam.  Aber es gibt eine solche Gelegenheit.  Wir kämpfen immer noch nicht für die Reinheit des Rennens, sondern lösen praktische Probleme <br><br>  <code>/api/v1/tickets.json</code> Sie anstelle der universellen Ressource <code>/api/v1/tickets.json</code> weitere Ressourcen hinzu: <br><br>  <code>/api/v1/tickets/{ticket_id}/migrate.json</code> - Migrieren Sie von einem Typ zu einem anderen <br>  <code>/api/v1/tickets/{ticket_id}/status.json</code> - wenn es ein <code>/api/v1/tickets/{ticket_id}/status.json</code> gibt <br><br>  Zweitens können Sie sich jede Operation als Ressource im Rahmen von REST vorstellen.  Gibt es eine Ticketmigrationsoperation von einem Typ zu einem anderen (oder von einem Projekt zu einem anderen?).  Ok, es wird also eine Ressource geben <br> <code>/api/v1/tickets/migration.json</code> <br> <br>  Gibt es einen Geschäftsbetrieb zum Erstellen eines Testabonnements? <br> <code>/api/v1/subscriptions/trial.json</code> <br> <br>  Gibt es eine Geldtransferoperation? <br> <code>/api/v1/money_transfers.json</code> <br> <br>  Usw. <br><br>  Das Antipattern mit der datenzentrierten API bezieht sich tatsächlich auch auf die RPC-Interaktion.  Zum Beispiel das Vorhandensein zu allgemeiner Methoden wie editAccount () oder editTicket ().  "Objekt ändern" trägt nicht die semantische Last, die dem Problembereich zugeordnet ist.  Dies bedeutet, dass diese Methode aus verschiedenen Gründen aufgerufen wird, aus verschiedenen Gründen, um sich zu ändern. <br><br>  Es ist zu beachten, dass datenzentrierte Schnittstellen in Ordnung sind, wenn der Problembereich nur das Speichern, Empfangen und Ändern von Daten umfasst. <br><br><h3>  Ereignismodell </h3><br>  Eine Möglichkeit, Codeteile zu lösen, besteht darin, die Interaktion zwischen Diensten über eine Nachrichtenwarteschlange zu organisieren. <br><br>  Wenn wir beispielsweise im Dienst bei der Registrierung eines Benutzers einen Begrüßungsbrief senden, eine Anfrage für einen Kundenmanager in CRM erstellen usw. müssen, ist es logisch, keinen externen Serviceabruf zu tätigen, sondern die Meldung "Benutzer 123 ist registriert" in den Registrierungsdienst aufzunehmen ”, Und alle notwendigen Dienste werden diese Nachricht lesen und die notwendigen Maßnahmen ergreifen.  Gleichzeitig erfordert das Ändern der Geschäftslogik keine Änderung des Registrierungsdienstes. <br><br>  Meistens werden nicht nur Nachrichten in die Warteschlange geworfen, sondern auch Ereignisse.  Da die Warteschlange nur ein Transportprotokoll ist, gelten für die Datenschnittstelle dieselben Einschränkungen wie für die reguläre synchrone Schnittstelle.  Um Probleme beim Ändern der Benutzeroberfläche und bei nachfolgenden Änderungen in anderen Diensten zu vermeiden, ist es daher am besten, Ereignisse so problemorientiert wie möglich zu gestalten.  Dennoch werden solche Ereignisse häufig als Domänenereignisse bezeichnet.  Gleichzeitig hat die Verwendung des Ereignismodells in der Regel keinen großen Einfluss auf die Grenzen, an denen (Mikro-) Dienste kämpfen. <br><br>  Da Domänenereignisse praktisch 1: 1 in synchrone API-Methoden übersetzt werden, schlagen sie manchmal sogar vor, einen Ereignisstrom anstelle eines Ereignisstroms anstelle eines API-Aufrufs zu verwenden (Event Sourcing).  Durch den Ablauf von Ereignissen können Sie jederzeit den Status von Objekten wiederherstellen, haben aber auch einen freien Verlauf.  Tatsächlich ist dieser Ansatz normalerweise nicht sehr flexibel - Sie müssen alle Ereignisse unterstützen, und es ist oft einfacher, eine Story neben der üblichen API zu halten. <br><br><h3>  Microservices und Leistung.  Cqrs </h3><br>  Im Prinzip impliziert der Problembereich Änderungen im Code, die nicht nur mit funktionalen Geschäftsanforderungen verbunden sind, sondern auch mit nicht funktionalen - zum Beispiel der Leistung.  Wenn es zwei Codeteile mit unterschiedlichen Leistungsanforderungen gibt, bedeutet dies, dass die Trennung dieser beiden Codeteile möglicherweise sinnvoll ist.  Und sie sind normalerweise in separate Dienste unterteilt, um verschiedene Sprachen und Technologien verwenden zu können, die für die Aufgabe besser geeignet sind. <br><br>  Beispielsweise gibt es in einem in PHP geschriebenen Dienst eine CPU-gebundene Rechnermethode, die komplexe Berechnungen durchführt.  Mit zunehmender Last und Datenmenge hörte er auf zu bewältigen.  Und natürlich ist es als eine der Optionen sinnvoll, Berechnungen nicht in PHP-Code, sondern in einem separaten Hochleistungssystem-Daemon durchzuführen. <br><br>  Als eines der Beispiele für die Aufteilung von Diensten nach dem Produktivitätsprinzip - die Trennung von Diensten in Lesen und Ändern (CQRS).  Diese Trennung wird häufig angeboten, da die Leistungsanforderungen von Lesediensten und Schreiben unterschiedlich sind.  Die Leselast ist oft eine Größenordnung höher als die Schreiblast.  Und die Anforderungen an die Antwortgeschwindigkeit von Leseanforderungen sind viel höher als für das Schreiben. <br><br>  Der Kunde verbringt 99% der Zeit mit der Suche nach Waren und nur 1% der Zeit mit dem Bestellvorgang.  Für einen Kunden in einem Suchstatus ist die Anzeigegeschwindigkeit wichtig und Funktionen in Bezug auf Filter, verschiedene Optionen zum Anzeigen von Waren usw.  Daher ist es sinnvoll, einen separaten Dienst hervorzuheben, der für die Suche, Filterung und Anzeige von Waren zuständig ist.  Ein solcher Dienst funktioniert höchstwahrscheinlich mit einer Art ELK, einer dokumentenorientierten Datenbank mit denormalisierten Daten. <br><br>  Offensichtlich ist eine naive Unterteilung in Lese- und Änderungsdienste möglicherweise nicht immer gut. <br><br>  Ein Beispiel.  Für einen Manager, der mit dem Füllen der Produktpalette arbeitet, besteht das Hauptmerkmal in der Möglichkeit, Waren bequem hinzuzufügen, zu löschen, zu ändern und anzuzeigen.  Es gibt nicht viel Last, wenn wir das Lesen trennen und in separate Dienste umwandeln, werden wir nichts von einer solchen Trennung erhalten, außer bei Problemen, wenn es notwendig ist, koordinierte Änderungen an den Diensten vorzunehmen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469001/">https://habr.com/ru/post/de469001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468991/index.html">Modulare Sprite-Charaktere und ihre Animation</a></li>
<li><a href="../de468993/index.html">Oculus Quest stellt eine Verbindung zu einem PC her und sieht Hände</a></li>
<li><a href="../de468995/index.html">Offenheitsrichtlinie: Wie Benutzer das Projekt beeinflussen</a></li>
<li><a href="../de468997/index.html">Mentoring - ein Muss oder ein schöner Bonus?</a></li>
<li><a href="../de468999/index.html">Welche Länder haben das „langsamste“ Internet und wer korrigiert die Situation in schwer erreichbaren Regionen?</a></li>
<li><a href="../de469003/index.html">„Konferenz für Menschen und zur Lösung ihrer Bedürfnisse“: DevOpsDays-Programmkomitee für eine Community-Konferenz</a></li>
<li><a href="../de469005/index.html">Ohio Challenger 2P und sein 4 KB RAM</a></li>
<li><a href="../de469007/index.html">RubyRussia 2019. Nikita Shilnikov über algebraische Effekte</a></li>
<li><a href="../de469009/index.html">Frachtkult in der Softwareentwicklung</a></li>
<li><a href="../de469011/index.html">11 Mythen über USB Typ C.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>