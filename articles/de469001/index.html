<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêß üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üçæ Wie man Brei aus Microservices kocht üßù üìµ ü§Ωüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einer der Gr√ºnde f√ºr die Popularit√§t von Microservices ist die M√∂glichkeit einer autonomen und unabh√§ngigen Entwicklung. Im Wesentlichen ist die Micro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man Brei aus Microservices kocht</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469001/">  Einer der Gr√ºnde f√ºr die Popularit√§t von Microservices ist die M√∂glichkeit einer autonomen und unabh√§ngigen Entwicklung.  Im Wesentlichen ist die Microservice-Architektur der Austausch der M√∂glichkeit einer autonomen Entwicklung f√ºr eine komplexere (im Vergleich zu einem Monolithen) Bereitstellung, Test, Debugging und √úberwachung.  Beachten Sie jedoch, dass Microservices die Aufgabentrennung nicht verzeihen.  Wenn die Aufgabentrennung falsch ist, treten bei verschiedenen Diensten h√§ufig abh√§ngige √Ñnderungen auf.  Und dies ist viel schmerzhafter und komplizierter als koordinierte √Ñnderungen im Rahmen verschiedener Module oder Pakete innerhalb des Monolithen.  Konsistente √Ñnderungen an Microservices werden durch das konsistente Layout, die Bereitstellung, das Testen usw. erschwert. <br><br>  Und ich m√∂chte √ºber die verschiedenen Muster und Antimuster der Aufteilung der Zust√§ndigkeiten in Mikrodienste sprechen. <br><a name="habracut"></a><br><h3>  Service Entity als Antipattern </h3><br>  "Service Entity" ist eines der m√∂glichen (Anti) Muster des Designs von Microservice-Architekturen, das zu stark abh√§ngigem Code in verschiedenen Diensten f√ºhrt und innerhalb von Diensten lose gekoppelt ist. <br><br>  F√ºr die meisten Entwickler scheint es, dass er bei der Auswahl von Diensten nach dem Wesen des Themenbereichs: ‚ÄûGesch√§ft‚Äú, ‚ÄûPerson‚Äú, ‚ÄûKunde‚Äú, ‚ÄûAuftrag‚Äú, ‚ÄûBild‚Äú den Grunds√§tzen der alleinigen Verantwortung folgt, und dar√ºber hinaus erscheint dies h√§ufig logisch.  Der Service-Entity-Ansatz kann sich jedoch in ein Antimuster verwandeln.  Dies liegt daran, dass die meisten Funktionen oder √Ñnderungen mehrere Entit√§ten betreffen und nicht eine.  Infolgedessen kombiniert jeder dieser Services die Logik verschiedener Gesch√§ftsprozesse. <br><br>  Nehmen Sie zum Beispiel einen Online-Shop.  Wir haben uns entschlossen, die Dienstleistungen ‚ÄûProdukt‚Äú, ‚ÄûBestellung‚Äú, ‚ÄûKunde‚Äú hervorzuheben. <br><br>  Welche √Ñnderungen und Dienstleistungen sollte ich vornehmen, um die Lieferung nach Hause hinzuzuf√ºgen? <br>  Zum Beispiel k√∂nnen Sie dies tun: <br><br><ul><li>  F√ºgen Sie im Service "Bestellung" die Lieferadresse, die gew√ºnschte Zeit und den Lieferboten hinzu </li><li>  F√ºgen Sie im Client-Service eine Liste ausgew√§hlter Lieferadressen f√ºr den Client hinzu </li><li>  F√ºgen Sie im Service ‚ÄûProdukt‚Äú eine Entit√§tsliste der Waren hinzu </li></ul><br>  F√ºr die Schnittstelle des Lieferanten muss im Bestelldienst eine separate API-Methode erstellt werden, die eine Liste der diesem bestimmten Anbieter zugewiesenen Bestellungen enth√§lt.  Dar√ºber hinaus sind Methoden erforderlich, um Waren aus der Bestellung zu entfernen, die nicht passten oder die der Kunde zum Zeitpunkt der Lieferung abgelehnt hat. <br><br>  Oder welche √Ñnderungen und bei welchen Dienstleistungen muss ich vornehmen, um Rabatte auf den Aktionscode hinzuzuf√ºgen? <br>  Zumindest ben√∂tigen Sie: <br><br><ul><li>  F√ºgen Sie dem Bestellservice einen Aktionscode hinzu </li><li>  F√ºgen Sie im Service "Produkt" hinzu, ob auf den Aktionscode f√ºr dieses Produkt Rabatte gelten </li><li>  F√ºgen Sie im Kundenservice eine Liste der Aktionscodes hinzu, die dem Kunden ausgestellt wurden </li></ul><br>  In der Manageroberfl√§che ist das Hinzuf√ºgen eines personalisierten Aktionscodes zum Kunden eine separate Methode im Kundenservice, die nur f√ºr Filialleiter verf√ºgbar ist, dem Kunden jedoch nicht.  Erstellen Sie im Service "Produkt" eine Methode, die eine Liste der Produkte enth√§lt, die vom Aktionscode betroffen sind, damit der Kunde die Auswahl in seiner Benutzeroberfl√§che erleichtern kann. <br><br>  Die Ursachen f√ºr √Ñnderungen im Service k√∂nnen verschiedene Gesch√§ftsprozesse sein - Auswahl und Design, Zahlung und Abrechnung, Lieferung.  Jeder der Problembereiche hat seine eigenen Einschr√§nkungen, Invarianten und Anforderungen f√ºr die Bestellung.  Infolgedessen stellt sich heraus, dass wir im ‚ÄûProdukt‚Äú -Dienst Informationen √ºber das Produkt, √ºber Rabatte und Produktbilanzen in Lagern speichern.  Und in der "Bestellung" ist die Logik des Zustellers gespeichert. <br><br>  Mit anderen Worten, eine √Ñnderung der Gesch√§ftslogik, die auf mehrere Dienste verteilt ist, f√ºhrt zu abh√§ngigen √Ñnderungen in mehreren Diensten.  Gleichzeitig ist in einem Dienst ein Code enthalten, der nicht miteinander verbunden ist. <br><br><h3>  Speicherdienste </h3><br>  Es scheint, dass dieses Problem gel√∂st werden kann, wenn ein separater "Layer" -Dienst √ºber Entit√§tsdiensten erstellt wird, der die gesamte Logik kapselt.  Aber normalerweise endet das auch schlecht.  Weil dann Entit√§tsdienste zu Speicherdiensten werden, d.h.  Die gesamte Gesch√§ftslogik wird mit Ausnahme der Speicherung aus ihnen herausgewaschen. <br><br>  Wenn die Daten in verschiedenen Datenbanken auf verschiedenen Maschinen gespeichert sind, dann wir <br><br><ul><li>  Wir verlieren an Leistung, weil wir Daten nicht direkt aus der Datenbank, sondern √ºber die Serviceschicht bereitstellen </li><li>  Wir verlieren an Flexibilit√§t, da die Service-API normalerweise viel weniger flexibel ist als SQL oder eine andere Abfragesprache </li><li>  Wir verlieren an Flexibilit√§t, weil es schwierig ist, Daten von verschiedenen Diensten zusammenzuf√ºhren <br></li></ul><br>  Wenn verschiedene Entit√§tsdienste Zugriff auf andere Datenbanken haben, erfolgt die Kommunikation zwischen Diensten implizit. √úber eine gemeinsame Datenbank ist es nur m√∂glich, √Ñnderungen vorzunehmen, die sich auf eine √Ñnderung des Datenschemas auswirken, nachdem √ºberpr√ºft wurde, dass durch diese √Ñnderung nicht alle anderen Dienste besch√§digt werden, die diese Datenbank oder dieses Tablet verwenden . <br><br>  Neben der komplexen Entwicklung werden solche Services zu kritisch und stark ausgelastet. Bei fast jeder Anforderung eines Top-Level-Service m√ºssen Sie mehrere Anforderungen an verschiedene Service-Entit√§ten stellen. Dies bedeutet, dass die Bearbeitung noch schwieriger wird, um den gestiegenen Anforderungen an Zuverl√§ssigkeit und Leistung gerecht zu werden. <br><br>  Aufgrund solcher Schwierigkeiten bei der Entwicklung und Unterst√ºtzung von Entity-Services in ihrer reinen Form sehen Sie selten ein Muster. In der Regel werden Entity-Services zu einem oder zwei zentralen ‚ÄûMicroservice-Monolithen‚Äú, die sich h√§ufig √§ndern und die Hauptgesch√§ftslogik und Placer kleiner Microservices enthalten, bei denen es sich normalerweise um Infrastruktur handelt und kleine, die sich selten √§ndern. <br><br><h3>  Trennung nach Problembereichen </h3><br>  Ver√§nderungen an sich werden nicht geboren, sie kommen aus einem Problembereich.  Ein Problembereich ist ein Aufgabenbereich, in dem Probleme, die √Ñnderungen im Code erfordern, in einer Sprache unter Verwendung eines Satzes von Konzepten formuliert oder durch Gesch√§ftslogik miteinander verbunden werden.  Dementsprechend gibt es im Rahmen eines Problembereichs h√∂chstwahrscheinlich eine Reihe von Einschr√§nkungen, Invarianten, auf die Sie sich beim Schreiben von Code verlassen k√∂nnen. <br><br>  Die Trennung der Verantwortung von Diensten nach Problembereichen und nicht nach Entit√§ten f√ºhrt normalerweise zu einer besser unterst√ºtzten und verst√§ndlicheren Architektur.  Problembereiche entsprechen meist Gesch√§ftsprozessen.  F√ºr den Online-Shop sind die wahrscheinlichsten Problembereiche "Zahlung und Abrechnung", "Lieferung", "Bestellvorgang". <br><br>  √Ñnderungen, die mehrere Problembereiche gleichzeitig betreffen w√ºrden, sind geringer als √Ñnderungen, die mehrere Entit√§ten betreffen w√ºrden. <br><br>  Dar√ºber hinaus k√∂nnen nach Gesch√§ftsprozessen aufgeschl√ºsselte Services in Zukunft wiederverwendet werden.  Wenn wir beispielsweise neben dem Online-Shop einen weiteren Verkauf von Flugtickets t√§tigen m√∂chten, k√∂nnen wir den allgemeinen Service ‚ÄûAbrechnung und Zahlung‚Äú wiederverwenden.  Und machen Sie keine anderen √§hnlich, sondern spezifisch f√ºr den Verkauf von Tickets. <br><br>  Zum Beispiel k√∂nnen wir so in Dienstleistungen unterteilen: <br><br><ul><li>  Eine Dienstleistung oder eine Gruppe von Dienstleistungen ‚ÄûLieferung‚Äú, in der die Arbeitslogik mit der Lieferung eines bestimmten Auftrags, der Organisation der Arbeit der Lieferanten, der Bewertung der Qualit√§t ihrer Arbeit, der mobilen Anwendung des Lieferanten usw. gespeichert wird. </li><li>  Ein Dienst oder eine Gruppe von Diensten ‚ÄûAbrechnung und Zahlung‚Äú, in denen die Logik der Arbeit mit Zahlungen, Zahlungskonten f√ºr juristische Personen, der Erstellung von Vertr√§gen und Abschlussdokumenten gespeichert wird. </li><li>  Service oder Gruppe von Services ‚ÄûBestellprozess‚Äú, in dem die Logik der Produktauswahl, Katalogisierung, Marken, Warenkorblogik usw. des Kunden gespeichert ist. </li><li>  Service "Autorisierung und Authentifizierung". </li><li>  Es kann sogar sinnvoll sein, den Rabattdienst zu trennen. </li></ul><br>  Um miteinander zu interagieren, k√∂nnen Dienste das Ereignismodell verwenden oder einfache Objekte miteinander austauschen (erholsame API, GRPC usw.).  Es ist zwar erw√§hnenswert, dass es nicht einfach ist, die Interaktion zwischen solchen Diensten korrekt zu organisieren.  Zumindest hat die Datendezentralisierung irgendwann Probleme mit der Konsistenz (eventuelle Konsistenz) und der Transaktionsf√§higkeit (falls dies wichtig ist). <br><br>  Die Dezentralisierung von Daten, der Austausch einfacher Objekte hat Vor- und Nachteile.  Einerseits erm√∂glicht die Dezentralisierung die unabh√§ngige Entwicklung und den Betrieb mehrerer Dienste.  Andererseits die Kosten f√ºr das Speichern von zwei oder drei Kopien von Daten und die Aufrechterhaltung der Konsistenz in verschiedenen Systemen. <br><br>  Im wirklichen Leben passiert oft etwas dazwischen.  Service-Entit√§t mit einem Mindestsatz von Attributen, die von allen Services von Verbrauchern verwendet wird.  Und eine minimale Logikschicht - zum Beispiel ein Statusmodell und Ereignisse in der Warteschlange mit der Benachrichtigung √ºber alle √Ñnderungen in der Entit√§t.  Gleichzeitig behalten Verbraucherdienste immer noch h√§ufig einen ‚ÄûCache‚Äú von Daten.  Es wird alles M√∂gliche getan, damit sich an einem solchen Dienst so wenig wie m√∂glich √§ndert, und dies ist im Prinzip schwierig, da es viele Verbraucher gibt. <br><br>  Gleichzeitig ist es wichtig zu verstehen, dass jede Partition - sowohl nach Entit√§t als auch nach Problembereich - kein Patentrezept ist. Es wird immer Funktionen geben, die abh√§ngige √Ñnderungen in mehreren Diensten erfordern.  Es ist nur so, dass es bei einer Panne viel mehr solche √Ñnderungen geben wird als bei einer anderen.  Die Aufgabe der Entwicklung besteht darin, die Anzahl der abh√§ngigen √Ñnderungen zu minimieren. <br><br>  Eine ideale Aufteilung ist nur m√∂glich, wenn Sie zwei v√∂llig unabh√§ngige Produkte haben.  In jedem Gesch√§ft ist alles mit allem verbunden. Die einzige Frage ist, wie viel damit verbunden ist. <br><br>  Und die Frage ist die Trennung der Verantwortlichkeiten und die H√∂he der Hindernisse f√ºr Abstraktionen. <br><br><h3>  Design Service API </h3><br>  Das Entwerfen von Schnittstellen innerhalb des Dienstes wiederholt den Verlauf mit der Aufteilung in Dienste nur in kleinerem Ma√üstab.  Das √Ñndern der Schnittstelle (nicht nur einer Erweiterung) ist komplex und zeitaufw√§ndig.  In komplexen Anwendungen sollte die Schnittstelle universell genug sein, um keine st√§ndigen √Ñnderungen zu verursachen, und sie sollte spezifisch und spezifisch genug sein, um keine Ausbreitung von Verantwortung und Semantik zu verursachen. <br><br>  Daher m√ºssen Dienstschnittstellen so gestaltet sein, dass ihre Semantik √Ñnderungen widersteht.  Dies ist m√∂glich, wenn sich die Semantik oder der Verantwortungsbereich der Schnittstelle auf die Einschr√§nkungen des Problembereichs st√ºtzt. <br><br><h3>  CRUD-Schnittstellen f√ºr Services mit komplexer Gesch√§ftslogik </h3><br>  Eine zu breite und unspezifische Schnittstelle tr√§gt entweder zur Erosion der Verantwortung oder zu √ºberm√§√üiger Komplexit√§t bei. <br><br>  Beispiel: CRUD-API f√ºr Dienste mit komplexer Gesch√§ftslogik. Solche Schnittstellen kapseln kein Verhalten.  Sie erm√∂glichen nicht nur, dass Gesch√§ftslogik in andere Dienste eindringt und die Verantwortung des Dienstes untergr√§bt, sondern provozieren auch die Verbreitung von Gesch√§ftslogik - Einschr√§nkungen, Invarianten und Methoden f√ºr die Arbeit mit Daten sind jetzt in anderen Diensten enthalten.  Interface User Services (APIs) m√ºssen die Logik selbst implementieren. <br><br>  Wenn wir versuchen, ohne die Schnittstelle wesentlich zu √§ndern, die Gesch√§ftslogik auf den Service zu √ºbertragen, erhalten wir eine zu universelle und zu komplizierte Methode. <br><br>  Zum Beispiel gibt es einen Ticketservice.  Es gibt verschiedene Arten von Tickets.  Jeder Typ hat einen anderen Satz von Feldern und eine etwas andere Validierung.  Das Ticket hat auch ein Statusmodell - eine Zustandsmaschine f√ºr den √úbergang von einem Status zu einem anderen. <br><br>  Lassen Sie die API folgenderma√üen aussehen: POST / PATCH / GET-Methoden, URL /api/v1/tickets/{ticket_idasket.json <br><br>  So k√∂nnen Sie das Ticket aktualisieren <br><br><pre><code class="json hljs">PATCH /api/v<span class="hljs-number"><span class="hljs-number">1</span></span>/tickets/{ticket_id}.json { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bug"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"closed"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> }</code> </pre> <br>  Wenn das Statusmodell vom Ticket abh√§ngt, sind Konflikte der Gesch√§ftslogik m√∂glich.  √Ñndern Sie zuerst den Status gem√§√ü dem alten Statusmodell und dann den Ticket-Typ.  Oder umgekehrt? <br><br>  Es stellt sich heraus, dass es innerhalb der API-Methode Code gibt, der nicht miteinander verbunden ist - sich √§ndernde Entit√§tsfelder, eine Liste verf√ºgbarer Felder, abh√§ngig vom Ticket-Typ, und ein Statusmodell.  Sie √§ndern sich aus verschiedenen Gr√ºnden und es ist sinnvoll, sie nach verschiedenen API-Methoden und -Schnittstellen zu verteilen. <br><br>  Wenn das √Ñndern eines Felds im Rahmen von API-CRUD-Methoden nicht nur eine Daten√§nderung ist, sondern eine Operation, die sich auf eine koordinierte √Ñnderung des Status einer Entit√§t bezieht, sollte diese Operation in eine separate Methode √ºbernommen und nicht direkt ge√§ndert werden.  Wenn das √Ñndern einer API ohne Abw√§rtskompatibilit√§t (f√ºr √∂ffentliche APIs) sehr schlecht ist, sollten Sie beim Entwerfen der API sofort dar√ºber nachdenken. <br><br>  Um solche Probleme zu vermeiden, ist es daher besser, die Schnittstellen klein, spezifisch und so problemorientiert wie m√∂glich zu gestalten, als universelle datenzentrierte. <br><br>  Dieses (Anti) Muster ist h√§ufiger charakteristisch f√ºr RESTful-Schnittstellen, da standardm√§√üig nur wenige datenzentrierte ‚ÄûVerben‚Äú von Aktionen zum Erstellen, L√∂schen, Aktualisieren und Lesen vorhanden sind.  Keine gesch√§ftsspezifischen Entit√§tsoperationen <br><br>  Was kann getan werden, um RESTful problemorientierter zu machen? <br>  Zun√§chst k√∂nnen Sie Entit√§ten Methoden hinzuf√ºgen.  Die Schnittstelle wird weniger erholsam.  Aber es gibt eine solche Gelegenheit.  Wir k√§mpfen immer noch nicht f√ºr die Reinheit des Rennens, sondern l√∂sen praktische Probleme <br><br>  <code>/api/v1/tickets.json</code> Sie anstelle der universellen Ressource <code>/api/v1/tickets.json</code> weitere Ressourcen hinzu: <br><br>  <code>/api/v1/tickets/{ticket_id}/migrate.json</code> - Migrieren Sie von einem Typ zu einem anderen <br>  <code>/api/v1/tickets/{ticket_id}/status.json</code> - wenn es ein <code>/api/v1/tickets/{ticket_id}/status.json</code> gibt <br><br>  Zweitens k√∂nnen Sie sich jede Operation als Ressource im Rahmen von REST vorstellen.  Gibt es eine Ticketmigrationsoperation von einem Typ zu einem anderen (oder von einem Projekt zu einem anderen?).  Ok, es wird also eine Ressource geben <br> <code>/api/v1/tickets/migration.json</code> <br> <br>  Gibt es einen Gesch√§ftsbetrieb zum Erstellen eines Testabonnements? <br> <code>/api/v1/subscriptions/trial.json</code> <br> <br>  Gibt es eine Geldtransferoperation? <br> <code>/api/v1/money_transfers.json</code> <br> <br>  Usw. <br><br>  Das Antipattern mit der datenzentrierten API bezieht sich tats√§chlich auch auf die RPC-Interaktion.  Zum Beispiel das Vorhandensein zu allgemeiner Methoden wie editAccount () oder editTicket ().  "Objekt √§ndern" tr√§gt nicht die semantische Last, die dem Problembereich zugeordnet ist.  Dies bedeutet, dass diese Methode aus verschiedenen Gr√ºnden aufgerufen wird, aus verschiedenen Gr√ºnden, um sich zu √§ndern. <br><br>  Es ist zu beachten, dass datenzentrierte Schnittstellen in Ordnung sind, wenn der Problembereich nur das Speichern, Empfangen und √Ñndern von Daten umfasst. <br><br><h3>  Ereignismodell </h3><br>  Eine M√∂glichkeit, Codeteile zu l√∂sen, besteht darin, die Interaktion zwischen Diensten √ºber eine Nachrichtenwarteschlange zu organisieren. <br><br>  Wenn wir beispielsweise im Dienst bei der Registrierung eines Benutzers einen Begr√º√üungsbrief senden, eine Anfrage f√ºr einen Kundenmanager in CRM erstellen usw. m√ºssen, ist es logisch, keinen externen Serviceabruf zu t√§tigen, sondern die Meldung "Benutzer 123 ist registriert" in den Registrierungsdienst aufzunehmen ‚Äù, Und alle notwendigen Dienste werden diese Nachricht lesen und die notwendigen Ma√ünahmen ergreifen.  Gleichzeitig erfordert das √Ñndern der Gesch√§ftslogik keine √Ñnderung des Registrierungsdienstes. <br><br>  Meistens werden nicht nur Nachrichten in die Warteschlange geworfen, sondern auch Ereignisse.  Da die Warteschlange nur ein Transportprotokoll ist, gelten f√ºr die Datenschnittstelle dieselben Einschr√§nkungen wie f√ºr die regul√§re synchrone Schnittstelle.  Um Probleme beim √Ñndern der Benutzeroberfl√§che und bei nachfolgenden √Ñnderungen in anderen Diensten zu vermeiden, ist es daher am besten, Ereignisse so problemorientiert wie m√∂glich zu gestalten.  Dennoch werden solche Ereignisse h√§ufig als Dom√§nenereignisse bezeichnet.  Gleichzeitig hat die Verwendung des Ereignismodells in der Regel keinen gro√üen Einfluss auf die Grenzen, an denen (Mikro-) Dienste k√§mpfen. <br><br>  Da Dom√§nenereignisse praktisch 1: 1 in synchrone API-Methoden √ºbersetzt werden, schlagen sie manchmal sogar vor, einen Ereignisstrom anstelle eines Ereignisstroms anstelle eines API-Aufrufs zu verwenden (Event Sourcing).  Durch den Ablauf von Ereignissen k√∂nnen Sie jederzeit den Status von Objekten wiederherstellen, haben aber auch einen freien Verlauf.  Tats√§chlich ist dieser Ansatz normalerweise nicht sehr flexibel - Sie m√ºssen alle Ereignisse unterst√ºtzen, und es ist oft einfacher, eine Story neben der √ºblichen API zu halten. <br><br><h3>  Microservices und Leistung.  Cqrs </h3><br>  Im Prinzip impliziert der Problembereich √Ñnderungen im Code, die nicht nur mit funktionalen Gesch√§ftsanforderungen verbunden sind, sondern auch mit nicht funktionalen - zum Beispiel der Leistung.  Wenn es zwei Codeteile mit unterschiedlichen Leistungsanforderungen gibt, bedeutet dies, dass die Trennung dieser beiden Codeteile m√∂glicherweise sinnvoll ist.  Und sie sind normalerweise in separate Dienste unterteilt, um verschiedene Sprachen und Technologien verwenden zu k√∂nnen, die f√ºr die Aufgabe besser geeignet sind. <br><br>  Beispielsweise gibt es in einem in PHP geschriebenen Dienst eine CPU-gebundene Rechnermethode, die komplexe Berechnungen durchf√ºhrt.  Mit zunehmender Last und Datenmenge h√∂rte er auf zu bew√§ltigen.  Und nat√ºrlich ist es als eine der Optionen sinnvoll, Berechnungen nicht in PHP-Code, sondern in einem separaten Hochleistungssystem-Daemon durchzuf√ºhren. <br><br>  Als eines der Beispiele f√ºr die Aufteilung von Diensten nach dem Produktivit√§tsprinzip - die Trennung von Diensten in Lesen und √Ñndern (CQRS).  Diese Trennung wird h√§ufig angeboten, da die Leistungsanforderungen von Lesediensten und Schreiben unterschiedlich sind.  Die Leselast ist oft eine Gr√∂√üenordnung h√∂her als die Schreiblast.  Und die Anforderungen an die Antwortgeschwindigkeit von Leseanforderungen sind viel h√∂her als f√ºr das Schreiben. <br><br>  Der Kunde verbringt 99% der Zeit mit der Suche nach Waren und nur 1% der Zeit mit dem Bestellvorgang.  F√ºr einen Kunden in einem Suchstatus ist die Anzeigegeschwindigkeit wichtig und Funktionen in Bezug auf Filter, verschiedene Optionen zum Anzeigen von Waren usw.  Daher ist es sinnvoll, einen separaten Dienst hervorzuheben, der f√ºr die Suche, Filterung und Anzeige von Waren zust√§ndig ist.  Ein solcher Dienst funktioniert h√∂chstwahrscheinlich mit einer Art ELK, einer dokumentenorientierten Datenbank mit denormalisierten Daten. <br><br>  Offensichtlich ist eine naive Unterteilung in Lese- und √Ñnderungsdienste m√∂glicherweise nicht immer gut. <br><br>  Ein Beispiel.  F√ºr einen Manager, der mit dem F√ºllen der Produktpalette arbeitet, besteht das Hauptmerkmal in der M√∂glichkeit, Waren bequem hinzuzuf√ºgen, zu l√∂schen, zu √§ndern und anzuzeigen.  Es gibt nicht viel Last, wenn wir das Lesen trennen und in separate Dienste umwandeln, werden wir nichts von einer solchen Trennung erhalten, au√üer bei Problemen, wenn es notwendig ist, koordinierte √Ñnderungen an den Diensten vorzunehmen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469001/">https://habr.com/ru/post/de469001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468991/index.html">Modulare Sprite-Charaktere und ihre Animation</a></li>
<li><a href="../de468993/index.html">Oculus Quest stellt eine Verbindung zu einem PC her und sieht H√§nde</a></li>
<li><a href="../de468995/index.html">Offenheitsrichtlinie: Wie Benutzer das Projekt beeinflussen</a></li>
<li><a href="../de468997/index.html">Mentoring - ein Muss oder ein sch√∂ner Bonus?</a></li>
<li><a href="../de468999/index.html">Welche L√§nder haben das ‚Äûlangsamste‚Äú Internet und wer korrigiert die Situation in schwer erreichbaren Regionen?</a></li>
<li><a href="../de469003/index.html">‚ÄûKonferenz f√ºr Menschen und zur L√∂sung ihrer Bed√ºrfnisse‚Äú: DevOpsDays-Programmkomitee f√ºr eine Community-Konferenz</a></li>
<li><a href="../de469005/index.html">Ohio Challenger 2P und sein 4 KB RAM</a></li>
<li><a href="../de469007/index.html">RubyRussia 2019. Nikita Shilnikov √ºber algebraische Effekte</a></li>
<li><a href="../de469009/index.html">Frachtkult in der Softwareentwicklung</a></li>
<li><a href="../de469011/index.html">11 Mythen √ºber USB Typ C.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>