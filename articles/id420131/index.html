<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≠ üõ∏ üõÄüèø Metode Penambangan Bitcoin Probabilistik üë®üèø‚Äçüéì üìΩÔ∏è üôÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya pikir sedikit omong kosong pada hari Selasa tidak akan melukai minggu kerja. Saya memiliki hobi, di waktu luang saya mencoba mencari cara untuk m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode Penambangan Bitcoin Probabilistik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420131/"><img src="https://habrastorage.org/webt/oi/lh/dt/oilhdtkhhgrgz2gpjy00mjrxhaq.jpeg"><br><br>  Saya pikir sedikit omong kosong pada hari Selasa tidak akan melukai minggu kerja.  Saya memiliki hobi, di waktu luang saya mencoba mencari cara untuk meretas algoritma penambangan bitcoin, menghindari pencarian nonse bodoh dan menemukan solusi untuk masalah pencocokan hash dengan konsumsi energi minimal.  Saya harus mengatakan langsung hasilnya, tentu saja, saya belum mencapainya, tetapi mengapa saya tidak menuliskan ide-ide yang lahir di kepala?  Di suatu tempat mereka perlu ditempatkan ... <br><br>  Terlepas dari khayalan dari ide-ide di bawah ini, saya pikir artikel ini mungkin berguna bagi seseorang yang sedang belajar <br><br><ol><li>  Bahasa C ++ dan templatnya </li><li>  beberapa sirkuit digital </li><li>  sedikit teori probabilitas dan aritmatika probabilistik </li><li>  algoritma hashing bitcoin secara detail </li></ol><a name="habracut"></a><br>  Di mana kita mulai? <br><br>  Mungkin dari item terakhir dan paling membosankan di daftar ini?  Sabar, maka itu akan lebih menyenangkan. <br>  Mari kita pertimbangkan secara rinci algoritma untuk menghitung fungsi hashing bitcoin.  Sederhana F (x) = sha256 (sha256 (x)), di mana x adalah input 80 byte, header blok bersama dengan nomor versi blok, blok hash, root merkle, timestamp, bits dan nonce.  Berikut adalah contoh header blok yang cukup baru yang dilewatkan ke fungsi hashing: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//blk=533522 0x00,0x00,0x00,0x20, 0x6d,0xa5,0xdd,0xb5,0x78,0x04,0x08,0x80,0xae,0x3d,0xed,0xc5,0x8e,0xe9,0x74,0x93,0x93,0x6d,0x6a,0xf4,0x0e,0x80,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xdf,0x3e,0xb0,0xf4,0x92,0xbf,0xe9,0xb8,0xc8,0x12,0x1f,0x84,0xdd,0x35,0xe1,0x38,0x09,0xcc,0x28,0xc2,0x33,0x53,0x90,0x4e,0x15,0x49,0x5e,0xc7,0xb0,0x78,0x35,0x91, 0x82,0xDB,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0xAA,0x02,0x44,0x22, //blk=533523 0x00,0x00,0x00,0x20, 0x6a,0x27,0x37,0xc3,0x1f,0x68,0xf8,0xe3,0x03,0xa3,0x5d,0xff,0x2d,0x97,0x39,0xaf,0x81,0xa2,0xf5,0xf0,0x7c,0xdb,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xa1,0xb8,0x4f,0x75,0x66,0xf3,0xf3,0x8e,0x78,0xf7,0xa2,0xa2,0xa2,0x19,0xa1,0x18,0x45,0xfa,0x58,0x53,0xe4,0x05,0x50,0x12,0x57,0xa1,0xab,0x2c,0x39,0xe6,0x1f,0x63, 0xA0,0xDB,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0x84,0x7B,0x86,0xE7, //blk=533524 0x00,0x00,0x00,0x20, 0xb3,0xc7,0xaa,0x07,0x26,0xdb,0xe8,0x58,0x19,0xa8,0xb9,0x53,0x08,0x62,0x8b,0xca,0x58,0x00,0x69,0x64,0x58,0x69,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x4e,0xfc,0xf4,0x5c,0xad,0x31,0x44,0x5b,0xb1,0x13,0x80,0x03,0xe0,0xfd,0x04,0x24,0x86,0xcc,0x7a,0x8c,0xa7,0x7c,0x30,0x60,0x05,0x6f,0x43,0xcf,0x25,0x45,0x8f,0xd8, 0x80,0xDE,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0xF7,0x2B,0x3B,0x42,</span></span></code> </pre> <br>  Kumpulan byte ini adalah bahan yang cukup berharga, karena seringkali tidak mudah bagi penambang untuk mencari tahu dalam urutan apa byte harus mengikuti ketika membentuk header, sering membalikkan tempat byte rendah dan tinggi (endian). <br><br>  Jadi, dari header blok, 80 byte dianggap hash sha256 dan kemudian dari hasil sha256 lain. <br>  Algoritma sha256 itu sendiri, jika Anda melihat sumber yang berbeda, biasanya terdiri dari empat fungsi: <br><br><ol><li>  membatalkan sha256_init (SHA256_CTX * ctx); </li><li>  membatalkan sha256_transform (SHA256_CTX * ctx, const BYTE data []); </li><li>  membatalkan sha256_update (SHA256_CTX * ctx, const BYTE data [], size_t len); </li><li>  membatalkan sha256_final (SHA256_CTX * ctx, BYTE hash []); </li></ol><br>  Fungsi pertama yang dipanggil saat menghitung hash adalah sha256_init (), yang mengembalikan struktur SHA256_CTX.  Tidak ada yang istimewa di sana kecuali delapan kata negara 32-bit, yang awalnya diisi dengan kata-kata khusus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SHA256_CTX *ctx)</span></span></span><span class="hljs-function"> </span></span>{ ctx-&gt;datalen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ctx-&gt;bitlen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x6a09e667</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbb67ae85</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0x3c6ef372</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0xa54ff53a</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">0x510e527f</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-number"><span class="hljs-number">0x9b05688c</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">0x1f83d9ab</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-number"><span class="hljs-number">0x5be0cd19</span></span>; }</code> </pre><br>  Misalkan kita memiliki file yang hash-nya perlu dihitung.  Kami membaca file dengan blok ukuran sewenang-wenang dan memanggil fungsi sha256_update () tempat kami meneruskan pointer ke data blok dan panjang blok.  Fungsi mengakumulasi hash dalam struktur SHA256_CTX dalam array status: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SHA256_CTX *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BYTE data[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { ctx-&gt;data[ctx-&gt;datalen] = data[i]; ctx-&gt;datalen++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx-&gt;datalen == <span class="hljs-number"><span class="hljs-number">64</span></span>) { sha256_transform(ctx, ctx-&gt;data); ctx-&gt;bitlen += <span class="hljs-number"><span class="hljs-number">512</span></span>; ctx-&gt;datalen = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br>  Dengan sendirinya, sha256_update () memanggil fungsi workhorse sha256_transform (), yang sudah menerima blok hanya panjang tetap 64 byte: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/****************************** MACROS ******************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ROTLEFT(a,b) (((a) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (b)) | ((a) &gt;&gt; (32-(b)))) #define ROTRIGHT(a,b) (((a) &gt;&gt; (b)) | ((a) &lt;&lt; (32-(b)))) #define CH(x,y,z) (((x) &amp; (y)) ^ (~(x) &amp; (z))) #define MAJ(x,y,z) (((x) &amp; (y)) ^ ((x) &amp; (z)) ^ ((y) &amp; (z))) #define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22)) #define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25)) #define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) &gt;&gt; 3)) #define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) &gt;&gt; 10)) /**************************** VARIABLES *****************************/ static const uint32_t k[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; /*********************** FUNCTION DEFINITIONS ***********************/ void sha256_transform(SHA256_CTX *ctx, const BYTE data[]) { uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64]; for (i = 0, j = 0; i &lt; 16; ++i, j += 4) m[i] = (data[j] &lt;&lt; 24) | (data[j + 1] &lt;&lt; 16) | (data[j + 2] &lt;&lt; 8) | (data[j + 3]); for (; i &lt; 64; ++i) m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16]; a = ctx-&gt;state[0]; b = ctx-&gt;state[1]; c = ctx-&gt;state[2]; d = ctx-&gt;state[3]; e = ctx-&gt;state[4]; f = ctx-&gt;state[5]; g = ctx-&gt;state[6]; h = ctx-&gt;state[7]; for (i = 0; i &lt; 64; ++i) { t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i]; t2 = EP0(a) + MAJ(a, b, c); h = g; g = f; f = e; e = d + t1; d = c; c = b; b = a; a = t1 + t2; } ctx-&gt;state[0] += a; ctx-&gt;state[1] += b; ctx-&gt;state[2] += c; ctx-&gt;state[3] += d; ctx-&gt;state[4] += e; ctx-&gt;state[5] += f; ctx-&gt;state[6] += g; ctx-&gt;state[7] += h; }</span></span></span></span></code> </pre><br>  Ketika seluruh file hash telah dibaca dan sudah ditransfer ke fungsi sha256_update (), yang tersisa adalah memanggil fungsi sha256_final () terakhir, yang jika ukuran file bukan kelipatan 64 byte, itu akan menambahkan padding byte tambahan, menulis total panjang data pada akhir blok data terakhir dan akan melakukan sha256_transform () terakhir. <br>  Hasil hash tetap di array negara. <br><br>  Ini adalah "level tinggi" untuk berbicara. <br><br>  Sehubungan dengan penambang Bitcoin, tentu saja, para pengembang berpikir bagaimana mempertimbangkan lebih kecil dan lebih efisien. <br><br>  Sederhana: header hanya berisi 80 byte, yang bukan kelipatan 64 byte.  Dengan demikian, perlu sha256 pertama untuk melakukan dua sha256_transform ().  Namun, untungnya bagi para penambang, nonce dari blok ada di akhir header, jadi sha256_transform () pertama dapat dieksekusi hanya sekali - ini akan disebut midstate.  Selanjutnya, penambang melewati semua opsi nonse, yaitu 4 miliar, 2 ^ 32 dan menggantinya di bidang yang sesuai untuk sha256_transform kedua ().  Transformasi ini melengkapi fungsi sha256 pertama.  Hasilnya adalah delapan kata 32-bit, yaitu 32 byte.  Sangat mudah untuk menemukan sha256 dari mereka - sha256_transform () terakhir dipanggil, dan semuanya siap.  Perhatikan bahwa data input 32 byte lebih kecil dari 64 byte yang diperlukan untuk sha256_transform ().  Jadi sekali lagi blok akan diisi dengan nol dan panjang blok akan dimasukkan di akhir. <br><br>  Secara total, hanya ada tiga panggilan ke sha256_transform () di mana yang pertama harus dibaca hanya sekali untuk menghitung keadaan tengah. <br><br>  Saya mencoba untuk memperluas semua manipulasi data yang terjadi ketika menghitung hash dari header bitcoin menjadi satu fungsi, sehingga jelas bagaimana seluruh perhitungan terjadi khusus untuk bitcoin dan inilah yang terjadi: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//get bitcoin header via ptr to 80 bytes and calc hash template &lt;typename T&gt; void full_btc_hash(const uint8_t* ptr80, T nonce, T* presult) { //-1------------------------------------------ //init sha256 state s[7:0] T s[16]; for (int i = 0; i &lt; 8; i++) { s[i] = sha256_init_state[i]; presult[i] = sha256_init_state[i]; } uint8_t tail2[] = { 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00, }; uint32_t* p = (uint32_t*)tail2; for (int i = 0; i &lt; 8; i++) { s[i + 8] = ntohl(p[i]); } //get first block for sha256 uint8_t tail[] = { /* 2nd sha256 block padding */ 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x80 }; T blk1[32]; p = (uint32_t*)ptr80; for (int i = 0; i &lt; 19; i++) { blk1[i] = ntohl(p[i]); } //put nonce here blk1[19] = nonce; p = (uint32_t*)tail; for (int i = 0; i &lt; 12; i++) { blk1[i + 20] = ntohl(p[i]); } sha256_transform(s, &amp;blk1[0]); //warning! this can be called only once and produce MIDSTATE sha256_transform(s, &amp;blk1[16]); sha256_transform(presult, s); }</span></span></code> </pre><br>  Saya mengimplementasikan fungsi ini sebagai templat c ++, ia dapat beroperasi tidak hanya pada kata-kata 32-bit, katakanlah uint32_t, tetapi beroperasi pada kata-kata dengan tipe ‚ÄúT‚Äù yang berbeda dengan cara yang sama.  Saya miliki di sini dan keadaan sha256 disimpan sebagai array bertipe ‚ÄúT‚Äù dan sha256_transform () disebut dengan pointer parameter ke array bertipe ‚ÄúT‚Äù dan hasilnya dikembalikan sama.  Fungsi transformasi sekarang juga dalam bentuk template c ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ror32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T word, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shift)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (word &gt;&gt; shift) | (word &lt;&lt; (<span class="hljs-number"><span class="hljs-number">32</span></span> - shift)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x, T y, T z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z ^ (x &amp; (y ^ z)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x, T y, T z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &amp; y) | (z &amp; (x | y)); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e0(x) (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e1(x) (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s0(x) (ror32(x, 7) ^ ror32(x,18) ^ (x &gt;&gt; 3)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s1(x) (ror32(x,17) ^ ror32(x,19) ^ (x &gt;&gt; 10)) unsigned int ntohl(unsigned int in) { return ((in &amp; 0xff) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24) | ((in &amp; 0xff00) &lt;&lt; 8) | ((in &amp; 0xff0000) &gt;&gt; 8) | ((in &amp; 0xff000000) &gt;&gt; 24); } template &lt;typename T&gt; void LOAD_OP(int I, T *W, const u8 *input) { //W[I] = /*ntohl*/ (((u32*)(input))[I]); W[I] = ntohl(((u32*)(input))[I]); //W[I] = (input[3] &lt;&lt; 24) | (input[2] &lt;&lt; 16) | (input[1] &lt;&lt; 8) | (input[0]); } template &lt;typename T&gt; void BLEND_OP(int I, T *W) { W[I] = s1(W[I - 2]) + W[I - 7] + s0(W[I - 15]) + W[I - 16]; } template &lt;typename T&gt; void sha256_transform(T *state, const T *input) { T a, b, c, d, e, f, g, h, t1, t2; TW[64]; int i; /* load the input */ for (i = 0; i &lt; 16; i++) // MJ input is cast to u32* so this processes 16 DWORDS = 64 bytes W[i] = input[i]; /* now blend */ for (i = 16; i &lt; 64; i++) BLEND_OP(i, W); /* load the state into our registers */ a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; f = state[5]; g = state[6]; h = state[7]; // t1 = h + e1(e) + Ch(e, f, g) + 0x428a2f98 + W[0]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x71374491 + W[1]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xb5c0fbcf + W[2]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xe9b5dba5 + W[3]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x3956c25b + W[4]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x59f111f1 + W[5]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x923f82a4 + W[6]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xab1c5ed5 + W[7]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xd807aa98 + W[8]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x12835b01 + W[9]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x243185be + W[10]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x550c7dc3 + W[11]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x72be5d74 + W[12]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x80deb1fe + W[13]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x9bdc06a7 + W[14]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xc19bf174 + W[15]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xe49b69c1 + W[16]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xefbe4786 + W[17]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x0fc19dc6 + W[18]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x240ca1cc + W[19]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x2de92c6f + W[20]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x4a7484aa + W[21]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x5cb0a9dc + W[22]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x76f988da + W[23]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x983e5152 + W[24]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xa831c66d + W[25]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xb00327c8 + W[26]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xbf597fc7 + W[27]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0xc6e00bf3 + W[28]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xd5a79147 + W[29]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x06ca6351 + W[30]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x14292967 + W[31]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x27b70a85 + W[32]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x2e1b2138 + W[33]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x4d2c6dfc + W[34]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x53380d13 + W[35]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x650a7354 + W[36]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x766a0abb + W[37]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x81c2c92e + W[38]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x92722c85 + W[39]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xa2bfe8a1 + W[40]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xa81a664b + W[41]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xc24b8b70 + W[42]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xc76c51a3 + W[43]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0xd192e819 + W[44]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xd6990624 + W[45]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0xf40e3585 + W[46]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x106aa070 + W[47]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x19a4c116 + W[48]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x1e376c08 + W[49]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x2748774c + W[50]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x34b0bcb5 + W[51]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x391c0cb3 + W[52]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x4ed8aa4a + W[53]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x5b9cca4f + W[54]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x682e6ff3 + W[55]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x748f82ee + W[56]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x78a5636f + W[57]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x84c87814 + W[58]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x8cc70208 + W[59]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x90befffa + W[60]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xa4506ceb + W[61]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0xbef9a3f7 + W[62]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xc67178f2 + W[63]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; state[5] += f; state[6] += g; state[7] += h; }</span></span></span></span></code> </pre><br>  Menggunakan fungsi template C ++ nyaman karena saya bisa menghitung hash yang saya butuhkan dari data biasa dan mendapatkan hasil yang biasa: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> header[] = { <span class="hljs-number"><span class="hljs-number">0x02</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x17</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x5b</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0xc1</span></span>,<span class="hljs-number"><span class="hljs-number">0x8e</span></span>,<span class="hljs-number"><span class="hljs-number">0xd1</span></span>,<span class="hljs-number"><span class="hljs-number">0xf7</span></span>, <span class="hljs-number"><span class="hljs-number">0xe2</span></span>,<span class="hljs-number"><span class="hljs-number">0x55</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0xf2</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x59</span></span>,<span class="hljs-number"><span class="hljs-number">0x9b</span></span>,<span class="hljs-number"><span class="hljs-number">0x55</span></span>, <span class="hljs-number"><span class="hljs-number">0x33</span></span>,<span class="hljs-number"><span class="hljs-number">0x0e</span></span>,<span class="hljs-number"><span class="hljs-number">0xda</span></span>,<span class="hljs-number"><span class="hljs-number">0xb8</span></span>,<span class="hljs-number"><span class="hljs-number">0x78</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0xc8</span></span>,<span class="hljs-number"><span class="hljs-number">0x17</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x8a</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x29</span></span>,<span class="hljs-number"><span class="hljs-number">0x5a</span></span>,<span class="hljs-number"><span class="hljs-number">0x27</span></span>,<span class="hljs-number"><span class="hljs-number">0x47</span></span>,<span class="hljs-number"><span class="hljs-number">0xb4</span></span>,<span class="hljs-number"><span class="hljs-number">0xf1</span></span>, <span class="hljs-number"><span class="hljs-number">0xa0</span></span>,<span class="hljs-number"><span class="hljs-number">0xb3</span></span>,<span class="hljs-number"><span class="hljs-number">0x94</span></span>,<span class="hljs-number"><span class="hljs-number">0x8d</span></span>,<span class="hljs-number"><span class="hljs-number">0xf3</span></span>,<span class="hljs-number"><span class="hljs-number">0x99</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x44</span></span>, <span class="hljs-number"><span class="hljs-number">0xc0</span></span>,<span class="hljs-number"><span class="hljs-number">0xe1</span></span>,<span class="hljs-number"><span class="hljs-number">0x9f</span></span>,<span class="hljs-number"><span class="hljs-number">0xa6</span></span>,<span class="hljs-number"><span class="hljs-number">0xb2</span></span>,<span class="hljs-number"><span class="hljs-number">0xb9</span></span>,<span class="hljs-number"><span class="hljs-number">0x2b</span></span>,<span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">0x19</span></span>,<span class="hljs-number"><span class="hljs-number">0xc8</span></span>,<span class="hljs-number"><span class="hljs-number">0xe6</span></span>,<span class="hljs-number"><span class="hljs-number">0xba</span></span>, <span class="hljs-number"><span class="hljs-number">0xdc</span></span>,<span class="hljs-number"><span class="hljs-number">0x14</span></span>,<span class="hljs-number"><span class="hljs-number">0x17</span></span>,<span class="hljs-number"><span class="hljs-number">0x87</span></span>, <span class="hljs-number"><span class="hljs-number">0x35</span></span>,<span class="hljs-number"><span class="hljs-number">0x8b</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x53</span></span>, <span class="hljs-number"><span class="hljs-number">0x53</span></span>,<span class="hljs-number"><span class="hljs-number">0x5f</span></span>,<span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x19</span></span>, <span class="hljs-number"><span class="hljs-number">0x48</span></span>,<span class="hljs-number"><span class="hljs-number">0x75</span></span>,<span class="hljs-number"><span class="hljs-number">0x08</span></span>,<span class="hljs-number"><span class="hljs-number">0x33</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> test_nonce = <span class="hljs-number"><span class="hljs-number">0x48750833</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result[<span class="hljs-number"><span class="hljs-number">8</span></span>]; full_btc_hash(header, test_nonce, result); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* presult = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * )result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%02X "</span></span>, presult[i]);</code> </pre><br>  Ternyata: <br><br>  92 98 2A 50 91 FA BD 42 97 8A A5 2D CD C9 36 28 02 4A DD FE E0 67 A4 78 00 00 00 00 00 00 00 00 00 00 <br><br>  Pada akhir hash ada banyak nol, hash yang indah, bingo, dll. <br><br>  Dan sekarang lebih jauh, saya bisa mengirimkan data uint32_t tidak biasa ke fungsi hashing ini, tetapi kelas C ++ khusus saya, yang akan mendefinisikan ulang semua aritmatika. <br><br>  Ya, ya  Saya akan menerapkan matematika probabilistik "alternatif". <br>  Saya menciptakannya sendiri, menyadarinya, mengalaminya sendiri.  Tampaknya itu tidak bekerja dengan baik.  Lelucon.  Itu harus bekerja.  Mungkin saya bukan yang pertama yang saya coba untuk engkol. <br><br>  Sekarang kita lolos ke yang paling menarik. <br>  Semua aritmatika dalam elektronik digital dilakukan sebagai operasi pada bit, dan secara ketat ditentukan oleh operasi DAN, ATAU, BUKAN, EKSKLUSIF ATAU.  Kita semua tahu tabel kebenaran apa dalam aljabar Boolean. <br><br>  Saya sarankan menambahkan sedikit ketidakpastian pada perhitungan, membuatnya menjadi probabilistik. <br>  Biarkan setiap bit dalam kata tidak hanya memiliki nilai NOL dan SATU yang mungkin, tetapi juga semua nilai antara!  Saya mengusulkan untuk mempertimbangkan nilai sedikit sebagai probabilitas suatu peristiwa yang mungkin atau mungkin tidak terjadi.  Jika semua data awal diketahui dengan andal, maka hasilnya dapat diandalkan.  Dan jika beberapa data sedikit kurang, maka hasilnya akan berubah dengan beberapa probabilitas. <br><br>  Bahkan, anggaplah ada dua peristiwa independen "a" dan "b", probabilitas terjadinya yang secara alami dari nol menjadi satu, masing-masing, Pa dan Pb.  Bagaimana kemungkinan peristiwa akan terjadi secara bersamaan?  Saya yakin kita masing-masing tidak akan ragu untuk menjawab P = Pa * Pb dan ini adalah jawaban yang benar! <br><br>  Grafik 3D dari fungsi tersebut akan terlihat seperti ini (dari dua sudut pandang berbeda): <br><br><img src="https://habrastorage.org/webt/-e/ll/pw/-ellpwuzq9bxl8fi_b3l1drhutc.png"><br><br>  Dan berapa probabilitas bahwa peristiwa Pa atau peristiwa Pb akan terjadi? <br>  Probabilitas P = Pa + Pb-Pa * Pb.  Grafik fungsi seperti ini: <br><br><img src="https://habrastorage.org/webt/vs/sd/wk/vssdwknevb1dijfbqcy3lsnib0w.png"><br><br>  Dan jika kita mengetahui probabilitas peristiwa Pa terjadi, lalu berapa probabilitas bahwa peristiwa itu tidak akan terjadi? <br>  P = 1 - Pa. <br><br>  Sekarang mari kita membuat asumsi.  Bayangkan bahwa kita memiliki elemen logis yang menghitung probabilitas suatu peristiwa keluaran, mengetahui probabilitas peristiwa masukan: <br><br><img src="https://habrastorage.org/webt/tn/qk/-v/tnqk-v5-dce15dkr0-zsb1wmiww.gif"><br><br>  Memiliki elemen logis seperti itu dapat dengan mudah membuatnya menjadi lebih kompleks, misalnya, eksklusif atau, XOR: <br><br><img src="https://habrastorage.org/webt/l0/e8/ju/l0e8judlmw-uh6plwsuj5sjnutq.png"><br><br>  Sekarang melihat diagram elemen logika XOR ini, kita dapat memahami berapa probabilitas kejadian pada output XOR probabilistik akan: <br><br><img src="https://habrastorage.org/webt/oj/xy/re/ojxyrexx8xkmcrmoyfohfl6bqyw.png"><br><br>  Tapi itu belum semuanya.  Kami tahu logika khas dari penambah penuh dan mencari tahu bagaimana penambah multi-bit dibuat dari penambah penuh: <br><br><img src="https://habrastorage.org/webt/_s/fh/qs/_sfhqsmrhygqasjfv6inengna38.png"><br><br>  Jadi sekarang, menurut rencananya, kita sekarang dapat menghitung probabilitas sinyal pada outputnya, dengan probabilitas sinyal yang diketahui pada input. <br><br>  Dengan demikian, saya dapat menerapkan di c ++ kelas "32-bit" saya sendiri (saya akan menyebutnya x32) dengan aritmatika probabilistik, menimpa kelas ini untuk semua operasi sha256 seperti AND, OR, XOR, ADD dan shift.  Kelas akan menyimpan 32 bit di dalamnya, tetapi setiap bit adalah angka floating-point.  Setiap operasi logis atau aritmatika pada angka 32-bit akan menghitung probabilitas nilai setiap bit dengan parameter input yang diketahui atau sedikit diketahui dari operasi logis atau aritmatika. <br><br>  Pertimbangkan contoh yang sangat sederhana yang menggunakan matematika probabilistik saya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &gt; dbl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision(dbl::max_digits10); x32 a = <span class="hljs-number"><span class="hljs-number">0xaabbccdd</span></span>; x32 b = <span class="hljs-number"><span class="hljs-number">0x12345678</span></span>; &lt;b&gt;<span class="hljs-comment"><span class="hljs-comment">//b.setBit( 4, 0.75 );&lt;/b&gt; x32 c = a + b; cout &lt;&lt; std::hex &lt;&lt; "result = 0x" &lt;&lt; c.get32() &lt;&lt; "\n" &lt;&lt; std::dec; for (int i = 0; i &lt; 32; i++) cout &lt;&lt; "bit" &lt;&lt; i &lt;&lt; " = " &lt;&lt; c.get_bvi(i) &lt;&lt; "\n"; cout &lt;&lt; "ok\n"; }</span></span></code> </pre><br>  Dalam contoh ini, dua angka 32-bit ditambahkan. <br>  Sedangkan stringnya adalah b.setBit (4, 0,75);  Hasil penambahan dikomentari secara tepat diprediksi dan ditentukan sebelumnya, karena semua data input untuk penambahan diketahui.  Program mencetak ini ke konsol: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">result</span></span> = 0xbcf02355 bit0 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit1 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit2 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit3 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit4 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit5 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit6 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit7 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit8 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit9 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit10 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit11 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit12 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit13 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit14 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit15 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit16 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit17 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit18 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit19 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit20 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit21 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit22 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit23 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit24 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit25 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit26 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit27 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit28 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit29 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit30 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit31 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Jika saya batalkan komentar pada baris b.setBit (4, 0,75), maka dengan melakukan ini saya akan mengatakan kepada program: "tambahkan dua angka ini kepada saya, tetapi saya tidak benar-benar tahu nilai bit 4 dari argumen kedua, saya pikir itu adalah salah satu dengan probabilitas 0,75". <br><br>  Kemudian penambahan terjadi, sebagaimana mestinya, dengan perhitungan lengkap dari probabilitas sinyal keluaran, yaitu, bit: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> result = <span class="hljs-number"><span class="hljs-number">0xbcf02305</span></span> bit0 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit1 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit2 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit3 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit4 = <span class="hljs-number"><span class="hljs-number">0.75</span></span> bit5 = <span class="hljs-number"><span class="hljs-number">0.1875</span></span> bit6 = <span class="hljs-number"><span class="hljs-number">0.8125</span></span> bit7 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit8 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit9 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit10 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit11 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit12 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit13 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit14 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit15 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit16 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit17 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit18 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit19 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit20 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit21 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit22 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit23 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit24 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit25 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit26 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit27 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit28 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit29 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit30 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit31 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Karena fakta bahwa input data tidak terlalu terkenal, hasilnya tidak terlalu terkenal.  Selain itu, apa yang dapat dihitung secara andal dianggap dapat diandalkan.  Apa yang tidak dapat dihitung dianggap dengan probabilitas. <br><br>  Sekarang saya memiliki kelas c ++ 32-bit yang luar biasa untuk aritmatika fuzzy, saya dapat meneruskan array variabel tipe x32 ke fungsi full_btc_hash () dalam template dan mendapatkan hasil estimasi hasil hash yang mungkin. <br><br><div class="spoiler">  <b class="spoiler_title">Beberapa implementasi kelas x32 adalah:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;utility&gt; #include &lt;stdint.h&gt; #include &lt;vector&gt; #include &lt;limits&gt; using namespace std; #include &lt;boost/math/constants/constants.hpp&gt; #include &lt;boost/multiprecision/cpp_dec_float.hpp&gt; using boost::multiprecision::cpp_dec_float_50; //typedef double MY_FP; typedef cpp_dec_float_50 MY_FP; class x32 { public: x32(); x32(uint32_t n); void init(MY_FP val); void init(double* pval); void setBit(int i, MY_FP val) { bvi[i] = val; }; ~x32() {}; x32 operator|(const x32&amp; right); x32 operator&amp;(const x32&amp; right); x32 operator^(const x32&amp; right); x32 operator+(const x32&amp; right); x32&amp; x32::operator+=(const x32&amp; right); x32 operator~(); x32 operator&lt;&lt;(const unsigned int&amp; right); x32 operator&gt;&gt;(const unsigned int&amp; right); void print(); uint32_t get32(); MY_FP get_bvi(uint32_t idx) { return bvi[idx]; }; private: MY_FP not(MY_FP a); MY_FP and(MY_FP a, MY_FP b); MY_FP or (MY_FP a, MY_FP b); MY_FP xor(MY_FP a, MY_FP b); MY_FP bvi[32]; //bit values }; #include "stdafx.h" #include "x32.h" x32::x32() { for (int i = 0; i &lt; 32; i++) { bvi[i] = 0.0; } } x32::x32(uint32_t n) { for (int i = 0; i &lt; 32; i++) { bvi[i] = (n&amp;(1 &lt;&lt; i)) ? 1.0 : 0.0; } } void x32::init(MY_FP val) { for (int i = 0; i &lt; 32; i++) { bvi[i] = val; } } void x32::init(double* pval) { for (int i = 0; i &lt; 32; i++) { bvi[i] = pval[i]; } } x32 x32::operator&lt;&lt;(const unsigned int&amp; right) { x32 t; for (int i = 31; i &gt;= 0; i--) { if (i &lt; right) { t.bvi[i] = 0.0; } else { t.bvi[i] = bvi[i - right]; } } return t; } x32 x32::operator&gt;&gt;(const unsigned int&amp; right) { x32 t; for (unsigned int i = 0; i &lt; 32; i++) { if (i &gt;= (32 - right)) { t.bvi[i] = 0; } else { t.bvi[i] = bvi[i + right]; } } return t; } MY_FP x32::not(MY_FP a) { return 1.0 - a; } MY_FP x32::and(MY_FP a, MY_FP b) { return a * b; } MY_FP x32::or(MY_FP a, MY_FP b) { return a + b - a * b; } MY_FP x32::xor (MY_FP a, MY_FP b) { //(~(A &amp; B)) &amp; (A | B) return and( not( and(a,b) ) , or(a,b) ); } x32 x32::operator|(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = or ( bvi[i], right.bvi[i] ); } return t; } x32 x32::operator&amp;(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = and (bvi[i], right.bvi[i]); } return t; } x32 x32::operator~() { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = not(bvi[i]); } return t; } x32 x32::operator^(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = xor (bvi[i], right.bvi[i]); } return t; } x32 x32::operator+(const x32&amp; right) { x32 r; r.bvi[0] = xor (bvi[0], right.bvi[0]); MY_FP cout = and (bvi[0], right.bvi[0]); for (unsigned int i = 1; i &lt; 32; i++) { MY_FP xor_a_b = xor (bvi[i], right.bvi[i]); r.bvi[i] = xor( xor_a_b, cout ); MY_FP and1 = and (bvi[i], right.bvi[i]); MY_FP and2 = and (xor_a_b, cout); cout = or (and1,and2); } return r; } x32&amp; x32::operator+=(const x32&amp; right) { MY_FP cout = and (bvi[0], right.bvi[0]); bvi[0] = xor (bvi[0], right.bvi[0]); for (unsigned int i = 1; i &lt; 32; i++) { MY_FP xor_a_b = xor (bvi[i], right.bvi[i]); MY_FP and1 = and (bvi[i], right.bvi[i]); MY_FP and2 = and (xor_a_b, cout); bvi[i] = xor (xor_a_b, cout); cout = or (and1, and2); } return *this; } void x32::print() { for (int i = 0; i &lt; 32; i++) { cout &lt;&lt; bvi[i] &lt;&lt; "\n"; } } uint32_t x32::get32() { uint32_t r = 0; for (int i = 0; i &lt; 32; i++) { if (bvi[i] == 1.0) r = r | (1 &lt;&lt; i); else if (bvi[i] == 0.0) { //ok } else { //oops.. cout &lt;&lt; "bit not stable\n"; } } return r; }</span></span></span></span></code> </pre><br></div></div><br>  Untuk apa semua ini? <br><br>  Penambang Bitcoin tidak tahu sebelumnya apa nilai untuk memilih 32x nonce.  Penambang dipaksa untuk mengulangi semua 4 miliar dari mereka untuk menghitung hash sampai menjadi "indah", sampai nilai hash menjadi kurang dari target. <br><br>  Aritmatika probabilistik fuzzy secara teoritis memungkinkan Anda untuk menyingkirkan pencarian lengkap. <br><br>  Ya, saya awalnya tidak tahu arti dari semua bit nonse yang diperlukan.  Jika saya tidak mengetahuinya, jangan ada omong kosong - probabilitas awal non-bit adalah 0,5.  Bahkan dalam skenario ini, saya dapat menghitung probabilitas bit hash output.  Di suatu tempat sesuatu yang mereka hasilkan juga sekitar 0,5 plus atau minus setengah sen. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, sekarang saya dapat mengubah hanya satu bit nonse dari 0,5 menjadi 0,9 atau 0,1 atau 1,0 dan melihat bagaimana nilai probabilitas dari nilai sinyal dari setiap bit fungsi hash pada perubahan output. Sekarang saya memiliki lebih banyak informasi evaluasi. Saya sekarang dapat merasakan masing-masing bit input nonse secara individual dan melihat di mana probabilitas sinyal bergeser pada masing-masing bit output dari fungsi hash. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai contoh, berikut adalah fragmen yang mempertimbangkan fungsi hash dengan non-bit yang sama sekali tidak diketahui, ketika probabilitas nilai bitnya adalah 0,5 dan perhitungan kedua, ketika kita mengasumsikan bahwa nilai bit nonce [0] = 0,9:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &gt; dbl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision(dbl::max_digits10); <span class="hljs-comment"><span class="hljs-comment">//--------------------------------- //hash: 502A989242BDFA912DA58A972836C9CDFEDD4A0278A467E00000000000000000 const u8 strxx[] = { 0x02,0x00,0x00,0x00, 0x17,0x97,0x5b,0x97,0xc1,0x8e,0xd1,0xf7, 0xe2,0x55,0xad,0xf2,0x97,0x59,0x9b,0x55, 0x33,0x0e,0xda,0xb8,0x78,0x03,0xc8,0x17, 0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x8a,0x97,0x29,0x5a,0x27,0x47,0xb4,0xf1, 0xa0,0xb3,0x94,0x8d,0xf3,0x99,0x03,0x44, 0xc0,0xe1,0x9f,0xa6,0xb2,0xb9,0x2b,0x3a, 0x19,0xc8,0xe6,0xba, 0xdc,0x14,0x17,0x87, 0x35,0x8b,0x05,0x53, 0x53,0x5f,0x01,0x19, 0x48,0x75,0x08,0x33 }; double nonce_bits[32]; for (int i = 0; i &lt; 32; i++) nonce_bits[i] = 0.5; x32 nonce_x32_a; x32 nonce_x32_b; nonce_x32_a.init(nonce_bits); nonce_bits[0] = 0.9; nonce_x32_b.init(nonce_bits); x32 result_x32_a[8]; x32 result_x32_b[8]; full_btc_hash(strxx, nonce_x32_a, result_x32_a); full_btc_hash(strxx, nonce_x32_b, result_x32_b); for (int i = 0; i &lt; 32; i++) cout &lt;&lt; result_x32_a[7].get_bvi(i) &lt;&lt; " " &lt;&lt; result_x32_b[7].get_bvi(i) &lt;&lt; "\n";</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi kelas x32 :: get_bvi () mengembalikan probabilitas nilai bit dari angka ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menghitung dan melihat bahwa jika Anda mengubah nilai bit nonce [0] dari 0,5 menjadi 0,9, maka beberapa bit hash output nyaris tidak terayun ke atas, dan beberapa hampir tidak terayun ke bawah:</font></font><br><br><pre> <code class="hljs css">0<span class="hljs-selector-class"><span class="hljs-selector-class">.44525679540883948</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.44525679540840074</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.55268174813167364</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5526817481315932</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57758654725359399</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57758654725360606</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.49595026978928474</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.49595026978930477</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57118578561406703</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57118578561407746</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53237003739057907</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5323700373905661</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57269859374138096</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57269859374138162</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57631236396381141</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5763123639638157</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.47943176373960149</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.47943176373960219</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54955992675177704</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5495599267517755</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53321116270879686</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53321116270879733</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57294025883744952</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57294025883744984</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53131857821387693</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53131857821387655</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57253530821899101</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57253530821899102</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.50661432403287194</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.50661432403287198</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57149419848354913</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57149419848354916</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53220327148366491</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53220327148366487</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57268927270412251</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57268927270412251</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57632130426913003</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57632130426913005</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57233970084776142</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57233970084776143</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56824728628552812</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56824728628552813</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.45247155441889921</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.45247155441889922</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56875940568326509</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56875940568326509</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57524323439326321</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57524323439326321</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57587726902392535</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57587726902392535</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57597043124557292</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57597043124557292</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52847748894672118</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52847748894672118</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54512141953055808</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54512141953055808</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57362254577539695</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57362254577539695</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53082194129771177</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53082194129771177</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54404489702929382</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54404489702929382</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54065386336136847</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54065386336136847</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semacam angin sepoi-sepoi, perubahan yang nyaris tak terlihat dalam kemungkinan keluar pada 10 m setelah titik desimal. </font><font style="vertical-align: inherit;">Meskipun demikian ... Anda dapat mencoba membangun beberapa asumsi tentang ini. </font><font style="vertical-align: inherit;">Ternyata indah, bukan? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, jika bit input dari input nonse diinisialisasi dengan nilai probabilitas yang benar dan diperlukan, seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nonce_bits[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) nonce_bits[i] = (real_nonce32&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>; x32 nonce_x32; nonce_x32.init(nonce_bits); full_btc_hash(strxx, nonce_x32, result_x32);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kemudian menghitung hash probabilistik kita mendapatkan hasil yang benar logis - hash "indah" di output, bingo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi dengan matematika, semuanya ada di sini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap belajar bagaimana menganalisa napas angin ... dan hash rusak. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedengarannya seperti omong kosong, tapi ini omong kosong - dan saya sudah memperingatkan sejak awal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahan berguna lainnya:</font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minim Bitcoin dengan kertas dan pena.</font></font></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah mungkin menghitung bitcoin lebih cepat, lebih mudah atau lebih mudah?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana saya melakukan penambang blakecoin</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penambang FPGA Bitcoin di Mars rover board 3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penambang FPGA dengan Algoritma Blake</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420131/">https://habr.com/ru/post/id420131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420119/index.html">10 kerangka kerja web Python layak untuk digunakan pada tahun 2018</a></li>
<li><a href="../id420121/index.html">Uji Kekuatan: Rayap LT450, LXI</a></li>
<li><a href="../id420123/index.html">Apa sebenarnya Node.js?</a></li>
<li><a href="../id420125/index.html">Otomasi dalam keuangan: karyawan bank dapat dibiarkan tanpa pekerjaan karena robot</a></li>
<li><a href="../id420129/index.html">Pola asyncio coroutine: menunggu di luar</a></li>
<li><a href="../id420133/index.html">Pemodelan sistem dinamis: Bagaimana bulan bergerak?</a></li>
<li><a href="../id420135/index.html">Ini juga Toshiba: produk yang tidak terduga dari perusahaan Jepang</a></li>
<li><a href="../id420139/index.html">Buku ‚ÄúRekayasa Keandalan Situs. Keandalan dan keandalan seperti di Google ¬ª</a></li>
<li><a href="../id420141/index.html">Dari MPMS DBMS yang dimuat - Danau Data peppy dengan alat analitis: bagikan detail pembuatannya</a></li>
<li><a href="../id420143/index.html">Performa Kotlin di Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>