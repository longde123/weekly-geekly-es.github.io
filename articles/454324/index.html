<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüè≠ üßùüèª üéæ Punteros en Python: ¬øcu√°l es el punto? üëÑ üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üë≤üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si alguna vez ha trabajado con lenguajes de bajo nivel como C o C ++, probablemente haya escuchado sobre punteros. Le permiten aumentar en gran medida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Punteros en Python: ¬øcu√°l es el punto?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454324/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_i/vd/cj/_ivdcjv0itamifffxs0i1i-mqh4.jpeg"></div><br>  Si alguna vez ha trabajado con lenguajes de bajo nivel como C o C ++, probablemente haya escuchado sobre punteros.  Le permiten aumentar en gran medida la efectividad de diferentes piezas de c√≥digo.  Pero tambi√©n pueden confundir a los principiantes, e incluso a los desarrolladores experimentados, y generar errores en la administraci√≥n de la memoria.  ¬øHay punteros en Python, puedo emularlos de alguna manera? <br><br>  Los punteros son ampliamente utilizados en C y C ++.  De hecho, estas son variables que contienen las direcciones de memoria en las que se encuentran otras variables.  Para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repasar los</a> punteros, lea esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rese√±a</a> . <br><br>  Gracias a este art√≠culo, comprender√° mejor el modelo de objetos en Python y descubrir√° por qu√© los punteros en realidad no existen en este lenguaje.  En caso de que necesite simular el comportamiento de los punteros, aprender√° a emularlos sin la pesadilla de la administraci√≥n de la memoria. <br><a name="habracut"></a><br>  Con este art√≠culo, usted: <br><br><ul><li>  Aprende por qu√© Python no tiene punteros. </li><li>  Aprende la diferencia entre las variables C y los nombres en Python. </li><li>  Aprende a emular punteros en Python. </li><li> Usa <code>ctypes</code> experimentar con punteros reales. </li></ul><br>  <b>Nota</b> : Aqu√≠, el t√©rmino "Python" se aplica a la implementaci√≥n de Python en C, que se conoce como CPython.  Todas las discusiones sobre el dispositivo de lenguaje son v√°lidas para CPython 3.7, pero pueden no corresponder a iteraciones posteriores. <br><br><h2>  ¬øPor qu√© no hay punteros en Python? </h2><br>  No lo se  ¬øPueden existir punteros en Python de forma nativa?  Probablemente, pero aparentemente, los punteros contradicen el concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zen de Python</a> , porque provocan cambios impl√≠citos en lugar de expl√≠citos.  Los punteros suelen ser bastante complejos, especialmente para principiantes.  Adem√°s, lo empujan a tomar decisiones fallidas oa hacer algo realmente peligroso, como leer desde un √°rea de memoria, donde no deber√≠a haberlo le√≠do. <br><br>  Python intenta abstraer los detalles de implementaci√≥n del usuario, como una direcci√≥n de memoria.  A menudo en este lenguaje, el √©nfasis est√° en la usabilidad, no en la velocidad.  Por lo tanto, los punteros en Python no tienen mucho sentido.  Pero no se preocupe, el idioma predeterminado le brinda algunos de los beneficios de usar punteros. <br><br>  Para comprender los punteros en Python, repasemos brevemente las caracter√≠sticas de la implementaci√≥n del lenguaje.  En particular, debe comprender: <br><br><ol><li>  Qu√© son los objetos mutables e inmutables. </li><li>  C√≥mo se ordenan las variables / nombres en Python. </li></ol><br>  Aferrarse a sus direcciones de memoria, vamos! <br><br><h2>  Objetos en Python </h2><br>  Todo en Python es un objeto.  Por ejemplo, abra REPL y vea c√≥mo <code>isinstance()</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>isinstance(<span class="hljs-number"><span class="hljs-number">1</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(list(), object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; isinstance(foo, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Este c√≥digo demuestra que todo en Python es en realidad un objeto.  Cada objeto contiene al menos tres tipos de datos: <br><br><ul><li>  Contador de referencia. <br></li><li>  Tipo <br></li><li>  Valor. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se</a> utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un contador de referencia</a> para administrar la memoria.  Los detalles sobre esta administraci√≥n se escriben en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administraci√≥n de memoria en Python</a> .  El tipo se utiliza en el nivel de CPython para proporcionar seguridad de tipo durante el tiempo de ejecuci√≥n.  Y el valor es el valor real asociado con el objeto. <br><br>  Pero no todos los objetos son iguales.  Hay una diferencia importante: los objetos son mutables e inmutables.  Comprender esta distinci√≥n entre los tipos de objetos lo ayudar√° a comprender mejor la primera capa de la cebolla llamada "punteros en Python". <br><br><h2>  Objetos mutables e inmutables </h2><br>  Hay dos tipos de objetos en Python: <br><br><ol><li>  Objetos inmutables (no se pueden cambiar); <br></li><li>  Objetos modificables (sujetos a cambios). <br></li></ol><br>  Reconocer esta diferencia es la primera clave para viajar por el mundo de los punteros en Python.  Aqu√≠ hay una caracterizaci√≥n de la inmutabilidad de algunos tipos populares: <br><br><div class="scrollable-table"><table><tbody><tr><th width="400">  Tipo <br></th><th width="400">  Inmutable? <br></th></tr><tr><td>  int <br></td><td>  Si <br></td></tr><tr><td>  flotar <br></td><td>  Si <br></td></tr><tr><td>  bool <br></td><td>  Si <br></td></tr><tr><td>  complejo <br></td><td>  Si <br></td></tr><tr><td>  tupla <br></td><td>  Si <br></td></tr><tr><td>  conjunto congelado <br></td><td>  Si <br></td></tr><tr><td>  str <br></td><td>  Si <br></td></tr><tr><td>  lista <br></td><td>  No <br></td></tr><tr><td>  establecer <br></td><td>  No <br></td></tr><tr><td>  dict <br></td><td>  No <br></td></tr></tbody></table></div><br>  Como puede ver, muchos de los tipos primitivos com√∫nmente utilizados son inmutables.  Puede verificar esto escribiendo alg√∫n c√≥digo de Python.  Necesitar√° dos herramientas de la biblioteca est√°ndar: <br><br><ol><li>  <code>id()</code> devuelve la direcci√≥n de memoria del objeto; <br></li><li>  <code>is</code> devuelve <code>True</code> si y solo si dos objetos tienen la misma direcci√≥n de memoria. <br></li></ol><br>  Puede ejecutar este c√≥digo en un entorno REPL: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049376</span></span></code> </pre> <br>  Aqu√≠ establecemos la variable <code>x</code> en <code>5</code> .  Si intenta cambiar el valor usando la suma, obtendr√° un nuevo objeto: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-number"><span class="hljs-number">6</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049408</span></span></code> </pre> <br>  Aunque parezca que este c√≥digo simplemente cambia el valor de <code>x</code> , en realidad est√° obteniendo un <b>nuevo</b> objeto como respuesta. <br><br>  El tipo <code>str</code> tambi√©n es inmutable: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s = <span class="hljs-string"><span class="hljs-string">"real_python"</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819584048</span></span> &gt;&gt;&gt; s += <span class="hljs-string"><span class="hljs-string">"_rocks"</span></span> &gt;&gt;&gt; s <span class="hljs-string"><span class="hljs-string">'real_python_rocks'</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819609424</span></span></code> </pre> <br>  Y en este caso, <code>s</code> despu√©s de la operaci√≥n <code>+=</code> obtiene una direcci√≥n de memoria <b>diferente</b> . <br><br>  <b>Bonificaci√≥n</b> : el operador <code>+=</code> traduce en varias llamadas a m√©todos. <br><br>  Para algunos objetos, como una lista, <code>+=</code> convierte a <code>__iadd__()</code> ( <code>__iadd__()</code> local).  Se cambiar√° a s√≠ mismo y devolver√° la misma ID.  Sin embargo, <code>str</code> e <code>int</code> no tienen estos m√©todos y, como resultado, se <code>__add__()</code> lugar de <code>__iadd__()</code> . <br><br>  Consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n del modelo de datos de</a> Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para obtener m√°s detalles</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.</a> <br><br>  Cuando intentamos cambiar directamente el valor de cadena de <code>s</code> obtenemos un error: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"R"</span></span></code> </pre> <br>  Rastreo posterior (las √∫ltimas llamadas se muestran en √∫ltimo lugar): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;mdule&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'str'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  El c√≥digo anterior se bloquea y Python informa que <code>str</code> no admite este cambio, que corresponde a la definici√≥n de inmutabilidad de tipo <code>str</code> . <br><br>  Compare con un objeto mutable, por ejemplo, con una lista: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span> &gt;&gt;&gt; my_list.append(<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  Este c√≥digo demuestra la diferencia principal entre los dos tipos de objetos.  Inicialmente, <code>my_list</code> tiene una ID.  Incluso despu√©s de agregar <code>4</code> a la lista, <code>my_list</code> todav√≠a tiene <b>la misma</b> ID.  La raz√≥n es que la <code>list</code> tipos es mutable. <br><br>  Aqu√≠ hay otra demostraci√≥n de la mutabilidad de la lista mediante la asignaci√≥n: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  En este c√≥digo, cambiamos <code>my_list</code> y lo configuramos a <code>0</code> como primer elemento.  Sin embargo, la lista retuvo la misma ID despu√©s de esta operaci√≥n.  El siguiente paso en nuestro camino para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aprender Python</a> ser√° explorar su ecosistema. <br><br><h2>  Nos ocupamos de las variables. </h2><br>  Las variables en Python son fundamentalmente diferentes de las variables en C y C ++.  Esencialmente, simplemente no existen en Python.  <b>En lugar de variables, hay nombres</b> . <br><br>  Puede sonar pedante, y en su mayor parte lo es.  Muy a menudo, puede tomar nombres en Python como variables, pero debe comprender la diferencia.  Esto es especialmente importante cuando estudias un tema tan dif√≠cil como los punteros. <br><br>  Para que sea m√°s f√°cil de entender, veamos c√≥mo funcionan las variables en C, qu√© representan y luego comparemos con el trabajo de los nombres en Python. <br><br><h3>  Variables en C </h3><br>  Tome el c√≥digo que define la variable <code>x</code> : <br><br><pre> <code class="python hljs">int x = <span class="hljs-number"><span class="hljs-number">2337</span></span>;</code> </pre> <br>  La ejecuci√≥n de esta l√≠nea corta pasa por varias etapas diferentes: <br><br><ol><li>  Asignaci√≥n de memoria suficiente para un n√∫mero. <br></li><li>  Asignaci√≥n de <code>2337</code> a esta ubicaci√≥n de memoria. <br></li><li>  La asignaci√≥n que <code>x</code> indica este valor. <br></li></ol><br>  Una memoria simplificada podr√≠a verse as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f13/e62/d71/f13e62d71774b73aecff45931b6db57f.png"><br><br>  Aqu√≠, la variable <code>x</code> tiene una direcci√≥n falsa de <code>0x7f1</code> y un valor de <code>2337</code> .  Si luego desea cambiar el valor de <code>x</code> , puede hacer esto: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">2338</span></span>;</code> </pre> <br>  Este c√≥digo establece la variable <code>x</code> nuevo valor de <code>2338</code> , sobrescribiendo as√≠ el valor <b>anterior</b> .  Esto significa que la variable <code>x</code> <b>mutable</b> .  Esquema de memoria actualizado para el nuevo valor: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/491/19b/34749119bcba5c4009861aa4e7c40c45.png"><br><br>  Tenga en cuenta que la ubicaci√≥n de <code>x</code> no <code>x</code> cambiado, solo el valor en s√≠.  Esto es importante  Esto nos dice que <code>x</code> es <b>un lugar en la memoria</b> , y no solo un nombre. <br><br>  Tambi√©n puede considerar este problema como parte del concepto de propiedad.  Por un lado, <code>x</code> posee un lugar en la memoria.  Primero, <code>x</code> es un cuadro vac√≠o que puede contener solo un n√∫mero entero, en el que se pueden almacenar valores enteros. <br><br>  Cuando asigna a <code>x</code> alg√∫n valor, coloca el valor en un cuadro que pertenece a <code>x</code> .  Si desea introducir una nueva variable <code>y</code> , puede agregar esta l√≠nea: <br><br><pre> <code class="python hljs">int y = x;</code> </pre> <br>  Este c√≥digo crea un nuevo cuadro llamado <code>y</code> y copia el valor de <code>x</code> en √©l.  Ahora el circuito de memoria se ve as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caa/74d/ed3/caa74ded301b1f527e1b94516f1b1196.png"><br><br>  Tenga en cuenta la nueva ubicaci√≥n <code>y</code> - <code>0x7f5</code> .  Aunque el valor <code>x</code> se copi√≥ a <code>x</code> , la variable <code>y</code> posee una nueva direcci√≥n en la memoria.  Por lo tanto, puede sobrescribir el valor de <code>y</code> sin afectar a <code>x</code> : <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2339</span></span>;</code> </pre> <br>  Ahora el circuito de memoria se ve as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/f8d/ed4/fcff8ded49647ad0053a45f0773cb4bb.png"><br><br>  Repito: cambiaste el valor de <code>y</code> , pero no la ubicaci√≥n.  Adem√°s, no afect√≥ a la variable original <code>x</code> . <br><br>  Con nombres en Python, la situaci√≥n es completamente diferente. <br><br><h3>  Nombres en Python </h3><br>  No hay variables en Python, nombres en su lugar.  Puede usar el t√©rmino "variables" a su discreci√≥n, sin embargo, es importante conocer la diferencia entre variables y nombres. <br><br>  Tomemos el c√≥digo equivalente del ejemplo C anterior y escrib√°moslo en Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2337</span></span></code> </pre> <br>  Como en C, el c√≥digo pasa por varios pasos separados durante la ejecuci√≥n de esto: <br><br><ol><li>  Se crea PyObject. <br></li><li>  Al n√∫mero de PyObject se le asigna un c√≥digo de tipo. <br></li><li>  <code>2337</code> asignado un valor para PyObject. <br></li><li>  Se crea el nombre <code>x</code> . </li><li>  <code>x</code> apunta al nuevo PyObject. </li><li>  El recuento de referencia de PyObject se incrementa en 1. <br></li></ol><br>  <b>Nota</b> : <a href="">PyObject</a> no es lo mismo que un objeto en Python, esta entidad es espec√≠fica de CPython y representa la estructura b√°sica de todos los objetos de Python. <br><br>  PyObject se define como una estructura C, por lo que si se pregunta por qu√© no puede llamar directamente al c√≥digo de tipo o al contador de referencia, entonces la raz√≥n es que no tiene acceso directo a las estructuras.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los</a> m√©todos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sys.getrefcount ()</a> pueden ayudar a obtener alg√∫n tipo de material interno. <br><br>  Si hablamos de memoria, entonces puede verse as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d9/ad7/932/9d9ad79327405315461e3880fe3db256.png"><br><br>  Aqu√≠, el circuito de memoria es muy diferente del circuito en C que se muestra arriba.  En lugar de que <code>x</code> posea un bloque de memoria que almacena el valor <code>2337</code> , un objeto Python reci√©n creado posee la memoria en la que vive <code>2337</code> .  El nombre de Python <code>x</code> no posee directamente <b>ninguna</b> direcci√≥n en la memoria, al igual que una variable C posee una celda est√°tica. <br><br>  Si desea asignar <code>x</code> nuevo valor, pruebe este c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  El comportamiento del sistema ser√° diferente de lo que sucede en C, pero no diferir√° demasiado del enlace original en Python. <br><br>  En este c√≥digo: <br><br><ul><li>  Se crea un nuevo PyObject. <br></li><li>  Al n√∫mero de PyObject se le asigna un c√≥digo de tipo. <br></li><li>  <code>2</code> asigna un valor para PyObject. <br></li><li>  <code>x</code> apunta al nuevo PyObject. <br></li><li>  El recuento de referencia del nuevo PyObject se incrementa en 1. <br></li><li>  El recuento de referencia del antiguo PyObject se reduce en 1. <br></li></ul><br>  Ahora el circuito de memoria se ve as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/712/860/996/712860996aa37da34fdb69a466cdf5de.png"><br><br>  Esta ilustraci√≥n demuestra que <code>x</code> apunta a una referencia a un objeto y no posee el √°rea de memoria como antes.  Tambi√©n ver√° que el comando <code>x = 2338</code> no es una asignaci√≥n, sino un enlace del nombre <code>x</code> al enlace. <br><br>  Adem√°s, el objeto anterior (que contiene el valor <code>2337</code> ) ahora est√° en la memoria con un recuento de referencia de 0 y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el recolector de basura lo</a> eliminar√°. <br><br>  Puede ingresar un nuevo nombre <code>y</code> , como en el ejemplo C: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = x</code> </pre> <br>  Aparecer√° un nuevo nombre en la memoria, pero no necesariamente un nuevo objeto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/958/adc/410/958adc41013bb5483f0526689a48a871.png"><br><br>  Ahora ver√° que <b>no se ha</b> creado un nuevo objeto Python, solo se <b>ha</b> creado un nuevo nombre que apunta al mismo objeto.  Adem√°s, el contador de referencia de objeto aument√≥ en 1. Puede verificar la equivalencia de la identidad de los objetos para confirmar su identidad: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Este c√≥digo muestra que <code>x</code> e <code>y</code> son un objeto.  Pero no se equivoque: <code>y</code> todav√≠a es inmutable.  Por ejemplo, puede realizar una operaci√≥n de suma con <code>y</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Despu√©s de llamar a la adici√≥n, devolver√° un nuevo objeto Python.  Ahora el recuerdo se ve as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/abc/3e7/8bdabc3e7576ab86b00ba9c2b43b57b4.png"><br><br>  Se ha creado un nuevo objeto <code>y</code> ahora lo se√±ala.  Es curioso que obtendr√≠amos exactamente el mismo estado final si vinculamos directamente <code>y</code> a <code>2339</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = <span class="hljs-number"><span class="hljs-number">2339</span></span></code> </pre> <br>  Despu√©s de esta expresi√≥n, obtenemos un estado final de memoria, como en la operaci√≥n de suma.  Perm√≠tame recordarle que en Python no asigna variables, sino que vincula nombres a enlaces. <br><br><h3>  Sobre pasantes en Python </h3><br>  Ahora comprende c√≥mo se crean nuevos objetos en Python y c√≥mo se les asignan nombres.  Es hora de hablar sobre los objetos internos. <br><br>  Tenemos este c√≥digo de Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Como antes, <code>x</code> e <code>y</code> son nombres que apuntan al mismo objeto Python.  Pero este objeto que contiene el valor <code>1000</code> no siempre puede tener la misma direcci√≥n de memoria.  Por ejemplo, si sumas dos n√∫meros y obtienes 1000, obtendr√°s otra direcci√≥n: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">499</span></span> + <span class="hljs-number"><span class="hljs-number">501</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Esta vez, la cadena <code>x is y</code> devuelve <code>False</code> .  Si te da verg√ºenza, no te preocupes.  Esto es lo que sucede cuando se ejecuta este c√≥digo: <br><br><ol><li>  Se crea un objeto Python ( <code>1000</code> ). <br></li><li>  Se le da el nombre <code>x</code> . <br></li><li>  Se crea un objeto Python ( <code>499</code> ). <br></li><li>  Se crea un objeto Python ( <code>501</code> ). <br></li><li>  Estos dos objetos se suman. <br></li><li>  Se crea un nuevo objeto Python ( <code>1000</code> ). <br></li><li>  Se le da el nombre <code>y</code> . <br></li></ol><br>  <b>Explicaciones t√©cnicas</b> : Los pasos descritos se realizan solo cuando este c√≥digo se ejecuta dentro de REPL.  Si toma el ejemplo anterior, p√©guelo en el archivo y ejec√∫telo, entonces la l√≠nea <code>x is y</code> devolver√° <code>True</code> . <br><br>  La raz√≥n es el ingenio r√°pido del compilador CPython, que intenta realizar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimizaciones de mirilla</a> que ayudan a guardar los pasos de ejecuci√≥n de c√≥digo tanto como sea posible.  Los detalles se pueden encontrar en el <a href="">c√≥digo fuente del optimizador de agujeros CPython</a> . <br><br>  ¬øPero no es un desperdicio?  Bueno, s√≠, pero paga este precio por todos los grandes beneficios de Python.  ¬°No necesita pensar en eliminar tales objetos intermedios, y ni siquiera necesita saber acerca de su existencia!  La broma es que estas operaciones se realizan relativamente r√°pido, y no sabr√≠as sobre ellas hasta ese momento. <br><br>  Los creadores de Python sabiamente notaron esta sobrecarga y decidieron hacer varias optimizaciones.  Su resultado es un comportamiento que puede sorprender a los principiantes: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">20</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">19</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  En este ejemplo, el c√≥digo es casi el mismo que el anterior, excepto que obtenemos <code>True</code> .  Se trata de objetos internos.  Python crea previamente un subconjunto espec√≠fico de objetos en la memoria y los almacena en el espacio de nombres global para uso diario. <br><br>  ¬øQu√© objetos dependen de la implementaci√≥n de Python?  En CPython 3.7, los internos son: <br><br><ol><li>  Enteros que van desde <code>-5</code> a <code>256</code> . <br></li><li>  Cadenas que contienen solo letras ASCII, n√∫meros o guiones bajos. <br></li></ol><br>  Esto se debe a que estas variables se usan con mucha frecuencia en muchos programas.  Al realizar pr√°cticas internas, Python evita la asignaci√≥n de memoria para objetos persistentes. <br><br>  Las l√≠neas de menos de 20 caracteres de tama√±o y que contengan letras ASCII, n√∫meros o guiones bajos ser√°n internados porque se supone que deben usarse como identificadores: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s1) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s2) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Aqu√≠ <code>s1</code> y <code>s2</code> apuntan a la misma direcci√≥n en la memoria.  Si no insert√°ramos una letra, n√∫mero o gui√≥n bajo ASCII, obtendr√≠amos un resultado diferente: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Este ejemplo usa un signo de exclamaci√≥n, por lo que las cadenas no est√°n internados y son objetos diferentes en la memoria. <br><br>  <b>Bonificaci√≥n</b> : si desea que estos objetos se refieran al mismo objeto interno, puede usar <code>sys.intern()</code> .  Una forma de utilizar esta funci√≥n se describe en la documentaci√≥n: <br><br><blockquote>  El internamiento de cadenas es √∫til para un ligero aumento en el rendimiento de b√∫squeda del diccionario: si las claves en el diccionario y la clave a buscar se internan, entonces las comparaciones de claves (despu√©s del hash) se pueden hacer comparando punteros en lugar de cadenas.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuente</a> ) </blockquote><br>  Los internos a menudo confunden a los programadores.  Solo recuerde que si comienza a dudar, siempre puede usar <code>id()</code> y <code>is</code> para determinar la equivalencia de los objetos. <br><br><h2>  Emulaci√≥n de puntero de Python </h2><br>  El hecho de que los punteros est√©n ausentes de forma nativa en Python no significa que no pueda aprovechar los punteros.  En realidad, hay varias formas de emular punteros en Python.  Aqu√≠ nos fijamos en dos de ellos: <br><br><ol><li>  √öselo como punteros a tipos mutables. <br></li><li>  Utilizando objetos Python especialmente preparados. <br></li></ol><br><h3>  Usar como punteros de tipo mutable </h3><br>  Ya sabes qu√© son los tipos mutables.  Es gracias a su mutabilidad que podemos emular el comportamiento de los punteros.  Digamos que necesita replicar este c√≥digo: <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Este c√≥digo toma un puntero a un n√∫mero ( <code>*x</code> ) e incrementa el valor en 1. Aqu√≠ est√° la funci√≥n principal para ejecutar el c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdi.h&gt; int main(void) { int y = 2337; printf("y = %d\n", y); add_one(&amp;y); printf("y = %d\n", y); return 0; }</span></span></code> </pre> <br>  En el fragmento anterior, asignamos <code>y</code> a <code>2337</code> , mostramos el valor actual, lo incrementamos en 1 y luego mostramos un nuevo valor.  Lo siguiente aparece en la pantalla: <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2337</span></span> y = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Una forma de replicar este comportamiento en Python es usar un tipo mutable.  Por ejemplo, aplique una lista y cambie el primer elemento: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> ... x[<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; y = [<span class="hljs-number"><span class="hljs-number">2337</span></span>] &gt;&gt;&gt; add_one(y) &gt;&gt;&gt; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Aqu√≠ <code>add_one(x)</code> refiere al primer elemento y aumenta su valor en 1. Usar la lista significa que como resultado obtenemos el valor cambiado.  Entonces, ¬øhay punteros en Python?  No  El comportamiento descrito se hizo posible porque la lista es de tipo mutable.  Si intentas usar una tupla, obtienes un error: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>z = (<span class="hljs-number"><span class="hljs-number">2337</span></span>,) &gt;&gt;&gt; add_one(z)</code> </pre> <br>  Rastreo posterior (las √∫ltimas llamadas son las √∫ltimas): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> add_one TypeError: <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Este c√≥digo demuestra la inmutabilidad de la tupla, por lo que no admite la asignaci√≥n de elementos. <br><br>  <code>list</code> no <code>list</code> el √∫nico tipo mutable; los punteros de parte tambi√©n se emulan mediante <code>dict</code> . <br><br>  Suponga que tiene una aplicaci√≥n que debe rastrear la ocurrencia de eventos interesantes.  Esto se puede hacer creando un diccionario y usando uno de sus elementos como contador: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>counters = {<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>} &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... bar() ... &gt;&gt;&gt; foo() &gt;&gt;&gt; counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  En este ejemplo, el diccionario usa contadores para rastrear el n√∫mero de llamadas a funciones.  Despu√©s de llamar a <code>foo()</code> contador aument√≥ en 2, como se esperaba.  Y todo gracias a la <code>dict</code> . <br><br>  No olvide, esto es solo una <b>emulaci√≥n</b> del comportamiento del puntero, no tiene nada que ver con punteros reales en C y C ++.  Podemos decir que estas operaciones son m√°s caras que si se realizaran en C o C ++. <br><br><h3>  Usando objetos Python </h3><br>  <code>dict</code> es una excelente manera de emular punteros en Python, pero a veces es tedioso recordar qu√© nombre de clave usaste.  Especialmente si usa el diccionario en diferentes partes de la aplicaci√≥n.  Una clase personalizada de Python puede ayudar aqu√≠. <br><br>  Digamos que necesita rastrear m√©tricas en una aplicaci√≥n.  Una excelente manera de ignorar detalles molestos es crear una clase: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }</code> </pre> <br>  Este c√≥digo define la clase <code>Metrics</code> .  Todav√≠a usa el diccionario para almacenar datos actualizados que se encuentran en la <code>_metrics</code> miembro <code>_metrics</code> .  Esto le dar√° la mutabilidad requerida.  Ahora solo necesita acceder a estos valores.  Puedes hacer esto usando las propiedades: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... @property def func_calls(self): return self._metrics["func_calls"] @property def cat_pictures_served(self): return self._metrics["cat_pictures_served"]</span></span></code> </pre> <br>  Aqu√≠ usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@property</a> .  Si eres nuevo en decoradores, lee el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primer en decoradores Python</a> .  En este caso, el decorador <code>@property</code> permite acceder a <code>func_calls</code> y <code>cat_pictures_served</code> , como si fueran atributos: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; metrics.cat_pictures_served <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  El hecho de que pueda referirse a estos nombres como atributos significa que est√° abstra√≠do del hecho de que estos valores est√°n almacenados en el diccionario.  Adem√°s, hace que los nombres de los atributos sean m√°s expl√≠citos.  Por supuesto, deber√≠a poder aumentar los valores: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def inc_func_calls(self): self._metrics["func_calls"] += 1 def inc_cat_pics(self): self._metrics["cat_pictures_served"] += 1</span></span></code> </pre> <br>     : <br><br><ol><li> <code>inc_func_calls()</code> </li> <li> <code>inc_cat_pics()</code> </li> </ol><br>      <code>metrics</code> .     ,     ,   : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>     <code>func_calls</code>   <code>inc_func_calls()</code>         Python.    ,     -  <code>metrics</code> ,          . <br><br> <b></b> :   ,   <code>inc_func_calls()</code>  <code>inc_cat_pics()</code>   <code>@property.setter</code>        <code>int</code> ,     . <br><br>      <code>Metrics</code> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, } @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat_pictures_served</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_cat_pics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2>     ctypes </h2><br>  , -    Python,   CPython?     ctypes    ,   C.      ctypes,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extending Python With C Libraries and the ¬´ctypes¬ª Module</a> . <br><br>       ,     ,   .     - <code>add_one()</code> : <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br> ,      <code>x</code>  1.   ,      (shared) .  ,      <code>add.c</code> ,      gcc: <br><br><pre> <code class="python hljs">$ gcc -c -Wall -Werror -fpic add.c $ gcc -shared -o libadd1.so add.o</code> </pre> <br>      C   <code>add.o</code> .           <code>libadd1.so</code> . <br><br> <code>libadd1.so</code>      .    ctypes    Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes &gt;&gt;&gt; add_lib = ctypes.CDLL(<span class="hljs-string"><span class="hljs-string">"./libadd1.so"</span></span>) &gt;&gt;&gt; add_lib.add_one &lt;_FuncPtr object at <span class="hljs-number"><span class="hljs-number">0x7f9f3b8852a0</span></span>&gt;</code> </pre> <br>  ctypes.CDLL  ,     <code>libadd1</code> .      <code>add_one()</code> ,      ,        Python-.     ,    .  Python  ,      . <br><br>         , ctypes       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one = add_lib.add_one &gt;&gt;&gt; add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]</code> </pre> <br>     ,    C. ,        ,       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(<span class="hljs-number"><span class="hljs-number">1</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; ctypes.ArgumentError: argument <span class="hljs-number"><span class="hljs-number">1</span></span>: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeError</span></span></span><span class="hljs-class">'&gt;:</span></span> \ expected LP_c_int instance instead of int</code> </pre> <br> Python    ,  <code>add_one()</code>   ,     .  ,  ctypes      .       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = ctypes.c_int() &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>      <code>x</code>   <code>0</code> . ctypes    <code>byref()</code> ,      . <br><br> <b></b> :  <b> </b>     <b> </b> . <br><br>          ,       .         ,        . <br><br>   <code>add_one()</code>    : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(ctypes.byref(x)) <span class="hljs-number"><span class="hljs-number">998793640</span></span> &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Genial     1. ,     Python  . <br><br><h2>  Conclusi√≥n </h2><br>        Python  .          ,              Python. <br><br>         Python: <br><br><ul><li>          . <br></li><li>   Python-   . <br></li><li>       ctypes. <br></li></ul><br>       Python       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454324/">https://habr.com/ru/post/454324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454314/index.html">10 principios de programaci√≥n orientada a objetos que todo desarrollador debe conocer</a></li>
<li><a href="../454316/index.html">Siguiendo los pasos del ninja industrial: te invitamos a participar en la competencia en l√≠nea de seguridad industrial</a></li>
<li><a href="../454318/index.html">Sonando el pasado. Una gu√≠a para historiadores sobre la conversi√≥n de datos a sonido</a></li>
<li><a href="../454320/index.html">Analistas del mercado laboral y cient√≠ficos de datos</a></li>
<li><a href="../454322/index.html">Algunos dicen que la tecnolog√≠a DANE para navegadores ha fallado</a></li>
<li><a href="../454326/index.html">Excepto Moore, ¬øqui√©n m√°s formul√≥ las leyes de escalar los sistemas inform√°ticos?</a></li>
<li><a href="../454330/index.html">10 aspectos destacados de TechTrain 2018: IA para las masas, interfaces y m√°s</a></li>
<li><a href="../454332/index.html">C√≥mo Telegram bot super√≥ la dilaci√≥n de los dise√±adores y ayud√≥ a aumentar los ingresos de las agencias digitales</a></li>
<li><a href="../454334/index.html">Moto Weep AWS</a></li>
<li><a href="../454336/index.html">Cliente: - ¬øCu√°nto cuesta una copia de Facebook?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>