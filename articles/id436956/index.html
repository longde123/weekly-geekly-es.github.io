<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏾 🚨 ⚖️ Pada masalah shift, rambu dan kecepatan MK 🥖 🤦🏿 👨‍👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“Temukan alasan untuk semuanya dan kamu akan mengerti banyak” 
 Mungkin pembaca reguler saya (yah, mereka tidak mungkin) ingat bahwa dalam posting say...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pada masalah shift, rambu dan kecepatan MK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436956/"><h3>  “Temukan alasan untuk semuanya dan kamu akan mengerti banyak” </h3><br>  Mungkin pembaca reguler saya (yah, mereka tidak mungkin) ingat bahwa dalam posting saya saya bingung bahwa atribut yang tidak ditandatangani digunakan untuk menggambarkan register perangkat eksternal.  Dalam komentar, disarankan agar ini dilakukan untuk menghindari perilaku yang tidak jelas selama shift dan saya setuju.  Seperti yang baru-baru ini saya temukan, ada alasan lain untuk penggunaan atribut ini dan dapat diterapkan tidak hanya untuk register, tetapi juga untuk variabel biasa. <br><br>  Jadi, kita mulai. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Sebagai permulaan, pengantar kecil untuk besi</b> <div class="spoiler_text">  Sebagai platform target, kami akan mempertimbangkan MK 8-bit tanpa baterai (ini adalah upaya yang menyedihkan untuk menyembunyikan nama AVR yang dikompromikan), yang memiliki perintah yang diimplementasikan perangkat keras berikut: <br><br>  <b>lsl / lsr</b> logis kiri / kanan, bit rendah / tinggi dihapus; <br>  <b>rol / ror</b> siklik kiri / kanan melalui transfer (shift 9 bit); <br>  <b>asr</b> aritmatika bergeser ke kanan, bit yang paling signifikan (ditandatangani) disimpan (kami memperhatikan fakta bahwa untuk melakukan pergeseran jenis ini ke kiri umumnya tidak mungkin pada prinsipnya). <br><br>  Semua perintah ini dieksekusi pada operan byte dan merupakan dasar untuk implementasi semua shift lain yang mungkin.  Misalnya, pergeseran kata (2 byte rh, rl) dengan tanda di sebelah kanan dengan 1 digit diimplementasikan dengan urutan berikut: <br><br>  <b>asr rh;</b>  <b>ror rl;</b> <br></div></div><br>  Pertimbangkan contoh kode sederhana dan kode assembler yang sesuai untuk MK dengan sistem perintah AVR, seperti biasa, diperoleh di godbolt.org.  (menyiratkan bahwa optimasi diaktifkan dan variabelnya terletak di register r24) <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> byte; byte = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><pre> <code class="cpp hljs">clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 lsl r24 rol r25</code> </pre> <br>  dan melihat bahwa operasinya memakan waktu lima tim? <br><br>  Catatan: Jika seseorang dalam komentar memberi tahu Anda bagaimana mengatur fragmen ini (dan yang berikutnya) dalam 2 kolom, saya akan berterima kasih. <br><br>  Hal ini dapat dilihat dari kode assembler bahwa variabel byte diperluas ke tipe integer (16-bit) dalam tiga perintah pertama, dan dalam dua berikutnya, angka byte ganda benar-benar bergeser - entah bagaimana itu aneh, setidaknya aneh. <br><br>  Bergeser ke kanan tidak lebih baik <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 asr r25 ror r24</code> </pre> <br>  - lima tim yang sama.  Sementara itu, jelas bahwa pada kenyataannya, untuk melakukan operasi terakhir, Anda memerlukan satu perintah tunggal <br><br><pre> <code class="cpp hljs">sr r24</code> </pre> <br>  dan untuk operasi pertama tidak ada lagi.  Saya telah berulang kali menyatakan bahwa kompiler saat ini membuat kode assembler tidak lebih buruk daripada seorang programmer (meskipun itu adalah sistem perintah ARM), terutama jika Anda membantunya sedikit, dan tiba-tiba gelandangan seperti itu.  Tetapi cobalah membantu kompiler untuk membuat kode yang benar, mungkin ini masalah pencampuran tipe dalam operasi shift dan coba <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - tidak membantu, dari kata "sepenuhnya", tetapi pilihan <br><br><pre> <code class="cpp hljs"> byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  memberikan hasil yang sedikit lebih baik <br><br><pre> <code class="cpp hljs">ldi r25,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) asr r25 ror r24</code> </pre> <br>  - tiga tim, karena ekspansi ke keseluruhan sekarang menempati satu tim - lebih baik, meskipun tidak sempurna, gambar yang sama untuk <br><br><pre> <code class="cpp hljs">byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - tiga tim.  Nah, agar tidak menulis gips tambahan, kami membuat variabel itu sendiri tanpa tanda <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byteu;</code> </pre> <br>  dan BINGO - kode assembler sepenuhnya memenuhi harapan kami <br><br><pre> <code class="cpp hljs">byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; lsr r24</code> </pre> <br>  Aneh bagaimana kelihatannya, apa perbedaannya, untuk menunjukkan tipe variabel yang benar dengan segera, atau untuk membawanya langsung ke operasi - tetapi ternyata ada perbedaan. <br><br>  Studi lebih lanjut menunjukkan bahwa kode assembler memperhitungkan jenis variabel yang hasilnya ditetapkan <br><br><pre> <code class="cpp hljs">byteu = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  berfungsi dengan baik dan menghasilkan kode minimal, dan opsi <br><br><pre> <code class="cpp hljs">byte = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  tidak bisa tanpa tiga tim. <br><br>  Tentunya, perilaku seperti itu dijelaskan dalam standar bahasa, saya bertanya kepada mereka yang tahu dalam komentar, tetapi sekali lagi saya akan dengan bangga menyatakan bahwa "Chukchi bukan pembaca" dan saya akan melanjutkan ceritanya. <br><br>  Jadi, langkah seperti itu tidak membantu bergeser ke kanan - seperti sebelumnya, ada 3 tim (yah. Yang bukan 5, seperti untuk versi tanda) dan saya tidak bisa meningkatkan hasilnya dengan cara apa pun. <br>  Tetapi bagaimanapun juga, kita melihat bahwa operasi shift dengan nomor yang tidak ditandatangani dilakukan lebih cepat daripada dengan lawannya.  Oleh karena itu, jika kita tidak akan memperlakukan bit nomor paling signifikan sebagai tanda (dan dalam kasus register, biasanya demikian), maka kita tentu perlu menambahkan atribut yang tidak ditandatangani, yang akan kita lakukan di masa mendatang. <br><br>  Ternyata dengan bergeser secara umum, semuanya sangat menarik, mari kita mulai meningkatkan jumlah posisi ketika bergeser ke kiri dan melihat hasilnya: &lt;&lt; 1 dibutuhkan 1 siklus clock, &lt;&lt; 2 - 2, &lt;&lt; 3 - 3, 4 - 2 tanpa diduga, kompiler menerapkan optimasi rumit yang rumit <br><br><pre> <code class="cpp hljs">swap r24 andi r24,lo8(<span class="hljs-number"><span class="hljs-number">-16</span></span>)</code> </pre> <br>  di mana perintah s swap menukar dua camilan dalam satu byte.  Selanjutnya, berdasarkan optimasi terakhir &lt;&lt; 5 - 3, &lt;&lt; 6 - 4, &lt;&lt; 7 - 3 lagi secara tak terduga, ada optimasi lain <br><br><pre> <code class="cpp hljs">ror r24 clr r24 ror r24</code> </pre> <br>  bit transfer digunakan, &lt;&lt; 8 - 0 mengukur, karena ternyata 0, tidak ada gunanya mencari lebih jauh. <br><br>  Ngomong-ngomong, ini tugas yang menarik untuk Anda - untuk waktu minimum apa Anda bisa melakukan operasi <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> byteu; byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  yang menerjemahkan 0x1234 ke 0x2340.  Solusi yang jelas adalah dengan menjalankan beberapa perintah 4 kali <br><br><pre> <code class="cpp hljs">lsl rl rol rh</code> </pre> <br>  mengarah ke 4 * 2 = 8 langkah, saya cepat-cepat datang dengan pilihan <br><br><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> mov tmp,rl andi tmp,<span class="hljs-number"><span class="hljs-number">0x0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rh,tmp ; <span class="hljs-number"><span class="hljs-number">2343</span></span> andi rl,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br>  yang membutuhkan 7 langkah dan register perantara.  Jadi, kompiler menghasilkan kode 6 perintah dan tidak ada register perantara - keren, ya. <br><br><div class="spoiler">  <b class="spoiler_title">Saya menyembunyikan kode ini di bawah spoiler - coba cari solusinya sendiri.</b> <div class="spoiler_text">  Petunjuk: dalam rangkaian perintah MK ada perintah EKSKLUSIF ATAU atau TOTAL JUMLAH DUA <br><br><div class="spoiler">  <b class="spoiler_title">Ini dia, kode yang luar biasa ini</b> <div class="spoiler_text"><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">6343</span></span> andi r2l,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">6340</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br></div></div><br>  Saya hanya mendapatkan kesenangan estetika dari fragmen ini. <br></div></div><br>  Biasanya, untuk angka 16-bit, perbedaan antara kode untuk nomor yang ditandatangani dan yang tidak ditandatangani menghilang ketika bergeser ke kiri, aneh seperti itu. <br><br>  Mari kita kembali ke byte kita dan mulai bergerak ke kanan.  Seperti yang kita ingat, untuk byte yang ditandatangani kita memiliki 5 siklus clock, untuk byte yang tidak ditandai - 3 dan kali ini tidak dapat dikurangi.  Atau semua sama itu mungkin - ya, itu mungkin, tetapi sangat aneh (GCC dengan optimisasi dihidupkan - "ini adalah tempat yang sangat aneh"), yaitu ini <br><br><pre> <code class="cpp hljs">byteu = (byteu &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>;</code> </pre> <br>  yang menghasilkan tepat satu perintah untuk kedua varian tanda.  Cocok dan opsi <br><br><pre> <code class="cpp hljs"> byteu = (byteu &amp; <span class="hljs-number"><span class="hljs-number">0xFE</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  tetapi hanya untuk nomor yang tidak ditandatangani, dengan yang sudah ditandatangani semuanya menjadi lebih menyedihkan - 7 langkah, jadi kami terus mengeksplorasi hanya opsi pertama. <br><br>  Saya tidak bisa mengatakan bahwa saya mengerti apa yang terjadi, karena jelas bahwa perkalian logis (&amp;) dengan konstanta seperti itu setelah perubahan semacam itu tidak masuk akal (dan itu tidak masuk akal), tetapi kehadiran &amp; operasi mempengaruhi kode dari pergeseran itu sendiri.  "Kamu melihat gopher - tidak - dan aku tidak melihat, tetapi dia." <br><br>  Bergeser 2 dan seterusnya menunjukkan bahwa penting untuk melunasi bit tanda, tetapi jumlah awalnya tidak ditandatangani, secara umum, beberapa sampah diperoleh, "tetapi berhasil," adalah satu-satunya hal yang dapat dikatakan tentang ini. <br><br>  Namun demikian, aman untuk mengatakan bahwa menafsirkan isi register dan memori sebagai angka yang tidak ditandatangani memungkinkan Anda untuk melakukan sejumlah operasi (misalnya, menggeser atau memperluas nilai) dengan mereka lebih cepat dan menghasilkan kode yang lebih kompak, sehingga sangat direkomendasikan untuk menulis program untuk MK, kecuali kalau tidak (penafsiran sebagai angka sudah umum) bukanlah prasyarat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436956/">https://habr.com/ru/post/id436956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436946/index.html">Pengenalan sinar-X: presisi = 0,84, ingat = 0,96. Apakah kita perlu lebih banyak dokter?</a></li>
<li><a href="../id436948/index.html">Masa depan infrastruktur pusat data</a></li>
<li><a href="../id436950/index.html">Startups di CES 2019: Bagian Satu</a></li>
<li><a href="../id436952/index.html">Demi uang: cari dan eksploitasi kerentanan di terminal pembayaran seluler</a></li>
<li><a href="../id436954/index.html">Acara digital di Moskow dari 21 Januari hingga 27 Januari</a></li>
<li><a href="../id436958/index.html">Bot poker strategis Libratus disesuaikan untuk simulasi militer</a></li>
<li><a href="../id436960/index.html">Uji saya jika Anda bisa. Apakah pengembang YML Bermimpi pengujian bisa dilakukan?</a></li>
<li><a href="../id436962/index.html">Sumber terbuka populer - bagian satu: 3 alat untuk bekerja dengan data</a></li>
<li><a href="../id436964/index.html">"Rostelecom. DataTalks "- kursus kuliah gratis tentang rekayasa data dan manajemen data</a></li>
<li><a href="../id436966/index.html">Pengoptimalan situs web untuk Kecepatan GooglePage (semua fitur dipertimbangkan setelah pembaruannya) Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>