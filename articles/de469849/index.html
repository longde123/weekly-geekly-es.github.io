<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈸 🈁 🚔 Das Spiel „Attack 51%“: Schreiben eines einfachen eigenständigen Spiels auf der Obyte-Plattform 😅 🦐 🥒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel „Autonome Agenten“ oder wenn wir den Code in der offenen Kryptoplattform von Obyte ausführen, haben wir darüber gesprochen, was aut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Spiel „Attack 51%“: Schreiben eines einfachen eigenständigen Spiels auf der Obyte-Plattform</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/obyte/blog/469849/"><img src="https://habrastorage.org/webt/zi/a-/kz/zia-kzq-ohjjej4uyjlwt7md-ga.gif"><br><br>  Im letzten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Autonome Agenten“ oder wenn wir den Code in der offenen Kryptoplattform von Obyte ausführen, haben</a> wir darüber gesprochen, was autonome Agenten sind, und sie mit intelligenten Verträgen von Ethereum verglichen.  Schreiben wir nun unseren ersten autonomen Agenten (AA) anhand des 51% Attack-Beispiels.  Und am Ende des Artikels werden wir Möglichkeiten zur Verbesserung analysieren: Wie können Spieler vor dem Verlust / Verlust von Geldern geschützt werden und wie kann der Algorithmus verbessert werden, um die Auswirkung von „Walen“ mit großen Einzahlungen auf das Spielergebnis zu verringern. <br><a name="habracut"></a><br>  Die Originale beider eigenständiger Agenten sind im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Oscript-Code-Editor immer</a> in Form von Vorlagen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfügbar. Wählen</a> Sie sie einfach aus dem Dropdown-Menü aus: <i>„51% Angriffsspiel“</i> und <i>„Fundraising-Proxy“.</i> <br><br>  Bevor Sie mit dem Schreiben von AA in Oscript beginnen, empfehle ich dringend, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leitfaden Erste Schritte</a> <i>(deu)</i> in unserer Dokumentation zu lesen, um sich schnell mit den Grundprinzipien des Schreibens von AA vertraut zu machen. <br><br><h2>  Die Essenz des Spiels </h2><br>  Mehrere Teams konkurrieren gleichzeitig um das Recht, den gesamten Pool gesammelter Gelder zu sammeln.  Teamplayer machen Einzahlungen und erhöhen dadurch den Gesamtbetrag des Pools.  Das Team, das mindestens 51% aller eingenommenen und mindestens einen Tag lang als Leader gehaltenen Gelder eingezahlt hat, gewinnt.  Der Pool wird proportional zum geleisteten Beitrag auf die Spieler des Gewinnerteams verteilt, wodurch jeder Teilnehmer möglicherweise seine Investition verdoppeln kann. <br><br>  Sobald eines der Teams&gt; = 51% aller Gelder sammelt, wird es zuvor zum Gewinner erklärt und seine Teilnehmer können keine Einzahlungen mehr tätigen.  Alle anderen Teams haben 24 Stunden Zeit, um das Gewinnerteam zu überholen.  Sobald dies geschieht, wird das überholende Team der Gewinner und der Timer startet den Countdown erneut. <br><br>  Unsere Implementierung gibt "Aktien" an jeden Einzahler im Austausch gegen Bytes im Verhältnis 1: 1 aus. Wenn das Team gewinnt, kann der Teilnehmer gegen eine Aktie im gewonnenen Pool tauschen.  Aktien sind ein Aktivposten auf der Obyte-Plattform, der speziell für jedes Team freigegeben wurde.  Sie können wie jeder Vermögenswert übertragen / gehandelt werden und ihre potenziellen Gewinne an andere Personen verkaufen.  Der Aktienkurs hängt vom Markt ab, der die Gewinnchancen des Teams bewertet. <br><br>  Jeder kann ein Team bilden.  Der Schöpfer des Teams kann eine Gewinnprovision festlegen, die im Falle eines Sieges von jedem Teammitglied berechnet wird. <br><br>  Wir werden auch die zweite AA in unserem Spiel im Namen des Erstellers des Teams anwenden, der den erforderlichen Betrag „Crowd Funding“ durchführt. Nur wenn dies erreicht ist (in unserem Beispiel bei Erreichen von&gt; 51% des Spielpools), werden alle gesammelten Mittel an die Adresse AA gesendet Spiele, sonst kann das Geld frei zurückgenommen werden. <br><br><h2>  Schreiben von Oscript-Code </h2><br>  Ich möchte Sie daran erinnern, dass der AA-Code jedes Mal aufgerufen wird, wenn eine Transaktion an der Adresse dieses AA eingeht, der sogenannten  Transaktion auslösen.  Tatsächlich ist AA ein Code, der als Antwort auf eine Eingabe (Daten in einer Triggertransaktion und der aktuelle Status von AA selbst, gespeichert in Statusvariablen) eine Ausgabe generiert (eine andere "Antwort" -Transaktion) oder ihren Status ändert.  Unsere Aufgabe ist es, die Regeln der AA-Reaktion auf Eingabedaten zu programmieren.  Alle Transaktionen in Obyte sind eine Reihe von Nachrichten, meistens sind es "Zahlungs" -Nachrichten oder "Daten" -Nachrichten usw. <br><br><h3>  Initialisierung </h3><br>  Zuerst initialisieren wir unsere AA.  Der Init-Block wird bei jedem Start von AA ganz am Anfang aufgerufen.  Darin setzen wir lokale Konstanten für einen bequemeren Zugriff auf Werte. <br><br><pre><code class="javascript hljs">{     <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-string"><span class="hljs-string">`{         $team_creation_fee = 5000;         $challenging_period = 24*3600;         $bFinished = var['finished'];     }`</span></span>,     <span class="hljs-attr"><span class="hljs-attr">messages</span></span>: { <span class="hljs-attr"><span class="hljs-attr">cases</span></span>: [ ]     } }</code> </pre> <br>  String <i>$ bFinished = var ['beendet'];</i>  liest die <i>fertige</i> Variable aus dem Zustand AA. <br>  Ein Array der resultierenden Nachrichten wird von den <i>Fällen</i> umrahmt <i>: {}</i> Block, der dem üblichen <i>Schalter- / Fall- / Standardblock</i> ähnelt, basierend auf den Bedingungen in den if-untergeordneten Blöcken, wird nur eine der Nachrichten ausgewählt, oder wenn nein, <i>wenn</i> Blöcke <i>true zurückgeben</i> , wird dies der Fall sein letzte ausgewählte Nachricht. <br><br><h3>  Wir bilden ein Team </h3><br>  Der erste Block verarbeitet also Transaktionen, um einen neuen Befehl zu erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// create a new team; any excess amount is sent back if: `{trigger.data.create_team AND !$bFinished}`, init: `{ if (var['team_' || trigger.address || '_asset']) bounce('you already have a team'); if (trigger.output[[asset=base]] &lt; $team_creation_fee) bounce('not enough to pay for team creation'); }`, messages: [ { app: 'asset', payload: { is_private: false, is_transferrable: true, auto_destroy: false, fixed_denominations: false, issued_by_definer_only: true, cosigned_by_definer: false, spender_attested: false } }, { app: 'payment', if: `{trigger.output[[asset=base]] &gt; $team_creation_fee}`, payload: { asset: 'base', outputs: [ {address: "{trigger.address}", amount: "{trigger.output[[asset=base]] - $team_creation_fee}"} ] } }, { app: 'state', state: `{ var['team_' || trigger.address || '_founder_tax'] = trigger.data.founder_tax otherwise 0; var['team_' || trigger.address || '_asset'] = response_unit; response['team_asset'] = response_unit; }` } ]</span></span></code> </pre> <br>  Wie wir sehen, ist die Bedingung für die Ausführung dieses Blocks die erste im if-Block und eine Überprüfung, ob die Triggertransaktion eine Nachricht mit dem Datentyp ( <i>trigger.data.create_team</i> ) enthält, die einen Schlüssel namens <i>create_team hat</i> Das Spiel ist noch nicht vorbei ( <i>! $ bFinished</i> ).  Auf die lokale Konstante <i>$ bFinished kann</i> von überall im Code <i>zugegriffen</i> werden, wenn sie im Init-Block initialisiert wurde.  Wenn mindestens eine dieser Bedingungen nicht erfüllt wäre, würde der übergeordnete Fallblock einfach weiter ausgeführt und die Bedingungen für die folgenden Nachrichten überprüft, wobei diese übersprungen würde. <br><br>  Im nächsten <i>Init-</i> Block initialisieren wir nichts, sondern überprüfen die notwendigen Bedingungen, ohne die die Trigger-Transaktion als fehlerhaft angesehen wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-string"><span class="hljs-string">'team_'</span></span> || trigger.address || <span class="hljs-string"><span class="hljs-string">'_asset'</span></span>]) bounce(<span class="hljs-string"><span class="hljs-string">'you already have a team'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (trigger.output[[asset=base]] &lt; $team_creation_fee) bounce(<span class="hljs-string"><span class="hljs-string">'not enough to pay for team creation'</span></span>);</code> </pre> <br>  Hier verketten wir (mit ||) die Zeichenfolge mit der Variablen aus dem Transaktionsauslöser und versuchen herauszufinden, ob es eine Variable mit dem Namen <i>'team_' || gibt</i>  <i>trigger.address ||</i>  <i>'_asset'</i> in unserer AA-Geschichte. <br><br>  Der Aufruf von <i>bounce ()</i> setzt alle am aktuellen Moment vorgenommenen Änderungen zurück und gibt einen Fehler an den Aufrufer zurück. <br><br>  Beachten Sie auch, wie die Suche innerhalb der Triggertransaktion <i>ausgeführt wird</i> : <i>trigger.output [[Asset = Basis]]</i> sucht nach einer Ausgabe mit <i>Asset == Basis</i> , die den in der Triggertransaktion angegebenen Betrag in Bytes (Basis-Asset = Bytes) zurückgibt.  Und wenn dieser Betrag nicht ausreicht, um ein neues Team zu erstellen, rufen wir bounce () auf und essen stillschweigend alle eingehenden Bytes abzüglich bounce_fee, was standardmäßig 10.000 Bytes beträgt. <br><br>  Als nächstes beginnt der Großteil des Teambuilding-Codes.  Kurz gesagt lautet der Algorithmus wie folgt: <br><br><ol><li>  Die erste Nachricht gibt ein neues Asset frei ( <i>App: 'Asset'</i> ) <br></li><li>  Die zweite Nachricht gibt alles zurück, was mehr als die zum Erstellen des Befehls erforderliche Anzahl von Bytes ist ( <i>App: 'Zahlung'</i> ).  Schauen Sie sich hier den if-Block an.  Wenn diese Bedingung falsch ist (der Ersteller hat genau die erforderliche Anzahl von Bytes gesendet), wird diese Nachricht nicht in die resultierende Transaktion aufgenommen, sondern einfach verworfen. <br></li><li>  Die dritte Nachricht ändert den Status unserer AA ( <i>App: 'state'</i> ): Wir schreiben die als Argument übergebene <i>Gründersteuer</i> oder setzen sie auf 0, wenn sie nicht an die <i>Triggertransaktion</i> übertragen wurde.  Das <i>var1-</i> Konstrukt gibt <i>andernfalls var2 var1</i> zurück, wenn es in true umgewandelt wird, andernfalls gibt es var2 zurück.  Hier treffen wir auf die Variable response_unit, die immer den Hash der resultierenden Einheit enthält.  In diesem Fall, weil  Die resultierende Einheit erstellt ein neues Asset namens Asset-a und ist der Hash der erstellenden Einheit.  Die Zeichenfolge <i>response ['team_asset'] = response_unit</i> schreibt einfach denselben Hash (oder das Asset für den angegebenen Befehl) in das Array <i>responseVars</i> in der letzten Einheit.  Das Antwortarray kann auch der Person vorgelesen werden, die die Auslösetransaktion durchgeführt hat, sowie in Ereignis-Listenern, die Ereignisse mit dieser AA abonniert haben. <br></li></ol><br><h3>  Wir akzeptieren Einzahlungen </h3><br>  Wenn die Erstellung des Teams abgeschlossen ist, fahren Sie mit dem nächsten Block fort - Verarbeitung der Einzahlungen von Teammitgliedern. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// contribute to a team if: `{trigger.data.team AND !$bFinished}`, init: `{ if (!var['team_' || trigger.data.team || '_asset']) bounce('no such team'); if (var['winner'] AND var['winner'] == trigger.data.team) bounce('contributions to candidate winner team are not allowed'); }`, messages: [ { app: 'payment', payload: { asset: `{var['team_' || trigger.data.team || '_asset']}`, outputs: [ {address: "{trigger.address}", amount: "{trigger.output[[asset=base]]}"} ] } }, { app: 'state', state: `{ var['team_' || trigger.data.team || '_amount'] += trigger.output[[asset=base]]; if (var['team_' || trigger.data.team || '_amount'] &gt; balance[base]*0.51){ var['winner'] = trigger.data.team; var['challenging_period_start_ts'] = timestamp; } }` } ]</span></span></code> </pre> <br>  Von dem neuen, das wir hier treffen, ist die Ausgabe von Token des Vermögens des ausgewählten Teams an seinen Teilnehmer im Austausch für seine Einzahlung in Bytes: <br><br><pre> <code class="plaintext hljs">asset: `{var['team_' || trigger.data.team || '_asset']}`, outputs: [{address: "{trigger.address}", amount: "{trigger.output[[asset=base]]}"}</code> </pre> <br>  Wie wir uns erinnern, die Zustandsvariable <i>'team_' ||</i>  <i>trigger.data.team ||</i>  Wir haben das <i>'_asset'</i> in der Phase der <i>Teamerstellung</i> gespeichert und es speichert den Hash der Einheit, in der wir das Asset für dieses Team erstellt haben, <i>dh</i> den Namen dieses Assets - a. <br><br>  Im selben Block wird die Hauptbedingung auf 51% überprüft: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-string"><span class="hljs-string">'team_'</span></span> || trigger.data.team || <span class="hljs-string"><span class="hljs-string">'_amount'</span></span>] &gt; balance[base]*<span class="hljs-number"><span class="hljs-number">0.51</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-string"><span class="hljs-string">'winner'</span></span>] = trigger.data.team; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-string"><span class="hljs-string">'challenging_period_start_ts'</span></span>] = timestamp; }</code> </pre> <br>  Wenn nach dieser Auslösetransaktion der Kontostand des angegebenen Teams 51% überschreitet, wird das Team zum Gewinner erklärt und wir zeichnen den aktuellen Unix-Zeitstempel auf (starten Sie den Timer). <br><br>  Dieser Zeitstempel wird im dritten Block überprüft, wenn wir eine Auslösetransaktion mit dem Versuch erhalten, das Spiel zu beenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// finish the challenging period and set the winner if: `{trigger.data.finish AND !$bFinished}`, init: `{ if (!var['winner']) bounce('no candidate winner yet'); if (timestamp &lt; var['challenging_period_start_ts'] + $challenging_period) bounce('challenging period not expired yet'); }`, messages: [ { app: 'state', state: `{ var['finished'] = 1; var['total'] = balance[base]; var['challenging_period_start_ts'] = false; response['winner'] = var['winner']; }` } ]</span></span></code> </pre> <br><h3>  Wir zahlen einen Preis </h3><br>  Und der letzte Block, der am meisten Spaß macht, ist die Zahlung der gesamten Anzahlung an die Gewinner: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// pay out the winnings if: `{ if (!$bFinished) return false; $winner = var['winner']; $winner_asset = var['team_' || $winner || '_asset']; $asset_amount = trigger.output[[asset=$winner_asset]]; $asset_amount &gt; 0 }`, init: `{ $share = $asset_amount / var['team_' || $winner || '_amount']; $founder_tax = var['team_' || $winner || '_founder_tax']; $amount = round(( $share * (1-$founder_tax) + (trigger.address == $winner AND !var['founder_tax_paid'] ? $founder_tax : 0) ) * var['total']); }`, messages: [ { app: 'payment', payload: { asset: "base", outputs: [ {address: "{trigger.address}", amount: "{$amount}"} ] } }, { app: 'state', state: `{ if (trigger.address == $winner) var['founder_tax_paid'] = 1; }` } ]</span></span></code> </pre> <br>  Interessant ist hier der Initialisierungsblock, in dem wir die notwendigen Werte im Voraus berechnen: <br><br><pre> <code class="javascript hljs"> $share = $asset_amount / <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-string"><span class="hljs-string">'team_'</span></span> || $winner || <span class="hljs-string"><span class="hljs-string">'_amount'</span></span>]; $founder_tax = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-string"><span class="hljs-string">'team_'</span></span> || $winner || <span class="hljs-string"><span class="hljs-string">'_founder_tax'</span></span>]; $amount = round(( $share * (<span class="hljs-number"><span class="hljs-number">1</span></span>-$founder_tax) + (trigger.address == $winner AND !<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-string"><span class="hljs-string">'founder_tax_paid'</span></span>] ? $founder_tax : <span class="hljs-number"><span class="hljs-number">0</span></span>) ) * <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>[<span class="hljs-string"><span class="hljs-string">'total'</span></span>]);</code> </pre> <br>  Alle Mitglieder des Teams mit Ausnahme des Erstellers erhalten einen Betrag, der proportional zu ihrem ursprünglichen Beitrag ist (1-mal-1-Byte im Austausch für Asset-Token, die in einer Auslösetransaktion gesendet werden).  Dem Ersteller wird auch eine Provision gezahlt (es wird überprüft, ob die Adresse der <i>Person</i> , die die Auslösetransaktion gesendet hat, der Adresse des Erstellers des Gewinnerteams <i>trigger.address == $ Gewinner entspricht</i> ).  Es ist wichtig, nicht zu vergessen, dass die Provision nur einmal gezahlt werden sollte und der Ersteller unendlich viele Triggertransaktionen senden kann. Daher speichern wir das Flag im Status AA. <br><br><h2>  Starte das Spiel </h2><br>  Der Code ist also fertig.  Hier ist eine vollständige Auflistung davon: <br><br><div class="spoiler">  <b class="spoiler_title">vollständiger AA-Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-string"><span class="hljs-string">`{ $team_creation_fee = 5000; $challenging_period = 24*3600; $bFinished = var['finished']; }`</span></span>, <span class="hljs-attr"><span class="hljs-attr">messages</span></span>: { <span class="hljs-attr"><span class="hljs-attr">cases</span></span>: [ { <span class="hljs-comment"><span class="hljs-comment">// create a new team; any excess amount is sent back if: `{trigger.data.create_team AND !$bFinished}`, init: `{ if (var['team_' || trigger.address || '_amount']) bounce('you already have a team'); if (trigger.output[[asset=base]] &lt; $team_creation_fee) bounce('not enough to pay for team creation'); }`, messages: [ { app: 'asset', payload: { is_private: false, is_transferrable: true, auto_destroy: false, fixed_denominations: false, issued_by_definer_only: true, cosigned_by_definer: false, spender_attested: false } }, { app: 'payment', if: `{trigger.output[[asset=base]] &gt; $team_creation_fee}`, payload: { asset: 'base', outputs: [ {address: "{trigger.address}", amount: "{trigger.output[[asset=base]] - $team_creation_fee}"} ] } }, { app: 'state', state: `{ var['team_' || trigger.address || '_founder_tax'] = trigger.data.founder_tax otherwise 0; var['team_' || trigger.address || '_asset'] = response_unit; response['team_asset'] = response_unit; }` } ] }, { // contribute to a team if: `{trigger.data.team AND !$bFinished}`, init: `{ if (!var['team_' || trigger.data.team || '_asset']) bounce('no such team'); if (var['winner'] AND var['winner'] == trigger.data.team) bounce('contributions to candidate winner team are not allowed'); }`, messages: [ { app: 'payment', payload: { asset: `{var['team_' || trigger.data.team || '_asset']}`, outputs: [ {address: "{trigger.address}", amount: "{trigger.output[[asset=base]]}"} ] } }, { app: 'state', state: `{ var['team_' || trigger.data.team || '_amount'] += trigger.output[[asset=base]]; if (var['team_' || trigger.data.team || '_amount'] &gt; balance[base]*0.51){ var['winner'] = trigger.data.team; var['challenging_period_start_ts'] = timestamp; } }` } ] }, { // finish the challenging period and set the winner if: `{trigger.data.finish AND !$bFinished}`, init: `{ if (!var['winner']) bounce('no candidate winner yet'); if (timestamp &lt; var['challenging_period_start_ts'] + $challenging_period) bounce('challenging period not expired yet'); }`, messages: [ { app: 'state', state: `{ var['finished'] = 1; var['total'] = balance[base]; var['challenging_period_start_ts'] = false; response['winner'] = var['winner']; }` } ] }, { // pay out the winnings if: `{ if (!$bFinished) return false; $winner = var['winner']; $winner_asset = var['team_' || $winner || '_asset']; $asset_amount = trigger.output[[asset=$winner_asset]]; $asset_amount &gt; 0 }`, init: `{ $share = $asset_amount / var['team_' || $winner || '_amount']; $founder_tax = var['team_' || $winner || '_founder_tax']; $amount = round(( $share * (1-$founder_tax) + (trigger.address == $winner AND !var['founder_tax_paid'] ? $founder_tax : 0) ) * var['total']); }`, messages: [ { app: 'payment', payload: { asset: "base", outputs: [ {address: "{trigger.address}", amount: "{$amount}"} ] } }, { app: 'state', state: `{ if (trigger.address == $winner) var['founder_tax_paid'] = 1; }` } ] } ] } }</span></span></code> </pre> <br></div></div><br>  Lassen Sie uns den Code auf Gültigkeit prüfen und versuchen, ihn in testnet bereitzustellen. <br><br><ol><li>  Gehen Sie zum Online-Editor: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://testnet.oscript.org</a> <br></li><li>  Fügen Sie unseren Code ein und klicken Sie auf Validieren.  Wenn alles korrekt ist, sehen wir eine Berechnung der Codekomplexität: <i>AA validiert, Komplexität = 27, ops = 176</i> .  Hier ist ops die Anzahl der Operationen in unserem Code, Komplexität ist die Komplexität des Codes.  Obyte-AAs haben keine Zyklen, aber selbst dies ermöglicht keinen 100% igen Schutz des Netzwerks vor böswilligen AAs mit schlechtem Code.  Daher haben alle AAs eine Obergrenze für die Komplexität, Komplexität = 100. Die Codekomplexität wird zum Zeitpunkt der Bereitstellung berechnet und alle Zweige des Codes werden berücksichtigt.  Einige Operationen sind relativ einfach, z. B. ± und andere. Sie erhöhen die Komplexität nicht.  Andere, wie der Zugriff auf die Datenbank (Änderung des Status) oder komplexe Berechnungen (Aufruf einiger Funktionen), erhöhen die Komplexität.  Informationen dazu, welche Vorgänge einfach und welche komplex sind, finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sprachreferenz</a> . <br></li><li>  Klicken Sie auf Bereitstellen.  Wir sehen etwas Ähnliches <br></li></ol><br><pre> <code class="plaintext hljs">Check in explorer: https://testnetexplorer.obyte.org/#DiuxsmIijzkfAVgabS9chJm5Mflr74lZkTGud4PM1vI= Agent address: 6R7SF6LTCNSPLYLIJWDF57BTQVZ7HT5N</code> </pre> <br>  Ich rate Ihnen, dem Link im Explorer zu folgen und sicherzustellen, dass das Gerät mit unserer AA im Netzwerk verfügbar ist.  Der Explorer zeigt auch den vollständigen Code für unsere AA an  Alle AAs im Obyte-Netzwerk sind Open Source.  Sie können den Code eines Agenten an seiner Adresse studieren. <br><br><h2>  Crowdfunding </h2><br>  Und nun zu den versprochenen Optimierungen.  In der aktuellen Implementierung sendet jeder Spieler sofort Geld an die AA-Adresse des Spiels und gibt sein Team an.  Gleichzeitig wird das Team möglicherweise nie zum Anführer, und das Geld wurde bereits gesendet.  Wir können den Prozess des Geldsammelns optimieren und die Situation vermeiden, dass wir Geld an ein Team senden, das niemals ein Gewinner wird.  Dies kann mit der zweiten AA erfolgen, indem das sogenannte Crowdfunding von Geldern arrangiert wird, indem ein dynamisches Ziel für den Betrag der gesammelten Mittel festgelegt wird, der 51% des Betrags im Spiel entspricht. <br><br>  In Oscript können wir den Status jeder anderen AA lesen, sodass wir die Möglichkeit haben, ein dynamisches Ziel in unserer Crowdfunding-AA festzulegen. <br><br>  Der Algorithmus lautet wie folgt: Der Ersteller des Teams fordert die Spieler auf, Geld nicht an die Adresse des Spiels, sondern an die Adresse eines Agenten zu senden, der die Crowdfunding-Funktionalität implementiert.  Dieser Agent speichert die gesammelte Menge an Bytes zu Hause und sendet sie nur dann an das Spiel, wenn er&gt; = 51% der Menge im Spiel sammelt.  Und sofort wird dieses Team führend.  Wenn der erforderliche Betrag nicht eingezogen wird, wird das Geld einfach an die Spieler zurückgegeben.  In der Phase des Fundraising erhalten die Spieler keine Team-Spiel-Token, sondern Crowdfunding-Token, die bei Erfolg in Zukunft zurückerstattet oder gegen Spiel-Token eingetauscht werden können. <br><br>  Im nächsten Artikel implementieren wir diese Funktionalität. <br><br><h2>  Wir sammeln keine Bytes, sondern Zertifizierungen </h2><br>  In der einfachsten Form des Spiels "Attack 51%" sprechen wir über die Höhe der gesammelten Mittel.  So können „Wale“ mit großen Geldbörsen den größten Teil der Gewinne erzielen. <br><br>  Um das Spiel für alle Teilnehmer ehrlicher zu gestalten, werden wir versuchen, nicht die Anzahl der gesendeten Bytes, sondern die Anzahl der Teilnehmer in den Teams zu zählen.  Das Team, das die maximale Teilnehmerzahl gewinnen konnte, gewinnt.  Jeder Spieler investiert einen festen Betrag, beispielsweise 1 GB, und zählt als Einheit in den Teampool.  Nichts hindert uns jedoch daran, eine unendliche Anzahl neuer Adressen zu erstellen. Die kritische Bedingung ist daher, dass im Spiel nur Adressen zulässig sind, die mit anderen IDs verknüpft sind, wobei die Regel „Eine Person - eine ID“ eingehalten wird.  Eine solche Bindung wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zertifizierung bezeichnet</a> .  Ein Beispiel für eine Zertifizierung ist die Weitergabe des KYC-Verfahrens. Anschließend wird an die DAG eine Nachricht über die Verbindung zwischen der Obyte-Adresse und dem Hash personenbezogener Daten gesendet (die personenbezogenen Daten selbst werden in der Brieftasche des Benutzers gespeichert und er kann sie an einzelne Gegenparteien weitergeben, wenn er dies wünscht. Für diese Aufgabe sind sie jedoch nicht erforderlich nur die Tatsache der Bindung).  Ein weiteres Beispiel für die Zertifizierung ist die Zertifizierung von E-Mails in Domänen, in denen die Regel „Eine Person - eine E-Mail“ eingehalten wird, z. B. in Domänen einiger Universitäten, Unternehmen und Länder.  Somit wird eine reale Person nur einmal gezählt. <br><br>  Autonome Agenten können den Status der Zertifizierung von Adressen im Netzwerk anfordern, sodass eine minimale Anzahl von Änderungen am Code vorgenommen wird. <br><br>  Ich schlage vor, dass die Leser in den Kommentaren vorschlagen, an welchen Stellen und wie genau es notwendig ist, die Codezeilen der aktuellen Version des Spiels zu ändern, um dies zu implementieren.  Um wie immer die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oscript-Sprachreferenz zu unterstützen</a> . <br><br>  Unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwietracht</a> &amp; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469849/">https://habr.com/ru/post/de469849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469833/index.html">Programmatisches Management (und Muster)</a></li>
<li><a href="../de469835/index.html">Sowjetische Zukunftsträume, Teil 2. Jetzt mit Grab</a></li>
<li><a href="../de469837/index.html">Erstes Flutter-Treffen in St. Petersburg: Videoberichte</a></li>
<li><a href="../de469839/index.html">Sicherheitsanfälligkeit in Pikabu-Spam</a></li>
<li><a href="../de469843/index.html">"Wo sind diese jungen Punks, die uns vom Erdboden abwischen werden?"</a></li>
<li><a href="../de469855/index.html">Gradle + LLVM</a></li>
<li><a href="../de469861/index.html">Datenstrukturen für Spielprogrammierer: Massendaten</a></li>
<li><a href="../de469867/index.html">Wie wird daraus ein Schüler (und was haben Brettspiele damit zu tun)</a></li>
<li><a href="../de469871/index.html">Als Tastaturen Tische waren</a></li>
<li><a href="../de469875/index.html">So schützen Sie Ihre Passwörter im Jahr 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>