<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☪️ 👩🏼‍🤝‍👩🏻 🕵🏿 使用PVS-Studio查找LLVM 8中的错误 👕 🙉 👨🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自上次通过PVS-Studio检查LLVM项目的代码以来已经有两年了，所以让我们看看PVS-Studio是否仍然是检测错误和安全漏洞的工具中的领导者。 我们将通过扫描LLVM 8.0.0版本中的新错误来实现。 

 必须写的文章 
 坦白说，我不想写这篇文章。 谈论我们已经多次检查（ 1，2，3 ）...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用PVS-Studio查找LLVM 8中的错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/450002/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png" alt="PVS-Studio和LLVM 8.0.0"></div><br> 自上次通过PVS-Studio检查LLVM项目的代码以来已经有两年了，所以让我们看看PVS-Studio是否仍然是检测错误和安全漏洞的工具中的领导者。 我们将通过扫描LLVM 8.0.0版本中的新错误来实现。 <br><a name="habracut"></a><br><h2> 必须写的文章 </h2><br> 坦白说，我不想写这篇文章。 谈论我们已经多次检查（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1，2，3</a> ）的项目并不有趣。 我宁愿选择新的东西，但别无选择。 <br><br> 每次发行新版本的LLVM或更新<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Clang Static Analyzer时</a> ，我们都会收到以下内容的电子邮件： <br><br>  <i>嘿，新版本的Clang Static Analyzer有了新的诊断！</i>  <i>PVS-Studio似乎变得不那么重要了。</i>  <i>Clang可以检测到比以前更多的bug，现在正赶上PVS-Studio。</i>  <i>你说什么</i> <br><br> 为此，我很乐意回应： <br><br>  <b>我们也没有闲逛！</b> 我们大大提高了PVS-Studio的功能，所以不用担心-我们仍然是最好的。 <br><br> 恐怕这是一个不好的答案。 它没有提供证据，这就是我写这篇文章的原因。 因此，我再次检查了LLVM，发现了大量的各种错误。 我最喜欢的那些将进一步讨论。  Clang Static Analyzer无法检测到这些错误（或使过程非常麻烦），而我们可以。 而且，顺便说一句，我只花了一个晚上就把所有这些错误记录下来了。 <br><br> 不过，这篇文章花了我几个星期才能完成。 我只是无法让自己把收集到的材料写成文字:)。 <br><br> 顺便说一句，如果您想知道PVS-Studio采用了什么技术来检测错误和漏洞，请看一下这篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 <br><br><h2> 新的和现有的诊断 </h2><br> 正如我已经说过的，LLVM的许多检查中的最后一次是在两年前完成的，后来发现的错误已由作者修复。 本文将显示错误的新部分。 怎么会有新的错误？ 有以下三个原因： <br><br><ol><li>  LLVM项目正在不断发展； 作者修改现有代码并添加新代码。 修改的零件和新零件自然都具有新的错误。 对于定期而不是时常进行静态分析，这是一个有力的论据。 我们的文章格式非常适合展示PVS-Studio的功能，但与提高代码质量或降低错误修复成本无关。 定期使用静态分析！ </li><li> 我们修改并改进了现有的诊断程​​序，使分析仪能够检测到以前无法发现的错误。 </li><li>  PVS-Studio已通过两年前不存在的新诊断程序得到了增强。 我将这些警告分为一个单独的部分，以便更清楚地看到PVS-Studio的进度。 </li></ol><br><h2> 现有诊断程序发现的缺陷 </h2><br>  <b>片段编号</b>  <b>1：复制粘贴</b> <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldUpgradeX86Intrinsic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function *F, StringRef Name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Name == <span class="hljs-string"><span class="hljs-string">"addcarryx.u32"</span></span> || <span class="hljs-comment"><span class="hljs-comment">// Added in 8.0 .... Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0 Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0 Name == "avx512.cvtusi2sd" || // Added in 7.0 Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name == "sse2.pmulu.dq" || // Added in 7.0 Name == "sse41.pmuldq" || // Added in 7.0 Name == "avx2.pmulu.dq" || // Added in 7.0 .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V501</a> [CWE-570]在“ ||”的左侧和右侧有相同的子表达式“ Name.startswith（“ avx512.mask.permvar。”）” 操作员。 自动升级.cpp 73 <br><br> 出现“ avx512.mask.permvar”。 子字符串被检查两次。 第二个条件显然是检查其他内容，但是程序员忘记更改复制的行。 <br><br>  <b>片段编号</b>  <b>2：错别字</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CXNameRefFlags { CXNameRange_WantQualifier = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, CXNameRange_WantTemplateArgs = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, CXNameRange_WantSinglePiece = <span class="hljs-number"><span class="hljs-number">0x4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnnotateTokensWorker::HandlePostPonedChildCursor( CXCursor Cursor, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> StartTokenIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier; .... }</code> </pre> <br>  PVS-Studio诊断消息：V501在“ |”的左侧和右侧有相同的子表达式“ CXNameRange_WantQualifier” 操作员。  CIndex.cpp 7245 <br><br> 由于输入错误，命名的常量<i>CXNameRange_WantQualifier</i>被使用了两次。 <br><br>  <b>片段编号</b>  <b>3：对运算符优先级的混淆</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PPCTTIImpl::getVectorInstrCost(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Opcode, Type *Val, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V502</a> [CWE-783]也许“？：”操作符的工作方式与预期的不同。  '？：'运算符的优先级低于'=='运算符。  PPCTargetTransformInfo.cpp 404 <br><br> 我发现这个错误非常可爱。 是的，我知道我的口味很奇怪:)。 <br><br> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运算符的优先级</a> ，原始表达式的计算如下： <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-&gt;isLittleEndian())) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 但是，从实际的角度来看，这种情况没有意义，因为可以将其简化为： <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian())</code> </pre> <br> 这显然是一个错误。 程序员必须要检查<i>索引</i>为0/1的<i>索引</i>变量。 要修复代码，三元运算符应放在括号中： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre> <br> 三元运算符实际上非常棘手，可能会导致逻辑错误。 小心使用它，不要犹豫在它周围加上其他括号。 在“当心？：运算符并将其括在括号中”部分中将在此详细讨论该主题。 <br><br>  <b>片段编号</b>  <b>4，5：空指针</b> <br><br><pre> <code class="cpp hljs">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) { .... TypedInit *LHS = dyn_cast&lt;TypedInit&gt;(Result); .... LHS = dyn_cast&lt;TypedInit&gt;( UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get()) -&gt;Fold(CurRec)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LHS) { Error(PasteLoc, Twine(<span class="hljs-string"><span class="hljs-string">"can't cast '"</span></span>) + LHS-&gt;getAsString() + <span class="hljs-string"><span class="hljs-string">"' to string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V522</a> [CWE-476]可能会取消引用空指针“ LHS”。  TGParser.cpp 2152 <br><br> 如果<i>LHS</i>指针恰好为空，则程序应生成警告。 相反，它将取消引用非常空的指针： <i>LHS-&gt; getAsString（）</i> 。 <br><br> 错误处理程序包含错误的情况很常见，因为开发人员无法正确测试它们。 静态分析器会检查所有可访问的代码，无论实际执行的频率是多少。 这是静态分析如何补充其他代码测试和保护手段的一个很好的例子。 <br><br> 还可以找到<i>RHS</i>指针的类似故障处理程序：V522 [CWE-476]可能会取消引用空指针“ RHS”。  TGParser.cpp 2186 <br><br>  <b>片段编号</b>  <b>6：移动后使用指针</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ExtractBlocks(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; ProgClone = CloneModule(BD.getProgram(), VMap); .... BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= MiscompiledFunctions.clear(); for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) { Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first); // &lt;= assert(NewF &amp;&amp; "Function not found??"); MiscompiledFunctions.push_back(NewF); } .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V522 [CWE-476]可能会取消引用空指针“ ProgClone”。 错误编译.cpp 601 <br><br> 智能指针<i>ProgClone</i>首先释放对象所有权： <br><br><pre> <code class="cpp hljs">BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone));</code> </pre> <br> 实际上， <i>ProgClone</i>已成为空指针-因此，从技术上讲，空指针会进一步取消引用： <br><br><pre> <code class="cpp hljs">Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first);</code> </pre> <br> 但这不会发生！ 请注意，循环实际上根本不执行。 <br><br> 首先清除了<i>MiscompiledFunctions</i>容器： <br><br><pre> <code class="cpp hljs">MiscompiledFunctions.clear();</code> </pre> <br> 然后在循环条件中使用其大小： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, e = MisCompFunctions.size(); i != e; ++i) {</code> </pre> <br> 显然，循环不会开始。 我认为这也是一个错误，代码的外观也有所不同。 <br><br> 我猜我们在这里看到的是臭名昭著的错误奇偶校验，其中一个错误充当了另一个错误的伪装:)。 <br><br>  <b>片段编号</b>  <b>7：移动后使用指针</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; TestOptimizer(BugDriver &amp;BD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Test, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Safe) { outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Optimizing functions being tested: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Optimized = BD.runPassesOn(Test.get(), BD.getPassesToRun()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Optimized) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error running this sequence of passes"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" on the input program!\n"</span></span>; BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Test)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= BD.EmitProgressBitcode(*Test, "pass-error", false); // &lt;= if (Error E = BD.debugOptimizerCrash()) return std::move(E); return false; } .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V522 [CWE-476]可能会取消引用空指针“测试”。 错误编译cpp 709 <br><br> 这与前面的情况相似。 首先移动对象的内容，然后使用它，就好像什么都没发生一样。 在将移动语义添加到C ++之后，此错误变得越来越普遍。 那就是我喜欢这种语言的原因！ 您将获得新的射击方式，这意味着PVS-Studio将始终有工作要做：)。 <br><br>  <b>片段编号</b>  <b>8：空指针</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FunctionDumper::dump(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDBSymbolTypeFunctionArg &amp;Symbol) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TypeId = Symbol.getTypeId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type = Symbol.getSession().getSymbolById(TypeId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  PVS-Studio诊断消息：V522 [CWE-476]可能会取消引用空指针“类型”。  233.第233章 <br><br> 就像错误处理程序一样，打印调试数据的测试功能通常也无法获得足够的测试覆盖率，这就是一个例子。 该功能不是在帮助用户解决他们的问题，而是在等待他们解决问题。 <br><br> 固定代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>;</code> </pre> <br>  <b>片段编号</b>  <b>9：空指针</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SearchableTableEmitter::collectTableEntries( GenericTable &amp;Table, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Record *&gt; &amp;Items) { .... RecTy *Ty = resolveTypes(Field.RecType, TI-&gt;getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Ty) <span class="hljs-comment"><span class="hljs-comment">// &lt;= PrintFatalError(Twine("Field '") + Field.Name + "' of table '" + Table.Name + "' has incompatible type: " + Ty-&gt;getAsString() + " vs. " + // &lt;= TI-&gt;getType()-&gt;getAsString()); .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V522 [CWE-476]可能会取消引用空指针“ Ty”。  SearchableTableEmitter.cpp 614 <br><br> 我认为您不需要对此发表任何评论。 <br><br>  <b>片段编号</b>  <b>10：错别字</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FormatTokenLexer::tryMergeCSharpNullConditionals() { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Identifier = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Question = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... Identifier-&gt;ColumnWidth += Question-&gt;ColumnWidth; Identifier-&gt;Type = Identifier-&gt;Type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Tokens.erase(Tokens.end() - 1); return true; }</span></span></code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V570</a>为其分配了“标识符-&gt;类型”变量。 格式令牌Lexer.cpp 249 <br><br> 给变量赋值本身是没有意义的操作。 程序员必须具有以下目的： <br><br><pre> <code class="cpp hljs">Identifier-&gt;Type = Question-&gt;Type;</code> </pre> <br>  <b>片段编号</b>  <b>11：可疑的休息</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SystemZOperand::print(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindToken: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Token:"</span></span> &lt;&lt; getToken(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindReg: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reg:"</span></span> &lt;&lt; SystemZInstPrinter::getRegisterName(getReg()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V622</a> [CWE-478]考虑检查“ switch”语句。 第一个“ case”运算符可能会丢失。 系统ZAsmParser.cpp 652 <br><br> 开头有一个非常可疑的<i>break</i>语句。 这里不应该有别的东西吗？ <br><br>  <b>片段编号</b>  <b>12：解引用后检查指针</b> <br><br><pre> <code class="cpp hljs">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) { Function *Callee = CS.getCalledFunction(); Function *Caller = CS.getCaller(); TargetTransformInfo &amp;TTI = TTIWP-&gt;getTTI(*Callee); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::InlineCost::getNever(<span class="hljs-string"><span class="hljs-string">"undefined callee"</span></span>); .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V595</a> [CWE-476]在针对nullptr验证了“被<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调用</a>者”指针之前，已使用该指针。 检查行：172，174。AMDGPUInline.cpp 172 <br><br> 调用<i>getTTI</i>函数时，首先取消引用被调用方指针。 <br><br> 然后发现应该检查指针的<i>nullptr</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration())</code> </pre> <br> 太晚了... <br><br>  <b>片段编号</b>  <b>13-否....：取消引用后检查指针</b> <br><br> 前面的示例不是唯一的。 在此代码段中发现了相同的问题： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeDoubleFP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallInst *CI, IRBuilder&lt;&gt; &amp;B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isBinary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPrecise = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... Function *CalleeFn = CI-&gt;getCalledFunction(); StringRef CalleeNm = CalleeFn-&gt;getName(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= AttributeList CalleeAt = CalleeFn-&gt;getAttributes(); if (CalleeFn &amp;&amp; !CalleeFn-&gt;isIntrinsic()) { // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V595 [CWE-476]在针对nullptr对其进行验证之前，已使用了'CalleeFn'指针。 检查行：1079、1081。SimplifyLibCalls.cpp 1079 <br><br> 而这个： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::InstantiateAttrs(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MultiLevelTemplateArgumentList &amp;TemplateArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Decl *Tmpl, Decl *New, LateInstantiatedAttrVec *LateAttrs, LocalInstantiationScope *OuterMostScope) { .... NamedDecl *ND = dyn_cast&lt;NamedDecl&gt;(New); CXXRecordDecl *ThisContext = dyn_cast_or_null&lt;CXXRecordDecl&gt;(ND-&gt;getDeclContext()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(), ND &amp;&amp; ND-&gt;isCXXInstanceMember()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V595 [CWE-476]在针对nullptr对其进行验证之前，已使用了'ND'指针。 检查行：532、534。SemaTemplateInstantiateDecl.cpp 532 <br><br> 在这里： <br><br><ul><li>  V595 [CWE-476]在针对nullptr对其进行验证之前，已使用了'U'指针。 检查行：404、407。DWARFFormValue.cpp 404 </li><li>  V595 [CWE-476]在针对nullptr对其进行验证之前，已使用了'ND'指针。 检查行：2149，2151。SemaTemplateInstantiate.cpp 2149 </li></ul><br> 然后，我对跟踪V595警告失去了兴趣，因此，除了上面显示的错误之外，我无法告诉您是否还有其他此类错误。 我敢打赌。 <br><br>  <b>片段编号</b>  <b>17、18：可疑的转变</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLogicalImmediate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Imm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;Encoding)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Size = RegSize; .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V629</a> [CWE-190]考虑检查'〜（大小-1）&lt;&lt; 1'表达式。  32位值的位移，随后扩展为64位类型。  260 AArch64AddressingModes.h <br><br> 这段代码实际上可能是正确的，但是看起来确实很奇怪，需要检查。 <br><br> 假设<i>Size</i>变量的值为16； 那么<i>NImms</i>变量将获得以下值： <br><br>  11111111111111111111111111111111111111111111111111111111111111100000000 <br><br> 但实际上它将获得价值： <br><br>  0000000000000000000000000000000000000000001111111111111111111111111100000 <br><br> 发生这种情况是因为所有计算都是在32位无符号类型上完成的，然后才隐式提升为<i>uint64_t</i> ，并将最高有效位清零。 <br><br> 该问题可以解决如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br> 此类型的另一个错误：V629 [CWE-190]考虑检查'Immr &lt;&lt; 6'表达式。  32位值的位移，随后扩展为64位类型。  AArch64AddressingModes.h 269 <br><br>  <b>片段编号</b>  <b>19：</b> <b><i>还有其他</i></b> <b>关键词</b> <b><i>吗</i></b> <b>？</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OperandVector &amp;Operands) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) { <span class="hljs-comment"><span class="hljs-comment">// VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token. // Skip it. continue; } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) { // &lt;= Op.addRegWithFPInputModsOperands(Inst, 2); } else if (Op.isDPPCtrl()) { Op.addImmOperands(Inst, 1); } else if (Op.isImm()) { // Handle optional arguments OptionalIdx[Op.getImmTy()] = I; } else { llvm_unreachable("Invalid operand type"); } .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V646</a> [CWE-670]考虑检查应用程序的逻辑。 可能缺少“ else”关键字。  AMDGPUAsmParser.cpp 5655 <br><br> 这不是一个错误。 由于第一个<i>if</i>语句的<i>then</i>块以<i>continue</i>结尾，因此是否具有<i>else</i>关键字无关紧要。 在任何情况下，行为都是相同的。 但是，缺少<i>其他内容</i>会使代码的可读性降低，因此有潜在的危险。 如果有一天<i>继续</i>消失，行为将发生巨大变化。 我强烈建议添加<i>else</i> 。 <br><br>  <b>片段编号</b>  <b>20：四个相同的错别字</b> <br><br><pre> <code class="cpp hljs">LLVM_DUMP_METHOD <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Symbol::dump(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUndefined()) Result += <span class="hljs-string"><span class="hljs-string">"(undef) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakDefined()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-def) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakReferenced()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-ref) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThreadLocalValue()) Result += <span class="hljs-string"><span class="hljs-string">"(tlv) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SymbolKind::GlobalSymbol: Result + Name.str(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case SymbolKind::ObjectiveCClass: Result + "(ObjC Class) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCClassEHType: Result + "(ObjC Class EH) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCInstanceVariable: Result + "(ObjC IVar) " + Name.str(); // &lt;= break; } OS &lt;&lt; Result; }</span></span></code> </pre> <br>  PVS-Studio诊断消息： <br><br><ul><li>  V655 [CWE-480]字符串已连接，但未使用。 考虑检查“ Result + Name.str（）”表达式。  Symbol.cpp 32 </li><li>  V655 [CWE-480]字符串已连接，但未使用。 考虑检查'Result +“（ObjC Class）” + Name.str（）'表达式。  Symbol.cpp 35 </li><li>  V655 [CWE-480]字符串已连接，但未使用。 考虑检查'Result +“（ObjC Class EH）” + Name.str（）'表达式。  Symbol.cpp 38 </li><li>  V655 [CWE-480]字符串已连接，但未使用。 考虑检查“结果+“（ObjC IVar）” + Name.str（）”表达式。  Symbol.cpp 41 </li></ul><br> 程序员不小心使用了+运算符而不是+ =，并最终得到了四个无意义的构造。 <br><br>  <b>片段编号</b>  <b>21：未定义的行为</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReqFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;StringRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;FeaturesMap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Record *&gt; &amp;ReqFeatures)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;R : ReqFeatures) { StringRef AsmCondString = R-&gt;getValueAsString(<span class="hljs-string"><span class="hljs-string">"AssemblerCondString"</span></span>); SmallVector&lt;StringRef, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Ops; SplitString(AsmCondString, Ops, <span class="hljs-string"><span class="hljs-string">","</span></span>); assert(!Ops.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"AssemblerCondString cannot be empty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Op : Ops) { assert(!Op.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Empty operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FeaturesMap.find(Op) == FeaturesMap.end()) FeaturesMap[Op] = FeaturesMap.size(); } } }</code> </pre> <br> 尝试自行发现错误。 我添加了图像，以便您不会立即看到答案： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png" alt="???"></div><br><br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V708</a> [CWE-758]使用了危险的构造：'FeaturesMap [Op] = <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FeatureMap.size</a> （）'，其中'FeaturesMap'是'map'类的。 这可能导致不确定的行为。  RISCVCompressInstEmitter.cpp 490 <br><br> 错误的行是这一行： <br><br><pre> <code class="cpp hljs">FeaturesMap[Op] = FeaturesMap.size();</code> </pre> <br> 如果未找到<i>Op</i>元素，则程序将在映射中创建一个新元素，并为其分配该映射中元素的总数。 您只是不知道在添加新元素之前还是之后将调用<i>size</i>函数。 <br><br>  <b>片段编号</b>  <b>22-没有</b>  <b>24：重复的作业</b> <br><br><pre> <code class="cpp hljs">Error MachOObjectFile::checkSymbolTable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MachO::nlist STE = getSymbolTableEntry(SymDRI); NType = STE.n_type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= NType = STE.n_type; // &lt;= NSect = STE.n_sect; NDesc = STE.n_desc; NStrx = STE.n_strx; NValue = STE.n_value; } .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V519</a> [CWE-563]连续两次为'NType'变量分配值。 也许这是一个错误。 检查行：1663、1664。MachOObjectFile.cpp 1664 <br><br> 我认为这不是真正的错误-而是重复的作业。 但这仍然是一个缺陷。 <br><br> 其他两种情况： <br><br><ul><li>  V519 [CWE-563]连续两次为'B.NDesc'变量分配值。 也许这是一个错误。 检查行：1488、1489。llvm-nm.cpp 1489 </li><li>  V519 [CWE-563]连续两次为变量分配值。 也许这是一个错误。 检查行：59，61。coff2yaml.cpp 61 </li></ul><br>  <b>片段编号</b>  <b>25-没有</b>  <b>27：更多重复的作业</b> <br><br> 这些处理重复分配的版本略有不同。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Vectorizer::vectorizeLoadChain( ArrayRef&lt;Instruction *&gt; Chain, SmallPtrSet&lt;Instruction *, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; *InstructionsProcessed) { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Alignment = getAlignment(L0); .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> NewAlign = getOrEnforceKnownAlignment(L0-&gt;getPointerOperand(), StackAdjustedAlignment, DL, L0, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, &amp;DT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NewAlign != <span class="hljs-number"><span class="hljs-number">0</span></span>) Alignment = NewAlign; Alignment = NewAlign; .... }</code> </pre> <br>  PVS-Studio诊断消息：V519 [CWE-563]'Alignment'变量连续两次被赋值。 也许这是一个错误。 检查行：1158、1160。LoadStoreVectorizer.cpp 1160 <br><br> 这是一个非常奇怪的代码段，它可能包含逻辑错误。 首先根据条件为<i>Alignment</i>变量分配值，然后再次为其分配值，但无需任何事先检查。 <br><br> 类似缺陷： <br><br><ul><li>  V519 [CWE-563]'效果'变量连续两次被赋值。 也许这是一个错误。 检查行：152，165。WebAssemblyRegStackify.cpp 165 </li><li>  V519 [CWE-563]'ExpectNoDerefChunk'变量已连续两次分配值。 也许这是一个错误。 检查行：4970，4973。SemaType.cpp 4973 </li></ul><br>  <b>片段编号</b>  <b>28：始终为真状态</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrefixes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct InternalInstruction* insn)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> nextByte; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte == <span class="hljs-number"><span class="hljs-number">0xf3</span></span> &amp;&amp; (nextByte == <span class="hljs-number"><span class="hljs-number">0x88</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0x89</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc6</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc7</span></span>)) { insn-&gt;xAcquireRelease = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextByte != <span class="hljs-number"><span class="hljs-number">0x90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PAUSE instruction support // &lt;= break; } .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V547</a> [CWE-571]表达式'nextByte！= 0x90'始终为true。  X86DisassemblerDecoder.cpp 379 <br><br> 支票没有意义。  <i>nextByte</i>变量从不等于<i>0x90</i> ：从逻辑<i>上讲，</i>它仅来自上一个检查。 这一定是逻辑错误。 <br><br>  <b>片段编号</b>  <b>29-否....：始终为真/假条件</b> <br><br> 关于整个条件（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V547</a> ）或部分条件（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V560</a> ）始终为真或假的警告很多。 这些不是真正的错误，而是通常仅仅是错误的代码，宏扩展的影响等等。 也就是说，仍应检查所有此类警告，因为其中某些警告可能指向真正的逻辑错误。 例如，以下代码片段看起来不正确： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DecodeStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeGPRPairRegisterClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MCInst &amp;Inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Decoder)</span></span></span><span class="hljs-function"> </span></span>{ DecodeStatus S = MCDisassembler::Success; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RegNo &gt; <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCDisassembler::Fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((RegNo &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || RegNo == <span class="hljs-number"><span class="hljs-number">0xe</span></span>) S = MCDisassembler::SoftFail; .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V560</a> [CWE-570]条件表达式的一部分始终为false：RegNo == 0xe。  ARMDisassembler.cpp 939 <br><br>  <i>0xE</i>常数是十进制数字14。检查<i>RegNo == 0xe</i>没有意义，因为如果<i>RegNo&gt; 13</i> ，则函数将返回。 <br><br> 我看到了很多其他的V547和V560警告，但是像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V595一样</a> ，我对检查它们并不感到兴奋，因为我已经有足够的材料写一篇文章了：）。 因此，在LLVM中没有此类错误总数。 <br><br> 这是一个示例，说明为什么检查这些警告很无聊。 对以下代码发出警告时，分析仪完全正确。 但这仍然不是错误。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> UnwrappedLineParser::parseBracedList(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ContinueOnSemicolons, tok::TokenKind ClosingBraceKind) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasError = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... HasError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ContinueOnSemicolons) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !HasError; .... }</code> </pre> <br>  PVS-Studio诊断消息：V547 [CWE-570]表达式'！HasError'始终为false。  UnwrappedLineParser.cpp 1635 <br><br>  <b>片段编号</b>  <b>30：可疑的回报</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isImplicitlyDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MachineRegisterInfo &amp;MRI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg), E = MRI.def_instr_end(); It != E; ++It) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*It).isImplicitDef(); } .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V612</a> [CWE-670]循环内无条件的“返回”。  R600OptimizeVectorRegisters.cpp 63 <br><br> 它可能是错误或特定的编码技术，旨在与其他程序员交流一些想法。 对我来说，它什么也没说，只是那是一段非常可疑的代码。 请不要写这样的代码:)。 <br><br> 感到累了吗？ 好，该喝些茶或咖啡了。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png" alt="咖啡"></div><br><br><h2> 新诊断程序发现的缺陷 </h2><br> 我认为30个示例足以满足现有的诊断要求。 现在，让我们看看是否可以通过新的诊断找到有趣的东西，这些诊断是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上次</a>检查之后添加的。 在过去的两年中，C ++分析器模块扩展了66种新的诊断程序。 <br><br>  <b>片段编号</b>  <b>31：无法访问的代码</b> <br><br><pre> <code class="cpp hljs">Error CtorDtorRunner::run() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CtorDtorMap = ES.lookup(JITDylibSearchList({{&amp;JD, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}}), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Names), NoDependenciesToRegister, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CtorDtorMap.takeError(); CtorDtorsByPriority.clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V779</a> [CWE-561]检测到无法访问的代码。 可能存在错误。  ExecutionUtils.cpp 146 <br><br> 如您所见， <i>if</i>语句的两个分支都以<i>return</i>语句结尾，这意味着<i>CtorDtorsByPriority</i>容器将永远不会被清除。 <br><br>  <b>片段编号</b>  <b>32：无法访问的代码</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LLParser::ParseSummaryEntry() { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Lex.getKind()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_gv: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseGVEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_module: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseModuleEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_typeid: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; // &lt;= default: return Error(Lex.getLoc(), "unexpected summary kind"); } Lex.setIgnoreColonInIdentifiers(false); // &lt;= return false; }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V779 [CWE-561]检测到无法访问的代码。 可能存在错误。  LLParser.cpp 835 <br><br> 这个很有趣。 首先看一下这一部分： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br> 这段代码似乎没有什么奇怪的。  <i>break</i>语句是不必要的，可以安全地删除。 但这不是那么简单。 <br><br> 该警告由以下几行触发： <br><br><pre> <code class="cpp hljs">Lex.setIgnoreColonInIdentifiers(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br> 确实，此代码不可访问。  <i>switch</i>语句的所有大小写标签都以<i>return</i>结尾，而毫无意义的单独<i>中断</i>看起来不再那么无害了！ 如果其中一个分支的结尾是<i>休息</i>而不是<i>返回，该</i>怎么办？ <br><br>  <b>片段编号</b>  <b>33：意外清除最高有效位</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStubAlignment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arch == Triple::systemz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; RuntimeDyldImpl::emitSection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectFile &amp;Obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SectionRef &amp;Section, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCode) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> DataSize = Section.getSize(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StubBufSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V784</a>位掩码的大小小于第一个操作数的大小。 这将导致丢失更高的位。 运行系统Dyld.cpp 815 <br><br> 注意， <i>getStubAlignment</i>函数返回一个<i>无符号</i>值。 让我们看看表达式将如何求值，假设函数将返回值8： <br><br>  〜（getStubAlignment（）-1） <br><br>  〜（8u-1） <br><br>  0xFFFFFFF8u <br><br> 现在请注意， <i>DataSize</i>变量的类型为64位无符号。 因此，事实证明，执行操作DataSize＆0xFFFFFFF8将导致清除该值的所有32个最高有效位。 我不认为程序员想要那样。 也许他们的意思是DataSize＆0xFFFFFFFFFFFFFFFFFFF8u。 <br><br> 要修复该错误，应按以下方式重写代码： <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(getStubAlignment()) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br> 或像这样： <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1U</span></span>LL);</code> </pre> <br>  <b>片段编号</b>  <b>34：错误的显式类型转换</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleShuffleMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scale, ArrayRef&lt;T&gt; Mask, SmallVectorImpl&lt;T&gt; &amp;ScaledMask)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; Scale &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Unexpected scaling factor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumElts = Mask.size(); ScaledMask.assign(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(NumElts * Scale), <span class="hljs-number"><span class="hljs-number">-1</span></span>); .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1028</a> [CWE-190]可能的溢出。 考虑将'NumElts * Scale'运算符的类型转换为'size_t'类型，而不是结果类型。  1577年 <br><br> 在将类型为<i>int的</i>变量相乘时，使用显式类型转换来避免溢出。 但是，在这种情况下，它不起作用，因为首先会发生乘法，然后才将32位结果提升为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>size_t</i></a>类型。 <br><br>  <b>片段编号</b>  <b>35：错误的复制粘贴</b> <br><br><pre> <code class="cpp hljs">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return &amp;I; } .... }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V778</a> [CWE-682]找到了两个类似的代码片段。 也许这是一个错字，应该使用“ Op1”变量而不是“ Op0”。  InstCombineCompares.cpp 5507 <br><br> 这个新的很酷的诊断程序可以检测使用复制粘贴编写代码片段的情况，所有名称更改后都保存一个。 <br><br> 注意，在第二个块中，除一个以外的所有<i>Op0</i>都更改为<i>Op1</i> 。 代码可能看起来像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op1-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; }</code> </pre> <br>  <b>片段编号</b>  <b>36：变量混合</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1001</a> [CWE-563]分配了'Mode'变量，但在功能结束时未使用。  SIModeRegister.cpp 48 <br><br> 函数参数的名称与类成员的名称相同是非常危险的，因为您可能会混淆它们。 您在这里看到的就是一个例子。 以下表达式毫无意义： <br><br><pre> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br> 参数已更改，但此后从未使用过。 该代码段可能应如下所示： <br><br><pre> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br>  <b>片段编号</b>  <b>37：变量混合</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionBase</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SymbolTableSection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SectionBase { .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SymbolTableSection::addSymbol(Twine Name, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Bind, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Type, SectionBase *DefinedIn, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Visibility, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Shndx, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size) { .... Sym.Value = Value; Sym.Visibility = Visibility; Sym.Size = Size; Sym.Index = Symbols.size(); Symbols.emplace_back(llvm::make_unique&lt;Symbol&gt;(Sym)); Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize; }</code> </pre> <br>  PVS-Studio诊断消息：V1001 [CWE-563]分配了'Size'变量，但在功能结束时未使用。  Object.cpp 424 <br><br> 这与前面的示例相似。 正确版本： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize;</code> </pre> <br>  <b>片段编号</b>  <b>38-没有</b>  <b>47：缺少指针检查</b> <br><br> 我们稍早看了一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V595</a>警告的示例。 它检测到的情况是指针先被取消引用然后才被检查。 新的诊断<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1004</a>与此相反，它也可以检测大量错误。 它查找已测试的指针，必要时不再对其进行测试。 这是在LLVM的代码中发现的一些此类错误。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGEPCost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type *PointeeType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *Ptr, ArrayRef&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *&gt; Operands)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert(....); BaseGV = dyn_cast&lt;GlobalValue&gt;(Ptr-&gt;stripPointerCasts()); } bool HasBaseReg = (BaseGV == nullptr); auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V1004 [CWE-476]在针对nullptr进行验证之后，不安全地使用了'Ptr'指针。 检查行：729、738。TargetTransformInfoImpl.h 738 <br><br>  <i>Ptr</i>可以为<i>nullptr</i> ，由检查指示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br> 但是，取消了对同一指针的引用，而无需进行进一步的检查： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType());</code> </pre> <br> 另一个类似的情况。 <br><br><pre> <code class="cpp hljs">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Stub) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *FD = dyn_cast&lt;FunctionDecl&gt;(GD.getDecl()); SmallVector&lt;QualType, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; ArgTypes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FD) <span class="hljs-comment"><span class="hljs-comment">// &lt;= for (const ParmVarDecl *Parm : FD-&gt;parameters()) ArgTypes.push_back(Parm-&gt;getType()); CallingConv CC = FD-&gt;getType()-&gt;castAs&lt;FunctionType&gt;()-&gt;getCallConv(); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V1004 [CWE-476]在针对nullptr对其进行验证之后，不安全地使用了“ FD”指针。 检查行：3228、3231。CGDebugInfo.cpp 3231 <br><br> 注意<i>FD</i>指针。 该错误很简单，因此对此没有评论。 <br><br> 这里还有一个： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computePolynomialFromPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value &amp;Ptr, Polynomial &amp;Result, Value *&amp;BasePtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL)</span></span></span><span class="hljs-function"> </span></span>{ PointerType *PtrTy = dyn_cast&lt;PointerType&gt;(Ptr.getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PtrTy) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Result = Polynomial(); BasePtr = nullptr; } unsigned PointerBits = DL.getIndexSizeInBits(PtrTy-&gt;getPointerAddressSpace()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio诊断消息：V1004 [CWE-476]在针对nullptr对其进行验证后，不安全地使用了'PtrTy'指针。 检查行：960、965。InterleavedLoadCombinePass.cpp 965 <br><br> 您如何避免这样的错误？ 在检查代码时要非常小心，并定期通过PVS-Studio进行检查。 <br><br> 我认为我们不应该研究这种类型的其他示例，因此这里只是警告列表： <br><ul><li>  V1004 [CWE-476]在针对nullptr进行验证之后，不安全地使用了“ Expr”指针。 检查行：1049、1078。DebugInfoMetadata.cpp 1078 </li><li>  V1004 [CWE-476]在针对nullptr对其进行验证之后，不安全地使用了'PI'指针。 检查行：733、753。LegacyPassManager.cpp 753 </li><li>  V1004 [CWE-476]在针对nullptr对其进行验证之后，不安全地使用了“ StatepointCall”指针。 检查行：4371、4379。Verifier.cpp 4379 </li><li>  V1004 [CWE-476]在针对nullptr对其进行验证之后，不安全地使用了“ RV”指针。 检查行：2263，2268。TGParser.cpp 2268 </li><li>  V1004 [CWE-476]在针对nullptr进行验证之后，不安全地使用了'CalleeFn'指针。 检查行：1081、1096。SimplifyLibCalls.cpp 1096 </li><li>  V1004 [CWE-476]在针对nullptr进行验证之后，不安全地使用了“ TC”指针。 检查行：1819、1824。Driver.cpp 1824 </li></ul><br>  <b>片段编号</b>  <b>48-没有</b>  <b>60：不重要，但仍然是缺陷（潜在的内存泄漏）</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutator&gt; createISelMutator() { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutationStrategy&gt;&gt; Strategies; Strategies.emplace_back( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectorIRStrategy(InjectorIRStrategy::getDefaultOps())); .... }</code> </pre> <br>  PVS-Studio诊断消息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1023</a> [CWE-460]通过“ emplace_back”方法将没有所有者的指针添加到“策略”容器中。 发生异常时会发生内存泄漏。  llvm-isel-fuzzer.cpp 58 <br><br> 您不能简单地编写<i>xxx.push_back（新X）</i>以将元素附加到类型<i>std :: vector &lt;std :: unique_ptr &lt;X &gt;&gt;</i>的容器中，因为没有从<i>X *</i>隐式转换为<i>std :: unique_ptr &lt; X&gt;</i> 。 <br><br> 流行的解决方案是编写<i>xxx.emplace_back（新X），</i>因为它是可编译的： <i>emplace_back</i>方法直接从参数构造元素，因此可以使用显式构造函数。 <br><br> 但是该解决方案并不安全。 如果向量已满，将重新分配内存。 该操作可能失败，并最终引发<i>std :: bad_alloc</i>异常。 在这种情况下，指针将丢失并且程序将无法删除创建的对象。 <br><br> 一个更安全的解决方案是创建一个<i>unique_ptr</i> ，它将保留指针，直到向量尝试重新分配内存为止： <br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X))</code> </pre> <br>  C ++ 14标准允许您使用“ std :: make_unique”： <br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;X&gt;())</code> </pre> <br> 这种类型的缺陷在LLVM中不起作用。 如果内存分配失败，编译将仅终止。 就是说，这对于具有较长<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正常运行时间的</a>应用程序可能非常关键，因为当发生内存分配失败时，这些应用程序不能简单地终止。 <br><br> 因此，即使该代码对LLVM而言并不危险，我认为我仍然应该向您介绍此错误模式以及PVS-Studio现在可以检测到它的事实。 <br><br> 其他类似情况： <br><br><ul><li>  V1023 [CWE-460]通过'emplace_back'方法将没有所有者的指针添加到'Passes'容器中。 发生异常时会发生内存泄漏。  PassManager.h 546 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702 </li></ul><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我写下了60条警告，然后停止了。</font><font style="vertical-align: inherit;">PVS-Studio是否在LLVM中发现了其他错误？</font><font style="vertical-align: inherit;">是的，确实如此。</font><font style="vertical-align: inherit;">但是当我写下示例时，夜幕降临，所以我决定放弃。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我希望您喜欢阅读本文，并鼓励您自己尝试使用PVS-Studio分析仪。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此页面</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下载分析仪并获得试用密钥。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最重要的是，定期使用静态分析。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一次性检查</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（如我们为普及静态分析和推广PVS-Studio所做的</font><b><font style="vertical-align: inherit;">检查）</font></b><font style="vertical-align: inherit;">并非正常情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">祝您改善代码的质量和可靠性！</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450002/">https://habr.com/ru/post/zh-CN450002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449992/index.html">NodeMCU简单驱动程序模型（SDM）展示：动态用户界面</a></li>
<li><a href="../zh-CN449994/index.html">施耐德曼的八个黄金法则将帮助您创建更好的界面</a></li>
<li><a href="../zh-CN449996/index.html">了解FFT算法</a></li>
<li><a href="../zh-CN449998/index.html">常见问题解答：旅行者极客在旅行之前需要了解哪些疫苗</a></li>
<li><a href="../zh-CN450000/index.html">（从右到左（通过窥镜</a></li>
<li><a href="../zh-CN450004/index.html">快速的C / C ++缓存，线程安全</a></li>
<li><a href="../zh-CN450006/index.html">冷水机组数据中心冷却：选择哪种冷却液？</a></li>
<li><a href="../zh-CN450008/index.html">使用PVS-Studio分析仪查找LLVM 8中的错误</a></li>
<li><a href="../zh-CN450010/index.html">照片的存储，备份和分类</a></li>
<li><a href="../zh-CN450016/index.html">从头开始创建正式的验证系统。 第1部分：PHP和Python中的字符虚拟机</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>