<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèø üçñ üßíüèΩ Cara menjatuhkan 10 juta paket per detik üëû üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ‚ÄºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di perusahaan, tim kami untuk melawan serangan DDoS disebut "packet droppers". Sementara semua tim lain melakukan hal-hal keren dengan lalu lintas mel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menjatuhkan 10 juta paket per detik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419921/"> Di perusahaan, tim kami untuk melawan serangan DDoS disebut "packet droppers".  Sementara semua tim lain melakukan hal-hal keren dengan lalu lintas melewati jaringan kami, kami senang menemukan cara baru untuk menghilangkannya. <br><br><img src="https://habrastorage.org/webt/s-/3y/un/s-3yun8pllqd7-e077fuxbk9jiw.png"><br>  <i>Foto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brian Evans</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CC BY-SA 2.0</a></i> <br><br>  Kemampuan untuk dengan cepat menjatuhkan paket sangat penting dalam menentang serangan DDoS. <br><br>  Paket drop yang mencapai server kami dapat dilakukan di beberapa level.  Setiap metode memiliki pro dan kontra.  Di bawah potongan, kami melihat semua yang kami uji. <br><a name="habracut"></a><br><blockquote>  <i>Catatan Penerjemah: dalam output beberapa perintah yang disajikan, spasi tambahan dihapus untuk menjaga keterbacaan.</i> </blockquote><h1>  Situs uji </h1><br>  Untuk kenyamanan dalam membandingkan metode, kami akan memberi Anda beberapa angka, namun, jangan menerimanya secara harfiah, karena kepalsuan tes.  Kami akan menggunakan salah satu kartu jaringan Intel 10Gb / s kami.  Karakteristik server yang tersisa tidak begitu penting, karena kami ingin fokus pada batasan sistem operasi, bukan perangkat keras. <br><br>  Tes kami akan terlihat sebagai berikut: <br><br><ul><li>  Kami menciptakan banyak paket kecil UDP, mencapai nilai 14 juta paket per detik; </li><li>  Semua lalu lintas ini diarahkan ke satu inti prosesor dari server yang dipilih; </li><li>  Kami mengukur jumlah paket yang diproses oleh kernel pada satu inti prosesor. </li></ul><br>  Lalu lintas buatan dihasilkan sedemikian rupa untuk menciptakan beban maksimum: alamat IP acak dan port pengirim digunakan.  Ini seperti apa di tcpdump: <br><br><pre><code class="bash hljs">$ tcpdump -ni vlan100 -c 10 -t udp and dst port 1234 IP 198.18.40.55.32059 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.51.16.30852 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.35.51.61823 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.44.42.30344 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.106.227.38592 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.48.67.19533 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.49.38.40566 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.50.73.22989 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.43.204.37895 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.104.128.1543 &gt; 198.18.0.12.1234: UDP, length 16</code> </pre> <br>  Pada server yang dipilih, semua paket akan menjadi dalam satu antrian RX dan, karenanya, akan diproses oleh satu inti.  Kami mencapainya dengan kontrol aliran perangkat keras: <br><br><pre> <code class="bash hljs">ethtool -N ext0 flow-type udp4 dst-ip 198.18.0.12 dst-port 1234 action 2</code> </pre><br>  Pengujian kinerja adalah proses yang kompleks.  Ketika kami menyiapkan tes, kami melihat bahwa keberadaan soket mentah aktif secara negatif mempengaruhi kinerja, jadi sebelum menjalankan tes, Anda perlu memastikan bahwa tidak ada <code>tcpdump</code> yang berjalan.  Ada cara mudah untuk memeriksa proses yang buruk: <br><br><pre> <code class="bash hljs">$ ss -A raw,packet_raw -l -p|cat Netid State Recv-Q Send-Q Local Address:Port p_raw UNCONN 525157 0 *:vlan100 users:((<span class="hljs-string"><span class="hljs-string">"tcpdump"</span></span>,pid=23683,fd=3))</code> </pre><br>  Dan akhirnya, kami mematikan Intel Turbo Boost di server kami: <br><br><pre> <code class="hljs pgsql">echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee /sys/devices/<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>/cpu/intel_pstate/no_turbo</code> </pre> <br>  Terlepas dari kenyataan bahwa Turbo Boost adalah hal yang hebat dan meningkatkan throughput setidaknya 20%, itu secara signifikan merusak standar deviasi dalam pengujian kami.  Dengan turbo aktif, deviasi mencapai ¬± 1,5%, sementara tanpa turbo hanya 0,25%. <br><br><img src="https://habrastorage.org/webt/ic/ik/jq/icikjqda_ztydjswe8xjq07u5sa.png"><br><br><h3>  Langkah 1. Jatuhkan paket dalam aplikasi </h3><br>  Mari kita mulai dengan ide untuk mengirimkan semua paket ke aplikasi dan mengabaikannya di sana.  Untuk kejujuran percobaan, pastikan iptables tidak memengaruhi kinerja dengan cara apa pun: <br><br><pre> <code class="bash hljs">iptables -I PREROUTING -t mangle -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT iptables -I PREROUTING -t raw -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT iptables -I INPUT -t filter -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT</code> </pre><br>  Aplikasi adalah siklus sederhana di mana data yang diterima segera dibuang: <br><br><pre> <code class="python hljs">s = socket.socket(AF_INET, SOCK_DGRAM) s.bind((<span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>, <span class="hljs-number"><span class="hljs-number">1234</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: s.recvmmsg([...])</code> </pre><br>  Kami sudah menyiapkan <a href="">kode</a> , jalankan: <br><br><pre> <code class="bash hljs">$ ./dropping-packets/recvmmsg-loop packets=171261 bytes=1940176</code> </pre><br>  Solusi ini memungkinkan kernel untuk mengambil hanya 175 ribu paket dari antrian perangkat keras, seperti yang diukur oleh <code>ethtool</code> dan <code>mmwatch</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami</a> : <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'ethtool -S ext0|grep rx_2'</span></span> rx2_packets: 174.0k/s</code> </pre><br>  Secara teknis, 14 juta paket per detik tiba di server, namun satu inti prosesor tidak dapat mengatasi volume seperti itu.  <code>mpstat</code> mengkonfirmasi ini: <br><br><pre> <code class="bash hljs">$ watch <span class="hljs-string"><span class="hljs-string">'mpstat -u -I SUM -P ALL 1 1|egrep -v Aver'</span></span> 01:32:05 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 01:32:06 PM 0 0.00 0.00 0.00 2.94 0.00 3.92 0.00 0.00 0.00 93.14 01:32:06 PM 1 2.17 0.00 27.17 0.00 0.00 0.00 0.00 0.00 0.00 70.65 01:32:06 PM 2 0.00 0.00 0.00 0.00 0.00 100.00 0.00 0.00 0.00 0.00 01:32:06 PM 3 0.95 0.00 1.90 0.95 0.00 3.81 0.00 0.00 0.00 92.38</code> </pre><br><br>  Seperti yang dapat kita lihat, aplikasi ini bukan hambatan: CPU # 1 digunakan pada 27,17% + 2,17%, sementara penanganan interupsi membutuhkan 100% pada CPU # 2. <br><br>  Menggunakan <code>recvmessagge(2)</code> memainkan peran penting.  Setelah kerentanan Spectre ditemukan, panggilan sistem menjadi lebih mahal karena <abbr title="Isolasi halaman-tabel kernel">KPTI</abbr> dan <abbr title="Kembalikan trampolin">retpoline yang</abbr> digunakan dalam kernel <br><br><pre> <code class="hljs ruby">$ tail -n +<span class="hljs-number"><span class="hljs-number">1</span></span> /sys/devices/system/cpu/vulnerabilities/* ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/meltdown</span></span> &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> PTI ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/spectre</span></span>_v1 &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> __user pointer sanitization ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/spectre</span></span>_v2 &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> Full generic retpoline, IBPB, IBRS_FW</code> </pre><br><br><h3>  Langkah 2. Membunuh conntrack </h3><br>  Kami secara khusus membuat beban seperti itu dengan IP dan port pengirim yang berbeda untuk memuat conntrack sebanyak mungkin.  Jumlah entri dalam conntrack selama tes cenderung semaksimal mungkin dan kami dapat memverifikasi ini: <br><br><pre> <code class="bash hljs">$ conntrack -C 2095202 $ sysctl net.netfilter.nf_conntrack_max net.netfilter.nf_conntrack_max = 2097152</code> </pre><br>  Selain itu, di <code>dmesg</code> Anda juga dapat melihat jeritan conntrack: <br><br><pre> <code class="bash hljs">[4029612.456673] nf_conntrack: nf_conntrack: table full, dropping packet [4029612.465787] nf_conntrack: nf_conntrack: table full, dropping packet [4029617.175957] net_ratelimit: 5731 callbacks suppressed</code> </pre><br>  Jadi mari kita matikan: <br><br><pre> <code class="bash hljs">iptables -t raw -I PREROUTING -d 198.18.0.12 -p udp -m udp --dport 1234 -j NOTRACK</code> </pre><br>  Dan mulai ulang tes: <br><br><pre> <code class="bash hljs">$ ./dropping-packets/recvmmsg-loop packets=331008 bytes=5296128</code> </pre><br><br>  Ini memungkinkan kami untuk mencapai tanda 333 ribu paket per detik.  Hore! <br>  PS Menggunakan SO_BUSY_POLL kita dapat mencapai sebanyak 470 ribu per detik, namun, ini adalah topik untuk pos yang terpisah. <br><br><h3>  Langkah 3. Filter Berkeley Batch </h3><br>  Mari kita lanjutkan.  Mengapa kita perlu mengirimkan paket ke aplikasi?  Meskipun ini bukan solusi umum, kita dapat mengikat filter paket Berkeley klasik ke soket dengan memanggil <code>setsockopt(SO_ATTACH_FILTER)</code> dan mengkonfigurasi filter untuk menjatuhkan paket kembali ke kernel. <br>  Siapkan <a href="">kodenya</a> , jalankan: <br><br><pre> <code class="bash hljs">$ ./bpf-drop packets=0 bytes=0</code> </pre><br>  Menggunakan filter paket (filter Berkeley klasik dan lanjutan memberikan kinerja yang hampir sama), kami mendapatkan sekitar 512 ribu paket per detik.  Selain itu, menjatuhkan paket selama interupsi membebaskan prosesor dari keharusan membangunkan aplikasi. <br><br><h3>  Langkah 4. iptables DROP setelah routing </h3><br>  Sekarang kita bisa menjatuhkan paket dengan menambahkan aturan berikut ke iptables di rantai INPUT: <br><br><pre> <code class="bash hljs">iptables -I INPUT -d 198.18.0.12 -p udp --dport 1234 -j DROP</code> </pre><br>  Biarkan saya mengingatkan Anda bahwa kami sudah menonaktifkan conntrack dengan aturan <code>-j NOTRACK</code> .  Dua aturan ini memberi kita 608 ribu paket per detik. <br><br>  Mari kita lihat angka-angka di iptables: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'iptables -L -v -n -x | head'</span></span> Chain INPUT (policy DROP 0 packets, 0 bytes) pkts bytes target prot opt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> out <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> destination 605.9k/s 26.7m/s DROP udp -- * * 0.0.0.0/0 198.18.0.12 udp dpt:1234</code> </pre><br>  Yah, tidak buruk, tapi kita bisa berbuat lebih baik. <br><br><h3>  Langkah 5. iptab DROP dalam PREROUTING </h3><br>  Teknik yang lebih cepat adalah dengan menjatuhkan paket sebelum routing menggunakan aturan ini: <br><br><pre> <code class="bash hljs">iptables -I PREROUTING -t raw -d 198.18.0.12 -p udp --dport 1234 -j DROP</code> </pre> <br>  Ini memungkinkan kita untuk menjatuhkan paket besar 1,688 juta per detik. <br><br>  Sebenarnya, ini adalah lompatan yang sedikit mengejutkan dalam kinerja.  Saya masih tidak mengerti alasannya, mungkin rute kami rumit, atau mungkin hanya bug dalam konfigurasi server. <br><br>  Bagaimanapun, iptables mentah jauh lebih cepat. <br><br><h3>  Langkah 6. DROP nftables </h3><br>  Utilitas iptables sekarang agak lama.  Dia digantikan oleh nftables.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjelasan video ini tentang</a> mengapa nftables di atas.  Nftables menjanjikan lebih cepat dari iptables yang mulai memutih karena berbagai alasan, termasuk rumor bahwa retpoline banyak memperlambat iptables. <br><br>  Tetapi artikel kami masih bukan tentang membandingkan iptables dan nftables, jadi mari kita coba yang tercepat yang bisa saya lakukan: <br><br><pre> <code class="bash hljs">nft add table netdev filter nft -- add chain netdev filter input { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> filter hook ingress device vlan100 priority -500 \; policy accept \; } nft add rule netdev filter input ip daddr 198.18.0.0/24 udp dport 1234 counter drop nft add rule netdev filter input ip6 daddr fd00::/64 udp dport 1234 counter drop</code> </pre><br>  Penghitung dapat dilihat seperti ini: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'nft --handle list chain netdev filter input'</span></span> table netdev filter { chain input { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> filter hook ingress device vlan100 priority -500; policy accept; ip daddr 198.18.0.0/24 udp dport 1234 counter packets 1.6m/s bytes 69.6m/s drop <span class="hljs-comment"><span class="hljs-comment"># handle 2 ip6 daddr fd00::/64 udp dport 1234 counter packets 0 bytes 0 drop # handle 3 } }</span></span></code> </pre><br>  Pengait input nftables menunjukkan nilai sekitar 1,53 juta paket.  Ini sedikit kurang dari rantai PREROUTING di iptables.  Tetapi ada sebuah misteri dalam hal ini: secara teoritis, kait nftables berjalan lebih awal dari iptables PREROUTING dan, karenanya, harus diproses lebih cepat. <br><br>  Dalam pengujian kami, nftables sedikit lebih lambat dari iptables, tetapi nftables lebih dingin.  : P <br><br><h3>  Langkah 7. tc DROP </h3><br>  Agak tak terduga, kait tc (traffic control) terjadi lebih awal dari iptables PREROUTING.  tc memungkinkan kita untuk memilih paket sesuai dengan kriteria sederhana dan, tentu saja, menjatuhkannya.  Sintaksnya agak tidak biasa, jadi sebaiknya gunakan <a href="">skrip ini</a> untuk konfigurasi.  Dan kita membutuhkan aturan yang agak rumit yang terlihat seperti ini: <br><br><pre> <code class="bash hljs">tc qdisc add dev vlan100 ingress tc filter add dev vlan100 parent ffff: prio 4 protocol ip u32 match ip protocol 17 0xff match ip dport 1234 0xffff match ip dst 198.18.0.0/24 flowid 1:1 action drop tc filter add dev vlan100 parent ffff: protocol ipv6 u32 match ip6 dport 1234 0xffff match ip6 dst fd00::/64 flowid 1:1 action drop</code> </pre><br>  Dan kita dapat memeriksanya dalam aksi: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'tc -s filter show dev vlan100 ingress'</span></span> filter parent ffff: protocol ip pref 4 u32 filter parent ffff: protocol ip pref 4 u32 fh 800: ht divisor 1 filter parent ffff: protocol ip pref 4 u32 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1 (rule hit 1.8m/s success 1.8m/s) match 00110000/00ff0000 at 8 (success 1.8m/s ) match 000004d2/0000ffff at 20 (success 1.8m/s ) match c612000c/ffffffff at 16 (success 1.8m/s ) action order 1: gact action drop random <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> none pass val 0 index 1 ref 1 <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> 1 installed 1.0/s sec Action statistics: Sent 79.7m/s bytes 1.8m/s pkt (dropped 1.8m/s, overlimits 0 requeues 0)</code> </pre><br>  Hook tc memungkinkan kami untuk menjatuhkan hingga 1,8 juta paket per detik pada satu inti.  Ini bagus! <br>  Tapi kita bisa melakukannya lebih cepat ... <br><br><h3>  Langkah 8. XDP_DROP </h3><br>  Dan akhirnya, senjata terkuat kami: XDP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eXpress Data Path</a> .  Menggunakan XDP, kita dapat menjalankan kode Berkley Packet Filter (eBPF) yang diperluas secara langsung dalam konteks driver jaringan dan, yang paling penting, bahkan sebelum mengalokasikan memori untuk <code>skbuff</code> , yang menjanjikan kita peningkatan kecepatan. <br><br>  Biasanya, proyek XDP terdiri dari dua bagian: <br><br><ul><li>  kode eBPF yang dapat diunduh </li><li>  bootloader yang menempatkan kode di antarmuka jaringan yang benar </li></ul><br>  Menulis bootloader Anda adalah tugas yang sulit, jadi gunakan saja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chip iproute2 baru</a> dan muat kode dengan perintah sederhana: <br><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev ext0 xdp obj xdp-drop-ebpf.o</code> </pre><br>  Dam Ta! <br><br>  Kode sumber untuk <a href="">program eBPF yang dapat diunduh tersedia di sini</a> .  Program melihat karakteristik paket IP seperti protokol UDP, subnet pengirim, dan port tujuan: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h_proto == htons(<span class="hljs-type"><span class="hljs-type">ETH_P_IP</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iph-&gt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPPROTO_UDP</span></span></span><span class="hljs-class"> &amp;&amp; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">htonl</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iph</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">daddr</span></span></span><span class="hljs-class">) &amp; 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xFFFFFF00</span></span></span><span class="hljs-class">) == 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xC6120000</span></span></span><span class="hljs-class"> // 198.18.0.0/24 &amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udph</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dest</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">htons</span></span></span><span class="hljs-class">(1234)) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">XDP_DROP</span></span>; } }</code> </pre><br>  Program XDP harus dibangun menggunakan dentang modern, yang dapat menghasilkan bytecode BPF.  Setelah itu, kami dapat mengunduh dan menguji fungsionalitas program BFP: <br><br><pre> <code class="bash hljs">$ ip link show dev ext0 4: ext0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc fq state UP mode DEFAULT group default qlen 1000 link/ether 24:8a:07:8a:59:8e brd ff:ff:ff:ff:ff:ff prog/xdp id 5 tag aedc195cc0471f51 jited</code> </pre><br>  Dan kemudian lihat statistik di <code>ethtool</code> : <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'ethtool -S ext0|egrep "rx"|egrep -v ": 0"|egrep -v "cache|csum"'</span></span> rx_out_of_buffer: 4.4m/s rx_xdp_drop: 10.1m/s rx2_xdp_drop: 10.1m/s</code> </pre><br>  Yoo hoo!  Dengan XDP, kita dapat menjatuhkan hingga 10 juta paket per detik! <br><br><img src="https://habrastorage.org/webt/fq/mf/e5/fqmfe5jgs1qylz7fpwryoeey0ag.png"><br>  <i>Foto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andrew Filer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CC BY-SA 2.0</a></i> <br><br><h3>  Kesimpulan </h3><br>  Kami mengulangi percobaan untuk IPv4 dan IPv6 dan menyiapkan diagram ini: <br><br><img src="https://habrastorage.org/webt/dl/sc/qa/dlscqatdfii2rihttytjnfvtfea.png"><br>  Secara umum, dapat dikatakan bahwa pengaturan kami untuk IPv6 sedikit lebih lambat.  Tetapi karena paket IPv6 agak lebih besar, perbedaan dalam kecepatan diharapkan. <br><br>  Linux memiliki banyak cara untuk memfilter paket, masing-masing dengan kecepatan dan kompleksitasnya sendiri. <br><br>  Untuk melindungi dari DDoS, cukup masuk akal untuk memberikan paket ke aplikasi dan memprosesnya di sana.  Aplikasi yang disesuaikan dengan baik dapat menunjukkan hasil yang baik. <br><br>  Untuk serangan DDoS dengan IP acak atau spoof mungkin berguna untuk menonaktifkan conntrack untuk mendapatkan peningkatan kecil dalam kecepatan, tetapi berhati-hatilah: ada serangan terhadap yang conntrack sangat berguna. <br><br>  Dalam kasus lain, masuk akal untuk menambahkan firewall Linux sebagai salah satu cara untuk mengurangi serangan DDoS.  Dalam beberapa kasus, lebih baik menggunakan tabel "-t raw PREROUTING", karena jauh lebih cepat daripada tabel filter. <br><br>  Untuk kasus yang paling canggih, kami selalu menggunakan XDP.  Dan ya, ini adalah hal yang sangat kuat.  Berikut ini adalah grafik seperti di atas, hanya dengan XDP: <br><br><img src="https://habrastorage.org/webt/o4/un/dm/o4undm-syfgavdxop6izkvpckyk.png"><br>  Jika Anda ingin mengulang percobaan, ini adalah <a href="">README, tempat kami mendokumentasikan semuanya</a> . <br><br>  Kami di CloudFlare menggunakan ... hampir semua teknik ini.  Beberapa trik dalam ruang pengguna terintegrasi ke dalam aplikasi kami.  Teknik iptables ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gatebot</a> kami.  Akhirnya, kami mengganti solusi inti kami sendiri dengan XDP. <br><br>  Terima kasih banyak kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jesper Dangaard Brouer</a> atas bantuan mereka. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419921/">https://habr.com/ru/post/id419921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419911/index.html">Membangun orbit benda langit menggunakan Python</a></li>
<li><a href="../id419913/index.html">IKEA dan rumah pintar. Bagian 2</a></li>
<li><a href="../id419915/index.html">Bonding dan server SSH di initramfs</a></li>
<li><a href="../id419917/index.html">Neural networks: implementasi tugas tentang jamur pada Tensor Flow dan Python</a></li>
<li><a href="../id419919/index.html">Kontrol versi di dalam SQL Server</a></li>
<li><a href="../id419923/index.html">Pekerjaan sementara saya, jam tangan motherboard</a></li>
<li><a href="../id419925/index.html">Kontrol versi file individual menggunakan GitHub Gist</a></li>
<li><a href="../id419927/index.html">[DotNetBook] Pengecualian: Jenis Arsitektur Sistem</a></li>
<li><a href="../id419929/index.html">[DotNetBook] Acara pengecualian dan cara mendapatkan StackOverflow dan ExecutionEngineException dari awal</a></li>
<li><a href="../id419931/index.html">[DotNetBook] Saatnya menghibur cerita: situasi yang sangat luar biasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>