<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêµ ü§¶üèΩ üéΩ BuatRemoteThread untuk Linux üôÖüèΩ ‚è∫Ô∏è üéá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WinAPI memiliki fungsi CreateRemoteThread yang memungkinkan Anda untuk memulai utas baru di ruang alamat proses lain. Ini dapat digunakan untuk berbag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BuatRemoteThread untuk Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473740/"><p><img src="https://habrastorage.org/webt/qu/fi/43/qufi43ym9g9-ptbmm43ajv-e_-4.jpeg" width="300" align="right" alt="Mitsuha membawa aliran baru">  WinAPI memiliki fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">CreateRemoteThread</a> yang memungkinkan Anda untuk memulai utas baru di ruang alamat proses lain.  Ini dapat digunakan untuk berbagai injeksi DLL, baik untuk tujuan buruk (menipu dalam game, pencurian kata sandi, dll.), Dan untuk memperbaiki bug dalam program yang sedang berjalan saat itu juga, atau menambahkan plugin ke tempat-tempat yang tidak disediakan. </p><br><p>  Secara umum, fungsi ini memiliki utilitas aplikasi yang meragukan, oleh karena itu tidak mengherankan bahwa Linux tidak memiliki analog CreateRemoteThread yang sudah jadi.  Namun, saya bertanya-tanya bagaimana itu bisa diterapkan.  Mempelajari topik itu berubah menjadi petualangan yang baik. </p><br><p>  Saya akan berbicara secara rinci tentang bagaimana, dengan bantuan spesifikasi ELF, beberapa pengetahuan tentang arsitektur x86_64 dan panggilan sistem Linux, menulis sepotong kecil debugger Anda sendiri yang dapat memuat dan mengeksekusi kode arbitrer dalam proses yang sudah berjalan dan bekerja. </p><br><p>  Memahami teks akan membutuhkan pengetahuan dasar tentang pemrograman sistem untuk Linux: bahasa C, menulis dan debugging program di atasnya, pemahaman tentang peran kode mesin dan memori di komputer, konsep panggilan sistem, keakraban dengan perpustakaan utama, dan membaca dokumentasi. </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ide utama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sketsa solusi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Langkah 1. Koneksi ke proses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Langkah 2. Cari perpustakaan di memori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Langkah 3. Parsing gambar perpustakaan ELF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Langkah 4. Menerapkan shellcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Langkah 5. Memulai utas baru</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ul><br><p>  Hasilnya, saya dapat "menambahkan" kemampuan untuk mempratinjau kata sandi di Pusat Kontrol Gnome: </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="demonstrasi injeksi di Pusat Kontrol Gnome"></p><br><h2 id="osnovnye-idei">  Ide utama </h2><br><p>  Jika tidak ada klausa dalam persyaratan tentang memuat kode ke dalam proses yang sudah berjalan, maka solusinya akan sangat sederhana: LD_PRELOAD.  Variabel lingkungan ini memungkinkan memuat pustaka sewenang-wenang dengan aplikasi.  Di pustaka bersama, Anda bisa menentukan <em>fungsi konstruktor</em> yang dijalankan saat pustaka memuat. </p><br><p>  Bersama-sama, LD_PRELOAD dan konstruktor memungkinkan kode arbitrer untuk dieksekusi dalam proses apa pun menggunakan loader dinamis.  Ini adalah fitur yang relatif terkenal yang sering digunakan untuk debugging.  Misalnya, Anda dapat mengunduh perpustakaan Anda sendiri dengan aplikasi, yang mendefinisikan fungsi malloc () dan free (), yang dapat membantu menangkap kebocoran memori. </p><br><p>  Sayangnya, LD_PRELOAD hanya berfungsi saat proses dimulai.  Itu tidak bisa digunakan untuk memuat perpustakaan ke dalam proses yang sudah berjalan.  Ada fungsi dlopen () untuk memuat pustaka saat proses sedang berjalan, tetapi jelas proses itu sendiri harus memanggilnya untuk memuat plugin. </p><br><blockquote> <strong>Tentang executable statis</strong> <br><br>  LD_PRELOAD hanya berfungsi dengan program yang menggunakan pemuat dinamis.  Jika program dibangun dengan sakelar <code>-static</code> , maka ia menyertakan semua pustaka yang diperlukan.  Dalam hal ini, resolusi dependensi di perpustakaan dilakukan pada waktu pembangunan dan program biasanya tidak siap dan tidak dapat memuat perpustakaan secara dinamis setelah perakitan, pada waktu berjalan. <br><br>  Dalam program yang dirakit secara statis, Anda dapat menyuntikkan kode saat runtime, tetapi ini harus dilakukan dengan cara yang sedikit berbeda.  Dan ini tidak sepenuhnya aman, karena program mungkin tidak siap untuk belokan seperti itu. </blockquote><p>  Secara umum, tidak ada solusi nyaman yang siap pakai, Anda harus menulis sepeda Anda.  Kalau tidak, Anda tidak akan membaca teks ini :) </p><br><p>  Secara konseptual, untuk memaksa proses orang lain menjalankan beberapa jenis kode, Anda perlu melakukan tindakan berikut: </p><br><ol><li>  Dapatkan kontrol dalam proses target. </li><li>  Muat kode ke dalam memori proses target. </li><li>  Siapkan kode yang diunduh untuk dieksekusi dalam proses target. </li><li>  Atur eksekusi kode yang diunduh dengan proses target. </li></ol><br><p>  Ayo pergi ... </p><br><h3 id="poluchenie-upravleniya-v-processe">  Mendapatkan kontrol dalam proses </h3><br><p>  Pertama-tama, kita perlu mensubordinasikan proses target sesuai keinginan kita.  Lagi pula, biasanya proses hanya mengeksekusi kode mereka sendiri, atau kode pustaka yang dimuat, atau hasil kompilasi JIT.  Tapi yang pasti bukan kode kita. </p><br><p>  Salah satu opsi adalah menggunakan semacam kerentanan dalam proses yang memungkinkan Anda mengambil kendali.  Contoh klasik dari tutorial: buffer overflow, memungkinkan untuk menulis ulang alamat pengirim di stack.  Ini menyenangkan, kadang-kadang bahkan berhasil, tetapi tidak cocok untuk kasus umum. </p><br><p>  Kami akan menggunakan cara lain yang jujur ‚Äã‚Äãuntuk mendapatkan kendali: <em>men-debug panggilan sistem</em> .  Debuger interaktif dapat dengan sempurna menghentikan proses pihak ketiga, mengevaluasi ekspresi, dan banyak hal lainnya.  Mereka bisa - kita bisa. </p><br><p>  Di Linux, panggilan sistem debugging utama adalah <strong>ptrace ()</strong> .  Ini memungkinkan Anda untuk terhubung ke proses, memeriksa status mereka, dan mengontrol kemajuan eksekusi mereka.  ptrace () didokumentasikan dengan cukup baik, tetapi rincian penggunaannya hanya jelas dalam praktiknya. </p><br><h3 id="zagruzka-koda-v-pamyat-processa">  Memuat kode ke dalam memori proses </h3><br><p>  Dalam kasus buffer overflows, payload ( <em>kode shell</em> ) biasanya termasuk dalam konten yang meluap buffer yang sama.  Saat menggunakan debugger, kode yang diperlukan dapat ditulis ke memori proses secara langsung.  Di WinAPI ada fungsi khusus WriteProcessMemory untuk ini.  Linux untuk tujuan ini sesuai dengan cara UNIX: untuk setiap proses dalam sistem terdapat file <strong>/ proc / $ pid / mem</strong> , yang menampilkan memori dari proses ini.  Dimungkinkan untuk menulis sesuatu ke memori proses menggunakan input-output yang biasa. </p><br><h3 id="podgotovka-koda-k-ispolneniyu">  Mempersiapkan kode untuk dieksekusi </h3><br><p>  Menulis kode saja ke dalam memori tidak cukup.  Masih perlu ditulis <em>ke memori yang dapat dieksekusi</em> .  Dalam hal merekam melalui kerentanan, ada kesulitan non-sepele dengan ini, tetapi karena kita dapat sepenuhnya mengontrol proses target, itu tidak akan menjadi masalah bagi kita untuk menemukan atau mengalokasikan memori "yang benar" untuk diri kita sendiri. </p><br><p>  Poin penting persiapan lainnya adalah kode shell itu sendiri.  Di dalamnya, kita mungkin ingin menggunakan beberapa fungsi dari perpustakaan, seperti input-output, primitif grafik, dan sebagainya.  Namun, kita harus menuliskan kode mesin telanjang, yang dengan sendirinya tidak tahu tentang alamat semua fungsi keren ini di perpustakaan.  Dari mana Anda mendapatkannya? </p><br><p>  Untuk menyederhanakan masa pakai sistem operasi dan menyulitkan masa pakai kode jahat, perpustakaan biasanya tidak menggunakan alamat tetap (dan berisi apa yang disebut <em>kode posisi-independen</em> ).  Jadi alamat tidak bisa ditebak. </p><br><p>  Ketika proses dimulai secara normal, <em>loader</em> yang melakukan <em>relokasi</em> bertanggung jawab untuk menentukan alamat perpustakaan yang tepat.  Namun, ia memenuhi hanya sekali di awal.  Jika proses memungkinkan pemuatan dinamis perpustakaan, maka ada <em>pemuat dinamis</em> di dalamnya yang dapat melakukan hal yang sama saat proses sedang berjalan.  Namun, alamat loader dinamis juga tidak diperbaiki. </p><br><p>  Secara umum, dengan perpustakaan, ada empat opsi: </p><br><ul><li>  jangan gunakan pustaka sama sekali, lakukan segalanya pada panggilan sistem yang bersih </li><li>  letakkan salinan semua perpustakaan yang diperlukan ke dalam kode shell </li><li>  kerjakan sendiri loader dinamis </li><li>  temukan bootloader yang dinamis dan buat itu memuat perpustakaan kami </li></ul><br><p>  Kami akan memilih yang terakhir, karena kami ingin perpustakaan, dan menulis bootloader penuh kami untuk waktu yang lama.  Ini bukan metode yang paling rahasia, dan bukan yang paling menarik, tetapi yang paling sederhana, kuat dan dapat diandalkan. </p><br><h3 id="peredacha-upravleniya-kodu">  Transfer kendali ke kode </h3><br><p>  ptrace () memungkinkan Anda untuk mengubah register prosesor, jadi seharusnya tidak ada masalah dengan mentransfer kontrol ke kode yang dimuat dan disiapkan: cukup tulis alamat kode kami di register% rip - dan voila!  Namun, pada kenyataannya, semuanya tidak sesederhana itu.  Kesulitan terhubung dengan fakta bahwa proses debug sebenarnya belum hilang dan juga memiliki beberapa jenis kode yang telah dieksekusi dan akan terus dieksekusi. </p><br><h2 id="eskiz-resheniya">  Sketsa solusi </h2><br><p>  Total, kami akan menerapkan aliran kami dalam proses pihak ketiga sebagai berikut: </p><br><ol><li>  Kami terhubung ke proses target untuk debugging. </li><li>  Kami menemukan perpustakaan yang diperlukan dalam memori: <br><ul><li>  libdl - untuk memuat perpustakaan baru </li><li>  libpthread - untuk memulai utas baru </li></ul></li><li>  Kami menemukan fungsi yang diperlukan di perpustakaan: <br><ul><li>  libdl: dlopen (), dlsym () </li><li>  libpthread: pthread_create (), pthread_detach () </li></ul></li><li><p>  Kami memperkenalkan kode shell ke dalam memori proses target: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *entry = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br></li><li>  Kami memberikan kode shell yang harus dipenuhi. </li></ol><br><p>  Sebagai hasilnya, perpustakaan akan melakukan hal yang benar untuk kita: mereka akan memuat perpustakaan kita dengan kode yang kita butuhkan dalam memori dan memulai utas baru yang mengeksekusi kode ini. </p><br><h3 id="ogranicheniya">  Keterbatasan </h3><br><p>  Pendekatan yang dijelaskan di atas memberikan batasan tertentu: </p><br><ul><li>  Bootloader harus memiliki hak yang memadai untuk men-debug proses target. </li><li>  Prosesnya harus menggunakan libdl (siap untuk memuat modul secara dinamis). </li><li>  Prosesnya harus menggunakan libpthread (siap untuk multithreading). </li><li>  Aplikasi statis tidak didukung. </li></ul><br><p>  Selain itu, saya pribadi terlalu malas untuk repot dengan dukungan semua arsitektur, jadi kami akan membatasi diri hingga x86_64.  (Bahkan x86 32-bit akan lebih rumit.) </p><br><p>  Seperti yang Anda lihat, semua ini mengakhiri penggunaan rahasia dengan target jahat.  Namun, tugas tersebut masih mempertahankan minat penelitian dan bahkan menyisakan peluang yang lemah untuk penggunaan industri. </p><br><h3 id="otstuplenie-ob-ispolzovanii-libdl-i-libpthread">  Digression: tentang menggunakan libdl dan libpthread </h3><br><p>  Pembaca-pembaca berpengalaman mungkin bertanya-tanya: mengapa memerlukan libdl jika __libc_dlopen_mode () dan __libc_dlsym () fungsi internal sudah dibangun ke dalam glibc, dan libdl hanya membungkus mereka?  Demikian pula, mengapa perlu libpthread jika utas baru dapat dengan mudah dibuat menggunakan panggilan sistem clone ()? </p><br><p>  Memang, di Internet ada jauh dari satu contoh bagaimana mereka digunakan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://github.com/gaffe23/linux-inject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://github.com/TsarFox/hypodermic</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://hick.org/code/skape/papers/needle.txt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://github.com/ice799/injectso64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://www.ouah.org/subversiveld.pdf</a> </li></ul><br><p>  Mereka bahkan disebutkan dalam literatur hacker populer: </p><br><ul><li>  Belajar Analisis Biner Linux </li><li>  Seni forensik memori </li></ul><br><p>  Jadi mengapa tidak?  Yah, setidaknya karena kami tidak menulis kode berbahaya di mana solusi cocok yang menghilangkan 90% dari pemeriksaan, memakan ruang 20 kali lebih sedikit, tetapi juga berfungsi dalam 80% kasus.  Selain itu, saya ingin mencoba semuanya dengan tangan saya sendiri. </p><br><p>  Memang, libdl tidak <em>perlu</em> memuat perpustakaan dalam kasus glibc.  Penggunaannya oleh proses menunjukkan bahwa itu jelas siap untuk memuat kode dinamis.  Meskipun demikian, pada prinsipnya, Anda dapat menolak untuk menggunakan libdl (mengingat bahwa kita masih perlu mencari glibc nanti juga). </p><br><blockquote>  <strong>Kenapa dlopen () di dalam glibc sama sekali?</strong> <br><br>  Ini pertanyaan yang menarik dengan caranya sendiri.  Jawaban singkat: detail implementasi. <br><br>  Intinya adalah <em>saklar layanan nama</em> (NSS) - salah satu bagian dari glibc yang menyediakan terjemahan berbagai nama: nama mesin, protokol, pengguna, server mail, dll. Dialah yang bertanggung jawab untuk fungsi seperti getaddrinfo () untuk mendapatkan alamat IP dengan nama domain dan getpwuid () untuk mendapatkan informasi tentang pengguna dengan pengenal numeriknya. <br><br>  NSS memiliki arsitektur modular dan memuat modul secara dinamis.  Sebenarnya, untuk ini, glibc juga membutuhkan mekanisme untuk memuat perpustakaan secara dinamis.  Itulah sebabnya ketika Anda mencoba menggunakan getaddrinfo () dalam aplikasi yang dirakit secara statis, linker mencetak peringatan yang "tidak bisa dipahami": <br><pre>
 /tmp/build/socket.o: Dalam fungsi `Socket :: bind ':
 socket.o :(. teks + 0x374): peringatan: Menggunakan 'getaddrinfo' di ditautkan secara statis
 aplikasi membutuhkan saat runtime perpustakaan bersama dari versi glibc
 digunakan untuk menghubungkan
</pre><br></blockquote><p>  Adapun utas, utas biasanya tidak hanya tumpukan dan kode yang dapat dieksekusi, tetapi juga data global yang disimpan dalam <em>penyimpanan utas-lokal</em> (TLS).  Inisialisasi yang benar dari utas baru membutuhkan operasi terkoordinasi dari kernel OS, pemuat kode biner, dan runtime bahasa pemrograman.  Oleh karena itu, panggilan sederhana untuk mengkloning () sudah cukup untuk membuat aliran yang dapat menulis ke file ‚ÄúHello world!‚Äù, Tetapi ini mungkin tidak berfungsi untuk kode yang lebih kompleks yang memerlukan akses ke TLS dan hal-hal menarik lainnya yang tersembunyi dari mata programmer aplikasi. </p><br><p>  Poin lain yang terkait dengan multithreading adalah proses single-threaded.  Apa yang terjadi jika kita membuat utas baru dalam proses yang tidak dipahami sebagai multithreaded?  Perilaku yang benar dan tidak jelas.  Memang, dalam proses tersebut tidak ada sinkronisasi kerja antara utas, yang cepat atau lambat akan menyebabkan korupsi data.  Jika kami menuntut agar aplikasi menggunakan libpthread, maka kami dapat memastikan bahwa aplikasi tersebut siap untuk bekerja di lingkungan multi-utas (setidaknya harus siap). </p><br><h2 id="shag-1-podklyuchenie-k-processu">  Langkah 1. Koneksi ke proses </h2><br><p>  Pertama, kita perlu terhubung ke proses target untuk debugging, dan kemudian, putuskan dari sana kembali.  Di sinilah panggilan sistem <em>ptrace</em> () masuk </p><br><h3 id="pervyy-kontakt-s-ptrace">  Kontak pertama dengan ptrace () </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Dalam dokumentasi untuk ptrace ()</a> Anda dapat menemukan hampir semua informasi yang diperlukan: </p><br><pre>   Melampirkan dan melepaskan
        Utas dapat dilampirkan ke pelacak menggunakan panggilan<font></font>
<font></font>
            ptrace (PTRACE_ATTACH, pid, 0, 0);<font></font>
<font></font>
        atau<font></font>
<font></font>
            ptrace (PTRACE_SEIZE, pid, 0, PTRACE_O_flags);<font></font>
<font></font>
        PTRACE_ATTACH mengirim SIGSTOP ke utas ini.  Jika pelacak menginginkan ini
        SIGSTOP tidak memiliki efek, perlu menekannya.  Perhatikan bahwa jika
        sinyal lain secara bersamaan dikirim ke utas ini selama pemasangan, the
        pelacak dapat melihat jejak memasuki penghentian pengiriman sinyal dengan sinyal lain
        nal (s) pertama!  Praktik yang biasa dilakukan adalah memasukkan kembali sinyal-sinyal ini sampai
        SIGSTOP terlihat, kemudian menekan injeksi SIGSTOP.  Bug desain
        di sini adalah bahwa ptrace melampirkan dan SIGSTOP yang dikirimkan secara bersamaan dapat
        ras dan SIGSTOP bersamaan dapat hilang.
</pre><br><p>  Jadi langkah pertama adalah menggunakan PTRACE_ATTACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_ATTACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Setelah ptrace (), proses target tidak cukup siap untuk debugging.  Kami terhubung ke sana, tetapi untuk studi interaktif dari keadaan proses, itu harus dihentikan.  ptrace () mengirimkan sinyal SIGSTOP ke proses, tetapi kita masih harus menunggu sampai proses tersebut benar-benar berhenti. </p><br><p>  Untuk menunggu, gunakan panggilan sistem <em>waitpid</em> ().  Pada saat yang sama, beberapa kasus batas yang menarik patut dicatat.  Pertama, proses tersebut dapat berakhir atau mati tanpa menerima SIGSTOP.  Dalam hal ini, kita tidak bisa berbuat apa-apa.  Kedua, beberapa sinyal lain mungkin sebelumnya dikirim ke proses.  Dalam hal ini, kita harus membiarkan proses memprosesnya (menggunakan PTRACE_CONT), dan diri kita sendiri, terus menunggu lebih lanjut untuk SIGSTOP kami: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expected_signal)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,    -  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      ‚Äî   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSIGNALED(status) || WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status)) { <span class="hljs-comment"><span class="hljs-comment">/* *  WSTOPSIG()   , *   ptrace()   *     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stop_signal = status &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stop_signal == expected_signal) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, stop_signal) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*   ‚Äî   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="otklyuchenie-ot-processa">  Proses pemutusan </h3><br><p>  Menghentikan proses debugging jauh lebih sederhana: cukup gunakan PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Sebenarnya, menonaktifkan debugger secara eksplisit tidak selalu diperlukan.  Ketika proses debugger berakhir, secara otomatis terputus dari semua proses debug, dan proses dilanjutkan jika mereka dihentikan oleh ptrace ().  Namun, jika proses debugged dihentikan secara eksplisit oleh debugger menggunakan sinyal SIGSTOP tanpa menggunakan ptrace (), itu tidak akan bangun tanpa sinyal SIGCONT atau PTRACE_DETACH yang sesuai.  Karena itu, lebih baik untuk memutuskan sambungan dari proses secara budaya. </p><br><h3 id="nastroyka-ptrace_scope">  Pengaturan Ptrace_scope </h3><br><p>  Debugger memiliki kontrol penuh atas proses yang sedang di-debug.  Jika ada yang bisa men-debug apa pun, apa yang akan menjadi perluasan untuk kode berbahaya!  Jelas bahwa debugging interaktif adalah kegiatan yang agak spesifik, biasanya hanya diperlukan untuk pengembang.  Selama operasi normal sistem, paling sering tidak perlu proses debug. </p><br><p>  Untuk alasan ini, karena alasan keamanan, sistem biasanya menonaktifkan kemampuan untuk men-debug proses apa pun secara default.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Modul keamanan <strong>Yama</strong></a> bertanggung jawab untuk ini, dikelola melalui file / proc / sys / kernel / yama / ptrace_scope.  Ini memberikan empat perilaku: </p><br><ul><li>  0 - pengguna dapat men-debug setiap proses yang ia mulai </li><li>  1 - mode default, hanya proses yang dimulai oleh debugger yang dapat di-debug </li><li>  2 - hanya administrator sistem root yang dapat men-debug proses </li><li>  3 - debugging dilarang untuk semua orang sama sekali, mode tidak mati sampai sistem reboot </li></ul><br><p>  Tentunya, untuk keperluan kami, akan perlu untuk dapat men-debug proses yang diluncurkan sebelum debugger kami, jadi untuk percobaan Anda perlu beralih sistem ke mode pengembangan dengan menulis 0 ke file ptrace_scope khusus (yang memerlukan hak administrator): </p><br><pre> <code class="plaintext hljs">$ sudo sh -c 'echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope'</code> </pre> <br><p>  atau jalankan debugger sebagai administrator: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread ...</code> </pre> <br><h3 id="rezultaty-pervogo-shaga">  Hasil langkah pertama </h3><br><p>  Sebagai hasilnya, pada langkah pertama, kami dapat terhubung ke proses target sebagai debugger dan kemudian memutusnya. </p><br><p>  Proses target akan dihentikan dan kami dapat memastikan bahwa sistem operasi benar-benar melihat kami sebagai debugger: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread --target $(pgrep docker) $ cat /proc/$(pgrep docker)/status | head Name: docker State: t (tracing stop) &lt;---    Tgid: 31330 Ngid: 0 Pid: 31330 PPid: 1 TracerPid: 2789 &lt;--- PID   Uid: 0 0 0 0 Gid: 0 0 0 0 FDSize: 64 $ ps a | grep [2]789 2789 pts/5 S+ 0:00 ./inject-thread --target 31330</code> </pre> <br><h2 id="shag-2-poisk-bibliotek-v-pamyati">  Langkah 2. Cari perpustakaan di memori </h2><br><p>  Langkah selanjutnya lebih sederhana: Anda perlu mencari di memori proses target perpustakaan dengan fungsi yang kita butuhkan.  Tetapi ada banyak memori, di mana mulai mencari dan apa sebenarnya? </p><br><h3 id="fayl-procpidmaps">  File / proc / $ pid / maps </h3><br><p>  Sebuah file khusus akan membantu kita dengan ini, di mana kernel memberi tahu tentang apa dan di mana proses tersebut berada dalam memori.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Seperti yang Anda ketahui</a> , di direktori / proc untuk setiap proses terdapat subdirektori.  Dan ada file di dalamnya yang menggambarkan proses <em>kartu memori</em> : </p><br><pre> $ cat / proc / self / maps
 00400000-0040c000 r-xp 00000000 fe: 01 1044592 / bin / cat
 0060b000-0060c000 r - p 0000b000 fe: 01 1044592 / bin / cat
 0060c000-0060d000 rw-p 0000c000 fe: 01 1044592 / bin / cat
 013d5000-013f6000 rw-p 00000000 00:00 0 [tumpukan]
 7f9920bd1000-7f9920d72000 r-xp 00000000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920d72000-7f9920f72000 --- p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f72000-7f9920f76000 r - p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f76000-7f9920f78000 rw-p 001a5000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7fc3f8381000-7fc3f8385000 rw-p 00000000 00:00 0
 7fc3f8385000-7fc3f83a6000 r-xp 00000000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f83ec000-7fc3f840e000 rw-p 00000000 00:00 0
 7fc3f840e000-7fc3f8597000 r - p 00000000 fe: 01 657286 / usr / lib / lokal / arsip-lokal
 7fc3f8597000-7fc3f859a000 rw-p 00000000 00:00 0
 7fc3f85a3000-7fc3f85a5000 rw-p 00000000 00:00 0
 7fc3f85a5000-7fc3f85a6000 r - p 00020000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a6000-7fc3f85a7000 rw-p 00021000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a7000-7fc3f85a8000 rw-p 00000000 00:00 0
 7ffdb6f0e000-7ffdb6f2f000 rw-p 00000000 00:00 0 [tumpukan]
 7ffdb6f7f000-7ffdb6f81000 r-xp 00000000 00:00 0 [vdso]
 7ffdb6f81000-7ffdb6f83000 r - p 00000000 00:00 0 [vvar]
 ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
</pre><br><p>  Isi file ini dihasilkan dengan cepat oleh kernel sistem operasi dari struktur internal yang menggambarkan wilayah memori dari proses yang menarik bagi kami, dan berisi informasi berikut: </p><br><ul><li>  rentang alamat yang dialokasikan untuk wilayah tersebut </li><li>  hak akses ke wilayah tersebut <br><ul><li>  <code>r/-</code> : baca </li><li>  <code>w/-</code> : tulis </li><li>  <code>x/-</code> : eksekusi </li><li>  <code>p/s</code> : berbagi memori dengan proses lain </li></ul></li><li>  offset file (jika ada) </li><li>  kode perangkat tempat file yang ditampilkan berada </li><li>  nomor inode file (jika ada) </li><li>  path ke file yang ditampilkan (jika ada) </li></ul><br><p>  Beberapa wilayah memori dipetakan ke file: ketika suatu proses membaca memori tersebut, itu sebenarnya membaca data dari file yang sesuai pada offset tertentu.  Jika Anda dapat menulis ke suatu wilayah, maka perubahan dalam memori dapat dilihat hanya oleh proses itu sendiri (mekanisme <em>copy-on-write</em> , mode <code>p</code> bersifat pribadi), atau disinkronkan dengan disk (mode <code>s</code> dibagikan). </p><br><p>  Wilayah lain <em>anonim</em> - memori ini tidak sesuai dengan file apa pun.  Sistem operasi hanya memberikan proses sepotong memori fisik yang digunakannya.  Daerah tersebut digunakan, misalnya, untuk memori proses "normal": stack dan heap.  Wilayah anonim dapat bersifat pribadi untuk suatu proses atau dibagi di antara beberapa proses (mekanisme <em>memori bersama</em> ). </p><br><p>  Selain itu, ada beberapa daerah khusus dalam memori yang ditandai dengan nama semu [vdso] dan [vsyscall].  Mereka digunakan untuk mengoptimalkan beberapa panggilan sistem. </p><br><p>  Kami tertarik pada wilayah tempat konten file perpustakaan ditampilkan.  Jika kita membaca kartu memori dan menyaring entri di dalamnya dengan nama file yang ditampilkan, maka kita akan menemukan semua alamat yang ditempati oleh perpustakaan yang kita butuhkan.  Format kartu memori secara khusus dibuat nyaman untuk pemrosesan program dan mudah dipahami menggunakan fungsi keluarga scanf (): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_proc_line</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_low = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_high = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> read = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> write = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> execute = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> path_offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    /proc/$pid/maps */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"%lx-%lx %c%c%c%*c %*lx %*x:%*x %*d %n"</span></span>, &amp;vaddr_low, &amp;vaddr_high, &amp;read, &amp;write, &amp;execute, &amp;path_offset); <span class="hljs-comment"><span class="hljs-comment">/* ,       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(line + path_offset, library)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region) { region-&gt;vaddr_low = vaddr_low; region-&gt;vaddr_high = vaddr_high; region-&gt;readable = (read == <span class="hljs-string"><span class="hljs-string">'r'</span></span>); region-&gt;writeable = (write == <span class="hljs-string"><span class="hljs-string">'w'</span></span>); region-&gt;executable = (execute == <span class="hljs-string"><span class="hljs-string">'x'</span></span>); region-&gt;content = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3 id="tayna-tretey-planety">    </h3><br><p>      ,  libc-2.19.so,     : </p><br><p><img src="https://habrastorage.org/webt/vf/lw/4m/vflw4m5jy3pwtbcxu0foudxnh3o.png" alt="  libc-2.19.so"></p><br><p>        2   -    ?  51?   ?  ? </p><br><p> ,    ,          . </p><br><p>  ,     <em></em>   ,         .  <em> </em>         ,    ,   ,           (, ,        ). </p><br><p>      ,  <em></em> (  4  ).    ,            . </p><br><p>  ,           .       ‚Äî    ‚Äî      .           2    ‚Äî   ,        ( x86_64    4 , 2 , 1 ).                  . </p><br><h3 id="rezultaty-vtorogo-shaga">    </h3><br><p>     ,          : </p><br><ul><li>  libdl: dlopen()  dlsym() </li><li>  libpthread: pthread_create()  pthread_detach() </li></ul><br><p>    ,       ,   .      Linux       ( <em>address space layout randomization</em> , ASLR).        (- ,     ),             ‚Äî    - . </p><br><p>       ,           ,      ,     /proc/$pid/maps.     ,          . </p><br><h2 id="shag-3-razbor-elf-obrazov-bibliotek">  3.  ELF-  </h2><br><p> ,      ,        ,   . </p><br><p>   : </p><br><pre> <code class="plaintext hljs">$ nm -D /lib/x86_64-linux-gnu/libdl-2.19.so | grep dlopen 0000000000001090 T dlopen</code> </pre> <br><p>  <em>nm</em>             .                . </p><br><p>   -  ,      nm     ,        .  ,      dlsym(). </p><br><h3 id="chtenie-pamyati-celevogo-processa">     </h3><br><p>   ‚Äî    ELF-,    .        procfs.    UNIX way,         <strong>/proc/$pid/mem</strong> ,    ‚Äî      (     /proc/$pid/maps). </p><br><p>   Linux           mmap(),         (    ,   ).            : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> offset = region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!buffer) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_close_file; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_region(fd, offset, buffer, length) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_free_buffer; region-&gt;content = buffer; close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error_free_buffer: <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); error_close_file: close(fd); error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">off_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, offset, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> remaining = length; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = buffer; <span class="hljs-comment"><span class="hljs-comment">/* *     .   , *      ,  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (remaining &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> count = read(fd, ptr, remaining); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; remaining -= count; ptr += count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>      ELF- .    , -,       ,  -,       . </p><br><h3 id="dvulikiy-elf">  ELF </h3><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">   ELF</a> ‚Äî         Linux.      ,    ,      . </p><br><p>      ELF   .    ELF    <em></em>    .    ‚Äî   <em></em> ,        .      ,  ‚Äî    .        ELF-. </p><br><p> ,   libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/at/zw/up/atzwupwipysw3kip1yx95aa-eps.png" alt="   libdl-2.19.so"></p><br><p> (          <code>readelf --headers</code> .) </p><br><p>   ,    ,   (29  9).    ‚Äî    ,           ,     .  ELF ‚Äî    ,      .  Linux, ,    LOAD,      (     ). </p><br><p>   ELF-     ,         . ,       . </p><br><p>       ,   . ¬´¬ª    .     .bss,   ,      (    ). </p><br><p>  ,   ELF     ‚Äî  ,     .       ... </p><br><h3 id="gde-lezhit-tablica-simvolov">    ? </h3><br><p>          ()   .        ,     dlsym(),       .  -   . </p><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"> ELF</a> (. 2-10).   ,        <strong>.dynamic</strong> ,     <strong>DYNAMIC</strong> .   .dynamic     ,  : </p><br><ul><li> <strong>.dynsym</strong> ‚Äî     ; </li><li> <strong>.dynstr</strong> ‚Äî     ; </li><li> <strong>.hash</strong> ‚Äî -,   . </li></ul><br><p>    ,     ,       ELF: </p><br><p><img src="https://habrastorage.org/webt/yw/y9/7d/ywy97dqzszhxz1jmoe45851oebe.png" alt="  DYNAMIC"></p><br><p>     ELF,      (1),      (2),      (3),      (4) <del>  ,    </del>  . </p><br><h4 id="zagolovok-elf--tablica-segmentov">  ELF ‚Üí   </h4><br><p> ()   ELF      &lt;elf.h&gt;, ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"> </a> .   ,  ELF ‚Äî      .    32-  64- ,      ,      ,   .          x86_64,    ELF  . </p><br><p>  ELF-    ( <strong>Elf64_Ehdr</strong> ).          ( <em>program headers</em> ),    <strong>e_phoff</strong>  <strong>e_phnum</strong> : </p><br><p><img src="https://habrastorage.org/webt/1z/al/rn/1zalrn30vwfxce_smmy4vylj55g.png" alt="Header ELF"></p><br><p>   ‚Äî    ,   ,  ELF-   ‚Äî     ,    ,     ,  ,    . </p><br><p>        e_phoff,       ,      .    e_phnum   e_phentsize  . </p><br><p>    (   ),        ELF ‚Äî    64 . </p><br><h4 id="tablica-segmentov--segment-dynamic">   ‚Üí  DYNAMIC </h4><br><p>      .   ‚Äî      <strong>Elf64_Phdr</strong> ( 64- ELF-),   .      <strong>PT_DYNAMIC</strong>   <strong>p_type</strong> : </p><br><p><img src="https://habrastorage.org/webt/i0/rg/cp/i0rgcpji9bl9wbsvegzrree9zfm.png" alt="Tabel segmen ELF"></p><br><p>          : </p><br><ul><li> <strong>p_vaddr</strong> ‚Äî   ,    ; </li><li> <strong>p_memsz</strong> ‚Äî      . </li></ul><br><p>     .dynamic      0x2D88 (     ).        DYNAMIC     ‚Äî   0x202D88.    0x210 (8448) .                . </p><br><h4 id="segment-dynamic--sekcii-dynsym-dynstr-hash">  DYNAMIC ‚Üí  .dynsym, .dynstr, .hash </h4><br><p>  .dynamic,    DYNAMIC,      .       <strong>Elf64_Dyn</strong> ,   : </p><br><p><img src="https://habrastorage.org/webt/dd/jp/th/ddjpthosvl8irw8ekelw0bdkaug.png" alt="Tag bagian DINAMIS"></p><br><p>    8     <strong>d_val</strong>  <strong>d_ptr</strong> ,   8-  <strong>d_tag</strong> ,  ,    .      : </p><br><ul><li> <strong>DT_HASH</strong> (4) ‚Äî    .hash ( d_ptr) </li><li> <strong>DT_STRTAB</strong> (5) ‚Äî    .dynstr ( d_ptr) </li><li> <strong>DT_SYMTAB</strong> (6) ‚Äî    .dynsym ( d_ptr) </li><li> <strong>DT_STRSZ</strong> (10) ‚Äî     .dynstr ( d_val) </li><li> <strong>DT_NULL</strong> (0) ‚Äî     </li></ul><br><p>       .     .dynamic     :  ,   ,    ,    . </p><br><p>    ,   DYNAMIC   <em></em>          ,    .      ,            ,  - ,   . </p><br><p>    .dynamic         ,          . -,   .dynstr   ,      ?     . </p><br><h3 id="poisk-funkciy-v-biblioteke">     </h3><br><p>            .     ,    <strong>.dynsym</strong>   ,        . (  ¬´¬ª   .symtab,      , ,  .    .) </p><br><h4 id="tablica-simvolov">   </h4><br><p>      <strong>Elf64_Sym</strong> ,        ELF ‚Äî , , , .       <code>dlopen</code> : </p><br><p><img src="https://habrastorage.org/webt/pd/5_/qh/pd5_qhcculmqmjk7p6krar1czjy.png" alt="Tabel karakter ELF"></p><br><p>      : </p><br><ul><li> <strong>st_name</strong> ‚Äî  ,       </li><li> <strong>st_info</strong> ‚Äî     (   ) </li><li> <strong>st_value</strong> ‚Äî     </li></ul><br><p> (  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  nm</a>   ,  dlopen()     .text,   0x1090   .) </p><br><p>     ,       . </p><br><h4 id="tablica-strok">   </h4><br><p>   ‚Äî     - ,    .            (   ).        <strong>.dynstr</strong> ,      libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/mg/b9/1v/mgb91vjtwrr_kqrncnrojgg6jum.png" alt="Tabel baris ELF"></p><br><p> ,           ( ¬´dlopen¬ª,   0xA5)      ,    .        . </p><br><h4 id="hesh-tablica"> - </h4><br><p>  <strong>.hash</strong>  <em>-</em> ,       .   - ‚Äî    ‚Äî      ELF-,       . ,         .dynsym,       ,      .   ( )     - . </p><br><p>  -      &lt;elf.h&gt;,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"> </a> (. 2-19).   -   ,   : </p><br><p><img src="https://habrastorage.org/webt/ez/a3/ku/eza3ku71zydhqm_e3je0xbtjec8.png" alt="tabel hash ELF"></p><br><p>  dimana </p><br><ul><li> nbuckets ‚Äî    buckets </li><li> nchains ‚Äî    chains (  ) </li><li> buckets ‚Äî      </li><li> chains ‚Äî      </li></ul><br><p>  -  : </p><br><ol><li>   <strong>h</strong>    . </li><li>   <strong>i</strong>  <code>buckets[h % nbuckets]</code> ,     . </li><li>      (     )  ,   . </li><li>    ‚Äî  <code>chains[i % nchains]</code> . </li><li>   3‚Äî4           ,       . </li></ol><br><p>  -,  ELF: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> h = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> g; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*name) { h = (h &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + *name++; g = h &amp; <span class="hljs-number"><span class="hljs-number">0xF0000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g) h ^= g &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; h &amp;= ~g; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h; }</code> </pre> <br><p> ,   <code>"dlopen"</code> -   112420542     : </p><br><p><img src="https://habrastorage.org/webt/zu/ch/4i/zuch4ibwuspxmog6_erhbq1evyg.png" alt="mencari karakter di perpustakaan"></p><br><p> libdl ‚Äî    ,    39   ,      .  -           . </p><br><h3 id="rezultaty-tretego-shaga">    </h3><br><p>              ,          : </p><br><ul><li> dlopen()  dlsym()   libdl </li><li> pthread_create()  pthread_detach()   libpthread </li></ul><br><p>   ,    . </p><br><p>         .            .      ,       . </p><br><p>     ELF-    .       ,      (  ).        ,    . ,    ,     .               . </p><br><h2 id="shag-4-vnedrenie-shell-koda">  4.  - </h2><br><p>   ,    ,    <em>-</em> ,     :         ,   .   -  . </p><br><h3 id="soderzhimoe-shell-koda">  - </h3><br><p> ,   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*entry)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br><p>       ? </p><br><p> ,        ‚Äî   .    ,     ,      ,       -  ‚Äî  -     !    . </p><br><p>    ‚Äî   -  .         ,    ,           :        . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* *      .rodata:   * .         , *        . */</span></span> .section .rodata <span class="hljs-comment"><span class="hljs-comment">/* *   .       . *      -:    ,  *  ,       . */</span></span> .global shellcode_start .global shellcode_address_dlopen .global shellcode_address_dlsym .global shellcode_address_pthread_create .global shellcode_address_pthread_detach .global shellcode_address_payload .global shellcode_address_entry .global shellcode_end <span class="hljs-comment"><span class="hljs-comment">/* *   dlopen().     #include &lt;dlfcn.h&gt;, *       . */</span></span> .set RTLD_LAZY, <span class="hljs-number"><span class="hljs-number">1</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_start: <span class="hljs-comment"><span class="hljs-comment">/* * void *payload = dlopen(shellcode_address_payload, RTLD_LAZY); * *        x86_64: * * -     %rdi, %rsi, %rdx, %rcx * -     %rax * -      * *         . * *       %rax,    *     . */</span></span> lea shellcode_address_payload(%rip),%rdi mov $RTLD_LAZY,%rsi mov shellcode_address_dlopen(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * void (*entry)(void) = dlsym(payload, shellcode_address_entry); */</span></span> mov %rax,%rdi lea shellcode_address_entry(%rip),%rsi mov shellcode_address_dlsym(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_t thread; * pthread_create(&amp;thread, NULL, entry, NULL); * *            * ,     pthread_create(). */</span></span> sub $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_detach(thread); * *    ,   ,  *     . */</span></span> mov (%rsp),%rdi add $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov shellcode_address_pthread_detach(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* *   - ‚Äî    ,     *      ret.    *     ,  *      . */</span></span> int $<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *       ,   *   ,    - *     .   ‚Äú  *  ‚Äù (global offset table, GOT),   *           . */</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlopen: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlsym: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_create: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_detach: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_payload: .space <span class="hljs-number"><span class="hljs-number">256</span></span> shellcode_address_entry: .space <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *  - . */</span></span> shellcode_end: .end</code> </pre> <br><p> ,   .      : </p><br><pre> <code class="plaintext hljs">$ as -o shellcode.o shellcode.S</code> </pre> <br><p>  ,      ,  ,   .            :   <em>  </em> (procedure linkage table, PLT),        . </p><br><p>     -    ,         (, )       .  <em>-</em>  <em></em> . </p><br><h3 id="razmeschenie-shell-koda-v-pamyati">  -   </h3><br><p>     <em>-</em>    . ,       ,   ,          .      ? </p><br><h4 id="trebovaniya-k-pamyati-pod-shell-kod">     - </h4><br><p>      ,       .      <em></em> ,       .    ,         .         ,       . </p><br><p>              (-  ),         :   ,    ,    . , ,   JIT-   ,       .    ? </p><br><h4 id="podhody-k-razmescheniyu-v-pamyati">      </h4><br><p>         : </p><br><ul><li>  -  ,     </li><li>   - ,    </li></ul><br><p>      ,  . -,    - ,     . -,       . -,      ,  -    -,     . </p><br><p>   ,      .     .  x86_64  <code>int $3</code>     ‚Äî 0xCC ‚Äî          .  ptrace()         PTRACE_POKETEXT ‚Äî ,     8   , . ,          ,     . </p><br><p> ,  ,   ,       :        .     -       ,  . </p><br><h4 id="kak-vydelit-novuyu-pamyat">    ? </h4><br><p>  ,  !    malloc()! </p><br><p> .      ,      -,    .       .          ,     mmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *shellcode_dst = mmap(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, shellcode_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); copy_shellcode(shellcode_dst, shellcode_src, shellcode_size); }</code> </pre> <br><p>  ,   ptrace()         ,     . </p><br><h3 id="vypolnenie-sistemnyh-vyzovov">    </h3><br><p>      ,     ?    ,            . Linux  x86_64   : </p><br><ul><li>       %rax </li><li>    ‚Äî    ‚Äî      %rsi, %rdi, %rdx, %r10, %r8, %r9 </li><li>   SYSCALL,     </li><li>       %rax </li></ul><br><p>  ptrace()           PTRACE_GETREGS  PTRACE_SETREGS.  ,        .   -   SYSCALL. </p><br><p>     :      ,       %rip.   ,   ,   SYSCALL. </p><br><h4 id="poisk-instrukcii-syscall">   SYSCALL </h4><br><p>    SYSCALL? ,    .   -   ,   <em>-</em>      .    ‚Äî   libc.  ,  ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_syscall_instruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct library *library)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; library-&gt;region_count; i++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory_region</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">region</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">library</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">regions</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(region-&gt;readable &amp;&amp; region-&gt;executable)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *region_data = region-&gt;content; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> region_size = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* * 0F 05 syscall */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; offset &lt; region_size - <span class="hljs-number"><span class="hljs-number">1</span></span>; offset++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_data[offset + <span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x0F</span></span> &amp;&amp; region_data[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0x05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> region-&gt;vaddr_low + offset; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>        , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  /proc/$pid/maps</a> .  x86_64     ,    -   .     <em></em>   ,    0x0F 0x05.     , ,  ARM,       0xDF 0x00 ( SVC #0),  <em>  </em> . </p><br><h4 id="ispolzovanie-ptrace_getsetregs">  PTRACE_{GET,SET}REGS </h4><br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_registers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct user_regs_struct *registers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_GETREGS, pid, registers, registers) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) err = -errno; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br><p>     <code>struct user_regs_struct</code> ,    &lt;sys/user.h&gt;.     .          .     ,        <em>varargs</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_regs_for_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct user_regs_struct *registers, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, va_list args)</span></span></span><span class="hljs-function"> </span></span>{ registers-&gt;rip = syscall_insn_vaddr; registers-&gt;rax = syscall_number; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; args_count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: registers-&gt;rdi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: registers-&gt;rsi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: registers-&gt;rdx = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: registers-&gt;r10 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: registers-&gt;r8 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: registers-&gt;r9 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -E2BIG; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">old_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *    ,   *      . */</span></span> get_registers(pid, &amp;old_registers); <span class="hljs-comment"><span class="hljs-comment">/* *      ,   * ,     . */</span></span> new_registers = old_registers; va_list args; va_start(args, args_count); set_regs_for_syscall(&amp;new_registers, syscall_insn_vaddr, syscall_number, args_count, args); va_end(args); set_registers(pid, &amp;new_registers); <span class="hljs-comment"><span class="hljs-comment">/* *    ,    *   ,    * (  ),    . *     . */</span></span> wait_for_syscall_completion(pid); <span class="hljs-comment"><span class="hljs-comment">/* *       *    . *        . */</span></span> get_registers(pid, &amp;new_registers); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = new_registers.rax; set_registers(pid, &amp;old_registers); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h4 id="ispolzovanie-ptrace_syscall">  PTRACE_SYSCALL </h4><br><p>       :        ,    ? </p><br><p>      PTRACE_SYSCALL.   PTRACE_CONT,     .   ,    - :    ,    . </p><br><p> PTRACE_SYSCALL    SIGTRAP    :      (     )       (      ).  , ptrace()   ,          ,         . </p><br><p>  ,           SIGTRAP: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_enter_exit_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_SYSCALL, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGTRAP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_completion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ wait_for_syscall_enter_exit_stop(pid); wait_for_syscall_enter_exit_stop(pid); }</code> </pre> <br><p>   ‚Äî   ,    ‚Äî       (wait_for_process_stop() <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ).           .       ,     . </p><br><h4 id="opciya-ptrace_o_tracesysgood">  PTRACE_O_TRACESYSGOOD </h4><br><p>   , PTRACE_SYSCALL      :       ,   ,  -  .  ,      SIGTRAP       (    ). </p><br><p>     SIGTRAP       <em></em> .        PTRACE_O_TRACESYSGOOD,            : </p><br><ul><li> SIGTRAP ‚Äî -     </li><li> SIGTRAP | 0x80 ‚Äî     </li></ul><br><pre> <code class="diff hljs"> int ptrace_attach(pid_t pid) { if (ptrace(PTRACE_ATTACH, pid, 0, 0) &lt; 0) return -1; if (wait_for_process_stop(pid, SIGSTOP) &lt; 0) return -1; + /*     */ + unsigned long options = PTRACE_O_TRACESYSGOOD; + if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) + return -1; return 0; } static int wait_for_syscall_enter_exit_stop(pid_t pid) { if (ptrace(PTRACE_SYSCALL, pid, 0, 0) &lt; 0) return -1; - if (wait_for_process_stop(pid, SIGTRAP) &lt; 0) + if (wait_for_process_stop(pid, SIGTRAP | 0x80) &lt; 0) return -1; return 0; }</code> </pre> <br><h3 id="zagruzka-shell-koda-v-pamyat">  -   </h3><br><p> -       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_text[SHELLCODE_TEXT_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shellcode_size = shellcode_end - shellcode_start; <span class="hljs-comment"><span class="hljs-comment">/*   ,  ,  . . */</span></span> prepare_shellcode(shellcode_text, shellcode_size); <span class="hljs-comment"><span class="hljs-comment">/*   -   */</span></span> write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); }</code> </pre> <br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   -</a>    :      dlopen(),               . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> offset = shellcode_addr - shellcode_start; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(shellcode_text + offset, data, length); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ copy_shellcode(shellcode_text, shellcode_start, shellcode_start, shellcode_size); copy_shellcode(shellcode_text, shellcode_address_dlopen, &amp;dlopen_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlopen_vaddr)); copy_shellcode(shellcode_text, shellcode_address_dlsym, &amp;dlsym_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlsym_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_create, &amp;pthread_create_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_create_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_detach, &amp;pthread_detach_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_detach_vaddr)); copy_shellcode(shellcode_text, shellcode_address_payload, payload, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(payload)); copy_shellcode(shellcode_text, shellcode_address_entry, entry, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(entry)); }</code> </pre> <br><p>     ,    ,      -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlopen[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlsym[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_create[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_detach[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_payload[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_entry[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_end[];</code> </pre> <br><p>      ,              . </p><br><p>    -        .         /proc/$pid/mem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_WRONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, vaddr, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = do_write_remote_memory(fd, data, size); close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> left = size; <span class="hljs-comment"><span class="hljs-comment">/* *    ,  ,     *   ,       *      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> wrote = write(fd, data, left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrote &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; data += wrote; left -= wrote; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-chetvyortogo-shaga">    </h3><br><p> ,             - ‚Äî ¬´ ¬ª .           .    - ,                . </p><br><h2 id="shag-5-zapusk-novogo-potoka">  5.    </h2><br><p>     -        .  ,    :    %rip  -,  PTRACE_SETREGS,  PTRACE_CONT    .     . </p><br><p> ,   ,    .      -?        ? </p><br><h3 id="pochemu-nuzhen-novyy-potok">     </h3><br><p>  ,    .    ,          ¬´ ¬ª  .  ,      .      : </p><br><ul><li>       </li><li>   (async-signal-safe)  </li></ul><br><p>      ‚Äî     . dlopen()  pthread_create()     .        -  dlopen(),      dlopen()  ? </p><br><p>        -, ,   ,       . ,     pthread_create()    .     ,       (     ).     clone(). </p><br><blockquote> <strong>  pthread_create()?</strong> <br><br>     ,  -     ,         ? <br><br> :          clone(). <br><br>          ,    (libc)    (pthread).   clone()       <em> </em> (thread control block, TCB)  <em> </em> (thread-local storage, TLS),        ,  . .     pthread_create()    ,    . <br><br>    ¬´¬ª,      clone()        libc  pthread.        ,    . </blockquote><br><h3 id="podgotovka-k-zapusku-potoka">     </h3><br><p>      clone()      : </p><br><ul><li>      ? </li><li>    ? </li><li>    -? </li></ul><br><h4 id="obrabotka-zaversheniya-potoka">    </h4><br><p>      :     -? </p><br><p>     ,  -       :   ,   ,       ,       . </p><br><p>        .  ,     ,        .  Bagaimana?  :     exit().          ,     . </p><br><p>         .     exit()   -: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+.set __NR_exit, 60 .set RTLD_LAZY, 1 @@ - /* - *  . - */ - int $3 + /* + * exit(0); + */ + xor %rdi,%rdi + mov $__NR_exit,%rax + syscall</span></span></code> </pre> <br><p>  :   exit() ‚Äî    exit()   .   exit()    <em></em> ,    exit()    ‚Äî <em> </em>   .    Linux     exit_group(). </p><br><h4 id="vydelenie-pamyati-pod-stek">     </h4><br><p>     .         .     ,      ,   PROT_EXEC: </p><br><pre> <code class="cpp hljs">shellcode_stack_vaddr = remote_mmap(target, syscall_vaddr, <span class="hljs-number"><span class="hljs-number">0</span></span>, SHELLCODE_STACK_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_STACK | MAP_GROWSDOWN, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>   ,   Linux  x86_64  <em> </em> ‚Äî  ¬´¬ª  ,     .  mmap()      ,   clone()     .  ,    mmap()  MAP_GROWSDOWN,       ,    . </p><br><h4 id="opciya-ptrace_o_traceclone">  PTRACE_O_TRACECLONE </h4><br><p>        .       ,   -   .         waitpid(),     :      ,          . </p><br><p>        ‚Äî   PTRACE_O_TRACECLONE.          .  ,       . ,      ,     ,    .      ,       PTRACE_ATTACH  ,    . </p><br><p> -,       : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- unsigned long options = PTRACE_O_TRACESYSGOOD; + unsigned long options = PTRACE_O_TRACESYSGOOD | PTRACE_O_TRACECLONE; if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) return -1;</span></span></code> </pre> <br><p> -,         clone(),    PTRACE_EVENT_CLONE,     ,  PTRACE_SYSCALL.        : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-void wait_for_syscall_completion(pid_t pid) +void wait_for_syscall_completion(pid_t pid, long syscall) { wait_for_syscall_enter_exit_stop(pid); + + /*  clone()   PTRACE_EVENT_CLONE */ + if (syscall == __NR_clone) + wait_for_clone_event(pid); wait_for_syscall_enter_exit_stop(pid); }</span></span></code> </pre> <br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_clone_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> event = SIGTRAP | (PTRACE_EVENT_CLONE &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, event) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     clone()  PID  ,    .         : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_ptrace_options</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_SETOPTIONS, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>   ,   clone()    ptrace(),  PTRACE_O_TRACECLONE.     ,     ,  -     . </p><br><h3 id="zapusk-novogo-potoka">    </h3><br><p>      ,   - .       clone()   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn_shell_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, <span class="hljs-comment"><span class="hljs-comment">/*   **  */</span></span> shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!shell_tid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">clone()    </a> :    ,   ,     ,  .      ,  . </p><br><p> CLONE_FILES, CLONE_FS, CLONE_IO, CLONE_SIGHAND, CLONE_SYSVSEM, CLONE_VM ‚Äî         . ,   CLONE_FILES    <em></em>   ,    (  fork()).      ‚Äî    <em></em> ‚Äî      ,        .       . , CLONE_VM   ,       ,    . </p><br><p>  CLONE_THREAD       <em></em> :    Linux ‚Äî  ¬´   ¬ª,     .  , ,  getpid()         , kill() ‚Äî   -   , execve() ‚Äî       ,   . </p><br><p>  ,  clone()   fork():        ,    .      clone()      :    ,  ‚Äî   .        . ( , ,        .) </p><br><p>    ,  pthread_create()    ,      ,    .     ? </p><br><h3 id="peredacha-upravleniya">   </h3><br><p>    fork()  : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* fork() ,    */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*     execve() */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span></code> </pre> <br><p>  ,     .  clone()                 .            . </p><br><p>      <a href="" rel="nofollow"> </a> . ,   clone()      ,    .      syscall   ret,       ,     .           . </p><br><h4 id="poisk-pary-instrukciy-syscall--ret">    SYSCALL + RET </h4><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> ,       .      ,     syscall   ret: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-if (region_size &lt; 2) +if (region_size &lt; 3) continue; /* * 0F 05 syscall + * C3 retq */ -for (size_t offset = 0; offset &lt; region_size - 1; offset++) { +for (size_t offset = 0; offset &lt; region_size - 2; offset++) { if (region_data[offset + 0] == 0x0F &amp;&amp; - region_data[offset + 1] == 0x05) + region_data[offset + 1] == 0x05 &amp;&amp; + region_data[offset + 2] == 0xC3) { return region-&gt;vaddr_low + offset; } }</span></span></code> </pre> <br><p>  ,       . </p><br><h4 id="podgotovka-steka">   </h4><br><p>     .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> prepare_shellcode()</a> ,    ,          : </p><br><pre> <code class="diff hljs"> void write_shellcode(void) { char shellcode_text[SHELLCODE_TEXT_SIZE]; size_t shellcode_size = shellcode_end - shellcode_start; /*   ,  ,  . . */ prepare_shellcode(shellcode_text, shellcode_size); /*   -   */ write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); + /*    ¬´¬ª   */ + unsigned long retaddr_vaddr = + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8; + write_remote_memory(target, retaddr_vaddr, + &amp;shellcode_text_vaddr, sizeof(shellcode_text_vaddr)); }</code> </pre> <br><p>  ,      ,     . </p><br><p>  ,     ,   <em></em> . System V ABI ,   ( %rsp)     16    .  <code>shellcode_stack_vaddr + SHELLCODE_STACK_SIZE</code>  :       (  4096 ),     1 .  8 ,     ,      retq,      -    .   -   : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- sub $8,%rsp + sub $16,%rsp /*   */ mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax</span></span></code> </pre> <br><p>     ,   %rsp    16       pthread_create().          SIGSEGV,     ‚Äî     pthread_create()   ,       . </p><br><h4 id="zapusk-potoka">   </h4><br><p>        ,       - ,      clone(): </p><br><pre> <code class="diff hljs"> static int spawn_shell_thread() { shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, /*   **  */ - shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8); if (!shell_tid) return -1; return 0; }</code> </pre> <br><p>      ptrace()    SIGSTOP,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ignore_thread_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait_for_process_stop(pid, SIGSTOP); }</code> </pre> <br><p>  Itu saja.               ptrace(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="zavershenie-potoka">   </h3><br><p>  ,    ,  ,    exit().        waitpid().     ‚Äî  CLONE_THREAD   wait()  ,‚Äî    PTRACE_O_TRACECLONE,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEXITSTATUS(status); }</code> </pre> <br><p>    pthread ,   ,  pthread_join()      pthread       ,        . ,  ‚Äî  .       ,   ,  . </p><br><h4 id="osvobozhdenie-pamyati">  Memori bebas </h4><br><p>     ,  -   .     ,   -   ,      munmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_munmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ perform_syscall(pid, syscall_insn_vaddr, __NR_munmap, <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) addr, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) len); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmap_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ remote_munmap(target, syscall_ret_vaddr, shellcode_text_vaddr, SHELLCODE_TEXT_SIZE); remote_munmap(target, syscall_ret_vaddr, shellcode_stack_vaddr, SHELLCODE_STACK_SIZE); }</code> </pre> <br><p> ,  ,     ,      ‚Äî  ptrace()   .        (, SIGSTOP),    ,   <em> </em>    (    ): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kill(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h4 id="otklyuchenie-otladchika">   </h4><br><p> ,      ,    .     PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-pyatogo-shaga">    </h3><br><p>                   ,      .     ,         .   ,      . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>      ?   . ,       ,      . </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="demonstrasi injeksi di Pusat Kontrol Gnome"></p><br><p>    Linux    .     GTK+     .      ,       make: </p><br><pre> <code class="bash hljs">libpayload.so: payload.c $(CC) $(CFLAGS) $(shell pkg-config --cflags --libs gtk+-3.0) -shared -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt;</code> </pre> <br><p>     entry()            GTK- ‚Äî    GTK  UI      ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;glib.h&gt; #include &lt;gtk/gtk.h&gt; static gboolean actual_entry(gpointer _arg) { /*       : */ hook_gtk_entry_constructor(); /*   FALSE,       */ return FALSE; } void entry(void) { /*    -,   */ g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, actual_entry, NULL, NULL); }</span></span></span></span></code> </pre> <br><p> ,   GTK   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">GtkEntry</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"> "input-purpose"</a>     .       ¬´¬ª,    ,      . </p><br><p> GTK   glib ‚Äî     ‚Äî      GtkEntry       .    constructed(),     .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*old_gtk_entry_constructed)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*    ,  ,   entry */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_gtk_entry_constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     GtkEntry */</span></span> GTypeClass *entry_type_class = g_type_class_peek(GTK_TYPE_ENTRY); GObjectClass *entry_object_class = G_OBJECT_CLASS(entry_type_class); <span class="hljs-comment"><span class="hljs-comment">/* *     "constructed"     . */</span></span> old_gtk_entry_constructed = entry_object_class-&gt;constructed; entry_object_class-&gt;constructed = new_gtk_entry_constructed; }</code> </pre> <br><p>   GtkEntry   : </p><br><ul><li>   ,  ,   </li><li>        </li></ul><br><p>  ,    GtkEntry  <em></em> ,   ,    .     ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"notify::input-purpose"</span></span>, G_CALLBACK(input_purpose_changed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-press"</span></span>, G_CALLBACK(icon_pressed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-release"</span></span>, G_CALLBACK(icon_released), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br><p>   .                ,         .         . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">input_purpose_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry)</span></span></span><span class="hljs-function"> </span></span>{ GtkInputPurpose purpose = gtk_entry_get_input_purpose(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (purpose == GTK_INPUT_PURPOSE_PASSWORD) { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } }</code> </pre> <br><p>   : ,      ,   ,  -       ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_pressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-add"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_released</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); }</code> </pre> <br><p>  Itu saja. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"> GitHub</a>         (GPLv2). </p><br><p> ,       .   gdb         : </p><br><pre> <code class="plaintext hljs">$ gdb --pid $(pgrep target) \ --batch \ -ex 'compile file -raw shell-code.c'</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473740/">https://habr.com/ru/post/id473740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473720/index.html">Dua cara untuk membuat unit test yang andal</a></li>
<li><a href="../id473722/index.html">Isolasi jarak jauh, kecemasan dan depresi</a></li>
<li><a href="../id473726/index.html">Tidak cukup hanya tahu apa itu Mutex, Semaphore, dan async / tunggu. Anda perlu tahu segalanya dari kuanta</a></li>
<li><a href="../id473728/index.html">Implementasi pemantauan yang khas. Nikolay Sivko</a></li>
<li><a href="../id473732/index.html">Sejarah penipuan dalam pembangunan jaringan kabel di bawah Kutub Utara sebesar $ 1 miliar</a></li>
<li><a href="../id473742/index.html">Printer rekayasa Epson untuk CAD dan GIS dan beberapa kata tentang "desain yang kuat"</a></li>
<li><a href="../id473748/index.html">Kurva Bezier dalam pelayanan ekonom tenaga kerja</a></li>
<li><a href="../id473750/index.html">Stereopi + WebRTC = telepresense di rumah</a></li>
<li><a href="../id473752/index.html">Apa yang salah dengan Copy-on-Write untuk Linux saat menyalin</a></li>
<li><a href="../id473756/index.html">HTTPS DNS - Solusi Setengah dan Salah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>