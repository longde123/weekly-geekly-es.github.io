<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔤 🧑🏿‍🤝‍🧑🏽 💜 دعونا نحاول التحدث عن آلات الحالة الهرمية بشكل عام ودعمها في SObjectizer-5 على وجه الخصوص 🈵 📠 🍑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ربما تكون آلات الحالة المحدودة واحدة من أكثر المفاهيم الأساسية والمستخدمة على نطاق واسع في البرمجة. تستخدم آلات الحالة المحدودة (KA) بنشاط في العديد م...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>دعونا نحاول التحدث عن آلات الحالة الهرمية بشكل عام ودعمها في SObjectizer-5 على وجه الخصوص</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423497/" style=";text-align:right;direction:rtl">  ربما تكون آلات الحالة المحدودة واحدة من أكثر المفاهيم الأساسية والمستخدمة على نطاق واسع في البرمجة.  تستخدم آلات الحالة المحدودة (KA) بنشاط في العديد من المنافذ التطبيقية.  على وجه الخصوص ، في منافذ مثل APCS والاتصالات ، والتي كان من الممكن التعامل معها ، تم العثور على المركبات الفضائية أقل قليلاً من كل خطوة. <br><br>  لذلك ، في هذه المقالة سنحاول التحدث عن المركبات الفضائية ، في المقام الأول عن آلات الحالة المحدودة الهرمية وقدراتها المتقدمة.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وأخبرنا</a> قليلاً عن دعم المركبة الفضائية في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SObjectizer-5</a> ، إطار عمل "الفاعل" لـ C ++.  واحدة من تلك القلة التي تكون مفتوحة وحرة ومتعددة المنصات ولا تزال على قيد الحياة. <br><br>  حتى إذا لم تكن مهتمًا بـ SObjectizer ، ولكنك لم تسمع أبدًا عن أجهزة الحالة المحدودة الهرمية أو مدى فائدة هذه الميزات المتقدمة للمركبة الفضائية مثل معالجات الإدخال / الإخراج للولايات أو تاريخ الحالة ، فقد تكون مهتمًا بالنظر تحت القطة و قراءة الجزء الأول من المقالة على الأقل. <br><a name="habracut"></a><br><h1 style=";text-align:right;direction:rtl">  كلمات عامة عن آلات الحالة المحدودة </h1><br>  لن نحاول إجراء برنامج تعليمي كامل في المقالة حول موضوع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأتمتة</a> ومجموعة متنوعة مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">آلات الحالة المحدودة</a> .  يحتاج القارئ إلى أن يكون لديه على الأقل فهم أساسي لهذه الأنواع من الكيانات. <br><br><h2 style=";text-align:right;direction:rtl">  آلات الحالة المحدودة المتقدمة وقدراتها </h2><br>  تحتوي المركبة الفضائية على العديد من الميزات "المتقدمة" التي تزيد بشكل كبير من سهولة استخدام المركبة الفضائية في البرنامج.  دعنا نلقي نظرة سريعة على هذه الميزات "المتقدمة". <br><br>  إخلاء المسؤولية: إذا كان القارئ على دراية جيدة بمخططات الحالة من UML ، فلن يجد أي شيء جديد لنفسه هنا. <br><br><h3 style=";text-align:right;direction:rtl">  آلات الحالة الهرمية </h3><br>  ربما تكون الفرصة الأكثر أهمية وقيمة هي تنظيم هرمية / تعشيش الدول.  نظرًا لأن القدرة على وضع الحالات في بعضها البعض على وجه التحديد هي التي تزيل "انفجار" عدد التحولات من دولة إلى أخرى مع زيادة تعقيد المركبة الفضائية. <br><br>  من الصعب شرح ذلك بالكلمات أكثر من إظهاره بالقدوة.  لذلك ، دعنا نتخيل أن لدينا infokiosk على الشاشة يتم عرض رسالة ترحيب لأول مرة.  يمكن للمستخدم تحديد عنصر "الخدمات" والانتقال إلى القسم لاختيار الخدمات التي يحتاجها.  أو يمكنه تحديد عنصر "الحساب الشخصي" والانتقال إلى قسم العمل مع بياناته وخدماته الشخصية.  أو يمكنه اختيار قسم المساعدة.  حتى الآن ، يبدو أن كل شيء بسيط ويمكن تمثيله بمخطط الحالة التالي (مبسط قدر الإمكان): <br><br><img src="https://habrastorage.org/webt/6e/lv/bm/6elvbm4wcsbmfbjaasp8zynjmtw.png"><br><br>  ولكن دعونا نحاول التأكد من أنه من خلال النقر على الزر "إلغاء" ، يمكن للمستخدم العودة من أي قسم إلى صفحة البداية برسالة ترحيب: <br><br><img src="https://habrastorage.org/webt/ok/hn/u3/okhnu3xrsjiss8u1fl1gygirn9u.png"><br><br>  المخطط يزداد تعقيدًا ، لكنه لا يزال تحت السيطرة.  ومع ذلك ، لنتذكر أنه في قسم "الخدمات" قد يكون لدينا عدة أقسام فرعية أخرى ، على سبيل المثال ، "الخدمات الشعبية" و "الخدمات الجديدة" و "القائمة الكاملة".  ومن كل قسم من هذه الأقسام ، تحتاج أيضًا إلى العودة إلى صفحة البداية.  أصبحت مركبتنا الفضائية البسيطة أكثر صعوبة: <br><br><img src="https://habrastorage.org/webt/ic/zx/hu/iczxhus-j_5ohrzwdxpbdf5n2qi.png"><br><br>  لكن هذا أبعد ما يكون عن الكل.  لم نأخذ في الاعتبار حتى الآن الزر "رجوع" ، الذي نحتاج من خلاله إلى العودة إلى القسم السابق.  دعنا نضيف رد فعل على زر "العودة" ونرى ما نحصل عليه: <br><br><img src="https://habrastorage.org/webt/mn/rq/t7/mnrqt7zjk8kyq6e3i1-jb9fgwya.png"><br><br>  نعم ، الآن نرى الطريق إلى المتعة الحقيقية.  ولكننا لم نفكر حتى في الأقسام الفرعية في قسمي "حسابي" و "مساعدة" ... إذا بدأنا ، فحينئذٍ ستتحول مركبتنا الفضائية البسيطة ، في البداية ، إلى شيء لا يمكن تصوره. <br><br>  هنا يأتي تعشيش الدول لمساعدتنا.  دعونا نتخيل أن لدينا حالتين فقط من المستوى الأعلى: WelcomeScreen و UserSelection.  جميع أقسامنا (مثل "الخدمات" و "حسابي" و "المساعدة") ستكون "متداخلة" في حالة اختيار المستخدم.  يمكنك القول بأن حالات ServicesScreen و ProfileScreen و HelpScreen ستكون تابعة لـ UserSelection.  وبما أنهم أطفال ، سيرثون رد الفعل لبعض الإشارات من حالتهم الأبوية.  لذلك ، يمكننا تحديد الاستجابة لزر الإلغاء في UserSelection.  لكننا لسنا بحاجة لتحديد هذا التفاعل في جميع الحالات الفرعية.  ما الذي يجعل مركبتنا الفضائية أكثر إيجازًا وفهمًا: <br><br><img src="https://habrastorage.org/webt/lx/nb/qn/lxnbqn3kqv9rst-fbebmx1kxhi8.png"><br><br>  هنا يمكنك ملاحظة أن رد فعل "إلغاء" و "رجوع" حددناه في UserSelection.  ويعمل هذا رد الفعل على زر "إلغاء الأمر" للجميع بدون استثناء الحالات الفرعية لاختيار المستخدم (بما في ذلك حالة فرعية أخرى لتحديد الخدمات المحددة).  ولكن في الحالة الفرعية لـ ServicesSelection ، يكون رد الفعل على الزر "السابق" مختلفًا بالفعل - فالعودة ليست في WelcomScreen ، ولكن في ServicesScreen. <br><br>  تسمى CAs التي تستخدم التسلسل الهرمي / التعشيش للحالات آلات الحالة المحدودة الهرمية (ICA). <br><br><h3 style=";text-align:right;direction:rtl">  رد فعل على الدخول / الخروج من / إلى الدولة </h3><br>  ميزة مفيدة للغاية هي القدرة على تعيين استجابة لدخول حالة معينة ، وكذلك رد فعل على الخروج من حالة.  لذلك ، في المثال أعلاه مع infokiosk ، يمكن تعليق معالج لدخول كل من الحالات ، مما سيؤدي إلى تغيير محتويات شاشة infokiosk. <br><br>  يمكن توسيع المثال السابق قليلاً.  لنفترض أن لدينا دولتان فرعيتان في WelcomScreen: BrightWelcomScreen ، حيث سيتم إبراز الشاشة بشكل طبيعي ، و DarkWelcomScreen ، حيث سيتم تقليل سطوع الشاشة.  يمكننا أن نجعل معالج إدخال DarkWelcomScreen سيخفت الشاشة.  ومعالج خروج DarkWelcomScreen الذي سيعيد السطوع الطبيعي. <br><br><img src="https://habrastorage.org/webt/qm/n0/2y/qmn02yrt9xxxmmawcpzufiexrpg.png"><br><br><h3 style=";text-align:right;direction:rtl">  التغيير التلقائي للحالة بعد وقت محدد </h3><br>  في بعض الأحيان ، قد يكون من الضروري الحد من بقاء المركبة الفضائية في حالة معينة.  لذا ، في المثال أعلاه ، يمكننا تحديد الوقت الذي تظل فيه ICA في حالة BrightWelcomScreen بدقيقة واحدة.  بمجرد انتهاء الدقيقة ، يتحول ICA تلقائيًا إلى حالة DarkWelcomScreen. <br><br><h3 style=";text-align:right;direction:rtl">  تاريخ المركبة الفضائية </h3><br>  ميزة أخرى مفيدة للغاية لـ ICA هي تاريخ حالة المركبة الفضائية. <br><br>  دعونا نتخيل أن لدينا نوعًا ما من ICA التجريدي من هذا النوع: <br><br><img src="https://habrastorage.org/webt/6i/6n/bl/6i6nblfh7l89fzaulpzsa3mo4a4.png"><br><br>  يمكن أن ينتقل ICA هذا من TopLevelState1 إلى TopLevelState2 والعكس صحيح.  ولكن داخل TopLevelState1 هناك العديد من الحالات المتداخلة.  إذا انتقل ICA ببساطة من TopLevelState2 إلى TopLevelState1 ، فسيتم تنشيط حالتين على الفور: TopLevelState1 و NestedState1.  تم تنشيط NestedState1 لأنها الحالة الفرعية الأولية لحالة TopLevelState1. <br><br>  تخيل الآن أنه كلما غيرت ICA حالتها من NestedState1 إلى NestedState2.  داخل NestedState2 ، تم تنشيط SubState InternalState1 (حيث أنها الحالة الفرعية الأولية لـ NestedState2).  ومن InternalState1 ذهبنا إلى InternalState2.  وبالتالي ، لدينا الحالات التالية نشطة في نفس الوقت: TopLevelState1 و NestedState2 و InternalState2.  وهنا ننتقل إلى TopLevelState2 (أي أننا غادرنا بشكل عام TopLevelState1). <br><br>  يصبح Active TopLevelState2.  وبعد ذلك نريد العودة إلى TopLevelState1.  يوجد في TopLevelState1 ، وليس في أي دولة فرعية معينة في TopLevelState1. <br><br>  لذا ، من TopLevelState2 نذهب إلى TopLevelState1 وأين نصل؟ <br><br>  إذا لم يكن لـ TopLevelState1 أي سجل ، فسنأتي إلى TopLevelState1 و NestedState1 (نظرًا لأن NestedState1 هي الحالة الفرعية الأولية لـ TopLevelState1).  على سبيل المثال  القصة الكاملة عن التحولات داخل TopLevelState1 ، التي حدثت قبل مغادرة TopLevelState2 ، قد ضاعت تمامًا. <br><br>  إذا كان TopLevelState1 لديه ما يسمى ب  التاريخ الضحل ، ثم عند العودة من TopLevelState2 إلى TopLevelState1 ، نصل إلى NestedState2 و InternalState1.  وصلنا إلى NestedState2 لأنه تم تسجيله في سجل حالة TopLevelState1.  ونصل إلى InternalState1 لأنه هو البداية لـ NestedState2.  اتضح أنه في التاريخ السطحي لـ TopLevelState1 ، يتم تخزين المعلومات فقط حول الحالة الثانوية للمستوى الأول.  لا يتم الحفاظ على تاريخ الحالات المضمنة في هذه الحالات الفرعية. <br><br>  ولكن إذا كان لـ TopLevelState1 تاريخًا عميقًا ، فعندما نعود من TopLevelState2 إلى TopLevelState1 ، فإننا ننتقل إلى NestedState2 و InternalState2.  لأنه في التاريخ العميق ، يتم تخزين معلومات كاملة عن الحالات الفرعية النشطة ، بغض النظر عن عمقها. <br><br><h3 style=";text-align:right;direction:rtl">  الدول المتعامدة </h3><br>  حتى الآن ، قمنا بفحص ICA حيث يمكن أن يكون هناك دولة واحدة فقط نشطة داخل الدولة.  ولكن في بعض الأحيان قد تكون هناك حالات عندما يكون في حالة معينة من ICA يجب أن يكون هناك العديد من الحالات الفرعية النشطة في وقت واحد.  تسمى هذه الحالات الثانوية الدول المتعامدة. <br><br>  المثال الكلاسيكي الذي يوضح الحالات المتعامدة هو لوحة مفاتيح الكمبيوتر المألوفة وأوضاع NumLock و CapsLock و ScrollLock.  يمكننا القول أن العمل مع NumLock / CapsLock / ScrollLock موصوف من قبل الدول المتعامدة الفرعية داخل الحالة النشطة: <br><br><img src="https://habrastorage.org/webt/hv/kf/8p/hvkf8p_gqijakghmndndhlileag.png"><br><br><h3 style=";text-align:right;direction:rtl">  كل ما تريد معرفته عن آلات الحالة المحدودة ، ولكن ... </h3><br>  بشكل عام ، هناك مقالة تأسيسية عن التدوين الرسمي لمخططات الدولة من ديفيد هاريل: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المخططات الإحصائية: الشكلية البصرية للأنظمة المعقدة (1987)</a> . <br><br>  هناك ، يتم فحص المواقف المختلفة التي يمكن مواجهتها عند العمل مع أجهزة الحالة المحدودة باستخدام مثال التحكم في الساعة الإلكترونية العادية.  إذا لم يقرأه أحد ، أوصي به بشدة.  في الأساس ، ذهب كل شيء وصفه Harel بعد ذلك إلى تدوين UML.  ولكن عندما تقرأ وصف الرسوم البيانية للحالة من UML ، فأنت لا تفهم دائمًا ماذا ولماذا ومتى تحتاج إليه.  ولكن في مقال Harel ، ينتقل العرض التقديمي من مواقف بسيطة إلى مواقف أكثر تعقيدًا.  وأنت على دراية أفضل بكل القوة التي تخفيها آلات الحالة المحدودة في حد ذاتها. <br><br><h1 style=";text-align:right;direction:rtl">  آلات الحالة المحدودة في SObjectizer </h1><br>  علاوة على ذلك ، سنتحدث عن SObjectizer وتفاصيله.  إذا كنت لا تفهم تمامًا الأمثلة أدناه ، فقد يكون من المنطقي معرفة المزيد حول SObjectizer.  على سبيل المثال ، من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقال المراجعة حول SObjecizer</a> والعديد من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المقالات</a> اللاحقة التي تقدم القراء إلى SObjectizer ، والانتقال من البسيط إلى المعقد (المقالة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأولى</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">والثانية</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">والثالثة</a> ). <br><br><h2 style=";text-align:right;direction:rtl">  الوكلاء في SObjectizer هم آلات الدولة </h2><br>  كان الوكلاء في SObjectizer منذ البداية آلات حالة ذات حالات صريحة.  حتى إذا لم يصف مطور الوكيل أيًا من حالاته الخاصة في فئة الوكيل الخاصة به ، فإن الوكيل لا يزال لديه حالة افتراضية ، والتي تم استخدامها افتراضيًا.  على سبيل المثال ، إذا قام أحد المطورين بعمل وكيل تافه مثل: <br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;how_are_you&gt;([]{ std::cout &lt;&lt; "I'm fine!" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); } };</span></span></code> </pre> <br>  عندها قد لا يشك في أنه في الواقع جميع الاشتراكات التي قام بها تتم من أجل الحالة الافتراضية.  ولكن إذا أضاف المطور حالاته الخاصة إلى الوكيل ، فعليك بالفعل التفكير في توقيع الوكيل بشكل صحيح في الحالة الصحيحة.  هنا ، على سبيل المثال ، تعديل بسيط (وكالعادة) للعامل الموضح أعلاه: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,  ,   . state_t st_free{this}; // ,  ,   . state_t st_busy{this}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  قمنا بتعيين معالجين مختلفين لإشارة how_are_you ، لكل منهما لحالته الخاصة. <br><br>  والخطأ في تعديل وكيل simple_demo هذا هو أنه في حالة st_free أو st_busy ، لن يستجيب الوكيل لإنهاء العمل على الإطلاق ، لأن  تركنا اشتراك الإقلاع في الحالة الافتراضية ، لكننا لم نجعل الاشتراكات المقابلة لـ st_free و st_busy.  طريقة بسيطة وواضحة لحل هذه المشكلة هي إضافة الاشتراكات المناسبة إلى st_free و st_busy: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"> simple_demo(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { <span class="hljs-comment"><span class="hljs-comment">//   how_are_you   ,    . st_free .event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); st_busy .event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //     st_free. this &gt;&gt;= st_free; }</span></span></code> </pre> <br>  صحيح ، هذه الطريقة تتفوق على لصق النسخ ، وهو ليس جيدًا.  يمكنك التخلص من النسخ واللصق عن طريق إدخال حالة أصل مشتركة لـ st_free و st_busy: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      . state_t st_basic{this}; // ,  ,   . //      st_basic. state_t st_free{initial_substate_of{st_basic}}; // ,  ,   . //     st_basic. state_t st_busy{substate_of{st_basic}}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { //   quit   st_basic    //  ""  . st_basic.event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  من أجل العدالة ، يجب أن يضاف أنه في البداية يمكن أن يكون عملاء SObjectizer مجرد آلات دولة بسيطة.  ظهر دعم المركبات الفضائية الهرمية مؤخرًا نسبيًا ، في يناير 2016. <br><br><h2 style=";text-align:right;direction:rtl">  لماذا وكلاء SObjectizer آلات الحالة المحدودة؟ </h2><br>  يحتوي هذا السؤال على إجابة بسيطة للغاية: <s>حدث ذلك أن</s> جذور SObjectizer تنمو من عالم أنظمة التحكم في العمليات ، وهناك آلات حالة محدودة تستخدم في كثير من الأحيان.  لذلك ، اعتبرنا أنه من الضروري أن تكون العوامل الموجودة في SObjectizer هي آلات الحالة.  هذا مريح للغاية إذا تم استخدام CAs في التطبيق الذي يحاولون تطبيق SObjectizer.  والحالة الافتراضية ، التي يمتلكها جميع العملاء ، تسمح لنا بعدم التفكير في المركبات الفضائية إذا لم يكن استخدام المركبة الفضائية مطلوبًا. <br><br>  من حيث المبدأ ، إذا نظرت إلى نموذج الممثلين نفسه ، وإلى المبادئ التي بني عليها هذا النموذج: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  الفاعل هو كيان له سلوك ؛ </li><li style=";text-align:right;direction:rtl">  الجهات الفاعلة الرد على الرسائل الواردة ؛ </li><li style=";text-align:right;direction:rtl">  بعد استلام الرسالة ، يمكن للممثل: <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إرسال عدد معين من الرسائل إلى الجهات الفاعلة الأخرى ؛ </li><li style=";text-align:right;direction:rtl">  إنشاء عدد من الجهات الفاعلة الجديدة ؛ </li><li style=";text-align:right;direction:rtl">  تحديد سلوك جديد لمعالجة الرسائل اللاحقة. </li></ul></li></ul><br>  يمكن للمرء أن يجد تشابهًا قويًا بين المركبات الفضائية البسيطة والممثلين.  يمكنك حتى أن تقول أن الممثلين هم آلات دولة محدودة بسيطة. <br><br><h2 style=";text-align:right;direction:rtl">  ما ميزات أجهزة الحالة المتقدمة التي يدعمها SObjectizer؟ </h2><br>  من الميزات المذكورة أعلاه لآلات الحالة المحدودة المتقدمة ، يدعم SObjectizer كل شيء باستثناء الحالات المتعامدة.  الأشياء الجيدة الأخرى ، مثل الولايات المتداخلة ، ومعالجات الإدخال / الإخراج ، والقيود المفروضة على الوقت المستغرق في الولاية ، والتاريخ للولايات ، مدعومة. <br><br>  بدعم من الدول المتعامدة ، لم تنمو أول مرة معًا.  من ناحية ، لم يكن المقصود من البنية الداخلية لـ SObjectizer دعم العديد من الحالات المستقلة والنشطة في نفس الوقت للعامل.  من ناحية أخرى ، هناك أسئلة أيديولوجية حول كيفية تصرف الوكيل الذي لديه حالات متعامدة.  تبين أن تشابك هذه الأسئلة معقد للغاية ، وكان العادم المفيد صغيرًا جدًا لحل هذه المشكلة.  نعم ، وفي ممارستنا ، لم تكن هناك حالات تتطلب الحالات المتعامدة ، ولكن سيكون من المستحيل القيام بذلك ، على سبيل المثال ، من خلال تقسيم العمل بين عدة عوامل مرتبطة بسياق عمل مشترك واحد. <br><br>  ومع ذلك ، إذا كان شخص ما بحاجة إلى ميزة مثل حالات التعامد ، ولديك أمثلة من العالم الحقيقي للمهام التي تتطلب ذلك ، فلنتحدث.  ربما ، لدينا أمثلة ملموسة أمام أعيننا ، يمكننا إضافة هذه الميزة إلى SObjectizer. <br><br><h2 style=";text-align:right;direction:rtl">  كيف يبدو دعم الميزات المتقدمة لـ ICA في التعليمات البرمجية </h2><br>  في هذا الجزء من القصة ، سنحاول الانتقال سريعًا إلى SObjectizer-5 API للعمل مع ICA.  دون التعمق في التفاصيل ، فقط حتى يكون لدى القارئ فكرة عما هو وكيف يبدو.  يمكن العثور على معلومات أكثر تفصيلا ، إذا كنت ترغب في ذلك ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في الوثائق الرسمية</a> . <br><br><h3 style=";text-align:right;direction:rtl">  الدول المتداخلة </h3><br>  من أجل الإعلان عن حالة متداخلة ، تحتاج إلى تمرير التعبير الأولي_ substate_of أو substate_of إلى مُنشئ كائن state_t المقابل: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_parent{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  . state_t st_first_child{initial_substate_of{st_parent}}; //   . //    . state_t st_second_child{substate_of{st_parent}}; //   . state_t st_third_child{substate_of{st_parent}}; //   . state_t st_first_grandchild{initial_substate_of{st_third_child}}; //    . state_t st_second_grandchild{substate_of{st_third_child]}; ... };</span></span></code> </pre> <br>  إذا كانت الحالة S تحتوي على العديد من الحالات الفرعية C1 و C2 و ... و Cn ، فيجب وضع علامة على إحدى هذه الحالات (وواحدة فقط) على أنها أولية فرعية.  يتم تشخيص انتهاك هذه القاعدة في وقت التشغيل. <br><br>  الحد الأقصى لعمق تداخل الحالة في SObjectizer-5 محدود.  في الإصدارات 5.5 ، هذه المستويات 16.  يتم تشخيص انتهاك هذه القاعدة في وقت التشغيل. <br><br>  الحيلة الأكثر أهمية مع الحالات المتداخلة هي أنه عندما يتم تنشيط حالة تحتوي على حالات متداخلة ، يتم تنشيط العديد من الحالات في وقت واحد.  لنفترض أن هناك حالة A تحتوي على ركائز فرعية B و C ، وفي الحالة الفرعية B توجد ركائز فرعية D و E: <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  عندما يتم تنشيط الحالة أ ، في الواقع ، يتم تنشيط ثلاث حالات على الفور: A و AB و ABD <br><br>  إن حقيقة أن العديد من الدول يمكن أن تكون نشطة في آن واحد لها أخطر تأثير على شيئين أرشيفيين.  أولاً ، للبحث عن معالج للرسالة الواردة التالية.  لذلك ، في المثال الموضح للتو ، سيتم البحث عن معالج الرسائل أولاً في حالة ABD. إذا لم يكن هناك معالج مناسب هناك ، فسيستمر البحث في حالته الأصلية ، أي  في AB وتضر بالفعل ، إذا لزم الأمر ، سيستمر البحث في الدولة A. <br><br>  ثانيًا ، يؤثر وجود العديد من الحالات النشطة على ترتيب استدعاء معالجات الإدخال / الإخراج للولايات.  ولكن سيتم مناقشة هذا أدناه. <br><br><h3 style=";text-align:right;direction:rtl">  معالجات I / O الدولة </h3><br>  بالنسبة للولاية ، يمكن تحديد معالجات حالة الدخول والخروج من الولاية.  يتم ذلك باستخدام أساليب state_t :: on_enter و state_t :: on_exit.  عادة ، يتم استدعاء هذه الطرق في طريقة so_define_agent () (أو مباشرة في مُنشئ الوكيل إذا كان الوكيل تافهًا ولم يتم توفير الميراث منه). <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_busy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :       , //     . st_free.on_enter([]{ ... }); st_busy.on_exit([]{ ...}); ... this &gt;&gt;= st_free; } ... };</span></span></code> </pre> <br>  ربما تكون اللحظة الأكثر صعوبة مع معالجات on_enter / on_exit هي استخدامها للحالات المتداخلة.  دعنا نعود إلى المثال مع الحالات A و B و C و D و E. <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  افترض أن لكل ولاية معالج on_enter و on_exit. <br><br>  دع A. تصبح الحالة الحالية للعامل.  يتم تنشيط الحالات A و AB و ABD أثناء تغيير حالة الوكيل ، سيتم استدعاء A.on_enter و ABon_enter و ABDon_enter.  وبهذا الترتيب. <br><br>  لنفترض أن هناك انتقال إلى ABE. سيتم استدعاء ABDon_exit و ABEon_enter. <br><br>  إذا وضعنا الوكيل في حالة AC ، فسيتم استدعاء ABEon_exit و ABon_exit و ACon_enter. <br><br>  إذا تم إلغاء تسجيل العامل الموجود في حالة التيار المتردد ، فسيتم استدعاء معالجات ACon_exit و A.on_exit فور الانتهاء من طريقة so_evt_finish (). <br><br><h3 style=";text-align:right;direction:rtl">  حدود الوقت </h3><br>  يتم تعيين الحد الزمني للبقاء الوكيل في حالة معينة باستخدام أسلوب state_t :: time_limit.  كما هو الحال مع on_enter / on_exit ، عادة ما يتم استدعاء طرق time_limit حيث يتم تكوين الوكيل للعمل داخل SObjectizer: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">led_indicator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> inactive{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> active{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        15s. //        inactive. active.time_limit(15s, inactive); ... } ... };</span></span></code> </pre> <br>  إذا تم تعيين الحد الزمني للولاية ، فعندما يدخل الوكيل هذه الحالة ، يبدأ SObjectizer في حساب الوقت المستغرق في الولاية.  إذا غادر الوكيل الحالة ، ثم عاد إلى هذه الحالة مرة أخرى ، فسيبدأ العد التنازلي مرة أخرى. <br><br>  إذا تم تعيين حدود زمنية للحالات المضمنة ، فأنت بحاجة إلى توخي الحذر ، لأن  الحيل الغريبة ممكنة: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   . state_t A{this}, B{this}; //   first . state_t C{initial_substate_of{A}}, st_D{substate_of{A}}; ... void so_define_agent() override { A.time_limit(15s, B); C.time_limit(10s, D); D.time_limit(20s, C); ... } ... };</span></span></code> </pre> <br>  افترض أن وكيلًا يدخل في الحالة أ.  يتم تنشيط الدولتين A و C لكل من A و C.  في السابق ، سينتهي بالحالة C وسيتحول الوكيل إلى الحالة D. سيبدأ هذا العد التنازلي للبقاء في الحالة D. ولكن سيستمر العد التنازلي للبقاء في A!  نظرًا لأنه خلال فترة الانتقال من C إلى D ، استمر العامل في البقاء في الحالة A. وبعد خمس ثوانٍ من الانتقال القسري من C إلى D ، سيذهب الوكيل إلى الحالة B. <br><br><h3 style=";text-align:right;direction:rtl">  قصة ثروة </h3><br>  بشكل افتراضي ، ليس لدى الدول الوكيل تاريخ.  لتنشيط حفظ التاريخ لدولة ما ، قم بتمرير ثابت الضحلة (الدولة سيكون لها تاريخ ضحل) أو تاريخ عميق (الدولة سيكون لها تاريخ عميق) إلى مُنشئ state_t.  على سبيل المثال: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> A{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, shallow_history}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> B{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, deep_history}; ... };</code> </pre> <br>  يعد تاريخ الولايات موضوعًا صعبًا ، خاصة عند استخدام عمق لائق لتعشيش الدول وللدول الفرعية تاريخها الخاص.  لذلك ، للحصول على معلومات أكثر اكتمالاً حول هذا الموضوع ، من الأفضل الرجوع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إلى الوثائق</a> ، إلى التجربة.  حسنًا ، أن تسألنا إذا كنت لا تستطيع معرفة ذلك بنفسك ؛) <br><br><h3 style=";text-align:right;direction:rtl">  just_switch_to، transfer_to_state، قمع </h3><br>  تحتوي فئة state_t على عدد من الأساليب الأكثر استخدامًا التي تم عرضها أعلاه بالفعل: event () لاشتراك الأحداث في رسالة ، on_enter () و on_exit () لتعيين معالجات الإدخال / الإخراج ، time_limit () لتعيين حد للوقت المستغرق في الولاية. <br><br>  إلى جانب هذه الأساليب ، عند العمل مع ICA ، فإن الطرق التالية لفئة state_t مفيدة جدًا: <br><br>  الطريقة just_switch_to () ، المصممة للحالة عندما يكون رد الفعل الوحيد على الرسالة الواردة هو نقل الوكيل إلى حالة جديدة.  يمكنك الكتابة: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">some_state.just_switch_to&lt;some_msg&gt;(another_state);</code> </pre> <br>  بدلاً من: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">some_state.event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_msg&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= another_state; });</code> </pre> <br>  تُعد طريقة transfer_to_state () مفيدة جدًا عندما تتم معالجة بعض الرسائل M بنفس الطريقة في حالتين أو أكثر S1 ، S2 ، ... ، Sn.  ولكن ، إذا كنا في الولايات S2 ، ... ، Sn ، فعلينا أولاً العودة إلى S1 ، وعندها فقط نقوم بمعالجة M. <br><br>  إذا كان هذا يبدو صعبًا ، فربما في مثال رمز ، سيتم فهم هذا الموقف بشكل أفضل: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); ... //      . Sn.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); } ... };</span></span></code> </pre> <br>  ولكن بدلاً من تحديد معالجات الأحداث المشابهة جدًا لـ S2 ، ... ، Sn ، استخدم transfer_to_state: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.transfer_to_state&lt;M&gt;(S1); ... //      . Sn.transfer_to_state&lt;M&gt;(Sn); } ... };</span></span></code> </pre> <br>  تمنع الطريقة suppress () بحث معالج الأحداث عن الحالة الفرعية الحالية وجميع الحالات الفرعية الرئيسية الخاصة بها.  افترض أن لدينا حالة أصل A يتم فيها استدعاء std :: abort () في الرسالة M.  وهناك حالة تابعة لـ B يمكن فيها تجاهل M بأمان.  يجب تحديد رد الفعل على M في الحالة الفرعية B ، لأنه إذا لم نفعل ذلك ، فسيتم العثور على معالج B في A. لذلك ، سنحتاج إلى كتابة شيء مثل: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) {}); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br>  تتيح لك طريقة suppress () كتابة هذا الموقف في التعليمات البرمجية بشكل أكثر وضوحًا ورسوماتًا: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.suppress&lt;M&gt;(); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br><h2 style=";text-align:right;direction:rtl">  مثال بسيط جدا </h2><br>  تتضمن الأمثلة القياسية لـ SObjectizer v.5.5 مثالًا بسيطًا ، <a href="">blinking_led</a> ، والذي يحاكي تشغيل مؤشر LED الوامض.  مخطط حالة الوكيل من هذا المثال هو كما يلي: <br><br><img src="https://habrastorage.org/webt/9d/yt/ms/9dytmskalbsypsg9xjjzkwupl5k.png"><br><br>  وإليك رمز الوكيل الكامل من هذا المثال: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  هنا ، يتم تنفيذ جميع الأعمال الفعلية داخل معالجات الإدخال / الإخراج للحالة الفرعية blink_on.  حسنًا ، بالإضافة إلى ذلك ، يحد من مدة الإقامة في العمل الثانوي في blink_on و blink_off. <br><br><h2 style=";text-align:right;direction:rtl">  ليس مثال بسيط للغاية </h2><br>  تتضمن الأمثلة القياسية لـ SObjectizer v.5.5 أيضًا مثالًا أكثر تعقيدًا بكثير ، <a href="">intercom_statechart</a> ، والذي يحاكي سلوك لوحة هاتف الباب.  ويظهر مخطط الحالة للعامل الرئيسي في هذا المثال شيئًا مثل هذا: <br><br><img src="https://habrastorage.org/webt/o-/i6/7d/o-i67dswwms9rkutntnvd-hrx7e.jpeg"><br><br>  كل شيء قاسي للغاية لأن هذا التقليد لا يدعم فقط الاتصال بشقة عن طريق الرقم ، ولكن أيضًا أشياء مثل رمز سري فريد لكل شقة ، بالإضافة إلى رمز خدمة خاص.  تسمح لك هذه الرموز بفتح قفل الباب دون طلب أي مكان. <br><br>  لا تزال هناك أشياء مثيرة للاهتمام في هذا المثال.  لكنها كبيرة جدًا بحيث لا يمكن وصفها بالتفصيل (حتى المقالة المستقلة قد لا تكون كافية لذلك).  لذلك إذا كنت مهتمًا بمظهر ICA المعقد حقًا في SObjectizer ، يمكنك أن ترى في هذا المثال.  وإذا كان هناك شيء غير واضح ، فيمكنك طرح سؤال علينا.  على سبيل المثال ، في التعليقات على هذه المقالة. <br><br><h1 style=";text-align:right;direction:rtl">  هل من الممكن عدم استخدام دعم المركبة الفضائية المدمج في SObjectizer-5؟ </h1><br>  لذلك ، يحتوي SObjectizer-5 على دعم مضمن لـ ICA مع مجموعة واسعة جدًا من الميزات المدعومة.  يتم هذا الدعم بالطبع من أجل استخدامه.  على وجه الخصوص ، آليات تصحيح SObjectizer ، مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تتبع تسليم الرسائل</a> ، تدرك حالة الوكيل وتعرض الحالة الحالية في رسائل التصحيح الخاصة بها. <br><br>  ومع ذلك ، إذا لم يرغب المطور لسبب ما في استخدام أدوات SObjectizer-5 المدمجة ، فقد لا يفعل ذلك. <br><br>  على سبيل المثال ، يمكنك رفض استخدام SObjectizer state_t وأشياء أخرى مثله لأن state_t عبارة عن كائن ثقيل جدًا به داخل std :: string ، وزوج من std :: function ، والعديد من العدادات مثل std :: size_t ، خمس مؤشرات لأشياء مختلفة وبعض التفاهات الأخرى.  معا ، هذا على لينكس 64 بت و GCC-5.5 ، على سبيل المثال ، يعطي 160 بايت لكل حالة (بصرف النظر عما يمكن تخصيصه في الذاكرة الديناميكية). <br><br>  إذا كنت بحاجة ، على سبيل المثال ، إلى مليون وكيل في التطبيق ، كل منها سيكون له 10 حالات ، فقد لا يكون الحمل الإضافي لـ SObjectizer state_t مقبولًا.  في هذه الحالة ، يمكنك استخدام آلية أخرى للعمل مع أجهزة الحالة ، وتفويض معالجة الرسالة يدويًا لهذه الآلية.  شيء مثل: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">external_fsm_demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { some_fsm_type my_fsm_; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe_self() .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_one&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_two&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_three&gt; cmd) { my_fsm_.handle(*cmd); }); ... } ... };</code> </pre> <br>  في هذه الحالة ، أنت تدفع مقابل الكفاءة من خلال زيادة حجم العمل اليدوي وعدم وجود مساعدة من آليات تصحيح SObjectizer.  ولكن هنا يعود الأمر للمطور ليقرر. <br><br><h1 style=";text-align:right;direction:rtl">  الخلاصة </h1><br>  تحولت المقالة إلى أنها ضخمة ، أكثر بكثير مما كان مخططا في الأصل.  شكرا لكل من قرأ على هذا المكان.  إذا رأى أحد القراء أنه من الممكن ترك ملاحظاتك في التعليقات على المقالة ، فسيكون ذلك رائعًا. <br><br>  إذا بقي شيء ما غير واضح ، فقم بطرح الأسئلة ، وسوف نجيب بسعادة. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أيضًا ، مع اغتنام هذه الفرصة ، أود أن ألفت انتباه أولئك المهتمين بـ SObjectizer ، حيث بدأ هذا العمل في الإصدار التالي من SObjectizer في إطار الفرع 5.5. </font><font style="vertical-align: inherit;">باختصار حول ما يعتبر للتنفيذ في 5.5.23 ، الموصوفة </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">بشكل كامل ، ولكن باللغة الإنجليزية ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">يمكنك ترك رأيك حول أي من الميزات المقترحة للتنفيذ ، أو تقديم شيء آخر.</font></font> على سبيل المثال<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هناك فرصة حقيقية للتأثير على تطوير SObjectizer. </font><font style="vertical-align: inherit;">علاوة على ذلك ، بعد إصدار v.5.5.23 ، قد يكون هناك توقف مؤقت في العمل على SObjectizer وقد لا تكون الفرصة القادمة لتضمين شيء مفيد في 2018 SObjectizer موجودة.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar423497/">https://habr.com/ru/post/ar423497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar423487/index.html">Node.js بدون وحدات node_modules</a></li>
<li><a href="../ar423489/index.html">أنا طبيب طوارئ وأريد التحدث عن مخطط القلب الكهربائي الجديد لـ Apple Watch</a></li>
<li><a href="../ar423491/index.html">ملخص PHP رقم 139 (3 - 17 سبتمبر 2018)</a></li>
<li><a href="../ar423493/index.html">Android Go هو المستقبل مليار جهاز وبحد أقصى 50 ميجا بايت. محاضرة ياندكس</a></li>
<li><a href="../ar423495/index.html">ماذا بداخل XGBoost ، وما علاقة Go به؟</a></li>
<li><a href="../ar423499/index.html">DevBoy - كيف أنشأت مشروع جهاز مفتوح المصدر وأطلقت مشروعًا على Kickstarter</a></li>
<li><a href="../ar423501/index.html">بحث وإنشاء نمط مرئي لمشروع تصميم</a></li>
<li><a href="../ar423503/index.html">تجربتي في الحركة والعيش والدراسة في ألمانيا</a></li>
<li><a href="../ar423505/index.html">تبيع زوكربيرج أسهم فيسبوك مقابل 13 مليار دولار حتى "لا يضطر أطفالنا إلى المرض"</a></li>
<li><a href="../ar423507/index.html">كيفية حفظ الذاكرة في علامات تبويب المتصفح ، ولكن لا تفقد محتوياتها. تجربة فريق Yandex.Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>