<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏾 🔓 💬 Cara Kerja JS: Komunikasi WebRTC dan P2P 🌬️ 👩🏿‍💼 😽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Nasihat membaca] 19 bagian siklus lainnya  Bagian 1: Tinjauan umum mesin, mekanisme runtime, panggilan stack 
 Bagian 2: Tentang V8 internal dan opti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara Kerja JS: Komunikasi WebRTC dan P2P</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416821/"><div class="spoiler">  <b class="spoiler_title">[Nasihat membaca] 19 bagian siklus lainnya</b> <div class="spoiler_text">  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinjauan umum mesin, mekanisme runtime, panggilan stack</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang V8 internal dan optimasi kode</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengelola memori, empat jenis memori bocor dan berurusan dengannya</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Event Loop, Async, dan Five Ways untuk Meningkatkan Kode Anda dengan async / menunggu</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSocket dan HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang harus dipilih?</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur dan ruang lingkup WebAssembly</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Web dan Lima Skenario Penggunaan</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Layanan</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemberitahuan push web</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lacak perubahan di DOM dengan MutationObserver</a> <br>  Bagian 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin rendering halaman web dan tip untuk mengoptimalkan kinerja mereka</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Animasi dengan CSS dan JavaScript</a> <br>  Bagian 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Pohon Sintaks Abstrak, Parsing dan Optimalisasi nya</a> <br>  Bagian 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara kerja JS: kelas dan warisan, transpilasi dalam Babel dan TypeScript</a> <br>  Bagian 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Penyimpanan</a> <br>  Bagian 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Shadow DOM Technology dan Komponen Web</a> <br>  Bagian 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Mekanisme Komunikasi WebRTC dan P2P</a> <br>  Bagian 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Elemen Kustom</a> </div></div><br>  Hari ini kami menerbitkan terjemahan bagian 18 dari serangkaian materi yang didedikasikan untuk segala sesuatu yang berkaitan dengan JavaScript.  Di sini kita akan berbicara tentang teknologi WebRTC, yang bertujuan mengatur pertukaran data langsung antara aplikasi browser secara real time. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/aff/ed1/fee/affed1fee433a9375eefd24a753a89b8.png" alt="gambar"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ulasan</font> </h2><br>  Apa itu WebRTC?  Untuk memulainya, perlu dikatakan bahwa singkatan RTC adalah singkatan dari Real Time Communication (komunikasi dalam waktu nyata).  Ini saja memberi banyak informasi tentang teknologi ini. <br><br>  WebRTC menempati ceruk yang sangat penting di antara mekanisme platform web.  Sebelumnya, teknologi P2P (koneksi peer-to-peer, point-to-point, peer-to-peer, peer-to-peer) yang digunakan oleh aplikasi seperti obrolan desktop memberi mereka peluang yang tidak dimiliki proyek web.  WebRTC membuat perbedaan untuk teknologi web. <br><br>  WebRTC, jika kita melihat teknologi ini secara umum, memungkinkan aplikasi web untuk membuat koneksi P2P, yang akan kita bahas di bawah ini.  Selain itu, kami akan membahas topik-topik berikut di sini untuk menunjukkan gambaran lengkap dari struktur internal WebRTC: <br><br><ul><li>  Komunikasi P2P. </li><li>  Firewall dan teknologi NAT Traversal. </li><li>  Pemberian sinyal, sesi dan protokol. </li><li>  API WebRTC </li></ul><br><h2>  <font color="#3AC1EF">Komunikasi P2P</font> </h2><br>  Misalkan dua pengguna telah meluncurkan, masing-masing di browser mereka sendiri, sebuah aplikasi yang memungkinkan Anda untuk mengatur obrolan video menggunakan WebRTC.  Mereka ingin membuat koneksi P2P.  Setelah keputusan dibuat, kita memerlukan mekanisme yang memungkinkan browser pengguna untuk menemukan satu sama lain dan menjalin komunikasi dengan mempertimbangkan mekanisme perlindungan informasi yang tersedia dalam sistem.  Setelah membuat koneksi, pengguna akan dapat bertukar informasi multimedia secara real time. <br><br>  Salah satu kesulitan utama yang terkait dengan koneksi P2P browser adalah browser pertama-tama harus saling menemukan, dan kemudian membangun koneksi jaringan berdasarkan soket untuk menyediakan transfer data dua arah.  Kami menyarankan untuk mendiskusikan kesulitan yang terkait dengan pemasangan koneksi tersebut. <br><br>  Ketika aplikasi web membutuhkan beberapa data atau sumber daya, aplikasi itu mengunduhnya dari server dan hanya itu.  Alamat server diketahui oleh aplikasi.  Jika kita berbicara, misalnya, tentang membuat obrolan P2P, yang operasinya didasarkan pada koneksi langsung peramban, alamat peramban ini tidak diketahui sebelumnya.  Akibatnya, untuk membuat koneksi P2P, Anda harus menghadapi beberapa masalah. <br><br><h2>  <font color="#3AC1EF">Firewall dan Protokol Traversal NAT</font> </h2><br>  Komputer biasa, sebagai suatu peraturan, tidak memiliki alamat IP eksternal statis yang ditugaskan kepadanya.  Alasan untuk ini adalah bahwa komputer seperti itu biasanya terletak di belakang firewall dan perangkat NAT. <br><br>  NAT adalah mekanisme yang menerjemahkan alamat IP lokal internal yang terletak di belakang firewall ke alamat IP global global.  Teknologi NAT digunakan, pertama, untuk alasan keamanan, dan kedua, karena pembatasan yang diberlakukan oleh IPv4 pada jumlah alamat IP global yang tersedia.  Itu sebabnya aplikasi web menggunakan WebRTC tidak boleh bergantung pada kenyataan bahwa perangkat saat ini memiliki alamat IP statis global. <br><br>  Mari kita lihat cara kerja NAT.  Jika Anda berada di jaringan perusahaan dan terhubung ke WiFi, komputer Anda akan diberi alamat IP yang hanya ada di belakang perangkat NAT Anda.  Misalkan ini adalah alamat IP 172.0.23.4.  Namun, untuk dunia luar, alamat IP Anda mungkin terlihat seperti 164.53.27.98.  Akibatnya, dunia luar melihat permintaan Anda berasal dari alamat 164.53.27.98, tetapi berkat NAT, jawaban atas permintaan yang dibuat oleh komputer Anda untuk layanan eksternal akan dikirim ke alamat internal Anda 172.0.23.4.  Ini terjadi menggunakan tabel terjemahan.  Harap dicatat bahwa selain alamat IP, nomor port juga diperlukan untuk jaringan. <br><br>  Mengingat bahwa NAT terlibat dalam proses interaksi sistem Anda dengan dunia luar, peramban Anda, untuk membangun koneksi WebRTC, perlu mengetahui alamat IP komputer tempat peramban yang ingin Anda komunikasikan jalankan. <br><br>  Di sinilah server STUN (Session Traversal Utilities for NAT) dan TURN (Traversal Using Relays around NAT) memasuki server.  Untuk memastikan pengoperasian teknologi WebRTC, permintaan terlebih dahulu dibuat ke server STUN, untuk mengetahui alamat IP eksternal Anda.  Bahkan, kita berbicara tentang permintaan yang dibuat ke server jauh untuk mencari tahu dari alamat IP apa server menerima permintaan ini.  Setelah menerima permintaan serupa, server jarak jauh akan mengirim respons yang berisi alamat IP yang terlihat. <br><br>  Berdasarkan asumsi bahwa skema ini operasional dan Anda menerima informasi tentang alamat dan port IP eksternal Anda, maka Anda dapat memberi tahu peserta lain dalam sistem (kami akan memanggil mereka teman sebaya) tentang cara menghubungi Anda secara langsung.  Rekan-rekan ini juga dapat melakukan hal yang sama menggunakan STUN atau MENGHIDUPKAN server dan dapat memberi tahu Anda alamat mana yang ditugaskan untuk mereka. <br><br><h2>  <font color="#3AC1EF">Pemberian sinyal, sesi dan protokol</font> </h2><br>  Proses menemukan informasi jaringan, yang dijelaskan di atas, adalah salah satu bagian dari sistem pensinyalan besar, yang, dalam kasus WebRTC, didasarkan pada standar JSEP (JavaScript Session Establishment Protocol).  Signaling termasuk penemuan sumber daya jaringan, pembuatan dan manajemen sesi, keamanan komunikasi, koordinasi parameter media, penanganan kesalahan. <br><br>  Agar koneksi berfungsi, rekan harus menyetujui format data yang akan mereka tukarkan, dan mengumpulkan informasi tentang alamat jaringan komputer tempat aplikasi tersebut berjalan.  Mekanisme pensinyalan untuk berbagi informasi penting ini bukan bagian dari API WebRTC. <br><br>  Pensinyalan tidak didefinisikan oleh standar WebRTC, dan itu tidak diterapkan dalam API-nya untuk memberikan fleksibilitas dalam teknologi dan protokol yang digunakan.  Pemberian sinyal dan server yang mendukungnya adalah tanggung jawab pengembang aplikasi WebRTC. <br><br>  Berdasarkan asumsi bahwa aplikasi WebRTC Anda yang berjalan di browser dapat menentukan alamat IP eksternal browser menggunakan STUN, seperti dijelaskan di atas, langkah selanjutnya adalah membahas parameter sesi dan membuat koneksi dengan browser lain. <br><br>  Diskusi awal parameter sesi dan pembentukan koneksi dibuat menggunakan protokol pensinyalan / komunikasi yang berspesialisasi dalam komunikasi multimedia.  Protokol ini, di samping itu, bertanggung jawab untuk mematuhi aturan di mana sesi dikelola dan diakhiri. <br><br>  Salah satu protokol ini disebut SIP (Session Initiation Protocol).  Harap dicatat bahwa karena fleksibilitas subsistem pensinyalan WebRTC, SIP bukan satu-satunya protokol pensinyalan yang dapat digunakan.  Protokol pensinyalan yang dipilih, di samping itu, harus bekerja dengan protokol lapisan aplikasi yang disebut SDP (Session Description Protocol), yang digunakan saat menggunakan WebRTC.  Semua metadata yang terkait dengan data multimedia ditransmisikan menggunakan protokol SDP. <br><br>  Setiap peer (yaitu, aplikasi yang menggunakan WebRTC) yang mencoba untuk menghubungi peer lain menghasilkan seperangkat rute kandidat untuk protokol ICE (Interactive Connectivity Establishment).  Calon mewakili kombinasi alamat IP, port, dan protokol transport yang dapat digunakan.  Harap dicatat bahwa satu komputer dapat memiliki banyak antarmuka jaringan (kabel, nirkabel, dan sebagainya), sehingga dapat ditetapkan beberapa alamat IP, satu untuk setiap antarmuka. <br><br>  Berikut adalah diagram dengan MDN yang menggambarkan proses pertukaran data di atas. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/eb5/3a2/c33eb53a21f48ec8f629ac38fc503d4e.png"></div><br>  <i><font color="#999999">Proses pertukaran data diperlukan untuk membangun koneksi P2P</font></i> <br><br><h2>  <font color="#3AC1EF">Buat koneksi</font> </h2><br>  Setiap rekan kerja pertama-tama mengetahui alamat IP eksternal seperti yang dijelaskan di atas.  Kemudian, "saluran" data pensinyalan dibuat secara dinamis, yang berfungsi untuk mendeteksi rekan dan mendukung pertukaran data di antara mereka, untuk membahas parameter sesi dan pemasangannya. <br><br>  "Saluran" ini tidak dikenal dan tidak dapat diakses oleh dunia luar, diperlukan pengenal unik untuk mengaksesnya. <br><br>  Harap perhatikan bahwa karena fleksibilitas WebRTC, dan fakta bahwa proses pensinyalan tidak ditentukan oleh standar, konsep "saluran" dan urutan penggunaannya mungkin sedikit berbeda tergantung pada teknologi yang digunakan.  Bahkan, beberapa protokol tidak memerlukan mekanisme "saluran" untuk mengatur pertukaran data.  Kami, untuk keperluan materi ini, menganggap bahwa "saluran" dalam implementasi sistem digunakan. <br><br>  Jika dua atau lebih rekan kerja terhubung ke "saluran" yang sama, rekan kerja mendapatkan kesempatan untuk bertukar data dan mendiskusikan informasi sesi.  Proses ini mirip dengan template <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerbit-pelanggan</a> .  Secara umum, rekan yang memulai koneksi mengirimkan "penawaran" menggunakan protokol pensinyalan seperti SIP atau SDP.  Inisiator mengharapkan untuk menerima "respons" dari penerima proposal, yang terhubung ke "saluran" yang dianggap. <br><br>  Setelah jawaban diterima, proses menentukan dan mendiskusikan kandidat ICE terbaik yang dikumpulkan oleh setiap pesta berlangsung.  Setelah kandidat ICE optimal dipilih, parameter data yang akan dipertukarkan antara rekan-rekan dan mekanisme routing jaringan (alamat IP dan port) disepakati. <br><br>  Kemudian, sesi soket jaringan aktif dibuat di antara rekan-rekan.  Selanjutnya, masing-masing rekan menciptakan aliran data lokal dan titik akhir saluran data, dan transmisi dua arah data multimedia mulai menggunakan teknologi yang diterapkan. <br><br>  Jika proses negosiasi untuk memilih kandidat ICE terbaik tidak berhasil, yang kadang-kadang terjadi karena kesalahan firewall dan sistem NAT, opsi cadangan digunakan, yang terdiri dalam menggunakan, sebagai relay, server TURN.  Proses ini melibatkan server yang bertindak sebagai perantara yang menyampaikan data yang dipertukarkan antar rekan.  Harap dicatat bahwa skema ini bukan koneksi P2P nyata di mana rekan-rekan mengirim data secara langsung satu sama lain. <br><br>  Saat menggunakan fallback menggunakan TURN untuk pertukaran data, setiap rekan tidak lagi perlu tahu cara berkomunikasi dengan orang lain dan cara mentransfer data ke sana.  Alih-alih, rekan perlu tahu server TURN eksternal mana yang perlu mengirim data multimedia secara real time dan dari server mana mereka perlu menerima selama sesi komunikasi. <br><br>  Penting untuk dipahami bahwa sekarang ini adalah cara cadangan untuk mengatur komunikasi.  TURN-server harus sangat andal, memiliki bandwidth yang besar dan daya komputasi yang serius, mendukung pekerjaan dengan data yang berpotensi besar.  Menggunakan server TURN, oleh karena itu, jelas mengarah pada biaya tambahan dan peningkatan kompleksitas sistem. <br><br><h2>  <font color="#3AC1EF">API WebRTC</font> </h2><br>  Ada tiga kategori utama API yang ada di WebRTC: <br><br><ul><li>  API Pengambilan Media dan Streaming bertanggung jawab atas penangkapan dan streaming media.  API ini memungkinkan Anda untuk terhubung ke perangkat input, seperti mikrofon dan webcam, dan menerima aliran media dari mereka. </li><li>  API RTCPeerConnection  Menggunakan API dari kategori ini, dimungkinkan, dari satu titik akhir WebRTC, untuk mengirim, secara real time, aliran data audio atau video yang ditangkap melalui Internet ke titik akhir lain dari WebRTC.  Menggunakan API ini, Anda dapat membuat koneksi antara mesin lokal dan rekan jauh.  Ini menyediakan metode untuk menghubungkan ke rekan jauh, untuk mengelola koneksi, dan untuk memantau statusnya.  Mekanismenya digunakan untuk menutup koneksi yang tidak perlu. </li><li>  API RTCDataChannel  Mekanisme yang diwakili oleh API ini memungkinkan transfer data sewenang-wenang.  Setiap saluran data dikaitkan dengan antarmuka RTCPeerConnection. </li></ul><br>  Mari kita bicara tentang API ini. <br><br><h2>  <font color="#3AC1EF">Pengambilan dan Aliran Media API</font> </h2><br>  Media Capture and Streams API, sering disebut sebagai Media Stream API atau Stream API, adalah API yang mendukung bekerja dengan aliran data audio dan video, metode untuk bekerja dengannya.  Dengan menggunakan API ini, Anda dapat menetapkan batasan terkait dengan tipe data, di sini ada panggilan balik untuk penyelesaian operasi yang berhasil dan tidak berhasil yang digunakan saat menggunakan mekanisme asinkron untuk bekerja dengan data, dan peristiwa yang dimunculkan selama operasi. <br><br>  Metode <code>getUserMedia()</code> dari <code>getUserMedia()</code> API meminta izin kepada pengguna untuk bekerja dengan perangkat input yang menghasilkan stream <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MediaStream</a> dengan trek audio atau video yang berisi jenis media yang diminta.  Aliran semacam itu dapat mencakup, misalnya, trek video (sumbernya adalah perangkat keras atau sumber video virtual, seperti kamera, perekam video, layanan berbagi layar, dll.), Trek audio (sumber audio fisik atau virtual juga dapat membentuknya, seperti mikrofon, konverter analog-ke-digital, dan sebagainya), dan mungkin jenis trek lainnya. <br><br>  Metode ini mengembalikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">janji</a> yang diselesaikan ke objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MediaStream</a> .  Jika pengguna menolak permintaan untuk izin atau media yang sesuai tidak tersedia, maka janji tersebut akan diselesaikan, masing-masing, dengan kesalahan <code>PermissionDeniedError</code> atau <code>NotFoundError</code> . <br><br>  Anda dapat mengakses singleton <code>MediaDevice</code> melalui objek <code>navigator</code> : <br><br><pre> <code class="hljs php">navigator.mediaDevices.getUserMedia(constraints) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> });</code> </pre> <br>  Perhatikan bahwa ketika Anda memanggil metode <code>getUserMedia()</code> , Anda harus memberikannya objek <code>constraints</code> yang memberi tahu API jenis aliran apa yang harus dikembalikan.  Di sini Anda dapat mengonfigurasi banyak hal, termasuk kamera yang ingin Anda gunakan (depan atau belakang), kecepatan bingkai, resolusi, dan sebagainya. <br><br>  Mulai dari versi 25, browser berbasis Chromium memungkinkan Anda mentransfer audio dari <code>getUserMedia()</code> elemen audio atau video (namun, perhatikan bahwa secara default elemen media akan dinonaktifkan). <br><br>  Metode <code>getUserMedia()</code> juga dapat digunakan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">simpul input untuk API Audio Web</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gotStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stream</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.AudioContext = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.AudioContext || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitAudioContext;   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> audioContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioContext();   <span class="hljs-comment"><span class="hljs-comment">//  AudioNode     var mediaStreamSource = audioContext.createMediaStreamSource(stream);   //       ,    ,   //       !   mediaStreamSource.connect(audioContext.destination); } navigator.getUserMedia({audio:true}, gotStream);</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Keterbatasan terkait dengan perlindungan informasi pribadi</font> </h2><br>  Pengambilan data tanpa izin dari mikrofon atau kamera adalah gangguan serius dengan kehidupan pribadi pengguna.  Oleh karena itu, penggunaan <code>getUserMedia()</code> menyediakan untuk penerapan persyaratan yang sangat spesifik untuk memberi tahu pengguna tentang apa yang terjadi dan untuk mengelola izin.  Metode <code>getUserMedia()</code> harus selalu mendapatkan izin pengguna sebelum membuka perangkat input apa pun yang mengumpulkan media, seperti webcam atau mikrofon.  Browser dapat menawarkan opsi pengaturan izin satu kali untuk suatu domain, tetapi mereka diharuskan untuk meminta izin setidaknya pertama kali mereka mengakses perangkat media, dan pengguna harus secara eksplisit memberikan izin tersebut. <br><br>  Selain itu, aturan yang terkait dengan memberi tahu pengguna tentang apa yang terjadi adalah penting di sini.  Browser diperlukan untuk menampilkan indikator yang menunjukkan penggunaan mikrofon atau kamera.  Tampilan indikator semacam itu tidak bergantung pada keberadaan indikator sistem perangkat keras yang mengindikasikan pengoperasian perangkat tersebut.  Selain itu, browser harus menunjukkan indikator bahwa izin untuk menggunakan perangkat input telah diberikan, bahkan jika perangkat tidak digunakan pada suatu waktu untuk merekam data yang relevan. <br><br><h2>  <font color="#3AC1EF">Antarmuka RTCPeerConnection</font> </h2><br>  Antarmuka RTCPeerConnection adalah koneksi WebRTC antara komputer lokal dan rekan jauh.  Ini menyediakan metode untuk menghubungkan ke sistem jarak jauh, untuk mendukung koneksi dan memantau statusnya, dan untuk menutup koneksi setelah tidak lagi diperlukan. <br><br>  Berikut adalah diagram arsitektur WebRTC yang menunjukkan peran RTCPeerConnection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/a16/dfe/4c0a16dfe63b400dc7082cd733ffa863.png"></div><br>  <i><font color="#999999">Peran RTCPeerConnection</font></i> <br><br>  Dari perspektif JavaScript, pengetahuan utama yang dapat diambil dari analisis diagram ini adalah bahwa RTCPeerConnection mengabstraksi pengembang web dari mekanisme kompleks yang terletak di level sistem yang lebih dalam.  Codec dan protokol yang digunakan oleh WebRTC melakukan pekerjaan yang baik untuk memungkinkan pertukaran data real-time, bahkan ketika menggunakan jaringan yang tidak terpercaya.  Berikut adalah beberapa tugas yang diselesaikan oleh mekanisme ini: <br><br><ul><li>  Masking packet loss. </li><li>  Pembatalan gema. </li><li>  Adaptasi Bandwidth. </li><li>  Penyangga dinamis untuk menghilangkan jitter. </li><li>  Kontrol volume otomatis. </li><li>  Pengurangan dan penindasan kebisingan. </li><li>  "Membersihkan" gambar. </li></ul><br><h2>  <font color="#3AC1EF">API RTCDataChannel</font> </h2><br>  Seperti halnya data audio dan video, WebRTC mendukung transmisi real-time dari tipe data lainnya.  API RTCDataChannel memungkinkan Anda untuk mengatur pertukaran data sewenang-wenang P2P. <br><br>  Ada banyak skenario untuk menggunakan API ini.  Inilah beberapa di antaranya: <br><br><ul><li>  Game </li><li>  Obrolan teks waktu-nyata. </li><li>  Transfer file. </li><li>  Organisasi jaringan desentralisasi. </li></ul><br>  API ini ditujukan untuk penggunaan kapabilitas RTCPeerConnection API yang paling efisien dan memungkinkan Anda untuk mengatur sistem pertukaran data yang kuat dan fleksibel dalam lingkungan P2P.  Di antara fitur-fiturnya adalah sebagai berikut: <br><br><ul><li>  Bekerja efektif dengan sesi menggunakan RTCPeerConnection. </li><li>  Dukungan untuk beberapa saluran komunikasi yang digunakan secara bersamaan dengan penentuan prioritas. </li><li>  Dukungan untuk metode pengiriman pesan yang andal dan tidak dapat diandalkan. </li><li>  Manajemen Keamanan Terpadu (DTLS) dan Kemacetan. </li></ul><br>  Sintaks di sini mirip dengan yang digunakan ketika bekerja dengan teknologi WebSocket.  Metode <code>send()</code> dan acara <code>message</code> diterapkan di sini: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> peerConnection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webkitRTCPeerConnection(servers,   {<span class="hljs-attr"><span class="hljs-attr">optional</span></span>: [{<span class="hljs-attr"><span class="hljs-attr">RtpDataChannels</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]} ); peerConnection.ondatachannel = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   receiveChannel = event.channel;   receiveChannel.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{       <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"#receiver"</span></span>).innerHTML = event.data;   }; }; sendChannel = peerConnection.createDataChannel(<span class="hljs-string"><span class="hljs-string">"sendDataChannel"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">reliable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"button#send"</span></span>).onclick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">"textarea#send"</span></span>).value;   sendChannel.send(data); }</code> </pre> <br><h2>  <font color="#3AC1EF">WebRTC di dunia nyata</font> </h2><br>  Di dunia nyata, komunikasi WebRTC membutuhkan server.  Sistem tidak terlalu rumit, terima kasih kepada mereka, urutan tindakan berikut diterapkan: <br><br><ul><li>  Pengguna saling menemukan dan bertukar informasi tentang satu sama lain, misalnya nama. </li><li>  Aplikasi klien WebRTC (rekan) bertukar informasi jaringan. </li><li>  Peers bertukar informasi tentang data media, seperti format dan resolusi video. </li><li>  Aplikasi klien WebRTC membuat koneksi melewati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gateway NAT</a> dan firewall. </li></ul><br>  Dengan kata lain, WebRTC membutuhkan empat jenis fungsi server: <br><br><ul><li>  Berarti untuk menemukan pengguna dan mengatur interaksi mereka. </li><li>  Pemberian sinyal. </li><li>  Lewati NAT dan firewall. </li><li>  Relay server digunakan ketika koneksi P2P tidak dapat dibuat. </li></ul><br>  Protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STUN</a> dan ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MENGHIDUPKAN</a> digunakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ICE</a> untuk memungkinkan RTCPeerConnection untuk bekerja dengan mekanisme bypass NAT dan untuk mengatasi kesulitan lain yang dihadapi ketika mengirimkan data melalui jaringan. <br><br>  Seperti yang telah disebutkan, ICE adalah protokol untuk menghubungkan rekan, seperti dua klien obrolan video.  Pada awal sesi komunikasi, ICE mencoba untuk menghubungkan rekan secara langsung, dengan penundaan sesedikit mungkin, melalui UDP.  Selama proses ini, server STUN memiliki satu tugas: untuk membiarkan rekan di belakang NAT mempelajari alamat dan port publiknya.  Lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar</a> server STUN yang tersedia ini (Google juga memiliki server semacam itu). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/935/4e9/1a09354e9eb986043dc153ffb8b82500.png"></div><br>  <i><font color="#999999">STUN server</font></i> <br><br><h2>  <font color="#3AC1EF">Deteksi Kandidat ICE</font> </h2><br>  Jika koneksi UDP tidak dapat dibangun, ICE mencoba membuat koneksi TCP: first - over HTTP, then - over HTTPS.  Jika koneksi langsung tidak dapat dibuat - khususnya, karena ketidakmampuan untuk memotong NAT perusahaan dan firewall, ICE menggunakan perantara (relay) dalam bentuk server TURN.  Dengan kata lain, ICE pertama-tama akan mencoba menggunakan STUN dengan UDP untuk koneksi langsung dari rekan-rekan, dan jika ini tidak berhasil, ia akan menggunakan opsi mundur dengan penyewa dalam bentuk server MENGHIDUPKAN.  Istilah "pencarian kandidat" mengacu pada proses mencari antarmuka dan port jaringan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80d/c0a/41b/80dc0a41b9c4f59966b325e95c99e9c3.png"></div><br>  <i><font color="#999999">Menemukan antarmuka dan port jaringan yang sesuai</font></i> <br><br><h2>  <font color="#3AC1EF">Keamanan</font> </h2><br>  Aplikasi komunikasi waktu nyata atau plugin terkait dapat menyebabkan masalah keamanan.  Secara khusus, kita berbicara tentang hal-hal berikut: <br><br><ul><li>  Data media yang tidak terenkripsi atau data lain dapat dicegat di sepanjang jalur antara browser, atau antara browser dan server. </li><li>  Aplikasi dapat, tanpa sepengetahuan pengguna, merekam dan mengirimkan data video dan audio ke penyerang. </li><li>  Bersama-sama dengan plug-in atau aplikasi yang tampak tidak berbahaya, virus atau perangkat lunak berbahaya lainnya bisa sampai ke komputer pengguna. </li></ul><br>  WebRTC memiliki beberapa mekanisme yang dirancang untuk menangani ancaman ini: <br><br><ul><li>  Implementasi WebRTC menggunakan protokol aman seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DTLS</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SRTP</a> . </li><li>  Untuk semua komponen sistem WebRTC, penggunaan enkripsi adalah wajib.  Ini juga berlaku untuk mekanisme pensinyalan. </li><li>  WebRTC bukan plugin.  Komponen WebRTC berjalan di kotak pasir peramban, dan tidak dalam proses terpisah.  Komponen diperbarui ketika browser diperbarui. </li><li>  Akses ke kamera dan mikrofon harus diberikan secara eksplisit.  Dan, ketika kamera atau mikrofon digunakan, fakta ini jelas ditampilkan di antarmuka pengguna browser. </li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  WebRTC adalah teknologi yang sangat menarik dan kuat untuk proyek-proyek yang menggunakan transfer data apa pun antar browser secara real time.  Penulis materi mengatakan bahwa perusahaannya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SessionStack</a> , menggunakan mekanisme tradisional untuk bertukar data dengan pengguna, yang melibatkan penggunaan server.  Namun, jika mereka menggunakan WebRTC untuk memecahkan masalah yang terkait, ini akan memungkinkan pengorganisasian pertukaran data secara langsung antara browser, yang akan menyebabkan penurunan keterlambatan dalam transfer data dan untuk mengurangi beban pada infrastruktur perusahaan. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan teknologi WebRTC dalam proyek Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416821/">https://habr.com/ru/post/id416821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416809/index.html">Model snooker Elo dan EloBet</a></li>
<li><a href="../id416813/index.html">Ketika 2 x 3 = 2, atau sekali lagi tentang virtualisasi data</a></li>
<li><a href="../id416815/index.html">Bagaimana kami berhenti menghabiskan satu minggu mengeluarkan dev-stand</a></li>
<li><a href="../id416817/index.html">Posisi Ketiga dalam tahap kualifikasi DataScienceGame 2018</a></li>
<li><a href="../id416819/index.html">Perpisahan, microservices: dari seratus anak bermasalah hingga satu superstar</a></li>
<li><a href="../id416823/index.html">Darah, Keringat, dan Piksel: Tentang Buku Jason Schreier</a></li>
<li><a href="../id416825/index.html">Bagaimana TIDAK menjadi pengembang biasa-biasa saja</a></li>
<li><a href="../id416827/index.html">Kontainer Dewasa (Bagian 02): Panduan Praktis untuk Terminologi</a></li>
<li><a href="../id416829/index.html">Pola Model ABI v0.5.6 Beta</a></li>
<li><a href="../id416831/index.html">Routing eksternal dari lalu lintas domestik Rusia akan dikurangi menjadi 5%</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>