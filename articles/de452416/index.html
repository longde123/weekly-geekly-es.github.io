<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèΩ üê∏ üë©üèº‚Äçüé® Skelettanimation an der Seite der Grafikkarte ‚õπüèæ üíè üôèüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unity hat k√ºrzlich ECS eingef√ºhrt. W√§hrend des Studiums interessierte ich mich daf√ºr, wie Animation und ECS Freunde werden k√∂nnen. Und im Suchprozess ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Skelettanimation an der Seite der Grafikkarte</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452416/"><p>  Unity hat k√ºrzlich ECS eingef√ºhrt.  W√§hrend des Studiums interessierte ich mich daf√ºr, wie Animation und ECS Freunde werden k√∂nnen.  Und im Suchprozess bin ich auf eine interessante Technik gesto√üen, die die Jungs von NORDVEUS in ihrer Demo f√ºr den Unite Austin 2017-Bericht verwendet haben. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unite Austin 2017 - Massive Schlacht im Spellsouls-Universum.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </p><br><p>  Der Bericht enth√§lt viele interessante L√∂sungen, aber heute werden wir die Erhaltung der Skelettanimation in der Textur im Hinblick auf ihre weitere Anwendung diskutieren. </p><br><p>  Warum solche Schwierigkeiten, fragst du? </p><br><p>  Die Jungs von NORDVEUS haben gleichzeitig eine gro√üe Anzahl derselben Art von animiertem Objekt auf den Bildschirm gemalt: Skelette, Schwertk√§mpfer.  Bei Verwendung des herk√∂mmlichen Ansatzes: <u>SkinnedMeshRenderers</u> und <u>Animation \ Animator</u> werden die Zeichnungsaufrufe erh√∂ht und die CPU f√ºr das Rendern der Animation zus√§tzlich belastet.  Um diese Probleme zu l√∂sen, wurde die Animation auf die Seite der GPU bzw. auf den Vertex-Shader verschoben. </p><br><a name="habracut"></a><br><p>  Ich war sehr interessiert an dem Ansatz und beschloss, ihn genauer herauszufinden. Da ich keine Artikel zu diesem Thema fand, ging ich in den Code ein.  W√§hrend des Studiums des Problems wurde dieser Artikel geboren und meine Vision, dieses Problem zu l√∂sen. </p><br><h4>  Also schneiden wir den Elefanten in St√ºcke: </h4><br><br><ul><li>  Abrufen von Animationstasten aus Clips </li><li>  Speichern von Daten in der Textur </li><li>  Netzvorbereitung </li><li>  Shader </li><li>  Alles zusammenf√ºgen </li></ul><br><br><h4>  Abrufen von Animationstasten aus Animationsclips </h4><br><p>  Aus den Komponenten von <u>SkinnedMeshRenderers erhalten wir</u> eine Reihe von Bones und ein Mesh.  Die <u>Animationskomponente</u> bietet eine Liste der verf√ºgbaren Animationen.  Daher m√ºssen wir f√ºr jeden Clip die Transformationsmatrix Frame f√ºr Frame f√ºr alle Knochen des Netzes speichern.  Mit anderen Worten, wir behalten die Pose des Charakters pro Zeiteinheit bei. </p><br><p>  Wir w√§hlen ein zweidimensionales Array aus, in dem die Daten gespeichert werden.  Eine Dimension hat die Anzahl der Frames multipliziert mit der L√§nge des Clips in Sekunden.  Ein weiterer Grund ist die Gesamtzahl der Knochen im Netz: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneMatrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matrix4x4[Mathf.CeilToInt(frameRate * clip.length), renderer.bones.Length];</code> </pre> <br><p>  Im folgenden Beispiel √§ndern wir die Frames f√ºr den Clip nacheinander und speichern die Matrizen: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//       for (var frameIndex = 0; frameIndex &lt; totalFramesInClip; ++frameIndex) { //  : 0 -  , 1 - . var normalizedTime = (float) frameIndex / totalFramesInClip; //     animationState.normalizedTime = normalizedTime; animation.Sample(); //     for (var boneIndex = 0; j &lt; renderer.bones.Length; boneIndex++) { //         var matrix = renderer.bones[boneIndex].localToWorldMatrix * renderer.sharedMesh.bindposes[boneIndex]; //   boneMatrices[i, j] = matrix; } }</span></span></code> </pre><br><p>  Matrizen sind 4 mal 4, aber die letzte Zeile sieht immer so aus (0, 0, 0, 1).  Daher kann es zum Zwecke einer leichten Optimierung √ºbersprungen werden.  Dies reduziert wiederum die Kosten f√ºr die Daten√ºbertragung zwischen dem Prozessor und der Grafikkarte. </p><br><pre> <code class="plaintext hljs">a00 a01 a02 a03 a10 a11 a12 a13 a20 a21 a22 a23 0 0 0 1</code> </pre><br><h4>  Speichern von Daten in der Textur </h4><br><p>  Um die Gr√∂√üe der Textur zu berechnen, multiplizieren wir die Gesamtzahl der Frames in allen Animationsclips mit der Anzahl der Bones und der Anzahl der Zeilen in der Matrix (wir waren uns einig, dass wir die ersten 3 Zeilen speichern). </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataSize = numberOfBones * numberOfKeyFrames * MATRIX_ROWS_COUNT); <span class="hljs-comment"><span class="hljs-comment">//      var size = NextPowerOfTwo((int) Math.Sqrt(dataSize)); var texture = new Texture2D(size, size, TextureFormat.RGBAFloat, false) { wrapMode = TextureWrapMode.Clamp, filterMode = FilterMode.Point, anisoLevel = 0 };</span></span></code> </pre><br><p>  Wir schreiben die Daten in die Textur.  F√ºr jeden Clip speichern wir die Transformationsmatrix Frame f√ºr Frame.  Das Datenformat ist wie folgt.  Clips werden nacheinander aufgenommen und bestehen aus einer Reihe von Frames.  Was wiederum aus einer Reihe von Knochen besteht.  Jeder Knochen enth√§lt 3 Matrixreihen. </p><br><pre> <code class="plaintext hljs">Clip0[Frame0[Bone0[row0,row1,row2]...BoneN[row0,row1,row2].]...FramM[bone0[row0,row1,row2]...ClipK[...]</code> </pre><br><p>  Das Folgende ist der Speichercode: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> textureColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[texture.width * texture.height]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clipOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clipIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; clipIndex &lt; sampledBoneMatrices.Count; clipIndex++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> framesCount = sampledBoneMatrices[clipIndex].GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyframeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; keyframeIndex &lt; framesCount; keyframeIndex++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frameOffset = keyframeIndex * numberOfBones * <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; boneIndex &lt; numberOfBones; boneIndex++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = clipOffset + frameOffset + boneIndex * <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = sampledBoneMatrices[clipIndex][keyframeIndex, boneIndex]; textureColor[index + <span class="hljs-number"><span class="hljs-number">0</span></span>] = matrix.GetRow(<span class="hljs-number"><span class="hljs-number">0</span></span>); textureColor[index + <span class="hljs-number"><span class="hljs-number">1</span></span>] = matrix.GetRow(<span class="hljs-number"><span class="hljs-number">1</span></span>); textureColor[index + <span class="hljs-number"><span class="hljs-number">2</span></span>] = matrix.GetRow(<span class="hljs-number"><span class="hljs-number">2</span></span>); } } } texture.SetPixels(textureColor); texture.Apply(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h4>  Netzvorbereitung </h4><br><p>  F√ºgen Sie einen zus√§tzlichen Satz von Texturkoordinaten hinzu, f√ºr die wir f√ºr jeden Scheitelpunkt die zugeh√∂rigen Knochenindizes und das Gewicht des Einflusses des Knochens auf diesen Scheitelpunkt speichern. <br>  Unity bietet eine Datenstruktur, in der bis zu 4 Knochen f√ºr einen Scheitelpunkt m√∂glich sind.  Unten finden Sie den Code zum Schreiben dieser Daten in UV.  Wir speichern Knochenindizes in UV1, Gewichte in UV2. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneWeights = mesh.boneWeights; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector4&gt;(mesh.vertexCount); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boneInfluences = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector4&gt;(mesh.vertexCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mesh.vertexCount; i++) { boneIds.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(bw.boneIndex0, bw.boneIndex1, bw.boneIndex2, bw.boneIndex3); boneInfluences.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(bw.weight0, bw.weight1, bw.weight2, bw.weight3)); } mesh.SetUVs(<span class="hljs-number"><span class="hljs-number">1</span></span>, boneIds); mesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, boneInfluences);</code> </pre><br><h4>  Shader </h4><br><p>  Die Hauptaufgabe des Shaders besteht darin, die Transformationsmatrix f√ºr den mit dem Scheitelpunkt verbundenen Knochen zu finden und die Koordinaten des Scheitelpunkts mit dieser Matrix zu multiplizieren.  Dazu ben√∂tigen wir einen zus√§tzlichen Satz von Koordinaten mit Indizes und Knochengewichten.  Wir brauchen auch den Index des aktuellen Frames, er √§ndert sich im Laufe der Zeit und wird von der CPU √ºbertragen. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// frameOffset = clipOffset + frameIndex * clipLength * 3 -     CPU // boneIndex -      ,   UV1 int index = frameOffset + boneIndex * 3;</span></span></code> </pre><br><p>  Wir haben also den Index der ersten Zeile der Matrix erhalten, der Index der zweiten und dritten Zeile ist +1 bzw. +2.  Es bleibt, den eindimensionalen Index in die normalisierten Koordinaten der Textur zu √ºbersetzen, und daf√ºr ben√∂tigen wir die Gr√∂√üe der Textur. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexToUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, float2 size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(index % size.x)) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) / size.x, ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(index / size.x)) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) / size.y, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p>  Nachdem wir die Zeilen subtrahiert haben, sammeln wir die Matrix, ohne die letzte Zeile zu vergessen, die immer gleich (0, 0, 0, 1) ist. </p><br><pre> <code class="cpp hljs">float4 row0 = tex2Dlod(frameOffset, IndexToUV(index + <span class="hljs-number"><span class="hljs-number">0</span></span>, animationTextureSize)); float4 row1 = tex2Dlod(frameOffset, IndexToUV(index + <span class="hljs-number"><span class="hljs-number">1</span></span>, animationTextureSize)); float4 row2 = tex2Dlod(frameOffset, IndexToUV(index + <span class="hljs-number"><span class="hljs-number">2</span></span>, animationTextureSize)); float4 row3 = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4x4(row0, row1, row2, row3);</code> </pre><br><p>  Gleichzeitig k√∂nnen mehrere Knochen gleichzeitig einen Scheitelpunkt beeinflussen.  Die resultierende Matrix ist die Summe aller Matrizen, die den Scheitelpunkt beeinflussen, multipliziert mit dem Gewicht ihres Einflusses. </p><br><pre> <code class="cpp hljs">float4x4 m0 = CreateMatrix(frameOffset, bones.x) * boneInfluences.x; float4x4 m1 = CreateMatrix(frameOffset, bones.y) * boneInfluences.y; float4x4 m2 = CreateMatrix(frameOffset, bones.z) * boneInfluences.z; float4x4 m3 = CreateMatrix(frameOffset, bones.w) * boneInfluences.w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m0 + m1 + m2 + m3;</code> </pre><br><p>  Nachdem wir die Matrix erhalten haben, multiplizieren wir sie mit den Koordinaten des Scheitelpunkts.  Daher werden alle Scheitelpunkte in die Pose des Charakters verschoben, die dem aktuellen Frame entspricht.  Wenn Sie den Rahmen √§ndern, werden wir den Charakter animieren. </p><br><h4>  Alles zusammenf√ºgen </h4><br><p>  Zum Anzeigen von Objekten verwenden wir Graphics.DrawMeshInstancedIndirect, in das wir das vorbereitete Netz und Material √ºbertragen.  Au√üerdem m√ºssen wir im Material die Textur mit Animationen an die Texturgr√∂√üe und ein Array mit Zeigern auf den Rahmen f√ºr jedes Objekt zur aktuellen Zeit √ºbergeben.  Als zus√§tzliche Information √ºbergeben wir die Position f√ºr jedes Objekt und die Drehung.  Informationen zum √Ñndern der Position und Drehung auf der Shader-Seite finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[Artikel]</a> . </p><br><p>  Erh√∂hen Sie bei der Aktualisierungsmethode die Zeit, die seit Beginn der Animation in Time.deltaTime vergangen ist. </p><br><p>  Um den Frame-Index zu berechnen, m√ºssen wir die Zeit normalisieren, indem wir sie durch die L√§nge des Clips dividieren.  Daher ist der Frame-Index im Clip das Produkt der normalisierten Zeit durch die Anzahl der Frames.  Der Frame-Index in der Textur ist die Summe der Verschiebung des Beginns des aktuellen Clips und des Produkts des aktuellen Frames um die in diesem Frame gespeicherte Datenmenge. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offset = clipStart + frameIndex * bonesCount * <span class="hljs-number"><span class="hljs-number">3.0f</span></span></code> </pre> <br><p>  Nachdem wahrscheinlich alle Daten an den Shader √ºbergeben wurden, rufen wir Graphics.DrawMeshInstancedIndirect mit dem vorbereiteten Netz und Material auf. </p><br><h4>  Schlussfolgerungen </h4><br><p>  Das Testen dieser Technik auf einem Computer mit einer 1050-Grafikkarte ergab eine Leistungssteigerung von etwa dem Zweifachen. </p><br><img src="https://habrastorage.org/webt/yz/a-/iv/yza-ivxgj5ccdyb7kxomb2smgxm.png" alt="Bild"><br><p>  Animation von 4000 Objekten des gleichen Typs auf der CPU </p><br><img src="https://habrastorage.org/webt/xd/73/e1/xd73e1eil8yq1qjo134kx77cbna.png" alt="Bild"><br><p>  Animation von 8000 Objekten des gleichen Typs auf der GPU </p><br><p>  Gleichzeitig zeigt das Testen dieser Szene auf einem MacBook Pro 15 mit integrierter Grafikkarte das gegenteilige Ergebnis.  Die GPU verliert schamlos (ca. 2-3 mal), was nicht √ºberraschend ist. </p><br><p>  Die Animation auf der Grafikkarte ist ein weiteres Tool, das in Ihrer Anwendung verwendet werden kann.  Aber wie alle Werkzeuge sollte es mit Bedacht und unangebracht eingesetzt werden. </p><br><h4>  Referenzen </h4><br><br><ul><li>  Animationsinstanzierung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instanzierung f√ºr SkinnedMeshRenderer</a> </li><li>  GPUSkinning - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verbessern Sie die Leistung.</a> </li><li>  UniteAustinTechnicalPresentation - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ECS-Demo</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[GitHub-Projektcode]</a> <br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit. </p><br><p>  PS: Ich bin neu in Unity und kenne nicht alle Feinheiten. Der Artikel enth√§lt m√∂glicherweise Ungenauigkeiten.  Ich hoffe, sie mit Ihrer Hilfe zu beheben und das Thema besser zu verstehen. </p><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452416/">https://habr.com/ru/post/de452416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452404/index.html">F√ºnf wichtige ITSM-Trends f√ºr dieses Jahr</a></li>
<li><a href="../de452408/index.html">Maine Coon Toilette</a></li>
<li><a href="../de452410/index.html">Bash-Start im Detail</a></li>
<li><a href="../de452412/index.html">Datenschutz, IoT und Mozilla WebThings</a></li>
<li><a href="../de452414/index.html">HP Reverb - √úberpr√ºfung des neuen VR-Sets</a></li>
<li><a href="../de452418/index.html">Wie erstelle ich eine Produktpr√§sentation, die den Kunden anspricht?</a></li>
<li><a href="../de452424/index.html">Ein Heliummangel kann die Entwicklung von Quantencomputern verlangsamen und die Situation diskutieren</a></li>
<li><a href="../de452426/index.html">Anmelden bei Azure DevOps mit GitHub-Anmeldeinformationen</a></li>
<li><a href="../de452428/index.html">Schnelles Yandex-W√∂rterbuch</a></li>
<li><a href="../de452430/index.html">QA: Hackathons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>