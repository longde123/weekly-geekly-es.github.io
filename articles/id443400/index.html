<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚼 👩🏿‍🔧 🏴‍☠️ Menghitung Bug di Windows Calculator 🙆🏿 🧗🏿 👨🏿‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa hari yang lalu, Microsoft membuat kode sumber Kalkulator Windows mereka tersedia untuk umum. Kalkulator adalah aplikasi yang secara tradision...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menghitung Bug di Windows Calculator</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/443400/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/6f/da/q8/6fdaq8pfgpkoynkt0qwqvljuj7e.png"></div><br>  Beberapa hari yang lalu, Microsoft membuat kode sumber Kalkulator Windows mereka tersedia untuk umum.  Kalkulator adalah aplikasi yang secara tradisional dikirimkan dengan setiap versi Windows.  Sejumlah proyek Microsoft menjadi open-source selama beberapa tahun terakhir, tetapi kali ini beritanya diliput bahkan oleh media non-IT pada hari pertama.  Ya, ini adalah program yang populer namun kecil di C ++.  Terlepas dari ukurannya, kami masih berhasil menemukan sejumlah fragmen yang mencurigakan dalam kodenya menggunakan analisa statis PVS-Studio. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Saya tidak berpikir kita perlu memperkenalkan Kalkulator karena Anda tidak akan menemukan pengguna Windows yang tidak tahu apa itu.  Sekarang siapa pun dapat mengunduh kode sumber aplikasi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> dan menyarankan peningkatannya. <br><br>  Fungsi berikut, misalnya, sudah menarik perhatian komunitas: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TraceLogger::LogInvalidInputPasted(....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetTraceLoggingProviderEnabled()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><pre> <code class="cpp hljs"> LoggingFields fields{}; fields.AddString(<span class="hljs-string"><span class="hljs-string">L"Mode"</span></span>, NavCategory::GetFriendlyName(mode)-&gt;Data()); fields.AddString(<span class="hljs-string"><span class="hljs-string">L"Reason"</span></span>, reason); fields.AddString(<span class="hljs-string"><span class="hljs-string">L"PastedExpression"</span></span>, pastedExpression); fields.AddString(<span class="hljs-string"><span class="hljs-string">L"ProgrammerNumberBase"</span></span>, GetProgrammerType(...).c_str()); fields.AddString(<span class="hljs-string"><span class="hljs-string">L"BitLengthType"</span></span>, GetProgrammerType(bitLengthType).c_str()); LogTelemetryEvent(EVENT_NAME_INVALID_INPUT_PASTED, fields); }</code> </pre> <br>  Fungsi ini mencatat teks dari clipboard dan mengirimkannya ke server Microsoft.  Namun, pos ini bukan tentang fungsi itu, tetapi Anda pasti akan melihat banyak cuplikan yang mencurigakan. <br><br>  Kami menggunakan analisa statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> untuk memeriksa kode sumber Kalkulator.  Karena tidak ditulis dalam standar C ++, banyak pembaca reguler kami meragukan cek semacam itu akan mungkin, tetapi kami melakukannya.  Alat analisis mendukung C ++ / CLI dan C ++ / CX, dan meskipun beberapa diagnostik memang menghasilkan beberapa kesalahan positif, kami tidak menemukan masalah kritis yang akan menghambat pekerjaan PVS-Studio. <br><br>  Sama seperti pengingat, jika Anda ketinggalan berita tentang kemampuan lain dari alat kami, PVS-Studio tidak hanya mendukung C dan C ++ tetapi C # dan Java juga. <br><br><h2>  Perbandingan string salah </h2><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> 'm_resolvedName == L "en-US"' selalu salah.  Untuk membandingkan string, Anda harus menggunakan fungsi wcscmp ().  Kalkulator LocalizationSettings.h 180 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> m_resolvedName[LOCALE_NAME_MAX_LENGTH]; Platform::String^ GetEnglishValueFromLocalizedDigits(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_resolvedName == <span class="hljs-string"><span class="hljs-string">L"en-US"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ref <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Platform::String(localizedString.c_str()); } .... }</code> </pre> <br>  Saat melihat laporan penganalisa, saya mengurutkan peringatan dengan kode diagnostik dalam urutan menaik, dan yang ini, yang membuat contoh yang sangat jelas, adalah yang pertama dalam daftar. <br><br>  Anda lihat, contoh di atas menunjukkan perbandingan string yang salah.  Programmer sebenarnya membandingkan pointer daripada nilai string dengan membandingkan alamat array karakter dengan string literal.  Pointer ini tidak pernah sama, jadi kondisinya selalu salah juga.  Untuk perbandingan string yang benar, seseorang harus menggunakan fungsi <i>wcscmp</i> , misalnya. <br><br>  Ngomong-ngomong, ketika saya sedang menulis artikel ini, array karakter <i>m_resolvedName</i> diperbaiki dalam file header dan menjadi string tipe <i>std :: wstring</i> , sehingga perbandingan dapat dilakukan dengan benar sekarang.  Pada saat Anda akan membaca artikel ini, banyak bug lain mungkin akan diperbaiki juga berkat para penggemar dan ulasan seperti ini. <br><br><h2>  Kebocoran memori dalam kode asli </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V773</a> Fungsi itu keluar tanpa melepaskan pointer 'temp'.  Kebocoran memori dimungkinkan.  CalcViewModel StandardCalculatorViewModel.cpp 529 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> StandardCalculatorViewModel::HandleUpdatedOperandData(Command cmdenum) { .... <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>* temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>[<span class="hljs-number"><span class="hljs-number">100</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (commandIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] temp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... length = m_selectedExpressionLastData-&gt;Length() + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... String^ updatedData = ref <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(temp); UpdateOperand(m_tokenPosition, updatedData); displayExpressionToken-&gt;Token = updatedData; IsOperandUpdatedUsingViewModel = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; displayExpressionToken-&gt;CommandIndex = commandIndex; }</code> </pre> <br>  Pointer <i>temp</i> merujuk ke array 100 elemen yang dialokasikan secara dinamis.  Sayangnya, memori dilepaskan hanya di satu bagian dari fungsi, sementara sisanya berakhir dengan kebocoran memori.  Ini tidak terlalu buruk, tetapi masih dianggap sebagai bug dalam kode C ++. <br><br><h2>  Pengecualian yang sulit dipahami </h2><br>  Kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V702</a> harus selalu diturunkan dari std :: exception (dan yang sama) sebagai 'publik' (tidak ada kata kunci yang ditentukan, jadi kompiler secara default ke 'private').  CalcManager CalcException.h 4 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CalcException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CalcException(HRESULT hr) { m_hr = hr; } <span class="hljs-function"><span class="hljs-function">HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_hr; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HRESULT m_hr; };</code> </pre> <br>  Penganalisis telah mendeteksi kelas yang berasal dari kelas <i>std :: exception</i> menggunakan pengubah <i>pribadi</i> (yang default jika tidak ada pengubah lain yang ditentukan).  Masalah dengan kode ini adalah bahwa pawang akan mengabaikan pengecualian tipe <i>CalcException</i> ketika mencoba untuk menangkap <i>std ::</i> generic generic karena warisan pribadi melarang konversi tipe implisit. <br><br><h2>  Hari yang terlewat </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V719</a> Pernyataan beralih tidak mencakup semua nilai enum 'DateUnit': Hari.  CalcViewModel DateCalculator.cpp 279 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum_is_bitflag_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DateUnit</span></span></span><span class="hljs-class"> {</span></span> Year = <span class="hljs-number"><span class="hljs-number">0x01</span></span>, Month = <span class="hljs-number"><span class="hljs-number">0x02</span></span>, Week = <span class="hljs-number"><span class="hljs-number">0x04</span></span>, Day = <span class="hljs-number"><span class="hljs-number">0x08</span></span> }; Windows::Globalization::Calendar^ m_calendar; DateTime DateCalculationEngine::AdjustCalendarDate(Windows::Foundation::DateTime date, DateUnit dateUnit, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> difference) { m_calendar→SetDateTime(date); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (dateUnit) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DateUnit::Year: { .... m_calendar-&gt;AddYears(difference); m_calendar-&gt;ChangeCalendarSystem(currentCalendarSystem); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DateUnit::Month: m_calendar-&gt;AddMonths(difference); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DateUnit::Week: m_calendar-&gt;AddWeeks(difference); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_calendar-&gt;GetDateTime(); }</code> </pre> <br>  Sangat mencurigakan bahwa pernyataan beralih tidak memiliki kasus <i>DateUnit :: Hari</i> .  Karena itu, nilai hari tidak akan ditambahkan ke kalender (variabel <i>m_calendar</i> ), meskipun kalender tersebut memiliki metode <i>AddDays</i> . <br><br>  Kasus mencurigakan lainnya dengan enumerasi lain: <br><br><ul><li>  V719 Pernyataan sakelar tidak mencakup semua nilai enum 'eANGLE_TYPE': ANGLE_RAD.  CalcManager trans.cpp 109 </li><li>  V719 Pernyataan sakelar tidak mencakup semua nilai enum 'eANGLE_TYPE': ANGLE_RAD.  CalcManager trans.cpp 204 </li><li>  V719 Pernyataan sakelar tidak mencakup semua nilai enum 'eANGLE_TYPE': ANGLE_RAD.  CalcManager trans.cpp 276 </li></ul><br><h2>  Perbandingan angka nyata yang mencurigakan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V550</a> Perbandingan akurat yang aneh: rasio == ambang batas.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B) &lt;Epsilon.  Calculator AspectRatioTrigger.cpp 80 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AspectRatioTrigger::UpdateIsActive(Size sourceSize) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> numerator, denominator; .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (denominator &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ratio = numerator / denominator; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> threshold = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(Threshold); isActive = ((ratio &gt; threshold) || (ActiveIfEqual &amp;&amp; (ratio == threshold))); } SetActive(isActive); }</code> </pre> <br>  Penganalisis menunjukkan <i>rasio</i> ekspresi mencurigakan <i>== ambang batas</i> .  Variabel-variabel ini bertipe <i>ganda</i> dan, oleh karena itu, hampir tidak dapat dibandingkan secara tepat menggunakan operator biasa yang sama.  Selain itu, nilai variabel <i>rasio</i> adalah hasil dari operasi divisi. <br><br>  Kode seperti itu terlihat sangat aneh dalam aplikasi seperti Kalkulator.  Saya menyertakan daftar lengkap peringatan jenis ini untuk berjaga-jaga: <br><br><ul><li>  V550 Perbandingan presisi yang aneh.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B) &lt;Epsilon.  CalcManager UnitConverter.cpp 752 </li><li>  V550 Perbandingan akurat yang aneh: stod (roundedString)! = 0,0.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B)&gt; Epsilon.  CalcManager UnitConverter.cpp 778 </li><li>  V550 Perbandingan presisi yang aneh.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B) &lt;Epsilon.  CalcManager UnitConverter.cpp 790 </li><li>  V550 Perbandingan akurat yang aneh: stod (roundedString)! = 0,0.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B)&gt; Epsilon.  CalcManager UnitConverter.cpp 820 </li><li>  V550 Perbandingan akurat yang aneh: conversionTable [m_toType] .ratio == 1.0.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B) &lt;Epsilon.  CalcManager UnitConverter.cpp 980 </li><li>  V550 Perbandingan akurat yang aneh: conversionTable [m_toType] .offset == 0,0.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B) &lt;Epsilon.  CalcManager UnitConverter.cpp 980 </li><li>  V550 Perbandingan akurat yang aneh: returnValue! = 0. Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B)&gt; Epsilon.  CalcManager UnitConverter.cpp 1000 </li><li>  V550 Perbandingan presisi yang aneh: sizeToUse! = 0,0.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B)&gt; Epsilon.  CalcViewModel LocalizationService.cpp 270 </li><li>  V550 Perbandingan presisi yang aneh: sizeToUse! = 0,0.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B)&gt; Epsilon.  CalcViewModel LocalizationService.cpp 289 </li><li>  V550 Perbandingan presisi yang aneh: sizeToUse! = 0,0.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B)&gt; Epsilon.  CalcViewModel LocalizationService.cpp 308 </li><li>  V550 Perbandingan presisi yang aneh: sizeToUse! = 0,0.  Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B)&gt; Epsilon.  CalcViewModel LocalizationService.cpp 327 </li><li>  V550 Perbandingan akurat yang aneh: stod (stringToLocalize) == 0. Mungkin lebih baik menggunakan perbandingan dengan presisi yang ditentukan: fabs (A - B) &lt;Epsilon.  CalcViewModel UnitConverterViewModel.cpp 388 </li></ul><br><h2>  Urutan fungsi yang mencurigakan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1020</a> Fungsi keluar tanpa memanggil fungsi 'TraceLogger :: GetInstance (). LogNewWindowCreationEnd'.  Periksa baris: 396, 375. Aplikasi Kalkulator.xaml.cpp 396 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> App::OnAppLaunch(IActivatedEventArgs^ args, String^ argument) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_preLaunched) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> newCoreAppView = CoreApplication::CreateNewView(); newCoreAppView-&gt;Dispatcher-&gt;RunAsync(....([....]() { TraceLogger::GetInstance().LogNewWindowCreationBegin(....); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Begin .... TraceLogger::GetInstance().LogNewWindowCreationEnd(....); // &lt;= End })); } else { TraceLogger::GetInstance().LogNewWindowCreationBegin(....); // &lt;= Begin ActivationViewSwitcher^ activationViewSwitcher; auto activateEventArgs = dynamic_cast&lt;IViewSwitcherProvider^&gt;(args); if (activateEventArgs != nullptr) { activationViewSwitcher = activateEventArgs-&gt;ViewSwitcher; } if (activationViewSwitcher != nullptr) { activationViewSwitcher-&gt;ShowAsStandaloneAsync(....); TraceLogger::GetInstance().LogNewWindowCreationEnd(....); // &lt;= End TraceLogger::GetInstance().LogPrelaunchedAppActivatedByUser(); } else { TraceLogger::GetInstance().LogError(L"Null_ActivationViewSwitcher"); } } m_preLaunched = false; .... }</span></span></code> </pre> <br>  Diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1020</a> memeriksa blok kode dan mencari cabang dengan panggilan fungsi yang hilang menggunakan heuristik. <br><br>  Cuplikan di atas berisi blok dengan panggilan ke fungsi <i>LogNewWindowCreationBegin</i> dan <i>LogNewWindowCreationEnd</i> .  Ini diikuti oleh blok lain di mana fungsi <i>LogNewWindowCreationEnd</i> dipanggil hanya jika kondisi tertentu terpenuhi, yang terlihat sangat mencurigakan. <br><br><h2>  Tes tidak dapat diandalkan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V621</a> Pertimbangkan untuk memeriksa operator 'untuk'.  Ada kemungkinan bahwa loop akan dieksekusi secara tidak benar atau tidak akan dieksekusi sama sekali.  CalculatorUnitTests UnitConverterViewModelUnitTests.cpp 500 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NumbersAndOperatorsEnum</span></span></span><span class="hljs-class"> {</span></span> .... Add = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) CM::Command::CommandADD, <span class="hljs-comment"><span class="hljs-comment">// 93 .... None = (int) CM::Command::CommandNULL, // 0 .... }; TEST_METHOD(TestButtonCommandFiresModelCommands) { .... for (NumbersAndOperatorsEnum button = NumbersAndOperatorsEnum::Add; button &lt;= NumbersAndOperatorsEnum::None; button++) { if (button == NumbersAndOperatorsEnum::Decimal || button == NumbersAndOperatorsEnum::Negate || button == NumbersAndOperatorsEnum::Backspace) { continue; } vm.ButtonPressed-&gt;Execute(button); VERIFY_ARE_EQUAL(++callCount, mock-&gt;m_sendCommandCallCount); VERIFY_IS_TRUE(UCM::Command::None == mock-&gt;m_lastCommand); } .... }</span></span></code> </pre> <br>  Alat analisa telah mendeteksi loop <i>untuk</i> yang tidak berjalan sama sekali, yang berarti tes tidak mengeksekusi baik.  Nilai awal dari <i>tombol</i> penghitung putaran (93) lebih besar dari nilai akhir (0) sejak awal. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V760</a> Dua blok teks yang identik ditemukan.  Blok kedua dimulai dari baris 688. CalculatorUnitTests UnitConverterViewModelUnitTests.cpp 683 <br><br><pre> <code class="cpp hljs">TEST_METHOD(TestSwitchAndReselectCurrentlyActiveValueDoesNothing) { <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;UnitConverterMock&gt; mock = make_shared&lt;UnitConverterMock&gt;(); VM::<span class="hljs-function"><span class="hljs-function">UnitConverterViewModel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WCHAR * vFrom = <span class="hljs-string"><span class="hljs-string">L"1"</span></span>, *vTo = <span class="hljs-string"><span class="hljs-string">L"234"</span></span>; vm.UpdateDisplay(vFrom, vTo); vm.Value2Active = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Establish base condition VERIFY_ARE_EQUAL((UINT)1, mock-&gt;m_switchActiveCallCount); VERIFY_ARE_EQUAL((UINT)1, mock-&gt;m_sendCommandCallCount); VERIFY_ARE_EQUAL((UINT)1, mock-&gt;m_setCurUnitTypesCallCount); vm.Value2Active = true; VERIFY_ARE_EQUAL((UINT)1, mock-&gt;m_switchActiveCallCount); VERIFY_ARE_EQUAL((UINT)1, mock-&gt;m_sendCommandCallCount); VERIFY_ARE_EQUAL((UINT)1, mock-&gt;m_setCurUnitTypesCallCount); }</span></span></code> </pre> <br>  Tes mencurigakan lainnya.  Penganalisis telah mendeteksi dua fragmen kode identik yang segera dieksekusi satu demi satu.  Sepertinya kode ini ditulis menggunakan teknik salin-tempel dan programmer lupa untuk memodifikasi salinan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V601</a> Nilai 'salah' secara implisit dilemparkan ke tipe integer.  Periksa argumen kedua.  CalculatorUnitTests CalcInputTest.cpp 352 <br><br><pre> <code class="cpp hljs">Rational CalcInput::ToRational(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> radix, <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> precision) { .... } TEST_METHOD(ToRational) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rat = m_calcInput.ToRational(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); .... }</code> </pre> <br>  Fungsi <i>ToRational</i> disebut dengan nilai Boolean <i>false</i> , sedangkan parameter yang sesuai adalah tipe <i>int32_t</i> dan disebut <i>presisi</i> . <br><br>  Saya memutuskan untuk melacak nilai kode dan melihat bahwa itu kemudian diteruskan ke fungsi <i>StringToRat</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">PRAT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringToRat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> precision)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br>  dan kemudian ke <i>StringToNumber</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">PNUMBER </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringToNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> precision)</span></span></span><span class="hljs-function"> </span></span>{ .... stripzeroesnum(pnumret, precision); .... }</code> </pre> <br>  Inilah tubuh fungsi target: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stripzeroesnum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Inout_ PNUMBER pnum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starting)</span></span></span><span class="hljs-function"> </span></span>{ MANTTYPE *pmant; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cdigits; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fstrip = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; pmant=pnum-&gt;mant; cdigits=pnum-&gt;cdigit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cdigits &gt; starting ) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { pmant += cdigits - starting; cdigits = starting; } .... }</span></span></code> </pre> <br>  Variabel <i>presisi</i> sekarang bernama <i>starting</i> dan berpartisipasi dalam ekspresi <i>cdigits&gt; starting</i> , yang sangat mencurigakan karena <i>false</i> dilewatkan sebagai nilai asli. <br><br><h2>  Redundansi </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V560</a> Bagian dari ekspresi kondisional selalu benar: NumbersAndOperatorsEnum :: Tidak ada! = Op.  CalcViewModel UnitConverterViewModel.cpp 991 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UnitConverterViewModel::OnPaste(String^ stringToPaste, ViewMode mode) { .... NumbersAndOperatorsEnum op = MapCharacterToButtonId(*it, canSendNegate); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NumbersAndOperatorsEnum::None != op) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... if (NumbersAndOperatorsEnum::None != op &amp;&amp; // &lt;= NumbersAndOperatorsEnum::Negate != op) { .... } .... } .... }</span></span></code> </pre> <br>  Variabel <i>op</i> sudah dibandingkan dengan nilai <i>NumbersAndOperatorsEnum :: Tidak ada</i> , sehingga pemeriksaan duplikat dapat dihapus. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V728</a> Pemeriksaan berlebihan dapat disederhanakan.  The '(A &amp;&amp; B) ||  Ekspresi (! A &amp;&amp;! B) 'sama dengan ekspresi' bool (A) == bool (B) '.  Calculator Calculator.xaml.cpp 239 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Calculator::AnimateCalculator(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> resultAnimate) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (App::IsAnimationEnabled()) { m_doAnimate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; m_resultAnimate = resultAnimate; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((m_isLastAnimatedInScientific &amp;&amp; IsScientific) || (!m_isLastAnimatedInScientific &amp;&amp; !IsScientific)) &amp;&amp; ((m_isLastAnimatedInProgrammer &amp;&amp; IsProgrammer) || (!m_isLastAnimatedInProgrammer &amp;&amp; !IsProgrammer))) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;OnStoryboardCompleted(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } } }</code> </pre> <br>  Ekspresi bersyarat besar ini awalnya 218 karakter, tetapi saya membaginya menjadi beberapa baris untuk tujuan demonstrasi.  Ini dapat ditulis ulang menjadi versi yang jauh lebih pendek dan, yang paling penting, lebih jelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( m_isLastAnimatedInScientific == IsScientific &amp;&amp; m_isLastAnimatedInProgrammer == IsProgrammer) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;OnStoryboardCompleted(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V524</a> Aneh bahwa tubuh fungsi 'ConvertBack' sepenuhnya setara dengan tubuh fungsi 'Konversi'.  Kalkulator BooleanNegationConverter.cpp 24 <br><br><pre> <code class="cpp hljs">Object^ BooleanNegationConverter::Convert(....) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) targetType; <span class="hljs-comment"><span class="hljs-comment">// Unused parameter (void) parameter; // Unused parameter (void) language; // Unused parameter auto boxedBool = dynamic_cast&lt;Box&lt;bool&gt;^&gt;(value); auto boolValue = (boxedBool != nullptr &amp;&amp; boxedBool-&gt;Value); return !boolValue; } Object^ BooleanNegationConverter::ConvertBack(....) { (void) targetType; // Unused parameter (void) parameter; // Unused parameter (void) language; // Unused parameter auto boxedBool = dynamic_cast&lt;Box&lt;bool&gt;^&gt;(value); auto boolValue = (boxedBool != nullptr &amp;&amp; boxedBool-&gt;Value); return !boolValue; }</span></span></code> </pre> <br>  Penganalisa telah mendeteksi dua fungsi yang diimplementasikan secara identik.  Seperti yang <i>disarankan oleh</i> nama mereka, <i>Convert</i> dan <i>ConvertBack</i> , mereka seharusnya melakukan hal-hal yang berbeda, tetapi para pengembang harus lebih tahu. <br><br><h2>  Kesimpulan </h2><br>  Saya kira setiap proyek Microsoft yang dibuat open-source memberi kami kesempatan untuk menunjukkan pentingnya analisis statis - bahkan pada proyek sekecil Kalkulator.  Perusahaan besar, seperti Microsoft, Google, Amazon, dll., Mempekerjakan banyak pengembang berbakat, tetapi mereka masih manusia membuat kesalahan.  Alat analisis statis adalah salah satu cara terbaik untuk membantu tim pengembang mana pun meningkatkan kualitas produk mereka. <br><br>  Selamat mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> dan cobalah "Kalkulator" Anda sendiri.  :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443400/">https://habr.com/ru/post/id443400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443390/index.html">Fitur Bahasa Inggris Australia</a></li>
<li><a href="../id443392/index.html">Game save history: dari kata sandi di atas kertas hingga awan</a></li>
<li><a href="../id443394/index.html">Rilis eksperimental Blazor 0.9.0 sekarang tersedia</a></li>
<li><a href="../id443396/index.html">Pencetakan 3D dan airsoft: bagaimana saya mencetak "drive"</a></li>
<li><a href="../id443398/index.html">Menerapkan ERP di perusahaan industri: Alevtina Svetozarovna dan Excel terhadap arsitek keras dan pabrik Inggris</a></li>
<li><a href="../id443402/index.html">Cara membuat ulasan kode lebih cepat dan lebih efisien</a></li>
<li><a href="../id443404/index.html">Tujuan Baru NASA untuk Pencarian Peradaban Luar Angkasa: Tanda-Tanda Teknologi</a></li>
<li><a href="../id443406/index.html">20 kesalahan teratas saat bekerja dengan multithreading di C ++ dan cara untuk menghindarinya</a></li>
<li><a href="../id443408/index.html">Foton, kuanta, dan keadaan Fock: manipulasi tingkat kuantum dengan resonator frekuensi radio</a></li>
<li><a href="../id443412/index.html">Mengapa programmer terus menggunakan Java verbose, meskipun ada Python ringkas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>