<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèº üêå üïô Inicie la pantalla en STM32 a trav√©s de LTDC ... en los registros üéÇ üêä ‚òùüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saludos! Recientemente, un proyecto necesitaba lanzar una pantalla que tuviera una interfaz LVDS. Para implementar la tarea, se seleccion√≥ el controla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inicie la pantalla en STM32 a trav√©s de LTDC ... en los registros</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412753/"> Saludos!  Recientemente, un proyecto necesitaba lanzar una pantalla que tuviera una interfaz LVDS.  Para implementar la tarea, se seleccion√≥ el controlador STM32F746, porque  Ya he trabajado mucho con √©l y tiene el m√≥dulo LTDC, que le permite trabajar directamente con la pantalla sin un controlador.  En este caso, el controlador ya est√° implementado dentro del microcontrolador.  Adem√°s, el √∫ltimo argumento fue que hab√≠a una depuraci√≥n de STM32F746-Disco en esta piedra, que ten√≠a a mano, lo que significa que pod√≠a comenzar a trabajar en el proyecto sin esperar a que la placa, los componentes, etc. <br><br>  Hoy les dir√© c√≥mo ejecutar el m√≥dulo LTDC, trabajando con registros (CMSIS).  A HAL y otras bibliotecas no les gusta y no usan por razones religiosas, pero esto tambi√©n es de inter√©s.  Ver√° que generar perif√©ricos complejos en registros es tan simple como SPI normal.  Interesante?  Entonces vamos! <br><br><img src="https://habrastorage.org/webt/1q/dg/rd/1qdgrdp09rbyqcdhtzsvz8aqkbc.jpeg"><br><a name="habracut"></a><br><h2>  1. Un poco sobre LTDC </h2><br>  Este m√≥dulo perif√©rico es esencialmente un controlador, que generalmente se encuentra al costado de la pantalla, por ejemplo, SSD1963 y similares.  Si observamos la estructura de LTDC, veremos que f√≠sicamente es un bus paralelo de 24 bits + acelerador de gr√°ficos de hardware + matriz de datos en RAM, que de hecho es un b√∫fer de pantalla (buffer de cuadro). <br><br><img src="https://habrastorage.org/webt/wm/g-/7k/wmg-7k_nhwtycbwgiefmyyagmxo.png"><br><br>  En la salida, tenemos el bus paralelo habitual, que contiene 24 bits de color (8 bits por color del modelo RGB), l√≠neas de sincronizaci√≥n, una l√≠nea de encendido / apagado de pantalla y reloj de p√≠xeles.  La √∫ltima, de hecho, es una se√±al de reloj mediante la cual los p√≠xeles se cargan en la pantalla, es decir, si tenemos una frecuencia de 9,5 MHz, en 1 segundo podemos cargar 9,5 millones de p√≠xeles.  Esto en teor√≠a, por supuesto, en la pr√°ctica, los n√∫meros son algo m√°s modestos debido a los tiempos y otras cosas. <br><br>  <u>Para una introducci√≥n m√°s detallada a LTDC, le aconsejo que lea algunos documentos:</u> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una visi√≥n general de las capacidades de LTDC en F4, en nuestro F7 todo es igual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nota de aplicaci√≥n 4861. "Controlador de pantalla LCD-TFT (LTDC) en MCU STM32"</a> </li></ol><br><h2>  2. ¬øQu√© necesitamos hacer? </h2><br>  Los microcontroladores ST han ganado popularidad por una buena raz√≥n, el requisito m√°s importante para cualquier componente electr√≥nico es la documentaci√≥n, y todo est√° bien.  El sitio es ciertamente terrible, pero dejar√© enlaces a toda la documentaci√≥n.  El fabricante nos salva del tormento y la invenci√≥n de la bicicleta, por lo tanto, en la p√°gina 520 en el <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manual de referencia RM0385,</a></i> se dan pasos en blanco y negro, lo que debemos hacer: <br><br><img src="https://habrastorage.org/webt/bz/nx/ul/bznxulxfphrlrfmc_47lhv9wvgy.png"><br><br>  De hecho, no tiene que hacer la mitad de lo descrito: no es necesario iniciarlo o ya est√° configurado de forma predeterminada.  Para el inicio m√≠nimo, que nos permite dibujar p√≠xeles, mostrar im√°genes, gr√°ficos, texto, etc., es suficiente hacer lo siguiente: <br><br><ul><li>  Habilitar el marcado LTDC </li><li>  Configure el sistema de reloj y la frecuencia de salida de datos (reloj de p√≠xeles) </li><li>  Configure los puertos de E / S (GPIO) para trabajar con LTDC </li><li>  Configurar horarios para nuestro modelo de pantalla </li><li>  <s>Ajusta la polaridad de las se√±ales.</s>  <s>Ya hecho por defecto</s> </li><li>  <s>Especifique el color de fondo de la pantalla.</s>  <s>Todav√≠a no lo veremos, puedes dejarlo "a cero</s> </li><li>  Establecer el tama√±o real del √°rea visible de la pantalla para una capa espec√≠fica </li><li>  Seleccione el formato de color: ARGB8888, RGB 888, RGB565, etc. </li><li>  Especifique la direcci√≥n de la matriz que actuar√° como un b√∫fer de trama </li><li>  Indique la cantidad de datos en una l√≠nea (longitud en ancho) </li><li>  Indique el n√∫mero de l√≠neas (altura de visualizaci√≥n) </li><li>  Incluya la capa con la que estamos trabajando </li><li>  Habilitar m√≥dulo LTDC </li></ul><br>  Miedo  Y ten√≠a miedo, pero result√≥ funcionar durante 20 minutos con todos los procedimientos.  Hay una tarea, el plan est√° planeado y solo queda cumplirlo. <br><br><h2>  3. Configuraci√≥n del sistema de reloj </h2><br>  El primer elemento que necesitamos para enviar una se√±al de reloj al m√≥dulo LTDC, esto se hace escribiendo en el registro RCC: <br><br><pre><code class="cpp hljs">RCC-&gt;APB2ENR |= RCC_APB2ENR_LTDCEN;</code> </pre> <br>  A continuaci√≥n, debe configurar la frecuencia de reloj del cuarzo externo (HSE) a una frecuencia de 216 MHz, es decir, al m√°ximo.  El primer paso es encender la fuente del reloj desde el resonador de cuarzo y esperar la bandera de listo: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!(RCC-&gt;CR &amp; RCC_CR_HSERDY));</code> </pre><br>  Ahora configure el retraso para la memoria flash del controlador, como  ella no sabe trabajar en la frecuencia central.  Su valor, como el resto de los datos, se toma del manual de referencia: <br><br><pre> <code class="cpp hljs">FLASH-&gt;ACR |= FLASH_ACR_LATENCY_5WS;</code> </pre><br>  Ahora, para obtener la frecuencia deseada, dividir√© 25 MHz de la entrada a 25 y obtendr√© 1 MHz.  Luego, solo en PLL multiplico por 432, porque  en el futuro hay un divisor de frecuencia con un valor m√≠nimo de / 2 y debe aplicarle el doble de frecuencia.  Despu√©s de eso, conectamos la entrada PLL a nuestro resonador de cuarzo (HSE): <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLM_0 | RCC_PLLCFGR_PLLM_3 | RCC_PLLCFGR_PLLM_4; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLN_4 | RCC_PLLCFGR_PLLN_5 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLN_8; RCC-&gt;PLLCFGR |= RCC_PLLCFGR_PLLSRC;</code> </pre><br>  Ahora habilite PLL y espere la bandera de listo: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLON; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>){}</code> </pre><br>  Asignamos la salida de nuestro PLL como la fuente de la frecuencia del sistema y esperamos la bandera de listo: <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {}</code> </pre><br>  Esto finaliza la configuraci√≥n general del reloj y pasamos a configurar la frecuencia del reloj (PLLSAI) para nuestra pantalla (reloj de p√≠xeles).  La se√±al para PLLSAI seg√∫n la hoja de datos se toma despu√©s del divisor / 25, es decir, en la entrada tenemos 1 MHz.  Necesitamos obtener una frecuencia de aproximadamente 9.5 MHz, para esto multiplicamos la frecuencia de 1 MHz por 192, y luego usando dos divisores por 5 y 4 obtenemos el valor deseado PLLSAI = 1 MHz * 192/5/4 = 9.6 MHz: <br><br><pre> <code class="cpp hljs">RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7; RCC-&gt;PLLSAICFGR |= RCC_PLLSAICFGR_PLLSAIR_0 | RCC_PLLSAICFGR_PLLSAIR_2; RCC-&gt;DCKCFGR1 |= RCC_DCKCFGR1_PLLSAIDIVR_0; RCC-&gt;DCKCFGR1 &amp;= ~RCC_DCKCFGR1_PLLSAIDIVR_1;</code> </pre><br>  Como paso final, habilitamos PLLSAI para la pantalla y esperamos el indicador de listo para trabajar: <br><br><pre> <code class="cpp hljs">RCC-&gt;CR |= RCC_CR_PLLSAION; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((RCC-&gt;CR &amp; RCC_CR_PLLSAIRDY) == <span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br>  Esto completa la configuraci√≥n b√°sica del sistema de reloj, para no olvidar y no sufrir, habilitemos la sincronizaci√≥n en todos los puertos de entrada / salida (GPIO).  No tenemos bater√≠a, al menos para la depuraci√≥n, por lo que no guardamos: <br><br><pre> <code class="cpp hljs">RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOBEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOCEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIODEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOEEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOFEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOGEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOHEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOJEN; RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOKEN;</code> </pre><br><h2>  4. Configuraci√≥n de puertos de E / S (GPIO) </h2><br>  Configurar gpio es muy simple: tenemos todas las patas del bus LTDC para configurar como salida alternativa y a una frecuencia alta.  Para hacer esto, en el manual de referencia en la p√°gina 201 tenemos este consejo: <br><br><img src="https://habrastorage.org/webt/m5/bw/e9/m5bwe9v-fev5yahji9hqc9iofno.png"><br><br>  La tabla indica qu√© bits en los registros debe establecer para obtener la configuraci√≥n necesaria.  Vale la pena se√±alar que todas las llaves est√°n deshabilitadas.  ¬øD√≥nde buscar qu√© funci√≥n alternativa incluir?  Y para esto, vaya a la p√°gina 76 en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">datos</a> de nuestro controlador y mire la siguiente tabla: <br><br><img src="https://habrastorage.org/webt/d1/6a/6-/d16a6-uye3sjdb7rrf_m-qnz2os.png"><br><br>  Como puede ver, la l√≥gica de la tabla es la m√°s simple: encontramos la funci√≥n que necesitamos, en nuestro caso LTDC B0, luego miramos en qu√© GPIO est√° (PE4, por ejemplo) y en la parte superior vemos el n√∫mero de la funci√≥n alternativa que usaremos para configurar (AF14 aqu√≠).  Para configurar nuestra salida como una salida push-pull con una funci√≥n alternativa, LTDC B0, necesitamos escribir el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs">GPIOE-&gt;MODER &amp;= ~GPIO_MODER_MODER4; GPIOE-&gt;MODER |= GPIO_MODER_MODER4_1; GPIOE-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR4_1; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;= ~GPIO_AFRL_AFRL4_0; GPIOE-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= GPIO_AFRL_AFRL4_1 | GPIO_AFRL_AFRL4_2 | GPIO_AFRL_AFRL4_3;</code> </pre><br>  Di un ejemplo para el pin PE4, que corresponde al pin B0 en el bus LTDC, es decir, es un bit azul de color cero.  Para todas las dem√°s conclusiones, la configuraci√≥n es id√©ntica, solo 2 conclusiones merecen especial atenci√≥n, una de las listas incluye una pantalla y la otra su luz de fondo.  Est√°n configurados como una salida push-pull normal, que todos usan para parpadear un LED.  La configuraci√≥n se ve as√≠: <br><br><pre> <code class="cpp hljs">GPIOK-&gt;MODER &amp;= ~GPIO_MODER_MODER3; GPIOK-&gt;MODER |= GPIO_MODER_MODER3_0;</code> </pre><br>  Esta configuraci√≥n es para la salida PK3, que enciende y apaga nuestra luz de fondo.  Por cierto, tambi√©n puede EMPUJARLO para ajustar suavemente el brillo.  Para PI12, que incluye una pantalla (DISP), todo es igual.  La velocidad en estos 2 pines es baja por defecto, porque  no se requieren algunas acciones de alta frecuencia de ellos. <br><br>  Puede ver todos los dem√°s puertos de E / S en la placa de circuito de la placa de depuraci√≥n, o en el diagrama de circuito de su propio dispositivo. <br><br><h2>  5. Tiempos y sus configuraciones </h2><br>  Los tiempos desde un punto de vista f√≠sico son retrasos comunes.  Creo que ha observado repetidamente varias perversiones del tipo de retraso (1) cuando mir√≥ ejemplos de c√≥digo en pantallas con controladores SPI / I2C similares a ILI9341.  All√≠, se necesita un retraso para que el controlador, por ejemplo, tenga tiempo de aceptar el comando, ejecutarlo y luego hacer algo con los datos.  En el caso de LTDC, todo es casi igual, solo que no haremos muletas y, por qu√© no, nuestro microcontrolador puede configurar los tiempos necesarios en el hardware.  ¬øPor qu√© se necesitan en una pantalla donde no hay controlador?  S√≠, es elemental que despu√©s de llenar la primera l√≠nea de p√≠xeles, vaya a la siguiente l√≠nea y regrese a su comienzo.  Esto se debe a la tecnolog√≠a de producci√≥n de pantallas y, por lo tanto, cada modelo de pantalla espec√≠fico tiene sus propios tiempos. <br><br>  Para averiguar qu√© valores necesitamos, vaya al sitio web de ST y mire el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diagrama de la placa de depuraci√≥n STM32F746-Disco</a> .  All√≠ podemos ver que la pantalla es <i>RK043FN48H-CT672B</i> y la documentaci√≥n est√° disponible, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Estamos m√°s interesados ‚Äã‚Äãen la tabla en la p√°gina 13 en la secci√≥n 7.3.1: <br><br><img src="https://habrastorage.org/webt/t7/fk/ou/t7fkoukmcua7rsnn6bmema1dhio.png"><br><br>  Estos son nuestros valores que necesitaremos al configurar.  Tambi√©n en la documentaci√≥n hay mucho m√°s que es interesante, por ejemplo, diagramas de se√±ales en el bus, etc., que podr√≠a necesitar si, por ejemplo, desea elevar la pantalla a FPGA o CPLD. <br><br>  Ve a la configuraci√≥n.  En primer lugar, para no mantener estos valores en mi cabeza, los organizar√© en forma de definiciones: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HSYNC ((uint16_t)30) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HBP ((uint16_t)13) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HFP ((uint16_t)32) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VSYNC ((uint16_t)10) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VBP ((uint16_t)2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_VFP ((uint16_t)2)</span></span></code> </pre><br>  Hay una caracter√≠stica interesante.  Timing <i>Pulse Width</i> , que se llama <i>DISPLAY_HSYNC</i> , tiene un valor en la tabla solo para la frecuencia de reloj de p√≠xeles de 5 MHz, pero para 9 y 12 MHz no lo es.  Este tiempo debe seleccionarse para su pantalla, obtuve este valor de 30, cuando en los ejemplos de ST era diferente.  Al principio, si tiene un error con su configuraci√≥n, la imagen se desplazar√° hacia la izquierda o hacia la derecha.  Si est√° a la derecha, disminuimos el tiempo; si a la izquierda, lo aumentamos.  De hecho, afecta el origen de la zona visible, que veremos m√°s adelante.  Solo tenga en cuenta que la siguiente imagen de la p√°gina 24 de nuestro AN4861 ayudar√° a comprender todo este p√°rrafo: <br><br><img src="https://habrastorage.org/webt/nu/cd/gc/nucdgcesjmx8gqq-bjwfnusk0vc.png"><br><br>  Una peque√±a abstracci√≥n es conveniente aqu√≠.  Tenemos 2 zonas de visualizaci√≥n: visibles y generales.  La zona visible tiene dimensiones con una resoluci√≥n declarada de 480 por 272 p√≠xeles, y la zona total es el visible + nuestros tiempos, de los cuales hay 3 en cada lado.  Tambi√©n vale la pena entender (esto ya no es una abstracci√≥n) que una marca del sistema es 1 p√≠xel, por lo que el √°rea total es 480 p√≠xeles + HSYNC + HBP + HFP. <br><br>  Tambi√©n vale la pena darse cuenta de que cuantos menos tiempos, mejor: la pantalla se actualizar√° m√°s r√°pido y la velocidad de fotogramas aumentar√° ligeramente.  Por lo tanto, despu√©s de la primera ejecuci√≥n, experimente con los tiempos y reduzca lo m√°s posible mientras mantiene la estabilidad. <br><br>  Para establecer los tiempos, hice una peque√±a "hoja de trucos" para el futuro dentro del proyecto, tambi√©n lo ayudar√° a comprender qu√© figura espec√≠fica y d√≥nde escribirla: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *************************** Timings for TFT display********************************** * * HSW = (DISPLAY_HSYNC - 1) * VSH = (DISPLAY_VSYNC - 1) * AHBP = (DISPLAY_HSYNC + DISPLAY_HBP - 1) * AVBP = (DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - 1) * AAH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - 1) * TOTALW = (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - 1) * TOTALH = (DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP - 1) * */</span></span></code> </pre><br>  ¬øDe d√≥nde viene esta "hoja de trucos" ... Primero, viste una "f√≥rmula" similar un par de p√°rrafos antes.  En segundo lugar, vaya a la p√°gina 56 de nuestro AN4861: <br><br><img src="https://habrastorage.org/webt/sz/zf/yc/szzfyccwyqfw_t9ki0dazyck3ys.png"><br><br>  Es cierto, espero que haya entendido el significado f√≠sico de los tiempos antes de la aparici√≥n de esta hoja de trucos y estoy seguro de que usted mismo podr√≠a haberlo compilado.  No tiene nada de complicado, y las im√°genes de RM y AN ayudan a comprender visualmente el efecto de los tiempos en el proceso de formaci√≥n de im√°genes. <br><br>  Ahora es el momento de escribir un c√≥digo que configure estos tiempos.  En la "hoja de trucos" se indican los bits del registro en el que escribir, por ejemplo, TOTALH, y despu√©s de que el signo sea igual a la f√≥rmula que le da a la salida un cierto n√∫mero.  Ok?  Luego escribimos: <br><br><pre> <code class="cpp hljs">LTDC-&gt;SSCR |= ((DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;BPCR |= ((DISPLAY_HSYNC+DISPLAY_HBP<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_VSYNC+DISPLAY_VBP<span class="hljs-number"><span class="hljs-number">-1</span></span>)); LTDC-&gt;AWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>)); LTDC-&gt;TWCR |= ((DISPLAY_WIDTH + DISPLAY_HSYNC + DISPLAY_HBP + DISPLAY_HFP <span class="hljs-number"><span class="hljs-number">-1</span></span>)&lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> |(DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP + DISPLAY_VFP - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  ¬°Y eso es todo con los tiempos!  En esta secci√≥n, solo puede configurar el color de fondo.  Lo tengo negro por defecto, por lo que est√° escrito en cero.  Si desea cambiar el color de la capa de fondo (fondo), puede escribir igualmente cualquier valor, por ejemplo, <i>0xFFFFFFFF</i> y llenar todo con blanco: <br><br><pre> <code class="cpp hljs">LTDC-&gt;BCCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  Hay una ilustraci√≥n maravillosa en el <i>manual de referencia</i> , que demuestra claramente que en realidad tenemos 3 capas: fondo, capa 1 y capa 2. La capa de fondo est√° "castrada" y solo puede rellenarse con un color espec√≠fico, pero tambi√©n puede ser incre√≠blemente √∫til en la implementaci√≥n futuro dise√±o de GUI.  Adem√°s, esta ilustraci√≥n demuestra claramente la prioridad de las capas, lo que significa que veremos el color de relleno en el fondo solo cuando las capas restantes est√©n vac√≠as o transparentes. <br><br>  Como ejemplo, mostrar√© una de las p√°ginas del proyecto donde, durante la implementaci√≥n de la plantilla, el fondo se llen√≥ con un color y el controlador no volvi√≥ a dibujar toda la p√°gina, sino solo sectores individuales, lo que permiti√≥ recibir aproximadamente 50-60 fps para muchas otras tareas: <br><br><img src="https://habrastorage.org/webt/7b/yn/il/7byniliyqlnqy0yyzpfk8um7_mg.jpeg"><br><br><h2>  6. La parte final de la configuraci√≥n de LTDC </h2><br>  La configuraci√≥n de LTDC se divide en 2 secciones: la primera es com√∫n para todo el m√≥dulo LTDC y est√° ubicada en el <i>grupo de</i> registro <i>LTDC</i> , y la segunda est√° configurada en una de dos capas y est√° en el <i>grupo</i> <i>LTDC_Layer1</i> y <i>LTDC_Layer2</i> . <br><br>  Realizamos la configuraci√≥n general en el p√°rrafo anterior, que incluye la configuraci√≥n de los tiempos, la capa de fondo.  Ahora pasamos a configurar las capas y nuestra lista requiere el tama√±o real de la zona visible de la capa, que se describe en forma de 4 coordenadas (x0, y0, x1, y2), que nos permiten obtener las dimensiones del rect√°ngulo.  El tama√±o de la capa visible puede ser menor que la resoluci√≥n de la pantalla, nadie se molesta en hacer que el tama√±o de la capa sea 100 por 100 p√≠xeles.  Para ajustar el tama√±o de la zona visible, escriba el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;WHPCR |= (((DISPLAY_WIDTH + DISPLAY_HBP + DISPLAY_HSYNC - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (DISPLAY_HBP + DISPLAY_HSYNC)); LTDC_Layer2-&gt;WVPCR |= (((DISPLAY_HEIGHT + DISPLAY_VSYNC + DISPLAY_VBP - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) |(DISPLAY_VSYNC + DISPLAY_VBP));</code> </pre><br>  Como puede ver, todo es igual que con los tiempos.  Los puntos de partida (x0, y0) de la zona visible consisten en la suma de dos tiempos: HSYNC + HBP y VSYNC + VBP.  Para calcular las coordenadas del punto final (x1, y1), el ancho y la altura en p√≠xeles simplemente se agregan a los datos del valor. <br><br>  Ahora necesita configurar el formato de los datos recibidos.  La calidad m√°xima se obtiene cuando se utiliza el formato ARGB8888, pero al mismo tiempo obtenemos la cantidad m√°xima de memoria ocupada.  Un p√≠xel ocupa 32 bits o 4 bytes, lo que significa que toda la pantalla ocupa 4 * 480 * 272 = 522,240 bytes, es decir, la mitad de la memoria flash de nuestro controlador no es el m√°s d√©bil.  No tenga miedo: la conexi√≥n de SDRAM externa y memoria Flash a trav√©s de QSPI resuelve problemas de memoria y no hay restricciones en este formato, nos alegramos de buena calidad.  Si desea ahorrar espacio o su pantalla no admite el formato de 24 bits, se utilizan modelos m√°s adecuados para esto, por ejemplo, RGB565.  Un formato muy popular tanto para pantallas como para c√°maras, y lo m√°s importante al usarlo, 1 p√≠xel toma solo 5 + 6 + 5 = 16 bits o 2 bytes.  En consecuencia, la cantidad de memoria ocupada por la capa ser√° 2 veces menor.  Por defecto, el controlador ya tiene configurado el formato ARGB8888 y tiene este aspecto: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;PFCR = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Si necesita un formato diferente al ARGB8888, vaya a las p√°ginas 533 y 534 del <i>manual de referencia</i> y seleccione el formato deseado de la lista a continuaci√≥n: <br><br><img src="https://habrastorage.org/webt/be/fg/qa/befgqaa2-iokyso1coeqhaii9zu.png"><br><br>  Ahora cree una matriz y pase su direcci√≥n a LTDC, se convertir√° en un b√∫fer de trama y ser√° un "reflejo" de nuestra capa.  Por ejemplo, debe llenar el primer p√≠xel en la primera fila con color blanco, para esto solo necesita escribir el valor de color (0xFFFFFFFF) en el primer elemento de esta matriz.  ¬øNecesita llenar el primer p√≠xel en la segunda fila?  Luego tambi√©n escribimos el valor de color en el elemento con el n√∫mero (480 + 1).  480 - haga un salto de l√≠nea, luego agregue el n√∫mero en la l√≠nea que necesitamos. <br><br>  Esta configuraci√≥n se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_WIDTH ((uint16_t)480) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DISPLAY_HEIGHT ((uint16_t)272) const uint32_t imageLayer2[DISPLAY_WIDTH * DISPLAY_HEIGHT]; LTDC_Layer2-&gt;CFBAR = (uint32_t)imageLayer2;</span></span></code> </pre><br>  En el buen sentido, despu√©s de configurar LTDC, tambi√©n debe configurar SDRAM para eliminar el modificador <i>const</i> y obtener el b√∫fer de trama en la RAM, porque  La propia RAM de MK no es suficiente incluso para una capa con 4 bytes.  Aunque esto no est√° de m√°s probar la configuraci√≥n correcta de los perif√©ricos. <br><br>  Luego, debe especificar el valor de la capa alfa, es decir, la transparencia de nuestra capa <i>Layer2</i> , para esto escribimos un valor de 0 a 255, donde 0 es una capa completamente transparente, 255 es completamente opaca, que es 100% visible: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CACR = <span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre> <br>  Seg√∫n nuestro plan, ahora es necesario registrar el tama√±o de nuestra √°rea de visualizaci√≥n visible en bytes, para esto escribimos los valores correspondientes en los registros: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CFBLR |= (((PIXEL_SIZE * DISPLAY_WIDTH) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (PIXEL_SIZE * DISPLAY_WIDTH + <span class="hljs-number"><span class="hljs-number">3</span></span>)); LTDC_Layer2-&gt;CFBLNR |= DISPLAY_HEIGHT;</code> </pre><br>  Quedan los dos √∫ltimos pasos, a saber, la inclusi√≥n de la capa 2 y el m√≥dulo perif√©rico LTDC en s√≠.  Para hacer esto, escriba los bits correspondientes: <br><br><pre> <code class="cpp hljs">LTDC_Layer2-&gt;CR |= LTDC_LxCR_LEN; LTDC-&gt;GCR |= LTDC_GCR_LTDCEN;</code> </pre><br>  ¬°Esto completa la configuraci√≥n de nuestro m√≥dulo y usted puede trabajar con nuestra pantalla! <br><br><h2>  7. Un poco sobre trabajar con LTDC </h2><br>  Todo el trabajo con la pantalla ahora se reduce a escribir datos en la matriz <i>imageLayer2</i> , tiene un tama√±o de 480 por 272 elementos, lo que corresponde totalmente a nuestra resoluci√≥n y sugiere una verdad simple: <b>1 elemento de matriz = 1 p√≠xel en la pantalla</b> . <br><br>  Como ejemplo, escrib√≠ una imagen en una matriz que convert√≠ en <b>LCD Image Converter</b> , pero en realidad es poco probable que sus tareas se limiten a esto.  Hay dos formas: usar una GUI preparada y escribirla usted mismo.  Para tareas relativamente simples como la salida de texto, gr√°ficos y similares, le aconsejo que escriba su propia GUI, tomar√° un poco de tiempo y le dar√° una comprensi√≥n completa de su trabajo.  Cuando la tarea es grande y dif√≠cil, y no hay tiempo para desarrollar su propia GUI, le aconsejo que preste atenci√≥n a las soluciones ya preparadas, por ejemplo, uGFX y similares. <br><br>  Los s√≠mbolos de texto, l√≠neas y otros elementos son inherentemente conjuntos de p√≠xeles, por lo que para implementarlos debe implementar la l√≥gica usted mismo, pero debe comenzar con la funci√≥n m√°s b√°sica: "salida de p√≠xeles".  Debe tomar 3 argumentos: la coordenada a lo largo de X, la coordenada a lo largo de Y y, en consecuencia, el color en el que se pinta el p√≠xel dado.  Puede verse as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ColorDisplay { RED = <span class="hljs-number"><span class="hljs-number">0xFFFF0000</span></span>, GREEN = <span class="hljs-number"><span class="hljs-number">0xFF00FF00</span></span>, BLUE = <span class="hljs-number"><span class="hljs-number">0xFF0000FF</span></span>, BLACK = <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>, WHITE = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> } Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPixel</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> setY, Color Color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> numBuffer = ((setY - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DISPLAY_WIDTH) + setX; imageLayer2[numBuffer] = Color; }</code> </pre><br>  Despu√©s de tomar las coordenadas en una funci√≥n, las recalculamos en el n√∫mero de la matriz que corresponde a la coordenada dada y luego escribimos el color recibido en el elemento recibido.  En funci√≥n de esta funci√≥n, ya puede implementar funciones para mostrar geometr√≠a, texto y otras "ventajas" de la GUI.  Creo que la idea es comprensible, pero la forma de darle vida depende de su criterio. <br><br><h2>  Resumen </h2><br>  Como puede ver, la implementaci√≥n de perif√©ricos incluso complejos en registros (CMSIS) no es una tarea dif√≠cil, solo necesita comprender c√≥mo funciona en su interior.  Por supuesto, ahora est√° de moda desarrollar firmware sin comprender lo que est√° sucediendo, pero este es un callej√≥n sin salida si planea convertirse en ingeniero, y no ... <br><br>  Si compara el c√≥digo resultante con una soluci√≥n en HAL o SPL, notar√° que el c√≥digo escrito en los registros es m√°s compacto.  Agregando un par de comentarios donde lo necesite y envolvi√©ndolo en funciones, obtenemos legibilidad al menos no peor que la de HAL / SPL, y si recuerda que el <i>manual de referencia</i> documenta los registros, entonces trabajar con CMSIS es m√°s conveniente. <br><br>  1) El proyecto con fuentes en TrueSTUDIO se puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> <br><br>  2) Para aquellos que se sienten m√°s c√≥modos mirando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> <br><br>  3) Descargue la utilidad para convertir im√°genes en c√≥digo LCD Image Converter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es412753/">https://habr.com/ru/post/es412753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es412741/index.html">C√≥mo dejar de temer que la inteligencia artificial te dejar√° sin trabajo</a></li>
<li><a href="../es412743/index.html">Profesi√≥n: detective cibern√©tico</a></li>
<li><a href="../es412747/index.html">MIS Almacenamiento de datos m√©dicos</a></li>
<li><a href="../es412749/index.html">La electr√≥nica como arte: corriente el√©ctrica</a></li>
<li><a href="../es412751/index.html">Calvicie: Teor√≠a y pr√°ctica del tratamiento, parte 1 "Mi dihidrotestosterona, mi enemigo"</a></li>
<li><a href="../es412755/index.html">Telegram lanz√≥ el servidor proxy oficial MTProto</a></li>
<li><a href="../es412757/index.html">Bombillas LED en Jap√≥n</a></li>
<li><a href="../es412759/index.html">Nuevo servidor MTProto-proxy de Telegram</a></li>
<li><a href="../es412763/index.html">Uso de la placa de recarga Firefly-RK3288 con el SoC RockChip RK3288 Sensor t√©rmico digital Microchip I2C - MCP9808</a></li>
<li><a href="../es412765/index.html">Introducci√≥n al nuevo sistema de tarjeta de mosaico Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>