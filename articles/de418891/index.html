<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßò ‚èèÔ∏è üéæ Wir haben die Android-Quellcodes mit PVS-Studio √ºberpr√ºft, oder niemand ist perfekt üë©üèº‚Äçüíº üéâ ü•ê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A. A. 
 Die Entwicklung gro√üer komplexer Projekte ist ohne den Einsatz von Programmiermethoden und -werkzeugen zur Kontrolle der Codequalit√§t nicht m√∂...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir haben die Android-Quellcodes mit PVS-Studio √ºberpr√ºft, oder niemand ist perfekt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418891/">  A. A. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d66/7b5/688/d667b56886adb4c140b623e5c14d4fd5.png" alt="Android und Unicorn PVS-Studio"></div><br>  Die Entwicklung gro√üer komplexer Projekte ist ohne den Einsatz von Programmiermethoden und -werkzeugen zur Kontrolle der Codequalit√§t nicht m√∂glich.  Erstens ist es ein kompetenter Codierungsstandard, Code√ºberpr√ºfungen, Komponententests, statische und dynamische Codeanalysatoren.  All dies hilft, Fehler im Code in den fr√ºhesten Entwicklungsstadien zu identifizieren.  Dieser Artikel beschreibt die Funktionen des statischen Analysators PVS-Studio zum Erkennen von Fehlern und potenziellen Schwachstellen im Code des Android-Betriebssystems.  Wir hoffen, dass der Artikel die Leser f√ºr die Methodik der statischen Code-Analyse attraktiv macht und sie bei der Entwicklung ihrer eigenen Projekte implementieren m√∂chte. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Ein Jahr ist vergangen, seit ein gro√üer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber Fehler im Tizen-Betriebssystem geschrieben wurde, und ich wollte noch einmal eine ebenso interessante Studie √ºber ein Betriebssystem durchf√ºhren.  Die Wahl fiel auf Android. <br><br>  Der Code des Android-Betriebssystems ist qualitativ hochwertig und gut getestet.  W√§hrend der Entwicklung wird mindestens ein statischer Coverity-Code-Analysator verwendet, wie aus den Kommentaren des Formulars hervorgeht: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Coverity: [FALSE-POSITIVE error] intended fall through */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Missing break statement between cases in switch statement */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* fall through */</span></span></code> </pre> <br>  Im Allgemeinen ist dies ein interessantes und qualitativ hochwertiges Projekt, und das Auffinden von Fehlern ist eine Herausforderung f√ºr unseren statischen Analysator PVS-Studio. <br><br>  Ich denke, dass der Leser nur durch den Umfang des Artikels versteht, dass der PVS-Studio-Analysator hervorragende Arbeit geleistet hat und viele Fehler im Code dieses Betriebssystems gefunden hat. <br><br><h2>  Aufz√§hlung der allgemeinen Schw√§chen </h2><br>  In dem Artikel finden Sie Verweise auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Common Weakness Enumeration</a> (CWE).  Lassen Sie uns den Grund f√ºr die Bezugnahme auf diese Liste erl√§utern und erkl√§ren, warum dies aus Sicherheitsgr√ºnden wichtig ist. <br><br>  Oft ist die Ursache f√ºr Schwachstellen in Programmen nicht eine schwierige Situation, sondern ein banaler Softwarefehler.  Hier ist es angebracht, dieses Zitat von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prqa.com</a> zu zitieren: <br><br>  Das Nationale Institut f√ºr Standards und Technologie (NIST) berichtet, dass 64% der Software-Schwachstellen auf Programmierfehler und nicht auf fehlende Sicherheitsfunktionen zur√ºckzuf√ºhren sind. <br><br>  Sie k√∂nnen im Artikel ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie PVS-Studio helfen kann, Schwachstellen zu finden?</a> ‚Äú Lesen. Einige Beispiele f√ºr einfache Fehler, die zu Schwachstellen in Projekten wie MySQL, iOS, NAS und illumos-gate f√ºhrten. <br><br>  Dementsprechend k√∂nnen viele Schwachstellen beseitigt werden, indem h√§ufige Fehler rechtzeitig erkannt und behoben werden.  Und hier kommt die Common Weakness Enumeration ins Spiel. <br><br>  Fehler sind unterschiedlich und nicht alle Fehler sind aus Sicherheitsgr√ºnden gef√§hrlich.  Fehler, die m√∂glicherweise zu Sicherheitsl√ºcken f√ºhren k√∂nnen, werden in der Common Weakness Enumeration erfasst.  Diese Liste wird aktualisiert, und es gibt wahrscheinlich Fehler, die zu Sicherheitsl√ºcken f√ºhren k√∂nnen, die jedoch noch nicht in diese Liste aufgenommen wurden. <br><br>  Wenn der Fehler jedoch gem√§√ü CWE klassifiziert wird, bedeutet dies, dass es theoretisch m√∂glich ist, ihn als Sicherheitsanf√§lligkeit ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CVE</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auszunutzen</a> .  Ja, die Wahrscheinlichkeit daf√ºr ist gering.  Sehr selten verwandelt sich CWE in CVE.  Wenn Sie Ihren Code jedoch vor Sicherheitsl√ºcken sch√ºtzen m√∂chten, sollten Sie nach M√∂glichkeit so viele in CWE beschriebene Fehler wie m√∂glich finden und beheben. <br><br>  Die Beziehung zwischen PVS-Studio, Fehlern, CWE und CVE ist schematisch in der Abbildung dargestellt: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06f/5b9/142/06f5b9142918167cf4e0951f3affbaa6.png" alt="CWE, CVE, PVS-Studio"></div><br><br>  Einige Fehler werden als CWE klassifiziert.  PVS-Studio kann viele dieser Fehler erkennen und so verhindern, dass einige dieser Fehler zu Sicherheitsl√ºcken (CVE) werden. <br><br>  Wir k√∂nnen sagen, dass PVS-Studio viele potenzielle Schwachstellen identifiziert, bevor sie Schaden anrichten.  Somit ist PVS-Studio ein statisches Tool zum Testen der Anwendungssicherheit ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SAST</a> ). <br><br>  Nun, ich denke, es ist klar, warum ich es bei der Beschreibung der Fehler f√ºr wichtig hielt, zu beachten, wie sie gem√§√ü CWE klassifiziert werden.  Auf diese Weise ist es einfacher zu zeigen, wie wichtig es ist, einen statischen Code-Analysator in kritischen Projekten zu verwenden, auf die sich Betriebssysteme eindeutig beziehen. <br><br><h2>  Android-Check </h2><br>  Zur Analyse des Projekts habe ich den PVS-Studio Analyzer Version 6.24 verwendet.  Der Analysator unterst√ºtzt derzeit die folgenden Sprachen und Compiler: <br><br><ul><li>  Windows  Visual Studio 2010-2017 C, C ++, C ++ / CLI, C ++ / CX (WinRT), C # </li><li>  Windows  IAR Embedded Workbench, C / C ++ - Compiler f√ºr ARM C, C ++ </li><li>  Windows / Linux  Keil ¬µVision, DS-MDK, ARM-Compiler 5/6 C, C ++ </li><li>  Windows / Linux  Code Composer Studio von Texas Instruments, Tools zur ARM-Codegenerierung C, C ++ </li><li>  Windows / Linux / macOS.  Clang C, C ++ </li><li>  Linux / MacOS.  GCC C, C ++ </li><li>  Windows  MinGW C, C ++ </li></ul><br>  Hinweis  Vielleicht haben einige unserer Leser die Nachricht verpasst, dass wir die Arbeit in der macOS-Umgebung unterst√ºtzt haben, und sie werden an dieser Ver√∂ffentlichung interessiert sein: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio-Version f√ºr macOS: 64 Schwachstellen im Apple XNU-Kernel</a> ". <br><br>  Das √úberpr√ºfen des Android-Quellcodes war kein Problem, daher werde ich nicht weiter darauf eingehen.  Das Problem war vielmehr meine Besch√§ftigung mit anderen Aufgaben, weshalb ich nicht die Zeit und Energie fand, den Bericht so sorgf√§ltig zu betrachten, wie ich es gerne h√§tte.  Ein kurzer Blick war jedoch mehr als genug, um eine gro√üe Sammlung interessanter Fehler f√ºr einen soliden Artikel zu sammeln. <br><br>  Am wichtigsten: Ich fordere Android-Entwickler auf, nicht nur die im Artikel beschriebenen Fehler zu korrigieren, sondern auch eine sorgf√§ltigere unabh√§ngige Analyse durchzuf√ºhren.  Ich habe den Analysebericht oberfl√§chlich betrachtet und viele schwerwiegende Fehler √ºbersehen k√∂nnen. <br><br>  Beim ersten Test erzeugt der Analysator viele falsch positive Ergebnisse, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies ist jedoch kein Problem</a> .  Unser Team hilft Ihnen gerne mit Empfehlungen zur Konfiguration des Analysators, um die Anzahl der Fehlalarme zu verringern.  Bei Bedarf stellen wir Ihnen auch einen Lizenzschl√ºssel f√ºr einen Monat oder l√§nger zur Verf√ºgung.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schreiben Sie uns</a> im Allgemeinen, wir helfen Ihnen und sagen es Ihnen. <br><br>  Nun wollen wir sehen, welche Fehler und potenziellen Schwachstellen ich gefunden habe.  Ich hoffe, Ihnen gef√§llt, was der statische Code-Analysator PVS-Studio finden kann.  Viel Spa√ü beim Lesen. <br><br><h2>  Sinnlose Vergleiche </h2><br>  Der Analysator betrachtet die Ausdr√ºcke als abnormal, wenn sie immer wahr oder falsch sind.  Solche Warnungen werden gem√§√ü der Common Weakness Enumeration wie folgt klassifiziert: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-570</a> : Ausdruck ist immer falsch </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-571</a> : Ausdruck ist immer wahr </li></ul><br>  Der Analysator generiert viele solcher Warnungen, und leider sind die meisten f√ºr Android-Code falsch.  In diesem Fall ist der Analysator nicht schuld.  Nur der Code ist so geschrieben. <br>  Ich werde dies anhand eines einfachen Beispiels demonstrieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> GENERIC_TARGET const char alternative_config_path[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/data/nfc/"</span></span></span><span class="hljs-meta">; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> const char alternative_config_path[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> CNxpNfcConfig&amp; CNxpNfcConfig::GetInstance() { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alternative_config_path[0] != </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\0'</span></span></span><span class="hljs-meta">) { .... }</span></span></code> </pre> <br>  Hier generiert der Analysator eine Warnung: V547 CWE-570 Der Ausdruck 'alternative_config_path [0]! =' \ 0 '' ist immer falsch.  phNxpConfig.cpp 401 <br><br>  Tatsache ist, dass das Makro <i>GENERIC_TARGET</i> nicht definiert ist und aus Sicht des Analysators der Code folgenderma√üen aussieht: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> alternative_config_path[] = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alternative_config_path[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) {</code> </pre> <br>  Der Analysator muss lediglich eine Warnung ausgeben, da die Leitung leer ist und sich am Nullpunktversatz immer eine Klemmennull befindet.  Somit hat der Analysator formal Recht, eine Warnung auszugeben.  Aus praktischer Sicht bietet diese Warnung jedoch keinen Nutzen. <br><br>  Leider kann mit solchen Situationen nichts gemacht werden.  Wir m√ºssen alle diese Warnungen systematisch √ºberpr√ºfen und viele Stellen als falsch positiv markieren, damit der Analysator keine Nachrichten mehr in diesen Zeilen ausgibt.  Dies muss wirklich getan werden, da neben bedeutungslosen Nachrichten viele echte M√§ngel festgestellt werden. <br><br>  Ich gebe ehrlich zu, dass ich nicht daran interessiert war, Warnungen dieser Art sorgf√§ltig zu pr√ºfen, und habe sie oberfl√§chlich durchgesehen.  Selbst dies wird jedoch ausreichen, um zu zeigen, dass solche Diagnosen sehr n√ºtzlich sind und interessante Fehler finden. <br><br>  Ich m√∂chte mit der klassischen Situation beginnen, in der die Funktion zum Vergleichen zweier Objekte falsch implementiert ist.  Warum klassisch?  Dies ist ein typisches Fehlermuster, auf das wir in einer Vielzahl von Projekten st√§ndig sto√üen.  H√∂chstwahrscheinlich gibt es drei Gr√ºnde f√ºr sein Auftreten: <br><br><ol><li>  Die Vergleichsfunktionen sind einfach und werden ‚Äûautomatisch‚Äú und mithilfe der Copy-Paste-Technologie geschrieben.  Beim Schreiben eines solchen Codes ist eine Person unaufmerksam und macht h√§ufig Tippfehler. </li><li>  In der Regel wird f√ºr solche Funktionen keine Code√ºberpr√ºfung durchgef√ºhrt, da es zu faul ist, einfache und langweilige Funktionen zu betrachten. </li><li>  Unit-Tests werden f√ºr solche Funktionen normalerweise nicht durchgef√ºhrt.  Weil Faulheit.  Dar√ºber hinaus sind die Funktionen einfach und Programmierer glauben nicht, dass Fehler in ihnen m√∂glich sind. </li></ol><br>  Diese Gedanken und Beispiele werden im Artikel "Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B√∂se lebt in den Funktionen des Vergleichs</a> " ausf√ºhrlicher beschrieben. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAudioPlaybackRateEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AudioPlaybackRate &amp;pr1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AudioPlaybackRate &amp;pr2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(pr1.mSpeed - pr2.mSpeed) &lt; AUDIO_TIMESTRETCH_SPEED_MIN_DELTA &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(pr1.mPitch - pr2.mPitch) &lt; AUDIO_TIMESTRETCH_PITCH_MIN_DELTA &amp;&amp; pr2.mStretchMode == pr2.mStretchMode &amp;&amp; pr2.mFallbackMode == pr2.mFallbackMode; }</code> </pre> <br>  Vor uns liegt also die klassische Funktion, zwei Objekte vom Typ <i>AudioPlaybackRate zu vergleichen</i> .  Und wie ich denke, vermutet der Leser, dass es falsch ist.  Der PVS-Studio-Analysator bemerkt sofort zwei Tippfehler: <br><br><ul><li>  V501 CWE-571 Links und rechts vom Operator '==' befinden sich identische Unterausdr√ºcke: pr2.mStretchMode == pr2.mStretchMode AudioResamplerPublic.h 107 </li><li>  V501 CWE-571 Links und rechts vom Operator '==' befinden sich identische Unterausdr√ºcke: pr2.mFallbackMode == pr2.mFallbackMode AudioResamplerPublic.h 108 </li></ul><br>  Das Feld <i>pr2.mStretchMode</i> und das Feld <i>pr2.mFallbackMode werden</i> mit sich selbst verglichen.  Es stellt sich heraus, dass die Funktion Objekte nicht genau genug vergleicht. <br><br>  Der folgende sinnlose Vergleich befindet sich in einer Funktion, die Fingerabdruckinformationen in einer Datei speichert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveFingerprint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">worker_thread_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* listener, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ns = fwrite(&amp;listener-&gt;secureid[idx], <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, fp); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nf = fwrite(&amp;listener-&gt;fingerid[idx], <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, fp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ns != <span class="hljs-number"><span class="hljs-number">1</span></span> || ns !=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= ALOGW("Corrupt emulator fingerprints storage; " "could not save fingerprints"); fclose(fp); return; }</span></span></code> </pre> <br>  In diesem Code wird eine Anomalie durch zwei Diagnosen gleichzeitig erkannt: <br><br><ul><li>  V501 CWE-570 Links und rechts vom '||' befinden sich identische Unterausdr√ºcke.  Operator: ns! = 1 ||  ns! = 1 Fingerabdruck.c 126 </li><li>  V560 CWE-570 Ein Teil des bedingten Ausdrucks ist immer falsch: ns! = 1. Fingerabdruck.c 126 </li></ul><br>  Es gibt keine Behandlung der Situation, in der der zweite Aufruf der Funktion <i>fwrite</i> keine Daten in eine Datei schreiben kann.  Mit anderen Worten wird der Wert der Variablen <i>nf</i> nicht √ºberpr√ºft.  Die richtige Pr√ºfung sollte folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ns != <span class="hljs-number"><span class="hljs-number">1</span></span> || nf != <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Wir fahren mit dem n√§chsten Fehler fort, der mit der Verwendung des Operators <i>&amp; verbunden ist</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_RDONLY 00000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_WRONLY 00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_RDWR 00000002 static ssize_t verity_read(fec_handle *f, ....) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* if we are in read-only mode and expect to read a zero block, skip reading and just return zeros */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f-&gt;mode &amp; O_RDONLY &amp;&amp; expect_zeros) { memset(data, 0, FEC_BLOCKSIZE); goto valid; } .... }</span></span></code> </pre> <br>  PVS-Studio-Warnung: V560 CWE-570 Ein Teil des bedingten Ausdrucks ist immer falsch: f-&gt; mode &amp; 00000000. fec_read.cpp 322 <br><br>  Beachten Sie, dass die Konstante <i>O_RDONLY</i> Null ist.  Dies macht den Ausdruck <i>f-&gt; mode &amp; O_RDONLY</i> sinnlos, da er immer 0 ist. Es stellt sich heraus, dass die Bedingung der <i>if-Anweisung</i> niemals erf√ºllt ist und Anweisung-true toter Code ist. <br><br>  Die richtige Pr√ºfung sollte folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f-&gt;mode == O_RDONLY &amp;&amp; expect_zeros) {</code> </pre> <br>  Schauen wir uns nun einen klassischen Tippfehler an, als wir vergessen haben, einen Teil der Bedingung zu schreiben. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { .... CHANGE_DISPLAY_INFO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RotaryEncoderInputMapper::configure(<span class="hljs-keyword"><span class="hljs-keyword">nsecs_t</span></span> when, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InputReaderConfiguration* config, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> changes) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!changes || (InputReaderConfiguration::CHANGE_DISPLAY_INFO)) { .... }</code> </pre> <br>  PVS-Studio Warnung: V768 CWE-571 Die Aufz√§hlungskonstante 'CHANGE_DISPLAY_INFO' wird als Variable eines Booleschen Typs verwendet.  InputReader.cpp 3016 <br><br>  Die Bedingung ist immer wahr, da der Operand <i>InputReaderConfiguration :: CHANGE_DISPLAY_INFO</i> eine Konstante gleich 4 ist. <br><br>  Wenn Sie sich ansehen, wie der Code in der Nachbarschaft geschrieben ist, wird klar, dass die Bedingung tats√§chlich so sein sollte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!changes || (changes &amp; InputReaderConfiguration::CHANGE_DISPLAY_INFO)) {</code> </pre> <br>  Den folgenden Vergleich, der keinen Sinn ergibt, habe ich im Schleifenoperator getroffen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_printerAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">ipp_t</span></span> *collection = ippGetCollection(attrptr, i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>, attrptr = ippFirstAttribute(collection); (j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (attrptr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); attrptr = ippNextAttribute(collection)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....TopMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....BottomMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....LeftMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....RightMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } .... }</code> </pre> <br>  PVS-Studio Warnung: V560 CWE-571 Ein Teil des bedingten Ausdrucks ist immer wahr: (j &lt;4).  ipphelper.c 926 <br><br>  Beachten Sie, dass der Wert der Variablen <i>j</i> nirgendwo erh√∂ht wird.  Dies bedeutet, dass der Unterausdruck <i>(j &lt;4)</i> immer wahr ist. <br><br>  Die gr√∂√üte Anzahl n√ºtzlicher Operationen des PVS-Studio-Analysators, die immer wahre / falsche Bedingungen betreffen, bezieht sich auf den Code, in dem das Ergebnis der Erstellung von Objekten mit dem <i>neuen</i> Operator √ºberpr√ºft wird.  Mit anderen Worten, der Analysator erkennt das folgende Codemuster: <br><br><pre> <code class="cpp hljs">T *p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR;</code> </pre> <br>  Solche √úberpr√ºfungen sind sinnlos.  Wenn es nicht m√∂glich war, Speicher f√ºr das Objekt zuzuweisen, wird eine Ausnahme vom Typ <i>std :: bad_alloc ausgel√∂st,</i> und der Zeigerwert wird nur nicht √ºberpr√ºft. <br><br>  Hinweis  Der <i>neue</i> Operator kann <i>nullptr zur√ºckgeben, indem</i> er <i>new (std :: nothrow) T schreibt.</i>  Dies gilt jedoch nicht f√ºr die besprochenen Fehler.  Der PVS-Studio-Analysator ber√ºcksichtigt <i>(std :: nothrow)</i> und gibt keine Warnung aus, wenn das Objekt auf diese Weise erstellt wird. <br><br>  Es scheint, dass solche Fehler harmlos sind.  Denken Sie daran, ein zus√§tzlicher Scheck, der niemals funktioniert.  Auf jeden Fall wird eine Ausnahme ausgel√∂st, die irgendwo verarbeitet wird.  Leider setzen einige Entwickler in die Anweisung-true der <i>if-Anweisungsaktionen</i> , die Ressourcen usw. freisetzen.  Da dieser Code nicht ausgef√ºhrt wird, kann dies zu Speicherlecks und anderen Fehlern f√ºhren. <br><br>  Betrachten Sie einen dieser F√§lle, die mir im Android-Code aufgefallen sind. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_apk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *target_package_name)</span></span></span><span class="hljs-function"> </span></span>{ .... FileMap *dataMap = zip-&gt;createEntryFileMap(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataMap == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ALOGW(<span class="hljs-string"><span class="hljs-string">"%s: failed to create FileMap\n"</span></span>, __FUNCTION__); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[uncompLen]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> == buf) { ALOGW(<span class="hljs-string"><span class="hljs-string">"%s: failed to allocate %"</span></span> PRIu32 <span class="hljs-string"><span class="hljs-string">" byte\n"</span></span>, __FUNCTION__, uncompLen); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dataMap; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warnung: V668 CWE-570 Es macht keinen Sinn, den 'buf'-Zeiger gegen null zu testen, da der Speicher mit dem' neuen 'Operator zugewiesen wurde.  Die Ausnahme wird bei einem Speicherzuordnungsfehler generiert.  scan.cpp 213 <br><br>  Bitte beachten Sie, dass der Programmierer versucht, den ersten Block freizugeben, wenn es nicht m√∂glich ist, einen zweiten Speicherblock zuzuweisen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dataMap;</code> </pre> <br>  Dieser Code wird niemals die Kontrolle bekommen.  Das ist toter Code.  Wenn eine Ausnahme auftritt, tritt ein Speicherverlust auf. <br><br>  Das Schreiben eines solchen Codes ist grunds√§tzlich falsch.  F√ºr solche F√§lle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden intelligente Zeiger</a> erfunden. <br><br>  Insgesamt hat der PVS-Studio-Analysator <b>176</b> Stellen im Android-Code erkannt, an denen der Zeiger √ºberpr√ºft wird, nachdem Objekte mit <i>new erstellt wurden</i> .  Ich habe nicht verstanden, wie gef√§hrlich jeder dieser Orte ist, und nat√ºrlich werde ich den Artikel nicht mit all diesen Warnungen √ºberladen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interessenten</a> k√∂nnen andere Warnungen in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android_V668.txt sehen</a> . <br><br><h2>  Dereferenzieren eines Nullzeigers </h2><br>  Das Dereferenzieren eines Nullzeigers f√ºhrt zu einem undefinierten Programmverhalten. Daher ist es hilfreich, solche Stellen zu finden und zu beheben.  Abh√§ngig von der Situation kann der PVS-Studio-Analysator diese Fehler gem√§√ü der Common Weakness Enumeration wie folgt klassifizieren: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-119</a> : Unsachgem√§√üe Einschr√§nkung von Operationen innerhalb der Grenzen eines Speicherpuffers </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-476</a> : NULL-Zeiger-Dereferenzierung </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-628</a> : Funktionsaufruf mit falsch angegebenen Argumenten </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-690</a> : Deaktivierter R√ºckgabewert f√ºr NULL-Zeiger-Dereferenzierung </li></ul><br>  Ich finde solche Fehler oft im Code, der f√ºr den Umgang mit nicht standardm√§√üigen oder falschen Situationen verantwortlich ist.  Niemand testet solchen Code, und der Fehler kann sehr lange darin leben.  Ein solcher Fall wird jetzt betrachtet. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseEffect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xmlProxyLib == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { ALOGE(<span class="hljs-string"><span class="hljs-string">"effectProxy must contain a &lt;%s&gt;: %s"</span></span>, tag, dump(*xmlProxyLib)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warnung: V522 CWE-476 Es kann zu einer Dereferenzierung des Nullzeigers 'xmlProxyLib' kommen.  EffectsConfig.cpp 205 <br><br>  Wenn der <i>xmlProxyLib-</i> Zeiger <i>nullptr ist</i> , zeigt der Programmierer eine Debug-Meldung an, f√ºr die dieser Zeiger dereferenziert werden muss.  Ups ... <br><br>  Betrachten Sie nun eine interessantere Version des Fehlers. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">soinfo_unload_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(soinfo* root)</span></span></span><span class="hljs-function"> </span></span>{ .... soinfo* needed = find_library(si-&gt;get_primary_namespace(), library_name, RTLD_NOLOAD, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needed != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= PRINT("warning: couldn't find %s needed by %s on unload.", library_name, si-&gt;get_realpath()); return; } else if (local_unload_list.contains(needed)) { return; } else if (needed-&gt;is_linked() &amp;&amp; // &lt;= needed-&gt;get_local_group_root() != root) { external_unload_list.push_back(needed); } else { unload_list.push_front(needed); } .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: V522 CWE-476 Es kann zu einer Dereferenzierung des Nullzeigers 'ben√∂tigt' kommen.  linker.cpp 1847 <br><br>  Wenn der Zeiger <i>ben√∂tigt wird! = Nullptr</i> , wird eine Warnung ausgegeben, was ein sehr verd√§chtiges Verhalten des Programms ist.  Es wird schlie√ülich klar, dass der Code einen Fehler enth√§lt, wenn Sie unten <i>nachsehen</i> , dass bei <i>Bedarf == nullptr</i> der Nullzeiger in dem Ausdruck <i>erforderlich-&gt; is_linked ()</i> dereferenziert wird. <br><br>  H√∂chstwahrscheinlich sind die Operatoren! = Und == hier einfach verwirrt.  Wenn Sie ersetzen, ist der Funktionscode sinnvoll und der Fehler verschwindet. <br><br>  Der Gro√üteil der Warnungen bez√ºglich der m√∂glichen Dereferenzierung eines Nullzeigers bezieht sich auf eine Situation der Form: <br><br><pre> <code class="cpp hljs">T *p = (T *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> (N); *p = x;</code> </pre> <br>  Funktionen wie <i>malloc</i> , <i>strdup</i> usw. k√∂nnen <i>NULL zur√ºckgeben,</i> wenn kein Speicher zugewiesen werden kann.  Daher k√∂nnen Sie Zeiger, die diese Funktionen zur√ºckgeben, nicht dereferenzieren, ohne zuvor den Zeiger zu √ºberpr√ºfen. <br><br>  Es gibt viele √§hnliche Fehler, daher werde ich nur zwei einfache Codefragmente angeben: das erste mit <br>  <i>malloc</i> und der zweite mit <i>strdup</i> . <br><br><pre> <code class="cpp hljs">DownmixerBufferProvider::DownmixerBufferProvider(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">effect_param_t</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> param = (<span class="hljs-keyword"><span class="hljs-keyword">effect_param_t</span></span> *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(downmixParamSize); param-&gt;psize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">downmix_params_t</span></span>); .... }</code> </pre> <br>  PVS-Studio Warnung: V522 CWE-690 M√∂glicherweise wird ein potenzieller Nullzeiger 'param' dereferenziert.  √úberpr√ºfen Sie die Zeilen: 245, 244. BufferProviders.cpp 245 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">descriptorClassToDot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* str)</span></span></span><span class="hljs-function"> </span></span>{ .... newStr = strdup(lastSlash); newStr[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(lastSlash)<span class="hljs-number"><span class="hljs-number">-1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  PVS-Studio Warnung: V522 CWE-690 M√∂glicherweise wird ein potenzieller Nullzeiger 'newStr' dereferenziert.  √úberpr√ºfen Sie die Zeilen: 203, 202. DexDump.cpp 203 <br><br>  Jemand k√∂nnte sagen, dass dies kleinere Fehler sind.  Wenn nicht gen√ºgend Speicher vorhanden ist, st√ºrzt das Programm beim Dereferenzieren des Nullzeigers einfach ab. Dies ist normal.  Da es keinen Speicher gibt, gibt es nichts zu versuchen, mit dieser Situation irgendwie umzugehen. <br><br>  Eine solche Person ist falsch.  Zeiger m√ºssen √ºberpr√ºft werden!  Ich habe dieses Thema im Artikel ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum ist es wichtig zu √ºberpr√ºfen, was die Malloc-Funktion zur√ºckgegeben hat</a> ‚Äú ausf√ºhrlich untersucht.  Ich empfehle Ihnen dringend, es allen vorzulesen, die es nicht gelesen haben. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/793/0c5/9237930c52039f4f7e0542bee775ce72.png" alt="malloc"></div><br><br>  Kurz gesagt besteht die Gefahr, dass das Schreiben in den Speicher nicht unbedingt in der N√§he der Nulladresse erfolgt.  Es ist m√∂glich, Daten irgendwo sehr weit in eine Speicherseite zu schreiben, die nicht schreibgesch√ºtzt ist, und dadurch einen schwer fassbaren Fehler zu verursachen, oder im Allgemeinen kann dieser Fehler als Sicherheitsanf√§lligkeit verwendet werden.  Mal sehen, was ich am Beispiel der Funktion <i>check_size meine</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">radio_metadata_buffer_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **metadata_ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_int)</span></span></span><span class="hljs-function"> </span></span>{ .... metadata = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(metadata, new_size_int * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); memmove( (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)metadata + new_size_int - (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)metadata + metadata-&gt;size_int - (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>), (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); .... }</code> </pre> <br>  PVS-Studio-Warnung: V769 CWE-119 Der Zeiger '(uint32_t *) Metadaten' im Ausdruck '(uint32_t *) Metadaten + new_size_int' k√∂nnte nullptr sein.  In diesem Fall ist der resultierende Wert sinnlos und sollte nicht verwendet werden.  √úberpr√ºfen Sie die Zeilen: 91, 89. radio_metadata.c 91 <br><br>  Ich habe die Logik der Funktion nicht verstanden, aber das ist nicht notwendig.  Hauptsache, es wird ein neuer Puffer erstellt und die Daten dort kopiert.  Wenn die <i>Realloc-</i> Funktion <i>NULL</i> zur√ºckgibt, werden die Daten an die Adresse ((uint32_t *) NULL + Metadaten-&gt; size_int - (Metadaten-&gt; Anzahl + 1)) kopiert. <br><br>  Wenn der <i>Wert f√ºr metadata-&gt; size_int</i> gro√ü ist, sind die Konsequenzen bedauerlich.  Es stellt sich heraus, dass die Daten in einen zuf√§lligen Speicher geschrieben werden. <br><br>  √úbrigens gibt es eine andere Art der Nullzeiger-Dereferenzierung, die der PVS-Studio-Analysator nicht als CWE-690, sondern als CWE-628 (ung√ºltiges Argument) klassifiziert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_tcp_ports</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *portstring, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ports)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buffer; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp; buffer = strdup(portstring); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cp = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">':'</span></span>)) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) .... }</code> </pre> <br>  PVS-Studio Warnung: V575 CWE-628 Der potenzielle Nullzeiger wird an die Funktion 'strchr' √ºbergeben.  √úberpr√ºfen Sie das erste Argument.  √úberpr√ºfen Sie die Zeilen: 47, 46. libxt_tcp.c 47 <br><br>  Tatsache ist, dass eine Zeiger-Dereferenzierung auftritt, wenn die <i>strchr-</i> Funktion <i>aufgerufen wird</i> .  Daher interpretiert der Analysator diese Situation so, dass er einen falschen Wert an die Funktion √ºbergibt. <br><br>  Die restlichen <b>194</b> Warnungen dieses Typs liste ich in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android_V522_V575.txt auf</a> . <br><br>  Eine besondere Pikantheit f√ºr all diese Fehler bieten √ºbrigens die zuvor erl√§uterten Warnungen zum √úberpr√ºfen des Zeigers nach dem Aufrufen des <i>neuen</i> Operators.  Es stellt sich heraus, dass 195 Aufrufe der Funktionen <i>malloc</i> / <i>realloc</i> / <i>strdup</i> usw. <i>vorliegen</i> , wenn der Zeiger nicht <i>aktiviert</i> ist.  Es gibt jedoch 176 Stellen, an denen der Zeiger nach dem Aufruf von <i>new</i> √ºberpr√ºft wird.  Stimmen Sie zu, ein seltsamer Ansatz! <br><br>  Am Ende m√ºssen wir nur die Warnungen V595 und V1004 ber√ºcksichtigen, die auch mit der Verwendung von Nullzeigern verbunden sind. <br><br>  V595 erkennt Situationen, in denen der Zeiger dereferenziert und dann √ºberpr√ºft wird.  Synthetisches Beispiel: <br><br><pre> <code class="cpp hljs">p-&gt;foo(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) Error();</code> </pre> <br>  V1004 zeigt die umgekehrte Situation an, als der Zeiger zuerst √ºberpr√ºft und dann vergessen wurde.  Synthetisches Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p) p-&gt;foo(); p-&gt;doo();</code> </pre> <br>  Schauen wir uns einige Fragmente des Android-Codes an, bei denen Fehler dieses Typs aufgetreten sind.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speziell erkl√§ren, dass ihre Funktionen nicht erforderlich sind. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">PV_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RC_UpdateBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VideoEncData *video, Int currLayer, Int num_skip)</span></span></span><span class="hljs-function"> </span></span>{ rateControl *rc = video-&gt;rc[currLayer]; MultiPass *pMP = video-&gt;pMP[currLayer]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (video == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || rc == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || pMP == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PV_FAIL; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V595 CWE-476 Der 'Video'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 385, 388. rate_control.cpp 385</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resampler_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct resampler_itfe *resampler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rsmp</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class">;</span></span> rsmp-&gt;frames_in = <span class="hljs-number"><span class="hljs-number">0</span></span>; rsmp-&gt;frames_rq = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rsmp != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; rsmp-&gt;speex_resampler != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { speex_resampler_reset_mem(rsmp-&gt;speex_resampler); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V595 CWE-476 Der Zeiger 'rsmp' wurde verwendet, bevor er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 54, 57. Resampler.c 54</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bta_gattc_disc_cmpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tBTA_GATTC_CLCB* p_clcb, UNUSED_ATTR tBTA_GATTC_DATA* p_data)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_clcb-&gt;status != GATT_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_clcb-&gt;p_srcb) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;tBTA_GATTC_SERVICE&gt;().swap( p_clcb-&gt;p_srcb-&gt;srvc_cache); } bta_gattc_cache_reset(p_clcb-&gt;p_srcb-&gt;server_bda); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-Warnung: V1004 CWE-476 Der Zeiger 'p_clcb-&gt; p_srcb' wurde unsicher verwendet, nachdem er gegen nullptr √ºberpr√ºft wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 695, 701. bta_gattc_act.cc 701 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist nicht interessant, andere Warnungen dieses Typs zu ber√ºcksichtigen. </font><font style="vertical-align: inherit;">Darunter befinden sich sowohl Fehler als auch falsche Warnungen, die aufgrund von schlecht oder schwer geschriebenem Code auftreten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe ein Dutzend n√ºtzliche Warnungen geschrieben:</font></font><br><br><ul><li> V1004 CWE-476 The 'ain' pointer was used unsafely after it was verified against nullptr. Check lines: 101, 105. rsCpuIntrinsicBLAS.cpp 105 </li><li> V595 CWE-476 The 'outError' pointer was utilized before it was verified against nullptr. Check lines: 437, 450. Command.cpp 437 </li><li> V595 CWE-476 The 'out_last_reference' pointer was utilized before it was verified against nullptr. Check lines: 432, 436. AssetManager2.cpp 432 </li><li> V595 CWE-476 The 'set' pointer was utilized before it was verified against nullptr. Check lines: 4524, 4529. ResourceTypes.cpp 4524 </li><li> V595 CWE-476 The 'reply' pointer was utilized before it was verified against nullptr. Check lines: 126, 133. Binder.cpp 126 </li><li> V595 CWE-476 The 'video' pointer was utilized before it was verified against nullptr. Check lines: 532, 540. rate_control.cpp 532 </li><li> V595 CWE-476 The 'video' pointer was utilized before it was verified against nullptr. Check lines: 702, 711. rate_control.cpp 702 </li><li> V595 CWE-476 The 'pInfo' pointer was utilized before it was verified against nullptr. Check lines: 251, 254. ResolveInfo.cpp 251 </li><li> V595 CWE-476 The 'address' pointer was utilized before it was verified against nullptr. Check lines: 53, 55. DeviceHalHidl.cpp 53 </li><li> V595 CWE-476 The 'halAddress' pointer was utilized before it was verified against nullptr. Check lines: 55, 82. DeviceHalHidl.cpp 55 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dann langweilte ich mich und filterte Warnungen dieser Art heraus. Daher wei√ü ich nicht einmal, wie viele echte Fehler der Analysator erkannt hat. Diese Warnungen warten auf ihren Helden, der sie sorgf√§ltig studiert und √Ñnderungen am Code vornimmt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte meine neuen Leser nur auf Fehler dieser Art aufmerksam machen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NJ_EXTERN NJ_INT16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">njx_search_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NJ_CLASS *iwnn, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... NJ_PREVIOUS_SELECTION_INFO *prev_info = &amp;(iwnn-&gt;previous_selection); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iwnn == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NJ_SET_ERR_VAL(NJ_FUNC_NJ_SEARCH_WORD, NJ_ERR_PARAM_ENV_NULL); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V595 CWE-476 Der Zeiger 'iwnn' wurde verwendet, bevor er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 686, 689. ndapi.c 686 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Leute denken, dass hier kein Fehler vorliegt, weil "es keine echte Dereferenzierung des Zeigers gibt". </font><font style="vertical-align: inherit;">Die Adresse einer nicht vorhandenen Variablen wird einfach berechnet. </font><font style="vertical-align: inherit;">Wenn der Zeiger </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Null ist, wird die Funktion beendet. </font><font style="vertical-align: inherit;">Daher ist nichts Schlimmes passiert, dass wir zuvor die Adresse eines Klassenmitglieds falsch berechnet haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nein, so kannst du nicht reden. </font><font style="vertical-align: inherit;">Dieser Code f√ºhrt zu undefiniertem Verhalten und kann daher nicht so geschrieben werden. </font><font style="vertical-align: inherit;">Undefiniertes Verhalten kann sich beispielsweise wie folgt manifestieren:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Compiler sieht den Zeiger dereferenziert: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn-&gt; previous_selection</font></font></i> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie k√∂nnen einen Nullzeiger nicht dereferenzieren, da dies ein undefiniertes Verhalten ist </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Compiler kommt zu dem Schluss, dass der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger </font><font style="vertical-align: inherit;">immer ungleich Null ist</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Compiler entfernt die zus√§tzliche Pr√ºfung: if (iwnn == NULL) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt, wenn das Programm ausgef√ºhrt wird, wird die Pr√ºfung auf den Nullzeiger nicht durchgef√ºhrt, und die Arbeit beginnt mit dem falschen Zeiger auf das Klassenmitglied </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Thema wird in meinem Artikel " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dereferenzieren eines Nullzeigers f√ºhrt zu undefiniertem Verhalten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">ausf√ºhrlicher beschrieben </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Private Daten werden nicht im Speicher gel√∂scht </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich eine schwerwiegende potenzielle Sicherheitsanf√§lligkeit vor, die gem√§√ü der Common Weakness Enumeration als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-14</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Compiler-Entfernung von Code zum L√∂schen von Puffern </font><font style="vertical-align: inherit;">klassifiziert wird </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurz gesagt, das Fazit lautet: Der Compiler hat das Recht, den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionsaufruf zu entfernen, </font><font style="vertical-align: inherit;">wenn der Puffer danach nicht mehr verwendet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ich √ºber diese Art von Sicherheitsanf√§lligkeit schreibe, erscheinen Kommentare notwendigerweise, dass dies nur ein Fehler im Compiler ist, der behoben werden muss. </font><font style="vertical-align: inherit;">Nein, das ist keine Panne. </font><font style="vertical-align: inherit;">Bevor Sie Einw√§nde erheben, lesen Sie bitte die folgenden Materialien:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roman Fomichev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Private Daten sicher bereinigen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung der allgemeinen Schw√§chen. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-14</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diagnose </font><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen ist alles ernst. </font><font style="vertical-align: inherit;">Gibt es solche Fehler in Android?</font></font> Nat√ºrlich gibt es.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt im Allgemeinen viele, wo es gibt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beweise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :). </font><i><font style="vertical-align: inherit;">Kehren</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir zum Android-Code zur√ºck und schauen uns den Anfang und das Ende der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FwdLockGlue_InitializeRoundKeys an</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , da die Mitte f√ºr uns nicht interessant ist.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FwdLockGlue_InitializeRoundKeys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> keyEncryptionKey[KEY_SIZE]; .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(keyEncryptionKey, <span class="hljs-number"><span class="hljs-number">0</span></span>, KEY_SIZE); <span class="hljs-comment"><span class="hljs-comment">// Zero out key data. }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V597 CWE-14 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der Puffer 'keyEncryptionKey' geleert wird. Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen. FwdLockGlue.c 102 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Array </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keyEncryptionKey</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird auf dem Stapel erstellt und speichert private Informationen. Am Ende der Funktion m√∂chten sie dieses Array mit Nullen f√ºllen, damit es nicht versehentlich dort ankommt, wo es nicht sein sollte. Wie Informationen dahin gelangen k√∂nnen, wo sie nicht sein sollten, wird der Artikel " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher √ºberschreiben - warum?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Array mit privaten Informationen mit Nullen zu f√ºllen, wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion verwendet </font><font style="vertical-align: inherit;">. Der Kommentar ‚ÄûSchl√ºsseldaten auf Null setzen‚Äú best√§tigt, dass wir alles richtig verstehen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist, dass der Compiler beim </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Release-Version mit sehr hoher Wahrscheinlichkeit den </font><i><font style="vertical-align: inherit;">Memset-</font></i><font style="vertical-align: inherit;"> Funktionsaufruf l√∂scht </font><font style="vertical-align: inherit;">. Da der Puffer nach dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufruf </font><font style="vertical-align: inherit;">nicht verwendet wird, ist der Aufruf der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion selbst </font><font style="vertical-align: inherit;">aus Sicht des Compilers √ºberfl√ºssig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warnungen schrieb ich eine Datei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android_V597.txt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gab einen weiteren Fehler, bei dem der Speicher nicht √ºberschrieben wurde, obwohl in diesem Fall die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memset-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">nichts damit zu tun hat.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SHA1Transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buffer[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">64</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a, b, c, d, e; .... <span class="hljs-comment"><span class="hljs-comment">/* Wipe variables */</span></span> a = b = c = d = e = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V1001 CWE-563 Die Variable 'a' wird zugewiesen, aber erst am Ende der Funktion verwendet. </font><font style="vertical-align: inherit;">sha1.c 213 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio hat eine Anomalie festgestellt, die darauf zur√ºckzuf√ºhren ist, dass Variablen nach dem Zuweisen von Werten nicht mehr verwendet werden. </font><font style="vertical-align: inherit;">Der Analysator klassifizierte diesen Defekt als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-563</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Zuordnung zu Variable ohne Verwendung. </font><font style="vertical-align: inherit;">Und formal hat er Recht, obwohl es sich hier tats√§chlich wieder um CWE-14 handelt. </font><font style="vertical-align: inherit;">Der Compiler wird diese Zuweisungen wegwerfen, da sie aus Sicht von C und C ++ √ºberfl√ºssig sind. </font><font style="vertical-align: inherit;">Infolgedessen beh√§lt der Stapel die alten Werte der Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e bei</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in denen private Daten gespeichert sind.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nicht spezifiziertes / implementierungsdefiniertes Verhalten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> W√§hrend Sie nicht m√ºde sind, schauen wir uns einen komplexen Fall an, der eine gr√ºndliche Beschreibung meinerseits erfordert. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> GGLfixed; <span class="hljs-function"><span class="hljs-function">GGLfixed </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gglFastDivx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GGLfixed n, GGLfixed d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((d&gt;&gt;<span class="hljs-number"><span class="hljs-number">24</span></span>) &amp;&amp; ((d&gt;&gt;<span class="hljs-number"><span class="hljs-number">24</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) { n &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; d &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gglMulx(n, gglRecip(d)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-Warnung: V793 Es ist seltsam, dass das Ergebnis der Anweisung '(d &gt;&gt; 24) + 1' Teil der Bedingung ist. </font><font style="vertical-align: inherit;">Vielleicht h√§tte diese Aussage mit etwas anderem verglichen werden sollen. </font><font style="vertical-align: inherit;">fixed.cpp 75 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Programmierer wollte √ºberpr√ºfen, ob die 8 h√∂herwertigen Bits der Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheiten enthalten, aber nicht alle Bits gleichzeitig. </font><font style="vertical-align: inherit;">Mit anderen Worten, der Programmierer wollte √ºberpr√ºfen, ob sich ein anderer Wert als 0x00 und 0xFF im High-Byte befindet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Er ging die L√∂sung dieses Problems unn√∂tig kreativ an. Zun√§chst verifizierte er durch Schreiben eines Ausdrucks (d &gt;&gt; 24), dass die h√∂chstwertigen Bits ungleich Null sind. Es gibt Anspr√ºche auf diesen Ausdruck, aber es ist interessanter, die rechte Seite des Ausdrucks zu analysieren: ((d &gt;&gt; 24) +1). Der Programmierer verschiebt die hohen acht Bits in das niedrige Byte. Gleichzeitig wird berechnet, dass das h√∂chstwertige Vorzeichenbit in allen anderen Bits dupliziert wird.</font></font> Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Variable d 0b11111111'00000000'00000000'00000000 ist, erhalten wir nach der Verschiebung den Wert 0b11111111'11111111'111111'11111111. Durch Hinzuf√ºgen von 1 zum Wert 0xFFFFFFFF vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plant der Programmierer, 0 zu erhalten. Das hei√üt: -1 + 1 = 0. Mit dem Ausdruck ((d &gt;&gt; 24) +1) pr√ºft er also, ob nicht alle hohen acht Bits gleich 1 sind. Ich verstehe, dass dies ziemlich schwierig ist. Nehmen Sie sich also bitte Zeit und versuchen Sie herauszufinden, wie und was funktioniert :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun wollen wir sehen, was mit diesem Code nicht stimmt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Verschieben wird das h√∂chstwertige Vorzeichenbit nicht unbedingt "verschmiert". Der Standard sagt dazu Folgendes: ‚ÄûDer Wert von E1 &gt;&gt; E2 ist E1 nach rechts verschobene E2-Bitpositionen. Wenn E1 einen vorzeichenlosen Typ hat oder wenn E1 einen vorzeichenbehafteten Typ und einen nicht negativen Wert hat, ist der Wert des Ergebnisses der integrale Bestandteil des Quotienten von E1 / 2 ^ E2. Wenn E1 einen vorzeichenbehafteten Typ und einen negativen Wert hat, ist der resultierende Wert implementierungsdefiniert. " </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das neueste Angebot ist uns wichtig. Wir haben also das implementierungsdefinierte Verhalten erreicht. Wie dieser Code funktioniert, h√§ngt von der Mikroprozessorarchitektur und der Compiler-Implementierung ab. Nach der Verschiebung k√∂nnen Nullen in den h√∂chstwertigen Bits erscheinen, und dann unterscheidet sich der Ausdruck ((d &gt;&gt; 24) +1) immer von 0, d. H. wird immer wahrer Wert sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher die Schlussfolgerung: Keine Notwendigkeit, weise zu sein. </font><font style="vertical-align: inherit;">Der Code wird zuverl√§ssiger und verst√§ndlicher, wenn Sie beispielsweise Folgendes schreiben:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GGLfixed </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gglFastDivx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GGLfixed n, GGLfixed d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> hibits = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(d) &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hibits != <span class="hljs-number"><span class="hljs-number">0x00</span></span> &amp;&amp; hibits != <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { n &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; d &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gglMulx(n, gglRecip(d)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wahrscheinlich habe ich nicht die ideale Option vorgeschlagen, aber in diesem Code ist kein Verhalten durch die Implementierung definiert, und es wird f√ºr den Leser einfacher zu verstehen, was √ºberpr√ºft wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie verdienen eine Tasse Kaffee oder Tee. </font><font style="vertical-align: inherit;">Ablenken und weitermachen: Wir warten auf einen interessanten Fall von nicht n√§her bezeichnetem Verhalten.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/1a9/86b/f531a986b1bca57105eddf63d12bd50b.png" alt="Aufmerksamkeit"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend des Interviews stelle ich als eine der ersten Fragen an den Bewerber Folgendes: ‚ÄûWas wird die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion drucken </font><font style="vertical-align: inherit;">und warum?‚Äú</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d,%d"</span></span>, i++, i++)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die richtige Antwort: Dies ist ein nicht spezifiziertes Verhalten. </font><font style="vertical-align: inherit;">Die Prozedur zur Berechnung der tats√§chlichen Argumente beim Aufruf der Funktion ist nicht definiert. </font><font style="vertical-align: inherit;">Gelegentlich zeige ich sogar, dass dieser Code, der mit Hilfe von Visual C ++ kompiliert wurde, "6.5" auf dem Bildschirm anzeigt, was Neulinge mit schwachem Wissen und Geist zu einem v√∂lligen Stillstand bringt :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies scheint ein weit hergeholtes Problem zu sein. </font><font style="vertical-align: inherit;">Aber nein, dieser Code kann in ernsthaften Anwendungen gefunden werden, zum Beispiel in Android-Code.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ComposerClient::CommandReader::parseSetLayerCursorPosition( <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length != CommandWriterBase::kSetLayerCursorPositionLength) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> err = mHal.setLayerCursorPosition(mDisplay, mLayer, readSigned(), readSigned()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err != Error::NONE) { mWriter.setError(getCommandLoc(), err); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V681 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-758</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Sprachstandard definiert keine Reihenfolge, in der die Funktionen 'readSigned' bei der Auswertung von Argumenten aufgerufen werden. </font><font style="vertical-align: inherit;">ComposerClient.cpp 836 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Codezeile interessiert uns:</font></font><br><br><pre> <code class="cpp hljs">mHal.setLayerCursorPosition(...., readSigned(), readSigned());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Aufrufen der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readSigned</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">zwei Werte gelesen. </font><font style="vertical-align: inherit;">Es ist jedoch unm√∂glich vorherzusagen, in welcher Reihenfolge die Werte gelesen werden. </font><font style="vertical-align: inherit;">Dies ist ein klassischer Fall von nicht spezifiziertem Verhalten.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorteile der Verwendung eines statischen Code-Analysators </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem gesamten Artikel werden die statische Code-Analyse im Allgemeinen und unser PVS-Studio-Tool im Besonderen popul√§r gemacht. </font><font style="vertical-align: inherit;">Einige Fehler sind jedoch nur perfekt, um die M√∂glichkeiten der statischen Analyse zu demonstrieren. </font><font style="vertical-align: inherit;">Sie sind durch Code√ºberpr√ºfungen schwer zu identifizieren, und nur ein nicht m√ºdes Programm bemerkt sie leicht. </font><font style="vertical-align: inherit;">Betrachten Sie einige solcher F√§lle.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span>&gt; kBootReasonMap = { .... {<span class="hljs-string"><span class="hljs-string">"watchdog_sdi_apps_reset"</span></span>, <span class="hljs-number"><span class="hljs-number">106</span></span>}, {<span class="hljs-string"><span class="hljs-string">"smpl"</span></span>, <span class="hljs-number"><span class="hljs-number">107</span></span>}, {<span class="hljs-string"><span class="hljs-string">"oem_modem_failed_to_powerup"</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>}, {<span class="hljs-string"><span class="hljs-string">"reboot_normal"</span></span>, <span class="hljs-number"><span class="hljs-number">109</span></span>}, {<span class="hljs-string"><span class="hljs-string">"oem_lpass_cfg"</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// &lt;= {"oem_xpu_ns_error", 111}, // &lt;= {"power_key_press", 112}, {"hardware_reset", 113}, {"reboot_by_powerkey", 114}, {"reboot_verity", 115}, {"oem_rpm_undef_error", 116}, {"oem_crash_on_the_lk", 117}, {"oem_rpm_reset", 118}, {"oem_lpass_cfg", 119}, // &lt;= {"oem_xpu_ns_error", 120}, // &lt;= {"factory_cable", 121}, {"oem_ar6320_failed_to_powerup", 122}, {"watchdog_rpm_bite", 123}, {"power_on_cable", 124}, {"reboot_unknown", 125}, .... };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio-Warnungen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V766 CWE-462 Ein Element mit demselben Schl√ºssel "oem_lpass_cfg" wurde bereits hinzugef√ºgt. </font><font style="vertical-align: inherit;">bootstat.cpp 264</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V766 CWE-462 Ein Element mit demselben Schl√ºssel "oem_xpu_ns_error" wurde bereits hinzugef√ºgt. </font><font style="vertical-align: inherit;">bootstat.cpp 265</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiedene Werte mit denselben Schl√ºsseln werden in den </font><font style="vertical-align: inherit;">sortierten assoziativen Container ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: map</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) eingef√ºgt. In Bezug auf die Aufz√§hlung allgemeiner Schw√§chen ist dies der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-462</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Doppelter Schl√ºssel in </font><font style="vertical-align: inherit;">der </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">assoziativen</font></a><font style="vertical-align: inherit;"> Liste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Programmtext wird gek√ºrzt und Fehler werden mit Kommentaren markiert, sodass der Fehler offensichtlich erscheint. Wenn Sie diesen Code jedoch nur mit Ihren Augen lesen, ist es sehr schwierig, solche Fehler zu finden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich einen anderen Code vor, der sehr schwer zu lesen ist, da er vom gleichen Typ und uninteressant ist.</font></font><br><br><pre> <code class="cpp hljs">MtpResponseCode MyMtpDatabase::getDevicePropertyValue(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT8: packet.putInt8(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT8: packet.putUInt8(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT16: packet.putInt16(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT16: packet.putUInt16(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT32: packet.putInt32(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT32: packet.putUInt32(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT64: packet.putInt64(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT64: packet.putUInt64(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT128: packet.putInt128(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT128: packet.putInt128(longValue); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V525 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-682</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Code enth√§lt die Sammlung √§hnlicher Bl√∂cke. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Elemente 'putInt8', 'putUInt8', 'putInt16', 'putUInt16', 'putInt32', 'putUInt32', 'putInt64', 'putUInt64', 'putInt128', 'putInt128' in den Zeilen 620, 623, 626, 629 , 632, 635, 638, 641, 644, 647. android_mtp_MtpDatabase.cpp 620 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTP_TYPE_UINT128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hatte durch Funktion verursacht werden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putUInt128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nicht </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putInt128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und der letzte in diesem Abschnitt ist ein gro√üartiges Beispiel f√ºr erfolgloses Kopieren und Einf√ºgen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btif_rc_upstreams_evt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AVRC_PDU_REQUEST_CONTINUATION_RSP: { BTIF_TRACE_EVENT( <span class="hljs-string"><span class="hljs-string">"%s() REQUEST CONTINUATION: target_pdu: 0x%02d"</span></span>, __func__, pavrc_cmd-&gt;continu.target_pdu); tAVRC_RESPONSE avrc_rsp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dev-&gt;rc_connected == TRUE) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;(avrc_rsp.continu), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tAVRC_NEXT_RSP)); avrc_rsp.continu.opcode = opcode_from_pdu(AVRC_PDU_REQUEST_CONTINUATION_RSP); avrc_rsp.continu.pdu = AVRC_PDU_REQUEST_CONTINUATION_RSP; avrc_rsp.continu.status = AVRC_STS_NO_ERROR; avrc_rsp.continu.target_pdu = pavrc_cmd-&gt;continu.target_pdu; send_metamsg_rsp(p_dev, <span class="hljs-number"><span class="hljs-number">-1</span></span>, label, ctype, &amp;avrc_rsp); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AVRC_PDU_ABORT_CONTINUATION_RSP: { BTIF_TRACE_EVENT( <span class="hljs-string"><span class="hljs-string">"%s() ABORT CONTINUATION: target_pdu: 0x%02d"</span></span>, __func__, pavrc_cmd-&gt;<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu); tAVRC_RESPONSE avrc_rsp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dev-&gt;rc_connected == TRUE) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;(avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tAVRC_NEXT_RSP)); avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.opcode = opcode_from_pdu(AVRC_PDU_ABORT_CONTINUATION_RSP); avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.pdu = AVRC_PDU_ABORT_CONTINUATION_RSP; avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.status = AVRC_STS_NO_ERROR; avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu = pavrc_cmd-&gt;continu.target_pdu; send_metamsg_rsp(p_dev, <span class="hljs-number"><span class="hljs-number">-1</span></span>, label, ctype, &amp;avrc_rsp); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bevor Sie die Warnung und den weiteren Text des Analysators lesen, empfehle ich, den Fehler selbst zu suchen. </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83b/679/4ad/83b6794adb823b1fa52e18c91eff1ed2.png" alt="Ablenkendes Bild, Java"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit Sie die Antwort nicht versehentlich sofort lesen, finden Sie hier ein Bild, mit dem Sie die Aufmerksamkeit ablenken k√∂nnen. </font><font style="vertical-align: inherit;">Wenn Sie interessiert sind, was ein Ei mit der Aufschrift Java bedeutet, dann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier</font></a><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, Ihnen hat die Suche nach Tippfehlern gefallen. </font><font style="vertical-align: inherit;">Jetzt ist es an der Zeit, den Analysator zu warnen: V778 CWE-682 Es wurden zwei √§hnliche Codefragmente gefunden. </font><font style="vertical-align: inherit;">M√∂glicherweise ist dies ein Tippfehler und die Variable 'abort' sollte anstelle von 'continue' verwendet werden. </font><font style="vertical-align: inherit;">btif_rc.cc 1554 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anscheinend wurde der Code mit der Copy-Paste-Methode geschrieben, und eine Person konnte wie immer beim Bearbeiten des kopierten Codefragments nicht aufmerksam sein. </font><font style="vertical-align: inherit;">Infolgedessen ersetzte er ganz am Ende nicht " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " durch " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbrechen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br><br>  Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im zweiten Block sollte geschrieben werden: </font></font><br><br><pre> <code class="cpp hljs">avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu = pavrc_cmd-&gt;<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Situation f√§llt vollst√§ndig unter die Definition des " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Last-Line-Effekts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", da am Ende ein Fehler beim Ersetzen von Namen gemacht wurde.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesichtspalme </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein sehr lustiger Fehler h√§ngt mit der Konvertierung zwischen Little-Endian- und Big-Endian-Datenformaten zusammen (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytereihenfolge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bswap32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((pData &amp; <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x00FF0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x0000FF00</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x000000FF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ELFAttribute::merge(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> subsection_length = *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(subsection_data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (llvm::sys::IsLittleEndianHost != m_Config.targets().isLittleEndian()) bswap32(subsection_length); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V530 CWE-252 Der R√ºckgabewert der Funktion 'bswap32' muss verwendet werden. </font><font style="vertical-align: inherit;">ELFAttribute.cpp 84 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beschwerden </font><i><font style="vertical-align: inherit;">√ºber die</font></i><font style="vertical-align: inherit;"> Funktion </font><i><font style="vertical-align: inherit;">bswap32</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aber es wird falsch verwendet:</font></font><br><br><pre> <code class="cpp hljs">bswap32(subsection_length);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Autor schlug vor, die Variable als Referenz an die Funktion zu √ºbergeben und dort zu √§ndern. </font><font style="vertical-align: inherit;">Sie m√ºssen jedoch den von der Funktion zur√ºckgegebenen Wert verwenden. </font><font style="vertical-align: inherit;">Infolgedessen findet keine Datenkonvertierung statt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Analysator hat diesen Fehler als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-252</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Unchecked Return Value </font><font style="vertical-align: inherit;">identifiziert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tats√§chlich ist es jedoch angemessener, hier </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-198</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Verwendung der falschen Bytereihenfolge aufzurufen. </font><font style="vertical-align: inherit;">Leider kann der Analysator den Fehler aus einer √ºbergeordneten Sicht nicht verstehen. </font><font style="vertical-align: inherit;">Dies hindert ihn jedoch nicht daran, diesen schwerwiegenden Fehler im Code zu identifizieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der richtige Code lautet:</font></font><br><br><pre> <code class="cpp hljs">subsection_length = bswap32(subsection_length);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt drei weitere Stellen im Android-Code mit demselben Fehler: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252 Der R√ºckgabewert der Funktion 'bswap32' muss verwendet werden. </font><font style="vertical-align: inherit;">ELFAttribute.cpp 218</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252 Der R√ºckgabewert der Funktion 'bswap32' muss verwendet werden. </font><font style="vertical-align: inherit;">ELFAttribute.cpp 346</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252 Der R√ºckgabewert der Funktion 'bswap32' muss verwendet werden. </font><font style="vertical-align: inherit;">ELFAttribute.cpp 352</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um solche Fehler zu vermeiden, wird empfohlen, das Attribut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[nodiscard]] zu verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieses Attribut gibt an, dass der R√ºckgabewert einer Funktion beim Aufrufen verwendet werden muss. </font><font style="vertical-align: inherit;">Wenn Sie also so schreiben:</font></font><br><br><pre> <code class="cpp hljs">[[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bswap32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann w√ºrde der Fehler bereits beim Kompilieren der Datei erkannt. </font><font style="vertical-align: inherit;">Weitere Informationen zu einigen neuen n√ºtzlichen Attributen finden Sie im Artikel " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">meines Kollegen </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nicht erreichbarer Code </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Programmier- und Compilertheorie ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht erreichbarer Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Teil des Programmcodes, der unter keinen Umst√§nden ausgef√ºhrt werden kann, da er im Kontrollflussdiagramm nicht erreichbar ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus Sicht der Common Weakness Enumeration handelt es sich um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dead Code.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> sp&lt;IEffect&gt; createEffect(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pDesc == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> effect; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { *status = BAD_VALUE; } } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V779 CWE-561 Nicht erreichbarer Code erkannt. </font><font style="vertical-align: inherit;">M√∂glicherweise liegt ein Fehler vor. </font><font style="vertical-align: inherit;">IAudioFlinger.cpp 733 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return-Anweisung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muss sich explizit unten befinden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Fehler dieses Typs:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561 Nicht erreichbarer Code erkannt. </font><font style="vertical-align: inherit;">M√∂glicherweise liegt ein Fehler vor. </font><font style="vertical-align: inherit;">bta_hf_client_main.cc 612</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561 Nicht erreichbarer Code erkannt. </font><font style="vertical-align: inherit;">M√∂glicherweise liegt ein Fehler vor. </font><font style="vertical-align: inherit;">android_media_ImageReader.cpp 468</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561 Nicht erreichbarer Code erkannt. </font><font style="vertical-align: inherit;">M√∂glicherweise liegt ein Fehler vor. </font><font style="vertical-align: inherit;">AMPEG4AudioAssembler.cpp 187</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pause </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergessene </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterbrechung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein klassischer Fehler von C- und C ++ - Programmierern. </font><font style="vertical-align: inherit;">Um dem entgegenzuwirken, wurde in C ++ 17 eine n√ºtzliche Anmerkung als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[fallthrough]] angezeigt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie k√∂nnen </font><font style="vertical-align: inherit;">mehr √ºber diesen Fehler und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[Fallthrough]]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in meinem Artikel " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Break and Fallthrough</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">lesen</font></a><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber w√§hrend die Welt voll von altem Code ist, in dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fallthrough</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht verwendet wird, ist PVS-Studio f√ºr Sie n√ºtzlich. </font><font style="vertical-align: inherit;">Betrachten Sie einige Fehler in Android gefunden. </font><font style="vertical-align: inherit;">Gem√§√ü der Common Weakness Enumeration werden diese Fehler als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-484</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ausgelassene Unterbrechungsanweisung in Switch </font><font style="vertical-align: inherit;">klassifiziert </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> A2dpCodecConfigLdac::setCodecConfig(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_192000: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sampleRate &amp; A2DP_LDAC_SAMPLING_FREQ_192000) { result_config_cie.sampleRate = A2DP_LDAC_SAMPLING_FREQ_192000; codec_capability_.sample_rate = codec_user_config_.sample_rate; codec_config_.sample_rate = codec_user_config_.sample_rate; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_16000: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_24000: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_NONE: codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE; codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V796 CWE-484 M√∂glicherweise fehlt die Anweisung 'break' in der Anweisung switch. </font><font style="vertical-align: inherit;">a2dp_vendor_ldac.cc 912 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, der Fehler bedarf keiner Erkl√§rung. </font><font style="vertical-align: inherit;">Ich stelle nur fest, dass eine Anomalie im Code h√§ufig auf mehr als eine Weise erkannt wird. </font><font style="vertical-align: inherit;">Dieser Fehler wird beispielsweise auch durch V519-Warnungen erkannt:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V519 CWE-563 Der Variablen 'codec_capability_.sample_rate' werden zweimal nacheinander Werte zugewiesen. </font><font style="vertical-align: inherit;">Vielleicht ist das ein Fehler. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 910, 916. a2dp_vendor_ldac.cc 916</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V519 CWE-563 Der Variablen 'codec_config_.sample_rate' werden zweimal hintereinander Werte zugewiesen. </font><font style="vertical-align: inherit;">Vielleicht ist das ein Fehler. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 911, 917. a2dp_vendor_ldac.cc 917</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und noch ein paar Fehler: </font></font><br><br><pre> <code class="cpp hljs">Return&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; EffectsFactory::getAllDescriptors(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> -ENOSYS: { <span class="hljs-comment"><span class="hljs-comment">// Effect list has changed. goto restart; } case -ENOENT: { // No more effects available. result.resize(i); } default: { result.resize(0); retval = Result::NOT_INITIALIZED; } } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V796 CWE-484 M√∂glicherweise fehlt die Anweisung 'break' in der Anweisung switch. </font><font style="vertical-align: inherit;">EffectsFactory.cpp 118</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reverb_getParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REFLECTIONS_LEVEL: *(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REFLECTIONS_DELAY: *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REVERB_DELAY: *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V796 CWE-484 M√∂glicherweise fehlt die Anweisung 'break' in der Anweisung switch. </font><font style="vertical-align: inherit;">EffectReverb.cpp 1847</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SLresult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IAndroidConfiguration_GetConfiguration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (IObjectToObjectID((thiz)-&gt;mThis)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SL_OBJECTID_AUDIORECORDER: result = android_audioRecorder_getConfig( (CAudioRecorder *) thiz-&gt;mThis, configKey, pValueSize, pConfigValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SL_OBJECTID_AUDIOPLAYER: result = android_audioPlayer_getConfig( (CAudioPlayer *) thiz-&gt;mThis, configKey, pValueSize, pConfigValue); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: result = SL_RESULT_FEATURE_UNSUPPORTED; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V796 CWE-484 M√∂glicherweise fehlt die Anweisung 'break' in der Anweisung switch. </font><font style="vertical-align: inherit;">IAndroidConfiguration.cpp 90</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Falsche Speicherverwaltung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier habe ich Fehler im Zusammenhang mit falscher Speicherverwaltung zusammengestellt. </font><font style="vertical-align: inherit;">Solche Warnungen werden gem√§√ü der Common Weakness Enumeration wie folgt klassifiziert:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-401</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Unsachgem√§√üe Freigabe des Speichers vor dem Entfernen der letzten Referenz ('Speicherleck')</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : R√ºckgabe der Stapelvariablenadresse</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-762</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Nicht √ºbereinstimmende Speicherverwaltungsroutinen</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beginnen wir mit Funktionen, die einen Verweis auf eine bereits zerst√∂rte Variable zur√ºckgeben. </font></font><br><br><pre> <code class="cpp hljs">TransformIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ++*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } TransformIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; --*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio-Warnungen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V558 CWE-562 Die Funktion gibt den Verweis auf das tempor√§re lokale Objekt zur√ºck: tmp. </font><font style="vertical-align: inherit;">transform_iterator.h 77</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V558 CWE-562 Die Funktion gibt den Verweis auf das tempor√§re lokale Objekt zur√ºck: tmp. </font><font style="vertical-align: inherit;">transform_iterator.h 92</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Funktionen ihre Ausf√ºhrung beendet haben, wird die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zerst√∂rt, da sie auf dem Stapel erstellt wurde. </font><font style="vertical-align: inherit;">Folglich geben Funktionen einen Verweis auf ein bereits zerst√∂rtes (nicht vorhandenes) Objekt zur√ºck. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die richtige L√∂sung w√§re, einen Wert von zur√ºckzugeben:</font></font><br><br><pre> <code class="cpp hljs">TransformIterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ++*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } TransformIterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; --*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie noch traurigeren Code, der besondere Aufmerksamkeit verdient. </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/b25/299/619b2529917e9570454e60bf9c27c3f8.png" alt="Gef√§hrlicher Code"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register_socket_transport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* serial, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local)</span></span></span><span class="hljs-function"> </span></span>{ atransport* t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> atransport(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!serial) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), <span class="hljs-string"><span class="hljs-string">"T-%p"</span></span>, t); serial = buf; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V507 CWE-562 Der Zeiger auf das lokale Array 'buf' wird au√üerhalb des Bereichs dieses Arrays gespeichert. Ein solcher Zeiger wird ung√ºltig. transport.cpp 1030 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein gef√§hrlicher Code. Wenn der tats√§chliche Wert des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seriellen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arguments </font><font style="vertical-align: inherit;">NULL ist, sollte ein tempor√§rer Puffer auf dem Stapel verwendet werden. Wenn der Hauptteil der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if-Anweisung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> endet, existiert das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><font style="vertical-align: inherit;">nicht mehr. Der Ort, an dem der Puffer erstellt wurde, kann zum Speichern anderer auf dem Stapel erstellter Variablen verwendet werden. In den Daten beginnt ein h√∂llisches Durcheinander, und die Folgen eines solchen Fehlers werden schlecht vorhergesagt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die folgenden Fehler beziehen sich auf inkompatible Methoden zum Erstellen und Zerst√∂ren von Objekten.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SensorService::SensorEventConnection::reAllocateCacheLocked(....) { <span class="hljs-keyword"><span class="hljs-keyword">sensors_event_t</span></span> *eventCache_new; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> new_cache_size = computeMaxCacheSizeLocked(); eventCache_new = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sensors_event_t</span></span>[new_cache_size]; .... <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mEventCache; mEventCache = eventCache_new; mCacheSize += count; mMaxCacheSize = new_cache_size; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-Warnung: V611 CWE-762 Der Speicher wurde mit dem Operator 'new T []' zugewiesen, aber mit dem Operator 'delete' freigegeben. √úberpr√ºfen Sie diesen Code. Es ist wahrscheinlich besser, 'delete [] mEventCache;' zu verwenden. √úberpr√ºfen Sie die Zeilen: 391, 384. SensorEventConnection.cpp 391 Hier ist </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alles einfach. Der Puffer, auf den ein Mitglied der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mEventCache-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">zeigt, wird mit dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operator </font><i><font style="vertical-align: inherit;">[]</font></i><font style="vertical-align: inherit;"> zugewiesen </font><font style="vertical-align: inherit;">. Und geben Sie diesen Speicher mit dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂schoperator frei</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies ist falsch und f√ºhrt zu undefiniertem Programmverhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñhnlicher Fehler:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">aaudio_result_t</span></span> AAudioServiceEndpointCapture::open(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mDistributionBuffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distributionBufferSizeBytes = getStreamInternal()-&gt;getFramesPerBurst() * getStreamInternal()-&gt;getBytesPerFrame(); mDistributionBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[distributionBufferSizeBytes]; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-Warnung: V611 CWE-762 Der Speicher wurde mit dem Operator 'new T []' zugewiesen, aber mit dem Operator 'delete' freigegeben. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie diesen Code. </font><font style="vertical-align: inherit;">Es ist wahrscheinlich besser, 'delete [] mDistributionBuffer;' zu verwenden. </font><font style="vertical-align: inherit;">AAudioServiceEndpointCapture.cpp 50 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, der Fehler bedarf keiner Erkl√§rung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der folgende Fall ist etwas interessanter, aber das Wesen des Fehlers ist genau das gleiche.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeifFrameInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... mIccData.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[iccSize]); .... } .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt; mIccData; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Falsche Verwendung von unique_ptr. </font></font> Der mit 'new []' zugewiesene Speicher wird mit 'delete' bereinigt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HeifDecoderAPI.h 62 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardm√§√üig </font><font style="vertical-align: inherit;">ruft </font><font style="vertical-align: inherit;">die Smart-Pointer- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klasse std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂schoperator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf, um ein Objekt zu zerst√∂ren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion wird der </font><font style="vertical-align: inherit;">Speicher jedoch mit dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operator </font><i><font style="vertical-align: inherit;">[]</font></i><font style="vertical-align: inherit;"> zugewiesen </font><font style="vertical-align: inherit;">.</font></font><br><br>  Die richtige Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[]&gt; mIccData;</code> </pre> <br>  Andere Fehler: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Falsche Verwendung von unique_ptr. </font></font> Der mit 'new []' zugewiesene Speicher wird mit 'delete' bereinigt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atrace.cpp 949 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Falsche Verwendung von unique_ptr. </font></font> Der mit 'new []' zugewiesene Speicher wird mit 'delete' bereinigt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atrace.cpp 950 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Falsche Verwendung von unique_ptr. </font></font> Der mit 'new []' zugewiesene Speicher wird mit 'delete' bereinigt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HeifDecoderImpl.cpp 102 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Falsche Verwendung von unique_ptr. </font></font> Der mit 'new []' zugewiesene Speicher wird mit 'delete' bereinigt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HeifDecoderImpl.cpp 166 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762 Falsche Verwendung von unique_ptr. </font></font> Der mit 'new []' zugewiesene Speicher wird mit 'delete' bereinigt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ColorSpace.cpp 360 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Speicherverlustfehler vervollst√§ndigen diesen Abschnitt. </font><font style="vertical-align: inherit;">Eine unangenehme √úberraschung ist, dass es mehr als 20 solcher Fehler gab. Es scheint mir, dass dies sehr schmerzhafte Fehler sein k√∂nnen, die zu einer allm√§hlichen Verringerung des freien Speichers bei l√§ngerem Dauerbetrieb des Betriebssystems f√ºhren.</font></font><br><br><pre> <code class="cpp hljs">Asset* Asset::createFromUncompressedMap(FileMap* dataMap, AccessMode mode) { _FileAsset* pAsset; <span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> result; pAsset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> _FileAsset; result = pAsset-&gt;openChunk(dataMap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != NO_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; pAsset-&gt;mAccessMode = mode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pAsset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio Warnung: V773 CWE-401 Die Funktion wurde beendet, ohne den Zeiger 'pAsset' loszulassen. </font></font> Ein Speicherverlust ist m√∂glich.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset.cpp 296 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es nicht m√∂glich war, einen bestimmten </font><font style="vertical-align: inherit;">Block </font><font style="vertical-align: inherit;">zu √∂ffnen, wird die Funktion beendet, ohne das Objekt zu zerst√∂ren, dessen Zeiger in der Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pAsset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infolgedessen tritt ein Speicherverlust auf. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Fehler sind √§hnlich, daher sehe ich keinen Grund, sie im Artikel zu ber√ºcksichtigen. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessenten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen andere Warnungen in der Datei sehen: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Android_V773.txt</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Array ins Ausland gehen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine gro√üe Anzahl fehlerhafter Muster, die zum √úberlauf des Arrays f√ºhren. </font><font style="vertical-align: inherit;">Bei Android habe ich nur ein Fehlermuster des folgenden Typs festgestellt:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || i &gt; MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; A[i] = x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C und C ++ sind Array-Zellen von 0 nummeriert, sodass der maximale Index eines Elements im Array um eins kleiner sein muss als die Gr√∂√üe des Arrays. </font><font style="vertical-align: inherit;">Die richtige Pr√ºfung sollte folgenderma√üen aussehen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || i &gt;= MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; A[i] = x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das √úberlaufen eines </font><font style="vertical-align: inherit;">Arrays wird gem√§√ü der Common Weakness Enumeration als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-119</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Unsachgem√§√üe Einschr√§nkung von Operationen innerhalb der Grenzen eines Speicherpuffers </font><font style="vertical-align: inherit;">klassifiziert </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sehen Sie sich an, wie diese Fehler im Android-Code aussehen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">btif_hf_cb_t</span></span> btif_hf_cb[BTA_AG_MAX_NUM_CLIENTS]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSlcConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RawAddress* bd_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!bd_addr) { LOG(WARNING) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string"><span class="hljs-string">": bd_addr is null"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = btif_hf_idx_by_bdaddr(bd_addr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || idx &gt; BTA_AG_MAX_NUM_CLIENTS) { LOG(WARNING) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string"><span class="hljs-string">": invalid index "</span></span> &lt;&lt; idx &lt;&lt; <span class="hljs-string"><span class="hljs-string">" for "</span></span> &lt;&lt; *bd_addr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> btif_hf_cb[idx].state == BTHF_CONNECTION_STATE_SLC_CONNECTED; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V557 CWE-119 Array-√úberlauf ist m√∂glich. </font><font style="vertical-align: inherit;">Der Wert des 'idx'-Index k√∂nnte 6 erreichen. Btif_hf.cc 277 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtige </font><font style="vertical-align: inherit;">Pr√ºfoption </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || idx &gt;= BTA_AG_MAX_NUM_CLIENTS) {</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Genau die gleichen Fehler wurden zwei weitere Dinge gefunden: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 CWE-119 Array-√úberlauf ist m√∂glich. </font><font style="vertical-align: inherit;">Der Wert des 'idx'-Index k√∂nnte 6 erreichen. Btif_hf.cc 869</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 CWE-119 Array-√úberlauf ist m√∂glich. </font><font style="vertical-align: inherit;">Der Wert des Index 'index' k√∂nnte 6 erreichen. Btif_rc.cc 374</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterbrochene Zyklen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt viele M√∂glichkeiten, einen fehlerhaften Zyklus zu schreiben. </font><font style="vertical-align: inherit;">Im Android-Code sind Fehler aufgetreten, die gem√§√ü der Common Weakness Enumeration wie folgt klassifiziert werden k√∂nnen:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Unsachgem√§√üe Eingabevalidierung</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-670</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Immer inkorrekte Implementierung des Kontrollflusses</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-691</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Unzureichendes Kontrollflussmanagement</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-834</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : √úberm√§√üige Iteration</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gleichzeitig gibt es nat√ºrlich auch andere M√∂glichkeiten, beim Schreiben von Zyklen ‚Äûdein eigenes Bein zu schie√üen‚Äú, aber diesmal haben sie mich nicht getroffen. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s is already in *.base_fs format, just ..... "</span></span>, ....); rewind(blk_alloc_file); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((c = fgetc(blk_alloc_file)) != EOF) { fputc(c, base_fs_file); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V739 CWE-20 EOF sollte nicht mit einem Wert vom Typ 'char' verglichen werden. Das '(c = fgetc (blk_alloc_file))' sollte vom Typ 'int' sein. blk_alloc_to_base_fs.c 61 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Analysator hat festgestellt, dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EOF-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstante </font><font style="vertical-align: inherit;">mit einer Variablen vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verglichen wird </font><font style="vertical-align: inherit;">. Mal sehen, warum dieser Code falsch ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fgetc</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert zur√ºck </font><font style="vertical-align: inherit;">, n√§mlich: Sie kann eine Zahl von 0 bis 255 oder EOF (-1) zur√ºckgeben. Der Lesewert wird in eine Variable vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char eingef√ºgt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aus diesem Grund wird ein Zeichen mit dem Wert 0xFF (255) zu -1 und wird genauso interpretiert wie das Ende einer Datei (EOF).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund solcher Fehler sto√üen Benutzer, die erweiterte ASCII-Codes verwenden, manchmal auf eine Situation, in der eines der Zeichen in ihrem Alphabet von Programmen falsch verarbeitet wird. Beispielsweise hat der letzte Buchstabe des russischen Alphabets in der Codierung Windows-1251 nur den Code 0xFF und wird von einigen Programmen als das Ende der Datei wahrgenommen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassend k√∂nnen wir sagen, dass die Bedingung zum Stoppen des Zyklus falsch geschrieben ist. Um die Situation zu beheben, muss die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom </font><font style="vertical-align: inherit;">Typ int sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir fahren fort und ber√ºcksichtigen bekanntere Fehler bei der Verwendung der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisung </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> AudioPolicyManager::registerPolicyMixes(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mixes.size(); i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mHwModules.size(); j++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (strcmp(AUDIO_HARDWARE_MODULE_ID_REMOTE_SUBMIX, mHwModules[j]-&gt;mName) == 0 &amp;&amp; mHwModules[j]-&gt;mHandle != 0) { rSubmixModule = mHwModules[j]; break; } .... } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V534 CWE-691 Es ist wahrscheinlich, dass im Operator 'for' eine falsche Variable verglichen wird. Betrachten Sie die √úberpr√ºfung von 'i'. AudioPolicyManager.cpp 2489 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund eines Tippfehlers in einer verschachtelten Schleife verwendet die Bedingung die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , obwohl Sie die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j verwenden m√ºssen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Infolgedessen wird die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unkontrolliert inkrementiert, was im Laufe der Zeit dazu f√ºhrt, dass das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mHwModules-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array </font><i><font style="vertical-align: inherit;">au√üerhalb der Grenzen liegt</font></i><font style="vertical-align: inherit;"> . Was als n√§chstes passieren wird, kann nicht vorhergesagt werden, da es ein undefiniertes Programmverhalten geben wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses fehlerhafte Fragment wurde √ºbrigens komplett in eine andere Funktion kopiert. Daher hat der Analysator hier genau den gleichen Fehler gefunden: AudioPolicyManager.cpp 2586.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt 3 weitere Codefragmente, die mir sehr verd√§chtig sind. </font><font style="vertical-align: inherit;">Ich gehe jedoch nicht davon aus, dass dieser Code definitiv fehlerhaft ist, da es dort eine komplexe Logik gibt. </font><font style="vertical-align: inherit;">In jedem Fall muss ich auf diesen Code achten, damit der Autor ihn √ºberpr√ºft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Fragment:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ce_t3t_handle_check_cmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; p_cb-&gt;cur_cmd.num_blocks; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; T3T_MSG_NDEF_ATTR_INFO_SIZE; i++) { checksum += p_temp[i]; } .... } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V535 CWE-691 Die Variable 'i' wird f√ºr diese Schleife und f√ºr die √§u√üere Schleife verwendet. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 398, 452. ce_t3t.cc 452 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowohl f√ºr den externen als auch f√ºr den internen Zyklus verwendet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei weitere √§hnliche Analysator-Trigger:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V535 CWE-691 Die Variable 'xx' wird f√ºr diese Schleife und f√ºr die √§u√üere Schleife verwendet. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 801, 807. sdp_db.cc 807</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V535 CWE-691 Die Variable 'xx' wird f√ºr diese Schleife und f√ºr die √§u√üere Schleife verwendet. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 424, 438. nfa_hci_act.cc 438</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bist du noch nicht m√ºde? </font><font style="vertical-align: inherit;">Ich empfehle, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anzuhalten und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">herunterzuladen</font></a><font style="vertical-align: inherit;"> , um zu versuchen, Ihr Projekt zu √ºberpr√ºfen.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/8e3/d36/30b8e3d36a2b05111cee2b76d981d89f.png" alt="Probieren Sie PVS-Studio aus"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt machen wir weiter. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NFA_HCI_LAST_PROP_GATE 0xFF tNFA_HCI_DYN_GATE* nfa_hciu_alloc_gate(uint8_t gate_id, tNFA_HANDLE app_handle) { .... for (gate_id = NFA_HCI_FIRST_HOST_SPECIFIC_GENERIC_GATE; gate_id </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= NFA_HCI_LAST_PROP_GATE; gate_id++) { if (gate_id == NFA_HCI_CONNECTIVITY_GATE) gate_id++; if (nfa_hciu_find_gate_by_gid(gate_id) == NULL) break; } if (gate_id &gt; NFA_HCI_LAST_PROP_GATE) { LOG(ERROR) &lt;&lt; StringPrintf( "nfa_hci_alloc_gate - no free Gate ID: %u " "App Handle: 0x%04x", gate_id, app_handle); return (NULL); } .... }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-Warnung: V654 CWE-834 Die Bedingung 'gate_id &lt;= 0xFF' der Schleife ist immer wahr. </font><font style="vertical-align: inherit;">nfa_hci_utils.cc 248 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie Folgendes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Konstante </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NFA_HCI_LAST_PROP_GATE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist gleich 0xFF.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Variable vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als </font><i><font style="vertical-align: inherit;">Schleifenz√§hler verwendet</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Daher ist der Wertebereich dieser Variablen [0..0xFF].</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass die Bedingung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gate_id &lt;= NFA_HCI_LAST_PROP_GATE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immer wahr ist und die Ausf√ºhrung der Schleife nicht stoppen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Analysator hat diesen Fehler als CWE-834 klassifiziert, kann aber auch als CWE-571 interpretiert werden: Ausdruck ist immer wahr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Fehler in der Schleife h√§ngt mit undefiniertem Verhalten zusammen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> SimpleDecodingSource::doRead(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retries = <span class="hljs-number"><span class="hljs-number">0</span></span>; ++retries; ) { .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V654 CWE-834 Die Bedingung '++ Wiederholungen' der Schleife ist immer wahr. </font><font style="vertical-align: inherit;">SimpleDecodingSource.cpp 226 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offenbar wollte der Entwickler auf variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholungen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat alle m√∂glichen Werte f√ºr die Variable genommen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und erst dann hat der Zyklus beendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schleife sollte anhalten, wenn der Ausdruck </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">++ erneut versucht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird 0. Dies ist nur m√∂glich, wenn die Variable √ºberl√§uft. </font><font style="vertical-align: inherit;">Da die Variable vom Typ mit Vorzeichen ist, f√ºhrt ihr √úberlauf zu undefiniertem Verhalten. </font><font style="vertical-align: inherit;">Daher ist dieser Code falsch und kann zu unvorhersehbaren Konsequenzen f√ºhren. </font><font style="vertical-align: inherit;">Zum Beispiel hat der Compiler das volle Recht, die Pr√ºfung zu entfernen und nur Anweisungen zum Inkrementieren des Z√§hlers zu hinterlassen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und der letzte Fehler in diesem Abschnitt. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> Check(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; source) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pass = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(rc) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: SLOGI(<span class="hljs-string"><span class="hljs-string">"Filesystem check completed OK"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: SLOGE(<span class="hljs-string"><span class="hljs-string">"Filesystem check failed (not a FAT filesystem)"</span></span>); errno = ENODATA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pass++ &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { SLOGW(<span class="hljs-string"><span class="hljs-string">"Filesystem modified - rechecking (pass %d)"</span></span>, pass); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } SLOGE("Failing check after too many rechecks"); errno = EIO; return -1; case 8: SLOGE("Filesystem check failed (no filesystem)"); errno = ENODATA; return -1; default: SLOGE("Filesystem check failed (unknown exit code %d)", rc); errno = EIO; return -1; } } while (0); // &lt;= return 0; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-Warnung: V696 CWE-670 Der Operator 'continue' beendet die Schleife 'do {...} while (FALSE)', da die Bedingung immer falsch ist. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 105, 121. Vfat.cpp 105 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor uns befindet sich eine Schleife der Form:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um wiederholte Iterationen durchzuf√ºhren, verwendet der Programmierer die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continue-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisung </font><font style="vertical-align: inherit;">.</font></font> Das ist nicht richtig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continue-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anweisung </font><font style="vertical-align: inherit;">setzt die Schleife nicht sofort fort, sondern √ºberpr√ºft die Bedingung. </font><font style="vertical-align: inherit;">Da die Bedingung immer falsch ist, wird der Zyklus in jedem Fall nur einmal ausgef√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Fehler zu beheben, kann der Code beispielsweise wie folgt umgeschrieben werden:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable Neuzuweisung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein sehr </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√§ufiger Fehler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das erneute Schreiben in eine Variable, bevor der vorherige Wert verwendet wurde. </font><font style="vertical-align: inherit;">Meistens treten solche Fehler aufgrund eines Tippfehlers oder eines erfolglosen Kopierens und Einf√ºgens auf. </font><font style="vertical-align: inherit;">Gem√§√ü der Common Weakness Enumeration werden solche Fehler als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-563</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> klassifiziert </font><font style="vertical-align: inherit;">: Zuordnung zu Variablen ohne Verwendung. </font><font style="vertical-align: inherit;">Nicht ohne solche Fehler in Android.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> XMLNode::flatten_node(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;namespaceExt, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(namespaceExt)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mNamespacePrefix.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { namespaceExt.prefix.index = htodl(strings.offsetForString(mNamespacePrefix)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { namespaceExt.prefix.index = htodl((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>); } namespaceExt.prefix.index = htodl(strings.offsetForString(mNamespacePrefix)); namespaceExt.uri.index = htodl(strings.offsetForString(mNamespaceUri)); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V519 CWE-563 Der Variablen 'namespaceExt.prefix.index' werden zweimal nacheinander Werte zugewiesen. </font><font style="vertical-align: inherit;">Vielleicht ist das ein Fehler. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 1535, 1539. XMLNode.cpp 1539 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Wesentliche des Fehlers hervorzuheben, schreibe ich einen Pseudocode:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) X = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> X = <span class="hljs-number"><span class="hljs-number">2</span></span>; X = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unabh√§ngig von der Bedingung wird der Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (im vorliegenden Code </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NamespaceExt.prefix.index</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) immer ein Wert zugewiesen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AudioFlinger::RecordThread::threadLoop() { .... <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> framesToRead = mBufferSize / mFrameSize; framesToRead = min(mRsmpInFramesOA - rear, mRsmpInFramesP2 / <span class="hljs-number"><span class="hljs-number">2</span></span>); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V519 CWE-563 Der Variablen 'frameToRead' werden zweimal nacheinander Werte zugewiesen. </font><font style="vertical-align: inherit;">Vielleicht ist das ein Fehler. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 6341, 6342. Threads.cpp 6342 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist nicht klar, warum die Variable w√§hrend der Deklaration initialisiert werden musste, wenn dann sofort ein anderer Wert in sie geschrieben wird. </font><font style="vertical-align: inherit;">Hier stimmt etwas nicht.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SchedulingLatencyVisitorARM::VisitArrayGet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index-&gt;IsConstant()) { last_visited_latency_ = kArmMemoryLoadLatency; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (has_intermediate_address) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { last_visited_internal_latency_ += kArmIntegerOpLatency; } last_visited_internal_latency_ = kArmMemoryLoadLatency; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V519 CWE-563 Der Variablen 'last_visited_internal_latency_' werden zweimal nacheinander Werte zugewiesen. </font><font style="vertical-align: inherit;">Vielleicht ist das ein Fehler. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 680, 682. scheduler_arm.cc 682 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sehr seltsamer, bedeutungsloser Code. </font><font style="vertical-align: inherit;">Ich wage vorzuschlagen, dass es h√§tte geschrieben werden sollen:</font></font><br><br><pre> <code class="cpp hljs">last_visited_internal_latency_ += kArmMemoryLoadLatency;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und der letzte Fehler zeigt, wie der Analysator unerm√ºdlich Fehler findet, die selbst bei sorgf√§ltiger Code√ºberpr√ºfung am wahrscheinlichsten √ºbersprungen werden. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiprecision_fast_mod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> U; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> V; .... c[<span class="hljs-number"><span class="hljs-number">0</span></span>] += U; V = c[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; U; c[<span class="hljs-number"><span class="hljs-number">1</span></span>] += V; V = c[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; V; c[<span class="hljs-number"><span class="hljs-number">2</span></span>] += V; <span class="hljs-comment"><span class="hljs-comment">// V = c[2] &lt; V; // &lt;= c[2] += U; // V = c[2] &lt; U; // &lt;= c[3] += V; V = c[3] &lt; V; c[4] += V; V = c[4] &lt; V; c[5] += V; V = c[5] &lt; V; .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V519 CWE-563 Der Variablen 'V' werden zweimal hintereinander Werte zugewiesen. </font><font style="vertical-align: inherit;">Vielleicht ist das ein Fehler. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 307, 309. p_256_multprecision.cc 309 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code lautet so "Tr√§nen Sie die Augen aus", dass ich ihn nicht verstehen m√∂chte. </font><font style="vertical-align: inherit;">Dies ist deutlich sichtbar: Der Code enth√§lt einen Tippfehler, den ich mit Kommentaren hervorgehoben habe.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andere Fehler </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt vereinzelte Fehler, f√ºr die es keinen Sinn macht, separate Kapitel zu erstellen. </font><font style="vertical-align: inherit;">Sie sind jedoch genauso interessant und heimt√ºckisch wie die zuvor betrachteten. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorrangige Operationen</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-comment"><span class="hljs-comment">// Expand shorthands if (ssize_t idx = tagNames.find("3a") != -1) { ssize_t end = tagNames.find(",", idx); char* start = tagNames.lockBuffer(tagNames.size()); start[idx] = '\0'; .... } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V593 CWE-783 √úberpr√ºfen Sie den Ausdruck der Art 'A = B! = C'. Der Ausdruck wird wie folgt berechnet: 'A = (B! = C)'. TagMonitor.cpp 50 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung allgemeiner Schw√§chen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-783</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Fehler der Operatorpr√§zedenzlogik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Programmierer hat Folgendes konzipiert. Die Teilzeichenfolge "3a" wird durchsucht und die </font><font style="vertical-align: inherit;">Position dieser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teilzeichenfolge in die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><i><font style="vertical-align: inherit;">idx geschrieben</font></i><font style="vertical-align: inherit;"> . Wenn der Teilstring gefunden wird (idx! = -1), wird der Code ausgef√ºhrt, der den Wert der Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider ist der Programmierer √ºber die Priorit√§ten der Operationen verwirrt. Tats√§chlich funktioniert die Pr√ºfung folgenderma√üen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = (tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst wird gepr√ºft, ob die Zeichenfolge eine Teilzeichenfolge ‚Äû3a‚Äú enth√§lt, und das Ergebnis false / true wird in die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx eingef√ºgt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Infolgedessen hat die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDX-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">den Wert 0 oder 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Bedingung erf√ºllt ist (die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDX-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">ist 1), beginnt die Ausf√ºhrung der Logik, die die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDX-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable verwendet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eine Variable, die immer gleich 1 ist, f√ºhrt zu einem falschen Programmverhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen den Fehler beheben, wenn Sie die Initialisierung der Variablen anhand der folgenden Bedingung vornehmen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx != <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mit der neuen Version von C ++ 17 k√∂nnen Sie au√üerdem Folgendes schreiben: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>); idx != <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ung√ºltiger Konstruktor</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HearingDevice</span></span></span><span class="hljs-class"> {</span></span> .... HearingDevice() { HearingDevice(RawAddress::kEmpty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } .... };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V603 CWE-665 Das Objekt wurde erstellt, wird jedoch nicht verwendet. Wenn Sie den Konstruktor aufrufen m√∂chten, sollte 'this-&gt; HearingDevice :: HearingDevice (....)' verwendet werden. Hearing_aid.cc 176 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung allgemeiner Schw√§chen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-665</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Unsachgem√§√üe Initialisierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmierer irren sich oft, wenn sie versuchen, einen Konstruktor explizit aufzurufen, um ein Objekt zu initialisieren. Es gibt zwei Konstruktoren in der Klasse. Um die Gr√∂√üe des Quellcodes zu verringern, hat der Programmierer beschlossen, einen Konstruktor von einem anderen aufzurufen. Dieser Code entspricht jedoch keineswegs den Erwartungen des Entwicklers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes passiert. Ein neues unbenanntes Objekt vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HearingDevice wird erstellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und anschlie√üend zerst√∂rt. Infolgedessen bleiben die Klassenfelder nicht initialisiert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Fehler zu beheben, k√∂nnen Sie den delegierenden Konstruktor verwenden (diese Funktion wurde in C ++ 11 angezeigt). </font><font style="vertical-align: inherit;">Der richtige Code lautet:</font></font><br><br><pre> <code class="cpp hljs">HearingDevice() : HearingDevice(RawAddress::kEmpty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion gibt keinen Wert zur√ºck</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NET_RecvFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, struct sockaddr *from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *fromlen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> socklen = *fromlen; BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &amp;socklen) ); *fromlen = socklen; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V591 CWE-393 Die Funktion "Nicht ung√ºltig" sollte einen Wert zur√ºckgeben. </font><font style="vertical-align: inherit;">linux_close.cpp 139 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung allgemeiner Schw√§chen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-393</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : R√ºckgabe des falschen </font><font style="vertical-align: inherit;">Statuscodes </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Funktion gibt einen zuf√§lligen Wert zur√ºck. </font><font style="vertical-align: inherit;">Ein weiterer solcher Fehler: V591 CWE-393 Non-void-Funktion sollte einen Wert zur√ºckgeben. </font><font style="vertical-align: inherit;">linux_close.cpp 158 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsche Berechnung der Strukturgr√∂√üe</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MtpFfsHandle::handleControlRequest(....) { .... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mtp_device_status</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">st</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reinterpret_cast</span></span></span><span class="hljs-class">&lt;struct mtp_device_status*&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">buf</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">());</span></span> st-&gt;wLength = htole16(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(st)); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V568 Es ist seltsam, dass der Operator 'sizeof ()' die Gr√∂√üe eines Zeigers auf eine Klasse auswertet, nicht jedoch die Gr√∂√üe des Klassenobjekts 'st'. </font><font style="vertical-align: inherit;">MtpFfsHandle.cpp 251 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich bin sicher, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Gr√∂√üe der Struktur und nicht die Gr√∂√üe des Zeigers </font><font style="vertical-align: inherit;">in die Mitgliedsvariable </font><i><font style="vertical-align: inherit;">wLength einf√ºgen wollten</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dann sollte der richtige Code folgenderma√üen aussehen:</font></font><br><br><pre> <code class="cpp hljs">st-&gt;wLength = htole16(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*st));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñhnliche Reaktionen des Analysators: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568 Es ist seltsam, dass der Operator 'sizeof ()' die Gr√∂√üe eines Zeigers auf eine Klasse auswertet, nicht jedoch die Gr√∂√üe des Klassenobjekts 'cacheinfo'. </font><font style="vertical-align: inherit;">NetlinkEvent.cpp 220</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568 Es ist seltsam, dass der Operator 'sizeof ()' die Gr√∂√üe eines Zeigers auf eine Klasse auswertet, nicht jedoch die Gr√∂√üe des Klassenobjekts 'page-&gt; next'. </font><font style="vertical-align: inherit;">linker_block_allocator.cpp 146</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568 Es ist seltsam, dass das Argument des Operators sizeof () der Ausdruck '&amp; session_id' ist. </font><font style="vertical-align: inherit;">Referenz-ril.c 1775</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bedeutungslose Bitoperationen</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR 0x00000004 EGLContext eglCreateContext(....) { .... case EGL_CONTEXT_FLAGS_KHR: </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((attrib_val | EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR) || (attrib_val | EGL_CONTEXT_OPENGL_FORWARD_C....) || (attrib_val | EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR)) { context_flags = attrib_val; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { RETURN_ERROR(EGL_NO_CONTEXT,EGL_BAD_ATTRIBUTE); } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V617 CWE-480 √úberpr√ºfen Sie den Zustand. </font><font style="vertical-align: inherit;">Das Argument '0x00000001' des '|' </font><font style="vertical-align: inherit;">Die bitweise Operation enth√§lt einen Wert ungleich Null. </font><font style="vertical-align: inherit;">egl.cpp 1329 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung der allgemeinen Schw√§chen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-480</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Verwendung eines falschen Operators. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Ausdruck der Form (A | 1) || </font><font style="vertical-align: inherit;">(A | 2) || </font><font style="vertical-align: inherit;">(A | 4) macht keinen Sinn, da das Ergebnis immer wahr sein wird. </font><font style="vertical-align: inherit;">In der Tat m√ºssen Sie den Operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp; verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und dann macht der Code Sinn:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((attrib_val &amp; EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR) || (attrib_val &amp; EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR) || (attrib_val &amp; EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñhnlicher Fehler: V617 CWE-480 √úberpr√ºfen Sie den Zustand. Das Argument '0x00000001' des '|' Die bitweise Operation enth√§lt einen Wert ungleich Null. egl.cpp 1338 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falsche Bitverschiebung</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddressType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegsInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> saved_reg_map = <span class="hljs-number"><span class="hljs-number">0</span></span>; AddressType saved_regs[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> AddressType* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg &gt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(saved_regs) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(AddressType)) { <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); } saved_reg_map |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; reg; saved_regs[reg] = (*regs)[reg]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;(*regs)[reg]; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V629 CWE-190 √úberpr√ºfen Sie den Ausdruck '1 &lt;&lt; reg'. </font><font style="vertical-align: inherit;">Bitverschiebung des 32-Bit-Werts mit anschlie√üender Erweiterung auf den 64-Bit-Typ. </font><font style="vertical-align: inherit;">RegsInfo.h 47 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung allgemeiner Schw√§chen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-190</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Integer Overflow oder Wraparound. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei einer Verschiebung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 &lt;&lt; reg liegt der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wert der Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Bereich [0..63]. </font><font style="vertical-align: inherit;">Der Ausdruck dient dazu, verschiedene Zweiergrade zu erhalten, beginnend mit 2 ^ 0 und endend mit 2 ^ 63. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code funktioniert nicht. </font><font style="vertical-align: inherit;">Tatsache ist, dass das numerische Literal 1 einen 32-Bit- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Int-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typ hat </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher funktioniert es nicht, einen Wert gr√∂√üer als 1 ^ 31 zu erhalten. </font><font style="vertical-align: inherit;">Eine Verschiebung zu einem gr√∂√üeren Wert f√ºhrt zum √úberlaufen der Variablen und zum Auftreten eines undefinierten Verhaltens.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der richtige Code lautet: </font></font><br><br><pre> <code class="cpp hljs">saved_reg_map |= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; reg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder: </font></font><br><br><pre> <code class="cpp hljs">saved_reg_map |= <span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; reg;</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichenfolgen werden in sich selbst kopiert.</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PCLmGenerator::writeJobTicket() { <span class="hljs-comment"><span class="hljs-comment">// Write JobTicket char inputBin[256]; char outputBin[256]; if (!m_pPCLmSSettings) { return; } getInputBinString(m_pPCLmSSettings-&gt;userInputBin, &amp;inputBin[0]); getOutputBin(m_pPCLmSSettings-&gt;userOutputBin, &amp;outputBin[0]); strcpy(inputBin, inputBin); strcpy(outputBin, outputBin); .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio-Warnungen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V549 CWE-688 Das erste Argument der Funktion 'strcpy' entspricht dem zweiten Argument. </font><font style="vertical-align: inherit;">genPCLm.cpp 1181</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V549 CWE-688 Das erste Argument der Funktion 'strcpy' entspricht dem zweiten Argument. </font><font style="vertical-align: inherit;">genPCLm.cpp 1182</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gem√§√ü der Klassifizierung der Common Weakness Enumeration: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-688</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Funktionsaufruf mit falscher Variable oder Referenz als Argument. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strings werden aus irgendeinem Grund in sich selbst kopiert. </font><font style="vertical-align: inherit;">H√∂chstwahrscheinlich gibt es hier einige Tippfehler. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden einer nicht initialisierten Variablen</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mca_set_cfg_by_tbl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ tMCA_DCB* p_dcb; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tL2CAP_FCR_OPTS* p_opt; tMCA_FCS_OPT fcs = MCA_FCS_NONE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_tbl-&gt;tcid == MCA_CTRL_TCID) { p_opt = &amp;mca_l2c_fcr_opts_def; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { p_dcb = mca_dcb_by_hdl(p_tbl-&gt;cb_idx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dcb) { p_opt = &amp;p_dcb-&gt;p_chnl_cfg-&gt;fcr_opt; fcs = p_dcb-&gt;p_chnl_cfg-&gt;fcs; } } <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(p_cfg, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tL2CAP_CFG_INFO)); p_cfg-&gt;mtu_present = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; p_cfg-&gt;mtu = p_tbl-&gt;my_mtu; p_cfg-&gt;fcr_present = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;p_cfg-&gt;fcr, p_opt, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tL2CAP_FCR_OPTS)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V614 CWE-824 M√∂glicherweise nicht initialisierter Zeiger 'p_opt' verwendet. √úberpr√ºfen Sie das zweite tats√§chliche Argument der Funktion 'memcpy'. mca_main.cc 252 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung der allgemeinen Schw√§chen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-824</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Zugriff auf nicht initialisierten Zeiger. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_tbl-&gt; tcid! = MCA_CTRL_TCID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_dcb == nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">bleibt </font><font style="vertical-align: inherit;">der Zeiger </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_opt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht initialisiert. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fremde Verwendung von nicht initialisierten Variablen</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__time_t</span></span> tv_sec; <span class="hljs-comment"><span class="hljs-comment">/* Seconds. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tv_nsec; <span class="hljs-comment"><span class="hljs-comment">/* Nanoseconds. */</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> timespec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NsToTimespec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ns)</span></span></span><span class="hljs-function"> </span></span>{ timespec t; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> remainder; t.tv_sec = ns / kNanosPerSecond; remainder = ns % kNanosPerSecond; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remainder &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { t.tv_nsec--; remainder += kNanosPerSecond; } t.tv_nsec = remainder; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V614 CWE-457 Nicht initialisierte Variable 't.tv_nsec' verwendet. </font><font style="vertical-align: inherit;">clock_ns.h 55 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung der allgemeinen Schw√§chen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-457</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Verwendung einer nicht initialisierten Variablen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Zeitpunkt des Dekrementierens der Variablen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t.tv_nsec ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sie nicht initialisiert. </font><font style="vertical-align: inherit;">Die Variable wird sp√§ter initialisiert: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t.tv_nsec = Rest;</font></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etwas hier ist eindeutig verwirrt. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber Ausdruck</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bta_dm_co_ble_io_req</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... *p_auth_req = bte_appl_cfg.ble_auth_req | (bte_appl_cfg.ble_auth_req &amp; <span class="hljs-number"><span class="hljs-number">0x04</span></span>) | ((*p_auth_req) &amp; <span class="hljs-number"><span class="hljs-number">0x04</span></span>); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung: V578 Eine ungerade bitweise Operation wurde erkannt. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie es. </font><font style="vertical-align: inherit;">bta_dm_co.cc 259 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Ausdruck ist redundant. </font><font style="vertical-align: inherit;">Wenn Sie den Unterausdruck </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(bte_appl_cfg.ble_auth_req &amp; 0x04)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entfernen, </font><i><font style="vertical-align: inherit;">√§ndert sich</font></i><font style="vertical-align: inherit;"> das Ergebnis des Ausdrucks nicht. </font><font style="vertical-align: inherit;">Vielleicht gibt es hier einen Tippfehler. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leck behandeln</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RSReflectionCpp::genEncodedBitCode() { FILE *pfin = fopen(mBitCodeFilePath.c_str(), <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pfin == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: could not read file %s\n"</span></span>, mBitCodeFilePath.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> read_length; mOut.indent() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"static const unsigned char __txt[] ="</span></span>; mOut.startBlock(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((read_length = fread(buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), pfin)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mOut.indent(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; read_length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(buf2, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf2), <span class="hljs-string"><span class="hljs-string">"0x%02x,"</span></span>, buf[i]); mOut &lt;&lt; buf2; } mOut &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } mOut.endBlock(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); mOut &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio Warnung: V773 CWE-401 Die Funktion wurde beendet, ohne das Handle 'pfin' loszulassen. </font></font> Ein Ressourcenleck ist m√∂glich.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slang_rs_reflection_cpp.cpp 448 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Analysator klassifizierte diesen Fehler gem√§√ü der Common Weakness Enumeration als: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-401</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Unsachgem√§√üe Freigabe des Speichers vor dem Entfernen der letzten Referenz ('Memory Leak'). </font><font style="vertical-align: inherit;">Hier w√§re es jedoch korrekter, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-775 auszugeben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Fehlende Ver√∂ffentlichung des Dateideskriptors oder des Handles nach der effektiven Lebensdauer. </font><font style="vertical-align: inherit;">Ich werde meine Kollegen anweisen, diesen Fehler in PVS-Studio zu beheben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pfin-Griff wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nirgendwo freigegeben. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur vergessen, die </font><i><font style="vertical-align: inherit;">fclose-</font></i><font style="vertical-align: inherit;"> Funktion am Ende </font><i><font style="vertical-align: inherit;">aufzurufen</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ein unangenehmer Fehler, der schnell das gesamte Angebot an verf√ºgbaren Deskriptoren ersch√∂pfen kann. Danach ist es unm√∂glich, neue Dateien zu √∂ffnen.</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, findet der PVS-Studio-Analysator selbst in einem so bekannten und getesteten Projekt wie Android leicht viele Fehler und potenzielle Schwachstellen. </font><font style="vertical-align: inherit;">Um zusammenzufassen, welche Schwachstellen (potenzielle Schwachstellen) gefunden wurden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-14: Compiler-Entfernung von Code zum L√∂schen von Puffern </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-20: Unsachgem√§√üe Eingabevalidierung </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-119: Unsachgem√§√üe Einschr√§nkung von Operationen innerhalb der Grenzen eines Speicherpuffers </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-190: Integer Overflow oder Wraparound </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-198: Verwendung einer falschen Bytereihenfolge </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-393: R√ºckgabe des falschen Statuscodes </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-401: Unsachgem√§√üe Freigabe des Speichers vor dem Entfernen der letzten Referenz ('Speicherleck') </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-457: Verwendung einer nicht initialisierten Variablen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-462: Doppelter Schl√ºssel in assoziativer Liste </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-480: Verwendung eines falschen Operators </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-484: Unterbrechungsanweisung in Switch weggelassen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-561: Toter Code </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-562: R√ºckgabe der Stapelvariablenadresse </font></font></li><li> CWE-563: Assignment to Variable without Use </li><li> CWE-570: Expression is Always False </li><li> CWE-571: Expression is Always True </li><li> CWE-476: NULL Pointer Dereference </li><li> CWE-628: Function Call with Incorrectly Specified Arguments </li><li> CWE-665: Improper Initialization </li><li> CWE-670: Always-Incorrect Control Flow Implementation </li><li> CWE-682: Incorrect Calculation </li><li> CWE-688: Function Call With Incorrect Variable or Reference as Argument </li><li> CWE-690: Unchecked Return Value to NULL Pointer Dereference </li><li> CWE-691: Insufficient Control Flow Management </li><li> CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior </li><li> CWE-762: Mismatched Memory Management Routines </li><li> CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime </li><li> CWE-783: Operator Precedence Logic Error </li><li> CWE-824: Access of Uninitialized Pointer </li><li> CWE-834: Excessive Iteration </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt habe ich in dem Artikel 490 potenzielle Schwachstellen beschrieben. </font><font style="vertical-align: inherit;">Tats√§chlich kann der Analysator mehr von ihnen identifizieren, aber wie ich bereits schrieb, fand ich nicht die Kraft, den Bericht genauer zu studieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gr√∂√üe der getesteten Codebasis betr√§gt ungef√§hr 2.168.000 Codezeilen in C und C ++. </font><font style="vertical-align: inherit;">Davon sind 14,4% Kommentare. </font><font style="vertical-align: inherit;">Insgesamt erhalten wir ungef√§hr 1.855.000 Zeilen sauberen Codes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somit haben wir 490 CWEs f√ºr 1.855.000 Codezeilen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass der PVS-Studio-Analysator mehr als eine Schwachstelle (potenzielle Schwachstelle) pro 4000 Codezeilen in einem Android-Projekt erkennen kann. </font><font style="vertical-align: inherit;">Gutes Ergebnis f√ºr einen Code-Analysator, ich bin froh.</font></font><br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich w√ºnsche allen einen codelosen Code und schlage Folgendes vor: </font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">herunter</font></a><font style="vertical-align: inherit;"> und √ºberpr√ºfen Sie den Arbeitsentwurf.</font></font></li><li>  :      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     </a> . </li><li> ,        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RSS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vk.com</a> . </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Andrey Karpov. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">We Checked the Android Source Codes by PVS-Studio or Nothing is Perfect</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418891/">https://habr.com/ru/post/de418891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418879/index.html">Testmethode f√ºr Krypto-Austausch und Crypto-Wallets</a></li>
<li><a href="../de418883/index.html">GitLab auf NAS</a></li>
<li><a href="../de418885/index.html">Crispr kann nat√ºrliche Prozesse beschleunigen und den Anbau von Lebensmitteln ver√§ndern</a></li>
<li><a href="../de418887/index.html">Wie schnell expandiert das Universum?</a></li>
<li><a href="../de418889/index.html">Handbuch f√ºr manuelle Anwendungstests: Vorteile, Schritte und Methoden</a></li>
<li><a href="../de418895/index.html">Lerne k√ºnstliche Intelligenz, um ein Spiel zu spielen</a></li>
<li><a href="../de418897/index.html">CRDT: Konfliktfreie replizierte Datentypen</a></li>
<li><a href="../de418899/index.html">Erste Eindr√ºcke und Aktionen nach dem Upgrade von MySQL von Version 5.7 auf 8.0.11</a></li>
<li><a href="../de418901/index.html">Die Russen gewannen die Mehrheit der Goldmedaillen bei der Europ√§ischen Informatikolympiade eJOI 2018</a></li>
<li><a href="../de418903/index.html">Wissenschaftler: Es gibt nicht genug CO‚ÇÇ auf dem Mars, um die Atmosph√§re zu erw√§rmen. Polexplosion wird nicht helfen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>