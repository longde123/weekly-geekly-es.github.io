<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíª ‚òπÔ∏è üßñüèø Um zu argumentieren: Wenn Sie bis zum Ende gelesen haben, werden Sie verstehen, wie und warum genau GC funktioniert üë©üèΩ‚Äçüíª üë®‚ÄçüöÄ üßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich werde gleich sagen: Ich warte nie auf eine ausf√ºhrliche Antwort auf diese Frage zur sozialen Sicherheit. Das ist dumm und in meinem Fall egoistisc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um zu argumentieren: Wenn Sie bis zum Ende gelesen haben, werden Sie verstehen, wie und warum genau GC funktioniert</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/464169/"><p> Ich werde gleich sagen: Ich warte nie auf eine ausf√ºhrliche Antwort auf diese Frage zur sozialen Sicherheit.  Das ist dumm und in meinem Fall egoistisch.  Meiner Meinung nach ist es jedoch neben dem allgemeinen Interesse an der Plattform sehr n√ºtzlich zu wissen, wie es funktioniert, weil  Dies beseitigt eine Reihe von Problemen.  Beispielsweise wird die Option ausgeschlossen, wenn der Entwickler der Ansicht ist, dass <code>Dispose</code> automatisch aufgerufen wird und Sie sie nicht selbst aufrufen m√ºssen.  Oder wenn der Entwickler erfahrener ist, hilft er ihm automatisch, auf der Ebene des Muskelged√§chtnisses Code zu schreiben, der zu der geringsten Anzahl von Problemen f√ºhrt. </p><br><p>  Eine andere Frage, die ich subjektiv nicht wirklich mag, ist, wie seine Arbeit erkl√§rt wird.  Daher schlage ich einen alternativen Ansatz vor, der in meinem Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Platform Architecture beschrieben ist</a> . </p><br><p>  Wenn wir genau verstehen wollen, warum diese beiden Speicherverwaltungsalgorithmen ausgew√§hlt wurden: Sweep und Compact, m√ºssen wir Dutzende von Speicherverwaltungsalgorithmen ber√ºcksichtigen, die es auf der Welt gibt: beginnend mit gew√∂hnlichen W√∂rterb√ºchern und endend mit sehr komplexen sperrenfreien Strukturen.  Stattdessen <em>begr√ºnden</em> wir einfach <em>die</em> Wahl und <em>verstehen</em> dadurch <em>,</em> warum die Wahl so getroffen wurde.  Wir sehen uns das Booster-Startheft nicht mehr an: Wir haben eine vollst√§ndige Dokumentation in der Hand. </p><br><p>  Der Streit ist f√ºr beide Seiten von Vorteil: Wenn er nicht klar ist, werde ich die unklaren Punkte im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch</a> korrigieren, von denen ein kleiner Teil der gegebene Text ist. </p><br><p><img src="https://habrastorage.org/webt/sv/sw/_g/svsw_gfzggr2i1wk94ah_itbmqi.jpeg"></p><a name="habracut"></a><br><blockquote>  Ich habe das Format der Argumentation so gew√§hlt, dass Sie das Gef√ºhl haben, dass die Architekten der Plattform und ich zu den gleichen Ergebnissen gekommen sind, zu denen die echten Architekten in der Microsoft-Zentrale in Redmond gekommen sind. </blockquote><p>  Basierend auf der Klassifizierung der zugewiesenen Objekte anhand ihrer Gr√∂√üe k√∂nnen Sie den Speicherplatz f√ºr die Speicherzuweisung in zwei gro√üe Abschnitte unterteilen: einen Ort mit Objekten, deren Gr√∂√üe unter einem bestimmten Schwellenwert liegt, und einen Ort mit einer Gr√∂√üe √ºber diesem Schwellenwert, um festzustellen, welche Unterschiede bei der Verwaltung dieser Gruppen (basierend auf) auftreten k√∂nnen ihre Gr√∂√üe) und was daraus wird. </p><br><p>  Wenn wir die Verwaltung herk√∂mmlicher " <em>kleiner</em> " Objekte in Betracht ziehen, k√∂nnen wir feststellen, dass es f√ºr uns sehr teuer ist, Speicherverwaltungsdatenstrukturen zu verwalten, in denen Links zu jedem dieser Objekte gespeichert werden, wenn wir uns an die Idee halten, Informationen zu jedem Objekt zu speichern.  Am Ende kann sich herausstellen, dass Sie zum Speichern von Informationen zu einem Objekt so viel Speicher ben√∂tigen, wie das Objekt selbst ben√∂tigt.  Stattdessen sollten Sie ber√ºcksichtigen: Wenn wir w√§hrend der Speicherbereinigung von den Wurzeln aus tanzen und tief in den Graphen durch die ausgehenden Felder des Objekts gehen und nur eine lineare Passage entlang des Heaps ben√∂tigen, um M√ºllobjekte zu identifizieren, m√ºssen wir dann Informationen zu jedem Objekt in den Speicherverwaltungsalgorithmen speichern?  Die Antwort liegt auf der Hand: Es besteht keine Notwendigkeit daf√ºr.  Wir k√∂nnen also versuchen, von der Tatsache auszugehen, dass wir solche Informationen nicht speichern sollten: Wir k√∂nnen eine Reihe linear durchlaufen, die Gr√∂√üe jedes Objekts kennen und den Zeiger jedes Mal um die Gr√∂√üe des n√§chsten Objekts bewegen. </p><br><blockquote>  Es gibt keine zus√§tzlichen Datenstrukturen auf dem Heap, die Zeiger auf jedes Objekt enthalten, das der Heap steuert. </blockquote><p>  Wenn wir jedoch keinen Speicher mehr ben√∂tigen, m√ºssen wir ihn freigeben.  Und wenn wir Speicher freigeben, f√§llt es uns schwer, uns auf den linearen Durchgang des Haufens zu verlassen: Er ist lang und nicht effektiv.  Infolgedessen kommen wir zu dem Schluss, dass wir Informationen √ºber freie Speicherbereiche irgendwie speichern m√ºssen. </p><br><blockquote>  Der Heap enth√§lt Listen mit freiem Speicher. </blockquote><p>  Wenn, wie wir beschlossen haben, Informationen √ºber freie Bereiche gespeichert werden sollen und w√§hrend Speicherplatz freigegeben wurde, diese Bereiche zu klein waren, sto√üen wir zun√§chst auf das gleiche Problem beim Speichern von Informationen √ºber freie Bereiche, auf das wir bei der Betrachtung besetzter Bereiche gesto√üen sind (wenn Auf den Seiten des belegten Objekts wurde ein Objekt freigegeben, um Informationen dar√ºber zu speichern, ist es im schlimmsten Fall 2/3 seiner Gr√∂√üe erforderlich. Zeiger + Gr√∂√üe versus SyncBlockIndex + VMT + ein Feld - im Fall des Objekts).  Das klingt wieder verschwenderisch, m√ºssen Sie zugeben: Es ist nicht immer ein Gl√ºck, eine Gruppe von Objekten zu befreien, die aufeinander folgen.  Normalerweise werden sie auf chaotische Weise freigesetzt.  Im Gegensatz zu ausgelasteten Sites, die wir nicht linear durchsuchen m√ºssen, m√ºssen wir nach freien Sites suchen, da wir diese m√∂glicherweise erneut ben√∂tigen, wenn wir Speicher zuweisen.  Daher entsteht ein v√∂llig nat√ºrlicher Wunsch, die Fragmentierung zu verringern und den Haufen zusammenzudr√ºcken, indem alle besetzten Bereiche an freie Orte verschoben werden, wodurch ein gro√üer Bereich des freien Bereichs gebildet wird, in dem Speicher zugewiesen werden kann. </p><br><blockquote>  Hier kommt die Idee des Verdichtungsalgorithmus her. </blockquote><p>  Aber warte, sagst du?  Immerhin kann dieser Vorgang sehr schwierig sein.  Stellen Sie sich vor, Sie haben ein Objekt ganz am Anfang des Heaps freigegeben.  Und was, sagst du, brauchst du, um alles zu bewegen?  Nat√ºrlich k√∂nnen Sie sich das Thema Vektoranweisungen der CPU ausdenken, mit denen Sie einen riesigen belegten Speicherbereich kopieren k√∂nnen.  Dies ist jedoch nur der Beginn der Arbeit.  Wir m√ºssen auch alle Zeiger aus den Feldern von Objekten auf Objekte fixieren, die Bewegungen erfahren haben.  Dieser Vorgang kann sehr lange dauern.  Nein, wir m√ºssen von etwas anderem ausgehen.  Zum Beispiel, indem Sie das gesamte Segment des Heapspeichers in Sektoren aufteilen und separat damit arbeiten.  Wenn wir in jedem Sektor separat arbeiten (f√ºr die Vorhersagbarkeit und Skalierung dieser Vorhersagbarkeit - vorzugsweise f√ºr feste Gr√∂√üen), scheint die Idee der Komprimierung nicht so schwer zu sein: Es reicht aus, einen einzelnen Sektor zu komprimieren, und dann k√∂nnen Sie sogar anfangen, √ºber die Zeit zu sprechen, die zum Komprimieren eines solchen Sektors erforderlich ist . </p><br><p>  Nun bleibt zu verstehen, auf welcher Grundlage in Sektoren unterteilt werden soll.  Hier m√ºssen wir uns der zweiten Klassifizierung zuwenden, die auf der Plattform eingef√ºhrt wird: Speicherfreigabe, basierend auf der Lebensdauer der einzelnen Elemente. </p><br><p>  Die Unterteilung ist einfach: Wenn wir ber√ºcksichtigen, dass wir mit zunehmenden Adressen Speicher zuweisen, werden die ersten ausgew√§hlten Objekte zu den √§ltesten und die Objekte in den √§lteren Adressen zu den j√ºngsten.  Wenn Sie klug sind, k√∂nnen Sie au√üerdem zu dem Schluss kommen, dass Objekte in Anwendungen in zwei Gruppen unterteilt sind: diejenigen, die f√ºr ein langes Leben erstellt wurden, und diejenigen, die f√ºr ein sehr geringes Leben erstellt wurden.  Zum Beispiel, um Zeiger auf andere Objekte in Form einer Sammlung vor√ºbergehend zu speichern.  Oder die gleichen DTO-Objekte.  Dementsprechend erhalten wir von Zeit zu Zeit, wenn wir einen Haufen zusammendr√ºcken, eine Reihe von langlebigen Objekten - in den unteren Adressen und eine Reihe von kurzlebigen - im Senior. </p><br><blockquote>  So haben wir <em>Generationen erhalten</em> . </blockquote><p>  Wenn wir die Erinnerung in Generationen aufteilen, haben wir die M√∂glichkeit, seltener auf die Objekte der √§lteren Generation zu schauen, die immer mehr werden. </p><br><p>  Aber es stellt sich eine andere Frage: Wenn wir nur zwei Generationen haben, werden wir Probleme bekommen.  Oder wir werden versuchen, GC maskenlos schnell zum Laufen zu bringen: Dann werden wir bei der Gr√∂√üe der j√ºngeren Generation versuchen, die Mindestgr√∂√üe zu erreichen.  Infolgedessen versagen Objekte in der √§lteren Generation versehentlich (wenn der GC "gerade jetzt, w√§hrend einer w√ºtenden Speicherzuweisung f√ºr viele Objekte" funktioniert hat).  Um ein versehentliches Versagen zu minimieren, werden wir die Gr√∂√üe der j√ºngeren Generation erh√∂hen.  Dann arbeitet der GC der j√ºngeren Generation lange genug, verlangsamt und verlangsamt die Anwendung. </p><br><p>  Der Ausweg ist die Einf√ºhrung der "mittleren" Generation.  Teenager.  Mit anderen Worten, wenn Sie bis zur Pubert√§t leben, ist es wahrscheinlicher, dass Sie bis ins hohe Alter leben.  Die Essenz seiner Einf√ºhrung besteht darin, ein Gleichgewicht zwischen <em>der kleinsten j√ºngeren Generation</em> und der <em>stabilsten √§lteren Generation zu erreichen</em> , bei der es besser ist, nichts zu ber√ºhren.  Dies ist eine Zone, in der das Schicksal der Objekte noch nicht entschieden ist.  Die erste Generation (vergessen Sie nicht, was wir von Grund auf neu denken) ist ebenfalls klein und GC sieht dort seltener aus.  GC erm√∂glicht es somit den Objekten, die sich in der tempor√§ren ersten Generation befinden, nicht in die √§ltere Generation zu gelangen, was √§u√üerst schwierig zu sammeln ist. </p><br><blockquote>  So kamen wir auf die Idee von drei Generationen. </blockquote><p>  Die n√§chste Optimierungsebene ist der Versuch, die Komprimierung abzulehnen.  Wenn Sie es nicht tun, werden wir schlie√ülich eine riesige Schicht Arbeit los.  Kommen wir zur√ºck zum Thema kostenlose Websites. </p><br><p>  Wenn wir den gesamten im Heap verf√ºgbaren Speicher aufgebraucht haben und GC aufgerufen wurde, besteht ein nat√ºrlicher Wunsch, die Komprimierung zugunsten einer weiteren Zuweisung von Speicher innerhalb der freigegebenen Abschnitte zu verweigern, wenn ihre Gr√∂√üe ausreicht, um eine bestimmte Anzahl von Objekten aufzunehmen.  Hier kommen wir zu der Idee eines zweiten Algorithmus zum Freigeben von Speicher im GC namens <code>Sweep</code> : Wir komprimieren den Speicher nicht, wir verwenden Hohlr√§ume von freigegebenen Objekten, um neue Objekte zu platzieren </p><br><blockquote>  Deshalb haben wir alle Grundlagen von GC-Algorithmen beschrieben und begr√ºndet. </blockquote><p>  Nach zwei Tagen k√∂nnen wir also einige Schlussfolgerungen ziehen.  So wie ich es verstehe, verstehen die meisten Leute den gr√∂√üten Teil des Textes oder sogar den ganzen.  Einige Leute antworteten, dass sie nicht verstanden, andere teilweise verstanden.  Der Streit wurde von einem Team von Lesern gewonnen, wenn auch mit einem geringen Vorsprung, wie sie sagen.  Aber wie gesagt, jeder wird davon profitieren: Der Text wird ge√§ndert und erg√§nzt.  Au√üerdem an beiden Stellen aktualisiert: sowohl im Buch als auch hier im Artikel. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464169/">https://habr.com/ru/post/de464169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464151/index.html">Victor Vyalichkin: ‚ÄûFreiheit, Gleichheit, Br√ºderlichkeit gibt es nur in OpenStreetMap, wo immer alles in Sicht ist.‚Äú</a></li>
<li><a href="../de464155/index.html">KI hilft bei der Untersuchung von Tieren in Afrika</a></li>
<li><a href="../de464161/index.html">SPAM und GDRP - wie mache ich Mailinglisten "dort"?</a></li>
<li><a href="../de464163/index.html">Dieses Schl√ºsselwort in JavaScript. Komplettes * Handbuch</a></li>
<li><a href="../de464165/index.html">Habr Weekly # 14 / √úber die Kommunikationsregeln in Gruppenchats, Monopole und den Schutz von Kindern vor gef√§hrlichen Informationen</a></li>
<li><a href="../de464171/index.html">Software-Update-Sicherheit</a></li>
<li><a href="../de464173/index.html">"Verdammte Galeere", oder wo die Beine vom jammernden B√ºro wachsen</a></li>
<li><a href="../de464177/index.html">Das Buch "Kotlin. Programmierung f√ºr Profis "</a></li>
<li><a href="../de464179/index.html">Ein Standup in Yandex.Taxi oder Was Sie dem Backend-Entwickler beibringen m√ºssen</a></li>
<li><a href="../de464181/index.html">Poco - Python-basierte UI-Automatisierung f√ºr mobile Spiele als Teil der AirTest-IDE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>