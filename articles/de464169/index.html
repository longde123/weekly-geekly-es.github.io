<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍💻 ☹️ 🧖🏿 Um zu argumentieren: Wenn Sie bis zum Ende gelesen haben, werden Sie verstehen, wie und warum genau GC funktioniert 👩🏽‍💻 👨‍🚀 🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich werde gleich sagen: Ich warte nie auf eine ausführliche Antwort auf diese Frage zur sozialen Sicherheit. Das ist dumm und in meinem Fall egoistisc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um zu argumentieren: Wenn Sie bis zum Ende gelesen haben, werden Sie verstehen, wie und warum genau GC funktioniert</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/464169/"><p> Ich werde gleich sagen: Ich warte nie auf eine ausführliche Antwort auf diese Frage zur sozialen Sicherheit.  Das ist dumm und in meinem Fall egoistisch.  Meiner Meinung nach ist es jedoch neben dem allgemeinen Interesse an der Plattform sehr nützlich zu wissen, wie es funktioniert, weil  Dies beseitigt eine Reihe von Problemen.  Beispielsweise wird die Option ausgeschlossen, wenn der Entwickler der Ansicht ist, dass <code>Dispose</code> automatisch aufgerufen wird und Sie sie nicht selbst aufrufen müssen.  Oder wenn der Entwickler erfahrener ist, hilft er ihm automatisch, auf der Ebene des Muskelgedächtnisses Code zu schreiben, der zu der geringsten Anzahl von Problemen führt. </p><br><p>  Eine andere Frage, die ich subjektiv nicht wirklich mag, ist, wie seine Arbeit erklärt wird.  Daher schlage ich einen alternativen Ansatz vor, der in meinem Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Platform Architecture beschrieben ist</a> . </p><br><p>  Wenn wir genau verstehen wollen, warum diese beiden Speicherverwaltungsalgorithmen ausgewählt wurden: Sweep und Compact, müssen wir Dutzende von Speicherverwaltungsalgorithmen berücksichtigen, die es auf der Welt gibt: beginnend mit gewöhnlichen Wörterbüchern und endend mit sehr komplexen sperrenfreien Strukturen.  Stattdessen <em>begründen</em> wir einfach <em>die</em> Wahl und <em>verstehen</em> dadurch <em>,</em> warum die Wahl so getroffen wurde.  Wir sehen uns das Booster-Startheft nicht mehr an: Wir haben eine vollständige Dokumentation in der Hand. </p><br><p>  Der Streit ist für beide Seiten von Vorteil: Wenn er nicht klar ist, werde ich die unklaren Punkte im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch</a> korrigieren, von denen ein kleiner Teil der gegebene Text ist. </p><br><p><img src="https://habrastorage.org/webt/sv/sw/_g/svsw_gfzggr2i1wk94ah_itbmqi.jpeg"></p><a name="habracut"></a><br><blockquote>  Ich habe das Format der Argumentation so gewählt, dass Sie das Gefühl haben, dass die Architekten der Plattform und ich zu den gleichen Ergebnissen gekommen sind, zu denen die echten Architekten in der Microsoft-Zentrale in Redmond gekommen sind. </blockquote><p>  Basierend auf der Klassifizierung der zugewiesenen Objekte anhand ihrer Größe können Sie den Speicherplatz für die Speicherzuweisung in zwei große Abschnitte unterteilen: einen Ort mit Objekten, deren Größe unter einem bestimmten Schwellenwert liegt, und einen Ort mit einer Größe über diesem Schwellenwert, um festzustellen, welche Unterschiede bei der Verwaltung dieser Gruppen (basierend auf) auftreten können ihre Größe) und was daraus wird. </p><br><p>  Wenn wir die Verwaltung herkömmlicher " <em>kleiner</em> " Objekte in Betracht ziehen, können wir feststellen, dass es für uns sehr teuer ist, Speicherverwaltungsdatenstrukturen zu verwalten, in denen Links zu jedem dieser Objekte gespeichert werden, wenn wir uns an die Idee halten, Informationen zu jedem Objekt zu speichern.  Am Ende kann sich herausstellen, dass Sie zum Speichern von Informationen zu einem Objekt so viel Speicher benötigen, wie das Objekt selbst benötigt.  Stattdessen sollten Sie berücksichtigen: Wenn wir während der Speicherbereinigung von den Wurzeln aus tanzen und tief in den Graphen durch die ausgehenden Felder des Objekts gehen und nur eine lineare Passage entlang des Heaps benötigen, um Müllobjekte zu identifizieren, müssen wir dann Informationen zu jedem Objekt in den Speicherverwaltungsalgorithmen speichern?  Die Antwort liegt auf der Hand: Es besteht keine Notwendigkeit dafür.  Wir können also versuchen, von der Tatsache auszugehen, dass wir solche Informationen nicht speichern sollten: Wir können eine Reihe linear durchlaufen, die Größe jedes Objekts kennen und den Zeiger jedes Mal um die Größe des nächsten Objekts bewegen. </p><br><blockquote>  Es gibt keine zusätzlichen Datenstrukturen auf dem Heap, die Zeiger auf jedes Objekt enthalten, das der Heap steuert. </blockquote><p>  Wenn wir jedoch keinen Speicher mehr benötigen, müssen wir ihn freigeben.  Und wenn wir Speicher freigeben, fällt es uns schwer, uns auf den linearen Durchgang des Haufens zu verlassen: Er ist lang und nicht effektiv.  Infolgedessen kommen wir zu dem Schluss, dass wir Informationen über freie Speicherbereiche irgendwie speichern müssen. </p><br><blockquote>  Der Heap enthält Listen mit freiem Speicher. </blockquote><p>  Wenn, wie wir beschlossen haben, Informationen über freie Bereiche gespeichert werden sollen und während Speicherplatz freigegeben wurde, diese Bereiche zu klein waren, stoßen wir zunächst auf das gleiche Problem beim Speichern von Informationen über freie Bereiche, auf das wir bei der Betrachtung besetzter Bereiche gestoßen sind (wenn Auf den Seiten des belegten Objekts wurde ein Objekt freigegeben, um Informationen darüber zu speichern, ist es im schlimmsten Fall 2/3 seiner Größe erforderlich. Zeiger + Größe versus SyncBlockIndex + VMT + ein Feld - im Fall des Objekts).  Das klingt wieder verschwenderisch, müssen Sie zugeben: Es ist nicht immer ein Glück, eine Gruppe von Objekten zu befreien, die aufeinander folgen.  Normalerweise werden sie auf chaotische Weise freigesetzt.  Im Gegensatz zu ausgelasteten Sites, die wir nicht linear durchsuchen müssen, müssen wir nach freien Sites suchen, da wir diese möglicherweise erneut benötigen, wenn wir Speicher zuweisen.  Daher entsteht ein völlig natürlicher Wunsch, die Fragmentierung zu verringern und den Haufen zusammenzudrücken, indem alle besetzten Bereiche an freie Orte verschoben werden, wodurch ein großer Bereich des freien Bereichs gebildet wird, in dem Speicher zugewiesen werden kann. </p><br><blockquote>  Hier kommt die Idee des Verdichtungsalgorithmus her. </blockquote><p>  Aber warte, sagst du?  Immerhin kann dieser Vorgang sehr schwierig sein.  Stellen Sie sich vor, Sie haben ein Objekt ganz am Anfang des Heaps freigegeben.  Und was, sagst du, brauchst du, um alles zu bewegen?  Natürlich können Sie sich das Thema Vektoranweisungen der CPU ausdenken, mit denen Sie einen riesigen belegten Speicherbereich kopieren können.  Dies ist jedoch nur der Beginn der Arbeit.  Wir müssen auch alle Zeiger aus den Feldern von Objekten auf Objekte fixieren, die Bewegungen erfahren haben.  Dieser Vorgang kann sehr lange dauern.  Nein, wir müssen von etwas anderem ausgehen.  Zum Beispiel, indem Sie das gesamte Segment des Heapspeichers in Sektoren aufteilen und separat damit arbeiten.  Wenn wir in jedem Sektor separat arbeiten (für die Vorhersagbarkeit und Skalierung dieser Vorhersagbarkeit - vorzugsweise für feste Größen), scheint die Idee der Komprimierung nicht so schwer zu sein: Es reicht aus, einen einzelnen Sektor zu komprimieren, und dann können Sie sogar anfangen, über die Zeit zu sprechen, die zum Komprimieren eines solchen Sektors erforderlich ist . </p><br><p>  Nun bleibt zu verstehen, auf welcher Grundlage in Sektoren unterteilt werden soll.  Hier müssen wir uns der zweiten Klassifizierung zuwenden, die auf der Plattform eingeführt wird: Speicherfreigabe, basierend auf der Lebensdauer der einzelnen Elemente. </p><br><p>  Die Unterteilung ist einfach: Wenn wir berücksichtigen, dass wir mit zunehmenden Adressen Speicher zuweisen, werden die ersten ausgewählten Objekte zu den ältesten und die Objekte in den älteren Adressen zu den jüngsten.  Wenn Sie klug sind, können Sie außerdem zu dem Schluss kommen, dass Objekte in Anwendungen in zwei Gruppen unterteilt sind: diejenigen, die für ein langes Leben erstellt wurden, und diejenigen, die für ein sehr geringes Leben erstellt wurden.  Zum Beispiel, um Zeiger auf andere Objekte in Form einer Sammlung vorübergehend zu speichern.  Oder die gleichen DTO-Objekte.  Dementsprechend erhalten wir von Zeit zu Zeit, wenn wir einen Haufen zusammendrücken, eine Reihe von langlebigen Objekten - in den unteren Adressen und eine Reihe von kurzlebigen - im Senior. </p><br><blockquote>  So haben wir <em>Generationen erhalten</em> . </blockquote><p>  Wenn wir die Erinnerung in Generationen aufteilen, haben wir die Möglichkeit, seltener auf die Objekte der älteren Generation zu schauen, die immer mehr werden. </p><br><p>  Aber es stellt sich eine andere Frage: Wenn wir nur zwei Generationen haben, werden wir Probleme bekommen.  Oder wir werden versuchen, GC maskenlos schnell zum Laufen zu bringen: Dann werden wir bei der Größe der jüngeren Generation versuchen, die Mindestgröße zu erreichen.  Infolgedessen versagen Objekte in der älteren Generation versehentlich (wenn der GC "gerade jetzt, während einer wütenden Speicherzuweisung für viele Objekte" funktioniert hat).  Um ein versehentliches Versagen zu minimieren, werden wir die Größe der jüngeren Generation erhöhen.  Dann arbeitet der GC der jüngeren Generation lange genug, verlangsamt und verlangsamt die Anwendung. </p><br><p>  Der Ausweg ist die Einführung der "mittleren" Generation.  Teenager.  Mit anderen Worten, wenn Sie bis zur Pubertät leben, ist es wahrscheinlicher, dass Sie bis ins hohe Alter leben.  Die Essenz seiner Einführung besteht darin, ein Gleichgewicht zwischen <em>der kleinsten jüngeren Generation</em> und der <em>stabilsten älteren Generation zu erreichen</em> , bei der es besser ist, nichts zu berühren.  Dies ist eine Zone, in der das Schicksal der Objekte noch nicht entschieden ist.  Die erste Generation (vergessen Sie nicht, was wir von Grund auf neu denken) ist ebenfalls klein und GC sieht dort seltener aus.  GC ermöglicht es somit den Objekten, die sich in der temporären ersten Generation befinden, nicht in die ältere Generation zu gelangen, was äußerst schwierig zu sammeln ist. </p><br><blockquote>  So kamen wir auf die Idee von drei Generationen. </blockquote><p>  Die nächste Optimierungsebene ist der Versuch, die Komprimierung abzulehnen.  Wenn Sie es nicht tun, werden wir schließlich eine riesige Schicht Arbeit los.  Kommen wir zurück zum Thema kostenlose Websites. </p><br><p>  Wenn wir den gesamten im Heap verfügbaren Speicher aufgebraucht haben und GC aufgerufen wurde, besteht ein natürlicher Wunsch, die Komprimierung zugunsten einer weiteren Zuweisung von Speicher innerhalb der freigegebenen Abschnitte zu verweigern, wenn ihre Größe ausreicht, um eine bestimmte Anzahl von Objekten aufzunehmen.  Hier kommen wir zu der Idee eines zweiten Algorithmus zum Freigeben von Speicher im GC namens <code>Sweep</code> : Wir komprimieren den Speicher nicht, wir verwenden Hohlräume von freigegebenen Objekten, um neue Objekte zu platzieren </p><br><blockquote>  Deshalb haben wir alle Grundlagen von GC-Algorithmen beschrieben und begründet. </blockquote><p>  Nach zwei Tagen können wir also einige Schlussfolgerungen ziehen.  So wie ich es verstehe, verstehen die meisten Leute den größten Teil des Textes oder sogar den ganzen.  Einige Leute antworteten, dass sie nicht verstanden, andere teilweise verstanden.  Der Streit wurde von einem Team von Lesern gewonnen, wenn auch mit einem geringen Vorsprung, wie sie sagen.  Aber wie gesagt, jeder wird davon profitieren: Der Text wird geändert und ergänzt.  Außerdem an beiden Stellen aktualisiert: sowohl im Buch als auch hier im Artikel. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464169/">https://habr.com/ru/post/de464169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464151/index.html">Victor Vyalichkin: „Freiheit, Gleichheit, Brüderlichkeit gibt es nur in OpenStreetMap, wo immer alles in Sicht ist.“</a></li>
<li><a href="../de464155/index.html">KI hilft bei der Untersuchung von Tieren in Afrika</a></li>
<li><a href="../de464161/index.html">SPAM und GDRP - wie mache ich Mailinglisten "dort"?</a></li>
<li><a href="../de464163/index.html">Dieses Schlüsselwort in JavaScript. Komplettes * Handbuch</a></li>
<li><a href="../de464165/index.html">Habr Weekly # 14 / Über die Kommunikationsregeln in Gruppenchats, Monopole und den Schutz von Kindern vor gefährlichen Informationen</a></li>
<li><a href="../de464171/index.html">Software-Update-Sicherheit</a></li>
<li><a href="../de464173/index.html">"Verdammte Galeere", oder wo die Beine vom jammernden Büro wachsen</a></li>
<li><a href="../de464177/index.html">Das Buch "Kotlin. Programmierung für Profis "</a></li>
<li><a href="../de464179/index.html">Ein Standup in Yandex.Taxi oder Was Sie dem Backend-Entwickler beibringen müssen</a></li>
<li><a href="../de464181/index.html">Poco - Python-basierte UI-Automatisierung für mobile Spiele als Teil der AirTest-IDE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>