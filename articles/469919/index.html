<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥌 🥡 🙍🏽 Verificación del código de Telegram Open Network por el analizador PVS-Studio 💔 🌋 🤽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Telegram Open Network (TON) es una plataforma de los creadores del Telegram messenger, que, además de blockchain, contiene un gran conjunto de servici...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verificación del código de Telegram Open Network por el analizador PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/469919/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/c0/tz/i9/c0tzi9vm0tdw3xqqv98pdcjttya.png" alt="Imagen 1"></div><br>  Telegram Open Network (TON) es una plataforma de los creadores del Telegram messenger, que, además de blockchain, contiene un gran conjunto de servicios.  Los desarrolladores publicaron recientemente un código de plataforma escrito en C ++ y lo publicaron en GitHub.  Queríamos ver el proyecto antes de su lanzamiento oficial. <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Telegram Open Network</a> es un conjunto de varios servicios.  Por ejemplo, el proyecto tiene su propio sistema de pago basado en la criptomoneda Gram, también hay una máquina virtual TON VM: los contratos inteligentes funcionan en ella.  Hay un servicio de mensajería: TON Messages.  El proyecto en sí tiene como objetivo combatir la censura de Internet. <br><br>  El proyecto utiliza el sistema de ensamblaje CMake, por lo que no hubo problemas especiales con el ensamblaje y la verificación.  El código está escrito en C ++ 14 y tiene 210 mil líneas: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/jv/sh/v-/jvshv-1q6z4hncl76-yv9oeuxz0.png" alt="Cuadro 5"></div><br>  El proyecto es pequeño y de alta calidad, por lo que no hubo tantos errores, pero son dignos de atención y corrección. <br><br><h2>  Código de retorno </h2><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_workchain_shard_hashes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((shard.shard &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || cs.size_ext() != <span class="hljs-number"><span class="hljs-number">0x20000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... int r = process_workchain_shard_hashes(....); if (r &lt; 0) { return r; } .... return cb.store_bool_bool(true) &amp;&amp; cb.store_ref_bool(std::move(left)) &amp;&amp; cb.store_ref_bool(std::move(right)) &amp;&amp; cb.finalize_to(branch) ? r : -1; .... }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V601</a> El valor 'falso' se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">convierte</a> implícitamente en el tipo entero.  mc-config.cpp 884 <br><br>  Parece que en este punto los desarrolladores alteraron el estado de error devuelto.  Aparentemente, la función debería devolver un valor negativo en caso de falla, y no verdadero / falso.  Al menos, es el retorno de -1 lo que se puede observar en el siguiente código. <br><br><h2>  Comparar una variable consigo misma </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LastBlock</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> td::actor::Actor { .... ton::ZeroStateIdExt zero_state_id_; .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> LastBlock::update_zero_state(ton::ZeroStateIdExt zero_state_id) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zero_state_id_ == zero_state_id_) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } LOG(FATAL) &lt;&lt; ....; }</code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V501</a> Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subexpresiones</a> idénticas a la izquierda y a la derecha del operador '==': zero_state_id_ == zero_state_id_ LastBlock.cpp 66 <br><br>  El código TON se escribe utilizando un estándar de codificación en el que los miembros de la clase se nombran con un guión bajo al final.  Sin embargo, dicha ortografía, como en este caso, puede pasar desapercibida y provocar un error.  El parámetro que entra en esta función tiene un nombre similar a un miembro de la clase, por lo que son fáciles de confundir.  Lo más probable es que fuera él quien participara en la comparación. <br><br><h2>  Macro insegura </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> td { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { [[noreturn]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_check_error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// namespace detail } #define CHECK(condition) \ if (!(condition)) { \ ::td::detail::process_check_error(#condition, __FILE__, __LINE__); \ } void BlockDb::get_block_handle(BlockIdExt id, ....) { if (!id.is_valid()) { promise.set_error(....); return; } CHECK(id.is_valid()); // &lt;= .... }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V581</a> Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Verifique las líneas: 80, 84. blockdb.cpp 84 <br><br>  La condición dentro de la macro <i>CHECK</i> nunca se cumplirá, porque  su verificación ya estaba dentro del <i>if</i> anterior. <br><br>  Hay otro error: la macro <i>CHECK</i> no es segura, porque  la condición en su interior no está envuelta en una construcción <i>do {...} while (0)</i> .  Esto es para evitar colisiones con otras condiciones en <i>otra cosa</i> .  En otras palabras, este código no funcionará como se esperaba: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X) CHECK(condition) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> foo();</code> </pre> <br><h2>  Validación de variable de signo </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Slice</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; .... }; td::Result&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; CellSerializationInfo::get_bits(td::Slice cell) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> last = cell[data_offset + data_len - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!last || last == <span class="hljs-number"><span class="hljs-number">0x80</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return td::Status::Error("overlong encoding"); } .... }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Advertencia de</a> PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V560</a> Una parte de la expresión condicional siempre es falsa: último == 0x80.  boc.cpp 78 <br><br>  La segunda parte de la condición nunca se cumplirá, porque  escriba <i>char</i> en este caso tiene un signo.  Al asignar un valor a una variable de tipo <i>int</i> , el signo se expandirá, por lo tanto, el rango de valores de la variable permanecerá en el límite [-128, 127] y no en [0, 256]. <br><br>  Vale la pena señalar que el tipo <i>char</i> no siempre se firmará; este comportamiento depende de la plataforma y el compilador.  Entonces, esta condición aún se puede cumplir teóricamente cuando se ensambla en otra plataforma. <br><br><h2>  Bit negativo Bit Bit Shift </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyIntView</span></span></span><span class="hljs-class">&lt;Tr&gt;:</span></span>:export_bits_any(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mask = (<span class="hljs-number"><span class="hljs-number">-0x100</span></span> &gt;&gt; offs) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>; .... }</code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V610</a> Comportamiento no especificado.  Verifique el operador de turno '&gt;&gt;'.  El operando izquierdo '-0x100' es negativo.  bigint.hpp 1925 <br><br>  La operación de desplazar bit a bit un número negativo hacia la derecha es un comportamiento no especificado: no se sabe cómo se comportará el signo en este caso: ¿se expandirá o se llenará con ceros? <br><br><h2>  Comprobar nulo después de nuevo </h2><br><pre> <code class="cpp hljs">CellBuilder* CellBuilder::make_copy() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { CellBuilder* c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CellBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw CellWriteError(); } .... }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V668</a> No tiene sentido probar el puntero 'c' contra nulo, ya que la memoria se asignó utilizando el operador 'nuevo'.  La excepción se generará en caso de error de asignación de memoria.  CellBuilder.cpp 531 <br><br>  Todo está claro en la advertencia del analizador: en caso de que la asignación de memoria no sea exitosa, se generará una excepción y no se devolverá un puntero nulo.  La verificación no tiene sentido. <br><br><h2>  Volver a comprobar </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!no_env) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* path = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getenv(<span class="hljs-string"><span class="hljs-string">"FIFTPATH"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path) { parse_include_path_set(path ? path : <span class="hljs-string"><span class="hljs-string">"/usr/lib/fift"</span></span>, source_include_path); } } .... }</code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V547 La</a> expresión 'ruta' siempre es verdadera.  fift-main.cpp 136 <br><br>  Este código fue tomado en una de las utilidades internas.  El operador ternario en este caso es superfluo: la condición que está registrada ya existe dentro del <i>if</i> anterior.  Lo más probable es que olvidaron eliminar el operador ternario cuando querían abandonar las rutas estándar (al menos no se dijo nada sobre ellas en el mensaje de ayuda). <br><br><h2>  Variable no utilizada </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Op::set_var_info_except(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VarDescrList&amp; new_var_info, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">var_idx_t</span></span>&gt;&amp; var_list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var_list.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set_var_info(new_var_info); } VarDescrList tmp_info{new_var_info}; tmp_info -= var_list; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set_var_info(new_var_info); <span class="hljs-comment"><span class="hljs-comment">// &lt;= }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V1001</a> La variable 'tmp_info' se asigna pero no se usa al final de la función.  analyzer.cpp 140 <br><br>  Aparentemente, en la última línea de esta función, se planeó usar la variable <i>tmp_info</i> .  Aquí está el código para la misma función, pero con otros especificadores de parámetros: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Op::set_var_info_except(VarDescrList&amp;&amp; new_var_info, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">var_idx_t</span></span>&gt;&amp; var_list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (var_list.size()) { new_var_info -= var_list; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } return set_var_info(std::move(new_var_info)); }</span></span></code> </pre> <br><h2>  Mas o menos? </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VarDescr&amp; x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VarDescr&amp; y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (mode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// &gt; return x.always_greater(y) ? 1 : (x.always_leq(y) ? 2 : 3); case 2: // = return x.always_equal(y) ? 1 : (x.always_neq(y) ? 2 : 3); case 3: // &gt;= return x.always_geq(y) ? 1 : (x.always_less(y) ? 2 : 3); case 4: // &lt; return x.always_less(y) ? 1 : (x.always_geq(y) ? 2 : 3); case 5: // &lt;&gt; return x.always_neq(y) ? 1 : (x.always_equal(y) ? 2 : 3); case 6: // &gt;= return x.always_geq(y) ? 1 : (x.always_less(y) ? 2 : 3); case 7: // &lt;=&gt; return x.always_less(y) ? 1 : (x.always_equal(y) ? 2 : (x.always_greater(y) ? 4 : (x.always_leq(y) ? 3 : (x.always_geq(y) ? 6 : (x.always_neq(y) ? 5 : 7))))); default: return 7; } }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V1037</a> Dos o más ramificaciones de casos realizan las mismas acciones.  Líneas de verificación: 639, 645 builtins.cpp 639 <br><br>  Los lectores atentos pueden haber notado que falta la operación &lt;= en este código.  Y de hecho, debería ser el número 6.  Esto se puede encontrar en dos lugares.  El primero es la inicialización: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AsmOp </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile_cmp_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;VarDescr&gt;&amp; res, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;VarDescr&gt;&amp; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.is_int_const() &amp;&amp; y.is_int_const()) { r.set_const(compute_compare(x.int_const, y.int_const, mode)); x.unused(); y.unused(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> push_const(r.int_const); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = compute_compare(x, y, mode); .... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define_builtins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... define_builtin_func(<span class="hljs-string"><span class="hljs-string">"_==_"</span></span>, arith_bin_op, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(compile_cmp_int, _1, _2, <span class="hljs-number"><span class="hljs-number">2</span></span>)); define_builtin_func(<span class="hljs-string"><span class="hljs-string">"_!=_"</span></span>, arith_bin_op, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(compile_cmp_int, _1, _2, <span class="hljs-number"><span class="hljs-number">5</span></span>)); define_builtin_func(<span class="hljs-string"><span class="hljs-string">"_&lt;_"</span></span>, arith_bin_op, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(compile_cmp_int, _1, _2, <span class="hljs-number"><span class="hljs-number">4</span></span>)); define_builtin_func(<span class="hljs-string"><span class="hljs-string">"_&gt;_"</span></span>, arith_bin_op, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(compile_cmp_int, _1, _2, <span class="hljs-number"><span class="hljs-number">1</span></span>)); define_builtin_func(<span class="hljs-string"><span class="hljs-string">"_&lt;=_"</span></span>, arith_bin_op, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(compile_cmp_int, _1, _2, <span class="hljs-number"><span class="hljs-number">6</span></span>)); define_builtin_func(<span class="hljs-string"><span class="hljs-string">"_&gt;=_"</span></span>, arith_bin_op, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(compile_cmp_int, _1, _2, <span class="hljs-number"><span class="hljs-number">3</span></span>)); define_builtin_func(<span class="hljs-string"><span class="hljs-string">"_&lt;=&gt;_"</span></span>, arith_bin_op, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind(compile_cmp_int, _1, _2, <span class="hljs-number"><span class="hljs-number">7</span></span>)); .... }</code> </pre> <br>  En la función <i>define_builtins</i> , puede ver la llamada <i>compile_cmp_int</i> para <i>&lt;=</i> con el parámetro de modo igual a 6. <br><br>  Bueno, la segunda es la misma función <i>compile_cmp_int</i> , que tiene los nombres de las operaciones: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AsmOp </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile_cmp_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;VarDescr&gt;&amp; res, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;VarDescr&gt;&amp; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* cmp_names[] = {<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"GREATER"</span></span>, <span class="hljs-string"><span class="hljs-string">"EQUAL"</span></span>, <span class="hljs-string"><span class="hljs-string">"GEQ"</span></span>, <span class="hljs-string"><span class="hljs-string">"LESS"</span></span>, <span class="hljs-string"><span class="hljs-string">"NEQ"</span></span>, <span class="hljs-string"><span class="hljs-string">"LEQ"</span></span>, <span class="hljs-string"><span class="hljs-string">"CMP"</span></span>}; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exec_op(cmp_names[mode], <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Debajo del índice 6 está la palabra <i>LEQ</i> , que significa Menos o Igual. <br><br>  Otro hermoso error relacionado con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase de errores en las funciones de comparación</a> . <br><br><h2>  Otros </h2><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VM_LOG_IMPL(st, mask) \ LOG_IMPL_FULL(get_log_interface(st), ...., VERBOSITY_NAME(DEBUG), \ (get_log_mask(st) &amp; mask) != 0, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;=</span></span></span></span></code> </pre> <br>  Advertencia de PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V1003</a> La macro 'VM_LOG_IMPL' es una expresión peligrosa.  El parámetro 'máscara' debe estar rodeado de paréntesis.  log.h 23 <br><br>  La macro <i>VM_LOG_IMPL</i> no es segura.  Su segundo parámetro no está rodeado de paréntesis; esto puede provocar efectos secundarios si se pasa una expresión compleja a la condición.  Si la <i>máscara</i> es solo una constante, entonces no habrá problemas con este código, pero nada nos impide pasar algo más a la macro. <br><br><h2>  En conclusión </h2><br>  El código TON resultó no ser tan grande y no contiene muchos errores.  Por lo cual, por supuesto, vale la pena rendir homenaje a los programadores del equipo de Telegram.  Sin embargo, incluso ellos no son inmunes a los errores.  El analizador de código es una herramienta poderosa que puede encontrar lugares peligrosos en las primeras etapas, incluso en bases de código de alta calidad, por lo que no se debe descuidar su uso.  El análisis estático no es una herramienta para las comprobaciones únicas, sino que forma parte del proceso de desarrollo: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Incruste el análisis estático en el proceso y no busque errores</a> ". <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si desea compartir este artículo con una audiencia de habla inglesa, utilice el enlace a la traducción: Sergey Larin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprobación de Telegram Open Network con PVS-Studio</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469919/">https://habr.com/ru/post/469919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469909/index.html">Pantallas duales, Windows 10X y el nuevo teléfono inteligente Android: lo que Microsoft mostró en su Surface Event</a></li>
<li><a href="../469911/index.html">DVR: las principales diferencias entre los dispositivos modernos</a></li>
<li><a href="../469913/index.html">Dos caras de una moneda llamada "Eternidad"</a></li>
<li><a href="../469915/index.html">Comprobación de la red abierta de Telegram con PVS-Studio</a></li>
<li><a href="../469917/index.html">Texto rápido en PHP \ Python. Primeros pasos</a></li>
<li><a href="../469921/index.html">[Caso] Monitoreo de la calidad del aire en un pueblo rural</a></li>
<li><a href="../469923/index.html">Vulnerabilidad inesperada en productos Apple. Totalmente inesperado</a></li>
<li><a href="../469925/index.html">"F # no es más difícil de dominar que Entity Framework o WPF": Entrevista con Scott Vlashin</a></li>
<li><a href="../469931/index.html">¿Qué es un factor de velocidad de aprendizaje y cómo mejora las características de aprendizaje profundo?</a></li>
<li><a href="../469935/index.html">Curso "Fundamentos del trabajo efectivo con Wolfram Technologies": más de 13 horas de video conferencias, teoría y problemas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>