<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèø üê≤ üì† Sketch + Node.js: gere √≠cones para muitas plataformas e marcas. Parte 2 üëºüèº üé± üë©üèº‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© a segunda parte do artigo sobre a cria√ß√£o de uma ferramenta que pode exportar todos os √≠cones colocados em um arquivo de esbo√ßo: em diferentes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sketch + Node.js: gere √≠cones para muitas plataformas e marcas. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/442886/"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br>  Esta √© a segunda parte do artigo sobre a cria√ß√£o de uma ferramenta que pode exportar todos os √≠cones colocados em um arquivo de esbo√ßo: em diferentes formatos, para diferentes plataformas, com a possibilidade de testar A / B de cada √≠cone. <br><br>  Voc√™ pode ler a primeira parte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do link</a> . <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br>  Na √∫ltima vez, preparamos arquivos de esbo√ßo contendo todos os √≠cones nos estilos corretos e com os nomes corretos.  √â a vez de escrever c√≥digo. <br><br>  Basta dizer que passamos por tentativa e erro.  Depois que o l√≠der da nossa equipe, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nihil Verma</a> , que lan√ßou as bases do script, desenvolveu o c√≥digo-chave, iniciei um processo que exigia pelo menos tr√™s fases de refatora√ß√£o e muitas modifica√ß√µes.  Por esse motivo, n√£o abordarei os detalhes da cria√ß√£o do script e me concentrarei em como ele funciona hoje, em sua forma final. <br><a name="habracut"></a><br><h2>  Script de compila√ß√£o </h2><br>  O script de compila√ß√£o escrito no Node.js √© bastante direto em seu trabalho: importando depend√™ncias, declarando uma lista de arquivos do Sketch para processamento (√© uma lista de marcas, cada uma com uma lista de arquivos relacionados a ele) e garantindo que o Sketch esteja instalado no cliente , o script processa as marcas, por sua vez, realizando uma s√©rie de a√ß√µes com cada uma delas. <br><br><ol><li>  Leva tokens de design apropriados para as marcas (precisamos de valores de cores). <br></li><li>  Clona arquivos de esbo√ßo associados √† marca, descompacta-os para extrair arquivos JSON internos e processa alguns de seus valores internos (mais sobre isso posteriormente). <br></li><li>  L√™ os metadados necess√°rios desses arquivos JSON ( <i>document.json</i> , <i>meta.json</i> e <i>pages / pageUniqueID.json</i> ).  Estamos interessados ‚Äã‚Äãem listas de estilos e recursos / √≠cones comuns contidos nos arquivos. <br></li><li>  Ap√≥s mais algumas manipula√ß√µes com arquivos JSON, ele recria o arquivo morto e, usando arquivos de Sketch (clonados e atualizados), exporta e cria os arquivos finais de sa√≠da para tr√™s plataformas (iOS, Android, Mobile Web). <br></li></ol><br>  As partes relevantes do script de constru√ß√£o podem ser encontradas aqui: <br><br><pre><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; {   // get the design tokens for the brand   const brandTokens = getDesignTokens(brand);    // prepare the Sketch files (unzipped) and get a list of them   const sketchUnzipFolders = await prepareSketchFiles({     brand,     sketchFileNames: SKETCH_FILES[brand],     sketchFolder: SKETCH_FOLDER_PATH,     sketchTempFolder: SKETCH_TEMP_PATH   });   // get the Sketch metadata   const sketchMetadata = getSketchMetadata(sketchUnzipFolders);   const sketchDataSharedStyles = sketchMetadata.sharedStyles;   const sketchDataAssets = sketchMetadata.assetsMetadata;   generateAssetsPDF({     platform: 'ios',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   });   generateAssetsSVGDynamicMobileWeb({     platform: 'mw',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   });   generateAssetsVectorDrawableDynamicAndroid({     platform: 'android',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   }); }); }</code> </pre> <br>  De fato, o c√≥digo do pipeline √© muito mais complicado.  O motivo dessa complexidade est√° nas <code>prepareSketchFiles</code> , <code>getSketchMetadata</code> e <code>generateAssets[format][platform]</code> .  Abaixo tentarei descrev√™-los com mais detalhes. <br><br><h2>  Preparando arquivos de esbo√ßo </h2><br>  A primeira etapa do processo de montagem √© a prepara√ß√£o dos arquivos do Sketch, que posteriormente ser√£o usados ‚Äã‚Äãpara exportar recursos para v√°rias plataformas. <br><br>  Os arquivos associados a uma marca espec√≠fica (por exemplo, no caso do Blendr, s√£o <i>arquivos icons_common.sketch</i> e <i>icons_blendr.sketch</i> ) s√£o clonados em uma pasta tempor√°ria (mais precisamente, em uma subpasta nomeada ap√≥s o processamento da marca) e descompactados. <br><br>  Em seguida, os arquivos JSON s√£o processados.  Um prefixo √© adicionado ao nome dos recursos sujeitos ao teste A / B - assim, durante a exporta√ß√£o, eles s√£o salvos em uma subpasta com um nome predefinido (correspondente ao nome exclusivo do experimento).  Voc√™ pode entender se um recurso est√° sujeito ao teste A / B pelo nome da p√°gina em que est√° armazenado: se estiver, o nome conter√° o prefixo " <i>XP_</i> ". <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br><br>  No exemplo acima, os recursos exportados ser√£o armazenados em uma subpasta " <i>this__is_an_experiment</i> " com um nome de arquivo no formato " <i>icon-name [variant-name] .ext</i> ". <br><br><h2>  Leitura de metadados de esbo√ßo </h2><br>  A segunda etapa importante √© extrair todos os metadados necess√°rios dos arquivos do Sketch, ou melhor, dos arquivos JSON internos.  Como vimos acima, esses s√£o dois arquivos principais ( <i>document.json</i> e <i>meta.json</i> ) e arquivos de p√°gina ( <i>pages / pageUniqueId.json</i> ). <br><br>  O arquivo <i>document.json</i> √© usado para obter a lista de estilos comuns que aparecem sob a propriedade do objeto <i>layerStyles</i> : <br><br><pre> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": {  "_class": "sharedStyleContainer",  "objects": [    {      "_class": "sharedStyle",      "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4",      "name": "features/feature-like",      "value": {        "_class": "style",        "fills": [          {            "_class": "fill",            "isEnabled": true,            "color": {              "_class": "color",              "alpha": 1,              "blue": 0.10588235408067703,              "green": 0.4000000059604645,              "red": 1            },            "fillType": 0,            "noiseIndex": 0,            "noiseIntensity": 0,            "patternFillType": 1,            "patternTileScale": 1          }        ],        "blur": {...},        "startMarkerType": 0,        "endMarkerType": 0,        "miterLimit": 10,        "windingRule": 1      }    },    ...</code> </pre> <br>  Armazenamos informa√ß√µes b√°sicas sobre cada estilo em um objeto de formato de valor-chave.  Ele ser√° usado posteriormente quando precisarmos extrair o nome do estilo com base em um ID exclusivo (propriedade <code>do_objectID</code> no Sketch): <br><br><pre> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = {  name: object.name,  isFill: _.get(object, 'value.fills[0].color') !== undefined,  isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br>  Agora vamos ao arquivo <i>meta.json</i> e obtemos uma lista de p√°ginas.  Estamos interessados ‚Äã‚Äãem seu <code>unique-id</code> e <code>name</code> <code>unique-id</code> : <br><br><pre> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": {  "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": {    "name": "Icons",    "artboards": {      "3275987C-CE1B-4369-B789-06366EDA4C98": {        "name": "badge-feature-like"      },      "C6992142-8439-45E7-A346-FC35FA01440F": {        "name": "badge-feature-crush"      },      ...      "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": {        "name": "tabbar-livestream"      }      ...    }  },  "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": {    "name": "XP_this__is_an_experiment",    "artboards": {      "31A812E8-D960-499F-A10F-C2006DDAEB65": {        "name": "this__is_an_experiment/tabbar-livestream[variant1]"      },      "20F03053-ED77-486B-9770-32E6BA73A0B8": {        "name": "this__is_an_experiment/tabbar-livestream[variant2]"      },      "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": {        "name": "this__is_an_experiment/tabbar-livestream[control]"      }    }  },</code> </pre> <br>  Em seguida, lemos os arquivos JSON correspondentes a cada p√°gina na pasta <i>pages</i> (repito que os nomes dos arquivos t√™m o formato <i>[pageUniqueId] .json</i> ) e estudamos os recursos armazenados nesta p√°gina (eles se parecem com camadas).  Assim, obtemos o <b>nome</b> , a <b>largura / altura de</b> cada √≠cone, os <b>metadados do</b> Sketch para o √≠cone dessa camada e, se estamos lidando com uma p√°gina de <b>experi√™ncia</b> , o nome do <b>teste A / B</b> e uma <b>variante</b> desse √≠cone. <br><br>  <i>Nota</i> : o objeto page.json possui um dispositivo muito complexo, por isso n√£o vou insistir nele.  Se voc√™ estiver interessado no que est√° dentro, aconselho a criar um novo arquivo de esbo√ßo vazio, adicionar algum conte√∫do a ele e salv√°-lo;  renomeie sua extens√£o para ZIP, descompacte-o e examine um dos arquivos na pasta p√°ginas. <br><br>  No processo de processamento de pranchetas, tamb√©m criaremos uma <b>lista de experimentos</b> (e recursos relacionados).  Precisamos dele para determinar quais varia√ß√µes do √≠cone s√£o usadas em qual experimento - os nomes das varia√ß√µes do √≠cone est√£o anexados ao objeto "base". <br><br>  Para cada arquivo de esbo√ßo <code>assetsMetadata</code> marca que est√° sendo processado, criamos um objeto <code>assetsMetadata</code> seguinte apar√™ncia: <br><br><pre> <code class="plaintext hljs">{ "navigation-bar-edit": {  "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977",  ...sketch_artboard_properties,  "name": "navigation-bar-edit",  "assetname": "navigation-bar-edit",  "source": "icons_common",  "width": 48,  "height": 48  "layers": [    {      "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4",      "name": "Path",      ...sketch_layer_properties,      "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5",      "style": {        ...        "fills": [          {            "_class": "fill",            "isEnabled": true,            "color": {              "_class": "color",              "alpha": 1,              "blue": 0.8784313725490196,              "green": 0.8784313725490196,              "red": 0.8784313725490196            },          }        ],        "miterLimit": 10,        "startMarkerType": 0,        "windingRule": 1      },    },  ],  ... }, "experiment-name/navigation-bar-edit[variant]": {  "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7",  ...sketch_artboard_properties,  "name": "experiment-name/navigation-bar-edit[variant]",  "assetname": "navigation-bar-edit",  "source": "icons_common",  "width": 48,  "height": 48  ...</code> </pre> <br>  Como voc√™ pode ver, no experimento, um √∫nico √≠cone (neste caso <i>, barra de navega√ß√£o de edi√ß√£o</i> ) pode corresponder a muitos recursos.  Ao mesmo tempo, o mesmo √≠cone pode aparecer com o mesmo nome em outro arquivo de esbo√ßo associado √† marca.  <b>Isso √© muito √∫til</b> : usamos esse truque para compilar um conjunto comum de √≠cones e depois identificar op√ß√µes espec√≠ficas de acordo com a marca.  Por isso, declaramos os arquivos de esbo√ßo associados a uma determinada marca como uma matriz: <br><br><pre> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br>  Nesse caso, a ordem √© de import√¢ncia fundamental.  De fato, na fun√ß√£o <code>getSketchMetadata</code> chamada pelo script, n√£o retornamos objetos <code>assetsMetadata</code> um de cada vez como um arquivo de lista.  Em vez disso, realizamos uma mesclagem profunda de objetos - os combinamos e retornamos um √∫nico objeto <code>assetsMetadata</code> . <br><br>  Em geral, isso nada mais √© do que uma fus√£o "l√≥gica" de arquivos do Sketch e seus recursos em um √∫nico arquivo.  No entanto, a l√≥gica n√£o √© t√£o simples quanto parece.  Aqui est√° um diagrama que criamos na tentativa de descobrir o que acontece quando √≠cones com o mesmo nome (e possivelmente sujeitos ao teste A / B) em arquivos diferentes s√£o associados √† mesma marca: <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br><br><h2>  Cria√ß√£o de arquivos prontos em diferentes formatos para diferentes plataformas </h2><br>  A etapa final do nosso processo √© a cria√ß√£o direta de arquivos de √≠cones em diferentes formatos para diferentes plataformas (PDF para iOS, SVG / JSX para Web e VectorDrawable para Android). <br><br>  Como voc√™ pode ver no n√∫mero de par√¢metros passados ‚Äã‚Äãpara as fun√ß√µes <code>generateAssets[format][platform]</code> , essa parte do pipeline √© a mais complexa.  √â aqui que o processo come√ßa a ser interrompido e alterado, dependendo da plataforma.  Abaixo, voc√™ ver√° o curso l√≥gico do script como um todo e como a parte relacionada √† gera√ß√£o de recursos √© dividida em tr√™s processos semelhantes, mas diferentes: <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br>  Para criar recursos prontos com as cores corretas correspondentes √† marca que est√° sendo processada, precisaremos realizar mais algumas manipula√ß√µes com arquivos JSON.  Analisamos todas as camadas √†s quais o estilo geral √© aplicado e substitu√≠mos os valores das cores pelas cores do token de design da marca. <br><br>  Para gerar arquivos para o Android, voc√™ precisa executar uma a√ß√£o adicional (sobre isso um pouco mais tarde): <code>windingRule</code> propriedade <code>fill-rule</code> de cada camada de <code>even-odd</code> para <code>non-zero</code> (isso √© controlado pela propriedade <code>windingRule</code> do objeto JSON, na qual 1 significa "√≠mpar / par" e 0 √© "diferente de zero"). <br><br>  Depois de fazer essas manipula√ß√µes, empacotamos os arquivos JSON de volta em um arquivo de esbo√ßo padr√£o para processar e exportar recursos com propriedades atualizadas (arquivos clonados e atualizados s√£o arquivos de esbo√ßo comuns, podem ser abertos, visualizados, editados, salvos etc.) ) <br><br>  Depois disso, usamos o SketchTool (agrupado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em Node</a> ) para exportar automaticamente todos os recursos em formatos adequados para plataformas.  Para cada um dos arquivos associados √† marca (ou melhor, suas vers√µes clonadas e atualizadas), executamos o seguinte comando: <br><br><pre> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg --scales=1 --output=${destinationFolder} --overwriting`);</code> </pre> <br>  Como voc√™ pode imaginar, esse comando exporta recursos para a pasta de destino em um formato espec√≠fico, opcionalmente usando a escala (mantemos a escala original por enquanto).  A chave aqui √© a op√ß√£o <code>-overwriting</code> : assim como fazemos uma mesclagem profunda de objetos <code>assetsMetadata</code> (correspondentes aos arquivos de esbo√ßo "l√≥gicos"), ao exportar, mesclamos muitos arquivos em um diret√≥rio (relacionado √† marca / plataforma).  Isso significa que se o recurso - identificado pelo nome da camada - j√° existir no arquivo de esbo√ßo anterior, ele ser√° substitu√≠do durante a pr√≥xima exporta√ß√£o.  Novamente, isso nada mais √© do que uma opera√ß√£o de mesclagem normal. <br><br>  No entanto, neste exemplo, alguns recursos podem vir a ser "fantasmas".  Isso acontece quando o √≠cone no arquivo √© submetido ao teste A / B, mas √© substitu√≠do no arquivo subseq√ºente.  Em seguida, os arquivos variantes s√£o exportados para a pasta de destino, possuem um link correspondente ao recurso no objeto <code>assetsMetadata</code> (com sua chave e propriedades), mas n√£o s√£o associados a nenhum recurso base (devido √† fus√£o profunda dos objetos <code>assetsMetadata</code> ).  Esses arquivos ser√£o exclu√≠dos mais tarde, antes de concluir o processo. <br><br><hr><br>  Como j√° mencionado, plataformas diferentes requerem formatos de sa√≠da diferentes.  Os arquivos iOS cabem em PDFs, e podemos export√°-los diretamente usando o comando SketchTool.  Os arquivos JSX s√£o necess√°rios para a Web m√≥vel e o VectorDrawable para Android.  Por esse motivo, exportamos recursos no formato SVG para uma pasta tempor√°ria e depois os processamos. <br><br><h2>  PDFs para iOS </h2><br>  Curiosamente, o PDF √© o √∫nico (?) Formato que o Xcode e o OS / iOS suportam para importar e renderizar recursos vetoriais ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° uma breve explica√ß√£o da</a> escolha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da</a> Apple). <br><br>  Como podemos exportar diretamente para PDF via SketchTool, n√£o s√£o necess√°rias etapas adicionais: basta salvar os arquivos diretamente na pasta de destino e pronto. <br><br><h2>  Arquivos da Web React / JSX </h2><br>  No caso da Web, usamos o N√≥ da biblioteca SVGR, que permite converter componentes SVG em React.  No entanto, queremos fazer algo abruptamente: "dinamicamente colorir" o √≠cone em tempo de execu√ß√£o (as cores s√£o retiradas dos tokens).  Para fazer isso, antes da convers√£o, alteramos os valores de <code>fill</code> dos vetores aos quais o estilo geral foi aplicado anteriormente aos valores dos tokens correspondentes a esse estilo. <br><br>  Portanto, se o arquivo <i>badge-feature-like.svg</i> exportado do Sketch se parecer com o seguinte: <br><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) -&lt;a href="http://www.bohemiancoding.com/sketch"&gt; http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt;  &lt;g id="badge-feature-like"&gt;    &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt;    &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt;  &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br>  o <i>√≠cone</i> final resource / <i>badge-feature-like.js</i> ficar√° assim: <br><br><pre> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return (  &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt;    &lt;g fill="none" fillRule="evenodd"&gt;      &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt;      &lt;path fill="#FFF" d="M80.4061668,..." /&gt;    &lt;/g&gt;  &lt;/svg&gt; ); };</code> </pre> <br>  Como voc√™ pode ver, substitu√≠mos a cor de <code>fill</code> est√°tico por uma din√¢mica que aceita valores de tokens (eles podem ser disponibilizados para o componente React <code>&lt;Icon/&gt;</code> por meio da API de contexto, mas essa √© uma hist√≥ria diferente). <br><br>  Essa substitui√ß√£o √© poss√≠vel gra√ßas aos metadados do Sketch para os ativos do objeto <code>assetsMetadata</code> : percorrendo recursivamente as camadas, voc√™ pode criar um seletor DOM (no exemplo acima, <code>#Icons</code> <code>#badge-feature-like #circle</code> ) e us√°-lo para procurar um n√≥ na √°rvore SVG e substituir seu valor atributo de <code>fill</code> (para isso precisamos da biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cheerio</a> ). <br><br><h2>  Arquivos desenh√°veis ‚Äã‚Äãpara Android </h2><br>  O Android suporta gr√°ficos vetoriais usando o formato vetorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VectorDrawable</a> personalizado.  Normalmente, a convers√£o de SVG para VectorDrawable √© feita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diretamente no Android Studio</a> .  No entanto, quer√≠amos automatizar completamente o processo, ent√£o est√°vamos procurando uma maneira de converter usando o c√≥digo. <br><br>  Depois de estudar v√°rias ferramentas e bibliotecas, decidimos pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">svg2vectordrawable</a> .  Ele n√£o √© apenas suportado ativamente (em qualquer caso, mais ativo que todos os outros), mas tamb√©m mais funcional que o resto. <br><br>  As realidades s√£o que VectorDrawable e SVG n√£o s√£o iguais em sua funcionalidade: algumas fun√ß√µes SVG (por exemplo, gradientes radiais e realce complexo) n√£o s√£o suportadas pelo VectorDrawable, enquanto outras come√ßaram a ser suportadas recentemente (a partir da API Android 24).  Um dos problemas decorrentes disso √© que as vers√µes mais antigas (at√© 24) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o suportam o valor par-√≠mpar do atributo de regra de preenchimento</a> .  No entanto, no Badoo precisamos de suporte para o Android 5 e superior.  Por isso, em um dos est√°gios anteriores, aumentamos o <code>fill</code> cada vetor nos arquivos de esbo√ßo para um valor <code>non-zero</code> . <br><br>  Em princ√≠pio, os designers podem executar esta a√ß√£o manualmente: <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br>  Mas √© f√°cil esquecer e cometer um erro.  Portanto, decidimos adicionar uma etapa adicional ao processo para Android, na qual todos os vetores no JSON s√£o convertidos automaticamente para <code>non-zero</code> .  Isso √© feito para que, ao exportar √≠cones para o SVG, eles j√° estejam no formato necess√°rio e cada objeto VectorDrawable criado seja suportado por dispositivos no Android 5. <br><br>  O arquivo <i>badge-feature-like.xml conclu√≠do</i> √© assim: <br><br><pre> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path  android:fillColor="?color_feature_liked_you"  android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path  android:fillColor="#FFFFFF"  android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br>  Nos arquivos VectorDrawable, inserimos nomes de vari√°veis ‚Äã‚Äãpara cores de <code>fill</code> associadas a tokens de design por meio de estilos comuns em aplicativos Android. <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br><br>  Vale ressaltar que o Android Studio possui requisitos r√≠gidos para organizar recursos: sem subpastas e letras mai√∫sculas nos nomes!  Ent√£o tivemos que criar um novo formato para os nomes dos √≠cones: no caso de recursos a serem testados, eles se parecem com isso: <code>ic_icon-name__experiment-name__variant-name</code> . <br><br><h2>  Dicion√°rio JSON como uma biblioteca de recursos </h2><br>  Depois que os arquivos de recursos s√£o salvos no formato final, resta apenas coletar todas as metainforma√ß√µes obtidas durante a montagem e salv√°-las em um ‚Äúdicion√°rio‚Äù para usar quando os recursos forem importados e usados ‚Äã‚Äãpela base de c√≥digo de v√°rias plataformas. <br><br>  Ap√≥s extrair uma lista simples de √≠cones do objeto <code>assetsMetadata</code> -o, verificando cada um deles: <br><br><ul><li>  Esse √© um recurso regular (por exemplo, <code>tabbar-livestream</code> );  se sim, ent√£o deixe; <br></li><li>  se essa √© uma op√ß√£o para um teste A / B (por exemplo, <i>experiment / tabbar-livestream [variante]</i> ), associamos seu nome, caminho, nomes do teste A / B e variante √† propriedade <code>abtests</code> <br>  o recurso base (no nosso caso, √© <i>tabest-livestream</i> ), ap√≥s o qual exclu√≠mos o registro sobre a variante da lista / objeto (apenas o elemento "base" importa); <br></li><li>  se for um "fantasma", exclua o arquivo e remova a entrada da lista / objeto. <br></li></ul><br>  Depois de concluir esse processo, o dicion√°rio conter√° uma lista de todos os √≠cones b√°sicos (e seus testes A / B, se houver), e apenas eles.  As informa√ß√µes sobre cada um deles incluem o nome, tamanho, caminho e, se o √≠cone estiver sujeito ao teste A / B, informa√ß√µes sobre suas v√°rias op√ß√µes. <br><br>  O dicion√°rio √© salvo no formato JSON na pasta de destino da <i>marca</i> e <i>plataforma</i> .  Aqui, por exemplo, est√° o arquivo <i>assets.json</i> gerado para o aplicativo Blendr para Mobile Web: <br><br><pre> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": {    "badge-feature-like": {    "assetname": "badge-feature-like",    "path": "assets/badge-feature-like.jsx",    "width": 64,    "height": 64,    "source": "icons_common"  },  "navigation-bar-edit": {    "assetname": "navigation-bar-edit",    "path": "assets/navigation-bar-edit.jsx",    "width": 48,    "height": 48,    "source": "icons_common"  },  "tabbar-livestream": {    "assetname": "tabbar-livestream",    "path": "assets/tabbar-livestream.jsx",    "width": 128,    "height": 128,    "source": "icons_blendr",    "abtest": {      "this__is_an_experiment": {        "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx",        "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx",        "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx"      },      "a_second-experiment": {        "control": "assets/a_second-experiment/tabbar-livestream__control.jsx",        "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx"      }    }  },  ... } }</code> </pre> <br>  Agora, resta apenas empacotar todas as pastas de <i>ativos</i> em arquivos ZIP para facilitar o download. <br><br><h2>  Sum√°rio </h2><br>  O processo descrito no artigo, da clonagem e manipula√ß√£o dos arquivos do Sketch √† exporta√ß√£o e convers√£o de recursos para formatos suportados pelas plataformas e salvamento de meta-informa√ß√µes coletadas na biblioteca de recursos, √© repetido com todas as marcas anunciadas no script de constru√ß√£o. <br><br>  Aqui est√° uma captura de tela mostrando a apar√™ncia das pastas <i>src</i> e <i>dist</i> ap√≥s a conclus√£o do processo: <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br><br>  Nesse est√°gio, usando um comando simples, voc√™ pode fazer upload de todos os recursos (JSON, ZIP e arquivos de recursos) para o armazenamento remoto e disponibiliz√°-los para todas as plataformas para download e uso na base de c√≥digo. <br><br>  Como exatamente as plataformas recebem e processam recursos (usando scripts personalizados criados especificamente para essa finalidade) n√£o vai al√©m do escopo deste artigo.  E essa pergunta provavelmente ser√° abordada em um dos posts a seguir por um de meus colegas. <br><br><h2>  Conclus√£o (e li√ß√µes aprendidas) </h2><br>  Eu sempre amei Sketch.  Por muitos anos, o programa tem sido a ferramenta padr√£o para desenvolvedores e designers.  Portanto, fiquei muito curioso para aprender ferramentas de integra√ß√£o como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">html-sketchapp</a> e outras ferramentas semelhantes que poder√≠amos usar no fluxo de trabalho e em nossos pipelines. <br><br>  Eu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como muitos outros</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sempre lutei</a> por esse processo (ideal): <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br>  No entanto, devo admitir que comecei a duvidar que o Sketch seja uma ferramenta adequada, principalmente considerando o sistema de design.  Portanto, comecei a procurar outros servi√ßos, como o Figma com suas APIs abertas e o Framer X com integra√ß√£o conveniente com o React, porque n√£o senti o movimento do Sketch em dire√ß√£o √† integra√ß√£o com o c√≥digo (o que quer que fosse). <br><br>  Ent√£o, esse projeto me convenceu.  N√£o completamente, mas de v√°rias maneiras. <br><br>  Embora o Sketch n√£o abra suas APIs, o pr√≥prio dispositivo da estrutura interna de seus arquivos serve como um tipo de API "n√£o oficial".  Os criadores podem usar nomes criptografados ou ocultar chaves em objetos JSON, mas seguem uma conven√ß√£o de nomenclatura clara, leg√≠vel e conceitual.  Eu n√£o acho que isso seja um acidente. <br><br>  O fato de que os arquivos do Sketch podem ser gerenciados dessa maneira me abriu muitos desenvolvimentos e melhorias futuros: de plug-ins para verificar o nome, a estiliza√ß√£o e a estrutura das camadas de √≠cones, a integra√ß√£o com nosso Wiki e a documenta√ß√£o de nosso sistema de design (m√∫tuo).  Ao criar aplicativos Node no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Electron</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Carlo</a> , podemos facilitar aos projetistas a conclus√£o de muitas tarefas rotineiras. <br><br>    (  ,  )   ,  Sketch-   Cosmos  ¬´ ¬ª ‚Äî      - Cosmos.   ,        (   ;    ,    ‚Äî ).    ,      ‚Äî  ,   ,  . <br><br>      ,  Sketch-  , ,    MVP-,       .    ,     ,     . , , -,  ‚Äî    ,             .  ,         . <br><br>  :       <i></i> ,      <i></i> .   ,       <i></i> . <br><br> ,    , ‚Äî   .  ,  ,       ,    (,         A/B-),            Node.js  Sketch. <br><br>   !     . <br><br><h2>  </h2><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> (Mobile Web),     , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> (Android)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> (iOS),           . <br><br> , !             . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442886/">https://habr.com/ru/post/pt442886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442872/index.html">Como encontrei o ovo da p√°scoa na prote√ß√£o do Android e n√£o consegui um emprego no Google</a></li>
<li><a href="../pt442876/index.html">Mapeamento de ru√≠do com KSQL, Raspberry Pi e r√°dio</a></li>
<li><a href="../pt442880/index.html">Pontos de verifica√ß√£o virtuais: lista de verifica√ß√£o de configura√ß√£o</a></li>
<li><a href="../pt442882/index.html">[V√≠deo] "Piems n√£o s√£o necess√°rios" e mais tr√™s id√©ias de gerenciamento de projetos</a></li>
<li><a href="../pt442884/index.html">A tecnologia j√° permite que voc√™ converse com o carro como pessoa</a></li>
<li><a href="../pt442888/index.html">Personalizar select em css puro</a></li>
<li><a href="../pt442890/index.html">CYOD? COPE? BYOD?</a></li>
<li><a href="../pt442892/index.html">Programa√ß√£o orientada a depura√ß√£o ou tristeza aos olhos do integrador</a></li>
<li><a href="../pt442896/index.html">A produ√ß√£o aditiva de ciclo completo em uma empresa de avia√ß√£o √© uma quest√£o para o futuro pr√≥ximo</a></li>
<li><a href="../pt442898/index.html">Solu√ß√µes para o problema de bots de spam adicionados a grupos de telegramas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>