<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∂ üè¥ ü•£ Aufbau eines Teams zur Abfrage von Daten aus der Datenbank - Teil 2 üîß üîé üëçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vorherigen Teil habe ich mich auf die Tatsache konzentriert, dass das Team, das ich entwickle, Verhaltensweisen implementiert, die mit diesem Test ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aufbau eines Teams zur Abfrage von Daten aus der Datenbank - Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436348/"><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil habe</a> ich mich auf die Tatsache konzentriert, dass das Team, das ich entwickle, Verhaltensweisen implementiert, die mit diesem Test beschrieben werden k√∂nnen: </p><br><pre><code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'execute should return promise'</span></span>, () =&gt; { request.configure(options); request.execute().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(result.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <a name="habracut"></a><br><p>  Es scheint mir jetzt, dass es nicht ganz das ist, was ich m√∂chte, wenn ich <code>Promise</code> als Ergebnis <code>Promise</code> und es verarbeite.  Es w√§re besser, wenn das Team selbst diese Routinearbeit ausf√ºhren w√ºrde und das Ergebnis beispielsweise im <code>Redux</code> Repository abgelegt w√ºrde.  Ich werde versuchen, den vorhandenen Test neu zu schreiben, um meine neuen Erwartungen darin auszudr√ºcken: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../src/store'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DbMock = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../mocks/DbMock'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMock(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Request = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../src/storage/Request'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(db, store); }); it(<span class="hljs-string"><span class="hljs-string">'should dispatch action if record exists'</span></span>, () =&gt; { request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = store.getState().user; expect(user.Id).toEqual(options.query.Id); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Dies ist wahrscheinlich bequemer, obwohl ich jetzt die <code>execute</code> der <code>Request</code> Klasse unterrichten muss, um die R√ºckrufmethode auszuf√ºhren, wenn der Benutzer sie als Argument √ºbergibt.  Sie k√∂nnen nicht darauf verzichten, da ich bei der <code>execute</code> vermutlich asynchrone Aufrufe verwende, deren Testergebnisse nur getestet werden k√∂nnen, wenn sie davon √ºberzeugt sind, dass ihre Ausf√ºhrung abgeschlossen ist. </p><br><p>  Weiter ... Wenn ich mir die erste Codezeile anschaue, muss ich, bevor ich zum Bearbeiten des Codes der <code>Request</code> Klasse zur√ºckkehren kann, das <code>Redux</code> Paket zum Projekt hinzuf√ºgen, mindestens einen <code></code> implementieren und diesen Reduzierer separat im <code>Store</code> verpacken.  Der erste Test wird wahrscheinlich f√ºr das Getriebe sein: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduce = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../src/reducers/user'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should return new state'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">Name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = reduce(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'USER'</span></span>, user }); expect(state).toEqual(user); });</code> </pre> <br><p>  Ich f√ºhre die Tests durch und stimme <code>Jasmine</code> dass zus√§tzlich zu allen vorherigen Fehlern ein Modul mit dem Namen <code>../../src/reducers/user</code> nicht gefunden wurde.  Deshalb werde ich es schreiben, zumal es verspricht, winzig und schrecklich vorhersehbar zu sein: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'USER'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action.user; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = user;</code> </pre> <br><p>  Ich f√ºhre Tests durch und sehe keine radikalen Verbesserungen.  Dies liegt daran, dass ich das Modul <code>../../src/store</code> , dessen Existenz ich im Test f√ºr meine <code>Request</code> Klasse angenommen habe, noch nicht implementiert habe.  Und es gibt auch noch keinen Test f√ºr ihn.  Ich werde nat√ºrlich mit dem Test beginnen: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'store'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/store'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should reduce USER'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">Name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span> }; store.dispatch({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'USER'</span></span>, user }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = store.getState(); expect(state.user).toEqual(user); }); });</code> </pre> <br><p>  Tests?  Es gibt weitere Berichte √ºber das Fehlen des <code>store</code> , daher werde ich mich sofort darum k√ºmmern. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createStore = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).createStore; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combineReducers = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).combineReducers; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./reducers/user'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = combineReducers({user}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducers); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = store;</code> </pre> <br><p>  Da ich wei√ü, dass ich mehr als ein Getriebe haben werde, bin ich bei der Implementierung des <code></code> ein wenig voraus und verwende beim <code>combineReducers</code> Methode <code>combineReducers</code> .  Ich f√ºhre die Tests erneut aus und sehe eine neue Fehlermeldung, die mich dar√ºber <code>execute</code> , dass die <code>execute</code> meiner <code>Request</code> Klasse nicht wie in meinem Test vorgeschlagen funktioniert.  Aufgrund der Ausf√ºhrungsmethode wird der Benutzerdatensatz nicht im <code></code> .  Es ist Zeit, die <code>Request</code> Klasse <code>Request</code> . </p><br><p>  Ich erinnere mich, wie jetzt der Test der <code>execute</code> aussieht: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should dispatch action if record exists'</span></span>, () =&gt; { request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = store.getState().user; expect(user.Id).toEqual(options.query.Id); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Und ich werde den Code der Methode selbst korrigieren, damit der Test ausgef√ºhrt werden kann: </p><br><pre> <code class="javascript hljs">execute(callback){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.tableName }); table.where(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.query).fetch().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'USER'</span></span>, <span class="hljs-attr"><span class="hljs-attr">user</span></span>: item }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) callback(); }); }</code> </pre> <br><p>  Ich tippe die <code>npm test</code> und ... Bingo!  Meine Anfrage lernte nicht nur, Daten aus der Datenbank zu empfangen, sondern sie auch im <code> </code> zuk√ºnftigen Verarbeitungsprozesses zu speichern, damit nachfolgende Vorg√§nge diese Daten problemlos empfangen k√∂nnen. </p><br><p>  Aber!  Mein Handler kann nur eine Art von Aktion in den <code> </code> , was seine Funktionen stark einschr√§nkt.  Ich m√∂chte diesen Code wiederholt verwenden, wenn ich einen Datensatz aus der Datenbank extrahieren und zur weiteren Verarbeitung unter dem von mir ben√∂tigten Schl√ºssel an die Statuscontainerzelle senden muss.  Und so fange ich wieder an, den Test umzugestalten: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">Id</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }, success (result, store) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'USER'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { type , <span class="hljs-attr"><span class="hljs-attr">user</span></span>: result }; store.dispatch(action); } }; it(<span class="hljs-string"><span class="hljs-string">'should dispatch action if record exists'</span></span>, () =&gt; { request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = store.getState().user; expect(user.Id).toEqual(options.query.Id); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Mir kam der Gedanke, dass es sch√∂n w√§re, die <code>Request</code> Klasse vor ungew√∂hnlichen Funktionen f√ºr die Verarbeitung von Abfrageergebnissen zu sch√ºtzen.  Semantisch <code>Request</code> ist eine Anfrage.  Erf√ºllte die Anfrage, erhielt die Antwort, die Aufgabe ist erledigt, der Grundsatz der alleinigen Verantwortung der Klasse wird respektiert.  Und lassen Sie jemanden, der speziell in diesem Prozess geschult ist, mit den Ergebnissen umgehen, dessen alleinige Verantwortung eine bestimmte Version der Verarbeitung selbst sein soll.  Aus diesem Grund habe ich beschlossen, die <code>success</code> auf die Anforderungseinstellungen zu √ºbertragen. Dies ist die Aufgabe, die von der Anforderung erfolgreich zur√ºckgegebenen Daten zu verarbeiten. </p><br><p>  Tests, jetzt k√∂nnen Sie nicht ausf√ºhren.  Ich verstehe das intellektuell.  Ich habe nichts im Test selbst behoben und nichts an der Implementierung ge√§ndert, und die Tests sollten weiterhin erfolgreich ausgef√ºhrt werden.  Aber emotional muss ich den Befehl <code>npm test</code> ausf√ºhren und ihn <code>execute</code> <code>store.dispatch(...)</code> bearbeite ich die Implementierung meiner Methode <code>store.dispatch(...)</code> in der <code>Request</code> Klasse, um die Zeile durch den Aufruf von <code>store.dispatch(...)</code> durch die Zeile mit dem Aufruf von <code>this.options.success(...)</code> zu <code>this.options.success(...)</code> : </p><br><pre> <code class="javascript hljs">execute(callback){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.tableName }); table.where(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.query).fetch().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.success(item, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) callback(); }); }</code> </pre> <br><p>  Ich f√ºhre Tests durch.  Voila!  Tests sind komplett gr√ºn.  Das Leben wird besser!  Was weiter?  Ich sehe sofort, dass Sie den Titel des Tests √§ndern m√ºssen, da dies nicht ganz richtig ist.  Der Test √ºberpr√ºft nicht, ob das Versenden der Methode als Ergebnis der Anforderung erfolgt, sondern ob die Abfrage den Status im Container aktualisiert.  Deshalb √§ndere ich den Titel des Tests in ... nun, zum Beispiel: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should update store user state if record exists'</span></span>, () =&gt; { request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = store.getState().user; expect(user.Id).toEqual(options.query.Id); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Was weiter?  Und dann denke ich, es ist Zeit, nicht darauf zu achten, dass meine Anfrage anstelle der angeforderten Daten einen Fehler zur√ºckgibt.  Dies ist kein so unm√∂gliches Szenario.  Richtig?  Und die Hauptsache ist, dass ich in diesem Fall nicht in der Lage bin, den erforderlichen Datensatz vorzubereiten und an meinen KYC-Operator zu senden, um die Integration zu erm√∂glichen, mit der ich den gesamten Code schreibe.  Ist das so  Also  Zuerst schreibe ich einen Test: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should add item to store error state'</span></span>, () =&gt; { options.query = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">555</span></span> }; options.error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, store</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { type, error }; store.dispatch(action); }; request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = store.getState().error; expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(error)).toBeTruthy(); expect(error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(error[<span class="hljs-number"><span class="hljs-number">0</span></span>].message).toEqual(<span class="hljs-string"><span class="hljs-string">'Something goes wrong!'</span></span>); }); });</code> </pre> <br><p>  Ich wei√ü nicht, ob die Struktur des Tests zeigt, dass ich Zeit und Geld gespart und ein Minimum an Code geschrieben habe, um zu √ºberpr√ºfen, ob die Anforderung einen Fehler zur√ºckgibt.  Nein gesehen? </p><br><p>  Ich m√∂chte keine Zeit damit verschwenden, zus√§tzliche Implementierungen von <code>TableMock</code> , die Fehler imitieren.  Ich entschied, dass im Moment ein paar bedingte Konstrukte in der vorhandenen Implementierung f√ºr mich v√∂llig ausreichen w√ºrden, und schlug vor, dass dies durch Abfrage- <code>query</code> angepasst <code>query</code> kann.  Meine Annahmen sind also: </p><br><ul><li>  Wenn die <code>options.query</code> in der Abfrage <code>options.query</code> <strong>1 ist</strong> , gibt meine <code>options.query</code> immer das zul√§ssige <code>Promise</code> mit dem allerersten Datensatz aus der Sammlung zur√ºck. </li><li>  Wenn die <code>options.query</code> in der Abfrage <code>options.query</code> <strong>555</strong> lautet, gibt meine <code>options.query</code> immer ein abgelehntes <code>Promise</code> mit einer darin enthaltenen <code>Error</code> , deren <code>message</code> <strong>Etwas geht schief"</strong> lautet.  . </li></ul><br><p>  Das ist nat√ºrlich alles andere als ideal.  Es w√§re f√ºr die Wahrnehmung viel lesbarer und bequemer, die entsprechenden <code>DbMock</code> Instanzen zu implementieren, beispielsweise <code>HealthyDbMock</code> , <code>FaultyDbMock</code> , <code>EmptyDbMock</code> .  Aus den Namen, aus denen sofort hervorgeht, dass der erste immer korrekt funktioniert, der zweite immer falsch, und beim dritten k√∂nnen wir davon ausgehen, dass anstelle des Ergebnisses immer <code>null</code> .  Nachdem ich meine ersten Annahmen auf die oben genannte Weise √ºberpr√ºft habe, dass es meiner Meinung nach ein Minimum an Zeit in Anspruch nimmt, werde ich m√∂glicherweise zwei zus√§tzliche Instanzen von <code>DbMock</code> , die <em>ungesundes</em> Verhalten simulieren. </p><br><p>  Ich f√ºhre Tests durch.  Ich erhalte den erwarteten Fehler des Fehlens der Eigenschaft, die ich im <code> </code> ben√∂tige, und ... ich schreibe einen weiteren Test.  Diesmal f√ºr ein Getriebe, das Aktionen vom Typ <code>ERROR</code> . </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduce = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../src/reducers/error'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should add error to state array'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Oooops!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = reduce(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, { type, error }); expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(state)).toBeTruthy(); expect(state.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(state.includes(error)).toBeTruthy(); }); });</code> </pre> <br><p>  F√ºhren Sie die Tests erneut aus.  Alles wird erwartet, ein weiterer wurde zu den vorhandenen Fehlern hinzugef√ºgt.  Ich erkenne das <code></code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = [], action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.concat([action.error]); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = error;</code> </pre> <br><p>  Ich f√ºhre erneut Tests durch.  Der neue Reduzierer funktioniert wie erwartet, aber ich muss immer noch sicherstellen, dass er eine Verbindung zum Repository herstellt und die Aktionen verarbeitet, f√ºr die er vorgesehen ist.  Daher schreibe ich einen zus√§tzlichen Test f√ºr die vorhandene Speichertestsuite: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should reduce error'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Oooops!'</span></span>); store.dispatch({ type, error }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = store.getState(); expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(state.error)).toBeTruthy(); expect(state.error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(state.error.includes(error)).toBeTruthy(); });</code> </pre> <br><p>  Ich f√ºhre Tests durch.  Alles wird erwartet.  Eine Aktion vom Typ <code>ERROR</code> verarbeitet den vorhandenen Speicher nicht.  √Ñndern des vorhandenen Repository-Initialisierungscodes: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createStore = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).createStore; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combineReducers = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).combineReducers; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./reducers/user'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./reducers/error'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = combineReducers({ error, user }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducers); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = store;</code> </pre> <br><p>  Zum hundertsten Mal warf er ein Netz ... Sehr gut!  Das Repository sammelt jetzt empfangene Fehlermeldungen in einer separaten Containereigenschaft. </p><br><p>  Jetzt werde ich einige bedingte Konstrukte in die vorhandene <code>TableMock</code> Implementierung <code>TableMock</code> und ihr <code>TableMock</code> , einige Abfragen auf diese Weise zu starten und einen Fehler zur√ºckzugeben.  Der aktualisierte Code sieht folgenderma√üen aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(array){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container = array; } where(query){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.query = query; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } fetch(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.query.Id === <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.query.Id === <span class="hljs-number"><span class="hljs-number">555</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Something goes wrong!'</span></span>)); }); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = TableMock;</code> </pre> <br><p>  Ich f√ºhre die Tests aus und erhalte eine Nachricht √ºber die nicht behandelte Ablehnung von <code>Promise</code> in der execute-Methode der <code>Request</code> Klasse.  Ich f√ºge den fehlenden Code hinzu: </p><br><pre> <code class="javascript hljs">execute(callback){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.tableName }); table.where(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.query).fetch().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.success(item, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) callback(); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.error(error, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) callback(); }); }</code> </pre> <br><p>  Und ich f√ºhre die Tests erneut durch.  Und ???  Es gibt tats√§chlich keinen Test f√ºr die <code>execute</code> der <code>Request</code> Klasse, diesen: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should add item to store error state'</span></span>, () =&gt; { options.query = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">555</span></span> }; options.error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, store</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { type, error }; store.dispatch(action); }; request.configure(options); request.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = store.getState().error; expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(error)).toBeTruthy(); expect(error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(error[<span class="hljs-number"><span class="hljs-number">0</span></span>].message).toEqual(<span class="hljs-string"><span class="hljs-string">'Something goes wrong!'</span></span>); }); });</code> </pre> <br><p>  Er hat erfolgreich abgeschlossen.  Daher kann die Abfragefunktionalit√§t in Bezug auf die Fehlerbehandlung als implementiert betrachtet werden.  Ein weiterer Test fiel, der das Repository auf Fehlerbehandlung √ºberpr√ºft.  Das Problem ist, dass mein Speicherimplementierungsmodul in allen Tests allen Verbrauchern dieselbe statische Speicherinstanz zur√ºckgibt.  In dieser Hinsicht besteht die √úberpr√ºfung der Anzahl von Fehlern in dem Beh√§lter nicht notwendigerweise, da der Versand von Fehlern bereits in zwei Tests erfolgt.  Da zum Zeitpunkt des Teststarts bereits ein Fehler im Container vorhanden ist und dort w√§hrend des Teststarts ein weiterer Fehler hinzugef√ºgt wird.  Also hier ist dieser Code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = store.getState().error; expect(error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  L√∂st eine Ausnahme aus und meldet, dass der Ausdruck <code>error.length</code> tats√§chlich 2 und nicht 1 ist. Dieses Problem werde ich jetzt einfach l√∂sen, indem ich den Speicherinitialisierungscode direkt in den Speichertestinitialisierungscode √ºbertrage: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'store'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createStore = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).createStore; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combineReducers = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redux'</span></span>).combineReducers; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/reducers/user'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../src/reducers/error'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducers = combineReducers({ error, user }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = createStore(reducers); it(<span class="hljs-string"><span class="hljs-string">'should reduce USER'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">Name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span> }; store.dispatch({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'USER'</span></span>, user }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = store.getState(); expect(state.user).toEqual(user); }); it(<span class="hljs-string"><span class="hljs-string">'should reduce error'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> type = <span class="hljs-string"><span class="hljs-string">'ERROR'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Oooops!'</span></span>); store.dispatch({ type, error }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = store.getState(); expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(state.error)).toBeTruthy(); expect(state.error.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(state.error.includes(error)).toBeTruthy(); }); });</code> </pre> <br><p>  Der Initialisierungscode f√ºr den Test sieht jetzt etwas geschwollen aus, aber ich kann sp√§ter zu seinem Refactoring zur√ºckkehren. </p><br><p>  Ich f√ºhre Tests durch.  Voila!  Alle Tests wurden abgeschlossen und Sie k√∂nnen eine Pause machen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436348/">https://habr.com/ru/post/de436348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436338/index.html">Wie funktioniert der Flughafen Vnukovo?</a></li>
<li><a href="../de436340/index.html">Separate Protokollierungsstufe f√ºr jede Anforderung</a></li>
<li><a href="../de436342/index.html">Eine Einf√ºhrung in die robuste Optimierung [... und eine kleine Einkaufsliste, die ich vergessen habe ...]</a></li>
<li><a href="../de436344/index.html">Fibaro Home Center 2 und Thermostat f√ºr Fu√übodenheizung HeatIt. Wie man die Temperatur erh√∂ht</a></li>
<li><a href="../de436346/index.html">Ben√∂tigen Sie immer Docker, Microservices und reaktive Programmierung?</a></li>
<li><a href="../de436350/index.html">Lernen Sie kontroverse Taktiken, Techniken und allgemeines Wissen (ATT @ CK). Unternehmenstaktik. Teil 7</a></li>
<li><a href="../de436352/index.html">PostgreSQL News Digest. Ausgabe Nr. 14</a></li>
<li><a href="../de436354/index.html">Das US-Milit√§r vernachl√§ssigt Fragen der Cybersicherheit</a></li>
<li><a href="../de436356/index.html">[Interessant hinter dem H√ºgel] Wie stoppen wir die technologische Abh√§ngigkeit?</a></li>
<li><a href="../de436358/index.html">Warum unterrichten √§ltere Entwickler Sch√ºler?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>