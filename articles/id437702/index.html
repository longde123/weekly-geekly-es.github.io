<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👝 ⛰️ 🙅🏻 Parsing Wawancara Kerja Google: Pertanyaan Sinonim 😙 🛃 🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah artikel baru dari diskusi tugas dari wawancara di Google . Ketika saya bekerja di sana, saya menawarkan para kandidat tugas semacam itu. La...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parsing Wawancara Kerja Google: Pertanyaan Sinonim</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/467/e92/ec4467e926275a35882c2a8848097877.png" width="530"></div><br><br>  Ini adalah artikel baru dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi tugas dari wawancara di Google</a> .  Ketika saya bekerja di sana, saya menawarkan para kandidat tugas semacam itu.  Lalu ada kebocoran, dan mereka dilarang.  Tetapi koin memiliki sisi lain: sekarang saya dapat dengan bebas menjelaskan solusinya. <br><a name="habracut"></a><br>  Berita bagus untuk memulai: Saya keluar dari Google!  Saya senang memberi tahu Anda bahwa saya sekarang bekerja sebagai manajer teknis Reddit di New York!  Namun seri artikel ini masih akan dilanjutkan. <br><br>  <i>Penafian: Meskipun mewawancarai kandidat adalah salah satu tugas profesional saya, di blog ini saya berbagi pengamatan pribadi, cerita, dan pendapat pribadi.</i>  <i>Harap jangan menganggap ini sebagai pernyataan resmi dari Google, Alfabet, Reddit, orang atau organisasi lain.</i> <br><br><h1>  Pertanyaan </h1><br>  Setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir</a> tentang kemajuan kuda dalam memanggil nomor telepon, saya menerima kritik bahwa ini bukan masalah yang realistis.  Mungkin berguna untuk mempelajari keterampilan berpikir kandidat, tetapi harus saya akui: tugasnya sedikit tidak realistis.  Meskipun saya memiliki beberapa pemikiran tentang korelasi antara pertanyaan wawancara dan kenyataan, saya akan menyerahkannya kepada saya untuk saat ini.  Pastikan, saya membaca komentar di mana-mana dan saya punya sesuatu untuk dijawab, tetapi tidak sekarang. <br><br>  Tetapi ketika tugas mengoper kuda itu dilarang beberapa tahun yang lalu, saya mengambil hati kritik dan mencoba menggantinya dengan pertanyaan yang sedikit lebih relevan dengan ruang lingkup Google.  Dan apa yang bisa lebih relevan untuk Google daripada mekanisme permintaan pencarian?  Jadi saya menemukan pertanyaan ini dan menggunakannya untuk waktu yang lama sebelum juga dipublikasikan dan dilarang.  Seperti sebelumnya, saya akan merumuskan pertanyaan, menyelami penjelasannya, dan kemudian saya akan mengatakan bagaimana saya menggunakannya dalam wawancara dan mengapa saya menyukainya. <br><br>  Jadi pertanyaannya adalah. <br><br>  Bayangkan Anda mengelola mesin pencari populer dan melihat dua permintaan di log: katakanlah, "peringkat persetujuan Obama" dan "tingkat popularitas Obama" (jika saya ingat dengan benar, ini adalah contoh nyata dari basis pertanyaan, meskipun sekarang sedikit ketinggalan jaman ...) .  Kami melihat kueri yang berbeda, tetapi semua orang akan setuju: pengguna pada dasarnya mencari informasi yang sama, jadi kueri harus dianggap setara ketika menghitung jumlah kueri, menampilkan hasil, dll. <b>Bagaimana Anda menentukan apakah dua kueri itu sama?</b> <br><br>  Mari memformalkan tugas.  Misalkan ada dua set pasangan string: pasangan sinonim dan pasangan kueri. <br><br>  Secara khusus, berikut adalah contoh input untuk menggambarkan: <br><br><pre><code class="python hljs">SYNONYMS = [ (<span class="hljs-string"><span class="hljs-string">'rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'approval'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity'</span></span>), ] QUERIES = [ (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rates'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity ratings obama'</span></span>) ]</code> </pre> <br>  Hal ini diperlukan untuk menghasilkan daftar nilai-nilai logis: apakah permintaan di setiap pasangan identik. <br><br><h1>  Semua pertanyaan baru ... </h1><br>  Sepintas, ini adalah tugas sederhana.  Tetapi semakin lama Anda berpikir, semakin sulit jadinya.  Bisakah sebuah kata memiliki beberapa sinonim?  Apakah urutan kata itu penting?  Apakah hubungan sinonim transitif, yaitu, jika A identik dengan B dan B identik dengan C, apakah A sinonim untuk C?  Dapatkah sinonim menjangkau beberapa kata, bagaimana "AS" menjadi sinonim untuk frasa "Amerika Serikat" atau "Amerika Serikat"? <br><br>  Ambiguitas semacam itu segera memungkinkan untuk membuktikan diri kepada kandidat yang baik.  Hal pertama yang dia lakukan adalah mencari ambiguitas seperti itu dan mencoba menyelesaikannya.  Semua orang melakukan ini dengan cara yang berbeda: beberapa mendekati papan tulis dan mencoba menyelesaikan kasus-kasus tertentu secara manual, sementara yang lain melihat pertanyaan dan segera melihat celahnya.  Bagaimanapun, mengidentifikasi masalah-masalah ini pada tahap awal sangat penting. <br><br>  Fase "memahami masalah" sangat penting.  Saya suka menyebut rekayasa perangkat lunak disiplin fraktal.  Seperti halnya fraktal, aproksimasi mengungkapkan kompleksitas tambahan.  Anda pikir Anda memahami masalahnya, kemudian melihat lebih dekat - dan Anda melihat bahwa Anda melewatkan beberapa kehalusan atau detail implementasi yang dapat ditingkatkan.  Atau pendekatan yang berbeda untuk masalah tersebut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/53b/e5a/ee253be5a2b504b310dea6050559bcba.gif"><br>  <i><font color="gray">Set mandelbrot</font></i> <br><br>  <b>Kaliber seorang insinyur sangat ditentukan oleh seberapa dalam dia bisa memahami masalahnya.</b>  Mengubah pernyataan masalah yang tidak jelas menjadi serangkaian persyaratan yang terperinci adalah langkah pertama dalam proses ini, dan pernyataan yang disengaja memungkinkan Anda untuk mengevaluasi seberapa baik kandidat tersebut cocok dengan situasi baru. <br><br>  <i>Kami mengesampingkan pertanyaan sepele, seperti "Apakah huruf besar penting?" Itu tidak mempengaruhi algoritma utama.</i>  <i>Saya selalu memberikan jawaban paling sederhana untuk pertanyaan-pertanyaan ini (dalam hal ini, "Asumsikan bahwa semua huruf sudah diproses sebelumnya dan dikonversi ke huruf kecil")</i> <br><br><h1>  Bagian 1. (Tidak cukup) kasus sederhana </h1><br>  Jika kandidat mengajukan pertanyaan, saya selalu memulai dengan kasus paling sederhana: sebuah kata dapat memiliki beberapa sinonim, masalah urutan kata, sinonim tidak transitif.  Ini memberikan fungsi mesin pencari sangat terbatas, tetapi memiliki cukup kehalusan untuk wawancara yang menarik. <br><br>  Ikhtisar tingkat tinggi adalah sebagai berikut: pisahkan kueri menjadi kata-kata (misalnya, berdasarkan spasi) dan bandingkan pasangan yang sesuai untuk mencari kata dan sinonim yang identik.  Secara visual, tampilannya seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a65/908/7c1a6590877f4632beffa60d8cbb0afa.png"><br><br>  Dalam kode: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> words_are_synonyms(w1, w2): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Mudah kan?  Secara algoritma, ini cukup sederhana.  Tidak ada pemrograman dinamis, rekursi, struktur kompleks, dll. Manipulasi sederhana dari perpustakaan standar dan algoritma yang bekerja dalam waktu linier, bukan? <br><br>  Tapi ada lebih banyak nuansa daripada yang terlihat pada pandangan pertama.  Tentu saja, komponen yang paling sulit adalah perbandingan sinonim.  Meskipun komponennya mudah dipahami dan dijelaskan, ada banyak cara untuk membuat kesalahan.  Saya akan memberi tahu Anda tentang kesalahan paling umum. <br><br>  Untuk kejelasan: tidak ada kesalahan akan mendiskualifikasi kandidat;  jika itu, saya hanya menunjukkan kesalahan dalam implementasi, itu diperbaiki, dan kami melanjutkan.  Namun, wawancara adalah, pertama-tama, perjuangan melawan waktu.  Anda akan membuat, memperhatikan, dan memperbaiki kesalahan, tetapi butuh waktu yang dapat dihabiskan untuk yang lain, misalnya, untuk membuat solusi yang lebih optimal.  Hampir semua orang membuat kesalahan, ini normal, tetapi kandidat yang membuatnya lebih kecil menunjukkan hasil yang lebih baik hanya karena mereka menghabiskan lebih sedikit waktu untuk memperbaikinya. <br><br>  Itu sebabnya saya suka masalah ini.  Jika langkah seorang ksatria membutuhkan wawasan ke dalam pemahaman algoritma, dan kemudian (saya harap) implementasi sederhana, maka solusinya di sini adalah banyak langkah ke arah yang benar.  Setiap langkah mewakili rintangan kecil yang melaluinya sang kandidat dapat dengan anggun melompati atau tersandung dan bangkit.  Berkat pengalaman dan intuisi, kandidat yang baik menghindari jebakan kecil ini - dan mendapatkan solusi yang lebih rinci dan benar, sementara yang lebih lemah menghabiskan waktu dan energi untuk kesalahan dan biasanya tetap dengan kode yang salah. <br><br>  Pada setiap wawancara, saya melihat kombinasi keberhasilan dan kegagalan yang berbeda, ini adalah kesalahan yang paling umum. <br><br><h4>  Pembunuh Kinerja Acak </h4><br>  Pertama, beberapa kandidat telah menerapkan deteksi sinonim hanya dengan menelusuri daftar sinonim: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w1, w2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> ...</code> </pre> <br>  Sekilas, ini masuk akal.  Tetapi setelah diperiksa lebih dekat, idenya sangat, sangat buruk.  Bagi Anda yang tidak mengenal Python, kata kunci in adalah gula sintaksis untuk metode <i>berisi</i> dan berfungsi pada semua kontainer Python standar.  Ini adalah masalah karena <code>synonym_words</code> adalah daftar yang mengimplementasikan kata kunci in menggunakan pencarian linear.  Pengguna Python sangat sensitif terhadap kesalahan ini karena bahasa menyembunyikan tipe, tetapi pengguna C ++ dan Java juga terkadang membuat kesalahan serupa. <br><br>  Sepanjang karier saya, saya hanya menulis beberapa kali dengan kode pencarian linier, dan masing-masing dalam daftar tidak lebih dari dua lusin elemen.  Dan bahkan dalam kasus ini, ia menulis komentar panjang yang menjelaskan mengapa ia memilih pendekatan yang tampaknya kurang optimal.  Saya menduga bahwa beberapa kandidat menggunakannya hanya karena mereka tidak tahu bagaimana kata kunci in bekerja dalam daftar di pustaka standar Python.  Ini adalah kesalahan sederhana, tidak fatal, tetapi kenalan yang buruk dengan bahasa favorit Anda tidak terlalu baik. <br><br>  Dalam praktiknya, kesalahan ini mudah dihindari.  Pertama, jangan pernah lupa tipe objek Anda, bahkan jika Anda menggunakan bahasa yang tidak diketik seperti Python!  Kedua, ingatlah bahwa ketika Anda menggunakan kata kunci <i>in</i> dalam daftar, pencarian linear dimulai.  Jika tidak ada jaminan bahwa daftar ini akan selalu sangat kecil, itu akan mematikan kinerja. <br><br>  Agar kandidat sadar, biasanya cukup untuk mengingatkannya bahwa struktur input adalah daftar.  Sangat penting untuk mengamati bagaimana kandidat merespons permintaan tersebut.  Kandidat terbaik segera mencoba untuk entah bagaimana pra-proses sinonim, yang merupakan awal yang baik.  Namun, pendekatan ini bukannya tanpa perangkap ... <br><br><h4>  Gunakan struktur data yang benar </h4><br>  Dari kode di atas, segera jelas bahwa untuk mengimplementasikan algoritma ini dalam waktu linier, perlu untuk segera menemukan sinonim.  Dan ketika kita berbicara tentang pencarian cepat, selalu ada peta atau array hash. <br><br>  Bagi saya tidak masalah apakah kandidat memilih peta atau array hash.  Yang penting adalah bahwa ia akan meletakkannya di sana (omong-omong, jangan pernah menggunakan dict / hashmap dengan transisi ke <code>True</code> atau <code>False</code> ).  Kebanyakan kandidat memilih semacam dict / hashmap.  Kesalahan paling umum adalah asumsi bawah sadar bahwa setiap kata tidak memiliki lebih dari satu sinonim: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1] = w2 ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> synonyms[w1] == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Saya tidak menghukum kandidat karena kesalahan ini.  Tugas ini dirumuskan secara khusus agar tidak berfokus pada kenyataan bahwa kata-kata dapat memiliki beberapa sinonim, dan beberapa kandidat tidak menghadapi situasi seperti itu.  Paling cepat memperbaiki bug ketika saya menunjuk ke sana.  Kandidat yang baik memperhatikannya pada tahap awal dan biasanya tidak menghabiskan banyak waktu. <br><br>  Masalah yang sedikit lebih serius adalah kurangnya kesadaran bahwa hubungan sinonim menyebar ke dua arah.  Perhatikan bahwa dalam kode di atas ini diperhitungkan.  Tetapi ada implementasi dengan kesalahan: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) synonyms[w2].append(w1) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Mengapa dua menyisipkan dan menggunakan memori dua kali lebih banyak? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w2, tuple())): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Kesimpulan: <i>selalu pikirkan bagaimana mengoptimalkan kode</i> !  Dalam retrospeksi, permutasi fungsi pencarian adalah optimasi yang jelas, jika tidak kita dapat menyimpulkan bahwa kandidat tidak memikirkan opsi optimasi.  Sekali lagi, saya senang memberikan petunjuk, tetapi lebih baik menebaknya sendiri. <br><br><h1>  Sortir? </h1><br>  Beberapa kandidat cerdas ingin mengurutkan daftar sinonim dan kemudian menggunakan pencarian biner.  Sebenarnya, pendekatan ini memiliki keuntungan penting: tidak memerlukan ruang tambahan, kecuali untuk daftar sinonim (asalkan daftar tersebut boleh diubah). <br><br>  Sayangnya, kompleksitas waktu mengganggu: menyortir daftar sinonim membutuhkan waktu <code>Nlog(N)</code> , dan kemudian <code>log(N)</code> lain <code>log(N)</code> untuk mencari setiap pasangan sinonim, sedangkan solusi preprocessing yang dijelaskan terjadi dalam waktu linier dan kemudian konstan.  Selain itu, saya secara kategoris menentang memaksa kandidat untuk menerapkan pengurutan dan pencarian biner di papan tulis, karena: 1) algoritma pengurutan dikenal, oleh karena itu, sejauh yang saya tahu, kandidat dapat mengeluarkannya tanpa berpikir;  2) algoritma ini sangat sulit untuk diimplementasikan dengan benar, dan seringkali bahkan kandidat terbaik akan membuat kesalahan yang tidak mengatakan apa-apa tentang keterampilan pemrograman mereka. <br><br>  Setiap kali seorang kandidat mengusulkan solusi seperti itu, saya tertarik pada waktu pelaksanaan program dan bertanya apakah ada opsi yang lebih baik.  Sebagai informasi: jika pewawancara bertanya apakah ada opsi yang lebih baik, jawabannya hampir selalu ya.  Jika saya pernah mengajukan pertanyaan ini kepada Anda, jawabannya pasti akan seperti itu. <br><br><h4>  Akhirnya solusi </h4><br>  Pada akhirnya, kandidat menawarkan sesuatu yang benar dan cukup optimal.  Berikut ini adalah implementasi dalam waktu linear dan ruang linear untuk kondisi yang diberikan: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].add(w2) output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> ((w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2])): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Beberapa catatan singkat: <br><br><ul><li>  Perhatikan penggunaan <code>dict.get()</code> .  Anda bisa menerapkan pemeriksaan untuk melihat apakah kunci ada di dikt, dan kemudian mendapatkannya, tetapi ini adalah pendekatan yang rumit, meskipun dengan cara ini Anda akan menunjukkan pengetahuan Anda tentang perpustakaan standar. </li><li>  Saya pribadi bukan penggemar kode dengan sering <code>continue</code> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa panduan gaya melarang atau tidak merekomendasikan mereka</a> .  Saya sendiri di edisi pertama kode ini lupa <code>continue</code> pernyataan setelah memeriksa panjang permintaan.  Ini bukan pendekatan yang buruk, hanya tahu bahwa itu rawan kesalahan. </li></ul><br><h1>  Bagian 2: Semakin keras! </h1><br>  Kandidat yang baik, setelah menyelesaikan masalah, masih memiliki sepuluh hingga lima belas menit waktu tersisa.  Untungnya, ada banyak pertanyaan tambahan, meskipun tidak mungkin kita akan menulis banyak kode selama ini.  Namun, ini tidak perlu.  Saya ingin tahu dua hal tentang kandidat: apakah dia mampu mengembangkan algoritma dan apakah dia mampu membuat kode?  Masalah dengan langkah ksatria pertama menjawab pertanyaan tentang pengembangan algoritma, dan kemudian memeriksa kodenya, dan di sini kita mendapatkan jawaban dalam urutan terbalik. <br><br>  Pada saat kandidat menyelesaikan bagian pertama dari pertanyaan, ia telah menyelesaikan masalah dengan pengkodean (yang mengejutkan bukan-sepele).  Pada tahap ini, saya yakin dapat berbicara tentang kemampuannya untuk mengembangkan algoritma yang belum sempurna dan menerjemahkan ide ke dalam kode, serta kenalannya dengan bahasa favorit dan perpustakaan standar.  Sekarang percakapan menjadi jauh lebih menarik, karena persyaratan pemrograman bisa santai, dan kami akan menyelami algoritma. <br><br>  Untuk tujuan ini, kita kembali ke postulat utama dari bagian pertama: urutan kata itu penting, sinonim adalah non-transitif, dan untuk setiap kata ada beberapa sinonim.  Ketika wawancara berlangsung, saya mengubah masing-masing batasan ini, dan dalam fase baru ini, kandidat dan saya memiliki diskusi yang murni algoritmik.  Di sini saya akan memberikan contoh kode untuk mengilustrasikan sudut pandang saya, tetapi dalam wawancara nyata kita hanya berbicara tentang algoritma. <br><br>  Sebelum memulai, saya akan menjelaskan posisi saya: semua tindakan selanjutnya pada tahap wawancara ini terutama adalah "poin bonus".  Pendekatan pribadi saya adalah mengidentifikasi kandidat yang benar-benar melalui tahap pertama dan cocok untuk bekerja.  Tahap kedua diperlukan untuk menyoroti yang terbaik.  Peringkat pertama sudah sangat kuat dan berarti bahwa kandidat cukup baik untuk perusahaan, dan peringkat kedua mengatakan bahwa kandidat sangat baik dan perekrutannya akan menjadi kemenangan besar bagi kami. <br><br><h1>  Transitivitas: Pendekatan Naif </h1><br>  Pertama, saya ingin menghapus batasan transitivitas, jadi jika pasangan A - B dan B - C adalah sinonim, maka kata - kata A dan C juga sinonim.  Calon yang cerdas akan dengan cepat memahami bagaimana mengadaptasi solusi mereka sebelumnya, meskipun dengan penghapusan lebih lanjut dari pembatasan lain, logika dasar dari algoritma akan berhenti bekerja. <br><br>  Namun, bagaimana cara mengadaptasinya?  Salah satu pendekatan yang umum adalah mempertahankan satu set sinonim lengkap untuk setiap kata berdasarkan hubungan transitif.  Setiap kali kami memasukkan kata ke dalam serangkaian sinonim, kami juga menambahkannya ke set yang sesuai untuk semua kata di set ini: <br><br><pre> <code class="python hljs">synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]: synonyms[w].add(w2) synonyms[w1].add(w2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2]: synonyms[w].add(w1) synonyms[w2].add(w1)</code> </pre> <br>  <i><font color="gray">Harap perhatikan bahwa saat membuat kode, kami telah menyelidiki solusi ini.</font></i> <br><br>  Solusi ini berfungsi, tetapi jauh dari optimal.  Untuk memahami alasannya, kami memperkirakan kompleksitas spasial dari solusi ini.  Setiap sinonim harus ditambahkan tidak hanya pada himpunan kata awal, tetapi juga pada himpunan semua sinonimnya.  Jika ada satu sinonim, maka satu entri ditambahkan.  Tetapi jika kami memiliki 50 sinonim, Anda harus menambahkan 50 entri.  Pada gambar, terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/ab6/e25/e3fab6e25d14821ec06d623925db9ac5.png"></div><br><br>  Perhatikan bahwa kami beralih dari tiga kunci dan enam catatan menjadi empat kunci dan dua belas catatan.  Sebuah kata dengan 50 sinonim akan membutuhkan 50 kunci dan hampir 2500 entri.  Ruang yang diperlukan untuk mewakili satu kata tumbuh secara kuadratik dengan peningkatan set sinonim, yang agak boros. <br><br>  Ada solusi lain, tapi saya tidak akan terlalu dalam agar tidak mengembang artikel.  Yang paling menarik dari mereka adalah penggunaan struktur data sinonim untuk membangun grafik yang diarahkan, dan kemudian pencarian pertama untuk menemukan jalur antara dua kata.  Ini adalah solusi yang bagus, tetapi pencarian menjadi linier dalam ukuran set sinonim untuk kata tersebut.  Karena kami melakukan pencarian ini untuk setiap permintaan beberapa kali, pendekatan ini tidak optimal. <br><br><h1>  Transitivitas: Menggunakan Set Terpisah </h1><br>  Ternyata mencari sinonim adalah mungkin untuk waktu (hampir) konstan berkat struktur data yang disebut set disjoint.  Struktur ini menawarkan kemungkinan yang sedikit berbeda dari kumpulan data biasa. <br><br>  Struktur pengaturan yang biasa (hashset, treeset) adalah wadah yang memungkinkan Anda untuk dengan cepat menentukan apakah suatu benda di dalam atau di luarnya.  Disjoint set memecahkan masalah yang sama sekali berbeda: alih-alih mendefinisikan elemen tertentu, mereka memungkinkan Anda untuk menentukan <i>apakah dua elemen milik set yang sama</i> .  Selain itu, struktur melakukan ini untuk waktu yang sangat cepat <code>O(a(n))</code> , di mana <code>a(n)</code> adalah fungsi Ackerman terbalik.  Jika Anda belum mempelajari algoritme lanjutan, Anda mungkin tidak tahu fungsi ini, yang untuk semua input yang masuk akal sebenarnya dieksekusi dalam waktu yang konstan. <br><br>  Pada level tinggi, algoritme berfungsi sebagai berikut.  Set diwakili oleh pohon dengan orang tua untuk setiap elemen.  Karena setiap pohon memiliki root (elemen yang merupakan induknya sendiri), kita dapat menentukan apakah dua elemen milik set yang sama dengan melacak orang tua mereka ke root.  Jika dua elemen memiliki satu root, mereka milik satu set.  Menggabungkan set juga mudah: cukup temukan elemen root dan jadikan salah satu dari mereka root dari yang lain. <br><br>  Sejauh ini bagus, tapi sejauh ini tidak ada kecepatan menyilaukan yang terlihat.  Jenius struktur ini adalah dalam prosedur yang disebut <i>kompresi</i> .  Misalkan Anda memiliki pohon berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4b/132/102/e4b13210226d0375adc1acf7835ef4a2.png"></div><br><br>  Bayangkan Anda ingin tahu apakah <i>cepat</i> dan <i>tergesa</i> - <i>gesa</i> adalah sinonim.  Telusuri setiap orang tua - dan temukan root <i>cepat yang</i> sama.  Sekarang anggaplah kita melakukan pemeriksaan serupa untuk kata-kata <i>cepat</i> dan <i>cepat</i> .  Sekali lagi, kita naik ke root, dan dari <i>cepat</i> kita pergi ke rute yang sama.  Bisakah duplikasi pekerjaan dihindari? <br><br>  Ternyata kamu bisa.  Dalam arti tertentu, setiap elemen di pohon ini ditakdirkan untuk <i>berpuasa</i> .  Alih-alih melewati seluruh pohon setiap kali, mengapa tidak mengubah induk untuk semua keturunan <i>cepat</i> untuk mempersingkat rute ke root?  Proses ini disebut kompresi, dan dalam set yang terpisah ia tertanam dalam operasi pencarian root.  Misalnya, setelah operasi pertama yang membandingkan <i>speedy</i> dan <i>tergesa</i> - <i>gesa,</i> struktur akan memahami bahwa mereka adalah sinonim dan akan memampatkan pohon sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/381/3b9/2d43813b9925bf86d0e4b3a2c9a99707.png"></div><br>  <i><font color="gray">Untuk semua kata antara cepat dan cepat, orangtua diperbarui, hal yang sama terjadi dengan tergesa-gesa</font></i> <br><br>  Sekarang semua panggilan berikutnya akan terjadi dalam waktu yang konstan, karena setiap node di pohon ini menunjuk ke <i>cepat</i> .  Sangat tidak mudah untuk mengevaluasi kompleksitas waktu operasi: pada kenyataannya, itu tidak konstan, karena itu tergantung pada kedalaman pohon, tetapi dekat dengan konstan, karena struktur cepat dioptimalkan.  Untuk kesederhanaan, kami menganggap bahwa waktu adalah konstan. <br><br>  Dengan konsep ini, kami menerapkan perangkat yang tidak terkait untuk masalah kami: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisjointSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.parents = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w)</span></span></span><span class="hljs-function">:</span></span> words_traversed = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.parents[w] != w: words_traversed.append(w) w = self.parents[w] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words_traversed: self.parents[word] = w <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_synonyms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w1] = w1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w2] = w2 w1_root = self.get_root(w1) w2_root = self.get_root(w2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1_root &lt; w2_root: w1_root, w2_root = w2_root, w1_root self.parents[w2_root] = w1_root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">are_synonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_root(w1) == self.get_root(w2)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan menggunakan struktur ini, Anda dapat melakukan pra-proses sinonim dan menyelesaikan masalah dalam waktu linier. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peringkat dan catatan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada saat ini, kami telah mencapai batas yang dapat ditunjukkan oleh seorang kandidat dalam 40–45 menit wawancara. </font><font style="vertical-align: inherit;">Kepada semua kandidat yang mengatasi bagian pengantar dan membuat kemajuan signifikan dalam menggambarkan (tidak menerapkan) set yang tidak terkait, saya memberikan peringkat "Sangat Direkomendasikan untuk Dipekerjakan" dan memungkinkan mereka untuk mengajukan pertanyaan. </font><font style="vertical-align: inherit;">Saya belum pernah melihat seorang kandidat melangkah sejauh ini dan memiliki banyak waktu tersisa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada prinsipnya, masih ada varian masalah dengan transitivitas: misalnya, menghapus batasan pada urutan kata atau pada beberapa sinonim untuk sebuah kata. </font><font style="vertical-align: inherit;">Setiap keputusan akan sulit dan menyenangkan, tetapi saya akan meninggalkannya untuk nanti.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelebihan dari tugas ini adalah memungkinkan kandidat untuk melakukan kesalahan. </font><font style="vertical-align: inherit;">Pengembangan perangkat lunak harian terdiri dari siklus analisis, eksekusi, dan penyempurnaan yang tiada akhir. </font><font style="vertical-align: inherit;">Masalah ini memungkinkan bagi kandidat untuk menunjukkan kemampuan mereka di setiap tahap. </font><font style="vertical-align: inherit;">Pertimbangkan keterampilan yang dibutuhkan untuk mendapatkan skor maksimum pada ini:</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menganalisis pernyataan masalah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menentukan di mana tidak dirumuskan dengan jelas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kembangkan rumusan yang tidak ambigu. </font><font style="vertical-align: inherit;">Terus lakukan ini saat Anda menyelesaikan dan muncul pertanyaan baru. </font><font style="vertical-align: inherit;">Untuk efisiensi maksimum, lakukan operasi ini sedini mungkin, karena semakin jauh pekerjaan telah berjalan, semakin banyak waktu yang diperlukan untuk memperbaiki kesalahan.</font></font><br></li><li> <i> </i>  ,        .       ,         . <br></li><li> <i>  </i> .          ,    ,      . <br></li><li>  , <i>    </i> .     ,      <code>continue</code> ,   ,     . <br></li><li>    , <i>  :   ,   </i> ,    ,    . ,      ,       ,    . <br></li><li> <i>    </i> .   —    ,          .        —    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tak satu pun dari keterampilan ini dapat dipelajari dari buku teks (dengan kemungkinan pengecualian struktur data dan algoritma). </font><font style="vertical-align: inherit;">Satu-satunya cara untuk memperoleh ini adalah praktik rutin dan ekstensif, yang sesuai dengan apa yang dibutuhkan majikan: kandidat berpengalaman yang mampu menerapkan pengetahuan mereka secara efektif. </font><font style="vertical-align: inherit;">Maksud dari wawancara adalah menemukan orang-orang seperti itu, dan tugas dari artikel ini membantu saya dengan baik untuk waktu yang lama.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rencana masa depan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang bisa Anda pahami, tugas itu akhirnya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diketahui publik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sejak itu, saya telah menggunakan beberapa pertanyaan lain, tergantung pada apa yang ditanyakan pewawancara sebelumnya dan pada suasana hati saya (menanyakan satu pertanyaan membosankan sepanjang waktu). Saya masih menggunakan beberapa pertanyaan, jadi saya akan merahasiakannya, tetapi ada yang tidak! Anda dapat menemukannya di artikel berikut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam waktu dekat saya merencanakan dua artikel. Pertama, seperti yang dijanjikan di atas, saya akan menjelaskan solusi untuk dua masalah yang tersisa untuk tugas ini. Saya tidak pernah meminta mereka saat wawancara, tetapi mereka menarik dalam diri mereka sendiri. Selain itu, saya akan membagikan pemikiran dan pendapat pribadi saya tentang prosedur untuk menemukan karyawan di bidang TI, yang sangat menarik bagi saya sekarang, karena saya sedang mencari insinyur untuk tim saya di Reddit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti biasa, jika Anda ingin tahu tentang rilis artikel baru, ikuti saya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika Anda menyukai artikel ini, jangan lupa untuk memilih atau memberikan komentar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih sudah membaca! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: Anda dapat memeriksa kode semua artikel di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam GitHub repositori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bermain dengan mereka hidup</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berkat teman baik saya dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repl.it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437702/">https://habr.com/ru/post/id437702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437686/index.html">Learning go: menulis messenger p2p dengan enkripsi ujung ke ujung</a></li>
<li><a href="../id437688/index.html">OpenSceneGraph: Teknik Pemrograman Dasar</a></li>
<li><a href="../id437694/index.html">Analisis utilitas Files.walkFileTree ();</a></li>
<li><a href="../id437696/index.html">Intisari materi menarik untuk pengembang seluler # 283 (pada 21 - 27 Januari)</a></li>
<li><a href="../id437698/index.html">Layanan terjemahan paten WIPO Translate - pengalaman saya</a></li>
<li><a href="../id437704/index.html">Pengetahuan yang sangat baik tentang kurikulum sekolah sebagai indikator bukan kecerdasan tertinggi</a></li>
<li><a href="../id437706/index.html">Tahun dengan Tesla</a></li>
<li><a href="../id437710/index.html">Membatasi hak pengguna lokal di Linux seminimal mungkin</a></li>
<li><a href="../id437712/index.html">Stasiun Luar Angkasa Roskomnadzor</a></li>
<li><a href="../id437714/index.html">Kami menggambar ledakan kartun untuk 180 garis telanjang C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>