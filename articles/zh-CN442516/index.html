<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 🧑🏾‍🤝‍🧑🏻 🤴🏿 熊猫大数据分析指南 👩‍🎨 🆕 🛄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当使用pandas库分析大小不超过100 MB的小型数据集时，性能很少会成为问题。 但是，当研究数据集的大小可能达到数GB时，性能问题可能导致数据分析的持续时间显着增加，甚至由于内存不足而导致无法进行分析。 

 尽管Spark之类的工具可以有效地处理大型数据集（从数百GB到几TB），但是为了充分利...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>熊猫大数据分析指南</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/">当使用pandas库分析大小不超过100 MB的小型数据集时，性能很少会成为问题。 但是，当研究数据集的大小可能达到数GB时，性能问题可能导致数据分析的持续时间显着增加，甚至由于内存不足而导致无法进行分析。 <br><br> 尽管Spark之类的工具可以有效地处理大型数据集（从数百GB到几TB），但是为了充分利用它们的功能，您通常需要功能强大且昂贵的硬件。 而且，与大熊猫相比，它们在丰富的工具集（用于高质量清洁，研究和数据分析）方面没有差异。 对于中型数据集，最好尝试更有效地使用熊猫，而不是切换到其他工具。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br> 在今天要翻译的材料中，我们将讨论使用熊猫时使用内存的功能，以及如何通过简单地选择存储在<code>DataFrame</code>的表数据结构的列中的适当数据类型来简单地将内存消耗减少近90％。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">处理棒球比赛数据</font> </h2><br> 我们将使用130年来从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Retrosheet</a>收集的有关美国职棒大联盟的比赛数据。 <br><br> 最初，此数据显示为127个CSV文件，但我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">csvkit</a>将它们组合为一个数据集，并在结果表的第一行中添加了具有列名的行。 如果需要，您可以下载此数据的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们的版本</a>并进行试验，阅读本文。 <br><br> 让我们从导入数据集开始，然后看一下它的前五行。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>表<code>   </code>表的“ <code>   </code>找到它们。 <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br> 以下是有关此数据表中最重要的列的信息。 如果要阅读所有列的说明，则可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>找到整个数据集的数据字典。 <br><br><ul><li>  <code>date</code> -游戏的日期。 </li><li>  <code>v_name</code>来宾团队的名称。 </li><li>  <code>v_league</code>客队联赛。 </li><li>  <code>h_name</code>的名称。 </li><li>  <code>h_league</code>主队联赛。 </li><li>  <code>v_score</code>得分。 </li><li>  <code>h_score</code>得分。 </li><li>  <code>v_line_score</code>积分的摘要，例如<code>010000(10)00</code> 。 </li><li>  <code>h_line_score</code>的摘要，例如<code>010000(10)0X</code> 。 </li><li>  <code>park_id</code>进行游戏的字段的标识符。 </li><li>  <code>attendance</code> -观众人数。 </li></ul><br> 为了找到有关<code>DataFrame</code>对象的常规信息，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DataFrame.info（）</a>方法。 通过这种方法，您可以了解对象的大小，数据类型以及内存使用情况。 <br><br> 默认情况下，为了节省时间，pandas <code>DataFrame</code>了有关<code>DataFrame</code>内存使用情况的大概信息。 我们对准确的信息感兴趣，因此我们将<code>memory_usage</code>参数设置为<code>'deep'</code> 。 <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br> 以下是我们设法获得的信息： <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br> 事实证明，我们有171,907行和161列。 熊猫库自动检测到数据类型。 有83列包含数值数据，78列包含对象。 对象列用于存储字符串数据，并且在该列包含不同类型的数据的情况下。 <br><br> 现在，为了更好地理解如何使用此<code>DataFrame</code>优化内存使用，让我们讨论一下熊猫如何将数据存储在内存中。 <br><br><h2>  <font color="#3AC1EF">数据框的内部视图</font> </h2><br> 在大熊猫内部，数据列被分组为具有相同类型值的块。 这是一个如何将<code>DataFrame</code>的前12列存储在熊猫中的<code>DataFrame</code> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">熊猫中不同类型数据的内部表示</font></i> <br><br> 您可能会注意到，块不存储列名信息。 这是由于对数据块进行了优化，以将可用值存储在<code>DataFrame</code>对象的表单元格中。  <code>BlockManager</code>类负责存储有关数据集的行索引和列索引之间的对应关系以及存储在相同类型数据块中的内容的信息。 它充当提供对基本数据的访问的API的角色。 当我们读取，编辑或删除值时， <code>DataFrame</code>类与<code>BlockManager</code>类进行交互以将我们的请求转换为函数和方法调用。 <br><br> 每个数据类型在<code>pandas.core.internals</code>模块中都有一个专门的类。 例如，pandas使用<code>ObjectBlock</code>类表示包含字符串列的块，使用<code>FloatBlock</code>类表示包含包含浮点数的列的块。 对于代表看起来像整数或浮点数的数值的块，pandas <code>ndarray</code>列并将其存储为NumPy库的<code>ndarray</code>数据<code>ndarray</code> 。 该数据结构基于数组C，其值存储在连续的内存块中。 由于采用了这种数据存储方案，因此可以快速访问数据片段。 <br><br> 由于不同类型的数据是分开存储的，因此我们检查了不同类型数据的内存使用情况。 让我们从不同类型数据的平均内存使用量开始。 <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br> 结果，事实证明，不同类型数据的内存使用量的平均指标如下所示： <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br> 这些信息使我们了解到，大多数内存都花在存储对象值的78列上。 稍后我们将详细讨论，但现在让我们考虑是否可以通过存储数字数据的列来提高内存使用率。 <br><br><h2>  <font color="#3AC1EF">亚型</font> </h2><br> 正如我们已经说过的，熊猫将数值表示为<code>ndarray</code> NumPy数据结构并将其存储在连续的内存块中。 该数据存储模型使您可以节省内存并快速访问值。 由于熊猫使用相同数量的字节表示相同类型的每个值，并且<code>ndarray</code>结构存储有关值数量的信息，因此熊猫可以快速，准确地显示有关存储数值的列所消耗的内存量的信息。 <br><br> 大熊猫中的许多数据类型都有许多子类型，这些子类型可以使用更少的字节来表示每个值。 例如， <code>float</code>类型具有子类型<code>float16</code> ， <code>float32</code>和<code>float64</code> 。 类型名称中的数字表示该子类型用来表示值的位数。 例如，在刚列出的子类型中，分别将2、4、8和16个字节用于数据存储。 下表显示了熊猫中最常用的数据类型的子类型。 <br><table><tbody><tr><td>  <sup>内存使用量（字节）</sup> <sup><br></sup> </td><td>  <sup>浮点数</sup> <sup><br></sup> </td><td>  <sup>整数</sup> <sup><br></sup> </td><td>  <sup>无符号整数</sup> <sup><br></sup> </td><td>  <sup>日期和时间</sup> <sup><br></sup> </td><td>  <sup>布尔值</sup> <sup><br></sup> </td><td width="75">  <sup>对象</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1个</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>布尔</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>日期时间64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>可变存储容量</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>对象</sup> <sup><br></sup> </td></tr></tbody></table><br>  <code>int8</code>类型的值使用1个字节（8位）存储一个数字，可以表示256个二进制值（2到8的幂）。 这意味着该子类型可用于存储-128到127（包括0）范围内的值。 <br><br> 要检查适用于使用每个整数子类型存储的最小值和最大值，可以使用<code>numpy.iinfo()</code>方法。 考虑一个例子： <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br> 通过执行此代码，我们得到以下数据： <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br> 在这里，您可以注意<code>uint</code> （无符号整数）和<code>int</code> （有符号整数）类型之间的区别。 两种类型具有相同的容量，但是当仅在列中存储正值时，无符号类型可以更有效地使用内存。 <br><br><h2>  <font color="#3AC1EF">使用子类型优化数字数据的存储</font> </h2><br>  <code>pd.to_numeric()</code>函数可用于下转换数字类型。 要选择整数列，我们使用<code>DataFrame.select_dtypes()</code>方法，然后对其进行优化并比较优化前后的内存使用情况。 <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br> 这是内存消耗研究的结果： <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td> 到 <br></td><td> 之后 <br></td></tr><tr><td>  uint8 <br></td><td>  N <br></td><td>  5.0 <br></td></tr><tr><td>  uint32 <br></td><td>  N <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  N <br></td></tr></tbody></table><br> 结果，您可以看到内存使用量从7.9兆字节减少到1.5兆字节，即-我们将内存消耗降低了80％以上。 但是，此优化对原始<code>DataFrame</code>的总体影响不是特别强烈，因为它具有很少的整数列。 <br><br> 让我们对包含浮点数的列进行相同的操作。 <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br> 结果如下： <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td> 到 <br></td><td> 之后 <br></td></tr><tr><td>  float32 <br></td><td>  N <br></td><td>  77.0 <br></td></tr><tr><td>  float64 <br></td><td>  77.0 <br></td><td>  N <br></td></tr></tbody></table><br> 结果，所有存储浮点数且数据类型为<code>float64</code>现在都存储了<code>float32</code>类型的数字，这使我们的内存使用量减少了50％。 <br><br> 创建原始<code>DataFrame</code>的副本，使用这些优化的数字列而不是其中最初存在的数字列，并查看优化后的整体内存使用情况。 <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br> 这是我们得到的： <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br> 尽管我们通过存储数字数据的列显着减少了内存消耗，但是通常，在整个<code>DataFrame</code> ，内存消耗仅减少了7％。 对象类型存储的优化可以成为情况严重改善的源泉。 <br><br> 在进行优化之前，我们将仔细研究熊猫中字符串的存储方式，并将其与数字在此处的存储方式进行比较。 <br><br><h2>  <font color="#3AC1EF">比较存储数字和字符串的机制</font> </h2><br>  <code>object</code>类型使用Python字符串对象表示值。 部分原因是NumPy不支持缺少字符串值的表示。 由于Python是一种高级解释语言，因此它没有为程序员提供用于微调数据在内存中存储方式的工具。 <br><br> 此限制导致以下事实：字符串未存储在连续的内存碎片中；它们在内存中的表示是碎片化的。 这导致内存消耗增加，并且处理字符串值的速度变慢。 实际上，存储对象数据类型的列中的每个元素都是一个指针，该指针包含实际地址位于内存中的“地址”。 <br><br> 下图是基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>材料的图， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该</a>图比较了使用NumPy数据类型存储数字数据和使用Python的内置数据类型存储字符串。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">存储数字和字符串数据</font></i> <br><br> 在这里您可以回想起，在上面的表之一中，显示了使用可变数量的内存来存储对象类型的数据。 尽管每个指针占用1个字节的内存，但是每个特定的字符串值占用的内存量与在Python中用于存储单个字符串的内存量相同。 为了确认这一点，我们将使用<code>sys.getsizeof()</code>方法。 首先，查看各个行，然后查看存储字符串数据的<code>Series</code> pandas对象。 <br><br> 因此，首先我们检查通常的几行： <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br> 在这里，内存使用情况数据如下所示： <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br> 现在让我们看一下<code>Series</code>对象中字符串的用法： <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br> 在这里，我们得到以下内容： <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br> 在这里，您可以看到<code>Series</code> pandas对象中存储的行的大小与在Python中使用它们并将它们表示为单独的实体时的大小相似。 <br><br><h2>  <font color="#3AC1EF">使用分类变量优化对象类型数据的存储</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分类变量</a>出现在熊猫0.15版中。 对应的类型<code>category</code> ，在其内部机制中使用整数值，而不是存储在表列中的原始值。 熊猫使用单独的字典来设置整数和初始值的对应关系。 当列包含有限集中的值时，此方法很有用。 当将存储在列中的数据转换为<code>category</code>类型时，pandas使用<code>int</code>子类型，该子类型可以最有效地使用内存，并且能够表示在该列中找到的所有唯一值。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">使用int8子类型的源数据和分类数据</font></i> <br><br> 为了准确了解我们可以在何处使用分类数据来减少内存消耗，我们在存储对象类型值的列中找到唯一值的数量： <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br> 您可以在表格<code>    </code>上找到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该</a>表<code>    </code> 。 <br><br> 例如，在<code>day_of_week</code>列（即玩游戏的星期几）中，有171907个值。 其中只有7个是唯一的。 总体而言，单看此报告就足以理解，许多列中使用了许多唯一值来表示大约172,000个游戏的数据。 <br><br> 在进行全面优化之前，让我们选择一个至少存储对象数据的列（至少<code>day_of_week</code> ，并查看将其转换为分类类型时程序内部发生的情况。 <br><br> 如前所述，该列仅包含7个唯一值。 要将其转换为分类类型，我们使用<code>.astype()</code>方法。 <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br> 这是我们得到的： <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br> 如您所见，尽管列的类型已更改，但存储在其中的数据看起来与以前相同。 现在让我们看看程序内部正在发生什么。 <br><br> 在下面的代码中，我们使用<code>Series.cat.codes</code>属性来找出<code>category</code>类型用来表示一周中每一天的整数值： <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br> 我们设法找出以下内容： <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br> 在这里，您可以看到为每个唯一值分配了一个整数值，并且该列现在为<code>int8</code>类型。 没有丢失的值，但是如果是这种情况，则将使用-1表示这样的值。 <br><br> 现在，我们比较将<code>day_of_week</code>列转换为<code>category</code>类型之前和之后的内存消耗。 <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br> 结果如下： <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br> 如您所见，最初消耗了9.84兆字节的内存，优化后仅消耗了0.16兆字节，这意味着该指标提高了98％。 请注意，当在包含大约172,000个元素的列中仅使用7个唯一值时，使用此列可能证明是最有利可图的优化方案之一。 <br><br> 尽管将所有列转换为该数据类型的想法看起来很吸引人，但是在执行此操作之前，请考虑这种转换的负面影响。 因此，此转换最严重的缺点是不可能对分类数据执行算术运算。 这也适用于普通的算术运算，以及使用<code>Series.min()</code>和<code>Series.max()</code>而无需先将数据转换为实数类型的情况。 <br><br> 我们应该将<code>category</code>类型的使用限制为主要存储类型为<code>object</code>数据的列，其中少于50％的值是唯一的。 如果列中的所有值都是唯一的，则使用<code>category</code>类型将增加内存使用量。 这是由于以下事实：除了数字类别代码之外，您还必须在内存中存储原始字符串值。 有关<code>category</code>类型限制的详细信息，请参见pandas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> 。 <br><br> 让我们创建一个循环，循环访问存储类型为<code>object</code>数据的所有列，找出列中唯一值的数量是否超过50％，如果是，则将其转换为<code>category</code>类型。 <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br> 现在将优化后发生的事情与之前发生的事情进行比较： <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br> 我们得到以下内容： <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td> 到 <br></td><td> 之后 <br></td></tr><tr><td> 对象 <br></td><td>  78.0 <br></td><td>  N <br></td></tr><tr><td> 类别 <br></td><td>  N <br></td><td>  78.0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     —  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>亲爱的读者们！</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">eugene_bb</a> .    -  ,    —    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442516/">https://habr.com/ru/post/zh-CN442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442504/index.html">PHP Xdebug代理：当Xdebug的标准功能不够用时</a></li>
<li><a href="../zh-CN442506/index.html">俄罗斯是否因非法交易个人数据而受到惩罚？</a></li>
<li><a href="../zh-CN442508/index.html">udalenka如何加速GitLab的创新</a></li>
<li><a href="../zh-CN442512/index.html">在ZomboDB的示例上自定义Django ORM</a></li>
<li><a href="../zh-CN442514/index.html">分布式系统。 设计模式。 书评</a></li>
<li><a href="../zh-CN442518/index.html">2018年十大网络黑客技术</a></li>
<li><a href="../zh-CN442520/index.html">案例 节省30万羽 每月进行内容相关广告</a></li>
<li><a href="../zh-CN442522/index.html">直观的RL（强化学习）：优势演员关键评论（A2C）简介</a></li>
<li><a href="../zh-CN442524/index.html">如何提高个人识别和访问控制系统的安全性</a></li>
<li><a href="../zh-CN442526/index.html">苏联盒式磁带播放器的历史（第二部分）：随身听的热潮，克格勃的小工具和录音机</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>