<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîö üõ¨ üé≥ N√∫cleos de CPU ou o que √© SMP e o que ele come üç£ üë©üèæ‚Äçüè´ üë∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Bom dia, hoje eu gostaria de abordar um t√≥pico bastante simples que √© quase desconhecido para programadores comuns, mas cada um de voc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√∫cleos de CPU ou o que √© SMP e o que ele come</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426497/"><h2>  1. Introdu√ß√£o </h2><br>  Bom dia, hoje eu gostaria de abordar um t√≥pico bastante simples que √© quase desconhecido para programadores comuns, mas cada um de voc√™s provavelmente o usou. <br>  Estamos falando de multiprocessamento sim√©trico (popularmente - SMP) - a arquitetura encontrada em todos os sistemas operacionais multitarefa e, √© claro, √© parte integrante deles.  Todo mundo sabe que quanto mais n√∫cleos um processador tiver, mais poderoso ele ser√°, sim, mas como um sistema operacional pode usar v√°rios n√∫cleos ao mesmo tempo?  Alguns programadores n√£o chegam a esse n√≠vel de abstra√ß√£o - eles simplesmente n√£o precisam, mas acho que todos estar√£o interessados ‚Äã‚Äãem como o SMP funciona. <br><a name="habracut"></a><br><h2>  Multitarefa e sua implementa√ß√£o </h2><br>  Quem j√° estudou arquitetura de computadores sabe que o pr√≥prio processador n√£o √© capaz de executar v√°rias tarefas ao mesmo tempo; a multitarefa fornece apenas o sistema operacional, que alterna essas tarefas.  Existem v√°rios tipos de multitarefa, mas o mais apropriado, conveniente e amplamente utilizado √© a exclus√£o de multitarefa (voc√™ pode ler seus principais aspectos na Wikipedia).  √â baseado no fato de que cada processo (tarefa) tem sua pr√≥pria prioridade, o que afeta quanto tempo do processador ser√° alocado para ele.  Cada tarefa recebe um intervalo de tempo durante o qual o processo faz alguma coisa; ap√≥s o intervalo expirar, o SO transfere o controle para outra tarefa.  Surge a quest√£o - como distribuir recursos do computador, como mem√≥ria, dispositivos, etc.  entre processos?  Tudo √© muito simples: o Windows faz isso sozinho, o Linux usa um sistema de sem√°foro.  Mas um n√∫cleo n√£o √© s√©rio, seguimos em frente. <br><br><h3>  Interrup√ß√µes e PIC </h3><br>  Talvez para alguns isso acabe sendo not√≠cia, para outros n√£o, mas a arquitetura i386 (falarei sobre a arquitetura x86, o ARM n√£o conta, porque n√£o estudei essa arquitetura e nunca a encontrei (mesmo no n√≠vel de grava√ß√£o de um servi√ßo ou programa residente)) usa interrup√ß√µes (falaremos apenas sobre interrup√ß√µes de hardware, IRQ) para notificar o SO ou programa sobre um evento.  Por exemplo, h√° uma interrup√ß√£o 0x8 (para os modos protegido e longo, por exemplo, 0x20, dependendo de como configurar o PIC, mais sobre isso posteriormente), que √© chamado pelo PIT, que, por exemplo, pode gerar interrup√ß√µes com qualquer frequ√™ncia necess√°ria.  Em seguida, o trabalho do sistema operacional para a distribui√ß√£o de intervalos de tempo √© reduzido para 0, quando uma interrup√ß√£o √© chamada, o programa para e o controle √© dado, por exemplo, ao kernel, que por sua vez salva os dados atuais do programa (registros, sinalizadores etc.) e d√° controle ao pr√≥ximo processo . <br><br>  Como voc√™ provavelmente entendeu, interrup√ß√µes s√£o fun√ß√µes (ou procedimentos) chamadas em algum momento pelo equipamento ou pelo pr√≥prio programa.  No total, o processador suporta 16 interrup√ß√µes em dois PICs.  O processador possui sinalizadores e um deles √© o sinal "I" - Controle de interrup√ß√£o.  Ao definir esse sinalizador como 0, o processador n√£o causar√° nenhuma interrup√ß√£o de hardware.  Mas tamb√©m quero observar que existem as chamadas NMIs - interrup√ß√µes n√£o mascar√°veis ‚Äã‚Äã- os dados de interrup√ß√£o ainda ser√£o chamados, mesmo que o bit I esteja definido como 0. Usando a programa√ß√£o PIC, voc√™ pode desativar os dados de interrup√ß√£o, mas depois de retornar de qualquer interrup√ß√£o com IRET - eles novamente n√£o ser√£o banidos.  Observo que, em um programa regular, voc√™ n√£o pode rastrear a chamada de interrup√ß√£o - seu programa √© interrompido e retomado apenas depois de um tempo, seu programa nem percebe (sim, voc√™ pode verificar se a interrup√ß√£o foi chamada - mas por qu√™? <br><br><h5>  PIC - Controlador de interrup√ß√£o program√°vel </h5><br>  Do Wiki: <br><blockquote>  Como regra, √© um dispositivo eletr√¥nico, √†s vezes feito como parte do pr√≥prio processador ou chips complexos de seu quadro, cujas entradas s√£o eletricamente conectadas √†s sa√≠das correspondentes de v√°rios dispositivos.  O n√∫mero de entrada do controlador de interrup√ß√£o √© indicado por "IRQ".  Esse n√∫mero deve ser diferenciado da prioridade de interrup√ß√£o, bem como do n√∫mero da entrada na tabela de vetores de interrup√ß√£o (INT).  Portanto, por exemplo, em um PC IBM no modo de opera√ß√£o real (o MS-DOS funciona nesse modo) do processador, a interrup√ß√£o do teclado padr√£o usa IRQ 1 e INT 9. <br><br>  A plataforma IBM PC original usa um esquema de interrup√ß√£o muito simples.  O controlador de interrup√ß√£o √© um contador simples que itera sequencialmente os sinais de dispositivos diferentes ou √© redefinido para o in√≠cio quando uma nova interrup√ß√£o √© encontrada.  No primeiro caso, os dispositivos t√™m prioridade igual; no segundo, os dispositivos com um n√∫mero de s√©rie mais baixo (ou mais alto na contagem) t√™m uma prioridade mais alta. </blockquote><br>  Como voc√™ entende, este √© um circuito eletr√¥nico que permite que os dispositivos enviem solicita√ß√µes de interrup√ß√£o, geralmente existem exatamente 2 deles. <br><br>  Agora, vamos ao t√≥pico do artigo. <br><br><h2>  SMP </h2><br>  Para implementar esse padr√£o, novos esquemas come√ßaram a ser colocados nas placas-m√£e: APIC e ACPI.  Vamos falar sobre o primeiro. <br><br>  APIC - Advanced Programmable Interrupt Controller, uma vers√£o aprimorada do PIC.  √â usado em sistemas multiprocessadores e √© parte integrante de todos os mais recentes processadores Intel (e compat√≠veis).  O APIC √© usado para encaminhamento de interrup√ß√µes complexo e para o envio de interrup√ß√µes entre processadores.  Essas coisas n√£o eram poss√≠veis usando a especifica√ß√£o PIC mais antiga. <br><br><h3>  APIC local e IO APIC </h3><br>  Em um sistema baseado em APIC, cada processador consiste em um "n√∫cleo" e um "APIC local".  O APIC local √© respons√°vel por manipular a configura√ß√£o de interrup√ß√£o espec√≠fica do processador.  Entre outras coisas, ele cont√©m uma tabela vetorial local (LVT), que converte eventos, como o ‚Äúrel√≥gio interno‚Äù e outras fontes ‚Äúlocais‚Äù de interrup√ß√µes, em um vetor de interrup√ß√£o (por exemplo, o contato LocalINT1 pode gerar uma exce√ß√£o de NMI, preservando " 2 ‚Äùpara a entrada LVT correspondente). <br><br>  Mais informa√ß√µes sobre o APIC local podem ser encontradas no "Guia de programa√ß√£o do sistema" dos modernos processadores Intel. <br><br>  Al√©m disso, h√° um APIC IO (por exemplo, intel 82093AA), que faz parte do chipset e fornece controle de interrup√ß√£o de v√°rios processadores, incluindo distribui√ß√£o sim√©trica est√°tica e din√¢mica de interrup√ß√µes para todos os processadores.  Em sistemas com v√°rios subsistemas de E / S, cada subsistema pode ter seu pr√≥prio conjunto de interrup√ß√µes. <br><br>  Cada pino de interrup√ß√£o √© programado individualmente como disparado por borda ou n√≠vel.  O vetor de interrup√ß√£o e as informa√ß√µes de controle de interrup√ß√£o podem ser especificados para cada interrup√ß√£o.  O esquema de acesso indireto ao registro otimiza o espa√ßo de mem√≥ria necess√°rio para acessar os registros internos de E / S da APIC.  Para aumentar a flexibilidade do sistema ao alocar espa√ßo de mem√≥ria, os dois registros de E / S APIC s√£o realoc√°veis, mas o padr√£o √© 0xFEC00000. <br><br><h3>  Inicializando um APIC ‚Äúlocal‚Äù </h3><br>  O APIC local √© ativado no momento da inicializa√ß√£o e pode ser desativado redefinindo o bit 11 IA32_APIC_BASE (MSR) (isso funciona apenas com processadores com uma fam√≠lia&gt; 5, uma vez que o Pentium n√£o possui esse MSR), ent√£o o processador recebe suas interrup√ß√µes diretamente do 8259 PIC compat√≠vel .  No entanto, o guia de desenvolvimento de software da Intel afirma que ap√≥s desativar o APIC local por meio do IA32_APIC_BASE, voc√™ n√£o poder√° ativ√°-lo at√© que ele seja completamente redefinido.  O APO IO tamb√©m pode ser configurado para operar no modo legado, de modo a emular um dispositivo 8259. <br><br>  Os APICs locais s√£o mapeados para a p√°gina f√≠sica FEE00xxx (consulte a Tabela 8-1 Intel P4 SPG).  Este endere√ßo √© o mesmo para cada APIC local que existe na configura√ß√£o, o que significa que voc√™ pode acessar diretamente os registros do kernel APIC local no qual seu c√≥digo est√° sendo executado no momento.  Observe que h√° um MSR que define a base APIC real (dispon√≠vel apenas para processadores com uma fam√≠lia&gt; 5).  O MADT cont√©m uma base APIC local e, em sistemas de 64 bits, tamb√©m pode conter um campo que especifica uma redefini√ß√£o de 64 bits do endere√ßo base, que voc√™ deve usar em seu lugar.  Voc√™ pode deixar a base local da APIC apenas onde a encontrar ou mov√™-la para onde quiser.  Nota: N√£o acho que voc√™ possa mov√™-lo al√©m do quarto GB de RAM. <br><br>  Para permitir que o APIC local receba interrup√ß√µes, voc√™ deve configurar o Spurious Interrupt Vector Register.  O valor correto para esse campo √© o n√∫mero do IRQ que voc√™ deseja mapear para interrup√ß√µes falsas com os 8 bits inferiores e o 8¬∫ bit definido como 1 para realmente ativar o APIC (consulte a especifica√ß√£o para obter detalhes).  Voc√™ deve selecionar um n√∫mero de interrup√ß√£o com os 4 bits inferiores definidos;  A maneira mais f√°cil √© usar 0xFF.  Isso √© importante para alguns processadores mais antigos, pois para esses valores os 4 bits inferiores devem ser definidos como 1. <br><br>  Desative o 8259 PIC corretamente.  Isso √© quase t√£o importante quanto configurar o APIC.  Voc√™ faz isso em duas etapas: mascarando todas as interrup√ß√µes e reatribuindo o IRQ.  Disfar√ßar todas as interrup√ß√µes as desativa no PIC.  Remapear interrup√ß√µes √© o que voc√™ provavelmente j√° fez quando usou o PIC: deseja que as solicita√ß√µes de interrup√ß√£o iniciem em 32 em vez de 0 para evitar conflitos com exce√ß√µes (nos modos de processador protegido e longo (longo), porque As primeiras 32 interrup√ß√µes s√£o exce√ß√µes).  Ent√£o voc√™ deve evitar usar esses vetores de interrup√ß√£o para outros fins.  Isso √© necess√°rio porque, apesar de voc√™ mascarar todas as interrup√ß√µes do PIC, ele ainda pode gerar interrup√ß√µes falsas, que ser√£o processadas incorretamente como exce√ß√µes no seu kernel. <br>  Vamos para o SMP. <br><br><h3>  Multitarefa sim√©trica: inicializa√ß√£o </h3><br>  A sequ√™ncia de inicializa√ß√£o √© diferente para diferentes CPUs.  O Guia do programador da Intel (Se√ß√£o 7.5.4) cont√©m um protocolo de inicializa√ß√£o para processadores Intel Xeon e n√£o abrange processadores antigos.  Para um algoritmo geral de ‚Äútodos os tipos de processadores‚Äù, consulte Especifica√ß√£o do multiprocessador Intel. <br><br>  Para 80486 (com APIC 8249DX externo), voc√™ deve usar o IPIT INIT, seguido pelo IPI "INIT level an-assert" sem nenhum SIPI.  Isso significa que voc√™ n√£o pode dizer a eles por onde come√ßar a executar seu c√≥digo (a parte vetorial do SIPI) e eles sempre come√ßam a executar o c√≥digo do BIOS.  Nesse caso, voc√™ define o valor de redefini√ß√£o do BIOS do CMOS para "inicializa√ß√£o a quente com salto em dist√¢ncia" (ou seja, define CMOS 0x0F como 10) para que o BIOS execute jmp far ~ [0: 0x0469] e, em seguida, define o segmento e o deslocamento Pontos de entrada do ponto de acesso em 0x0469. <br><br>  O IPI ‚ÄúINIT level an-assert‚Äù n√£o √© suportado em novos processadores (Pentium 4 e Intel Xeon), e o AFAIK √© completamente ignorado nesses processadores. <br><br>  Para processadores mais recentes (P6, Pentium 4), basta um SIPI, mas n√£o tenho certeza se os processadores Intel mais antigos (Pentium) ou de outros fabricantes precisam de um segundo SIPI.  Tamb√©m √© poss√≠vel que exista um segundo SIPI no caso de uma falha na entrega do primeiro SIPI (ru√≠do do barramento, etc.). <br><br>  Normalmente, envio o primeiro SIPI e espero para ver se o AP aumenta o n√∫mero de processadores em execu√ß√£o.  Se n√£o aumentar esse contador dentro de alguns milissegundos, enviarei um segundo SIPI.  Isso √© diferente do algoritmo geral da Intel (que possui um atraso de 200 microssegundos entre o SIPI), mas tentar encontrar uma fonte de tempo que possa medir com precis√£o o atraso de 200 microssegundos durante uma inicializa√ß√£o antecipada n√£o √© t√£o simples.  Tamb√©m descobri que no hardware real, se o atraso entre o SIPI for muito longo (e voc√™ n√£o estiver usando o meu m√©todo), o AP principal poder√° executar o c√≥digo de inicializa√ß√£o do AP inicial para o SO duas vezes (o que, no meu caso, far√° com que o SO pense que temos o dobro de processadores do que realmente somos). <br><br>  Voc√™ pode transmitir esses sinais no barramento para iniciar cada dispositivo presente.  No entanto, voc√™ tamb√©m pode ativar os processadores que foram especialmente desativados (porque estavam "com defeito"). <br><br><h3>  Procurando informa√ß√µes usando a tabela MT </h3><br>  Algumas informa√ß√µes (que podem n√£o estar dispon√≠veis em m√°quinas mais recentes) destinadas ao multiprocessamento.  Primeiro voc√™ precisa encontrar a estrutura do ponteiro flutuante MP.  Ele est√° alinhado em um limite de 16 bytes e cont√©m uma assinatura no in√≠cio de "_MP_" ou 0x5F504D5F.  O sistema operacional deve procurar no EBDA, no espa√ßo da ROM do BIOS e no √∫ltimo kilobyte de "mem√≥ria base";  o tamanho da mem√≥ria base √© especificado em um valor de 2 bytes de 0x413 em kilobytes, menos 1 KB.  √â assim que a estrutura se parece: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_floating_pointer_structure</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> configuration_table; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> length; <span class="hljs-comment"><span class="hljs-comment">// In 16 bytes (eg 1 = 16 bytes, 2 = 32 bytes) uint8_t mp_specification_revision; uint8_t checksum; // This value should make all bytes in the table equal 0 when added together uint8_t default_configuration; // If this is not zero then configuration_table should be // ignored and a default configuration should be loaded instead uint32_t features; // If bit 7 is then the IMCR is present and PIC mode is being used, otherwise // virtual wire mode is; all other bits are reserved }</span></span></code> </pre> <br>  Aqui est√° a apar√™ncia da tabela de configura√ß√£o que a estrutura flutuante do ponteiro aponta para: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_configuration_table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "PCMP" uint16_t length; uint8_t mp_specification_revision; uint8_t checksum; // Again, the byte should be all bytes in the table add up to 0 char oem_id[8]; char product_id[12]; uint32_t oem_table; uint16_t oem_table_size; uint16_t entry_count; // This value represents how many entries are following this table uint32_t lapic_address; // This is the memory mapped address of the local APICs uint16_t extended_table_length; uint8_t extended_table_checksum; uint8_t reserved; }</span></span></code> </pre><br>  Ap√≥s a tabela de configura√ß√£o, est√£o as entradas entry_count, que cont√™m mais informa√ß√µes sobre o sistema, seguidas por uma tabela estendida.  As entradas t√™m 20 bytes para representar o processador ou 8 bytes para outra coisa.  Aqui est√° a apar√™ncia do processador APIC e dos registros de E / S. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_processor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 0 uint8_t local_apic_id; uint8_t local_apic_version; uint8_t flags; // If bit 0 is clear then the processor must be ignored // If bit 1 is set then the processor is the bootstrap processor uint32_t signature; uint32_t feature_flags; uint64_t reserved; }</span></span></code> </pre><br>  Aqui est√° a entrada IO APIC. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_io_apic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 2 uint8_t id; uint8_t version; uint8_t flags; // If bit 0 is set then the entry should be ignored uint32_t address; // The memory mapped address of the IO APIC is memory }</span></span></code> </pre><br><h3>  Procurando informa√ß√µes com a APIC </h3><br>  Voc√™ pode encontrar a tabela MADT (APIC) na ACPI.  A tabela lista os APICs locais, cujo n√∫mero deve corresponder ao n√∫mero de n√∫cleos no seu processador.  Os detalhes desta tabela n√£o est√£o aqui, mas voc√™ pode encontr√°-los na Internet. <br><br><h3>  Iniciar AP </h3><br>  Depois de coletar as informa√ß√µes, voc√™ precisa desativar o PIC e se preparar para a E / S da APIC.  Voc√™ tamb√©m precisa configurar o BSP do APIC local.  Ent√£o inicie o AP usando SIPI. <br><br>  <b>C√≥digo para o lan√ßamento de kernels:</b> <br><br>  Observo que o vetor especificado na inicializa√ß√£o indica o endere√ßo inicial: vetor 0x8 - endere√ßo 0x8000, vetor 0x9 - endere√ßo 0x9000, etc. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static u32 LocalApicIn(uint reg) { return MmioRead32(*g_localApicAddr + reg); } // ------------------------------------------------------------------------------------------------ static void LocalApicOut(uint reg, u32 data) { MmioWrite32(*g_localApicAddr + reg, data); } // ------------------------------------------------------------------------------------------------ void LocalApicInit() { // Clear task priority to enable all interrupts LocalApicOut(LAPIC_TPR, 0); // Logical Destination Mode LocalApicOut(LAPIC_DFR, 0xffffffff); // Flat mode LocalApicOut(LAPIC_LDR, 0x01000000); // All cpus use logical id 1 // Configure Spurious Interrupt Vector Register LocalApicOut(LAPIC_SVR, 0x100 | 0xff); } // ------------------------------------------------------------------------------------------------ uint LocalApicGetId() { return LocalApicIn(LAPIC_ID) &gt;&gt; 24; } // ------------------------------------------------------------------------------------------------ void LocalApicSendInit(uint apic_id) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, ICR_INIT | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } // ------------------------------------------------------------------------------------------------ void LocalApicSendStartup(uint apic_id, uint vector) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, vector | ICR_STARTUP | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } void SmpInit() { kprintf("Waking up all CPUs\n"); *g_activeCpuCount = 1; uint localId = LocalApicGetId(); // Send Init to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) { LocalApicSendInit(apicId); } } // wait PitWait(200); // Send Startup to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) LocalApicSendStartup(apicId, 0x8); } // Wait for all cpus to be active PitWait(10); while (*g_activeCpuCount != g_acpiCpuCount) { kprintf("Waiting... %d\n", *g_activeCpuCount); PitWait(10); } kprintf("All CPUs activated\n"); }</span></span></code> </pre><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">org</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>] AP: jmp short bsp ;     -   BSP xor ax,ax mov ss,ax mov sp, <span class="hljs-number"><span class="hljs-number">0</span></span>x7c00 xor ax,ax mov ds,ax ; Mark CPU as active lock inc byte [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>] ;   ,   jmp zop bsp: xor ax,ax mov ds,ax mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov word [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>x9090 ;  JMP   <span class="hljs-number"><span class="hljs-number">2</span></span> NOP<span class="hljs-string"><span class="hljs-string">' ;   ,  </span></span></code> </pre><br>  Agora, como voc√™ entende, para que o sistema operacional use muitos n√∫cleos, voc√™ precisa configurar a pilha para cada n√∫cleo, cada n√∫cleo, suas interrup√ß√µes etc., mas o mais importante √© que, ao usar o multiprocessamento sim√©trico, todos os n√∫cleos t√™m os mesmos recursos: uma mem√≥ria, um PCI, etc., e o sistema operacional s√≥ pode paralelizar tarefas entre os n√∫cleos. <br><br>  Espero que o artigo n√£o seja chato o suficiente e bastante informativo.  Da pr√≥xima vez, acho, podemos falar sobre como eles costumavam desenhar na tela (e agora eles desenham), sem usar shaders e placas de v√≠deo legais. <br><br>  Boa sorte </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426497/">https://habr.com/ru/post/pt426497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426487/index.html">Teste a automa√ß√£o do zero. Parte 1</a></li>
<li><a href="../pt426489/index.html">Sobre a rela√ß√£o de n√∫meros primos e irracionais</a></li>
<li><a href="../pt426491/index.html">Semana de Seguran√ßa 39: com a morte do Google+</a></li>
<li><a href="../pt426493/index.html">Descontos constantes de hosters para VPS e VPS.today Pesquisar visitantes</a></li>
<li><a href="../pt426495/index.html">Designer Solo. Como construir uma carreira quando voc√™ trabalha sozinho</a></li>
<li><a href="../pt426499/index.html">Programa educacional para trabalhar com cart√µes perfurados (ou a hist√≥ria de como o ‚Äúbig data‚Äù foi processado de 1890 a 1970)</a></li>
<li><a href="../pt426501/index.html">Lamoda por dentro: por que a loja on-line de 300 engenheiros</a></li>
<li><a href="../pt426503/index.html">Funcionalidade do SAP HANA como um banco de dados para o SAP HANA Data Management Suite</a></li>
<li><a href="../pt426505/index.html">Eventos digitais em Moscou, de 15 a 21 de outubro</a></li>
<li><a href="../pt426507/index.html">Criando uma arquitetura: trabalhando com o padr√£o iOS Coordinator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>