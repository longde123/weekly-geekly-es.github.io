<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥔 🏂🏾 👩‍❤️‍👩 PVS-Studio pour Java 🆔 🧕🏿 🏘️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la septième version de l'analyseur statique PVS-Studio, nous avons ajouté la prise en charge du langage Java. Il est temps de raconter brièvement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio pour Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436496/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio pour Java"></div><br>  Dans la septième version de l'analyseur statique PVS-Studio, nous avons ajouté la prise en charge du langage Java.  Il est temps de raconter brièvement comment nous avons commencé à prendre en charge le langage Java, jusqu'où nous en sommes et ce qui est dans nos plans futurs.  Bien sûr, cet article répertorie les premiers essais d'analyseur sur des projets open source. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  Voici une brève description de PVS-Studio pour les développeurs Java qui n'en ont pas entendu parler auparavant. <br><br>  Cet outil est conçu pour détecter les erreurs et les vulnérabilités potentielles dans le code source des programmes, écrits en C, C ++, C # et Java.  Il fonctionne dans l'environnement Windows, Linux et macOS. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> effectue une analyse de code statique et génère un rapport qui aide un développeur à trouver et à éliminer les défauts.  Pour ceux qui sont intéressés par la façon exacte dont PVS-Studio recherche les erreurs, je suggère de consulter l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Technologies utilisées dans l'analyseur de code PVS-Studio pour trouver des bogues et des vulnérabilités potentielles</a> ". <br><br><h2>  Début </h2><br>  J'aurais pu trouver une histoire intelligente sur la façon dont nous avons spéculé sur la prochaine langue à prendre en charge dans PVS-Studio.  À propos d'un choix judicieux de Java, qui est basé sur une grande popularité de ce langage, etc. <br><br>  Cependant, comme cela arrive dans la vie, le choix n'a pas été fait par une analyse approfondie, mais par une expérience :).  Oui, nous avons réfléchi à la direction du développement ultérieur de l'analyseur PVS-Studio.  Nous avons considéré ces langages comme: Java, PHP, Python, JavaScript, IBM RPG.  Nous étions même enclins au langage Java mais le choix final n'a pas été fait.  Pour ceux dont le regard reposait sur un RPG IBM inconnu, je voudrais vous diriger vers cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">note</a> , à partir de laquelle tout deviendra clair. <br><br>  À la fin de 2017, mon collègue Egor Bredikhin a examiné les bibliothèques prêtes à l'emploi de code d'analyse (en d'autres termes - analyseurs) pour de nouvelles directions de développement, intéressantes pour nous.  Finalement, il est tombé sur plusieurs projets pour analyser le code Java.  Il a réussi à créer rapidement un prototype d'analyseur avec quelques diagnostics basés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spoon</a> .  De plus, il est devenu clair que nous pourrions utiliser dans l'analyseur Java certains mécanismes de l'analyseur C ++ utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SWIG</a> .  Nous avons regardé ce que nous avions obtenu et réalisé que notre prochain analyseur serait pour Java. <br><br>  Nous tenons à remercier Egor pour son entreprise et le travail acharné qu'il a accompli sur l'analyseur Java.  Le processus de développement lui-même a été décrit par lui dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Développement d'un nouvel analyseur statique: PVS-Studio Java</a> ". <br><br><h2>  Et les concurrents? </h2><br>  Il existe de nombreux analyseurs de code statique gratuits et commerciaux pour Java à travers le monde.  Il est inutile de tous les énumérer dans l'article.  Je vais juste laisser le lien vers la " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liste des outils pour l'analyse de code statique</a> " (voir la section Java et multi-langage). <br><br>  Cependant, je sais que nous serons d'abord et avant tout interrogés sur IntelliJ IDEA, FindBugs et SonarQube (SonarJava). <br><br>  <b>IntelliJ IDEA</b> <br><br>  Un analyseur de code statique très puissant est intégré à IntelliJ IDEA.  De plus, l'analyseur évolue, ses auteurs suivent de près nos activités.  Ainsi, IntelliJ IDEA est un cookie difficile pour nous.  Nous ne pourrons pas dépasser IntelliJ IDEA en termes de capacités de diagnostic, du moins pour l'instant.  Par conséquent, nous nous concentrerons sur nos autres avantages. <br><br>  L'analyse statique dans IntelliJ IDEA est principalement l'une des caractéristiques de l'environnement, qui lui impose certaines limites.  Quant à nous, nous avons la liberté dans ce que nous pouvons faire avec notre analyseur.  Par exemple, nous pouvons l'adapter rapidement aux besoins spécifiques des clients.  Un soutien rapide et approfondi est notre avantage concurrentiel.  Nos clients communiquent directement avec les développeurs, travaillant sur l'une ou l'autre partie de PVS-Studio. <br><br>  Dans PVS-Studio, il existe de nombreuses opportunités pour l'intégrer dans un cycle de développement de grands projets anciens.  Par exemple, c'est notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégration avec SonarQube</a> .  Il inclut également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la suppression en masse</a> des avertissements de l'analyseur, ce qui vous permet de commencer immédiatement à utiliser l'outil dans un grand projet de suivi des bogues uniquement dans le code nouveau ou modifié.  PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut être construit</a> dans un processus d'intégration continue.  Je pense que ces fonctionnalités et d'autres aideront notre analyseur à trouver une place sous le soleil dans le monde Java. <br><br>  <b>Findbugs</b> <br><br>  Le projet FindBugs est abandonné.  Néanmoins, nous devons le mentionner en raison du fait qu'il s'agit peut-être de l'analyseur statique gratuit le plus célèbre du code Java. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpotBugs</a> pourrait être appelé le successeur de FindBugs.  Cependant, il est moins populaire et on ne sait pas encore ce qui va en résulter. <br><br>  De manière générale, nous pensons que même si FindBugs a été et reste extrêmement populaire, et en plus d'un analyseur gratuit, nous ne devrions pas nous y attarder.  Ce projet deviendra tranquillement une histoire. <br><br>  PS Soit dit en passant, maintenant PVS-Studio peut également être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisé gratuitement</a> lorsque vous travaillez avec des projets ouverts. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Nous pensons que nous ne sommes pas en concurrence avec SonarQube, mais le complétons.  PVS-Studio s'intègre à SonarQube, ce qui permet aux développeurs de trouver plus de bogues et de failles de sécurité potentielles dans leurs projets.  Nous expliquons régulièrement comment intégrer l'outil PVS-Studio et d'autres analyseurs dans SonarQube sur des master classes que nous organisons en fonction de différentes conférences. <br><br><h2>  Comment exécuter PVS-Studio pour Java </h2><br>  Nous avons mis à la disposition des utilisateurs les moyens les plus populaires d'intégration de l'analyseur dans le système de build: <br><br><ul><li>  Plugin pour Maven; </li><li>  Plugin pour Gradle; </li><li>  Plugin pour IntelliJ IDEA </li></ul><br>  Au cours de la phase de test, nous avons rencontré de nombreux utilisateurs qui ont des systèmes de construction auto-écrits, en particulier dans le domaine du développement mobile.  Ils ont profité de l'occasion pour exécuter l'analyseur directement, répertoriant les sources et le chemin de classe. <br><br>  Vous pouvez trouver des informations détaillées sur toutes les manières d'exécuter l'analyseur sur la page de documentation " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment exécuter PVS-Studio Java</a> ". <br><br>  Nous ne pouvions pas éviter la plate-forme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarQube</a> de contrôle de la qualité du code, qui est si populaire parmi les développeurs Java, nous avons donc ajouté la prise en charge du langage Java dans notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin pour SonarQube</a> . <br><br><h2>  Plans supplémentaires </h2><br>  Nous avons beaucoup d'idées qui pourraient nécessiter une enquête plus approfondie, mais certains plans spécifiques, inhérents à l'un de nos analyseurs, sont les suivants: <br><br><ul><li>  Création de nouveaux diagnostics et amélioration des diagnostics existants; </li><li>  Amélioration de l'analyse des flux de données; </li><li>  Augmentation de la fiabilité et de la convivialité. </li></ul><br>  Peut-être, nous trouverons le temps d'adapter le plugin IntelliJ IDEA pour CLion.  Salut aux développeurs C ++ qui ont lu sur l'analyseur Java :-) <br><br><h2>  Exemples d'erreurs trouvées dans les projets Open Source </h2><br>  Frissonne mes bois si je ne montre pas dans l'article quelques bugs trouvés avec le nouvel analyseur!  Eh bien, nous aurions pu prendre un gros projet Java open source et écrire un article classique sur les erreurs, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous</a> le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">faisons habituellement</a> . <br><br>  Cependant, j'anticipe immédiatement des questions sur ce que nous pouvons trouver dans des projets tels que IntelliJ IDEA, FindBugs, etc.  Je n'ai donc pas d'autre issue que de commencer avec ces projets.  J'ai donc décidé de vérifier et d'écrire rapidement plusieurs exemples intéressants d'erreurs des projets suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IntelliJ IDEA Community Edition</a> .  Je pense qu'il n'est pas nécessaire d'expliquer pourquoi ce projet a été choisi :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpotBugs</a>  Comme je l'ai écrit plus tôt, le projet FindBugs ne progresse pas.  Regardons donc à l'intérieur du projet SpotBugs, qui est le successeur de FindBugs.  SpotBugs est un analyseur statique classique de code Java. </li><li>  Quelque chose des projets de la société SonarSource, qui développe un logiciel de surveillance continue de la qualité du code.  Regardons maintenant à l'intérieur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarQube</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarJava</a> . </li></ul><br>  Écrire sur les bugs de ces projets est un défi.  Le fait est que ces projets sont de très haute qualité.  En fait, ce n'est pas surprenant.  Nos observations montrent que les analyseurs de code statique sont toujours bien testés et vérifiés à l'aide d'autres outils. <br><br>  Malgré tout cela, je vais devoir commencer exactement avec ces projets.  Je n'aurai pas la deuxième chance d'écrire à leur sujet.  Je suis sûr qu'après la sortie de PVS-Studio pour Java, les développeurs des projets répertoriés intégreront PVS-Studio et commenceront à l'utiliser pour des vérifications régulières ou, au moins, occasionnelles de leur code.  Par exemple, je sais que Tagir Valeev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">lany</a> ), l'un des développeurs de JetBrains, travaillant sur l'analyseur de code statique IntelliJ IDEA, au moment où j'écris, l'article joue déjà avec la version Beta de PVS-Studio .  Il nous a écrit environ 15 e-mails avec des rapports de bogues et des recommandations.  Merci, Tagir! <br><br>  Heureusement, je n'ai pas besoin de trouver autant de bogues dans un projet particulier.  Pour le moment, ma tâche est de montrer que l'analyseur PVS-Studio pour Java n'est pas apparu en vain et sera en mesure de remplir une gamme d'autres outils conçus pour améliorer la qualité du code.  Je viens de parcourir les rapports de l'analyseur et d'énumérer quelques erreurs qui semblaient intéressantes.  Si possible, j'ai essayé de citer différents types d'erreurs.  Voyons comment cela s'est avéré. <br><br><h3>  IntelliJ IDEA, Integer Division </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6011 [CWE-682] Le littéral '0,2' du type 'double' est comparé à une valeur du type 'int'.  TitleCapitalizationInspection.java 169 <br><br>  Le point était que la fonction devrait retourner true si moins de 20% des mots commencent par une majuscule.  En fait, la vérification ne fonctionne pas, car une division entière se produit.  En raison de la division, nous ne pouvons obtenir que deux valeurs: 0 ou 1. <br><br>  La fonction retournera false, uniquement si tous les mots commencent par une majuscule.  Dans tous les autres cas, l'opération de division donnera 0 et la fonction renverra true. <br><br><h3>  IntelliJ IDEA, boucle suspecte </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'index&gt; = 0' est toujours vraie.  Updater.java 184 <br><br>  Tout d'abord, regardez la condition <i>(0 &lt;= courant &amp;&amp; courant &lt;compte)</i> .  Elle n'est exécutée que si la valeur de la variable de <i>comptage</i> est supérieure à 0. <br><br>  Regardez maintenant la boucle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  L' <i>index</i> variable est initialisé avec un <i>nombre d'</i> expressions <i>- 1</i> .  Comme la variable de <i>comptage</i> est supérieure à 0, la valeur initiale de la variable d' <i>index</i> sera toujours supérieure ou égale à 0. Il s'avère que la boucle sera exécutée jusqu'à ce qu'un débordement de la variable d' <i>index</i> se produise. <br><br>  Très probablement, c'est juste une faute de frappe, et un décrément, pas un incrément d'une variable doit être exécuté: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA, copier-coller </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6001 [CWE-570] Il existe des sous-expressions identiques 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)' à gauche et à droite de '||'  opérateur.  Vérifiez les lignes: 127, 128. ExtensionOrderConverter.java 127 <br><br>  Bon vieil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effet de la dernière ligne</a> .  Un développeur a sauté le pistolet et ayant multiplié la ligne de code, a oublié de le réparer.  Par conséquent, une chaîne <i>str</i> est comparée à <i>BEFORE_STR_OLD</i> deux fois.  Très probablement, l'une des comparaisons doit être avec <i>AFTER_STR_OLD</i> . <br><br><h3>  IntelliJ IDEA, Typo </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6001 [CWE-571] Il existe des sous-expressions identiques '! StringUtil.endsWithChar (nom,' "')' à gauche et à droite de l'opérateur '&amp;&amp;'. JsonNamesValidator.java 27 <br><br>  Ce fragment de code vérifie que le nom est placé entre guillemets simples ou doubles.  Si ce n'est pas le cas, des guillemets doubles sont ajoutés automatiquement. <br><br>  En raison d'une faute de frappe, la fin du nom n'est vérifiée que pour la présence de guillemets doubles.  Par conséquent, le nom entre guillemets simples sera traité de manière incorrecte. <br><br>  Le nom <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  en raison de l'ajout de guillemets supplémentaires se transformera en: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, Protection incorrecte contre le dépassement de baie </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'i &lt;endOffset' est toujours vraie.  EnterAfterJavadocTagHandler.java 183 <br><br>  La sous-expression <i>i &lt;endOffset</i> dans la condition de l'opérateur <i>if</i> n'a pas de sens.  La variable <i>i</i> est toujours inférieure à <i>endOffset</i> dans tous les cas, ce qui découle de la condition de l'exécution de la boucle. <br><br>  Très probablement, un développeur souhaitait se protéger d'un dépassement de chaîne lors de l'appel de fonctions: <br><br><ul><li>  text.charAt (i + 1) </li><li>  CharArrayUtil.regionMatches (texte, i + 2, endOffset, startTag) </li></ul><br>  Dans ce cas, la sous-expression pour vérifier l'index doit être: <i>(i) &lt;endOffset-2</i> . <br><br><h3>  IntelliJ IDEA, Vérification répétée </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'buffer.length ()&gt; 0' est toujours vraie.  DeleteUtil.java 62 <br><br>  Cela peut être un code redondant inoffensif ou une erreur cruciale. <br><br>  Si un chèque en double est apparu accidentellement, par exemple lors d'une refactorisation, il n'y a rien de mal à cela.  Vous pouvez simplement supprimer le deuxième chèque. <br><br>  Un autre scénario est également possible.  La deuxième vérification doit être très différente et le code ne se comporte pas comme prévu.  Alors c'est une vraie erreur. <br><br>  <b>Remarque</b>  Soit dit en passant, il existe de nombreux contrôles redondants.  Eh bien, il est souvent clair que ce n'est pas une erreur.  Cependant, nous ne pouvons pas considérer les avertissements de l'analyseur comme de faux positifs.  Pour une explication, je voudrais citer un tel exemple, également tiré d'IntelliJ IDEA: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  L'analyseur indique que la fonction <i>text.contains ("\ r \ n")</i> renvoie toujours false.  En effet, si les caractères "\ n" et "\ r" ne sont pas trouvés, il ne sert à rien de rechercher "\ r \ n".  Ce n'est pas un bug, et le code est mauvais uniquement parce qu'il fonctionne légèrement plus lentement, effectuant une recherche vide de sens pour une sous-chaîne. <br><br>  Comment gérer un tel code, dans chaque cas, est une question pour les développeurs.  Lors de la rédaction d'articles, je ne fais généralement pas attention à ce code. <br><br><h3>  IntelliJ IDEA, quelque chose ne va pas </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-570] L'expression "" 0 ".equals (texte)" est toujours fausse.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  Le code contient à coup sûr une erreur logique.  J'ai du mal à dire exactement ce que le programmeur voulait vérifier et comment corriger le défaut.  Alors ici, je vais juste signaler un chèque sans signification. <br><br>  Au début, il faut vérifier que la chaîne contient au moins deux symboles.  Si ce n'est pas le cas, la fonction renvoie <i>false</i> . <br><br>  Vient ensuite le chèque <i>"0" .equals (texte)</i> .  Cela n'a pas de sens, car aucune chaîne ne peut contenir qu'un seul caractère. <br><br>  Donc, quelque chose ne va pas ici, et le code devrait être corrigé. <br><br><h3>  SpotBugs (Successeur de FindBugs), erreur de limitation sur le nombre d'itérations </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'count &lt;4' est toujours vraie.  Util.java 394 <br><br>  En théorie, une recherche de la balise xml ne doit être effectuée que dans les quatre premières lignes du fichier.  Mais du fait que l'on a oublié d'incrémenter la variable <i>count</i> , le fichier entier sera lu. <br><br>  Premièrement, cela peut être une opération très lente, et deuxièmement, quelque part au milieu du fichier, quelque chose pourrait être trouvé qui serait perçu comme une balise xml, et non comme ça. <br><br><h3>  SpotBugs (Successeur de FindBugs), effacement d'une valeur </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6021 [CWE-563] La valeur est affectée à la variable "priorité" mais n'est pas utilisée.  FindNonShortCircuit.java 197 <br><br>  La valeur de la variable <i>prioritaire</i> est définie en fonction de la valeur de la variable <i>sawNullTestVeryOld</i> .  Cependant, cela n'a pas d'importance du tout.  Après cela, la variable de <i>priorité se</i> verra attribuer une autre valeur dans tous les cas.  Une erreur évidente dans la logique de la fonction. <br><br><h3>  SonarQube, copier-coller </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 Il est étrange que le corps de la méthode 'setUpdatedAtFromDefinition' soit entièrement équivalent au corps d'une autre méthode 'setUpdatedAtFromMetadata'.  Vérifiez les lignes: 396, 405. RuleDto.java 396 <br><br>  Un champ de <i>définition</i> est utilisé dans la méthode <i>setUpdatedAtFromMetadata</i> .  Très probablement, le champ de <i>métadonnées</i> doit être utilisé.  Ceci est très similaire aux effets d'un copier-coller échoué. <br><br><h3>  SonarJava, doublons lors de l'initialisation de la carte </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  Avertissement PVS-Studio: V6033 [CWE-462] Un élément avec la même clé 'JavaPunctuator.PLUSEQU' a déjà été ajouté.  Vérifiez les lignes: 104, 100. KindMaps.java 104 <br><br>  La même paire clé-valeur est définie deux fois dans la carte.  Très probablement, cela s'est produit par inadvertance et il n'y a en fait aucune erreur réelle.  Cependant, ce code doit être vérifié dans tous les cas, car, peut-être, on a oublié d'ajouter une autre paire. <br><br><h2>  Conclusion </h2><br>  Pourquoi écrire une conclusion quand c'est si évident?!  Je vous suggère à tous de télécharger PVS-Studio dès maintenant et d'essayer de vérifier vos projets de travail sur le langage Java!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Téléchargez PVS-Studio</a> . <br><br>  Merci à tous pour votre attention.  J'espère que bientôt nous plairons à nos lecteurs avec une série d'articles sur la vérification de divers projets Java open source. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436496/">https://habr.com/ru/post/fr436496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436486/index.html">Que se passe-t-il sur le marché du podcast audio</a></li>
<li><a href="../fr436488/index.html">Currying et application partielle en C ++ 14</a></li>
<li><a href="../fr436490/index.html">Motorola prévoit d'introduire l'incarnation de Razr v3</a></li>
<li><a href="../fr436492/index.html">Nous recherchons des conférenciers au 10e DIY Mitap 17 février 2019</a></li>
<li><a href="../fr436494/index.html">Remplacement d'un disque tout en conservant une numérotation correcte dans CEPH</a></li>
<li><a href="../fr436498/index.html">Software AG: pas seulement ARIS</a></li>
<li><a href="../fr436500/index.html">Comment le cadre de Rise of the Tomb Raider est rendu</a></li>
<li><a href="../fr436502/index.html">Abonnement Pampers ou comment vendre plus aux mêmes clients</a></li>
<li><a href="../fr436504/index.html">Système en emballage ou contenu de l'emballage sous puce?</a></li>
<li><a href="../fr436506/index.html">Comment créer un IA-raciste sans trop d'effort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>