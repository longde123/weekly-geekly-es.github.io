<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèæ üë≤ ‚ùé Langkah pertama dengan Mesin Unicorn üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø üõÄüèº ü§üüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat mencari "Mesin Unicorn" di Habr, saya terkejut menemukan bahwa alat ini tidak pernah ditampilkan dalam artikel. Saya akan mencoba mengisi kekoson...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Langkah pertama dengan Mesin Unicorn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431058/"><p>  Saat mencari "Mesin Unicorn" di Habr, saya terkejut menemukan bahwa alat ini tidak pernah ditampilkan dalam artikel.  Saya akan mencoba mengisi kekosongan ini.  Mari kita mulai dengan dasar-dasarnya, dan lihat contoh menggunakan emulator di kehidupan nyata.  Agar tidak menemukan kembali roda, saya memutuskan untuk hanya menerjemahkan manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  <em>Sebelum memulai, saya akan mengatakan bahwa semua komentar atau komentar saya akan terlihat seperti ini</em> . </p><a name="habracut"></a><br><h1 id="chto-takoe-unicorn-engine">  Apa itu Mesin Unicorn? </h1><br><p>  <em>Para pengembang sendiri menulis tentang</em> <del>  <em>Mesin unicorn</em> </del>  <em>Unicorn Engine menyukai ini:</em> </p><br><blockquote>  Unicorn adalah emulator prosesor ringan, multi-platform dan multi-arsitektur. </blockquote><p>  Ini bukan emulator standar.  Itu tidak meniru operasi seluruh program atau seluruh OS.  Itu tidak mendukung perintah sistem (seperti membuka file, mengeluarkan karakter ke konsol, dll.).  Anda harus melakukan markup memori dan memuat data ke dalamnya sendiri, dan kemudian Anda cukup memulai eksekusi dari beberapa alamat tertentu. </p><br><p>  Jadi bagaimana manfaatnya? </p><br><ul><li>  Saat menganalisis virus, Anda dapat memanggil fungsi tunggal tanpa membuat proses berbahaya. </li><li>  Untuk mengatasi CTF. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk fuzzing</a> . </li><li>  <a href="">Plugin untuk gdb</a> untuk memprediksi keadaan masa depan, misalnya, hop masa depan atau nilai register. </li><li>  Emulasi kode kaya fitur. </li></ul><br><p>  Apa yang kamu butuhkan </p><br><ul><li>  Diinstal Mesin Unicorn dengan Python mengikat. </li><li>  Disassembler </li></ul><br><h1 id="primer">  Contoh </h1><br><p>  Sebagai contoh, ambil tugas dengan hxp CTF 2017 dengan nama <strong><em>Fibonacci</em></strong> .  Biner dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Ketika Anda memulai program, itu mulai menampilkan bendera kami di konsol, tetapi sangat lambat.  Setiap byte bendera berikutnya dianggap lebih lambat dan lebih lambat. </p><br><pre><code class="bash hljs">The flag is: hxp{F</code> </pre> <br><p>  Ini berarti bahwa untuk mendapatkan bendera dalam jumlah waktu yang wajar, kita perlu mengoptimalkan pengoperasian aplikasi ini. </p><br><p>  Menggunakan IDA Pro ( <em>saya pribadi menggunakan radare2 + Cutter</em> ) kami mendekompilasi kode menjadi pseudocode seperti-C.  Terlepas dari kenyataan bahwa kode tidak diurai dengan benar, kita masih bisa mendapatkan informasi darinya tentang apa yang terjadi di dalam. </p><br><div class="spoiler">  <b class="spoiler_title">Kode yang didekompilasi</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__int64 a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v3; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 int v4; // ebx@1 signed __int64 v5; // r8@2 char v6; // r9@3 __int64 v7; // r8@3 char v8; // cl@3 __int64 v9; // r9@5 int a2a; // [sp+Ch] [bp-1Ch]@3 v3 = &amp;encrypted_flag; v4 = 0; setbuf(stdout, 0LL); printf("The flag is: ", 0LL); while ( 1 ) { LODWORD(v5) = 0; do { a2a = 0; fibonacci(v4 + v5, &amp;a2a); v8 = v7; v5 = v7 + 1; } while ( v5 != 8 ); v4 += 8; if ( (unsigned __int8)(a2a &lt;&lt; v8) == v6 ) break; v3 = (char *)v3 + 1; _IO_putc((char)(v6 ^ ((_BYTE)a2a &lt;&lt; v8)), stdout); v9 = *((char *)v3 - 1); } _IO_putc(10, stdout); return 0LL; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, _DWORD *a2)</span></span></span><span class="hljs-function"> </span></span>{ _DWORD *v2; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 unsigned int v3; // er12@3 unsigned int result; // eax@3 unsigned int v5; // edx@3 unsigned int v6; // esi@3 unsigned int v7; // edx@4 v2 = a2; if ( i ) { if ( i == 1 ) { result = fibonacci(0, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } else { v3 = fibonacci(i - 2, a2); result = v3 + fibonacci(i - 1, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } v7 = v6 + (v5 &amp; 0x33333333) + ((v6 + (v5 &amp; 0x33333333)) &gt;&gt; 4); *v2 ^= ((BYTE1(v7) &amp; 0xF) + (v7 &amp; 0xF) + (unsigned __int8)((((v7 &gt;&gt; 8) &amp; 0xF0F0F) + (v7 &amp; 0xF0F0F0F)) &gt;&gt; 16)) &amp; 1; } else { *a2 ^= 1u; result = 1; } return result; }</span></span></code> </pre> </div></div><br><p>  Berikut adalah kode assembler dari fungsi <em>utama</em> dan <em>Fibonacci</em> : </p><br><div class="spoiler">  <b class="spoiler_title">utama</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x4004E0 main proc near ; DATA XREF: start+1Do .text:0x4004E0 .text:0x4004E0 var_1C = dword ptr -1Ch .text:0x4004E0 .text:0x4004E0 push rbp .text:0x4004E1 push rbx .text:0x4004E2 xor esi, esi ; buf .text:0x4004E4 mov ebp, offset unk_4007E1 .text:0x4004E9 xor ebx, ebx .text:0x4004EB sub rsp, 18h .text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x4004FB mov edi, offset format ; "The flag is: " .text:0x400500 xor eax, eax .text:0x400502 call _printf .text:0x400507 mov r9d, 49h .text:0x40050D nop dword ptr [rax] .text:0x400510 .text:0x400510 loc_400510: ; CODE XREF: main+8Aj .text:0x400510 xor r8d, r8d .text:0x400513 jmp short loc_40051B .text:0x400513 ; --------------------------------------------------------------------------- .text:0x400515 align 8 .text:0x400518 .text:0x400518 loc_400518: ; CODE XREF: main+67j .text:0x400518 mov r9d, edi .text:0x40051B .text:0x40051B loc_40051B: ; CODE XREF: main+33j .text:0x40051B lea edi, [rbx+r8] .text:0x40051F lea rsi, [rsp+28h+var_1C] .text:0x400524 mov [rsp+28h+var_1C], 0 .text:0x40052C call fibonacci .text:0x400531 mov edi, [rsp+28h+var_1C] .text:0x400535 mov ecx, r8d .text:0x400538 add r8, 1 .text:0x40053C shl edi, cl .text:0x40053E mov eax, edi .text:0x400540 xor edi, r9d .text:0x400543 cmp r8, 8 .text:0x400547 jnz short loc_400518 .text:0x400549 add ebx, 8 .text:0x40054C cmp al, r9b .text:0x40054F mov rsi, cs:stdout ; fp .text:0x400556 jz short loc_400570 .text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc .text:0x400565 movzx r9d, byte ptr [rbp-1] .text:0x40056A jmp short loc_400510 .text:0x40056A ; --------------------------------------------------------------------------- .text:0x40056C align 10h .text:0x400570 .text:0x400570 loc_400570: ; CODE XREF: main+76j .text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc .text:0x40057A add rsp, 18h .text:0x40057E xor eax, eax .text:0x400580 pop rbx .text:0x400581 pop rbp .text:0x400582 retn .text:0x400582 main endp</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">fibonacci</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x400670 fibonacci proc near ; CODE XREF: main+4Cp .text:0x400670 ; fibonacci+19p ... .text:0x400670 test edi, edi .text:0x400672 push r12 .text:0x400674 push rbp .text:0x400675 mov rbp, rsi .text:0x400678 push rbx .text:0x400679 jz short loc_4006F8 .text:0x40067B cmp edi, 1 .text:0x40067E mov ebx, edi .text:0x400680 jz loc_400710 .text:0x400686 lea edi, [rdi-2] .text:0x400689 call fibonacci .text:0x40068E lea edi, [rbx-1] .text:0x400691 mov r12d, eax .text:0x400694 mov rsi, rbp .text:0x400697 call fibonacci .text:0x40069C add eax, r12d .text:0x40069F mov edx, eax .text:0x4006A1 mov ebx, eax .text:0x4006A3 shr edx, 1 .text:0x4006A5 and edx, 55555555h .text:0x4006AB sub ebx, edx .text:0x4006AD mov ecx, ebx .text:0x4006AF mov edx, ebx .text:0x4006B1 shr ecx, 2 .text:0x4006B4 and ecx, 33333333h .text:0x4006BA mov esi, ecx .text:0x4006BC .text:0x4006BC loc_4006BC: ; CODE XREF: fibonacci+C2j .text:0x4006BC and edx, 33333333h .text:0x4006C2 lea ecx, [rsi+rdx] .text:0x4006C5 mov edx, ecx .text:0x4006C7 shr edx, 4 .text:0x4006CA add edx, ecx .text:0x4006CC mov esi, edx .text:0x4006CE and edx, 0F0F0F0Fh .text:0x4006D4 shr esi, 8 .text:0x4006D7 and esi, 0F0F0Fh .text:0x4006DD lea ecx, [rsi+rdx] .text:0x4006E0 mov edx, ecx .text:0x4006E2 shr edx, 10h .text:0x4006E5 add edx, ecx .text:0x4006E7 and edx, 1 .text:0x4006EA xor [rbp+0], edx .text:0x4006ED pop rbx .text:0x4006EE pop rbp .text:0x4006EF pop r12 .text:0x4006F1 retn .text:0x4006F1 ; --------------------------------------------------------------------------- .text:0x4006F2 align 8 .text:0x4006F8 .text:0x4006F8 loc_4006F8: ; CODE XREF: fibonacci+9j .text:0x4006F8 mov edx, 1 .text:0x4006FD xor [rbp+0], edx .text:0x400700 mov eax, 1 .text:0x400705 pop rbx .text:0x400706 pop rbp .text:0x400707 pop r12 .text:0x400709 retn .text:0x400709 ; --------------------------------------------------------------------------- .text:0x40070A align 10h .text:0x400710 .text:0x400710 loc_400710: ; CODE XREF: fibonacci+10j .text:0x400710 xor edi, edi .text:0x400712 call fibonacci .text:0x400717 mov edx, eax .text:0x400719 mov edi, eax .text:0x40071B shr edx, 1 .text:0x40071D and edx, 55555555h .text:0x400723 sub edi, edx .text:0x400725 mov esi, edi .text:0x400727 mov edx, edi .text:0x400729 shr esi, 2 .text:0x40072C and esi, 33333333h .text:0x400732 jmp short loc_4006BC .text:0x400732 fibonacci endp</code> </pre> </div></div><br><p>  Pada tahap ini, kami memiliki banyak peluang untuk menyelesaikan masalah ini.  Sebagai contoh, kita dapat mengembalikan kode menggunakan salah satu bahasa pemrograman dan menerapkan optimisasi di sana, tetapi proses mengembalikan kode adalah tugas yang sangat sulit, di mana kita dapat membuat kesalahan.  Nah, kemudian membandingkan kode untuk menemukan kesalahan umumnya tidak berharga.  Tetapi, jika kita menggunakan Mesin Unicorn, maka kita dapat melewati tahap rekonstruksi kode dan menghindari masalah yang dijelaskan di atas.  Tentu saja, kita dapat menghindari masalah ini menggunakan frida atau menulis skrip untuk gdb, tetapi ini bukan tentang itu. </p><br><p>  Sebelum memulai optimasi, kami akan menjalankan persaingan di Unicorn Engine tanpa mengubah program.  Dan hanya setelah peluncuran yang sukses, mari beralih ke pengoptimalan. </p><br><h2 id="shag-1-da-priydet-virtualizaciya">  Langkah 1: Biarkan Virtualisasi Datang </h2><br><p>  Mari kita buat file fibonacci.py dan simpan di sebelah biner. </p><br><p>  Mari kita mulai dengan mengimpor perpustakaan yang diperlukan: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn.x86_const <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct</code> </pre> <br><p>  Baris pertama memuat konstanta Unicorn biner dan dasar.  Baris kedua memuat konstanta untuk dua arsitektur x86 dan x86_64. </p><br><p>  Selanjutnya, tambahkan beberapa fungsi yang diperlukan: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.unpack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, data)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.pack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, num)</code> </pre> <br><p>  Di sini kami mengumumkan fungsi yang akan kami butuhkan nanti: </p><br><ul><li>  <strong>baca</strong> cukup mengembalikan isi file, </li><li>  <strong>u32</strong> mengambil string 4-byte dalam LE encoding dan mengkonversi ke int, </li><li>  <strong>p32</strong> melakukan yang sebaliknya - ia mengambil angka dan mengubahnya menjadi string 4-byte dalam LE encoding. </li></ul><br><p>  Catatan: Jika Anda telah menginstal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pwntools</a> , maka Anda tidak perlu membuat fungsi-fungsi ini, Anda hanya perlu mengimpornya: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pwn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br><p>  Dan akhirnya, mari mulai menginisialisasi kelas Mesin Unicorn untuk arsitektur x86_64: </p><br><pre> <code class="python hljs">mu = Uc (UC_ARCH_X86, UC_MODE_64)</code> </pre> <br><p>  Di sini kita memanggil fungsi <strong>Uc</strong> dengan parameter berikut: </p><br><ul><li>  Parameter pertama adalah arsitektur utama.  Konstanta mulai dengan <strong>UC_ARCH_</strong> ; </li><li>  parameter kedua adalah spesifikasi arsitektur.  Konstanta mulai dengan <strong>UC_MODE_</strong> . </li></ul><br><p>  Anda dapat menemukan semua konstanta di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lembar contekan</a> . </p><br><p>  Seperti yang saya tulis di atas, untuk menggunakan Mesin Unicorn, kita perlu menginisialisasi memori virtual secara manual.  Untuk contoh ini, kita perlu menempatkan kode dan menumpuk di suatu tempat di memori. </p><br><p>  Alamat dasar (Basis addr) dari biner dimulai pada 0x400000.  Mari kita meletakkan tumpukan kita pada 0x0 dan mengalokasikan 1024 * 1024 memori untuk itu.  Kemungkinan besar, kita tidak membutuhkan begitu banyak ruang, tetapi tetap tidak sakit. </p><br><p>  Kita dapat menandai memori dengan memanggil metode <strong>mem_map</strong> . </p><br><p>  Tambahkan baris ini: </p><br><pre> <code class="python hljs">BASE = <span class="hljs-number"><span class="hljs-number">0x400000</span></span> STACK_ADDR = <span class="hljs-number"><span class="hljs-number">0x0</span></span> STACK_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span> mu.mem_map(BASE, <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>) mu.mem_map(STACK_ADDR, STACK_SIZE)</code> </pre> <br><p>  Sekarang kita perlu memuat biner ke alamat utamanya dengan cara yang sama seperti bootloader.  Setelah itu kita perlu mengatur <strong>RSP</strong> ke ujung tumpukan. </p><br><pre> <code class="python hljs">mu.mem_write(BASE, read(<span class="hljs-string"><span class="hljs-string">"./fibonacci"</span></span>)) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Sekarang kita dapat memulai emulasi dan menjalankan kodenya, tetapi kita perlu mencari tahu di mana alamat untuk mulai bekerja dan kapan emulator harus berhenti. </p><br><p>  Ambil alamat dari perintah pertama dari <strong>main ()</strong> , kita dapat memulai emulasi dari 0x004004e0.  Akhir akan dianggap sebagai panggilan ke <strong>putc ("\ n")</strong> , yang terletak di 0x00400575, setelah menampilkan seluruh bendera. </p><br><pre> <code class="plaintext hljs">.text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc</code> </pre> <br><p>  Kita dapat mulai meniru: </p><br><pre> <code class="python hljs">mu.emu_start(<span class="hljs-number"><span class="hljs-number">0x004004e0</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400575</span></span>)</code> </pre> <br><p>  Sekarang jalankan skrip: </p><br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 32, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  Ups, ada yang salah, tapi kami bahkan tidak tahu.  Tepat sebelum memanggil <strong>mu.emu_start,</strong> kita dapat menambahkan: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code)</code> </pre> <br><p>  Kode ini menambahkan kait.  Kita mendeklarasikan fungsi <strong>hook_code</strong> kita sendiri, yang dipanggil oleh emulator sebelum setiap perintah.  Dibutuhkan parameter berikut: </p><br><ul><li>  salinan <strong>Uc kami</strong> , </li><li>  alamat instruksi </li><li>  instruksi ukuran </li><li>  data pengguna (kami dapat meneruskan nilai ini dengan argumen opsional ke <strong>hook_add ()</strong> ). <br>  Sekarang, jika kita menjalankan skrip, kita akan melihat output berikut: <br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py &gt;&gt;&gt; Tracing instruction at 0x4004e0, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e1, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e2, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004e4, instruction size = 0x5 &gt;&gt;&gt; Tracing instruction at 0x4004e9, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004eb, instruction size = 0x4 &gt;&gt;&gt; Tracing instruction at 0x4004ef, instruction size = 0x7 Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 41, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  Di alamat tempat kesalahan terjadi, kita dapat memahami bahwa skrip kami tidak dapat memproses perintah ini: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream</code> </pre> <br><p>  Instruksi ini membaca data dari alamat 0x601038 (Anda dapat melihatnya di IDA Pro).  Ini adalah bagian <strong>.bss</strong> yang tidak kami tandai.  Solusi saya adalah dengan hanya melewatkan semua instruksi yang bermasalah jika ini tidak mempengaruhi logika program. <br>  Di bawah ini adalah instruksi bermasalah lainnya: <br></p><pre> <code class="plaintext hljs">.text:0x4004F6 call _setbuf</code> </pre> <br><p>  Kami tidak dapat memanggil fungsi apa pun dengan glibc, karena kami tidak memiliki glibc yang dimuat dalam memori.  Bagaimanapun, kita tidak memerlukan perintah ini, jadi kita juga bisa melewatinya. <br>  Berikut daftar lengkap perintah yang harus dilewati: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x400502 call _printf .text:0x40054F mov rsi, cs:stdout ; fp</code> </pre> <br><p>  Untuk melewati perintah, kita perlu menulis ulang <strong>RIP</strong> dengan instruksi berikut: <br></p><pre> <code class="python hljs">mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Sekarang <strong>hook_code</strong> akan terlihat seperti ini: </p><br><p></p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Kita juga perlu melakukan sesuatu dengan instruksi yang menampilkan bendera di konsol byte-by-byte. </p><br><pre> <code class="plaintext hljs">.text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">__IO_putc</a> mengambil byte untuk keluaran sebagai <strong>argumen pertama</strong> (ini adalah register <strong>RDI</strong> ). </p><br><p>  Kita dapat membaca data secara langsung dari register, menampilkan data ke konsol dan melewati set instruksi ini.  Kode <strong>kait yang</strong> diperbarui disajikan di bawah ini: </p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print('&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) elif address == 0x400560: # c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size)</span></span></code> </pre> <br><p>  Kita bisa berlari dan semuanya akan bekerja, tetapi masih lambat. </p><br><h1 id="shag-2-uvelichim-skorost">  Langkah 2: Tingkatkan Kecepatan! </h1><br><p>  Mari kita pikirkan tentang meningkatkan kecepatan kerja.  Mengapa program ini sangat lambat? </p><br><p>  Jika kita melihat kode yang didekompilasi, kita akan melihat bahwa <strong>main ()</strong> memanggil <strong>fibonacci ()</strong> beberapa kali dan <strong>fibonacci ()</strong> adalah fungsi rekursif.  Mari kita melihat lebih dekat fungsi ini, ia mengambil dan mengembalikan dua argumen.  Nilai pengembalian pertama dilewatkan melalui register <strong>RAX</strong> , yang kedua dikembalikan melalui tautan yang dilewatkan melalui argumen kedua ke fungsi.  Jika kita melihat lebih dalam pada hubungan antara <strong>main ()</strong> dan <strong>fibonacci ()</strong> , maka kita akan melihat bahwa argumen kedua hanya mengambil dua nilai yang mungkin: 0 atau 1. Jika Anda masih tidak melihat ini, jalankan <strong>gdb</strong> dan letakkan breakpoint di awal fungsi <strong>Fibonacci ()</strong> . </p><br><p>  Untuk mengoptimalkan operasi algoritma, kita dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman dinamis</a> untuk mengingat nilai kembali untuk parameter yang masuk.  Pikirkan sendiri, argumen kedua hanya dapat mengambil dua nilai yang mungkin, jadi yang harus kita lakukan adalah mengingat <math> </math> $ inline $ 2 * MAX \ _OF \ _FIRST \ _ARGUMENT $ inline $   kukus </p><br><div class="spoiler">  <b class="spoiler_title">Bagi yang tidak mengerti</b> <div class="spoiler_text"><p>  <strong>fibonacci</strong> adalah fungsi rekursif yang menghitung nilai selanjutnya sebagai jumlah dari dua sebelumnya.  Di setiap langkah dia melangkah lebih dalam.  Setiap kali dia memulai, dia berjalan dengan cara yang sama seperti sebelumnya, ditambah satu makna baru. </p><br><p>  Contoh: <br>  Asumsikan kedalaman = 6, maka: <strong>1 1 2 3 5 8</strong> . <br>  Dan sekarang depth = 8, lalu: <strong>1 1 2 3 5 8</strong> 13 21. </p><br><p>  Kita hanya dapat mengingat bahwa 6 anggota pertama adalah <strong>1 1 2 3 5 8</strong> , dan ketika mereka meminta kita untuk menghitung lebih dari yang kita ingat, kita mengambil apa yang kita ingat dan hanya mempertimbangkan apa yang hilang. </p></div></div><br><p>  Setelah <strong>RIP</strong> berada di awal <strong>fibonacci ()</strong> , kita bisa mendapatkan argumen fungsi.  Kita tahu bahwa suatu fungsi mengembalikan hasil ketika ia keluar dari suatu fungsi.  Karena kita tidak dapat beroperasi dengan dua parameter sekaligus, kita perlu tumpukan untuk mengembalikan parameter.  Ketika kita memasukkan <strong>fibonacci (),</strong> kita perlu meletakkan argumen di stack, dan mengambilnya ketika kita keluar.  Untuk menyimpan pasangan yang dihitung, kita dapat menggunakan kamus. </p><br><p>  Bagaimana cara memproses sepasang nilai? </p><br><ul><li>  Di awal fungsi, kita dapat memeriksa apakah pasangan ini dalam hasil yang sudah kita ketahui: <br><ul><li>  jika ada, maka kita dapat mengembalikan pasangan ini.  Kami hanya perlu menulis nilai kembali di <strong>RAX</strong> dan di alamat tautan, yang ada di argumen kedua.  Kami juga menetapkan alamat <strong>RIP</strong> untuk keluar dari fungsi.  Kami tidak dapat menggunakan <strong>RET</strong> di <strong>fibonacci ()</strong> , karena panggilan ini terhubung, jadi kami akan mengambil beberapa <strong>RET</strong> dari <strong>main ()</strong> ; </li><li>  jika nilai-nilai ini tidak, maka kita cukup menambahkannya ke stack. </li></ul></li><li>  Sebelum keluar dari fungsi, kita dapat menyimpan pasangan yang dikembalikan.  Kami tahu argumen input, karena kami bisa membacanya dari tumpukan kami. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Kode ini disajikan di sini.</b> <div class="spoiler_text"><pre> <code class="python hljs">FIBONACCI_ENTRY = <span class="hljs-number"><span class="hljs-number">0x00400670</span></span> FIBONACCI_END = [ <span class="hljs-number"><span class="hljs-number">0x004006f1</span></span>, <span class="hljs-number"><span class="hljs-number">0x00400709</span></span>] instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET ,       fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref)</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Inilah keseluruhan skripnya</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack("I", data)[0] def p32(num): return struct.pack("I", num) FIBONACCI_ENTRY = 0x00400670 FIBONACCI_END = [ 0x004006f1, 0x00400709] instructions_skip_list = [0x004004ef,0x004004f6,0x00400502,0x0040054f] #     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET .     fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref) mu = Uc (UC_ARCH_X86, UC_MODE_64) BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read("./fibonacci")) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x004004e0, 0x00400575) print()</span></span></code> </pre></div></div><br><p>  Hore, kami akhirnya dapat mengoptimalkan aplikasi menggunakan Mesin Unicorn.  Kerja bagus! </p><br><h1 id="zametka">  Sebuah catatan </h1><br><p>  Sekarang saya memutuskan untuk memberi Anda sedikit pekerjaan rumah. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini Anda dapat menemukan</a> tiga tugas lagi, masing-masing memiliki petunjuk dan solusi lengkap.  Anda dapat mengintip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lembar contekan</a> sambil menyelesaikan masalah. </p><br><p>  Salah satu masalah yang paling menyebalkan adalah mengingat nama konstanta yang diinginkan.  Ini mudah ditangani jika Anda menggunakan add-on Tab di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IPython</a> .  Ketika Anda menginstal IPython, Anda dapat menulis <strong>dari unicorn import UC_ARCH_</strong> tekan Tab dan Anda akan <strong>ditampilkan</strong> semua konstanta yang memulai dengan cara yang sama. </p><p></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431058/">https://habr.com/ru/post/id431058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431046/index.html">Bagaimana z-index sebenarnya bekerja</a></li>
<li><a href="../id431048/index.html">Mesin acara menjaga siklus hidup</a></li>
<li><a href="../id431050/index.html">Ilusi kemurnian: apakah mineralisasi air mempengaruhi kualitasnya, dan bagaimana meter TDS akan membantu kita?</a></li>
<li><a href="../id431052/index.html">Frontend DevDay: Maps, Teams, Two Queries</a></li>
<li><a href="../id431056/index.html">USPACE: Waktu Drone</a></li>
<li><a href="../id431060/index.html">German ID spoofing dengan otentikasi online dan pendanaan pengungsi di Jerman</a></li>
<li><a href="../id431064/index.html">Manifesto Programmer yang Kaku</a></li>
<li><a href="../id431066/index.html">DEFCON 16. Bagaimana saya bisa menghubungi Anda? Biarkan saya daftar caranya. Bagian 2</a></li>
<li><a href="../id431068/index.html">Seni pendidikan: ideologi mesin slot</a></li>
<li><a href="../id431070/index.html">Hara makan? Kita berbicara tentang kebiasaan makan seorang spesialis IT modern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>