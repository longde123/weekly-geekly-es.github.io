<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüî¨ üìπ üÜï Secret du firmware üõÑ üë©üèΩ ü¶á</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auteurs: Ph.D. Chernov A.V. ( monsieur_cher ) et Ph.D. Troshina K.N. 

 Comment, en utilisant les hypoth√®ses les plus g√©n√©rales bas√©es sur la connaiss...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Secret du firmware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/442262/">  <b>Auteurs: Ph.D.</b>  <b>Chernov A.V.</b>  <b>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">monsieur_cher</a> ) et Ph.D.</b>  <b>Troshina K.N.</b> <br><br>  <b>Comment, en utilisant les hypoth√®ses les plus g√©n√©rales bas√©es sur la connaissance des architectures de processeur modernes, pouvez-vous restaurer la structure du programme √† partir d'une image binaire d'une architecture inconnue, puis restaurer des algorithmes et bien plus encore?</b> <br><br>  Dans cet article, nous parlerons d'une t√¢che int√©ressante qui nous a √©t√© confi√©e il y a plusieurs ann√©es.  Le client a demand√© √† g√©rer le micrologiciel binaire de l'appareil qui g√©rait un certain processus physique.  Il avait besoin d'un algorithme de contr√¥le sous la forme d'un programme C compil√©, ainsi que de formules expliquant comment elles fonctionnent et pourquoi.  Selon le Client, cela √©tait n√©cessaire pour assurer la compatibilit√© avec les "anciens" √©quipements du nouveau syst√®me.  La fa√ßon dont nous avons finalement trait√© la physique, dans le cadre de cette s√©rie d'articles, nous omettons, mais le processus de r√©cup√©ration de l'algorithme sera examin√© en d√©tail. <br><br>  L'utilisation presque omnipr√©sente des microcontr√¥leurs programmables dans les appareils de masse (IOT ou SmartHome Internet of Things) n√©cessite de pr√™ter attention √† l'analyse binaire du code int√©gr√©, ou, en d'autres termes, √† l'analyse binaire du micrologiciel de l'appareil. <br><br>  Une analyse binaire du micrologiciel de l'appareil peut avoir les objectifs suivants: <br><br><ul><li>  Analyse du code des vuln√©rabilit√©s permettant d'acc√©der de fa√ßon non autoris√©e √† l'appareil ou aux donn√©es transmises ou trait√©es par cet appareil. </li><li>  Analyse de code pour les fonctionnalit√©s non document√©es, conduisant, par exemple, √† une fuite d'informations. </li><li>  Analyse de code pour restaurer les protocoles et interfaces d'interaction avec les appareils afin d'assurer la compatibilit√© de cet appareil avec les autres. </li></ul><br>  La t√¢che d'analyse de code binaire pr√©sent√©e ci-dessus peut √™tre consid√©r√©e comme un cas particulier de la t√¢che d'analyse binaire pour garantir la compatibilit√© des p√©riph√©riques. <br><a name="habracut"></a><br><h4>  Analyse du format de fichier binaire </h4><br>  Si dans le monde des ¬´vrais¬ª syst√®mes d'exploitation, les formats de fichiers ex√©cutables sont standardis√©s, alors dans le monde des programmes embarqu√©s, chaque fournisseur peut utiliser sa solution propri√©taire.  Par cons√©quent, l'analyse du fichier de micrologiciel binaire doit commencer par l'analyse du format de fichier binaire. <br><br>  Au d√©but des travaux, la situation pour nous √©tait la suivante: nous avons re√ßu un certain fichier avec le firmware sans aucune documentation d'accompagnement.  Il n'y avait aucune information sur le format du fichier du firmware, ni sur l'architecture du microcontr√¥leur. <br><br>  Le fichier du firmware s'est av√©r√© √™tre un fichier texte.  Il contenait des lignes de la forme suivante: <br><br><pre><code class="tex hljs">:04013000260F970CF8 :10020000004D000B043F000B34AD010C002FFE4D30 :02023000FD0BC1 :1004000018001A0000001E0008005E000200190052</code> </pre> <br>  Apr√®s avoir soigneusement examin√© l'ensemble de ces lignes, nous avons r√©alis√© qu'il s'agit d'un format Intel HEX enti√®rement standard pour les microcontr√¥leurs.  Le fichier se compose d'enregistrements, chacun indiquant son type, son emplacement m√©moire, ses donn√©es et sa somme de contr√¥le.  En soi, l'utilisation du format Intel Hex implique que le fichier n'est probablement pas chiffr√© et est une image d'un programme qui r√©side en m√©moire. <br><br>  Bien que le format Intel Hex prenne en charge l'adressage m√©moire jusqu'√† 32 bits, il n'y avait que des adresses m√©moire 16 bits dans notre fichier.  Par cons√©quent, il est facile de cr√©er un fichier binaire d'une image m√©moire √† partir d'un fichier texte dans lequel les enregistrements du fichier de test d'origine seront d√©j√† plac√©s aux adresses sp√©cifi√©es.  Il est plus pratique d'inspecter un tel fichier binaire √† l'aide des utilitaires d'analyse de fichier binaire, et il est plus facile d'√©crire vos propres utilitaires pour celui-ci que pour Intel HEX.  Le fichier de m√©moire d'image binaire a confirm√© que le fichier n'√©tait pas chiffr√©, car une vari√©t√© de lignes significatives ont √©t√© trouv√©es dispers√©es √† diff√©rents endroits du code. <br>  Cependant, cela n'a pas r√©pondu √† la question de savoir quelle architecture ce fichier est. <br><br><img src="https://habrastorage.org/webt/25/6a/cq/256acqp6bgydpoj5ju-vwvc97gq.jpeg"><br><br>  Nous avons obtenu un fichier avec l'image m√©moire d'un microcontr√¥leur 16 bits ou 8 bits.  Et quel type de microcontr√¥leur n'est pas clair.  Nous avons pris IDA Pro et essay√© de d√©monter le fichier avec toutes les variantes possibles de processeurs pris en charge.  Et rien.  Aucun des processeurs IDA Pro pris en charge n'est apparu: la liste n'a pas √©t√© g√©n√©r√©e ou elle contenait un non-sens √©vident.  Il s'agissait peut-√™tre d'un programme pour l'un des processeurs IDA Pro pris en charge, mais nous avons fait quelque chose de mal.  Par exemple, vous avez juste besoin d'un traitement suppl√©mentaire du fichier image.  Dans tous les cas, il √©tait possible ici de suspendre le travail et de demander des informations suppl√©mentaires sur le fichier binaire. <br><br><h4>  Tous les processeurs sont √† peu pr√®s les m√™mes. </h4><br>  Mais cela est devenu int√©ressant pour nous, et ce que nous pouvons comprendre du programme binaire, m√™me si le processeur pour lequel il est compil√© est inconnu.  La r√©ponse est ¬´rien¬ª - sans int√©r√™t, m√™me si nous pouvons comprendre un peu, c'est mieux que rien.  √âvidemment, les cha√Ænes de texte peuvent fournir des informations sur le programme, mais nous visons plus - comprendre quelque chose de la structure du programme. <br>  Diff√©rentes architectures de processeur - un grand nombre.  L'√©volution de l'informatique a g√©n√©r√© m√™me les architectures les plus inhabituelles telles que les ordinateurs ternaires.  Cependant, les microprocesseurs et microcontr√¥leurs qui existent actuellement, au moins ceux de masse, sont remarquablement similaires les uns aux autres. <br><br>  Ci-dessous, nous √©num√©rons les principes de base communs aux microprocesseurs modernes. <br><br>  Ex√©cution coh√©rente des instructions.  Le processeur ex√©cute les instructions en s√©quence dans la m√©moire.  Il existe des instructions sp√©ciales pour les sauts et appels conditionnels et inconditionnels √† partir du sous-programme, qui vous permettent d'interrompre la s√©lection s√©quentielle des instructions de la m√©moire et de proc√©der √† l'ex√©cution d'une autre instruction.  Cependant, les autres instructions supposent une ex√©cution s√©quentielle et ne contiennent donc pas l'adresse de l'instruction suivante. <br><br>  <i>Codage binaire.</i>  Outre le fait que le processeur traite les donn√©es sous forme binaire, les instructions du processeur qui composent le programme ex√©cutable sont cod√©es au format binaire, c'est-√†-dire que les champs dans lesquels les param√®tres d'instruction sont stock√©s, par exemple les d√©calages ou les num√©ros de registre, occupent un nombre entier de bits.  On peut th√©oriquement imaginer que, malgr√© l'encodage binaire des donn√©es et des programmes, ils seront trait√©s dans le processeur dans un autre syst√®me num√©rique, mais nous ne sommes pas conscients d'une telle exotisme. <br><br>  En r√®gle g√©n√©rale, les principes suivants ne sont pas des principes architecturaux de base, mais ils sont pratiquement universellement mis en ≈ìuvre, en particulier pour le code machine qui n'est pas √©crit manuellement en langage assembleur, mais qui est g√©n√©r√© par un compilateur de langage de haut niveau. <br><br>  <i>Programmation proc√©durale.</i>  Le programme est divis√© en unit√©s structurelles, qui peuvent √™tre appel√©es diff√©remment: proc√©dures, fonctions, sous-programmes, etc. Les sous-programmes peuvent appeler d'autres sous-programmes, leur transmettre des param√®tres et obtenir le r√©sultat de l'ex√©cution.  Il est important que le sous-programme ait un point d'entr√©e, c'est-√†-dire que tous les sous-programmes qui invoquent celui donn√© vont √† la m√™me adresse de point d'entr√©e. <br><br>  En r√®gle g√©n√©rale, les routines ont un point de sortie qui renvoie le contr√¥le au point d'appel, mais cela est moins important que d'exiger un point d'entr√©e pour chaque routine.  Un tel code est g√©n√©ralement obtenu en compilant un programme.  L'optimiseur de temps de liaison peut d√©truire partiellement cette structure pour r√©duire la taille du programme, et la taille du programme est critique pour les syst√®mes embarqu√©s.  De plus, cette structure peut √™tre d√©truite par l'obfuscateur de code. <br><br>  L'imbrication des appels de sous-programme peut √™tre organis√©e √† l'aide de la pile, qui peut toujours √™tre utilis√©e pour transmettre des arguments au sous-programme et stocker des variables locales, mais au niveau actuel de d√©veloppement de l'architecture, ces informations sont pr√©matur√©es. <br><br>  Comment appliquer ces principes √† l'analyse initiale du code binaire? <br><br>  Nous faisons l'hypoth√®se de base qu'il existe une instruction RET (retour d'un sous-programme) dans le syst√®me de commande du processeur.  Cette instruction a une sorte de repr√©sentation binaire fixe, que nous allons rechercher.  Si RET n'est pas le seul, comme dans x86, o√π RET a un argument - la taille de la zone de param√®tres de sous-programme, ou si RET est un effet secondaire d'une op√©ration plus compliqu√©e, comme dans ARMv7, o√π la valeur PC peut √™tre extraite de la pile simultan√©ment avec les valeurs des autres registres (ldmfd sp! , {fp, pc}), alors, tr√®s probablement, notre recherche heuristique ne donnera pas de r√©sultats. <br><br>  Nous devons √©galement √©mettre imm√©diatement des hypoth√®ses raisonnables sur le principe des instructions de codage du processeur √† l'√©tude.  Les processeurs existants utilisent plusieurs principes pour coder les instructions: <br><br><ul><li>  Un flux d'octets √† partir duquel des instructions sont g√©n√©r√©es et diff√©rentes instructions sont cod√©es avec un nombre d'octets diff√©rent.  Dans cette cat√©gorie, le repr√©sentant le plus c√©l√®bre est la famille x86, des premiers processeurs 8080 aux processeurs 64 bits les plus modernes.  Une instruction de processeur x86_64 peut √™tre cod√©e dans une s√©quence de 1 √† 16 octets.  La m√™me famille de processeurs avec des longueurs d'instruction variables comprend 8051, qui est utilis√© dans les microcontr√¥leurs. </li><li>  Un flux de valeurs 16 bits.  De plus, chaque instruction a une taille fixe - 16 bits. </li><li>  Un flux de valeurs 16 bits, tandis que les instructions sont de taille variable.  L'un des repr√©sentants de cette famille est l'architecture PDP-11, dans laquelle la commande elle-m√™me occupe les 16 premiers bits, et elle peut √™tre suivie de valeurs directes ou d'adresses de m√©moire pour l'adressage direct.  Cela inclut le codage THUMB dans l'architecture ARM. </li><li>  Un flux de valeurs 32 bits, chaque instruction a une taille fixe de 32 bits.  Ce sont la majorit√© des processeurs RISC 32 et 64 bits: ARMv7, ARMv8, MIPS. </li></ul><br>  Choisir entre un flux d'octets de longueur variable et un flux de mots de 16 bits aidera √† visualiser l'image m√©moire ¬´√† l'≈ìil nu¬ª.  Peu importe la fa√ßon dont les instructions du processeur sont encod√©es, dans un programme d'une longueur suffisante, elles seront in√©vitablement r√©p√©t√©es.  Par exemple, sur l'instruction x86 <br><br><pre> <code class="tex hljs">add <span class="hljs-comment"><span class="hljs-comment">%ebx,%eax</span></span></code> </pre> <br>  qui ajoute les valeurs des registres eax et ebx et met le r√©sultat dans eax, est cod√© sur deux octets: <br><br><pre> <code class="tex hljs">01 d8.</code> </pre> <br>  Sur l'instruction ARMv7 <br><br><pre> <code class="tex hljs">add r0, r0, r1</code> </pre> <br>  qui ajoute les valeurs des registres r0 et r1 et place le r√©sultat dans r0, est cod√© par la valeur 32 bits e0800001. <br><br>  Dans un programme suffisamment volumineux, ces instructions seront r√©p√©t√©es plusieurs fois.  Si une s√©quence d'octets qui nous int√©resse (par exemple, 01 d8) se produit √† une adresse arbitraire non align√©e, nous pouvons supposer que les instructions du processeur sont cod√©es par un flux d'octets de taille variable.  Si la valeur, par exemple, e0800001 est trouv√©e uniquement √† des adresses qui sont des multiples de 4, nous pouvons faire une hypoth√®se sur une taille fixe d'instructions de processeur.  Bien s√ªr, il y a une erreur ici: nous avons pris des octets de donn√©es pour une instruction, ou c'est arriv√© par hasard que certaines instructions se sont toujours av√©r√©es align√©es.  Cependant, l'impact d'un tel ¬´bruit¬ª sur un programme de taille suffisante sera faible. <br><br>  Lorsque nous avons examin√© le micrologiciel analys√© sous cet angle, il est devenu clair que les instructions pour le processeur en question sont probablement cod√©es avec des valeurs 16 bits. <br><br>  Donc, en supposant que le codage de l'instruction RET est une valeur fixe de 16 bits, essayons de la trouver.  On retrouve dans l'image du programme les valeurs 16 bits les plus courantes.  Dans notre cas, les √©v√©nements suivants se sont produits: <br><br><pre> <code class="tex hljs"> (hex)   0b01 854 5.1<span class="hljs-comment"><span class="hljs-comment">% 0800 473 2.8% 8c0d 432 2.6% 2b00 401 2.4% 4e1c 365 2.2% 0801 277 1.6%</span></span></code> </pre><br>  Nous rechercherons l'instruction RET parmi ces valeurs 16 bits les plus souvent rencontr√©es dans le code.  Imm√©diatement, nous chercherons l'instruction CALL - coupl√©e √† l'instruction RET.  L'instruction CALL a au moins un param√®tre - l'adresse de saut, donc des valeurs fixes sont indispensables. <br><br>  Nous supposons que dans de nombreux cas, imm√©diatement apr√®s la fin d'un sous-programme, c'est-√†-dire apr√®s l'instruction RET, un autre sous-programme commence et ce sous-programme est appel√© par l'instruction CALL √† partir d'un autre point du programme.  Un grand nombre de sauts √† l'adresse imm√©diatement apr√®s RET sera l'une des caract√©ristiques de l'instruction CALL.  Bien s√ªr, cette r√®gle n'est pas universelle, car sur certaines plates-formes, en particulier ARMv7, imm√©diatement apr√®s la fin du sous-programme, un pool constant est g√©n√©ralement localis√©.  Dans ce cas, nous pouvons consid√©rer une plage d'adresses raisonnable imm√©diatement apr√®s RET comme points de transition de l'instruction RET. <br><br>  Dans le cas de l'instruction CALL, il peut y avoir beaucoup d'options pour l'encoder dans le sous-programme.  Premi√®rement, le processeur peut utiliser un ordre d'octets diff√©rent dans le mot: little-endian, comme sur la plupart des processeurs modernes, quand un entier multi-octets est √©crit en m√©moire, en commen√ßant par l'octet bas, et big-endian, quand un entier multi-octets est √©crit en m√©moire, en commen√ßant d'octet √©lev√©.  Presque tous les processeurs modernes fonctionnent en mode petit-boutiste, mais vous ne devez pas ignorer d'autres ordres d'octets possibles en un mot. <br>  Deuxi√®mement, l'instruction CALL peut utiliser soit l'adressage absolu du point de saut, soit l'adressage relatif √† l'adresse actuelle.  Dans le cas d'un adressage absolu, l'instruction cod√©e contient l'adresse √† laquelle vous souhaitez vous rendre dans certains bits de l'instruction cod√©e.  Pour garantir que le sous-programme est appel√© de n'importe quel point de l'espace d'adressage 16 bits vers n'importe quel autre point √† l'adresse absolue du mot 16 bits, l'instruction cod√©e n'est pas suffisante, car en plus de l'adresse de transition, les bits du code d'op√©ration doivent √™tre stock√©s ailleurs.  Par cons√©quent, il est logique de consid√©rer deux mots de 16 bits d'affil√©e et d'essayer diff√©rentes options pour diviser l'adresse de transition entre ces mots. <br><br>  Une alternative au codage absolu d'une adresse de routine est le codage relatif.  Dans l'instruction cod√©e, nous enregistrons la diff√©rence entre l'adresse du sous-programme et le point courant.  Le codage relatif est g√©n√©ralement pr√©f√©rable √† l'absolu, car, tout d'abord, un programme avec des transitions relatives est ind√©pendant de la position, c'est-√†-dire qu'il peut √™tre localis√© en m√©moire √† partir de n'importe quelle adresse sans aucune modification du code binaire.  Deuxi√®mement, pour coder l'offset, moins de bits peuvent √™tre r√©serv√©s que la dimension de l'espace d'adressage, du fait que dans de nombreux cas la routine appel√©e n'est pas si √©loign√©e de celle qui appelle.  Cependant, si le d√©calage de l'appel est en dehors de la plage de valeurs repr√©sentables, vous devrez ins√©rer des instructions sp√©ciales - ¬´sauts¬ª. <br><br>  Le codage relatif d'une adresse de sous-programme peut √™tre effectu√© avec quelques variantes: premi√®rement, l'adresse du point actuel du programme peut √™tre prise soit comme l'adresse de l'instruction actuelle, soit comme l'adresse de l'instruction suivante, comme dans les processeurs x86, ou l'adresse d'une autre instruction pr√®s du point actuel.  Par exemple, dans les processeurs ARM, le point de r√©f√©rence est l'adresse de l'instruction courante +8 (c'est-√†-dire non pas l'adresse de l'instruction suivant l'appel, mais l'adresse de l'instruction suivant la suivante).  De plus, puisque dans notre cas le programme est √©crit comme un flux de mots de 16 bits, il est logique de s'attendre √† ce que le d√©calage soit exprim√© en mots.  Autrement dit, pour obtenir l'adresse de la routine appel√©e, l'offset devra √™tre multipli√© par 2. <br><br>  En tenant compte de tout ce qui pr√©c√®de, nous obtenons l'espace d'√©num√©ration suivant pour rechercher une paire CALL / RET en code binaire. <br><br>  Tout d'abord, nous prenons des mots de 16 bits de la liste des valeurs les plus courantes dans le code comme candidats pour l'instruction RET.  Ensuite, nous recherchons dans l'instruction CALL: <br><br><ul><li>  Ordre des octets des mots big-endian et little-endian </li><li>  Codage absolu et relatif de l'adresse de routine dans l'instruction. </li></ul><br>  Pour le codage absolu, nous consid√©rons deux valeurs de 16 bits dans une rang√©e, √† savoir, nous trions diverses options pour placer un champ de bits qui stocke une adresse absolue dans un mot de 32 bits, et pour le codage relatif, nous consid√©rons √† la fois des valeurs de 16 bits et deux mots de 16 bits dans une rang√©e .  Ensuite, nous trions les diff√©rentes options pour placer un champ de bits qui stocke les d√©calages.  On v√©rifie si le d√©calage est exprim√© en octets ou en mots de 16 bits, c'est-√†-dire s'il faut multiplier le d√©calage par 2, on v√©rifie diff√©rentes options pour le point de r√©f√©rence: l'adresse de l'instruction courante, l'adresse de l'instruction suivante. <br><br>  Pour chacune des options de l'espace de recherche d√©crit ci-dessus, nous calculons des statistiques: <br><br><ul><li>  Combien d'adresses suppos√©es du d√©but des sous-programmes ne sont pas √©videmment correctes, c'est-√†-dire qu'elles sont situ√©es l√† o√π il n'y a rien, ou o√π les donn√©es (lignes explicites ou tableaux explicites de valeurs) sont √©videmment situ√©es.  M√™me pour la valeur correspondant au codage correct de l'instruction CALL, il est tout √† fait possible qu'un petit nombre d'adresses incorrectes du d√©but du sous-programme soit possible si la valeur correspondant √† l'instruction CALL appara√Æt accidentellement dans les donn√©es. </li><li>  Combien d'adresses de d√©but de routine putatives se trouvent imm√©diatement apr√®s l'instruction RET putative. </li><li>  Combien d'adresses de d√©but hypoth√©tiques de routines sont utilis√©es plus d'une fois. </li></ul><br>  Si nos hypoth√®ses sur une paire d'instructions CALL / RET sont correctes, elles devraient se trouver dans l'espace d'√©num√©ration d√©crit.  Mais il peut aussi y avoir des faux positifs.  Eh bien, nous commen√ßons la recherche. <br><br>  Et nous ne trouvons qu'une seule option possible! <br><br><pre> <code class="tex hljs">Trying 8c0d as RET After-ret-addr-set-size: 430 Matching call opcodes for 1, ff00ff00, 1: 000b003d: total: 1275, hits: 843 (66<span class="hljs-comment"><span class="hljs-comment">%), misses: 432 (33%), coverage: 76%</span></span></code> </pre> <br>  Ainsi, le mot 16 bits 8c0d convient comme candidat pour l'instruction RET.  Au total, le firmware contient 430 positions d'adresses de programme imm√©diatement apr√®s cette instruction.  Nous avons consid√©r√© des valeurs de 32 bits (deux mots de 16 bits cons√©cutifs), avec une valeur de masque d'adresse de ff 00 ff 00, une instruction avec le code 00 0b 00 3d a √©t√© trouv√©e.  Il existe 1275 instructions de ce type, dont 843 (soit 66%) transf√®rent le contr√¥le au point suivant imm√©diatement le candidat au RET.  Ainsi, deux instructions ont √©t√© identifi√©es: <br><br><ul><li>  RET: 8c0d (Little-Endian 16 bits) </li><li>  APPEL HHLL: 0bHH 3dLL (2 Little-Endian 16 bits) </li></ul><br>  L'instruction CALL utilise l'adressage absolu et lors de l'√©criture de l'adresse de saut, l'octet haut est √©crit en premier, puis l'octet bas est √©crit.  Il est possible qu'en r√©alit√©, ce soient deux instructions de processeur, dont chacune charge la moiti√© de l'adresse de transition, mais du point de vue de l'analyse de programme, ce n'est pas important.  Connaissant les instructions CALL et RET, nous pouvons d√©limiter plus pr√©cis√©ment les zones de code et les donn√©es de programme, qui seront importantes pour une analyse plus approfondie. <br><br>  √Ä suivre ... <br><br>  Plus loin, nous dirons comment les transitions conditionnelles et inconditionnelles et certaines op√©rations arithm√©tiques et logiques ont √©t√© restaur√©es. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442262/">https://habr.com/ru/post/fr442262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442250/index.html">React and Vue: Forces</a></li>
<li><a href="../fr442252/index.html">Cycle de vie du code Python - Mod√®le d'ex√©cution CPython</a></li>
<li><a href="../fr442256/index.html">D√©fense num√©rique du monde plastique des r√©gulateurs Internet nationaux</a></li>
<li><a href="../fr442258/index.html">Web scraping pour les d√©veloppeurs web: un bref r√©sum√©</a></li>
<li><a href="../fr442260/index.html">10 commandes Git qu'un d√©veloppeur doit savoir</a></li>
<li><a href="../fr442264/index.html">√âliminer les opportunit√©s de d√©tournement de trafic</a></li>
<li><a href="../fr442266/index.html">Delta Chat - messager d√©centralis√© au-dessus du courrier √©lectronique</a></li>
<li><a href="../fr442268/index.html">AsyncIO Micropython: m√©thodes de synchronisation en programmation asynchrone</a></li>
<li><a href="../fr442270/index.html">5 erreurs √† √©viter lors de la cr√©ation de mod√®les 3D pour l'impression 3D</a></li>
<li><a href="../fr442272/index.html">Aller + = versionner le package</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>