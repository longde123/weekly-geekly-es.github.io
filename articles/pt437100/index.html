<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äç‚öñÔ∏è ‚Ü™Ô∏è üëÜüèΩ A engenharia reversa da renderiza√ß√£o de The Witcher 3 üë®üèª‚Äçüè´ üë®üèº‚Äçüî¨ üéØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A primeira parte da tradu√ß√£o est√° aqui . Nesta parte, falaremos sobre o efeito da nitidez, brilho m√©dio, fases da lua e fen√¥menos atmosf√©ricos durante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A engenharia reversa da renderiza√ß√£o de The Witcher 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437100/">  A primeira parte da tradu√ß√£o est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Nesta parte, falaremos sobre o efeito da nitidez, brilho m√©dio, fases da lua e fen√¥menos atmosf√©ricos durante a chuva. <br><br><h2>  Parte 6. Afiar </h2><br>  Nesta parte, examinaremos mais de perto outro efeito de p√≥s-processamento de The Witcher 3 - Sharpen. <br><br>  A nitidez torna a imagem de sa√≠da um pouco mais n√≠tida.  Esse efeito √© conhecido pelo Photoshop e outros editores gr√°ficos. <br><br>  Em The Witcher 3, a nitidez tem duas op√ß√µes: baixa e alta.  Falarei sobre a diferen√ßa entre eles abaixo, mas, por enquanto, vamos dar uma olhada nas capturas de tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/1fc/6bc/2851fc6bc19e39660e0307f2775b0322.png" alt="imagem"></div><br>  <i>Op√ß√£o "Baixa" - at√©</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/cd4/4cd/dc2cd44cd83306f2c08bbf7f87831d8c.png" alt="imagem"></div><br>  <i>Op√ß√£o "Baixa" - ap√≥s</i> <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/807/2aa/aad8072aa3977f32549856c0be24206b.png"></div><br>  <i>Op√ß√£o alta - at√©</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/3ce/0f3/b873ce0f320a785f4fb4bc83e9a696f5.png"></div><br>  <i>Op√ß√£o "Alta" - depois</i> <br><br>  Se voc√™ quiser dar uma olhada em compara√ß√µes mais detalhadas (interativas), consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">se√ß√£o no Guia de desempenho da Nvidia The Witcher 3</a> .  Como voc√™ pode ver, o efeito √© especialmente vis√≠vel na grama e folhagem. <br><br>  Nesta parte do post, estudaremos o quadro desde o in√≠cio do jogo: eu o escolhi intencionalmente, porque aqui vemos o relevo (longa dist√¢ncia de renderiza√ß√£o) e a c√∫pula do c√©u. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/898/e97/895/898e9789593705231157a07ebcf34f5e.png"></div><br>  Em termos de entrada, a nitidez requer um buffer de cor <b>t0</b> (LDR ap√≥s corre√ß√£o de tom e reflexos da lente) e um buffer de profundidade <b>t1</b> . <br><br>  Vamos examinar o c√≥digo do assembler para o pixel shader: <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb3[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_input_ps_siv v0.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 7 <br> 0: ftoi r0.xy, v0.xyxx <br> 1: mov r0.zw, l(0, 0, 0, 0) <br> 2: ld_indexable(texture2d)(float,float,float,float) r0.x, r0.xyzw, t1.xyzw <br> 3: mad r0.x, r0.x, cb12[22].x, cb12[22].y <br> 4: mad r0.y, r0.x, cb12[21].x, cb12[21].y <br> 5: max r0.y, r0.y, l(0.000100) <br> 6: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 7: mad_sat r0.y, r0.y, cb3[1].z, cb3[1].w <br> 8: add r0.z, -cb3[1].x, cb3[1].y <br> 9: mad r0.y, r0.y, r0.z, cb3[1].x <br> 10: add r0.y, r0.y, l(1.000000) <br> 11: ge r0.x, r0.x, l(1.000000) <br> 12: movc r0.x, r0.x, l(0), l(1.000000) <br> 13: mul r0.z, r0.x, r0.y <br> 14: round_z r1.xy, v0.xyxx <br> 15: add r1.xy, r1.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000) <br> 16: div r1.xy, r1.xyxx, cb3[0].zwzz <br> 17: sample_l(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s0, l(0) <br> 18: lt r0.z, l(0), r0.z <br> 19: if_nz r0.z <br> 20: div r3.xy, l(0.500000, 0.500000, 0.000000, 0.000000), cb3[0].zwzz <br> 21: add r0.zw, r1.xxxy, -r3.xxxy <br> 22: sample_l(texture2d)(float,float,float,float) r4.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 23: mov r3.zw, -r3.xxxy <br> 24: add r5.xyzw, r1.xyxy, r3.zyxw <br> 25: sample_l(texture2d)(float,float,float,float) r6.xyz, r5.xyxx, t0.xyzw, s0, l(0) <br> 26: add r4.xyz, r4.xyzx, r6.xyzx <br> 27: sample_l(texture2d)(float,float,float,float) r5.xyz, r5.zwzz, t0.xyzw, s0, l(0) <br> 28: add r4.xyz, r4.xyzx, r5.xyzx <br> 29: add r0.zw, r1.xxxy, r3.xxxy <br> 30: sample_l(texture2d)(float,float,float,float) r1.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 31: add r1.xyz, r1.xyzx, r4.xyzx <br> 32: mul r3.xyz, r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000) <br> 33: mad r1.xyz, -r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000), r2.xyzx <br> 34: max r0.z, abs(r1.z), abs(r1.y) <br> 35: max r0.z, r0.z, abs(r1.x) <br> 36: mad_sat r0.z, r0.z, cb3[2].x, cb3[2].y <br> 37: mad r0.x, r0.y, r0.x, l(-1.000000) <br> 38: mad r0.x, r0.z, r0.x, l(1.000000) <br> 39: dp3 r0.y, l(0.212600, 0.715200, 0.072200, 0.000000), r2.xyzx <br> 40: dp3 r0.z, l(0.212600, 0.715200, 0.072200, 0.000000), r3.xyzx <br> 41: max r0.w, r0.y, l(0.000100) <br> 42: div r1.xyz, r2.xyzx, r0.wwww <br> 43: add r0.y, -r0.z, r0.y <br> 44: mad r0.x, r0.x, r0.y, r0.z <br> 45: max r0.x, r0.x, l(0) <br> 46: mul r2.xyz, r0.xxxx, r1.xyzx <br> 47: endif <br> 48: mov o0.xyz, r2.xyzx <br> 49: mov o0.w, l(1.000000) <br> 50: ret</code> <br> <br>  50 linhas de c√≥digo assembler parecem uma tarefa vi√°vel.  Vamos resolver isso. <br><br><h3>  Aumentar a gera√ß√£o de valor </h3><br>  O primeiro passo √© carregar o buffer de profundidade (linha 1).  Vale ressaltar que o "The Witcher 3" usa uma profundidade invertida (1,0 - perto, 0,0 - longe).  Como voc√™ deve saber, a profundidade do hardware est√° ligada de maneira n√£o linear (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo para obter detalhes</a> ). <br><br>  As linhas 3-6 fornecem uma maneira muito interessante de associar essa profundidade de hardware [1,0 - 0,0] aos valores [pr√≥ximos] (os definimos no est√°gio MatrixPerspectiveFov).  Considere os valores do buffer constante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/636/345/52a/63634552ae9daf03f14305c118cccc25.png"></div><br>  Tendo o valor "close" de 0,2 e o valor "far" 5000, podemos calcular os valores de cb12_v21.xy da seguinte maneira: <br><br> <code>cb12_v21.y = 1.0 / near <br> cb12_v21.x = - (1.0 / near) + (1.0 / near) * (near / far)</code> <br> <br>  Esse peda√ßo de c√≥digo √© bastante comum nos shaders TW3, ent√£o acho que √© apenas uma fun√ß√£o. <br><br>  Ap√≥s obter a ‚Äúprofundidade da pir√¢mide de visibilidade‚Äù, a linha 7 usa a escala / distor√ß√£o para criar o coeficiente de interpola√ß√£o (aqui usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">saturado</a> para limitar os valores ao intervalo [0-1]). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/efd/571/e89efd5711cb2aa1a3c544e9deda9321.png"></div><br>  cb3_v1.xy e cb3_v2.xy - esse √© o brilho do efeito de nitidez a dist√¢ncias curtas e longas.  Vamos cham√°-los de sharpenNear e sharpenFar.  E essa √© a √∫nica diferen√ßa entre as op√ß√µes "Baixa" e "Alta" desse efeito em The Witcher 3. <br><br>  Agora √© hora de usar a propor√ß√£o resultante.  As linhas 8-9 apenas fazem o <code>lerp(sharpenNear, sharpenFar, interpolationCoeff)</code> .  Para que √© isso?  Gra√ßas a isso, temos um brilho diferente perto de Geralt e longe dele.  D√™ uma olhada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/233/515/6462335151728759f236b58f14b894dd.png"></div><br>  Talvez isso seja quase impercept√≠vel, mas aqui interpolamos com base na dist√¢ncia o brilho de nitidez pr√≥ximo ao player (2.177151) e o brilho do efeito √© muito distante (1.91303).  Ap√≥s esse c√°lculo, adicionamos 1,0 ao brilho (linha 10).  Por que isso √© necess√°rio?  Suponha que a opera√ß√£o lerp mostrada acima nos deu 0,0.  Depois de adicionar 1.0, obtemos naturalmente 1.0, e esse √© um valor que n√£o afetar√° o pixel ao fazer a nitidez.  Leia mais sobre isso abaixo. <br><br>  Enquanto afiamos, n√£o queremos afetar o c√©u.  Isso pode ser conseguido adicionando uma verifica√ß√£o condicional simples: <br><br> <code>//   sharpen   <br> float fSkyboxTest = (fDepth &gt;= 1.0) ? 0 : 1;</code> <br> <br>  Em The Witcher 3, o valor da profundidade de pixel do c√©u √© 1,0, portanto, usamos-o para obter uma esp√©cie de "filtro bin√°rio" (um fato interessante: neste caso, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">etapa</a> n√£o funcionar√° corretamente). <br><br>  Agora podemos multiplicar o brilho interpolado por um "filtro do c√©u": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/ed1/f50/63ced1f5036d9ee63cfe54de6a501bc1.png"></div><br>  Essa multiplica√ß√£o √© realizada na linha 13. <br><br>  Exemplo de c√≥digo de sombreador: <br><br> <code>//    sharpen <br> float fSharpenAmount = fSharpenIntensity * fSkyboxTest;</code> <br> <br><h3>  Centro de amostragem de pixels </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SV_Position</a> tem um aspecto que ser√° importante aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um deslocamento de meio pixel</a> .  Acontece que esse pixel no canto superior esquerdo (0, 0) possui coordenadas n√£o (0, 0) em termos de SV_Position.xy, mas (0,5, 0,5).  Uau! <br><br>  Aqui queremos tirar uma amostra no centro do pixel, ent√£o vamos ver as linhas 14-16.  Voc√™ pode escrev√™-los em HLSL: <br><br> <code>//   . <br> //   ""   SV_Position.xy. <br> float2 uvCenter = trunc( Input.Position.xy ); <br> <br> //   ,       <br> uvCenter += float2(0.5, 0.5); <br> uvCenter /= g_Viewport.xy</code> <br> <br>  E mais tarde, amostramos a textura da cor de entrada dos cabos de texto "uvCenter".  N√£o se preocupe, o resultado da amostragem ser√° o mesmo do m√©todo "normal" (SV_Position.xy / ViewportSize.xy). <br><br><h3>  Para afiar ou n√£o afiar </h3><br>  A decis√£o sobre o uso de nitidez depende de fSharpenAmount. <br><br> <code>//     <br> float3 colorCenter = TexColorBuffer.SampleLevel( samplerLinearClamp, uvCenter, 0 ).rgb; <br> <br> //   <br> float3 finalColor = colorCenter; <br> <br> if ( fSharpenAmount &gt; 0 ) <br> { <br> //   sharpening... <br> } <br> <br> return float4( finalColor, 1 );</code> <br> <br><h3>  Afiar </h3><br>  √â hora de dar uma olhada no interior do pr√≥prio algoritmo. <br><br>  Essencialmente, ele executa as seguintes a√ß√µes: <br><br>  - mostra quatro vezes a textura da cor de entrada nos cantos do pixel, <br><br>  - adiciona amostras e calcula o valor m√©dio, <br><br>  - calcula a diferen√ßa entre "centro" e "cornerAverage", <br><br>  - encontre o componente absoluto m√°ximo da diferen√ßa, <br><br>  - corrige no m√°x.  abs.  componente usando escala + valores de vi√©s, <br><br>  - determina a magnitude do efeito usando max.  abs.  componente <br><br>  - calcula o valor do brilho (luma) para "centerColor" e "averageColor", <br><br>  - divide o colorCenter em sua luma, <br><br>  - calcula um novo valor de luma interpolado com base na magnitude do efeito, <br><br>  - Multiplica o colorCenter pelo novo valor de luma. <br><br>  Muito trabalho, e foi dif√≠cil para mim descobrir, porque nunca havia experimentado filtros de nitidez. <br><br>  Vamos come√ßar com o padr√£o de amostragem.  Como voc√™ pode ver no c√≥digo do assembler, quatro leituras de textura s√£o executadas. <br><br>  Isso ser√° melhor mostrado usando um exemplo de uma imagem de pixel (o n√≠vel de habilidade do artista √© <i>um especialista</i> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e3/d46/5fa/5e3d465fadc0bccd551256c40c6e5368.png"></div><br>  Todas as leituras no sombreador usam amostragem bilinear (D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT). <br><br>  O deslocamento do centro para cada um dos √¢ngulos √© (¬± 0,5, ¬± 0,5), dependendo do √¢ngulo. <br><br>  Veja como isso pode ser implementado no HLSL?  Vamos ver: <br><br> <code>float2 uvCorner; <br> float2 uvOffset = float2( 0.5, 0.5 ) / g_Viewport.xy; // remember about division! <br> <br> float3 colorCorners = 0; <br> <br> //    <br> // -0,5, -0.5 <br> uvCorner = uvCenter - uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, -0.5 <br> uvCorner = uvCenter + float2(uvOffset.x, -uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // -0.5, +0.5 <br> uvCorner = uvCenter + float2(-uvOffset.x, uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, +0.5 <br> uvCorner = uvCenter + uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb;</code> <br> <br>  Portanto, agora todas as quatro amostras est√£o resumidas na vari√°vel "colorCorners".  Vamos seguir estes passos: <br><br> <code>//     <br> float3 averageColorCorners = colorCorners / 4.0; <br> <br> //    <br> float3 diffColor = colorCenter - averageColorCorners; <br> <br> //  . . RGB-  <br> float fDiffColorMaxComponent = max( abs(diffColor.x), max( abs(diffColor.y), abs(diffColor.z) ) ); <br> <br> //    <br> float fDiffColorMaxComponentScaled = saturate( fDiffColorMaxComponent * sharpenLumScale + sharpenLumBias ); <br> <br> //     . <br> //   "1.0" -      fSharpenIntensity  1.0. <br> float fPixelSharpenAmount = lerp(1.0, fSharpenAmount, fDiffColorMaxComponentScaled); <br> <br> //   ""     . <br> float lumaCenter = dot( LUMINANCE_RGB, finalColor ); <br> float lumaCornersAverage = dot( LUMINANCE_RGB, averageColorCorners ); <br> <br> //  "centerColor"    <br> float3 fColorBalanced = colorCenter / max( lumaCenter, 1e-4 ); <br> <br> //    <br> float fPixelLuminance = lerp(lumaCornersAverage, lumaCenter, fPixelSharpenAmount); <br> <br> //     <br> finalColor = fColorBalanced * max(fPixelLuminance, 0.0); <br> } <br> <br> return float4(finalColor, 1.0);</code> <br> <br>  O reconhecimento da borda √© realizado calculando-se m√°x.  abs.  componente de diferen√ßa.  Jogada inteligente!  Confira sua visualiza√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/a26/44a/aa9a2644a16b1b79c6213f7d4effe068.jpg"></div><br>  <i>Visualiza√ß√£o do componente absoluto m√°ximo da diferen√ßa.</i> <br><br>  √ìtimo.  O shader HLSL finalizado est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Desculpe pela formata√ß√£o bastante ruim.  Voc√™ pode usar meu programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HLSLexplorer</a> e experimentar o c√≥digo. <br><br>  Felizmente, posso dizer que o c√≥digo acima cria o mesmo c√≥digo assembler que no jogo! <br><br>  Para resumir: O shader de nitidez do Witcher 3 est√° muito bem escrito (observe que fPixelSharpenAmount √© maior que 1,0! Isso √© interessante ...).  Al√©m disso, a principal maneira de alterar o brilho do efeito √© o brilho de objetos pr√≥ximos / distantes.  Neste jogo, eles n√£o s√£o constantes;  Eu compilei v√°rios exemplos de valores: <br><br>  Skellige: <br><br><table><tbody><tr><th></th><th>  sharpenNear </th><th>  sharpenFar </th><th>  sharpenDistanceScale </th><th>  sharpenDistanceBias </th><th>  sharpenLumScale </th><th>  sharpenLumBias </th></tr><tr><td>  <b>baixo</b> </td></tr></tbody><tbody><tr><td>  <b>alto</b> </td><td>  2.0 </td><td>  1.8 </td><td>  0,025 <br></td><td>  -0,25 <br></td><td>  -13.33333 <br></td><td>  1,33333 </td></tr></tbody></table><br>  Kaer Morhen: <br><br><table><tbody><tr><th></th><th>  sharpenNear <br></th><th>  sharpenFar <br></th><th>  sharpenDistanceScale <br></th><th>  sharpenDistanceBias <br></th><th>  sharpenLumScale <br></th><th>  sharpenLumBias <br></th></tr><tr><td>  baixo <br></td><td>  0,57751 <br></td><td>  0,31303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1,0 <br></td><td>  2.0 <br></td></tr><tr><td>  alto <br></td><td>  2.17751 <br></td><td>  1,91303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1,0 <br></td><td>  2.0 </td></tr></tbody></table><br><h2>  Parte 7. Brilho m√©dio </h2><br>  A opera√ß√£o de calcular o brilho m√©dio do quadro atual pode ser encontrada em quase todos os videogames modernos.  Esse valor geralmente √© usado posteriormente para o efeito de adapta√ß√£o ocular e corre√ß√£o de tons (veja na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte anterior do</a> post).  Em solu√ß√µes simples, o c√°lculo do brilho √© usado para, digamos, a textura 512 <sup>2</sup> , depois o c√°lculo dos n√≠veis de mip e a aplica√ß√£o deste √∫ltimo.  Isso geralmente funciona, mas limita bastante as possibilidades.  Solu√ß√µes mais complexas usam shaders computacionais que realizam, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">redu√ß√£o paralela</a> . <br><br>  Vamos descobrir como a equipe do CD Projekt Red resolveu esse problema no The Witcher 3.  Na parte anterior, eu j√° examinei a corre√ß√£o tonal e a adapta√ß√£o do olho, ent√£o a √∫nica pe√ßa restante do quebra-cabe√ßa era o brilho m√©dio. <br><br>  Para come√ßar, o c√°lculo m√©dio do brilho do The Witcher 3 consiste em duas passagens.  Para maior clareza, decidi dividi-las em partes separadas, e primeiro examinamos a primeira passagem - "distribui√ß√£o do brilho" (c√°lculo do histograma do brilho). <br><br><h3>  Distribui√ß√£o de brilho </h3><br>  Essas duas passagens s√£o f√°ceis de encontrar em qualquer analisador de quadros.  Estas s√£o as chamadas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Despacho</a> em ordem imediatamente antes de executar a adapta√ß√£o ocular: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/5fb/09c/7de5fb09ce00453f14262f9e2b1bae30.png"></div><br>  Vamos dar uma olhada na entrada desse passe.  Ele precisa de duas texturas: <br><br>  1) buffer de cores HDR, cuja escala √© reduzida para 1/4 x 1/4 (por exemplo, de 1920x1080 a 480x270), <br><br>  2) Buffer de profundidade de tela cheia <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/021/38b/795/02138b795946d192f553eadc20d34366.png"></div><br>  <i>Buffer colorido HDR de 1/4 x 1/4.</i>  <i>Observe o truque complicado - esse buffer faz parte de um buffer maior.</i>  <i>Reutilizar buffers √© uma boa pr√°tica.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/62d/c97/0e362dc97908f75db564cff0f46b1e7e.png"></div><br>  <i>Buffer de profundidade de tela cheia</i> <br><br>  Por que reduzir o buffer de cores?  Eu acho que √© tudo sobre desempenho. <br><br>  Quanto √† sa√≠da desse passe, √© um buffer estruturado.  256 elementos de 4 bytes cada. <br><br>  Os shaders n√£o possuem informa√ß√µes de depura√ß√£o aqui, portanto, suponha que seja apenas um buffer de valores int n√£o assinados. <br><br>  Importante: a primeira etapa no c√°lculo do brilho m√©dio chama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ClearUnorderedAccessViewUint</a> para redefinir todos os elementos do buffer estruturado para zero. <br><br>  Vamos estudar o c√≥digo assembler do shader computacional (este √© o primeiro shader computacional em toda a nossa an√°lise!) <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[3], immediateIndexed <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_uav_structured u0, 4 <br> dcl_input vThreadGroupID.x <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 6 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: store_structured g0.x, vThreadIDInGroup.x, l(0), l(0) <br> 1: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 2: store_structured g0.x, r0.x, l(0), l(0) <br> 3: store_structured g0.x, r0.y, l(0), l(0) <br> 4: store_structured g0.x, r0.z, l(0), l(0) <br> 5: sync_g_t <br> 6: ftoi r1.x, cb0[2].z <br> 7: mov r2.y, vThreadGroupID.x <br> 8: mov r2.zw, l(0, 0, 0, 0) <br> 9: mov r3.zw, l(0, 0, 0, 0) <br> 10: mov r4.yw, l(0, 0, 0, 0) <br> 11: mov r1.y, l(0) <br> 12: loop <br> 13: utof r1.z, r1.y <br> 14: ge r1.z, r1.z, cb0[0].x <br> 15: breakc_nz r1.z <br> 16: iadd r2.x, r1.y, vThreadIDInGroup.x <br> 17: utof r1.z, r2.x <br> 18: lt r1.z, r1.z, cb0[0].x <br> 19: if_nz r1.z <br> 20: ld_indexable(texture2d)(float,float,float,float) r5.xyz, r2.xyzw, t0.xyzw <br> 21: dp3 r1.z, r5.xyzx, l(0.212600, 0.715200, 0.072200, 0.000000) <br> 22: imul null, r3.xy, r1.xxxx, r2.xyxx <br> 23: ld_indexable(texture2d)(float,float,float,float) r1.w, r3.xyzw, t1.yzwx <br> 24: eq r1.w, r1.w, cb0[2].w <br> 25: and r1.w, r1.w, cb0[2].y <br> 26: add r2.x, -r1.z, cb0[2].x <br> 27: mad r1.z, r1.w, r2.x, r1.z <br> 28: add r1.z, r1.z, l(1.000000) <br> 29: log r1.z, r1.z <br> 30: mul r1.z, r1.z, l(88.722839) <br> 31: ftou r1.z, r1.z <br> 32: umin r4.x, r1.z, l(255) <br> 33: atomic_iadd g0, r4.xyxx, l(1) <br> 34: endif <br> 35: iadd r1.y, r1.y, l(64) <br> 36: endloop <br> 37: sync_g_t <br> 38: ld_structured r1.x, vThreadIDInGroup.x, l(0), g0.xxxx <br> 39: mov r4.z, vThreadIDInGroup.x <br> 40: atomic_iadd u0, r4.zwzz, r1.x <br> 41: ld_structured r1.x, r0.x, l(0), g0.xxxx <br> 42: mov r0.w, l(0) <br> 43: atomic_iadd u0, r0.xwxx, r1.x <br> 44: ld_structured r0.x, r0.y, l(0), g0.xxxx <br> 45: atomic_iadd u0, r0.ywyy, r0.x <br> 46: ld_structured r0.x, r0.z, l(0), g0.xxxx <br> 47: atomic_iadd u0, r0.zwzz, r0.x <br> 48: ret</code> <br> <br>  E um buffer constante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/805/dc6/c14805dc6b7ffd431d9307cc46dcba0d.png"></div><br>  J√° sabemos que a primeira entrada √© um buffer de cores HDR.  Com o FullHD, sua resolu√ß√£o √© 480x270.  Vamos olhar para a chamada de expedi√ß√£o. <br><br>  Despacho (270, 1, 1) - isso significa que executamos 270 grupos de encadeamentos.  Simplificando, executamos um grupo de linhas por linha do buffer de cores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/a97/7e3/e9aa977e3f9a60104fe9a66d797a27cc.png"></div><br>  <i>Cada grupo de encadeamentos executa uma linha do buffer de cores HDR</i> <br><br>  Agora que temos esse contexto, vamos tentar descobrir o que o shader faz. <br><br>  Cada grupo de threads possui 64 threads na dire√ß√£o X (dcl_thread_group 64, 1, 1), al√©m de mem√≥ria compartilhada, 256 elementos com 4 bytes cada (dcl_tgsm_structured g0, 4, 256). <br><br>  Observe que no shader usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SV_GroupThreadID</a> (vThreadIDInGroup.x) [0-63] e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SV_GroupID</a> (vThreadGroupID.x) [0-269]. <br><br>  1) Come√ßamos atribuindo a todos os elementos dos valores zero de mem√≥ria compartilhada.  Como a mem√≥ria total cont√©m 256 elementos e 64 threads por grupo, isso pode ser feito convenientemente com um loop simples: <br><br> <code>//   -      . <br> //        64 ,          4 . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = 0; <br> }</code> <br> <br>  2) Depois disso, definimos a barreira usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GroupMemoryBarrierWithGroupSync</a> (sync_g_t).  Fazemos isso para garantir que todos os threads na mem√≥ria compartilhada dos grupos sejam redefinidos para zero antes de prosseguir para a pr√≥xima etapa. <br><br>  3) Agora estamos executando um loop, que pode ser escrito aproximadamente assim: <br><br> <code>// cb0_v0.x -      .  1920x1080   1920/4 = 480; <br> float ViewportSizeX = cb0_v0.x; <br> [loop] for ( uint PositionX = 0; PositionX &lt; ViewportSizeX; PositionX += 64 ) <br> { <br> ...</code> <br> <br>  Este √© um loop for simples, com um incremento de 64 (voc√™ j√° entendeu o porqu√™?). <br><br>  O pr√≥ximo passo √© calcular a posi√ß√£o do pixel carregado. <br><br>  Vamos pensar sobre isso. <br><br>  Para a coordenada Y, podemos usar SV_GroupID.x porque lan√ßamos 270 grupos de encadeamentos. <br><br>  Para a coordenada X, podemos ... tirar proveito do fluxo atual do grupo!  Vamos tentar fazer isso. <br><br>  Como existem 64 threads em cada grupo, essa solu√ß√£o ignorar√° todos os pixels. <br><br>  Considere o grupo de threads (0, 0, 0). <br><br>  - O fluxo (0, 0, 0) processar√° pixels (0, 0), (64, 0), (128, 0), (192, 0), (256, 0), (320, 0), (384, 0), (448,0). <br><br>  - O encadeamento (1, 0, 0) processar√° os pixels (1, 0), (65, 0), (129, 0), (193, 0), (257, 0), (321, 0), (385, 0), (449, 0) ... <br><br>  - O fluxo (63, 0, 0) processar√° os pixels (63, 0), (127, 0), (191, 0), (255, 0), (319, 0), (383, 0), (447, 0) <br><br>  Assim, todos os pixels ser√£o processados. <br><br>  Tamb√©m precisamos garantir que n√£o carregemos pixels de fora do buffer de cores: <br><br> <code>//      X.  Y  GroupID. <br> uint CurrentPixelPositionX = PositionX + threadID; <br> uint CurrentPixelPositionY = groupID; <br> if ( CurrentPixelPositionX &lt; ViewportSizeX ) <br> { <br> // HDR- . <br> //   HDR-    ,     . <br> uint2 colorPos = uint2(CurrentPixelPositionX, CurrentPixelPositionY); <br> float3 color = texture0.Load( int3(colorPos, 0) ).rgb; <br> float luma = dot(color, LUMA_RGB);</code> <br> <br>  Est√° vendo?  √â bem simples! <br><br>  Tamb√©m calculei o brilho (linha 21 do c√≥digo do assembler). <br><br>  √ìtimo, j√° calculamos o brilho de um pixel colorido.  O pr√≥ximo passo √© carregar (n√£o a amostra!) O valor da profundidade correspondente. <br><br>  Mas aqui temos um problema, porque conectamos o buffer de profundidades de resolu√ß√£o total.  O que fazer sobre isso? <br><br>  Isso √© surpreendentemente simples - basta multiplicar colorPos por alguma constante (cb0_v2.z).  Reduzimos o buffer de cores HDR quatro vezes.  portanto, o valor √© 4! <br><br> <code>const int iDepthTextureScale = (int) cb0_v2.z; <br> uint2 depthPos = iDepthTextureScale * colorPos; <br> float depth = texture1.Load( int3(depthPos, 0) ).x;</code> <br> <br>  At√© a√≠ tudo bem!  Mas ... chegamos √†s linhas 24-25 ... <br><br> <code>24: eq r2.x, r2.x, cb0[2].w <br> 25: and r2.x, r2.x, cb0[2].y</code> <br> <br>  Ent√£o  Primeiro, temos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compara√ß√£o da igualdade de</a> ponto flutuante, seu resultado √© escrito em r2.x e logo depois disso ... o qu√™?  Bitwise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">And</a> ??  S√©rio?  Para um valor de ponto flutuante?  Que diabos ??? <br><br>  <b>O problema 'eq + and'</b> <br><br>  Deixe-me dizer que, para mim, foi a parte mais dif√≠cil do sombreador.  Eu at√© tentei combina√ß√µes estranhas asint / asfloat ... <br><br>  E se voc√™ usar uma abordagem um pouco diferente?  Vamos apenas fazer a compara√ß√£o flutuante-flutuante usual no HLSL. <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y); <br> return test; <br> }</code> <br> <br>  E aqui est√° a sa√≠da no c√≥digo do assembler: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, l(0x3f800000) <br> 2: ret</code> <br> <br>  Interessante, certo?  Eu n√£o esperava ver "e" aqui. <br><br>  0x3f800000 √© apenas 1,0f ... √â l√≥gico, porque obtemos 1,0 e 0,0, caso contr√°rio, se a compara√ß√£o for bem-sucedida. <br><br>  Mas e se "substituirmos" 1.0 por algum outro valor?  Por exemplo, assim: <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y) ? cb0_v0.z : 0.0; <br> return test; <br> }</code> <br> <br>  Temos o seguinte resultado: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, cb0[0].z <br> 2: ret</code> <br> <br>  Ha!  Funcionou.  Essa √© apenas a m√°gica do compilador HLSL.  Nota: se voc√™ substituir 0.0 por outra coisa, ser√° movc. <br><br>  Vamos voltar ao shader computacional.  O pr√≥ximo passo √© verificar se a profundidade √© igual a cb0_v2.w.  √â sempre igual a 0,0 - em outras palavras, verificamos se um pixel est√° em um plano distante (no c√©u).  Nesse caso, atribu√≠mos a esse coeficiente algum valor, aproximadamente 0,5 (verifiquei em v√°rios quadros). <br><br>  Este coeficiente calculado √© usado para interpolar entre o brilho da cor e o brilho do ‚Äúc√©u‚Äù (valor cb0_v2.x, que geralmente √© aproximadamente igual a 0,0).  Suponho que isso seja necess√°rio para controlar a import√¢ncia do c√©u no c√°lculo do brilho m√©dio.  Geralmente a import√¢ncia √© reduzida.  Id√©ia muito inteligente. <br><br> <code>// ,       ( ).  ,    ,    <br> //    . <br> float value = (depth == cb0_v2.w) ? cb0_v2.y : 0.0; <br> <br> //  'value'  0.0,   lerp    'luma'.   'value'  <br> // (  0.50),   luma    . (cb0_v2.x    0.0). <br> float lumaOk = lerp( luma, cb0_v2.x, value );</code> <br> <br>  Como temos o lumaOk, o pr√≥ximo passo √© calcular seu logaritmo natural para criar uma boa distribui√ß√£o.  Mas espere, digamos que lumaOk √© 0,0.  Sabemos que o valor do log (0) √© indefinido, portanto adicionamos 1,0 porque log (1) = 0,0. <br><br>  Depois disso, escalamos o logaritmo calculado para 128 para distribu√≠-lo em 256 c√©lulas.  Muito esperto! <br><br>  E √© daqui que esse valor 88.722839 √© obtido.  Este √© um <code>128 *   (2)</code> . <br><br>  √â assim que o HLSL calcula os logaritmos. <br><br>  H√° apenas uma fun√ß√£o no c√≥digo do montador HLSL que calcula os logaritmos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">log</a> e possui uma base de 2. <br><br> <code>// ,  lumaOk  0.0. <br> // log(0)   undefined <br> // log(1) = 0. <br> //     <br> lumaOk = log(lumaOk + 1.0); <br> <br> //     128 <br> lumaOk *= 128;</code> <br> <br>  Finalmente, calculamos o √≠ndice da c√©lula a partir do brilho distribu√≠do logaritmicamente e adicionamos 1 √† c√©lula correspondente na mem√≥ria compartilhada. <br><br> <code>//   .    Uint,    256 , <br> //  ,      . <br> uint uLuma = (uint) lumaOk; <br> uLuma = min(uLuma, 255); <br> <br> //  1    . <br> InterlockedAdd( shared_data[uLuma], 1 );</code> <br> <br>  A pr√≥xima etapa ser√° novamente definir uma barreira para garantir que todos os pixels na linha foram processados. <br><br>  E o √∫ltimo passo √© adicionar valores da mem√≥ria compartilhada ao buffer estruturado.  Isso √© feito da mesma maneira, atrav√©s de um loop simples: <br><br> <code>// ,       <br> GroupMemoryBarrierWithGroupSync(); <br> <br> //      . <br> [unroll] for (uint idx = 0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> <br> uint data = shared_data[offset]; <br> InterlockedAdd( g_buffer[offset], data ); <br> }</code> <br> <br>  Ap√≥s todos os 64 threads no grupo de threads preencherem os dados comuns, cada thread adiciona 4 valores ao buffer de sa√≠da. <br><br>  Considere o buffer de sa√≠da.  Vamos pensar sobre isso.  A soma de todos os valores no buffer √© igual ao n√∫mero total de pixels!  (em 480x270 = 129.600).  Ou seja, sabemos quantos pixels t√™m um valor de brilho espec√≠fico. <br><br>  Se voc√™ √© pouco versado em sombreadores computacionais (como eu), a princ√≠pio pode n√£o estar claro; portanto, leia o post mais algumas vezes, pegue papel e l√°pis e tente entender os conceitos nos quais essa t√©cnica √© constru√≠da. <br><br>  Isso √© tudo!  √â assim que The Witcher 3 calcula um histograma de brilho.  Pessoalmente, aprendi muito ao escrever esta parte.  Parab√©ns aos caras da CD Projekt Red pelo excelente trabalho! <br><br>  Se voc√™ estiver interessado em um shader HLSL completo, ele estar√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Eu sempre me esfor√ßo para obter o c√≥digo de montagem o mais pr√≥ximo poss√≠vel do jogo e estou completamente feliz por ter conseguido novamente! <br><br><h2>  C√°lculo do brilho m√©dio </h2><br>  Esta √© a segunda parte da an√°lise dos c√°lculos de brilho m√©dio em "The Witcher 3: Wild Hunt". <br><br>  Antes de entrarmos em batalha com outro sombreador computacional, vamos repetir brevemente o que aconteceu na √∫ltima parte: trabalhamos com um buffer de cores HDR com uma escala de 1 / 4x1 / 4.  Ap√≥s a primeira passagem, obtivemos um histograma de brilho (buffer estruturado de 256 valores inteiros n√£o assinados).  Calculamos o logaritmo para o brilho de cada pixel, o distribu√≠mos por 256 c√©lulas e aumentamos o valor correspondente do buffer estruturado em 1 por pixel.  Por esse motivo, a soma total de todos os valores nessas 256 c√©lulas √© igual ao n√∫mero de pixels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/89c/d16/3c389cd16ec2eed7617dcf9334429c6e.png"></div><br>  <i>Um exemplo da sa√≠da da primeira passagem.</i>  <i>Existem 256 elementos.</i> <br><br>  Por exemplo, nosso buffer de tela cheia tem um tamanho de 1920x1080.  Depois de diminuir o zoom, a primeira passagem usou um buffer de 480x270.  A soma de todos os 256 valores no buffer ser√° igual a 480 * 270 = 129 600. <br><br>  Ap√≥s esta breve introdu√ß√£o, estamos prontos para avan√ßar para o pr√≥ximo passo: a computa√ß√£o. <br><br>  Desta vez, apenas um grupo de encadeamentos √© usado (Despacho (1, 1, 1)). <br><br>  Vejamos o c√≥digo do assembler do shader computacional: <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_uav_structured u0, 4 <br> dcl_uav_typed_texture2d (float,float,float,float) u1 <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 4 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, vThreadIDInGroup.x, l(0), u0.xxxx <br> 1: store_structured g0.x, vThreadIDInGroup.x, l(0), r0.x <br> 2: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 3: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.w, r0.x, l(0), u0.xxxx <br> 4: store_structured g0.x, r0.x, l(0), r0.w <br> 5: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.y, l(0), u0.xxxx <br> 6: store_structured g0.x, r0.y, l(0), r0.x <br> 7: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.z, l(0), u0.xxxx <br> 8: store_structured g0.x, r0.z, l(0), r0.x <br> 9: sync_g_t <br> 10: if_z vThreadIDInGroup.x <br> 11: mul r0.x, cb0[0].y, cb0[0].x <br> 12: ftou r0.x, r0.x <br> 13: utof r0.y, r0.x <br> 14: mul r0.yz, r0.yyyy, cb0[0].zzwz <br> 15: ftoi r0.yz, r0.yyzy <br> 16: iadd r0.x, r0.x, l(-1) <br> 17: imax r0.y, r0.y, l(0) <br> 18: imin r0.y, r0.x, r0.y <br> 19: imax r0.z, r0.y, r0.z <br> 20: imin r0.x, r0.x, r0.z <br> 21: mov r1.z, l(-1) <br> 22: mov r2.xyz, l(0, 0, 0, 0) <br> 23: loop <br> 24: breakc_nz r2.x <br> 25: ld_structured r0.z, r2.z, l(0), g0.xxxx <br> 26: iadd r3.x, r0.z, r2.y <br> 27: ilt r0.z, r0.y, r3.x <br> 28: iadd r3.y, r2.z, l(1) <br> 29: mov r1.xy, r2.yzyy <br> 30: mov r3.z, r2.x <br> 31: movc r2.xyz, r0.zzzz, r1.zxyz, r3.zxyz <br> 32: endloop <br> 33: mov r0.w, l(-1) <br> 34: mov r1.yz, r2.yyzy <br> 35: mov r1.xw, l(0, 0, 0, 0) <br> 36: loop <br> 37: breakc_nz r1.x <br> 38: ld_structured r2.x, r1.z, l(0), g0.xxxx <br> 39: iadd r1.y, r1.y, r2.x <br> 40: utof r2.x, r2.x <br> 41: utof r2.w, r1.z <br> 42: add r2.w, r2.w, l(0.500000) <br> 43: mul r2.w, r2.w, l(0.011271) <br> 44: exp r2.w, r2.w <br> 45: add r2.w, r2.w, l(-1.000000) <br> 46: mad r3.z, r2.x, r2.w, r1.w <br> 47: ilt r2.x, r0.x, r1.y <br> 48: iadd r2.w, -r2.y, r1.y <br> 49: itof r2.w, r2.w <br> 50: div r0.z, r3.z, r2.w <br> 51: iadd r3.y, r1.z, l(1) <br> 52: mov r0.y, r1.z <br> 53: mov r3.w, r1.x <br> 54: movc r1.xzw, r2.xxxx, r0.wwyz, r3.wwyz <br> 55: endloop <br> 56: store_uav_typed u1.xyzw, l(0, 0, 0, 0), r1.wwww <br> 57: endif <br> 58: ret</code> <br> <br>  H√° um buffer constante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbe/13a/0ab/bbe13a0abe0d79f47b0a59d33d51ab9c.png"></div><br>  D√™ uma olhada r√°pida no c√≥digo do assembler: dois UAVs est√£o anexados (u0: buffer de entrada da primeira parte e u1: textura de sa√≠da no formato 1x1 R32_FLOAT).  Tamb√©m vemos que existem 64 threads por grupo e 256 elementos de mem√≥ria de grupo compartilhada de 4 bytes. <br><br>  Come√ßamos preenchendo a mem√≥ria compartilhada com dados do buffer de entrada.  Temos 64 threads, ent√£o voc√™ ter√° que fazer quase o mesmo de antes. <br><br>  Para ter certeza absoluta de que todos os dados foram carregados para processamento adicional, depois disso, colocamos uma barreira. <br><br> <code>//   -        . <br> //        64 ,    4     <br> //    . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = g_buffer[offset]; <br> } <br> //    ,       ,     <br> //             . <br> GroupMemoryBarrierWithGroupSync();</code> <br> <br>  Todos os c√°lculos s√£o realizados em apenas um encadeamento, todos os outros s√£o usados ‚Äã‚Äãsimplesmente para carregar valores do buffer na mem√≥ria compartilhada. <br><br>  O fluxo de "computa√ß√£o" tem um √≠ndice de 0. Por qu√™?  Teoricamente, podemos usar qualquer fluxo do intervalo [0-63], mas, gra√ßas a uma compara√ß√£o com 0, podemos evitar compara√ß√µes adicionais inteiro-inteiro (instru√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ieq</a> ). <br><br>  O algoritmo √© baseado na indica√ß√£o do intervalo de pixels que ser√£o levados em considera√ß√£o na opera√ß√£o. <br><br>  Na linha 11, multiplicamos width * height para obter o n√∫mero total de pixels e os multiplicamos por dois n√∫meros do intervalo [0.0f-1.0f], indicando o in√≠cio e o final do intervalo.  Restri√ß√µes adicionais s√£o usadas para garantir que <code>0 &lt;= Start &lt;= End &lt;= totalPixels - 1</code> : <br><br> <code>//        0. <br> [branch] if (threadID == 0) <br> { <br> //         <br> uint totalPixels = cb0_v0.x * cb0_v0.y; <br> <br> //   (,  ,    ), <br> //        . <br> int pixelsToConsiderStart = totalPixels * cb0_v0.z; <br> int pixelsToConsiderEnd = totalPixels * cb0_v0.w; <br> <br> int pixelsMinusOne = totalPixels - 1; <br> <br> pixelsToConsiderStart = clamp( pixelsToConsiderStart, 0, pixelsMinusOne ); <br> pixelsToConsiderEnd = clamp( pixelsToConsiderEnd, pixelsToConsiderStart, pixelsMinusOne );</code> <br> <br>  Como voc√™ pode ver, existem dois ciclos abaixo.  O problema com eles (ou com seu c√≥digo assembler) √© que existem transi√ß√µes condicionais estranhas no final dos loops.  Foi muito dif√≠cil para mim recri√°-los.  Tamb√©m d√™ uma olhada na linha 21. Por que existe "-1"?  Vou explicar um pouco abaixo. <br><br>  A tarefa do primeiro ciclo √© eliminar <i>pixelsToConsiderStart</i> e fornecer o √≠ndice da c√©lula de buffer na qual <i>pixelsToConsiderStart</i> +1 est√° presente (assim como o n√∫mero de todos os pixels nas c√©lulas anteriores). <br><br>  Digamos que <i>pixelsToConsiderStart √©</i> aproximadamente igual a 30.000, e no buffer existem 37.000 pixels na c√©lula "zero" (isso acontece no jogo √† noite).  Portanto, queremos iniciar a an√°lise de brilho a partir de aproximadamente pixel 30001, presente na c√©lula "zero".  Nesse caso, sa√≠mos imediatamente do loop, obtendo o √≠ndice inicial '0' e zero pixels descartados. <br><br>  D√™ uma olhada no c√≥digo HLSL: <br><br> <code>//     <br> int numProcessedPixels = 0; <br> <br> //   [0-255] <br> int lumaValue = 0; <br> <br> //      <br> bool bExitLoop = false; <br> <br> //    -  "pixelsToConsiderStart" . <br> //          lumaValue,      . <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> // ,      lumaValue <br> int tempSum = numProcessedPixels + numPixels; <br> <br> //  ,  pixelsToConsiderStart,    . <br> // ,      lumaValue. <br> //  , pixelsToConsiderStart -   "" ,   ,    . <br> [flatten] <br> if (tempSum &gt; pixelsToConsiderStart) <br> { <br> bExitLoop = true; <br> } <br> else <br> { <br> numProcessedPixels = tempSum; <br> lumaValue++; <br> } <br> }</code> <br> <br>  O n√∫mero misterioso "-1" da linha 21 do c√≥digo do assembler est√° associado √† condi√ß√£o booleana para execu√ß√£o de loop (eu descobri isso quase por acidente). <br><br>  Tendo recebido o n√∫mero de pixels das c√©lulas <i>lumaValue</i> e do pr√≥prio <i>lumaValue</i> , podemos passar para o segundo ciclo. <br><br>  A tarefa do segundo ciclo √© calcular a influ√™ncia dos pixels e o brilho m√©dio. <br><br>  Come√ßamos com <i>lumaValue</i> calculado no primeiro loop. <br><br> <code>float finalAvgLuminance = 0.0f; <br> <br> //       <br> uint numProcessedPixelStart = numProcessedPixels; <br> <br> //    -      . <br> //    ,    ,        lumaValue. <br> //      [0-255],     ,    ,   ,    <br> //    pixelsToConsiderEnd. <br> //          . <br> bExitLoop = false; <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> //      <br> numProcessedPixels += numPixels; <br> <br> //    ,    [0-255] (uint) <br> uint encodedLumaUint = lumaValue; <br> <br> //        <br> float numberOfPixelsWithCurrentLuma = numPixels; <br> <br> //    ,    [0-255] (float) <br> float encodedLumaFloat = encodedLumaUint;</code> <br> <br>  Nesta fase, obtivemos o valor do brilho codificado no intervalo [0.0f-255.f]. <br><br>  O processo de decodifica√ß√£o √© bastante simples - voc√™ precisa reverter o c√°lculo do est√°gio de codifica√ß√£o. <br><br>  Uma breve repeti√ß√£o do processo de codifica√ß√£o: <br><br> <code>float luma = dot( hdrPixelColor, float3(0.2126, 0.7152, 0.0722) ); <br> ... <br> float outLuma; <br> <br> //   log(0)  undef,  log(1) = 0 <br> outLuma = luma + 1.0; <br> <br> //   <br> outLuma = log( outLuma ); <br> <br> //   128,   log(1) * 128 = 0, log(2,71828) * 128 = 128, log(7,38905) * 128 = 256 <br> outLuma = outLuma * 128 <br> <br> //   uint <br> uint outLumaUint = min( (uint) outLuma, 255);</code> <br> <br>  Para decodificar o brilho, revertemos o processo de codifica√ß√£o, por exemplo, assim: <br><br> <code>//    0.5f (  ,    ) <br> float fDecodedLuma = encodedLumaFloat + 0.5; <br> <br> //   : <br> <br> //   128 <br> fDecodedLuma /= 128.0; <br> <br> // exp(x),   log(x) <br> fDecodedLuma = exp(fDecodedLuma); <br> <br> //  1.0 <br> fDecodedLuma -= 1.0;</code> <br> <br>  Em seguida, calculamos a distribui√ß√£o multiplicando o n√∫mero de pixels com um determinado brilho pelo brilho decodificado e somando-os at√© chegarmos ao processamento dos pixels de <i>pixelsToConsiderEnd</i> . <br><br>          . <br><br>     ( ): <br><br> <code>//     <br> float fCurrentLumaContribution = numberOfPixelsWithCurrentLuma * fDecodedLuma; <br> <br> // ()       . <br> float tempTotalContribution = fCurrentLumaContribution + finalAvgLuminance; <br> <br> <br> [flatten] <br> if (numProcessedPixels &gt; pixelsToConsiderEnd ) <br> { <br> //     <br> bExitLoop = true; <br> <br> //      ,     . <br> //         <br> int diff = numProcessedPixels - numProcessedPixelStart; <br> <br> //     <br> finalAvgLuminance = tempTotalContribution / float(diff); <br> } <br> else <br> { <br> //       lumaValue <br> finalAvgLuminance = tempTotalContribution; <br> lumaValue++; <br> } <br> } <br> <br> //    <br> g_avgLuminance[uint2(0,0)] = finalAvgLuminance;</code> <br> <br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HLSLexplorer</a> ,             ¬´ 3¬ª (     !). <br><br>    .           .  : <br><br> 1)  ¬´¬ª   ,      ,    . <br><br> 2)        RenderDoc (v. 1.2). <br><br>  ¬´ld_structured_indexable¬ª   ,      0   ,    , -    . <br><br>          ,     ( .   ),   RenderDoc         ‚Äî     ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/a0e/74f/de1a0e74f0f6619994d1edc9621d148d.png"></div><br> <i> .  ‚Äî  ,  ‚Äî   .</i> <br><br><h2>  8.     </h2><br>          ¬´ 3¬ª (  ‚Äî   ¬´  ¬ª). <br><br>  ‚Äî    ,        ,        TW3   . <br><br>     ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/099/b6c/53f099b6ccfcef0eeb0755ced73894b9.jpg"></div><br>       ,      .    ,  ‚Äî    (. ),     ,    .       ,     ,       (   ),    . <br><br>  ,       ,  MinDepth  MaxDepth  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">D3D11_VIEWPORT</a>   0.0 (  ,     ).     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/999/ec7/6f5999ec7ca1176dfac370f60820d97f.jpg"></div><br> <i>,    </i> <br><br>  , ,  .     : <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[267], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_input_ps linear v1.w <br> dcl_input_ps linear v2.xyzw <br> dcl_input_ps linear v3.xy <br> dcl_input_ps linear v4.xy <br> dcl_output o0.xyzw <br> dcl_temps 3 <br> 0: mov r0.x, -cb0[0].w <br> 1: mov r0.y, l(0) <br> 2: add r0.xy, r0.xyxx, v2.xyxx <br> 3: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, r0.xyxx, t0.xyzw, s0 <br> 4: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 5: log r0.w, r0.w <br> 6: mul r0.w, r0.w, l(2.200000) <br> 7: exp r0.w, r0.w <br> 8: add r0.xyz, r0.xyzx, r0.xyzx <br> 9: dp3 r1.x, r0.xyzx, r0.xyzx <br> 10: rsq r1.x, r1.x <br> 11: mul r0.xyz, r0.xyzx, r1.xxxx <br> 12: mul r1.xy, r0.yyyy, v3.xyxx <br> 13: mad r0.xy, v4.xyxx, r0.xxxx, r1.xyxx <br> 14: mad r0.xy, v2.zwzz, r0.zzzz, r0.xyxx <br> 15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185) <br> 17: sincos r1.x, r2.x, r0.z <br> 18: mov r2.y, r1.x <br> 19: dp2_sat r0.x, r0.xyxx, r2.xyxx <br> 20: mul r0.xyz, r0.xxxx, cb12[266].xyzx <br> 21: mul r0.xyz, r0.xyzx, r0.wwww <br> 22: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 23: add_sat r0.w, -v1.w, l(1.000000) <br> 24: mul r0.w, r0.w, cb2[2].w <br> 25: mul o0.xyz, r0.wwww, r0.xyzx <br> 26: mov o0.w, l(0) <br> 27: ret</code> <br> <br>   ,      ¬´  ¬ª,  ‚Äî  . <br><br>       . <br><br> cb0[0].w      X.             . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/ddb/c02/fc2ddbc0262d27002f70d837a623c366.jpg"></div><br> <i>    </i> <br><br>        (1024x512).  RGB-   ,   - ‚Äî   . ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/733/1a1/3927331a17867d712e667c36a0ee6641.jpg"></div><br> <i>-  ‚Äî    .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/542/d70/c64542d70a7e3b58aa9426f12e8880d7.jpg"></div><br> <i>RGB-  ‚Äî   .</i> <br><br>    ,   RGBA-.        -  .    HLSL-    , : <br><br> <code>float4 MoonPS(in InputStruct IN) : SV_Target0 <br> { <br> //  Texcoords <br> float2 uvOffsets = float2(-cb0_v0.w, 0.0); <br> <br> //  texcoords <br> float2 uv = IN.param2.xy + uvOffsets; <br> <br> //   <br> float4 sampledTexture = texture0.Sample( sampler0, uv); <br> <br> //    -  - <br> float moonColorTex = pow(sampledTexture.a, 2.2 ); <br> <br> //     [0,1]   [-1,1]. <br> // : sampledTexture.xyz * 2.0 - 1.0    <br> float3 sampledNormal = normalize((sampledTexture.xyz - 0.5) * 2);</code> <br> <br>      ,     XY. ( The Witcher 3  Z  ,   Z-   1.0).      : <br><br> <code>//    <br> float3 Tangent = IN.param4.xyz; <br> float3 Normal = float3(IN.param2.zw, IN.param3.w); <br> float3 Bitangent = IN.param3.xyz; <br> <br> //  TBN <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> <br> //    XY <br> //   TBN  float3x2: 3 , 2  <br> float2 vNormal = mul(sampledNormal, (float3x2)TBN).xy;</code> <br> <br>        .     15-16: <br><br> <code>15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185)</code> <br> <br>     0.033864?  ,      ,      ,    29.53,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em dias! </font><font style="vertical-align: inherit;">√â isso que chamo de aten√ß√£o aos detalhes! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos assumir com seguran√ßa que cb0 [0] .y √© o n√∫mero de dias que se passaram durante o jogo. </font><font style="vertical-align: inherit;">Um desvio adicional √© usado aqui, usado como o deslocamento ao longo do eixo x da textura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo recebido esse coeficiente, multiplicamos por 2 * Pi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, usando sincos, calculamos outro vetor 2D. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao calcular o produto escalar entre o vetor normal e o vetor "lua", uma fase da lua √© simulada. </font><font style="vertical-align: inherit;">Veja as capturas de tela com diferentes fases da lua:</font></font><br><br> <code>//  . <br> //   days/29.53 + bias. <br> float phase = cb0_v0.y * (1.0 / SYNODIC_MONTH_LENGTH) + cb0_v0.w; <br> <br> //   2*PI.  , 29.53     <br> //   sin/cos. <br> phase *= TWOPI; <br> <br> //      . <br> float outSin = 0.0; <br> float outCos = 0.0; <br> sincos(phase, outSin, outCos); <br> <br> //    <br> float lunarPhase = saturate( dot(vNormal, float2(outCos, outSin)) );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c54/e7f/648/c54e7f6488b10d402a7f4b45e61d455d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/133/edc/899133edc0c04c67ffb4987748e908b7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O passo final √© executar uma s√©rie de opera√ß√µes de multiplica√ß√£o para calcular a cor final. </font><font style="vertical-align: inherit;">Voc√™ provavelmente n√£o entende por que esse sombreador envia um valor alfa de 0,0 para a sa√≠da. </font><font style="vertical-align: inherit;">Isso ocorre porque a lua √© renderizada com a mistura ativada:</font></font><br><br> <code>//        . <br> <br> // cb12_v266.xyz ,      . <br> //  (1.54, 2.82, 4.13) <br> float3 moonSurfaceGlowColor = cb12_v266.xyz; <br> <br> float3 moonColor = lunarPhase * moonSurfaceGlowColor; <br> moonColor = moonColorTex * moonColor; <br> <br> // cb_v2.xyz - , , ,  (1.0, 1.0, 1.0) <br> moonColor *= cb2_v2.xyz; <br> <br> //   ,    , .  -   . <br> //     ,         , <br> //   . <br> float paramHorizon = saturate(1.0 - IN.param1.w); <br> paramHorizon *= cb2_v2.w; <br> <br> moonColor *= paramHorizon; <br> <br> //        <br> return float4(moonColor, 0.0);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/549/32c/2d954932c188bcdcdd0a156796b85da7.jpg"></div><br>       (),      . <br><br>     ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .               RenderDoc    (  ¬´MoonPS¬ª  ¬´EditedShaderPS¬ª). <br><br>  :      : <br><br>  ‚Äî  ,  ‚Äî    . <br><br>       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff8/c4a/8fa/ff8c4a8fa103b9592941c965ad060729.jpg"></div><br>  ,      . <br><br><h2>  9. G- </h2><br>          (gbuffer)  The Witcher 3. <br><br>  ,       (deferred shading). <br><br>  :    ,         ,      . <br><br>   ( )   GBuffer    (, , specular color  ....),    ( )     . <br><br>   ‚Äî    ,           ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ,    . <br><br>   ,  GBuffer ‚Äî      .       .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  Crysis 3</a> . <br><br>          ¬´ 3:   ¬ª: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/6f5/537/2c36f5537e82217c31d0f5f682b17b6c.jpg"></div><br> <i>     </i> <br><br>  GBuffer     render target   DXGI_FORMAT_R8G8B8A8_UNORM    +    DXGI_FORMAT_D24_UNORM_S8_UINT. <br><br>   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/dec/857/309dec857a7839f41984b44ff82516ab.jpg"></div><br> <i>Render Target 0 ‚Äî RGB-,  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/44c/b90/16c44cb90b067cb420d921e101319bb0.jpg"></div><br> <i>Render Target 0 ‚Äî -.  ,   ,    .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/f1a/cf3/de9f1acf36c9f9e18ec6f4a9708ede11.jpg"></div><br> <i>Render Target 1 ‚Äî RGB-.       [0-1].</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/a60/1e8/0a5a601e893d88a619b94f1ed7d21ae2.jpg"></div><br> <i>Render Target 1 ‚Äî -.    !</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fa/8f5/d61/7fa8f5d61cfc903b764eec1e9b46c431.jpg"></div><br> <i>Render Target 2 ‚Äî RGB-.   specular color!</i> <br><br>    -  (   ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/27d/dab/e7e27ddab2102174b3f63bb9037e28a0.jpg"></div><br> <i> . ,     .</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/77d/daa/e4e77ddaa01705381f956410f546fdf4.jpg"></div><br> <i>-,       ( ,   ..)</i> <br><br>    GBuffer.         ,         . <br><br>     ¬´¬ª  ,   : <br><br><h3>   </h3><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) O √∫nico buffer a limpar √© o buffer de profundidade / est√™ncil.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se voc√™ analisar as texturas mencionadas acima em um bom analisador de quadros, ficar√° um pouco surpreso, porque elas n√£o usam a chamada "Limpar", com exce√ß√£o de Profundidade / Est√™ncil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou seja, na realidade, RenderTarget1 se parece com isso (observe os pixels ‚Äúemba√ßados‚Äù no plano distante):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/16a/3a7/22a16a3a7df971c2d1609f15e254cd06.jpg"></div><br>     . <br><br>  :   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ClearRenderTargetView</a>   ,      . <br><br> <b>2)   ‚Äî  </b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>       .  Witcher 3  reversed-z.             . <br><br>   DirectX  : <br><br> a)     ¬´0¬ª,   ¬´1¬ª. <br><br>           ¬´1¬ª.     ¬´¬ª   0,    . <br><br> b)            <br><br> c)     ¬´¬ª  ¬´¬ª <br><br>  OpenGL      (.   ),    . <br><br> <b>3)     </b> <br><br> ,   .         . <br><br><h3>   </h3><br>         ,   GBuffer  . <br><br> ,    ,   ,   specular. <br><br> ,    ,    . <br><br>     ,     .          ,     (,   ,  ). <br><br>        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/635/aa0/262635aa0a42dde5353586c867bc91d1.jpg"></div><br> <i>  !</i> <br><br> ,  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/fde/9bb/9e4fde9bbe2ebcc3c1088eff5e3ea40d.jpg"></div><br> ,    albedo,    specular color.   . <br><br>   ,      : <br><br>    , texcoords,    . <br><br>    <u> </u> texcoords,   //   ,     .     (,        )      ,       . <br><br>     : <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[3], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t2 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 3 <br> 0: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v1.xyxx, t1.xyzw, s0 <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t0.xyzw, s0 <br> 2: add r1.w, r1.y, r1.x <br> 3: add r1.w, r1.z, r1.w <br> 4: mul r2.x, r1.w, l(0.333300) <br> 5: add r2.y, l(-1.000000), cb4[1].x <br> 6: mul r2.y, r2.y, l(0.500000) <br> 7: mov_sat r2.z, r2.y <br> 8: mad r1.w, r1.w, l(-0.666600), l(1.000000) <br> 9: mad r1.w, r2.z, r1.w, r2.x <br> 10: mul r2.xzw, r1.xxyz, cb4[0].xxyz <br> 11: mul_sat r2.xzw, r2.xxzw, l(1.500000, 0.000000, 1.500000, 1.500000) <br> 12: mul_sat r1.w, abs(r2.y), r1.w <br> 13: add r2.xyz, -r1.xyzx, r2.xzwx <br> 14: mad r1.xyz, r1.wwww, r2.xyzx, r1.xyzx <br> 15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx <br> 21: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r1.xyz, v3.xyzx, r0.xxxx, r1.xyzx <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r1.xyzx <br> 28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w <br> 46: dp3 r0.w, r0.xyzx, r0.xyzx <br> 47: rsq r0.w, r0.w <br> 48: mul r0.xyz, r0.wwww, r0.xyzx <br> 49: max r0.w, abs(r0.y), abs(r0.x) <br> 50: max r0.w, r0.w, abs(r0.z) <br> 51: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 52: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 53: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 54: lt r1.z, r1.y, r1.x <br> 55: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 56: div r1.z, r1.y, r1.x <br> 57: div r0.xyz, r0.xyzx, r0.wwww <br> 58: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 59: mul r0.xyz, r0.wwww, r0.xyzx <br> 60: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 61: mov o0.w, cb4[2].x <br> 62: mov o2.w, l(0) <br> 63: ret</code> <br> <br>     .         . <br><br>     ‚Äî      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e94/24c/abb/e9424cabbd31630a47b7489e0e32c6af.jpg"></div><br><h4> Albedo </h4><br>     .    <strike>¬´OutputColor.rgb = Texture.Sample(uv).rgb¬ª</strike> <br><br>   RGB   ( 1),  14  ‚Äî  ,    ¬´  ¬ª.      HLSL: <br><br> <code>float3 albedoColorFilter( in float3 color, in float desaturationFactor, in float3 desaturationValue ) <br> { <br> float sumColorComponents = color.r + color.g + color.b; <br> <br> float averageColorComponentValue = 0.3333 * sumColorComponents; <br> float oneMinusAverageColorComponentValue = 1.0 - averageColorComponentValue; <br> <br> float factor = 0.5 * (desaturationFactor - 1.0); <br> <br> float avgColorComponent = lerp(averageColorComponentValue, oneMinusAverageColorComponentValue, saturate(factor)); <br> float3 desaturatedColor = saturate(color * desaturationValue * 1.5); <br> <br> float mask = saturate( avgColorComponent * abs(factor) ); <br> <br> float3 finalColor = lerp( color, desaturatedColor, mask ); <br> return finalColor; <br> }</code> <br> <br>        ,      .     ¬´material cbuffer¬ª. cb4_v1.x   1.0,    ,  0.0,       <i>lerp</i> . <br><br>    .     <i>desaturationFactor</i>  4.0 (     1.0),  <i>desaturatedColor</i>   .    -  (0.2, 0.3, 0.4);    . ,          DX11-,   ,    <i>desaturatedColor</i>  float3( 0.25, 0.3, 0.45 ) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12f/184/2d9/12f1842d9d272fc057f35bc73439c4c1.jpg"></div><br> <i>desaturationFactor = 1.0 (   )</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/ead/3a3/03cead3a3d5a713e051e7d863d99ecb0.jpg"></div><br> <i>desaturationFactor = 2.0</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/c81/992/cafc81992ebb70914c1e9d6605b8ba17.jpg"></div><br> <i>desaturationFactor = 3.0</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f37/193/7fb/f371937fb39f94a887410a951f9eb628.jpg"></div><br> <i>desaturationFactor = 4.0</i> <br><br>  ,      ,       albedo. <br><br>  15-20   : <br><br> <code>15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx</code> <br> <br> v0.z ‚Äî      ,    .    ,   v0.z      . <br><br> ,   - ,        albedo,    v0.z  0,   . HLSL: <br><br> <code>/* ALBEDO */ <br> //     (?) <br> float3 albedoColor = albedoColorFilter( colorTex, cb4_v1.x, cb4_v0.rgb ); <br> float albedoMaxComponent = getMaxComponent( albedoColor ); <br> <br> //   ,   <br> //       "paramZ"   0 <br> float paramZ = Input.out0.z; // ,    0 <br> <br> // ,  0.70  0.85      <br> //       lerp,     . <br> float param = (albedoMaxComponent &gt; 0.22) ? 0.70 : 0.85; <br> float mulParam = lerp(1, param, paramZ); <br> <br> //  <br> pout.RT0.rgb = albedoColor * mulParam; <br> pout.RT0.a = cb4_v2.x;</code> <br> <br>   RT0.a, ,   ,      ,        ,  ,   .  ? <br><br>     render target! <br><br><h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar descompactando o mapa normal e, como sempre, vincularemos os normais: </font><font style="vertical-align: inherit;">at√© agora, nada de surpreendente. </font><i><font style="vertical-align: inherit;">Veja as linhas 28-33:</font></i><font style="vertical-align: inherit;"> Podemos escrev√™-las mais ou menos da seguinte maneira: </font><font style="vertical-align: inherit;">N√£o tenho certeza se est√° correto escrever. </font><font style="vertical-align: inherit;">Se voc√™ souber o que √© essa opera√ß√£o matem√°tica, me avise. </font><font style="vertical-align: inherit;">Vemos que o pixel shader usa SV_IsFrontFace.</font></font><br><br> <code>/*  */ <br> float3 sampledNormal = ((normalTex.xyz - 0.5) * 2); <br> <br> //     TBN <br> float3 Tangent = Input.TangentW.xyz; <br> float3 Normal = Input.NormalW.xyz; <br> float3 Bitangent; <br> Bitangent.x = Input.out0.w; <br> Bitangent.yz = Input.out1.zw; <br> <br> //      ;  ,  ,   normal-tbn <br> //      'mad'   'mov' <br> Bitangent = saturate(Bitangent); <br> <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> float3 normal = mul( sampledNormal, TBN );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <code>28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>[branch] if (bIsFrontFace &lt;= 0) <br> { <br> float cosTheta = dot(Input.NormalW, normal); <br> float3 invNormal = cosTheta * Input.NormalW; <br> normal = normal - 2*invNormal; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br>  O que √© isso<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documenta√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vem para ajudar </font><font style="vertical-align: inherit;">(eu queria escrever "msdn", mas ...):</font></font><br><br><blockquote> ,     .     IsFrontFace   true.   ,    ( wireframe),   IsFrontFace     solid mode.       ,     ‚Äî  . </blockquote><br>     .    ,      (wireframe) . ,         (   )   wireframe. <br><br>  :        / ,     gbuffer [0-1]  / : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/46b/81b/59846b81b8b9ed57f0441f29e22e6656.jpg"></div><br> <i>   </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/590/7e1/a97/5907e1a978e58b6fa362ef2e4b6187a8.jpg"></div><br> <i>   </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/09a/c0e/74509ac0e56fa639ec4ae2d70a39be44.png"></div><br> <i> [0-1]  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/2f8/622/db82f86223182135807d316fe479ff08.png"></div><br> <i> [0-1]  </i> <br><br>  ,   render target  GBuffer   R8G8B8A8_UNORM?  ,      256  .      ? <br><br>   Gbuffer       ‚Äî  , ,  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br> ,     ,    .  ,         ,    13...: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/e4a/0bf/ab1e4a0bf128bfed8837d3cd081748f8.jpg"></div><br><br>  Ha!  The Witcher 3     " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Best Fit Normals</a> ".        ( ).      2009-2010   Crytek,   CryEngine   , BFN  <a href="">open source</a> . <br><br> BFN    ¬´¬ª . <br><br>      BFN      [-1;1]  [0, 1]. <br><br><h3> Specular </h3><br>    34,    specular: <br><br> <code>34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx</code> <br> <br>  ,      Albedo  ¬´¬ª: <br><br>    . ,    ¬´¬ª       specular color,     ‚Ä¶   0,        . <br><br> HLSL: <br><br> <code>/* SPECULAR */ <br> float3 specularTex = texture2.Sample( samplerAnisoWrap, Texcoords ).rgb; <br> <br> //   ,    Albedo.  . ,    <br> // -        "". <br> //      paramZ   0,    <br> //  . <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> float3 specB = (specularMaxComponent &gt; 0.2) ? specularTex : float3(0.12, 0.12, 0.12); <br> float3 finalSpec = lerp(specularTex, specB, paramZ); <br> pout.RT2.xyz = finalSpec;</code> <br> <br><h3>   </h3><br>    ,       ,    ,      .   ,  -      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/9e5/bd1/5d29e5bd1cb4888593139c38630e3f8e.jpg"></div><br> <i>-  ¬´ ¬ª.</i> <br><br>  : <br><br> <code>41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w</code> <br> <br>      ‚Äî v0.z!     albedo   specular: <br><br> <code>/* REFLECTIVITY */ <br> float reflectivity = normalTex.a; <br> float reflectivity2 = (reflectivity &lt; 0.33) ? (reflectivity * 0.95) : 0.33; <br> <br> float finalReflectivity = lerp(reflectivity, reflectivity2, paramZ); <br> pout.RT1.a = finalReflectivity;</code> <br> <br>  √ìtimo!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© o fim da an√°lise da primeira vers√£o do pixel shader. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° uma compara√ß√£o do meu sombreador (esquerda) com o original (direita):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/f18/47b/2c1f1847b5ceef3cd0e2f8dfba45d2a6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essas diferen√ßas n√£o afetam os c√°lculos, ent√£o meu trabalho aqui est√° conclu√≠do. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader: Albedo + op√ß√£o normal </font></font></h3><br>      ,     albedo  ,   specular.    : <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 4 <br> 0: mul r0.x, v0.z, cb4[0].x <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t1.xyzw, s0 <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.yzw, v1.xyxx, t0.wxyz, s0 <br> 3: add r2.x, r0.z, r0.y <br> 4: add r2.x, r0.w, r2.x <br> 5: add r2.z, l(-1.000000), cb4[2].x <br> 6: mul r2.yz, r2.xxzx, l(0.000000, 0.333300, 0.500000, 0.000000) <br> 7: mov_sat r2.w, r2.z <br> 8: mad r2.x, r2.x, l(-0.666600), l(1.000000) <br> 9: mad r2.x, r2.w, r2.x, r2.y <br> 10: mul r3.xyz, r0.yzwy, cb4[1].xyzx <br> 11: mul_sat r3.xyz, r3.xyzx, l(1.500000, 1.500000, 1.500000, 0.000000) <br> 12: mul_sat r2.x, abs(r2.z), r2.x <br> 13: add r2.yzw, -r0.yyzw, r3.xxyz <br> 14: mad r0.yzw, r2.xxxx, r2.yyzw, r0.yyzw <br> 15: max r2.x, r0.w, r0.z <br> 16: max r2.x, r0.y, r2.x <br> 17: lt r2.x, l(0.220000), r2.x <br> 18: movc r2.x, r2.x, l(-0.300000), l(-0.150000) <br> 19: mad r0.x, r0.x, r2.x, l(1.000000) <br> 20: mul o0.xyz, r0.xxxx, r0.yzwy <br> 21: add r0.xyz, r1.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r0.xyw, v3.xyxz, r0.xxxx, r1.xyxz <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r0.xywx <br> 28: uge r0.w, l(0), v4.x <br> 29: if_nz r0.w <br> 30: dp3 r0.w, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r0.wwww, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx <br> 43: max r0.w, r1.z, r1.y <br> 44: max r0.w, r0.w, r1.x <br> 45: lt r0.w, l(0.200000), r0.w <br> 46: movc r2.xyz, r0.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 47: add r2.xyz, -r1.xyzx, r2.xyzx <br> 48: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 49: lt r0.w, r1.w, l(0.330000) <br> 50: mul r1.x, r1.w, l(0.950000) <br> 51: movc r0.w, r0.w, r1.x, l(0.330000) <br> 52: add r0.w, -r1.w, r0.w <br> 53: mad o1.w, v0.z, r0.w, r1.w <br> 54: lt r0.w, l(0), cb4[7].x <br> 55: and o2.w, r0.w, l(0.064706) <br> 56: dp3 r0.w, r0.xyzx, r0.xyzx <br> 57: rsq r0.w, r0.w <br> 58: mul r0.xyz, r0.wwww, r0.xyzx <br> 59: max r0.w, abs(r0.y), abs(r0.x) <br> 60: max r0.w, r0.w, abs(r0.z) <br> 61: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 62: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 63: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 64: lt r1.z, r1.y, r1.x <br> 65: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 66: div r1.z, r1.y, r1.x <br> 67: div r0.xyz, r0.xyzx, r0.wwww <br> 68: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 69: mul r0.xyz, r0.wwww, r0.xyzx <br> 70: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 71: mov o0.w, cb4[6].x <br> 72: ret</code> <br> <br>        : <br><br> a) <b> 1, 19</b> :   v0.z   cb4[0].x   ,        albedo   19.      ¬´¬ª  v0.z. <br><br> b) <b> 54-55</b> : o2.w    ,  (cb4[7].x &gt; 0.0 ) <br><br>      ¬´-  ‚Äî ¬ª    .    : <br><br> <code>pout.RT2.w = (cb4_v7.x &gt; 0.0) ? (16.5/255.0) : 0.0;</code> <br> <br> c) <b> 34-42</b> :    specular. <br><br>    specular.        : <br><br> <code>34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx</code> <br> <br> ,     (1 ‚Äî  ).  ,  HLSL    : <br><br> <code>float oneMinusReflectivity = 1.0 - normalTex.a; <br> float3 specularTex = pow(cb4_v3.rgb, 2.2); <br> oneMinusReflectivity = oneMinusReflectivity * cb4_v4.x + cb4_v5.x; <br> specularTex = saturate(specularTex * oneMinusReflectivity); <br> specularTex = pow(specularTex, 1.0/2.2); <br> <br> //     ... <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> ...</code> <br> <br> ,           .        specular color. <br><br>     ,    . <br><br> 72    ‚Äî       WinMerge,     :       ,   .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HLSLexplorer</a>     ! <br><br><h3>   </h3><br> ‚Ä¶     , , ,     . <br><br> ,           ,     gbuffer The Witcher 3   .        ,   ,     ,       . <br><br>          pastebin: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> 1 ‚Äî   specular</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> 2 ‚Äî   specular</a> <br><br><h2>  10.     </h2><br>        ,     ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> /   .         . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VXt4PEEqV2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>          ,    CD Projekt Red  .  ! <br><br>         : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/62a/eb6/a9a62aeb6050efd2404f9d352fc89d33.png"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/e43/fcf/9aae43fcf34413a4810778e101b8a209.png"></div><br> <i>  </i> <br><br><h3>  </h3><br>     .      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/df3/add/fc4df3addf2524bc18f91c46a42fcd6a.jpg"></div><br> <i>   </i> <br><br>            ‚Äî      (0.0 ‚Äî 1.0). <br><br>        ‚Ä¶ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1d/a35/c00/c1da35c0080225e7a47d8010c42aeab8.jpg"></div><br>     : Texcoords  Instance_Transform. <br><br> Texcoords   : U        [0.02777 ‚Äî 1.02734]. V     1.0,    ‚Äî 0.0.  ,        . <br><br>       ,      ,       INSTANCE_TRANSFORM.     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e88/791/17e/e8879117edb6f1dd9b53d3e7334a22df.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/fb8/697/adffb8697a86ac86b935a00d6ae23dda.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/608/599/f6c/608599f6cf3930889c92df1a256991af.jpg"></div><br>   , ?   ,      ,   ! <br><br> <code>XMMATRIX mat( -227.7472, 159.8043, 374.0736, -116.4951, <br> -194.7577, -173.3836, -494.4982, 238.6908, <br> -14.16466, -185.4743, 784.564, -1.45565, <br> 0.0, 0.0, 0.0, 1.0 ); <br> <br> mat = XMMatrixTranspose( mat ); <br> <br> XMVECTOR vScale; <br> XMVECTOR vRotateQuat; <br> XMVECTOR vTranslation; <br> XMMatrixDecompose( &amp;vScale, &amp;vRotateQuat, &amp;vTranslation, mat ); <br> <br> //  ... <br> XMMATRIX matRotate = XMMatrixRotationQuaternion( vRotateQuat );</code> <br> <br>   : <br><br> <code>vRotateQuat: (0.0924987569, -0.314900011, 0.883411944, -0.334462732) <br> <br> vScale: (299.999969, 300.000000, 1000.00012) <br> <br> vTranslation: (-116.495102, 238.690796, -1.45564997)</code> <br> <br>        : (-116.5338, 234.8695, 2.09) <br><br>  ,   ,         ( TW3  Z  ),     ,  . <br><br>        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/457/ca6/f60457ca61dd2d15ec3805b387e71def.jpg"></div><br> <i>    . ,      .</i> <br><br><h3>   </h3><br>          . <br><br>        : <br><br> <code>vs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb1[7], immediateIndexed <br> dcl_constantbuffer cb2[6], immediateIndexed <br> dcl_input v0.xyz <br> dcl_input v1.xy <br> dcl_input v4.xyzw <br> dcl_input v5.xyzw <br> dcl_input v6.xyzw <br> dcl_input v7.xyzw <br> dcl_output o0.xyz <br> dcl_output o1.xyzw <br> dcl_output_siv o2.xyzw, position <br> dcl_temps 2 <br> 0: mov o0.xy, v1.xyxx <br> 1: mul r0.xyzw, v5.xyzw, cb1[6].yyyy <br> 2: mad r0.xyzw, v4.xyzw, cb1[6].xxxx, r0.xyzw <br> 3: mad r0.xyzw, v6.xyzw, cb1[6].zzzz, r0.xyzw <br> 4: mad r0.xyzw, cb1[6].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 5: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx <br> 6: mov r1.w, l(1.000000) <br> 7: dp4 o0.z, r1.xyzw, r0.xyzw <br> 8: mov o1.xyzw, v7.xyzw <br> 9: mul r0.xyzw, v5.xyzw, cb1[0].yyyy <br> 10: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw <br> 11: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw <br> 12: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 13: dp4 o2.x, r1.xyzw, r0.xyzw <br> 14: mul r0.xyzw, v5.xyzw, cb1[1].yyyy <br> 15: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw <br> 16: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw <br> 17: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 18: dp4 o2.y, r1.xyzw, r0.xyzw <br> 19: mul r0.xyzw, v5.xyzw, cb1[2].yyyy <br> 20: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw <br> 21: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw <br> 22: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 23: dp4 o2.z, r1.xyzw, r0.xyzw <br> 24: mul r0.xyzw, v5.xyzw, cb1[3].yyyy <br> 25: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw <br> 26: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw <br> 27: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 28: dp4 o2.w, r1.xyzw, r0.xyzw <br> 29: ret</code> <br> <br>     Texcoords ( 0)  Instance_LOD_Params ( 8),      : SV_Position ( )  Height ( .z)   . <br><br> ,       [0-1]?  ,               .  ! <br><br>    scale = float3(4, 4, 2),  bias = float3(-2, -2, -1).&lt; <br><br> ,     9  28 ‚Äî    row-major-. <br><br>         HLSL: <br><br> <code>cbuffer cbPerFrame : register (b1) <br> { <br> row_major float4x4 g_viewProjMatrix; <br> row_major float4x4 g_rainShaftsViewProjMatrix; <br> } <br> <br> cbuffer cbPerObject : register (b2) <br> { <br> float4x4 g_mtxWorld; <br> float4 g_modelScale; <br> float4 g_modelBias; <br> } <br> <br> struct VS_INPUT <br> { <br> float3 PositionW : POSITION; <br> float2 Texcoord : TEXCOORD; <br> float3 NormalW : NORMAL; <br> float3 TangentW : TANGENT; <br> float4 InstanceTransform0 : INSTANCE_TRANSFORM0; <br> float4 InstanceTransform1 : INSTANCE_TRANSFORM1; <br> float4 InstanceTransform2 : INSTANCE_TRANSFORM2; <br> float4 InstanceLODParams : INSTANCE_LOD_PARAMS; <br> }; <br> <br> struct VS_OUTPUT <br> { <br> float3 TexcoordAndZ : Texcoord0; <br> <br> float4 LODParams : LODParams; <br> float4 PositionH : SV_Position; <br> }; <br> <br> VS_OUTPUT RainShaftsVS( VS_INPUT Input ) <br> { <br> VS_OUTPUT Output = (VS_OUTPUT)0; <br> <br> //    <br> Output.TexcoordAndZ.xy = Input.Texcoord; <br> Output.LODParams = Input.InstanceLODParams; <br> <br> //   <br> float3 meshScale = g_modelScale.xyz; // float3( 4, 4, 2 ); <br> float3 meshBias = g_modelBias.xyz; // float3( -2, -2, -1 ); <br> float3 PositionL = Input.PositionW * meshScale + meshBias; <br> <br> //    instanceWorld  float4s: <br> float4x4 matInstanceWorld = float4x4(Input.InstanceTransform0, Input.InstanceTransform1, <br> Input.InstanceTransform2 , float4(0, 0, 0, 1) ); <br> <br> //     (.z) <br> float4x4 matWorldInstanceLod = mul( g_rainShaftsViewProjMatrix, matInstanceWorld ); <br> Output.TexcoordAndZ.z = mul( float4(PositionL, 1.0), transpose(matWorldInstanceLod) ).z; <br> <br> // SV_Posiiton <br> float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld ); <br> Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) ); <br> <br> return Output; <br> }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compara√ß√£o do meu sombreador (esquerda) e do original (direita): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef3/4f3/4ed/ef34f34edbc63113a08f47b7cde00df0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As diferen√ßas n√£o afetam os c√°lculos. </font><font style="vertical-align: inherit;">Eu injetei meu shader no quadro e estava tudo bem!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel shader </font></font></h3><br>  Finalmente!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para come√ßar, mostrarei a entrada: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duas texturas s√£o usadas aqui: a textura do ru√≠do e o buffer de profundidade:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/558/fc3/83a558fc3c8c7e723eb85308b12657d6.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/0da/111/db50da111880f6b934d8bed6b74491e6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valores de buffers constantes: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/394/bdc/a12394bdc039e522beeff97b8e41cd80.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37a/c47/485/37ac47485335960b2efbefc9f315ef14.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/e70/38a/4e7e7038a1bc956aadbb695d70b80ded.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/775/bc4/7ae775bc4a9388feceaa1ddf8c0a214a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E o c√≥digo do assembler para o pixel shader: </font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[8], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s15, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t15 <br> dcl_input_ps linear v0.xyz <br> dcl_input_ps linear v1.w <br> dcl_input_ps_siv v2.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 1 <br> 0: mul r0.xy, cb0[0].xxxx, cb4[5].xyxx <br> 1: mad r0.xy, v0.xyxx, cb4[4].xyxx, r0.xyxx <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t0.xyzw, s0 <br> 3: add r0.y, -cb4[2].x, cb4[3].x <br> 4: mad_sat r0.x, r0.x, r0.y, cb4[2].x <br> 5: mul r0.x, r0.x, v0.y <br> 6: mul r0.x, r0.x, v1.w <br> 7: mul r0.x, r0.x, cb4[1].x <br> 8: mul r0.yz, v2.xxyx, cb0[1].zzwz <br> 9: sample_l(texture2d)(float,float,float,float) r0.y, r0.yzyy, t15.yxzw, s15, l(0) <br> 10: mad r0.y, r0.y, cb12[22].x, cb12[22].y <br> 11: mad r0.y, r0.y, cb12[21].x, cb12[21].y <br> 12: max r0.y, r0.y, l(0.000100) <br> 13: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 14: add r0.y, r0.y, -v0.z <br> 15: mul_sat r0.y, r0.y, cb4[6].x <br> 16: mul_sat r0.x, r0.y, r0.x <br> 17: mad r0.y, cb0[7].y, r0.x, -r0.x <br> 18: mad r0.x, cb4[7].x, r0.y, r0.x <br> 19: mul r0.xyz, r0.xxxx, cb4[0].xyzx <br> 20: log r0.xyz, r0.xyzx <br> 21: mul r0.xyz, r0.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 22: exp r0.xyz, r0.xyzx <br> 23: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 24: mul o0.xyz, r0.xyzx, cb2[2].wwww <br> 25: mov o0.w, l(0) <br> 26: ret</code> <br> <br>  Uau!   ,        . <br><br>    ?     UV,     cbuffer (cb0[0].x)  /.  texcoords       ( 2). <br><br>     ,      min/max ( 0  1). <br><br>    ,     V (,   V   1  0?) ‚Äî  5. <br><br>     ¬´ ¬ª ‚Äî    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/1a8/801/0641a88012fb6ec18797c0b143fb5f27.png"></div><br> ,    (, ...) .  ,       ‚Äî           : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/8f5/ffd/1068f5ffde6b0efba2c4894b88d5ddf5.png"></div><br> <i> </i> <br><br>    ,      (    ).   ,     , ¬´  ¬ª. <br><br>     : <br><br> <code>farObjectsMask = saturate( (FrustumDepth - CylinderWorldSpaceHeight) * 0.001 );</code> <br> <br> (0.001   ),     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/02a/153/9ff02a1534054fb27b370d5cd58e7a75.png"></div><br> (    Sharpen    ,        .) <br><br>   ,        ,      ,       ,  0.0004. <br><br>      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/fb2/c1e/c49fb2c1e1dd2ee8d38d81c0cccb0daf.png"></div><br>     ( 16),     ,      (  ,   ),         ( 19),  - ( 20-22)    (23-24). <br><br>        -.  ,       : <br><br> <code>FinalColor = SourceColor * 1.0 + (1.0 - SourceAlpha) * DestColor</code> <br> <br>      ,   ,    : <br><br> SourceColor ‚Äî   RGB-   ,  DestColor ‚Äî   RGB-   render target.   SourceAlpha   0.0,    : <code>FinalColor = SourceColor + DestColor</code> . <br><br>  ,     .     (0, 0, 0),     . <br><br>     HLSL ‚Äî ,        : <br><br> <code>struct VS_OUTPUT <br> { <br> float3 TexcoordAndWorldspaceHeight : Texcoord0; <br> float4 LODParams : LODParams; // float4(1,1,1,1) <br> float4 PositionH : SV_Position; <br> }; <br> <br> float getFrustumDepth( in float depth ) <br> { <br> // from [1-0] to [0-1] <br> float d = depth * cb12_v22.x + cb12_v22.y; <br> <br> // special coefficents <br> d = d * cb12_v21.x + cb12_v21.y; <br> <br> // return frustum depth <br> return 1.0 / max(d, 1e-4); <br> } <br> <br> float4 EditedShaderPS( in VS_OUTPUT Input ) : SV_Target0 <br> { <br> // * Input from Vertex Shader <br> float2 InputUV = Input.TexcoordAndWorldspaceHeight.xy; <br> float WorldHeight = Input.TexcoordAndWorldspaceHeight.z; <br> float LODParam = Input.LODParams.w; <br> <br> // * Inputs <br> float elapsedTime = cb0_v0.x; <br> float2 uvAnimation = cb4_v5.xy; <br> float2 uvScale = cb4_v4.xy; <br> float minValue = cb4_v2.x; // 0.0 <br> float maxValue = cb4_v3.x; // 1.0 <br> float3 shaftsColor = cb4_v0.rgb; // RGB( 147, 162, 173 ) <br> <br> float3 finalColorFilter = cb2_v2.rgb; // float3( 1.175, 1.296, 1.342 ); <br> float finalEffectIntensity = cb2_v2.w; <br> <br> float2 invViewportSize = cb0_v1.zw; <br> <br> float depthScale = cb4_v6.x; // 0.001 <br> <br> // sample noise <br> float2 uvOffsets = elapsedTime * uvAnimation; <br> float2 uv = InputUV * uvScale + uvOffsets; <br> float disturb = texture0.Sample( sampler0, uv ).x; <br> <br> // * Intensity mask <br> float intensity = saturate( lerp(minValue, maxValue, disturb) ); <br> intensity *= InputUV.y; // transition from (0, 1) <br> intensity *= LODParam; // usually 1.0 <br> intensity *= cb4_v1.x; // 1.0 <br> <br> // Sample depth <br> float2 ScreenUV = Input.PositionH.xy * invViewportSize; <br> float hardwareDepth = texture15.SampleLevel( sampler15, ScreenUV, 0 ).x; <br> float frustumDepth = getFrustumDepth( hardwareDepth ); <br> <br> <br> // * Calculate mask covering distant objects behind cylinder. <br> <br> // Seems that the input really is world-space height (.z component, see vertex shader) <br> float depth = frustumDepth - WorldHeight; <br> float distantObjectsMask = saturate( depth * depthScale ); <br> <br> // * calculate final mask <br> float finalEffectMask = saturate( intensity * distantObjectsMask ); <br> <br> // cb0_v7.y and cb4_v7.x are set to 1.0 so I didn't bother with naming them :) <br> float paramX = finalEffectMask; <br> float paramY = cb0_v7.y * finalEffectMask; <br> float effectAmount = lerp(paramX, paramY, cb4_v7.x); <br> <br> // color of shafts comes from contant buffer <br> float3 effectColor = effectAmount * shaftsColor; <br> <br> // gamma correction <br> effectColor = pow(effectColor, 2.2); <br> <br> // final multiplications <br> effectColor *= finalColorFilter; <br> effectColor *= finalEffectIntensity; <br> <br> // return with zero alpha 'cause the blending used here is: <br> // SourceColor * 1.0 + (1.0 - SrcAlpha) * DestColor <br> return float4( effectColor, 0.0 ); <br> }</code> <br> <br>    ,         ,    . <br><br> ,   .   ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437100/">https://habr.com/ru/post/pt437100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437088/index.html">Promo√ß√£o de uma startup no exterior: como alcan√ßar centenas de milhares de leitores que falam ingl√™s com o Medium</a></li>
<li><a href="../pt437092/index.html">A seguran√ßa dos algoritmos de aprendizado de m√°quina. Ataques de Python</a></li>
<li><a href="../pt437094/index.html">Impulsionamos o Atlassian Service Desk - o an√∫ncio da mitap e transmiss√£o ao vivo</a></li>
<li><a href="../pt437096/index.html">UDB. O que √© isso? Parte 4. Datapath ALU</a></li>
<li><a href="../pt437098/index.html">6 de fevereiro de Moscou, DI Telegraph - Cozinha QIWI grande em design de produto</a></li>
<li><a href="../pt437102/index.html">Novo encontro de campe√µes de Lego: Lego Boost</a></li>
<li><a href="../pt437104/index.html">Introsc√≥pio: bem, teste de unidade muito pregui√ßoso</a></li>
<li><a href="../pt437106/index.html">TI na zona .it</a></li>
<li><a href="../pt437108/index.html">A maioria dos textos na Internet √© escrita por loucos.</a></li>
<li><a href="../pt437110/index.html">Os nanomateriais est√£o mudando nosso mundo e ainda n√£o temos procedimentos para verificar sua seguran√ßa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>