<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó∫Ô∏è üë©üèª‚Äçüåæ üåã Toda la verdad sobre linux epoll üë®üèæ‚ÄçüöÄ üôåüèΩ üë∞üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bueno, o casi todo ... 





 Creo que el problema en Internet moderno es el exceso de informaci√≥n de diferente calidad. Encontrar material sobre un t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre linux epoll</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416669/"><p>  Bueno, o casi todo ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/91f/776/71c/91f77671c2186bc1f2393c47e0696ee9.png"></p><br><p>  Creo que el problema en Internet moderno es el exceso de informaci√≥n de diferente calidad.  Encontrar material sobre un tema de inter√©s no es un problema; el problema es distinguir el material bueno del material malo si tiene poca experiencia en este campo.  Observo una imagen cuando hay mucha informaci√≥n general "en la parte superior" (casi al nivel de una enumeraci√≥n simple), muy pocos art√≠culos detallados y ning√∫n art√≠culo de transici√≥n de simple a complejo.  Sin embargo, es el conocimiento de las caracter√≠sticas de un mecanismo particular que nos permite tomar una decisi√≥n informada durante el desarrollo. </p><br><p>  En el art√≠culo intentar√© revelar cu√°l es la diferencia fundamental entre <strong>epoll</strong> y otros mecanismos, qu√© lo hace √∫nico, as√≠ como citar los art√≠culos que solo necesita leer para comprender mejor las posibilidades y los problemas de <strong>epoll</strong> . </p><br><blockquote> Cualquiera puede empu√±ar un hacha, pero se necesita un verdadero guerrero para hacerla cantar melod√≠a. </blockquote><p>  Supongo que el lector est√° familiarizado con <strong>epoll</strong> , al menos lea la p√°gina del manual.  Se ha escrito lo <strong>suficiente</strong> sobre <strong>epoll</strong> , <strong>poll</strong> , <strong>select</strong> para que todos los que se desarrollan bajo Linux hayan escuchado al menos una vez. </p><a name="habracut"></a><br><h1 id="mnoga--fd">  Mucha fd </h1><br><p>  Cuando la gente habla sobre <strong>epoll,</strong> b√°sicamente escucho la tesis de que su "rendimiento es mejor cuando hay muchos descriptores de archivos". </p><br><p>  Solo quiero hacer una pregunta: ¬øcu√°nto es cu√°nto?  ¬øCu√°ntas conexiones se necesitan y, lo que es m√°s importante, bajo qu√© condiciones comenzar√° <strong>Epoll</strong> a proporcionar ganancias de rendimiento tangibles? </p><br><p>  Para aquellos que estudiaron <strong>epoll</strong> (hay bastante material, incluidos art√≠culos cient√≠ficos), la respuesta es obvia: es mejor si y solo si el n√∫mero de compuestos "esperando un evento" excede significativamente el n√∫mero de "listos para el procesamiento".  La marca de la cantidad, cuando la ganancia se vuelve tan significativa que simplemente no hay orina para ignorar este hecho, se consideran 10k compuestos [4]. </p><br><p>  La suposici√≥n de que la mayor√≠a de las conexiones estar√°n pendientes proviene de la l√≥gica de sonido y la supervisi√≥n de la carga de los servidores que est√°n en uso activo. </p><br><p>  Si el n√∫mero de compuestos activos se esfuerza por el n√∫mero total, <del>  no habr√° ganancia </del>  no habr√° ganancia significativa, se debe a una ganancia significativa solo porque <strong>epoll</strong> devuelve solo descriptores que requieren atenci√≥n, y la <strong>encuesta</strong> devuelve todos los descriptores que se agregaron para observaci√≥n. </p><br><p>  Obviamente, en el √∫ltimo caso, pasamos tiempo recorriendo todos los descriptores + gastos generales de copiar una matriz de eventos del n√∫cleo. </p><br><p>  De hecho, en la medici√≥n de rendimiento inicial, que se adjunt√≥ al parche [9], este punto no se enfatiza y solo se puede adivinar por la presencia de la utilidad deadcon mencionada en el art√≠culo (desafortunadamente, el c√≥digo de utilidad pipetest.c se pierde).  Por otro lado, en otras fuentes [6, 8] es muy dif√≠cil no darse cuenta, porque este hecho pr√°cticamente se destaca. </p><br><p>  La pregunta surge de inmediato, pero ¬øqu√© pasa ahora si no se planea dar servicio a <strong>tantos</strong> descriptores de archivos <strong>epoll,</strong> por as√≠ <strong>decirlo</strong> , y no es necesario? </p><br><p>  A pesar de que <strong>Epoll</strong> fue creado originalmente espec√≠ficamente para tales situaciones [5, 8, 9], esto est√° lejos de ser la √∫nica diferencia entre <strong>Epoll</strong> . </p><br><h1 id="epollet">  EPOLLET </h1><br><p>  Para empezar, veremos la diferencia entre los disparadores activados por el borde y los activados por nivel. Hay una muy buena declaraci√≥n sobre este tema en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interrupciones activadas por el nivel disparado</a> por el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">borde contra el nivel - Venkatesh Yadav</a> : </p><br><blockquote>  Interrupci√≥n en el nivel, es como un ni√±o.  Si el beb√© est√° llorando, debe renunciar a todo lo que hizo y correr hacia el beb√© para alimentarlo.  Luego vuelves a poner al beb√© en la cuna.  Si vuelve a llorar, no lo dejar√°s en ning√∫n lado, pero intentar√°s calmarlo.  Y mientras el ni√±o est√° llorando, no lo dejar√° por un momento, y volver√° a trabajar solo cuando se calme.  Pero digamos que salimos al jard√≠n (interrupci√≥n apagada) cuando el ni√±o comenz√≥ a llorar, luego, cuando regres√≥ a casa (interrupci√≥n encendida), lo primero que debe hacer es ir a ver al ni√±o.  Pero nunca sabr√°s que estaba llorando mientras estabas en el jard√≠n. <br><br>  La interrupci√≥n en el frente es como una ni√±era electr√≥nica para padres sordos.  Tan pronto como el ni√±o comienza a llorar en el dispositivo, se enciende una luz roja y se ilumina hasta que presiona el bot√≥n.  Incluso si el ni√±o comenz√≥ a llorar, pero se detuvo r√°pidamente y se durmi√≥, sabr√° que estaba llorando.  Pero si √©l comenz√≥ a llorar y usted presion√≥ el bot√≥n (confirmaci√≥n de interrupci√≥n), la luz no se encender√° incluso si contin√∫a llorando.  El nivel de sonido en la habitaci√≥n deber√≠a bajar y luego volver a subir para que se encienda la luz. </blockquote><p>  Si el <strong>epoll</strong> (as√≠ como <strong>sondeo</strong> / <strong>selecci√≥n</strong> ) se desbloquea en el comportamiento activado por nivel si el controlador est√° en el estado especificado y se considerar√° activo hasta que se borre este estado, entonces el disparo por borde se desbloquea solo cambiando el estado ordenado dado actual. </p><br><p>  Esto le permite manejar el evento m√°s tarde, y no inmediatamente despu√©s de la recepci√≥n (casi una analog√≠a directa con la mitad superior y la mitad inferior del controlador de interrupciones). </p><br><p>  Ejemplo espec√≠fico con epoll: </p><br><p>  Nivel disparado </p><br><ul><li>  asa a√±adida a <strong>epoll</strong> con bandera <strong>EPOLLIN</strong> </li><li>  <strong>epoll_wait ()</strong> bloquea mientras espera un evento </li><li>  escribir en el descriptor de archivo 19 bytes </li><li>  <strong>epoll_wait () se</strong> desbloquea con el evento <strong>EPOLLIN</strong> </li><li>  no hacemos nada con los datos que vinieron </li><li>  <strong>epoll_wait () se</strong> desbloquea nuevamente con el evento <strong>EPOLLIN</strong> </li></ul><br><p>  Y esto continuar√° hasta que contemos o restablezcamos completamente los datos del descriptor. </p><br><p>  Edge activado </p><br><ul><li>  asa a√±adida a <strong>epoll</strong> con banderas <strong>EPOLLIN |</strong>  <strong>EPOLLET</strong> </li><li>  <strong>epoll_wait ()</strong> bloquea mientras espera un evento </li><li>  escribir en el descriptor de archivo 19 bytes </li><li>  <strong>epoll_wait () se</strong> desbloquea con el evento <strong>EPOLLIN</strong> </li><li>  no hacemos nada con los datos que vinieron </li><li>  <strong>epoll_wait () est√°</strong> bloqueado esperando un nuevo evento </li><li>  escribe otros 19 bytes en el descriptor de archivo </li><li>  <strong>epoll_wait () se</strong> desbloquea con el nuevo evento <strong>EPOLLIN</strong> </li><li>  <strong>epoll_wait () est√°</strong> bloqueado esperando un nuevo evento </li></ul><br><p>  ejemplo simple: <a href="">epollet_socket.c</a> </p><br><p>  Este mecanismo est√° <strong>dise√±ado</strong> para evitar la devoluci√≥n de <strong>epoll_wait ()</strong> debido a un evento que ya se est√° procesando. </p><br><p>  Si, en el caso del nivel, al llamar a <strong>epoll_wait (), el</strong> kernel verifica si fd est√° en este estado, entonces edge omite esta verificaci√≥n e inmediatamente pone el proceso de llamada en estado de suspensi√≥n. </p><br><p>  <strong>EPOLLET</strong> es lo que hace que <strong>epoll</strong> O (1) sea un multiplexor para eventos. </p><br><p>  Es necesario aclarar sobre <strong>EAGAIN</strong> y <strong>EPOLLET</strong> : la recomendaci√≥n con <strong>EAGAIN es</strong> no tratar el flujo de bytes, el peligro en este √∫ltimo caso surge solo si no ley√≥ el descriptor hasta el final y no llegaron nuevos datos.  Luego, la cola colgar√° en el descriptor, pero no recibir√° una nueva notificaci√≥n.  Con <strong>accept (), la</strong> situaci√≥n es simplemente diferente, all√≠ debe continuar hasta que <strong>accept ()</strong> devuelva <strong>EAGAIN</strong> , solo en este caso se garantiza la operaci√≥n correcta. </p><br><pre><code class="hljs lua">// TCP socket (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> stream) //  fd    EPOLLIN      int <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(fd, buffer, BUFFER_LEN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &lt; BUFFER_LEN) { //   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         //  -       epoll_wait, //      }</code> </pre> <br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ accept /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  listenfd    EPOLLIN      event.events = EPOLLIN | EPOLLERR; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event); sleep(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       &gt;1  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { newfd = accept(listenfd, ...); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  epoll_wait    listenfd    } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { while((newfd = accept(...)) &gt; 0) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -  } if(newfd == -1 &amp;&amp; errno = EAGAIN) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       } }</span></span></code> </pre> <br><p>  Con esta propiedad, solo el hambre es suficiente: </p><br><ul><li>  los paquetes llegan al descriptor </li><li>  leer paquetes en el b√∫fer </li><li>  otro paquete viene </li><li>  leer paquetes en el b√∫fer </li><li>  viene una peque√±a porci√≥n </li><li>  ... </li></ul><br><p>  Por lo tanto <strong>,</strong> no recibiremos <strong>EAGAIN</strong> pronto, pero es posible que no lo recibamos en absoluto. </p><br><p>  Por lo tanto, otros descriptores de archivos no reciben tiempo para el procesamiento, y estamos ocupados leyendo peque√±as porciones de datos que llegan constantemente. </p><br><h1 id="thundering-nerd-herd">  atronador <del>  nerd </del>  reba√±o </h1><br><p>  Para ir al √∫ltimo indicador, debe comprender por qu√© se cre√≥ realmente y uno de los problemas que surgieron para los desarrolladores con la evoluci√≥n de la tecnolog√≠a y el software. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://en.wikipedia.org/wiki/">Problema de reba√±o atronador</a> </p><br><blockquote>  Problema del reba√±o de truenos <br><br>  Imagine una gran cantidad de procesos esperando un evento.  Si se produce un evento, se despertar√° y comenzar√° la lucha por los recursos, aunque solo se requiere un proceso que se encargar√° del procesamiento posterior del evento.  El resto de los procesos volver√° a dormir. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Terminolog√≠a de TI - Vasily Alekseenko</a> </blockquote><p>  En este caso, estamos interesados ‚Äã‚Äãen el problema de <strong>accept ()</strong> y <strong>read ()</strong> distribuidos en streams junto con <strong>epoll</strong> . </p><br><h1 id="accept">  aceptar </h1><br><p>  En realidad, con una llamada de bloqueo para <strong>aceptar (),</strong> no ha habido problemas durante mucho tiempo.  El n√∫cleo se encargar√° de que solo se haya desbloqueado un proceso para este evento, y todas las conexiones entrantes se serialicen. </p><br><p>  Pero con <strong>epoll,</strong> tal truco no funcionar√°.  Si hemos <strong>escuchado ()</strong> en un socket sin bloqueo, cuando se establece la conexi√≥n, todos <strong>epoll_wait () esperar√°n</strong> el evento desde este descriptor. </p><br><p>  Por supuesto, <strong>accept ()</strong> solo podr√° hacer un hilo, el resto recibir√° <strong>EAGAIN</strong> , pero esto es un desperdicio de recursos. </p><br><p>  Adem√°s, <strong>EPOLLET</strong> tampoco nos ayuda, ya que no sabemos exactamente cu√°ntas conexiones hay en la cola de conexiones ( <strong>backlog</strong> ).  Como recordamos, cuando se usa <strong>EPOLLET</strong> , el procesamiento del socket debe continuar hasta que regrese con el <strong>c√≥digo de</strong> error <strong>EAGAIN</strong> , por lo que existe la posibilidad de que todos los <strong>accept ()</strong> sean procesados ‚Äã‚Äãpor un hilo y el resto no funcione. </p><br><p>  Y esto nuevamente nos lleva a una situaci√≥n en la que la corriente vecina se despert√≥ en vano. </p><br><p>  Tambi√©n podemos obtener un tipo diferente de inanici√≥n: solo tendremos un subproceso cargado y el resto no recibir√° conexiones para el procesamiento. </p><br><h1 id="epolloneshot">  EPOLLONESHOT </h1><br><p>  Antes de la versi√≥n 4.5, la √∫nica forma correcta de procesar el <strong>epoll</strong> distribuido en un descriptor <strong>listen ()</strong> sin bloqueo con la siguiente llamada <strong>accept ()</strong> era establecer el indicador <strong>EPOLLONESHOT</strong> , lo que nuevamente nos llev√≥ a <strong>aceptar que ()</strong> solo se procesara en un hilo a la vez. </p><br><p>  En resumen: si <strong>se</strong> usa <strong>EPOLLONESHOT, el</strong> evento asociado con un descriptor particular se activar√° solo una vez, despu√©s de lo cual es necesario volver a <strong>activar</strong> las banderas usando <strong>epoll_ctl ()</strong> . </p><br><h1 id="epollexclusive">  EPOLLEXCLUSIVO </h1><br><p>  Aqu√≠ <strong>EPOLLEXCLUSIVE</strong> y activado por nivel viene en nuestra ayuda. </p><br><p>  <strong>EPOLLEXCLUSIVE</strong> desbloquea un <strong>epoll_wait ()</strong> pendiente a la vez para un evento. </p><br><p>  El esquema es bastante simple (en realidad no): </p><br><ul><li>  Tenemos N hilos esperando un evento de conexi√≥n </li><li>  El primer cliente se conecta con nosotros. </li><li>  El hilo 0 se dispersar√° y comenzar√° a procesarse, otros hilos permanecer√°n bloqueados </li><li>  Un segundo cliente se conecta con nosotros, si el hilo 0 todav√≠a est√° ocupado con el procesamiento, entonces el hilo 1 est√° desbloqueado </li><li>  Continuamos m√°s hasta que se agote el grupo de subprocesos (nadie espera un evento en <strong>epoll_wait ()</strong> ) </li><li>  Otro cliente se est√° conectando con nosotros. </li><li>  Y su procesamiento recibir√° el primer hilo, que llamar√° a <strong>epoll_wait ()</strong> </li><li>  El segundo hilo recibir√° el segundo cliente, que llamar√° a <strong>epoll_wait ()</strong> </li></ul><br><p>  Por lo tanto, todo el mantenimiento se distribuye uniformemente entre los flujos. </p><br><pre> <code class="bash hljs">$ ./epollexclusive --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> -i, --ip=ADDR specify ip address -p, --port=PORT specify port -n, --threads=NUM specify number of threads to use <span class="hljs-comment"><span class="hljs-comment">#    -  n*8 -t, --thunder not adding EPOLLEXCLUSIVE #     thunder herd -h, --help prints this message $ sudo taskset -c 0-7 ./epollexclusive -i 10.56.75.201 -p 40000 -n 8 2&gt;&amp;1</span></span></code> </pre> <br><p>  c√≥digo de ejemplo: <a href="">epollexclusive.c</a> (solo funcionar√° con la versi√≥n del kernel de 4.5) </p><br><p>  Tenemos un modelo pre-fork en epoll.  Este esquema se aplica bien para conexiones TCP de <strong>corto tiempo</strong> . </p><br><h1 id="read">  leer </h1><br><p>  Pero con <strong>read ()</strong> en el caso de la transmisi√≥n de bytes, <strong>EPOLLEXCLUSIVE</strong> , como <strong>EPOLLET,</strong> no nos ayudar√°. </p><br><p>  Por razones obvias, sin <strong>EPOLLEXCLUSIVE</strong> no podemos usar ning√∫n nivel activado por nivel.  Con <strong>EPOLLEXCLUSIVE, no</strong> todo es mejor, ya que podemos obtener un paquete distribuido en secuencias, adem√°s de que llega un orden desconocido de bytes. </p><br><p>  Con <strong>EPOLLET, la</strong> situaci√≥n es la misma. </p><br><p>  Y aqu√≠ <strong>EPOLLONESHOT</strong> con reinicializaci√≥n al finalizar el trabajo ser√° la salida.  Entonces, tan pronto como un hilo funcione con este descriptor de archivo y b√∫fer: </p><br><ul><li>  asa a√±adida a <strong>epoll</strong> con banderas <strong>EPOLLONESHOT |</strong>  <strong>EPOLLET</strong> </li><li>  esperando en <strong>epoll_wait ()</strong> </li><li>  leer desde el socket al b√∫fer hasta que <strong>read ()</strong> devuelva <strong>EAGAIN</strong> </li><li>  reinicializar con banderas <strong>EPOLLONESHOT |</strong>  <strong>EPOLLET</strong> </li></ul><br><h1 id="struct--epoll_event">  struct epoll_event </h1><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> epoll_data { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> u32; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> u64; } <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> events; <span class="hljs-comment"><span class="hljs-comment">/* Epoll events */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* User data variable */</span></span> };</code> </pre> <br><p>  Este art√≠culo es quiz√°s el √∫nico en mi art√≠culo mi IMHO personal.  La capacidad de usar un puntero o un n√∫mero es √∫til.  Por ejemplo, usar un puntero cuando usas epoll te permite hacer un truco como este: </p><br><pre> <code class="hljs go">#define container_of(ptr, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, member) ({ \ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeof( ((<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;member ) *__mptr = (ptr); \ (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)( (char *)__mptr - offsetof(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>,member) );}) <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client { <span class="hljs-comment"><span class="hljs-comment">/** some usefull associated data...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event event; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* to_epoll_client(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event* event) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container_of(event, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client, event); } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client ec; ... epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;ec.e); ... epoll_wait (efd, events, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* ec_ = to_epoll_client(events[<span class="hljs-number"><span class="hljs-number">0</span></span>].data.ptr);</code> </pre> <br><p>  Creo que todos saben de d√≥nde vino esta t√©cnica. </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>  Espero que hayamos podido abrir el tema de <strong>epoll</strong> .  Aquellos que quieran usar este mecanismo conscientemente, solo necesitan leer los art√≠culos en la lista de referencias [1, 2, 3, 5]. </p><br><p>  Con base en este material (o, mejor a√∫n, leyendo cuidadosamente los materiales de las referencias), puede hacer un servidor pre-fork multi-thread (generaci√≥n avanzada del proceso) sin bloqueo (sin bloqueo) o revisar las estrategias existentes basadas en las propiedades especiales de <strong>epoll ()</strong> ). </p><br><p>  <strong>epoll es</strong> uno de los mecanismos √∫nicos que las personas que han elegido sus rutas de programaci√≥n de Linux necesitan saber, ya que brindan una gran ventaja sobre otros sistemas operativos) y, tal vez, abandonar√°n la plataforma cruzada para este caso particular (d√©jelo funcionar solo en Linux pero lo har√° bien). </p><br><h2 id="rassuzhdeniya-ob-specifichnosti-zadachi">  Razonamiento sobre la "especificidad" del problema </h2><br><p>  Antes de que alguien hable sobre la especificidad de estos indicadores y patrones de uso, quiero hacer una pregunta: </p><br><p>  "¬øPero no es nada que estemos tratando de discutir la especificidad para el mecanismo que se cre√≥ para tareas espec√≠ficas inicialmente [9, 11]? ¬øO incluso damos servicio a conexiones de 1k es una tarea diaria para un programador?" </p><br><p>  No entiendo el concepto de "especificidad de tarea", me recuerda todo tipo de gritos sobre la utilidad y la inutilidad de las diversas disciplinas que se ense√±an.  Permiti√©ndonos razonar de esta manera, nos arrogamos el derecho de decidir por otros qu√© informaci√≥n es √∫til para ellos y cu√°l es in√∫til, mientras que, no importa, no participar en el proceso educativo en su conjunto. </p><br><p>  Para los esc√©pticos, un par de enlaces: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aumento del rendimiento con SO_REUSEPORT en NGINX 1.9.1 - VBart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprendiendo de Unicornio: la manada de truenos accept () no es un problema - Chris Siebenmann</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Serializing accept (), AKA Thundering Herd, AKA the Zeeg Problem - Roberto De Ioris</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øC√≥mo interact√∫a el modo EPOLLEXCLUSIVE de epoll con la activaci√≥n de nivel?</a> </p><br><h1 id="spisok-literatury">  Referencias </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Select est√° fundamentalmente roto - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Epoll est√° fundamentalmente roto 1/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Epoll est√° fundamentalmente roto 2/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El problema C10K - Dan Kegel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Encuesta vs Epoll, una vez m√°s - Jacques Mattheij</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">epoll - Facilidad de notificaci√≥n de eventos de E / S - The Mann</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El m√©todo para la locura de Epoll - Cindy Sridharan</a> </li></ol><br><h2 id="benchmarks">  Puntos de referencia </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://lse.sourceforge.net/epoll/index.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://mvitolin.wordpress.com/2015/12/05/endurox-testing-epollexclusive-flag/</a> </li></ol><br><h2 id="evolyuciya-epoll">  La evoluci√≥n de epoll </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lwn.net/Articles/13918/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lwn.net/Articles/520012/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lwn.net/Articles/520198/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lwn.net/Articles/542629/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lwn.net/Articles/633422/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lwn.net/Articles/637435/</a> </li></ol><br><h1 id="postskriptum">  Postdata </h1><br><p>  ¬°Muchas gracias a Sergey ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">dlinyj</a> ) y Peter Ovchenkov por sus valiosos debates, comentarios y ayuda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416669/">https://habr.com/ru/post/es416669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416657/index.html">Dos tercios de las tarjetas de memoria usadas contienen datos personales de propietarios anteriores</a></li>
<li><a href="../es416659/index.html">Debido a lo que el volumen de pagos digitales para la econom√≠a del concierto alcanzar√° $ 1.2 billones de d√≥lares</a></li>
<li><a href="../es416661/index.html">¬øQu√© tendencias deben considerar los usuarios y proveedores de banca m√≥vil?</a></li>
<li><a href="../es416665/index.html">Reutilizaci√≥n de bibliotecas privadas de Android con Sonatype Nexus Repository OSS</a></li>
<li><a href="../es416667/index.html">Presupuesto de aislamiento de polvo y ruido de la antigua unidad del sistema</a></li>
<li><a href="../es416673/index.html">Soluci√≥n anal√≠tica para gerente</a></li>
<li><a href="../es416677/index.html">Cyberpunk y espejos: reflexiones en moda y cultura</a></li>
<li><a href="../es416679/index.html">Computaci√≥n perif√©rica: una combinaci√≥n amistosa de la "niebla" con las "nubes"</a></li>
<li><a href="../es416681/index.html">C√≥mo PostgreSQL y ClickHouse en Python mucho, r√°pida e inmediatamente en numpy</a></li>
<li><a href="../es416683/index.html">Que sigue O c√≥mo elegir caracter√≠sticas para el desarrollo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>