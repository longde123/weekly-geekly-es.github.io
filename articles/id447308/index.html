<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏼 🧘 🐲 Desain instan 🏴 🤽🏾 🕣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Orang belajar arsitektur dari buku-buku lama yang ditulis untuk Jawa. Buku-buku itu bagus, tetapi mereka memberikan solusi untuk masalah waktu itu den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desain instan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/447308/">  Orang belajar arsitektur dari buku-buku lama yang ditulis untuk Jawa.  Buku-buku itu bagus, tetapi mereka memberikan solusi untuk masalah waktu itu dengan instrumen waktu itu.  Waktu telah berubah, C # lebih mirip dengan Scala cahaya dari Jawa, dan ada beberapa buku bagus yang baru. <br><br>  Pada artikel ini, kita akan memeriksa kriteria untuk kode yang baik dan kode yang buruk, bagaimana dan apa yang harus diukur.  Kami akan melihat gambaran umum tugas dan pendekatan, kami akan menganalisis pro dan kontra.  Pada akhirnya akan ada rekomendasi dan praktik terbaik untuk merancang aplikasi web. <br><br>  Artikel ini adalah transkrip laporan saya dari konferensi DotNext 2018 Moscow.  Selain teks, ada video dan tautan ke slide di bawah potongan. <br><br><img src="https://habrastorage.org/webt/qu/ur/ih/quurihchxowghlgnkanhvmb5o7e.jpeg"><br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qJPwSvDLmQE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Halaman slide</b></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan di situs</a> . </blockquote>  Tentang saya secara singkat: Saya dari Kazan, saya bekerja untuk High Tech Group.  Kami sedang mengembangkan perangkat lunak untuk bisnis.  Baru-baru ini, saya telah mengajar kursus di Universitas Federal Kazan yang disebut Pengembangan Perangkat Lunak Korporat.  Dari waktu ke waktu saya masih menulis artikel tentang Habr tentang praktik rekayasa, tentang pengembangan perangkat lunak perusahaan. <br><br>  Seperti yang mungkin sudah Anda duga, hari ini saya akan berbicara tentang pengembangan perangkat lunak perusahaan, yaitu, bagaimana menyusun aplikasi web modern: <br><br><ul><li>  kriteria </li><li>  sejarah singkat perkembangan pemikiran arsitektural (apa, apa yang telah menjadi, apa masalahnya); </li><li>  ikhtisar kelemahan arsitektur engah klasik </li><li>  keputusan </li><li>  analisis implementasi langkah demi langkah tanpa merinci </li><li>  hasil. </li></ul><br><h1>  Kriteria </h1><br>  Kami merumuskan kriteria.  Saya benar-benar tidak suka ketika berbicara tentang desain dengan gaya "kung fu saya lebih kuat dari kung fu Anda".  Bisnis pada prinsipnya memiliki satu kriteria khusus yang disebut uang.  Semua orang tahu bahwa waktu adalah uang, jadi kedua komponen ini paling sering paling penting. <br><br><img src="https://habrastorage.org/webt/pu/2e/fh/pu2efhyhoibrcu9lav6fzdg48da.jpeg"><br><br>  Jadi, kriterianya.  Pada prinsipnya, bisnis paling sering bertanya kepada kami "sebanyak mungkin fitur per unit waktu", tetapi dengan satu peringatan - fitur ini seharusnya berfungsi.  Dan langkah pertama di mana itu mungkin rusak adalah review kode.  Artinya, tampaknya programmer mengatakan: "Saya akan melakukannya dalam tiga jam."  Tiga jam berlalu, ulasan masuk ke kode, dan pemimpin tim berkata: "Oh, tidak, ulangi."  Ada tiga lagi - dan berapa banyak iterasi yang ditinjau oleh kode, sehingga Anda perlu mengalikan tiga jam. <br><br>  Poin berikutnya adalah kembali dari tahap tes penerimaan.  Hal yang sama.  Jika fitur tidak bekerja, maka itu tidak dilakukan, tiga jam ini membentang selama seminggu, dua - well, seperti biasa.  Kriteria terakhir adalah jumlah regresi dan bug, yang, meskipun telah diuji dan diterima, melalui produksi.  Ini juga sangat buruk.  Ada satu masalah dengan kriteria ini.  Sulit dilacak, karena hubungan antara fakta bahwa kita mendorong sesuatu ke dalam repositori dan fakta bahwa sesuatu pecah setelah dua minggu bisa jadi sulit dilacak.  Tapi, bagaimanapun, itu mungkin. <br><br><h1>  Pengembangan arsitektur </h1><br>  Sekali waktu, ketika programmer baru mulai menulis program, masih belum ada arsitektur, dan semua orang melakukan semua yang mereka suka. <br><br><img src="https://habrastorage.org/webt/27/l7/oq/27l7oqmpgjyxndbw-4trowmrmem.jpeg"><br><br>  Karena itu, kami mendapatkan gaya arsitektur yang demikian.  Ini disebut "kode mie" di sini, mereka mengatakan "kode spageti" di luar negeri.  Semuanya terhubung dengan segalanya: kita mengubah sesuatu pada titik A - rusak pada titik B, benar-benar mustahil untuk memahami apa yang terhubung dengan apa.  Tentu saja, para programmer dengan cepat menyadari bahwa ini tidak akan berhasil, dan beberapa struktur harus dilakukan, dan memutuskan bahwa beberapa layer akan membantu kami.  Sekarang, jika Anda membayangkan bahwa daging cincang adalah kode, dan lasagna adalah lapisan seperti itu, inilah ilustrasi arsitektur berlapis.  Daging cincang tetap dicincang, tetapi sekarang daging cincang dari lapisan No. 1 tidak bisa pergi dan berbicara dengan daging cincang dari lapisan No. 2. Kami memberi kode beberapa bentuk: bahkan dalam gambar Anda dapat melihat bahwa memanjat lebih berbingkai. <br><br><img src="https://habrastorage.org/webt/yx/_j/cu/yx_jcumnfvnensrmrbjwi9lyyqa.jpeg"><br><br>  Semua orang mungkin akrab dengan <b>arsitektur berlapis klasik</b> : ada UI, ada logika bisnis, dan ada lapisan Akses Data.  Masih ada segala macam layanan, fasad dan lapisan, dinamai untuk arsitek yang keluar dari perusahaan, mungkin ada jumlah yang tidak terbatas. <br><br><img src="https://habrastorage.org/webt/dd/28/qj/dd28qjfaycsftyr71tczg5ykxjo.jpeg"><br><br>  Tahap selanjutnya adalah <b>arsitektur bawang yang</b> disebut.  Tampaknya ada perbedaan besar: sebelumnya ada kotak kecil, dan di sini ada lingkaran.  Tampaknya sangat berbeda. <br><br><img src="https://habrastorage.org/webt/pe/8r/rx/pe8rrxifll2tswmz63paezukklq.jpeg"><br><br>  Tidak juga.  Seluruh perbedaannya adalah bahwa di suatu tempat pada saat itu prinsip-prinsip SOLID dirumuskan, dan ternyata dalam bawang klasik ada masalah dengan inversi ketergantungan, karena kode domain abstrak untuk beberapa alasan tergantung pada implementasi, pada Akses Data, jadi kami memutuskan untuk menggunakan Akses Data , dan memiliki Akses Data tergantung pada domain. <br><br><img src="https://habrastorage.org/webt/8o/eb/we/8oebwed-cag1f-zvake5t9lmhl8.jpeg"><br><br>  Di sini saya berlatih menggambar dan menggambar arsitektur bawang, tetapi tidak secara klasik dengan "cincin".  Saya mendapatkan sesuatu di antara poligon dan lingkaran.  Saya melakukan ini hanya untuk menunjukkan bahwa jika Anda menemukan kata "bawang", "heksagonal" atau "port dan adaptor" - ini semua adalah satu dan sama.  Intinya adalah bahwa domain ada di tengah, itu dibungkus layanan, mereka bisa menjadi layanan domain atau aplikasi, yang Anda inginkan.  Dan dunia luar dalam bentuk UI, tes dan infrastruktur tempat DAL pindah ke - mereka berkomunikasi dengan domain melalui lapisan layanan ini. <br><br><h2>  Contoh sederhana.  Pembaruan email </h2><br>  Mari kita lihat bagaimana kasus penggunaan yang sederhana akan terlihat dalam paradigma seperti itu - memperbarui alamat email pengguna. <br><br><img src="https://habrastorage.org/webt/ta/fg/x-/tafgx-5pwfraeofdjg323ewoova.jpeg"><br><br>  Kami perlu mengirim permintaan, memvalidasi, memperbarui nilai dalam database, mengirim pemberitahuan ke email baru: "Semuanya beres, Anda mengubah email, kami tahu semuanya baik-baik saja", dan membalas browser "200" - semuanya baik-baik saja. <br><br><img src="https://habrastorage.org/webt/xs/vm/0f/xsvm0f4b6zhpypwnixjazbv3ufi.jpeg"><br><br>  Kode mungkin terlihat seperti ini.  Di sini kita memiliki validasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASP.NET</a> MVC standar, ada ORM untuk membaca dan memperbarui data, dan ada beberapa jenis pengirim email yang mengirimkan pemberitahuan.  Sepertinya semuanya baik-baik saja, kan?  Satu peringatan - di dunia yang ideal. <br><br>  Di dunia nyata, situasinya sedikit berbeda.  Intinya adalah untuk menambahkan otorisasi, pengecekan kesalahan, pemformatan, masuk dan profil.  Ini semua tidak ada hubungannya dengan use case kami, tetapi semua harus demikian.  Dan sepotong kecil kode itu menjadi besar dan menakutkan: dengan banyak sarang, dengan banyak kode, dengan fakta bahwa itu sulit dibaca, dan yang paling penting, bahwa ada lebih banyak kode infrastruktur daripada kode domain. <br><br><img src="https://habrastorage.org/webt/lh/xr/xd/lhxrxdbyaacgxsxrjcsoinbq-c8.jpeg"><br><br>  "Di mana layanannya?"  - katamu.  Saya menulis semua logika ke pengendali.  Tentu saja, ini masalah, sekarang saya akan menambahkan layanan, dan semuanya akan baik-baik saja. <br><br><img src="https://habrastorage.org/webt/c6/nd/ca/c6ndcaxmuebeyawelqctgsh19ig.jpeg"><br><br>  Kami menambahkan layanan, dan itu benar-benar menjadi lebih baik, karena alih-alih memakai alas kaki yang besar, kami mendapat satu baris kecil yang indah. <br><br>  Apakah sudah membaik?  Sudah menjadi!  Dan sekarang kita dapat menggunakan kembali metode ini di pengontrol yang berbeda.  Hasilnya jelas.  Mari kita lihat implementasi dari metode ini. <br><br><img src="https://habrastorage.org/webt/up/xx/rx/upxxrx8d_fc-5qmzbk-d0afuht4.jpeg"><br><br>  Tapi di sini semuanya tidak begitu baik.  Kode ini masih di sini.  Kami baru saja mentransfer hal yang sama ke layanan.  Kami memutuskan untuk tidak memecahkan masalah, tetapi hanya untuk menyamarkannya dan memindahkannya ke tempat lain.  Itu saja. <br><br><img src="https://habrastorage.org/webt/m0/bo/fj/m0bofjvz471nmxub7ubqhshqwgi.jpeg"><br><br>  Selain itu, beberapa pertanyaan lain muncul.  Haruskah kita melakukan validasi di controller atau di sini?  Yah, semacam suka, di controller.  Dan jika Anda perlu pergi ke database dan melihat bahwa ada ID atau tidak ada pengguna lain dengan email seperti itu?  Hmm, kalau begitu dalam layanan.  Tetapi penanganan kesalahan di sini?  Penanganan kesalahan ini mungkin ada di sini, dan penanganan kesalahan yang akan merespons ke browser di pengontrol.  Dan metode SaveChanges, apakah ada dalam layanan atau Anda perlu mentransfernya ke controller?  Mungkin begitu dan begitu, karena jika satu layanan dipanggil, lebih logis untuk memanggil layanan, dan jika Anda memiliki tiga metode layanan di controller yang perlu Anda panggil, maka Anda perlu memanggilnya di luar layanan ini sehingga transaksi itu adalah satu.  Refleksi ini menunjukkan bahwa mungkin lapisan tidak menyelesaikan masalah. <br><br><img src="https://habrastorage.org/webt/9d/s6/gd/9ds6gdwecmtqyjjv3rko5l-rccg.jpeg"><br><br>  Dan ide ini terpikir oleh lebih dari satu orang.  Jika Anda google, setidaknya tiga dari suami terhormat ini menulis tentang hal yang sama.  Dari atas ke bawah: Stephen .NET Junkie (sayangnya, saya tidak tahu nama belakangnya, karena dia tidak muncul di mana pun di Internet), penulis wadah IoC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simple Injector</a> .  Berikutnya Jimmy Bogard adalah penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AutoMapper</a> .  Dan di bawah ini adalah Scott Vlashin, penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # untuk kesenangan dan keuntungan</a> . <br><br><img src="https://habrastorage.org/webt/pu/lt/rz/pultrzyz_24mf5fycqif--zcbpe.jpeg"><br><br>  Semua orang ini berbicara tentang hal yang sama dan menyarankan untuk membangun aplikasi bukan berdasarkan lapisan, tetapi berdasarkan kasus penggunaan, yaitu, persyaratan yang diminta oleh bisnis.  Dengan demikian, use case dalam C # dapat ditentukan menggunakan antarmuka IHandler.  Ini memiliki nilai input, ada nilai output dan ada metode itu sendiri yang benar-benar mengeksekusi use case ini. <br><br><img src="https://habrastorage.org/webt/9m/lj/hw/9mljhwhphjkuckh2r5tvegoyzg0.jpeg"><br><br>  Dan di dalam metode ini bisa ada model domain, atau beberapa model denormalized untuk membaca, mungkin dengan Dapper atau dengan Pencarian Elastis, jika Anda perlu mencari sesuatu, dan mungkin Anda memiliki Legacy -sistem dengan prosedur tersimpan - tidak ada masalah, serta permintaan jaringan - baik, secara umum, apa pun yang mungkin Anda butuhkan di sana.  Tetapi jika tidak ada lapisan, apa yang harus dilakukan? <br><br><img src="https://habrastorage.org/webt/lg/iw/se/lgiwseqpyf9krjfkv4j9ciluxri.jpeg"><br><br>  Untuk memulai, mari kita hilangkan UserService.  Kami menghapus metode dan membuat kelas.  Dan kami akan menghapusnya, dan kami akan menghapusnya lagi.  Dan kemudian ambil dan hapus kelas. <br><br><img src="https://habrastorage.org/webt/xx/tv/z1/xxtvz10bmxyzpefudhd2cw7892y.jpeg"><br><br>  Mari kita berpikir, apakah kelas-kelas ini setara atau tidak?  Kelas GetUser mengembalikan data dan tidak mengubah apa pun di server.  Ini, misalnya, tentang permintaan "Beri saya ID pengguna."  Kelas UpdateEmail dan BanUser mengembalikan hasil operasi dan mengubah status.  Misalnya, ketika kami memberi tahu server: "Silakan ubah status, Anda perlu mengubah sesuatu." <br><br><img src="https://habrastorage.org/webt/yj/qs/tn/yjqstnlgzw9lwrk8s1nr0j2s47u.jpeg"><br><br>  Mari kita lihat protokol HTTP.  Ada metode GET, yang, sesuai dengan spesifikasi protokol HTTP, harus mengembalikan data dan tidak mengubah keadaan server. <br><br><img src="https://habrastorage.org/webt/uq/ql/7i/uqql7icixrsmjce88qwxwuxouss.jpeg"><br><br>  Dan ada metode lain yang dapat mengubah status server dan mengembalikan hasil operasi. <br><br><img src="https://habrastorage.org/webt/zu/u3/l6/zuu3l6-bulai-mgo4fozlyru8ci.jpeg"><br><br>  Paradigma CQRS tampaknya dirancang khusus untuk protokol HTTP.  Kueri adalah operasi GET, dan perintah adalah PUT, POST, HAPUS - tidak perlu menemukan apa pun. <br><br><img src="https://habrastorage.org/webt/2t/wk/yp/2twkypfgr9s5xxslujdjfelkkx4.jpeg"><br><br>  Kami mendefinisikan kembali Handler kami dan mendefinisikan antarmuka tambahan.  IQueryHandler, yang hanya berbeda dalam hal kita menggantungkan kendala bahwa jenis nilai input adalah IQuery.  IQuery adalah antarmuka penanda, tidak ada di dalamnya kecuali generik ini.  Kita memerlukan generik untuk menempatkan batasan di QueryHandler, dan sekarang, mendeklarasikan QueryHandler, kita tidak bisa lewat di sana bukan di Query, tetapi melewati objek Query di sana, kita tahu nilai baliknya.  Ini nyaman jika Anda hanya memiliki satu antarmuka, sehingga Anda tidak perlu mencari implementasinya dalam kode, dan sekali lagi agar tidak berantakan.  Anda menulis IQueryHandler, menulis implementasi di sana, dan di TOut Anda tidak bisa mengganti tipe nilai pengembalian yang lain.  Itu tidak mengkompilasi.  Dengan demikian, Anda dapat langsung melihat nilai input mana yang sesuai dengan data input mana. <br><br><img src="https://habrastorage.org/webt/e5/k9/pd/e5k9pdmjpohmvppi9j5mco2lpz8.jpeg"><br><br>  Situasinya sangat mirip untuk CommandHandler dengan satu pengecualian: generik ini diperlukan untuk satu trik lagi, yang akan kita lihat sedikit lebih jauh. <br><br><h3>  Implementasi Handler </h3><br>  Penangan, kami mengumumkan, apa implementasi mereka? <br><br><img src="https://habrastorage.org/webt/xb/ye/no/xbyeno8s7xry4tv5n1t2sgig4fk.jpeg"><br><br>  Apakah ada masalah?  Sepertinya ada yang gagal. <br><br><h3>  Dekorator bergegas untuk menyelamatkan </h3> <br>  Tapi itu tidak membantu, karena kita masih di tengah jalan, kita harus menyelesaikan sedikit lagi, dan kali ini kita perlu menggunakan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekorator</a> , yaitu fitur tata letak yang indah.  Dekorator dapat dibungkus dekorator, dibungkus dekorator, dibungkus dekorator - terus sampai Anda bosan. <br><br><img src="https://habrastorage.org/webt/pj/oj/m2/pjojm2jkr9q2q3of-rgouuydrjc.jpeg"><br><br>  Maka semuanya akan terlihat seperti ini: ada input Dto, memasuki dekorator pertama, kedua, ketiga, kemudian kita masuk ke Handler dan juga keluar, pergi melalui semua dekorator dan mengembalikan Dto di browser.  Kami mendeklarasikan kelas dasar abstrak untuk kemudian mewarisi, tubuh Handler diteruskan ke konstruktor, dan kami mendeklarasikan metode Handle abstrak, di mana logika dekorator tambahan akan digantung. <br><br><img src="https://habrastorage.org/webt/4k/df/ha/4kdfha-rrtuvomibpp8tuadhcrw.jpeg"><br><br>  Sekarang dengan bantuan dekorator Anda dapat membangun saluran pipa secara keseluruhan.  Mari kita mulai dengan tim.  Apa yang kita miliki  Nilai input, validasi, verifikasi hak akses, logika itu sendiri, beberapa peristiwa yang terjadi sebagai akibat dari logika ini, dan nilai pengembalian. <br><br><img src="https://habrastorage.org/webt/zp/yw/3i/zpyw3iastzi8ggkluwnk_dhdes0.jpeg"><br><br>  Mari kita mulai dengan validasi.  Kami mendeklarasikan dekorator.  IEnumerable dari validator tipe T masuk ke dalam konstruktor dekorator ini. Kami menjalankan semuanya, memeriksa apakah validasi gagal dan tipe kembalinya <code>IEnumerable&lt;validationresult&gt;</code> , maka kita dapat mengembalikannya karena jenisnya cocok.  Dan jika itu adalah Hander lain, maka Anda harus melemparkan Pengecualian, karena tidak ada hasil di sini, jenis nilai pengembalian lainnya. <br><br><img src="https://habrastorage.org/webt/wp/pi/bp/wppibp3w6wzoylmbhx8nsop6lda.jpeg"><br><br>  Langkah selanjutnya adalah Keamanan.  Kami juga mendeklarasikan dekorator, membuat metode CheckPermission, dan memverifikasi.  Jika tiba-tiba terjadi kesalahan, semuanya, kami tidak melanjutkan.  Sekarang, setelah kami menyelesaikan semua pemeriksaan dan yakin semuanya baik-baik saja, kami dapat memenuhi logika kami. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Obsesi dengan primitif</a> </h3><br>  Sebelum menunjukkan implementasi logika, saya ingin memulai sedikit lebih awal, yaitu dengan nilai input yang datang ke sana. <br><br><img src="https://habrastorage.org/webt/gl/y5/ro/gly5roxocvdausjqf9dztn69jjk.jpeg"><br><br>  Sekarang, jika kita memilih kelas seperti itu, maka yang paling sering terlihat seperti ini.  Setidaknya kode yang saya lihat dalam pekerjaan sehari-hari. <br><br><img src="https://habrastorage.org/webt/is/e4/6r/ise46rxpz-gsrqeqpqjwac-ir58.jpeg"><br><br>  Agar validasi berfungsi, kami menambahkan beberapa atribut di sini yang memberi tahu Anda seperti apa validasinya.  Ini akan membantu dari sudut pandang struktur data, tetapi tidak akan membantu dengan validasi seperti memeriksa nilai dalam database.  Ini hanya EmailAddress, tidak jelas caranya, di mana memeriksa bagaimana menggunakan atribut ini untuk pergi ke database.  Alih-alih atribut, Anda bisa pergi ke tipe khusus, maka masalah ini akan terpecahkan. <br><br><img src="https://habrastorage.org/webt/oq/6b/3x/oq6b3xuwdmc5xh_04v71g02jkmo.jpeg"><br><br>  Alih-alih <code>int</code> primitif, kami mendeklarasikan tipe Id yang memiliki generik yang merupakan entitas tertentu dengan kunci int.  Dan kami meneruskan entitas ini ke konstruktor, atau meneruskan Id-nya, tetapi pada saat yang sama kami harus melewati fungsi yang oleh Id dapat diambil dan dikembalikan, periksa apakah ada nol di sana atau tidak nol. <br><br><img src="https://habrastorage.org/webt/tt/fk/ut/ttfkutansz1nzthl3x5adtxftde.jpeg"><br><br>  Kami melakukan hal yang sama dengan Email.  Konversikan semua email ke garis bawah sehingga semuanya terlihat sama untuk kita.  Selanjutnya, kita mengambil atribut Email, menyatakannya sebagai statis untuk kompatibilitas dengan validasi ASP.NET, dan di sini kita sebut saja.  Artinya, ini juga bisa dilakukan.  Agar infrastruktur ASP.NET dapat menangkap semua ini, Anda harus sedikit mengubah serialisasi dan / atau ModelBinding.  Tidak ada banyak kode di sana, relatif sederhana, jadi saya tidak akan berhenti di situ. <br><br><img src="https://habrastorage.org/webt/md/5k/zi/md5kzigojhdaybdbizxrvby2p5w.jpeg"><br><br>  Setelah perubahan ini, alih-alih tipe primitif, tipe khusus muncul di sini: Id dan Email.  Dan setelah ModelBinder ini dan deserializer yang diperbarui berhasil, kami tahu pasti bahwa nilai-nilai ini benar, termasuk bahwa nilai-nilai tersebut ada di database.  "Invarian" <br><br><img src="https://habrastorage.org/webt/hu/ew/ul/huewulf5m8-mwkha62fbu3dm5sy.jpeg"><br><br>  Poin berikutnya yang ingin saya bahas adalah keadaan invarian di kelas, karena cukup sering <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model anemia</a> digunakan, di mana hanya ada kelas, banyak pengambil-penentu, sama sekali tidak jelas bagaimana mereka harus bekerja sama.  Kami bekerja dengan logika bisnis yang kompleks, jadi penting bagi kami bahwa kode tersebut mendokumentasikan sendiri.  Sebaliknya, lebih baik untuk mendeklarasikan konstruktor nyata bersama dengan kosong untuk ORM, itu dapat dinyatakan dilindungi sehingga pemrogram dalam kode aplikasi mereka tidak bisa menyebutnya, dan ORM bisa.  Di sini kita melewati bukan tipe primitif, tetapi tipe Email, sudah benar dengan benar, jika itu nol, kita masih membuang Pengecualian.  Anda dapat menggunakan beberapa Fody, PostSharp, tetapi C # 8 akan segera hadir. Dengan demikian, akan ada jenis referensi yang tidak dapat dibatalkan, dan lebih baik menunggu dukungannya dalam bahasa tersebut.  Saat berikutnya, jika kita ingin mengubah nama dan nama keluarga, kemungkinan besar kita ingin mengubahnya bersama, jadi harus ada metode publik yang tepat yang mengubahnya bersama-sama. <br><br><img src="https://habrastorage.org/webt/p8/ze/vw/p8zevw3bkth4ialnrabvlsk3hru.jpeg"><br><br>  Dalam metode publik ini, kami juga memverifikasi bahwa panjang garis-garis ini cocok dengan apa yang kami gunakan dalam database.  Dan jika ada sesuatu yang salah, maka hentikan eksekusi.  Di sini saya menggunakan trik yang sama.  Saya mendeklarasikan atribut khusus dan memanggilnya dalam kode aplikasi. <br><br><img src="https://habrastorage.org/webt/tj/ae/mi/tjaemirkcgpbgkmknl9acjkhioa.jpeg"><br><br>  Selain itu, atribut tersebut dapat digunakan kembali dalam Dto.  Sekarang, jika saya ingin mengubah nama dan nama keluarga, saya mungkin memiliki perintah perubahan seperti itu.  Apakah perlu menambahkan konstruktor khusus di sini?  Tampaknya sepadan.  Ini akan menjadi lebih baik, tidak ada yang akan mengubah nilai-nilai ini, tidak akan merusaknya, mereka akan benar. <br><br><img src="https://habrastorage.org/webt/lt/hq/r1/lthqr1w63fzepclzgrcl6ykwaik.jpeg"><br><br>  Sebenarnya tidak juga.  Faktanya adalah Dto bukan objek sama sekali.  Ini adalah kamus tempat kami menaruh data deserialisasi.  Yaitu, mereka berpura-pura menjadi objek, tentu saja, tetapi mereka hanya memiliki satu tanggung jawab - harus serial dan deserialized.  Jika kami mencoba melawan struktur ini, kami akan mulai mengumumkan beberapa ModelBinders dengan desainer, untuk melakukan sesuatu seperti ini sangat melelahkan, dan, yang paling penting, itu akan pecah dengan rilis baru kerangka kerja baru.  Semua ini dijelaskan dengan baik oleh Mark Simon dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Di perbatasan program tidak berorientasi objek"</a> , jika menarik, lebih baik membaca posnya, di sana dijelaskan secara rinci. <br><br><img src="https://habrastorage.org/webt/mf/bw/he/mfbwhegqg7nbmsw4iwj0y8w99c0.jpeg"><br><br>  Singkatnya, kita memiliki dunia eksternal yang kotor, kita memberi tanda pada input, mengubahnya menjadi model bersih kita, dan kemudian mentransfer semuanya kembali ke serialisasi, ke browser, lagi ke dunia eksternal yang kotor. <br><br><h3>  Handler </h3><br>  Setelah semua perubahan ini dilakukan, bagaimana Hander akan terlihat seperti di sini? <br><br><img src="https://habrastorage.org/webt/o-/ov/wl/o-ovwlxyrkjuv2murrbk4ifttr4.jpeg"><br><br>  Saya menulis dua baris di sini untuk membuatnya lebih mudah dibaca, tetapi secara umum dapat ditulis dalam satu.  Datanya benar, karena kami memiliki sistem tipe, ada validasi, yaitu data yang diperkuat beton, Anda tidak perlu memeriksanya lagi.  Pengguna seperti itu juga ada, tidak ada pengguna lain dengan email yang sibuk, semuanya bisa dilakukan.  Namun, masih belum ada panggilan ke metode SaveChanges, tidak ada pemberitahuan dan tidak ada log dan profiler, kan?  Kami melanjutkan. <br><a name="events"></a><br><h3>  Acara </h3><br>  Peristiwa domain. <br><br><img src="https://habrastorage.org/webt/fo/s8/tq/fos8tqpb3kq5ealyvsm3qu9ayhm.jpeg"><br><br>  Mungkin pertama kali konsep ini dipopulerkan oleh Udi Dahan dalam postingannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Acara Domain - Keselamatan"</a> .  Di sana, ia menyarankan hanya mendeklarasikan kelas statis dengan metode Naikkan dan melempar peristiwa seperti itu.  Beberapa saat kemudian, Jimmy Bogard mengusulkan implementasi yang lebih baik, disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pola peristiwa domain yang lebih baik"</a> . <br><br><img src="https://habrastorage.org/webt/lq/e_/hq/lqe_hqerzlvb_vi4less4xr6lg4.jpeg"><br><br>  Saya akan menunjukkan serialisasi Bogard dengan satu perubahan kecil, tetapi yang penting.  Alih-alih melempar peristiwa, kita dapat mendeklarasikan beberapa daftar, dan di tempat-tempat di mana semacam reaksi harus terjadi, langsung di dalam entitas untuk menyimpan peristiwa ini.  Dalam hal ini, pengambil <code>email</code> ini juga merupakan kelas Pengguna, dan kelas ini, properti ini tidak berpura-pura menjadi properti dengan pengambil dan setter otomatis, tetapi benar-benar menambahkan sesuatu pada ini.  Artinya, ini adalah enkapsulasi nyata, bukan senonoh.  Saat berubah, kami memeriksa apakah emailnya berbeda dan mengadakan acara.  Acara ini belum mencapai tempat, kami hanya memilikinya di daftar internal entitas. <br><br><img src="https://habrastorage.org/webt/ge/4c/nd/ge4cndzro2vbjuhb4qeujuot1qq.jpeg"><br><br>  Selanjutnya, pada saat kita akan memanggil metode SaveChanges, kita mengambil ChangeTracker, melihat apakah ada entitas yang mengimplementasikan antarmuka, apakah mereka memiliki peristiwa domain.  Dan jika ada, mari kita ambil semua acara domain ini dan mengirimkannya ke operator yang tahu apa yang harus dilakukan dengan mereka. <br><br>  Pelaksanaan dispatcher ini adalah topik untuk diskusi lain, ada beberapa kesulitan dengan pengiriman ganda di C #, tetapi ini juga dilakukan.  Dengan pendekatan ini, ada keuntungan lain yang tidak jelas.  Sekarang, jika kita memiliki dua pengembang, satu dapat menulis kode yang mengubah email ini, dan yang lain dapat melakukan modul notifikasi.  Mereka sama sekali tidak terhubung satu sama lain, mereka menulis kode yang berbeda, mereka hanya terhubung pada tingkat acara domain ini dari satu kelas Dto.  Pengembang pertama hanya membuang kelas ini di beberapa titik, yang kedua meresponsnya dan tahu bahwa itu perlu dikirim melalui email, SMS, push notification ke telepon dan semua juta notifikasi lainnya, dengan mempertimbangkan preferensi pengguna yang biasanya terjadi. <br><br><img src="https://habrastorage.org/webt/pb/-r/op/pb-ropw5rupxtrrbdfes8_lvp6q.jpeg"><br><br>  Inilah poin terkecil, tetapi penting.  Artikel Jimmy menggunakan kelebihan metode SaveChanges, dan lebih baik tidak melakukannya.  Dan lebih baik melakukannya di dekorator, karena jika kita membebani metode SaveChanges dan kita membutuhkan dbContext di Handler, kita akan mendapatkan dependensi melingkar.  Anda dapat bekerja dengan ini, tetapi solusinya sedikit kurang nyaman dan sedikit kurang indah.  Karena itu, jika pipa dibangun di atas dekorator, maka saya tidak melihat alasan untuk melakukannya secara berbeda. <br><br><h3>  Penebangan dan Pembuatan Profil </h3><br><img src="https://habrastorage.org/webt/bg/nq/m_/bgnqm_jchmmhwbbl7bsvb-binni.jpeg"><br><br>  Sarang kode tetap ada, tetapi pada contoh awal kita pertama kali menggunakan MiniProfiler, lalu coba tangkap, lalu jika.  Total ada tiga tingkat bersarang, sekarang masing-masing tingkat ini bersarang di dekorator sendiri.  Dan di dalam dekorator, yang bertanggung jawab untuk pembuatan profil, kami hanya memiliki satu tingkat sarang, kode dibaca dengan sempurna.  Selain itu, jelas bahwa dalam dekorator ini hanya ada satu tanggung jawab.  Jika dekorator bertanggung jawab untuk login, maka ia hanya akan login, jika untuk profiling, masing-masing, hanya profil, yang lainnya ada di tempat lain. <br><br><h3>  Tanggapan </h3><br>  Setelah seluruh pipeline bekerja, kita hanya bisa mengambil Dto dan mengirimkannya ke browser lebih lanjut, membuat serialisasi JSON. <br><br><img src="https://habrastorage.org/webt/wc/tt/0h/wctt0hneqcetsw0pjtya_s5p5eg.jpeg"><br><br>  Tetapi satu hal kecil lagi, hal semacam itu yang kadang-kadang dilupakan: pada setiap tahap, Pengecualian dapat terjadi di sini, dan sebenarnya Anda perlu untuk menanganinya. <br><br><img src="https://habrastorage.org/webt/rh/ns/lh/rhnslhowdccmndavybt1a9pyfmy.jpeg"><br><br>  Saya tidak bisa tidak menyebutkan Scott Vlashin dan laporannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"pemrograman berorientasi kereta api" di</a> sini lagi.  Mengapa  Laporan asli sepenuhnya dikhususkan untuk bekerja dengan kesalahan dalam bahasa F #, cara mengatur aliran sedikit berbeda dan mengapa pendekatan seperti itu lebih baik daripada menggunakan Exception'ov.  Dalam F #, ini benar-benar bekerja dengan sangat baik, karena F # adalah bahasa fungsional, dan Scott menggunakan fungsionalitas bahasa fungsional. <br><br><img src="https://habrastorage.org/webt/wd/-7/gg/wd-7ggf6-mg0y1orcgz-2si45ci.jpeg"><br><br>  Karena, mungkin, sebagian besar dari Anda masih menulis dalam C #, jika Anda menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analog dalam C #</a> , maka pendekatan ini akan terlihat seperti ini.  Alih-alih melempar pengecualian, kami mendeklarasikan kelas Hasil yang memiliki cabang yang sukses dan cabang yang tidak berhasil.  Dengan demikian, dua desainer.  Kelas hanya bisa dalam satu negara.  Kelas ini adalah kasus khusus dari jenis persatuan, persatuan terdiskriminasi dari F #, tetapi ditulis ulang dalam C #, karena tidak ada dukungan bawaan di C #. <br><br><img src="https://habrastorage.org/webt/jo/xu/p2/joxup2i8w_uziwqyawnwp6cty8e.jpeg"><br><br>  Alih-alih menyatakan getter publik bahwa seseorang mungkin tidak memeriksa nol dalam kode, Pencocokan Pola digunakan.  Sekali lagi, dalam F # itu akan menjadi bahasa Pencocokan Pola bawaan, dalam C # kita harus menulis metode terpisah di mana kita akan melewati satu fungsi yang tahu apa yang harus dilakukan dengan hasil operasi yang sukses, bagaimana mengubahnya lebih jauh ke bawah rantai, dan dengan kesalahan.  Yaitu, tidak masalah cabang mana yang bekerja untuk kita, kita harus memberikan ini ke satu hasil yang dikembalikan.  Dalam F #, ini semua bekerja dengan sangat baik, karena ada komposisi fungsional, baik, dan segala sesuatu yang telah saya daftarkan.  Di .NET, ini bekerja sedikit lebih buruk, karena segera setelah Anda memiliki lebih dari satu Hasil, tetapi banyak - dan hampir setiap metode dapat gagal karena satu alasan atau yang lain - hampir semua jenis fungsi yang dihasilkan menjadi jenis Hasil, dan Anda memerlukannya sebagai untuk menggabungkan sesuatu. <br><br><img src="https://habrastorage.org/webt/vb/s8/wd/vbs8wdzd81uocge3l2louammnwa.jpeg"><br><br>  Cara termudah untuk menggabungkan mereka adalah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan LINQ</a> , karena sebenarnya LINQ tidak hanya bekerja dengan IEnumerable, jika Anda mendefinisikan kembali metode SelectMany dan Select dengan cara yang benar, maka kompiler C # akan melihat bahwa Anda dapat menggunakan sintaks LINQ untuk jenis ini.  Secara umum, ternyata kertas kalkir dengan notasi Haskell atau dengan Ekspresi Komputasi yang sama dalam F #.  Bagaimana ini harus dibaca?  Di sini kita memiliki tiga hasil operasi, dan jika semuanya baik-baik saja di ketiga kasus, maka ambil hasil ini r1 + r2 + r3 dan tambahkan.  Jenis nilai yang dihasilkan juga akan menjadi Hasil, tetapi Hasil baru, yang kami nyatakan dalam Pilih.  Secara umum, ini bahkan merupakan pendekatan yang berfungsi, jika bukan hanya satu tetapi. <br><br><img src="https://habrastorage.org/webt/ez/8d/lw/ez8dlwqtpilfzqbpsp_8zg1udvw.jpeg"><br><br>  Untuk semua pengembang lain, segera setelah Anda mulai menulis kode seperti itu di C #, Anda mulai terlihat seperti ini.  “Ini adalah Pengecualian menakutkan yang buruk, jangan tulis mereka!  Mereka jahat!  Lebih baik tulis kode yang tidak ada yang mengerti dan tidak bisa men-debug! " <br><br><img src="https://habrastorage.org/webt/v4/v4/vd/v4v4vdhq2reierp3a0diyhtm-ws.jpeg"><br><br>  C # bukan F #, ini agak berbeda, tidak ada konsep yang berbeda atas dasar ini dilakukan, dan ketika kami mencoba menarik burung hantu di dunia seperti itu, ternyata yang paling tidak, tidak biasa. <br><br><img src="https://habrastorage.org/webt/ns/w3/q7/nsw3q7lbpx2xqiewao1619j-t1s.jpeg"><br><br>  Sebagai gantinya, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat normal bawaan</a> yang didokumentasikan, yang diketahui semua orang dan tidak akan menyebabkan disonansi kognitif di antara pengembang.  ASP.NET memiliki Pengecualian Handler global. <br><br><img src="https://habrastorage.org/webt/i8/9i/vk/i89ivkfdyr5w8xmemg2by9qz0zs.jpeg"><br><br>  Kami tahu bahwa jika ada masalah dengan validasi, Anda harus mengembalikan kode 400 atau 422 (Entitas yang tidak dapat diproses).  Jika ada masalah dengan otentikasi dan otorisasi, ada 401 dan 403. Jika terjadi kesalahan, maka ada yang salah.  Dan jika ada yang tidak beres dan Anda ingin memberi tahu pengguna apa tepatnya, tentukan jenis Pengecualian Anda, katakan bahwa itu adalah IHasUserMessage, nyatakan Pengambil pesan di antarmuka ini dan cukup periksa: jika antarmuka ini diimplementasikan, maka Anda dapat menerima pesan dari Exception dan berikan JSON kepada pengguna.  Jika antarmuka ini tidak diimplementasikan, itu berarti ada semacam kesalahan sistem, dan kami hanya memberi tahu pengguna bahwa ada kesalahan, kami sudah melakukannya, kita semua tahu - yah, seperti biasa. <br><br><h3>  Pipa permintaan </h3><br>  Kami menyimpulkan ini dengan tim dan melihat apa yang kami miliki di Read-stack.  Adapun permintaan, validasi, tanggapan langsung - ini adalah tentang hal yang sama, kami tidak akan berhenti secara terpisah.  Mungkin masih ada cache tambahan, tetapi secara umum tidak ada masalah besar dengan cache juga. <br><br><h3>  Keamanan </h3><br>  Mari kita lihat pemeriksaan keamanan dengan lebih baik.  Mungkin juga ada dekorator Keamanan yang sama, yang memeriksa apakah permintaan ini dapat dibuat atau tidak: <br><br><img src="https://habrastorage.org/webt/9k/y7/dr/9ky7drwhf3o5tk_r6wcapy4nqaw.jpeg"><br><br>  Tetapi ada kasus lain di mana kami menampilkan lebih dari satu catatan, dan daftar, dan untuk beberapa pengguna kami perlu menampilkan daftar lengkap (misalnya, untuk beberapa administrator super), dan untuk pengguna lain kami harus membuat daftar daftar terbatas, terbatas ketiga ke yang lain, baik, dan seperti yang sering terjadi dalam aplikasi perusahaan, hak akses bisa sangat canggih, jadi Anda harus yakin bahwa data yang tidak menargetkan pengguna ini tidak masuk ke daftar ini. <br><br>  Masalahnya diselesaikan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cukup sederhana</a> .  Kami dapat mendefinisikan kembali antarmuka (IPermissionFilter) ke mana permintaan asli datang dan pengembalian yang dapat diminta.  Perbedaannya adalah bahwa untuk queryable yang kembali, kami telah memberlakukan kondisi tambahan di mana, memeriksa pengguna saat ini dan berkata: "Di sini, kembalikan hanya data itu ke pengguna itu ..." - dan kemudian semua logika Anda terkait dengan izin .  Sekali lagi, jika Anda memiliki dua programmer, satu programmer pergi untuk menulis izin, ia tahu bahwa ia perlu menulis banyak izinFilters dan memeriksa apakah mereka bekerja dengan benar untuk semua entitas.  Dan programmer lain tidak tahu apa-apa tentang izin, dalam daftar mereka data yang benar selalu berlalu, itu saja.  Karena mereka menerima input bukan lagi queryable asli dari dbContext, tetapi terbatas pada filter.  IzinFilter tersebut juga memiliki properti tata letak, kita dapat menambahkan dan menerapkan semua permitFilters.  Sebagai hasilnya, kami mendapatkan izinFilter yang dihasilkan, yang akan mempersempit pemilihan data secara maksimal, dengan mempertimbangkan semua kondisi yang sesuai untuk entitas ini. <br><br><img src="https://habrastorage.org/webt/25/2o/xj/252oxjpxf1p7zd_aq3nt55cenyi.jpeg"><br><br>  Mengapa tidak melakukannya dengan alat bawaan ORM, misalnya, Filter Global dalam kerangka entitas?  Sekali lagi, agar Anda tidak membuat ketergantungan siklik untuk diri sendiri dan tidak menyeret cerita tambahan tentang lapisan bisnis Anda ke dalam konteks. <br><br><h3>  Pipa Permintaan.  Baca model </h3><br>  Masih melihat model membaca.  Paradigma CQRS tidak menggunakan model domain dalam tumpukan membaca, sebagai gantinya, kami hanya langsung membuat Dto yang dibutuhkan browser saat ini. <br><br><img src="https://habrastorage.org/webt/2s/kc/0y/2skc0ygq4rmh9rs6cyg5czxa5rm.jpeg"><br><br>  Jika kami menulis dalam C #, maka kemungkinan besar kami menggunakan LINQ, jika tidak ada persyaratan kinerja yang mengerikan, dan jika ada, maka Anda mungkin tidak memiliki aplikasi perusahaan.  Secara umum, masalah ini dapat diselesaikan sekali dan untuk semua dengan LinqQueryHandler.  Inilah kendala yang cukup menyeramkan pada generik: ini adalah Query, yang mengembalikan daftar proyeksi, dan masih dapat memfilter proyeksi ini dan mengurutkan proyeksi ini.  Dia juga hanya bekerja dengan beberapa jenis entitas dan tahu cara mengubah entitas ini menjadi proyeksi dan mengembalikan daftar proyeksi tersebut dalam bentuk Dto ke browser. <br><br><img src="https://habrastorage.org/webt/8e/vz/ax/8evzaxkzbhqx0mgxfadxacpek24.jpeg"><br><br>  Implementasi metode Handle bisa sangat sederhana.  Untuk jaga-jaga, periksa apakah filter TQuery ini mengimplementasikan entitas asli.  Selanjutnya kami melakukan proyeksi, itu adalah ekstensi AutoMapper'a.  Jika seseorang masih tidak tahu, AutoMapper dapat membangun proyeksi di LINQ, yaitu orang-orang yang akan membangun metode Pilih, dan tidak memetakannya dalam memori. <br><br>  Lalu kami menerapkan pemfilteran, menyortir, dan menampilkan semuanya di browser.     ,      DotNext,     ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,  , , ,     expression' ,            . <br><br><h3>     <s></s>   SQL </h3><br>  .  ,       DotNext', —      SQL.    Select , ,      ,  queryable-   . <br><br><img src="https://habrastorage.org/webt/3j/ns/3b/3jns3bzz_ebriubturd0ewzzwqg.jpeg"><br><br>      ,    .     ,    Title,  Title      ,     .      ,  .        SubTitle,      ,   ,     -      ,    queryable-   .    ,        . <br><br>      ,    .  ,    ,     .    ,   , .     «JsonIgnore»,     .    ,   ,  Dto.    ,     ,      .       JSON,  ,  Created  LastUpdated   ,  SubTitle —   ,   .    ,   ,        ,   , ,       .          ,  -     . <br><br><img src="https://habrastorage.org/webt/uy/el/go/uyelgoxsnf7dzhsv6arfq0q16ly.jpeg"><br><br>      . ,  -,      ,    .    ,  pipeline,     .      —      , ,  . ,      SaveChanges,   Query    SaveChanges.      ,    ,          ,   NuGet,         . <br><br>         .     ,    -  ,     ,     .   , ,   , , ,       —   . ,  ,      : «    », —   .  . <br><br><h2>   </h2><br>    ,    ? <br><br><img src="https://habrastorage.org/webt/rj/px/0i/rjpx0ig2zyqa7d9g47vibhbeccy.jpeg"><br><br>    -  .   . <br><br><img src="https://habrastorage.org/webt/d6/ag/p7/d6agp7a_t3m2ppxscq9vb7piagq.jpeg"><br><br>  , ,    ,     .   MediatR  ,         . ,    ,    — ,    MediatR   pipeline behaviour.    ,      Request/Response, RequestHandler'      .    Simple Injector,    —    . <br><br><img src="https://habrastorage.org/webt/qd/et/4g/qdet4g_b9ezljfr1mx9moe_m18y.jpeg"><br><br>       , ,  ,       ,  TIn: ICommand. <br><br><img src="https://habrastorage.org/webt/su/nb/vn/sunbvndlkmxley6clq7hs4hj70s.jpeg"><br><br>   Simple Injector'      constraint' .     ,    , ,     constraint',        Handler',     constraint. ,     constraint ICommand,      SaveChanges   constraint'  ICommand,  Simple Injector  ,    constraint' ,         Handler'. ,      ,          ,     . <br><br>  ? Simple Injector  MeriatR —  ,       ,    Autofac', -,          ,    ,  .  , . <br><br><h2>   ,    </h2><br>          ,   «». <br><br><img src="https://habrastorage.org/webt/8m/1l/lj/8m1lljzfrx2amaidftyjnthd3yc.jpeg"><br><br>   ,   «Clean architecture».             . <br><br><img src="https://habrastorage.org/webt/ch/gm/jq/chgmjq7gihsvthnvinnydngrtcw.jpeg"><br><br>  - -     ,   MVC,   ,    . <br><br><img src="https://habrastorage.org/webt/g8/70/wz/g870wzkcrbvqeplit3m_i69uru4.jpeg"><br><br>  ,   ,   ,     Angular, ,       ,      ,    .  ,  : « — MVC-»,  : «    Features,    :     ,    Blog     - Import,    -  ». <br><br>  , , ,  ,   MVC-,  ,   -  , .    MVC  .    ,   ,      —     .       . <br><br><img src="https://habrastorage.org/webt/ix/8v/qo/ix8vqotanjad8uljd2rfz17xygg.jpeg"><br><br><img src="https://habrastorage.org/webt/xq/lj/bv/xqljbvd8zk59n6pdn1-q-x4czhc.jpeg"><br><br>    -     ,  -   -,        . <br><br> -,     ,   .            ,   .   ,          -   ,         User Service,   pull request',     ,       User Service    ,   .    ,      - ,     -  , . -       ,             . <br><br>  .         ,          .  ,    ,             ,   . , ,  ,  ,   ,     ,    ,     -   .    ,      (    ,    ),     ,    «Delete»:   ,      ,  .  . <br><br>          —  «», ,   ,       ,   .          ,    :   ,    ,     ,      .           ,   .      ,    ,   .      ,      ,      . <br><br>   :        .    « »,        :     ,     ,         . ,    ,    ,       , ,    ,  ,   .        ,   .  ,   - pull request    ,    —  ,    — -   ,    .          VCS    :     -  ,    ?       ,    -  ,         ,    . <br><br><img src="https://habrastorage.org/webt/ie/g2/i6/ieg2i6gpy-mp6nsmrvdvxot3x6o.jpeg"><br><br>   , ,    ,   .  :     .        ,     .  ,    ,      ,  ,   .    , ,    ,      . ,  , .    « »,        ,     .  ,   ,      —  ,      ,   . <br><br>      :    , - , .           .  -      ,    ,  ,   ,  .       -        ,  -        ,      , ,      ,    .    . <br><br><img src="https://habrastorage.org/webt/8g/7g/3h/8g7g3htn43hhoprdfj2thj86wre.jpeg"><br><br> .         ,       IHandler     .    . <br><br>   IHandler    ICommandHandler  IQueryHandler  ,    .    ,     ,       .  ,   CommandHandler,      CommandHandler',       . <br><br>  Kenapa begitu      ,    Query   ,   Query —   .      ,     ,  ,    Hander,    CommandHandler  QueryHandler,   -  use case,     . <br><br>  —     ,      ,  ,    ,     :  ,  . <br><br>      ,  .         ,    .    ,       -. <br><br>      C# 8,   nullable reference type      .  , , ,     ,  . <br><br>         ChangeTracker' ORM. <br><br>  Exception' —     ,     F#,     C#.  ,   -     ,    -   , .        ,   ,      Exception', ,      LINQ,   ,  ,    ,     ,    , Dapper  - , ,  ,   .NET. <br><br>          ,  LINQ,  , permission' —   . ,    ,   - ,    ,       .      ,     —   . <br><br>        .  : <br><br><hr><br><ul><li> Vertical Slices <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.youtube.com/watch?v=SUiWfhAhgQw</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.cuttingedge.it/blogs/steven/pivot/entry.php?id=91</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cuttingedge.it/blogs/steven/pivot/entry.php?id=92</a> </li></ul></li><li>   <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/post/266937</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/post/205088</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/post/205108</a> </li></ul></li><li> Domain Events <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">udidahan.com/2009/06/14/domain-events-salvation</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">enterprisecraftsmanship.com/2017/10/03/domain-events-simple-and-reliable-solution</a> </li></ul></li><li> DDD <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/post/334126</a> </li></ul></li><li> ROP <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fsharpforfunandprofit.com/rop</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/post/339606</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/post/347284</a> </li></ul></li><li> LINQ  Expressions: <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/company/jugru/blog/423891</a> </li></ul></li><li> Clean Architecture <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.youtube.com/watch?v=JEeEic-c0D4</a> </li></ul></li></ul><br><img src="https://habrastorage.org/webt/fm/ik/wu/fmikwu49krcbqw7xbefe1vm6tsq.jpeg"><br><br>   —   .      .   —     «Domain Modeling Made Functional»,   F#,          F#,      ,     ,     ,        ,      .       C# ,    ,         Exception'. <br><br>  ,  ,   —  «Entity Framework Core In Action».      ,    Entity Framework,         ,     DDD  ORM,   ,   ORM      DDD    . <br><br><blockquote>  Menit periklanan. 15-16  2019  .NET- DotNext Piter,      .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447308/">https://habr.com/ru/post/id447308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447298/index.html">Manajemen pengetahuan melalui model kompetensi</a></li>
<li><a href="../id447300/index.html">Membangun VirtualBox untuk Windows</a></li>
<li><a href="../id447302/index.html">Sistem Operasi Akhir Pekan</a></li>
<li><a href="../id447304/index.html">Avaricious tidak membayar dua kali - kami mengonfigurasikan memori pada platform AMD B450 dan kami menerima produktivitas gratis</a></li>
<li><a href="../id447306/index.html">Tesla Transformer pada papan satu inci persegi</a></li>
<li><a href="../id447310/index.html">Bagaimana kami beralih dari pengembangan web ke pengembangan game</a></li>
<li><a href="../id447314/index.html">Apa yang saya pahami tentang membangun bisnis setelah bekerja selama tujuh tahun di Airbnb</a></li>
<li><a href="../id447318/index.html">Gadget dari pasar loak: mengapa membeli laptop Packard Bell yang berusia 20 tahun dengan harga 10 euro</a></li>
<li><a href="../id447322/index.html">Prinsip membangun API JSON SISA</a></li>
<li><a href="../id447324/index.html">Bagaimana komputer bekerja di dalam Hayabusa-2, yang menjatuhkan bom pada Ryuga. Dan foto-foto pengembangnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>