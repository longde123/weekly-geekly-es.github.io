<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↩️ 🧖 👇🏾 Wie ist der Barcode angeordnet? 😽 🍠 ✍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Ein moderner Mensch trifft jeden Tag auf Barcodes, ohne darüber nachzudenken. Wenn wir Produkte im Supermarkt kaufen, werden deren Code...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ist der Barcode angeordnet?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439604/">  Hallo Habr! <br><br>  Ein moderner Mensch trifft jeden Tag auf Barcodes, ohne darüber nachzudenken.  Wenn wir Produkte im Supermarkt kaufen, werden deren Codes mit Hilfe eines Barcodes genau gelesen.  Auch Pakete, Waren in Lagern und so weiter und so fort.  Allerdings wissen nur wenige, wie es wirklich funktioniert. <br><br>  Wie ist der Barcode angeordnet und was ist in diesem Bild codiert? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Versuchen wir es herauszufinden, gleichzeitig schreiben wir einen Decoder für solche Codes. <a name="habracut"></a><br><br><h2>  Einführung </h2><br>  Die Verwendung von Barcodes hat eine lange Geschichte.  Die ersten Automatisierungsversuche begannen bereits in den 1950er Jahren, 1952 wurde ein Patent für einen Codeleser erteilt.  Der an der Sortierung der Waggons auf der Eisenbahn beteiligte Ingenieur wollte den Prozess vereinfachen.  Die Idee war offensichtlich - die Nummer mit Streifen zu codieren und sie mit Fotozellen zu lesen.  1962 wurden Codes offiziell zur Identifizierung von Autos auf der amerikanischen Eisenbahn ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KarTrak-</a> System) verwendet. 1968 wurde der Suchscheinwerfer durch einen Laserstrahl ersetzt, der die Genauigkeit erhöhte und die Größe des Lesegeräts verringerte.  1973 erschien das Format „Universal Product Code“, und 1974 wurde das erste Produkt mit einem Codescanner (Wrigleys Kaugummi sind die USA;) in einem Supermarkt verkauft.  1984 verwendete ein Drittel der Geschäfte Luftschlangen, aber in Russland wurden sie um die 90er Jahre verwendet. <br><br>  Es werden sehr viele verschiedene Codes für verschiedene Aufgaben verwendet, zum Beispiel kann die Sequenz „12345678“ auf diese Weise dargestellt werden (und das ist noch nicht alles): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Beginnen wir mit dem bitweisen Parsen.  Darüber hinaus bezieht sich alles, was unten beschrieben wird, auf das Formular „Code-128“ - einfach, weil sein Format recht einfach und unkompliziert ist.  Wer mit anderen Arten experimentieren möchte, kann einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Generator</a> öffnen und sich selbst davon überzeugen. <br><br>  Auf den ersten Blick scheint der Barcode nur eine zufällige Folge von Zeilen zu sein, tatsächlich ist seine Struktur klar festgelegt: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Leerer Speicherplatz zur eindeutigen Identifizierung des Codeanfangs <br>  2 - Startsymbol.  Für Code-128 sind 3 Optionen möglich (A, B und C genannt): 11010000100, 11010010000 oder 11010011100, sie entsprechen verschiedenen Codetabellen (weitere Einzelheiten siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ). <br>  3 - Eigentlich der Code, der die Daten enthält, die wir brauchen <br>  4 - Prüfsumme <br>  5 - Stoppsymbol.  Für Code-128 ist dies 1100011101011. <br>  6 (1) - Leerraum. <br><br>  Nun dazu, wie Bits codiert werden.  Hier ist alles sehr einfach - wenn Sie die Breite der dünnsten Linie als „1“ annehmen, gibt die Linie mit doppelter Breite den Code „11“, ein dreifaches „111“ usw. an.  Der leere Raum ist nach dem gleichen Prinzip "0" oder "00" oder "000".  Wer möchte, kann den Startcode im Bild vergleichen, um sicherzustellen, dass die Regel erfüllt ist. <br><br>  Jetzt können Sie mit der Programmierung beginnen. <br><br><h2>  Holen Sie sich die Bitfolge </h2><br>  Im Prinzip ist dies der schwierigste Teil, und natürlich kann er algorithmisch auf verschiedene Arten implementiert werden.  Ich bin mir nicht sicher, ob der folgende Algorithmus optimal ist, aber für eine Fallstudie reicht er völlig aus. <br><br>  Laden Sie zunächst das Bild, dehnen Sie es in der Breite, ziehen Sie eine horizontale Linie von der Bildmitte, konvertieren Sie es in s / w und laden Sie es als Array. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Auf dem Barcode entspricht „1“ Schwarz und auf RGB dagegen 0, daher muss das Array invertiert werden.  Gleichzeitig berechnen wir den Durchschnittswert. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Wir starten das Programm, um sicherzustellen, dass der Barcode korrekt geladen ist: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Jetzt müssen Sie die Breite eines "Bits" bestimmen.  Dazu markieren wir den Beginn der Startsequenz "1101" und zeichnen die Momente des Übergangs des Graphen durch die Mittellinie auf. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Wir zeichnen nur die Übergänge durch die Mitte auf, so dass der Code „1101“ als „101“ geschrieben wird. Dies reicht jedoch aus, um die Breite in Pixel zu ermitteln. <br><br>  Nun die eigentliche Dekodierung.  Wir finden den nächsten Übergang durch die Mitte und bestimmen die Anzahl der Bits, die in das Intervall fallen.  Da die Übereinstimmung nicht absolut ist (der Code kann leicht gekrümmt oder gedehnt sein), verwenden wir die Rundung. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Ich bin mir nicht sicher, ob dies die beste Option ist. Vielleicht gibt es einen besseren Weg. Diejenigen, die dies wünschen, können in die Kommentare schreiben. <br><br>  Wenn alles richtig gemacht wurde, erhalten wir ungefähr die folgende Reihenfolge der Ausgabe: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Dekodierung </h2><br>  Hier gibt es grundsätzlich keine Schwierigkeiten.  Zeichen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code-128</a> werden mit einem 11-Bit-Code codiert, der 3 Varianten (A, B und C) aufweist und entweder unterschiedliche Zeichencodierungen oder Zahlen von 00 bis 99 speichern kann. <br><br>  In unserem Fall ist der Beginn der Sequenz 11010010000, was „Code B“ entspricht.  Es war furchtbar kaputt, alle Codes aus Wikipedia manuell einzugeben, daher wurde die Tabelle einfach aus dem Browser kopiert und auch in Python analysiert (Hinweis: Dies ist für die Produktion nicht erforderlich). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Jetzt bleibt das Einfachste.  Wir teilen unsere Bitfolge in Blöcke mit 11 Zeichen auf: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Schließlich bilden wir die Linie und zeigen sie auf dem Bildschirm an: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  Ich werde keine Antwort auf das geben, was in der Tabelle verschlüsselt ist. Lassen Sie es eine Hausaufgabe für die Leser sein (die Verwendung von vorgefertigten Programmen für Smartphones wird als Betrug betrachtet :). <br><br>  Der Code implementiert auch keine CRC-Überprüfung, diejenigen, die dies wünschen, können dies selbst tun. <br><br>  Natürlich ist der Algorithmus nicht perfekt und wurde in einer halben Stunde geschrieben.  Für professionellere Zwecke gibt es vorgefertigte Bibliotheken, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pyzbar</a> .  Code, der eine solche Bibliothek verwendet, benötigt nur 4 Zeilen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (Zuerst müssen Sie die Bibliothek installieren, indem Sie den Befehl pip install pyzbar eingeben.) <br><br>  <b>Ergänzung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">vinograd19</a> schrieb in den Kommentaren zur CRC-Zählung: <br><br>  <i>Die Geschichte der Prüfziffer ist interessant.</i>  <i>Es entstand evolutionär.</i> <i><br></i>  <i>Die Prüfziffer wird benötigt, um eine fehlerhafte Dekodierung zu vermeiden.</i>  <i>Wenn der Barcode 1234 war und als 7234 erkannt wurde, benötigen Sie eine Validierung, die das Ersetzen von 1 durch 7 verhindert. Die Validierung ist möglicherweise ungenau, sodass mindestens 90% der ungültigen Zahlen im Voraus ermittelt werden.</i> <i><br><br></i>  <i>1. Ansatz: Nehmen wir einfach den Betrag.</i>  <i>Damit der Rest der Division durch 10 0 ist. Nun, das heißt, die ersten 12 Zeichen tragen eine Informationslast, und die letzte Ziffer wird so ausgewählt, dass die Summe der Ziffern durch 10 geteilt wird. Dekodieren Sie die Sequenz. Wenn die Summe nicht durch 10 teilbar ist, bedeutet dies, dass Sie mit einem Fehler dekodiert haben und dies tun müssen diesmal noch einmal.</i>  <i>Beispielsweise ist der Code 1234 gültig.</i>  <i>1 + 2 + 3 + 4 = 10. Code 1216 ist ebenfalls gültig, 1218 jedoch nicht.</i> <i><br><br></i>  <i>Dies vermeidet Probleme mit der Automatisierung.</i>  <i>Zum Zeitpunkt der Erstellung der Barcodes gab es jedoch einen Fallback in Form der Eingabe einer Zahl auf den Tasten.</i>  <i>Und es gibt einen schlechten Fall: Wenn Sie die Reihenfolge der beiden Ziffern ändern, ändert sich die Prüfsumme nicht, und das ist schlecht.</i>  <i>Das heißt, wenn der Barcode 1234 als 2134 gehämmert wurde, konvergiert die Prüfsumme, aber wir haben die falsche Nummer eingegeben.</i>  <i>Es stellt sich heraus, dass die falsche Reihenfolge der Zahlen häufig vorkommt, wenn Sie schnell auf die Tasten klopfen.</i> <i><br><br></i>  <i>2. Ansatz.</i>  <i>Lassen Sie uns die Menge etwas komplizierter machen.</i>  <i>Damit werden die Zahlen an geraden Stellen zweimal berücksichtigt.</i>  <i>Wenn Sie dann die Reihenfolge ändern, konvergiert der Betrag definitiv nicht zum gewünschten.</i>  <i>Beispielsweise ist Code 2364 gültig (2 + 3 + 3 + 6 + 4 + 4 = 20) und Code 3264 ist ungültig (3+ 2 + 2 + 6 + 4 + 4 = 19).</i>  <i>Aber hier war ein anderes schlechtes Beispiel für das Fahren.</i>  <i>Einige Tastaturen sind so angeordnet, dass zehn Ziffern in zwei Reihen angeordnet sind.</i>  <i>Die erste Zeile ist 12345 und darunter die zweite zweite Zeile 67890. Wenn Sie anstelle der Taste „1“ die Taste „2“ rechts drücken, verhindert die Prüfsumme eine falsche Eingabe.</i>  <i>Wenn Sie jedoch anstelle der Taste „1“ die unten stehende Taste „6“ drücken, wird möglicherweise keine Warnung ausgegeben.</i>  <i>Immerhin ist 6 = 1 + 5, und wenn diese Zahl bei der Berechnung der Prüfsumme an einer geraden Stelle liegt, haben wir 2 * 6 = 2 * 1 + 2 * 5.</i>  <i>Das heißt, die Prüfsumme wurde um genau 10 erhöht, sodass sich die letzte Ziffer nicht geändert hat.</i>  <i>Beispielsweise sind die Prüfsummen in den Codes 2134 und 2634 gleich.</i>  <i>Der gleiche Fehler tritt auf, wenn wir 7 statt 2 drücken, statt 3 8 drücken und so weiter.</i> <i><br><br></i>  <i>3. Ansatz.</i>  <i>Ok, nehmen wir die Summe noch einmal, nur die Zahlen an geraden Stellen werden berücksichtigt ... dreimal.</i>  <i>Das heißt, der Code 1234565 ist gültig, da 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 + 5 = 50.</i> <i><br><br></i>  <i>Die beschriebene Methode ist zum Standard für die Berechnung der EAN13-Prüfsumme mit einigen Korrekturen geworden: Die Anzahl der Ziffern ist fest und gleich 13, wobei die 13. die gleiche Prüfsumme ist.</i>  <i>Die Zahlen an ungeraden Stellen werden dreimal gezählt, an geraden einmal.</i> <br><br><h2>  Fazit </h2><br>  Wie Sie sehen können, enthält selbst eine so einfache Sache wie ein Barcode viele interessante Dinge.  Übrigens, ein weiterer Life-Hack für diejenigen, die bis hierher gelesen haben - der Text unter dem Barcode (falls vorhanden) dupliziert seinen Inhalt vollständig.  Dies geschieht, damit der Bediener den unlesbaren Code manuell eingeben kann.  Um den Inhalt eines Barcodes herauszufinden, ist es normalerweise einfach - schauen Sie sich einfach den Text darunter an. <br><br>  Wie in den Kommentaren vorgeschlagen, ist der EAN-13-Code im Handel am beliebtesten, die Bitcodierung ist dort dieselbe, und diejenigen, die dies wünschen, können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Zeichenstruktur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">selbst sehen</a> . <br><br>  Wenn die Leser das Interesse nicht verloren haben, können Sie QR-Codes separat berücksichtigen. <br><br>  Vielen Dank für Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439604/">https://habr.com/ru/post/de439604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439594/index.html">Frühlingsanmerkungen: AOP Magic</a></li>
<li><a href="../de439596/index.html">Wie ich die Bildverarbeitung auf Android 15 Mal beschleunigt habe</a></li>
<li><a href="../de439598/index.html">Microsoft sprach über die Kosten für kostenpflichtigen Support für Windows 7</a></li>
<li><a href="../de439600/index.html">Finnland fasst vorläufige Versuchsergebnisse mit garantiertem Grundeinkommen zusammen</a></li>
<li><a href="../de439602/index.html">Ethik im digitalen Raum - die Grundregeln der internationalen digitalen Beziehungen</a></li>
<li><a href="../de439606/index.html">Pilotproduktion von Elektronik zum Mindestpreis</a></li>
<li><a href="../de439608/index.html">Moderne Religion: Was geben Google, Facebook, Amazon und Apple den Menschen?</a></li>
<li><a href="../de439610/index.html">Wie bei meinem Elektrofahrzeug Chevrolet Bolt wurden im Rahmen der Garantie zwei Batteriemodule ausgetauscht und das dritte überwacht</a></li>
<li><a href="../de439612/index.html">Robustes JavaScript: Jagd nach einem Mythos</a></li>
<li><a href="../de439614/index.html">Wie man eine gute Reparatur von einer schlechten unterscheidet oder wie wir in SRG eine Multithread-Java-Bibliothek aus dem Tomit-Parser erstellt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>