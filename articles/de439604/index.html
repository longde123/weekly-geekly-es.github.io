<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ü©Ô∏è üßñ üëáüèæ Wie ist der Barcode angeordnet? üòΩ üç† ‚úçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Ein moderner Mensch trifft jeden Tag auf Barcodes, ohne dar√ºber nachzudenken. Wenn wir Produkte im Supermarkt kaufen, werden deren Code...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ist der Barcode angeordnet?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439604/">  Hallo Habr! <br><br>  Ein moderner Mensch trifft jeden Tag auf Barcodes, ohne dar√ºber nachzudenken.  Wenn wir Produkte im Supermarkt kaufen, werden deren Codes mit Hilfe eines Barcodes genau gelesen.  Auch Pakete, Waren in Lagern und so weiter und so fort.  Allerdings wissen nur wenige, wie es wirklich funktioniert. <br><br>  Wie ist der Barcode angeordnet und was ist in diesem Bild codiert? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Versuchen wir es herauszufinden, gleichzeitig schreiben wir einen Decoder f√ºr solche Codes. <a name="habracut"></a><br><br><h2>  Einf√ºhrung </h2><br>  Die Verwendung von Barcodes hat eine lange Geschichte.  Die ersten Automatisierungsversuche begannen bereits in den 1950er Jahren, 1952 wurde ein Patent f√ºr einen Codeleser erteilt.  Der an der Sortierung der Waggons auf der Eisenbahn beteiligte Ingenieur wollte den Prozess vereinfachen.  Die Idee war offensichtlich - die Nummer mit Streifen zu codieren und sie mit Fotozellen zu lesen.  1962 wurden Codes offiziell zur Identifizierung von Autos auf der amerikanischen Eisenbahn ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KarTrak-</a> System) verwendet. 1968 wurde der Suchscheinwerfer durch einen Laserstrahl ersetzt, der die Genauigkeit erh√∂hte und die Gr√∂√üe des Leseger√§ts verringerte.  1973 erschien das Format ‚ÄûUniversal Product Code‚Äú, und 1974 wurde das erste Produkt mit einem Codescanner (Wrigleys Kaugummi sind die USA;) in einem Supermarkt verkauft.  1984 verwendete ein Drittel der Gesch√§fte Luftschlangen, aber in Russland wurden sie um die 90er Jahre verwendet. <br><br>  Es werden sehr viele verschiedene Codes f√ºr verschiedene Aufgaben verwendet, zum Beispiel kann die Sequenz ‚Äû12345678‚Äú auf diese Weise dargestellt werden (und das ist noch nicht alles): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Beginnen wir mit dem bitweisen Parsen.  Dar√ºber hinaus bezieht sich alles, was unten beschrieben wird, auf das Formular ‚ÄûCode-128‚Äú - einfach, weil sein Format recht einfach und unkompliziert ist.  Wer mit anderen Arten experimentieren m√∂chte, kann einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Generator</a> √∂ffnen und sich selbst davon √ºberzeugen. <br><br>  Auf den ersten Blick scheint der Barcode nur eine zuf√§llige Folge von Zeilen zu sein, tats√§chlich ist seine Struktur klar festgelegt: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Leerer Speicherplatz zur eindeutigen Identifizierung des Codeanfangs <br>  2 - Startsymbol.  F√ºr Code-128 sind 3 Optionen m√∂glich (A, B und C genannt): 11010000100, 11010010000 oder 11010011100, sie entsprechen verschiedenen Codetabellen (weitere Einzelheiten siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> ). <br>  3 - Eigentlich der Code, der die Daten enth√§lt, die wir brauchen <br>  4 - Pr√ºfsumme <br>  5 - Stoppsymbol.  F√ºr Code-128 ist dies 1100011101011. <br>  6 (1) - Leerraum. <br><br>  Nun dazu, wie Bits codiert werden.  Hier ist alles sehr einfach - wenn Sie die Breite der d√ºnnsten Linie als ‚Äû1‚Äú annehmen, gibt die Linie mit doppelter Breite den Code ‚Äû11‚Äú, ein dreifaches ‚Äû111‚Äú usw. an.  Der leere Raum ist nach dem gleichen Prinzip "0" oder "00" oder "000".  Wer m√∂chte, kann den Startcode im Bild vergleichen, um sicherzustellen, dass die Regel erf√ºllt ist. <br><br>  Jetzt k√∂nnen Sie mit der Programmierung beginnen. <br><br><h2>  Holen Sie sich die Bitfolge </h2><br>  Im Prinzip ist dies der schwierigste Teil, und nat√ºrlich kann er algorithmisch auf verschiedene Arten implementiert werden.  Ich bin mir nicht sicher, ob der folgende Algorithmus optimal ist, aber f√ºr eine Fallstudie reicht er v√∂llig aus. <br><br>  Laden Sie zun√§chst das Bild, dehnen Sie es in der Breite, ziehen Sie eine horizontale Linie von der Bildmitte, konvertieren Sie es in s / w und laden Sie es als Array. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Auf dem Barcode entspricht ‚Äû1‚Äú Schwarz und auf RGB dagegen 0, daher muss das Array invertiert werden.  Gleichzeitig berechnen wir den Durchschnittswert. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Wir starten das Programm, um sicherzustellen, dass der Barcode korrekt geladen ist: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Jetzt m√ºssen Sie die Breite eines "Bits" bestimmen.  Dazu markieren wir den Beginn der Startsequenz "1101" und zeichnen die Momente des √úbergangs des Graphen durch die Mittellinie auf. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Wir zeichnen nur die √úberg√§nge durch die Mitte auf, so dass der Code ‚Äû1101‚Äú als ‚Äû101‚Äú geschrieben wird. Dies reicht jedoch aus, um die Breite in Pixel zu ermitteln. <br><br>  Nun die eigentliche Dekodierung.  Wir finden den n√§chsten √úbergang durch die Mitte und bestimmen die Anzahl der Bits, die in das Intervall fallen.  Da die √úbereinstimmung nicht absolut ist (der Code kann leicht gekr√ºmmt oder gedehnt sein), verwenden wir die Rundung. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Ich bin mir nicht sicher, ob dies die beste Option ist. Vielleicht gibt es einen besseren Weg. Diejenigen, die dies w√ºnschen, k√∂nnen in die Kommentare schreiben. <br><br>  Wenn alles richtig gemacht wurde, erhalten wir ungef√§hr die folgende Reihenfolge der Ausgabe: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Dekodierung </h2><br>  Hier gibt es grunds√§tzlich keine Schwierigkeiten.  Zeichen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code-128</a> werden mit einem 11-Bit-Code codiert, der 3 Varianten (A, B und C) aufweist und entweder unterschiedliche Zeichencodierungen oder Zahlen von 00 bis 99 speichern kann. <br><br>  In unserem Fall ist der Beginn der Sequenz 11010010000, was ‚ÄûCode B‚Äú entspricht.  Es war furchtbar kaputt, alle Codes aus Wikipedia manuell einzugeben, daher wurde die Tabelle einfach aus dem Browser kopiert und auch in Python analysiert (Hinweis: Dies ist f√ºr die Produktion nicht erforderlich). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Jetzt bleibt das Einfachste.  Wir teilen unsere Bitfolge in Bl√∂cke mit 11 Zeichen auf: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Schlie√ülich bilden wir die Linie und zeigen sie auf dem Bildschirm an: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  Ich werde keine Antwort auf das geben, was in der Tabelle verschl√ºsselt ist. Lassen Sie es eine Hausaufgabe f√ºr die Leser sein (die Verwendung von vorgefertigten Programmen f√ºr Smartphones wird als Betrug betrachtet :). <br><br>  Der Code implementiert auch keine CRC-√úberpr√ºfung, diejenigen, die dies w√ºnschen, k√∂nnen dies selbst tun. <br><br>  Nat√ºrlich ist der Algorithmus nicht perfekt und wurde in einer halben Stunde geschrieben.  F√ºr professionellere Zwecke gibt es vorgefertigte Bibliotheken, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pyzbar</a> .  Code, der eine solche Bibliothek verwendet, ben√∂tigt nur 4 Zeilen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (Zuerst m√ºssen Sie die Bibliothek installieren, indem Sie den Befehl pip install pyzbar eingeben.) <br><br>  <b>Erg√§nzung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">vinograd19</a> schrieb in den Kommentaren zur CRC-Z√§hlung: <br><br>  <i>Die Geschichte der Pr√ºfziffer ist interessant.</i>  <i>Es entstand evolution√§r.</i> <i><br></i>  <i>Die Pr√ºfziffer wird ben√∂tigt, um eine fehlerhafte Dekodierung zu vermeiden.</i>  <i>Wenn der Barcode 1234 war und als 7234 erkannt wurde, ben√∂tigen Sie eine Validierung, die das Ersetzen von 1 durch 7 verhindert. Die Validierung ist m√∂glicherweise ungenau, sodass mindestens 90% der ung√ºltigen Zahlen im Voraus ermittelt werden.</i> <i><br><br></i>  <i>1. Ansatz: Nehmen wir einfach den Betrag.</i>  <i>Damit der Rest der Division durch 10 0 ist. Nun, das hei√üt, die ersten 12 Zeichen tragen eine Informationslast, und die letzte Ziffer wird so ausgew√§hlt, dass die Summe der Ziffern durch 10 geteilt wird. Dekodieren Sie die Sequenz. Wenn die Summe nicht durch 10 teilbar ist, bedeutet dies, dass Sie mit einem Fehler dekodiert haben und dies tun m√ºssen diesmal noch einmal.</i>  <i>Beispielsweise ist der Code 1234 g√ºltig.</i>  <i>1 + 2 + 3 + 4 = 10. Code 1216 ist ebenfalls g√ºltig, 1218 jedoch nicht.</i> <i><br><br></i>  <i>Dies vermeidet Probleme mit der Automatisierung.</i>  <i>Zum Zeitpunkt der Erstellung der Barcodes gab es jedoch einen Fallback in Form der Eingabe einer Zahl auf den Tasten.</i>  <i>Und es gibt einen schlechten Fall: Wenn Sie die Reihenfolge der beiden Ziffern √§ndern, √§ndert sich die Pr√ºfsumme nicht, und das ist schlecht.</i>  <i>Das hei√üt, wenn der Barcode 1234 als 2134 geh√§mmert wurde, konvergiert die Pr√ºfsumme, aber wir haben die falsche Nummer eingegeben.</i>  <i>Es stellt sich heraus, dass die falsche Reihenfolge der Zahlen h√§ufig vorkommt, wenn Sie schnell auf die Tasten klopfen.</i> <i><br><br></i>  <i>2. Ansatz.</i>  <i>Lassen Sie uns die Menge etwas komplizierter machen.</i>  <i>Damit werden die Zahlen an geraden Stellen zweimal ber√ºcksichtigt.</i>  <i>Wenn Sie dann die Reihenfolge √§ndern, konvergiert der Betrag definitiv nicht zum gew√ºnschten.</i>  <i>Beispielsweise ist Code 2364 g√ºltig (2 + 3 + 3 + 6 + 4 + 4 = 20) und Code 3264 ist ung√ºltig (3+ 2 + 2 + 6 + 4 + 4 = 19).</i>  <i>Aber hier war ein anderes schlechtes Beispiel f√ºr das Fahren.</i>  <i>Einige Tastaturen sind so angeordnet, dass zehn Ziffern in zwei Reihen angeordnet sind.</i>  <i>Die erste Zeile ist 12345 und darunter die zweite zweite Zeile 67890. Wenn Sie anstelle der Taste ‚Äû1‚Äú die Taste ‚Äû2‚Äú rechts dr√ºcken, verhindert die Pr√ºfsumme eine falsche Eingabe.</i>  <i>Wenn Sie jedoch anstelle der Taste ‚Äû1‚Äú die unten stehende Taste ‚Äû6‚Äú dr√ºcken, wird m√∂glicherweise keine Warnung ausgegeben.</i>  <i>Immerhin ist 6 = 1 + 5, und wenn diese Zahl bei der Berechnung der Pr√ºfsumme an einer geraden Stelle liegt, haben wir 2 * 6 = 2 * 1 + 2 * 5.</i>  <i>Das hei√üt, die Pr√ºfsumme wurde um genau 10 erh√∂ht, sodass sich die letzte Ziffer nicht ge√§ndert hat.</i>  <i>Beispielsweise sind die Pr√ºfsummen in den Codes 2134 und 2634 gleich.</i>  <i>Der gleiche Fehler tritt auf, wenn wir 7 statt 2 dr√ºcken, statt 3 8 dr√ºcken und so weiter.</i> <i><br><br></i>  <i>3. Ansatz.</i>  <i>Ok, nehmen wir die Summe noch einmal, nur die Zahlen an geraden Stellen werden ber√ºcksichtigt ... dreimal.</i>  <i>Das hei√üt, der Code 1234565 ist g√ºltig, da 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 + 5 = 50.</i> <i><br><br></i>  <i>Die beschriebene Methode ist zum Standard f√ºr die Berechnung der EAN13-Pr√ºfsumme mit einigen Korrekturen geworden: Die Anzahl der Ziffern ist fest und gleich 13, wobei die 13. die gleiche Pr√ºfsumme ist.</i>  <i>Die Zahlen an ungeraden Stellen werden dreimal gez√§hlt, an geraden einmal.</i> <br><br><h2>  Fazit </h2><br>  Wie Sie sehen k√∂nnen, enth√§lt selbst eine so einfache Sache wie ein Barcode viele interessante Dinge.  √úbrigens, ein weiterer Life-Hack f√ºr diejenigen, die bis hierher gelesen haben - der Text unter dem Barcode (falls vorhanden) dupliziert seinen Inhalt vollst√§ndig.  Dies geschieht, damit der Bediener den unlesbaren Code manuell eingeben kann.  Um den Inhalt eines Barcodes herauszufinden, ist es normalerweise einfach - schauen Sie sich einfach den Text darunter an. <br><br>  Wie in den Kommentaren vorgeschlagen, ist der EAN-13-Code im Handel am beliebtesten, die Bitcodierung ist dort dieselbe, und diejenigen, die dies w√ºnschen, k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Zeichenstruktur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">selbst sehen</a> . <br><br>  Wenn die Leser das Interesse nicht verloren haben, k√∂nnen Sie QR-Codes separat ber√ºcksichtigen. <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439604/">https://habr.com/ru/post/de439604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439594/index.html">Fr√ºhlingsanmerkungen: AOP Magic</a></li>
<li><a href="../de439596/index.html">Wie ich die Bildverarbeitung auf Android 15 Mal beschleunigt habe</a></li>
<li><a href="../de439598/index.html">Microsoft sprach √ºber die Kosten f√ºr kostenpflichtigen Support f√ºr Windows 7</a></li>
<li><a href="../de439600/index.html">Finnland fasst vorl√§ufige Versuchsergebnisse mit garantiertem Grundeinkommen zusammen</a></li>
<li><a href="../de439602/index.html">Ethik im digitalen Raum - die Grundregeln der internationalen digitalen Beziehungen</a></li>
<li><a href="../de439606/index.html">Pilotproduktion von Elektronik zum Mindestpreis</a></li>
<li><a href="../de439608/index.html">Moderne Religion: Was geben Google, Facebook, Amazon und Apple den Menschen?</a></li>
<li><a href="../de439610/index.html">Wie bei meinem Elektrofahrzeug Chevrolet Bolt wurden im Rahmen der Garantie zwei Batteriemodule ausgetauscht und das dritte √ºberwacht</a></li>
<li><a href="../de439612/index.html">Robustes JavaScript: Jagd nach einem Mythos</a></li>
<li><a href="../de439614/index.html">Wie man eine gute Reparatur von einer schlechten unterscheidet oder wie wir in SRG eine Multithread-Java-Bibliothek aus dem Tomit-Parser erstellt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>