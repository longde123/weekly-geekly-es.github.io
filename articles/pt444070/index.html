<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌮 👩🏻‍🎨 🔨 Desenvolvendo um hexapod a partir do zero (parte 4) - trajetórias e sequências matemáticas 👶🏼 ▶️ 🧑🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal! O desenvolvimento do hexapod foi um passo além. Desta vez, as trajetórias do movimento dos membros são implementadas e testadas - a próxi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvendo um hexapod a partir do zero (parte 4) - trajetórias e sequências matemáticas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444070/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ft/93/m5/ft93m5szh_bfaxkmnxialxpkoiu.png"></div><br>  Olá pessoal!  O desenvolvimento do hexapod foi um passo além.  Desta vez, as trajetórias do movimento dos membros são implementadas e testadas - a próxima parte da matemática do movimento.  Neste artigo, falarei sobre essas trajetórias e seqüências básicas de movimento.  Espero que seja interessante. <br><br>  <b>Etapas do desenvolvimento:</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1 - Design</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2 - montagem</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3 - Cinemática</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>Parte 4 - trajetórias e sequências matemáticas</b></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 5 - Eletrônica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 6 - transição para impressão 3D</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 7 - nova caixa, software aplicativo e protocolos de comunicação</a> <br><a name="habracut"></a><br><h2>  Trajetórias </h2><br>  A essência desse mecanismo é que, quando você define dois pontos, pode escolher a trajetória do membro.  Ao passar de um ponto para outro, as coordenadas mudam de acordo com certas equações paramétricas.  O mecanismo acabou por ser bastante poderoso e permite obter curvas interessantes para o movimento.  Ele também implementa a suavização dos movimentos, alterando a etapa do parâmetro t - quanto menor a etapa, mais pontos intermediários haverá, menor a velocidade e maior a suavidade do movimento. <br><br>  O procedimento para definir parâmetros de trajetória em alguns lugares é um pouco incompreensível e você pode ficar confuso.  A dificuldade reside no fato de que, ao definir as coordenadas dos pontos inicial e final, as coordenadas dos pontos reais no espaço nem sempre são definidas, ou seja,  algumas coordenadas definem os parâmetros de trajetória.  Eu tive que escrever um programa que exibisse um determinado caminho e, ao mesmo tempo, verifique a acessibilidade de cada ponto do caminho. <br><br>  O driver suporta os seguintes caminhos de movimento: <br><br><ol><li>  <b>XYZ_LINAR</b> é a mais simples de todas as trajetórias.  A trajetória é usada quando se move para frente, para trás, para cima e para baixo.  Todas as coordenadas mudam linearmente e são calculadas da seguinte maneira: <br><br><pre><code class="cpp hljs">x = t * (x1 - x0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + x0; y = t * (y1 - y0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + y0; z = t * (z1 - z0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + z0;</code> </pre> <br>  Aqui entendemos que não há problemas.  As coordenadas especificam os ângulos paralelepípedos e coincidem com as coordenadas reais.  O movimento ocorre ao longo da diagonal da caixa. <br><br><div class="spoiler">  <b class="spoiler_title">Visualização de trajetória</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t5/55/uy/t555uy9zum9cfwqa6hw4gwotdni.png"><br><img src="https://habrastorage.org/webt/bn/2n/p-/bn2np-sm7n7onhmvariez7_0jy4.png"><br><img src="https://habrastorage.org/webt/5p/g6/yw/5pg6yw_fpcqdxnr4lotb-n0so4u.png"><br></div></div><br></li><li>  <b>YZ_ARC_Y_LINEAR</b> - essa trajetória permite implementar o movimento ao longo de um arco.  A trajetória é usada ao girar, quando você precisa mover um membro no chão.  As coordenadas são calculadas da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// Circle Y y = t * (y1 - y0) / 180.0f + y0; z = R * cos(t_mapped_rad); // Circle X</span></span></code> </pre><br>  É aqui que a diversão começa.  As coordenadas especificam a direção dos raios para limitar o arco e podem não coincidir com as coordenadas reais.  Os raios estão no mesmo plano, enquanto o raio do círculo é igual ao comprimento do vetor até o ponto inicial. <br><br><div class="spoiler">  <b class="spoiler_title">Visualização de trajetória</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ky/p0/dw/kyp0dwzfg-0t_qsrmwvstiwlweq.png"><br><br><img src="https://habrastorage.org/webt/ak/ng/ey/akngeyx2imiyht44jebbuydxyaw.png"><br></div></div><br></li><li>  <b>XZ_ARC_Y_SINUS</b> - essa trajetória também permite implementar o movimento ao longo de um arco, mas mais complexo que YZ_ARC_Y_LINEAR.  A trajetória é usada ao girar, quando você precisa mover um membro pelo ar.  As coordenadas são calculadas da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// circle Y y = (y1 - y0) * sin(DEG_TO_RAD(t)) + y0; z = R * cos(t_mapped_rad); // circle X</span></span></code> </pre><br>  A diversão continua.  As coordenadas também especificam a direção dos raios para limitar o arco, mas NÃO coincidem com as coordenadas reais.  A coordenada Y do ponto de destino define a altura do seno. <br><br><div class="spoiler">  <b class="spoiler_title">Visualização de trajetória</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t6/2g/tf/t62gtfnlk7nwgibcchhawz2ug4e.png"><br></div></div><br></li><li>  <b>XZ_ELLIPTICAL_Y_SINUS</b> - essa trajetória permite implementar o movimento ao longo de uma elipse.  A trajetória é usada quando se move para frente e para trás, quando você precisa mover um membro pelo ar.  Essa trajetória é uma complicação do XZ_ARC_Y_SINUS e foi necessária apenas devido à marcha visualmente feia ao usar o XZ_ARC_Y_SINUS (pernas estendidas demais).  As coordenadas são calculadas da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = (z1 - z0) / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = (x1 - x0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = (y1 - y0); x = b * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(DEG_TO_RAD(<span class="hljs-number"><span class="hljs-number">180.0f</span></span> - t)) + x0; <span class="hljs-comment"><span class="hljs-comment">// circle Y y = c * sin(DEG_TO_RAD(t)) + y0; z = a * cos(DEG_TO_RAD(180.0f - t)) + z0 + a;</span></span></code> </pre><br>  As coordenadas especificam os ângulos paralelepípedos e NÃO coincidem com as coordenadas reais.  O movimento ocorre nos cantos inferiores da caixa, localizados no mesmo plano em que tocam a parte superior da peça.  É melhor olhar para a foto no spoiler, não sei como descrevê-la brevemente em palavras. <br><br><div class="spoiler">  <b class="spoiler_title">Visualização de trajetória</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pn/3x/4w/pn3x4wot6ajk1ofy4wl7rtjyp1y.png"><br></div></div></li></ol><br>  Isso completa a matemática básica do movimento do hexápode.  No meu projeto, este é um mínimo necessário para a implementação de quase qualquer movimento. <br><br><h2>  Sequências </h2><br><h3>  Pouco de teoria </h3><br>  Sequências são as ações elementares que compõem a marcha.  Eles são divididos em cíclicos e não cíclicos. <br><br><ul><li>  Sequências cíclicas podem ser realizadas várias vezes e, ao final de cada ciclo, os membros devem retornar à sua posição original (movimento e rotação); </li><li>  Sequências não cíclicas são realizadas apenas uma vez (subida e descida); </li></ul><br>  Cada sequência possui três blocos de iteração: bloco de preparação, bloco principal, bloco de conclusão. <br><br><ul><li>  Bloco de treinamento - contém iterações para mover os membros para a posição inicial da sequência.  No meu caso, avançar exige colocar as pernas em uma certa posição antes de começar a se mover.  É executado uma vez após a transição para a sequência; </li><li>  Bloco principal - contém a iteração principal da sequência.  Pode ser realizado ciclicamente; </li><li>  Conclusão do bloco - contém iterações para mover os membros para a posição base (a posição na qual os membros são definidos após o levantamento); </li></ul><br>  A figura abaixo mostra a sequência para avançar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yt/yf/vw/ytyfvwd1slowqjmordig0qenioa.png"></div><br><ul><li>  Pontos vermelhos indicam a posição inicial dos membros antes de começar a se mover </li><li>  Linhas azuis indicam as trajetórias do membro no chão </li><li>  As linhas pretas indicam as trajetórias do membro no ar </li><li>  As setas indicam a sequência </li></ul><br>  As coordenadas dos pontos são selecionadas com base na configuração da caixa.  Escolhi os pontos o mais próximo possível do corpo para reduzir o comprimento da alavanca.  Em um ciclo da sequência, o hexápode se move 18 cm (em 1 ciclo, são executados 2 passos - 1 passo em 3 membros).  Se você aumentar a distância, os membros começarão a se agarrar.  Este parâmetro é limitado apenas pela configuração do caso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/67/hs/0b/67hs0bhvmyfefjvvxyb0qh0lojy.png"></div><br>  A sequência é definida por dois pontos (1, 2) para cada membro e são utilizados dois caminhos: XYZ_LINEAR (linhas azuis) e XZ_ELLIPTICAL_Y_SINUS (linhas pretas).  O ponto 1 é usado pelo caminho XZ_ELLIPTICAL_Y_SINUS para definir a altura do seno e, consequentemente, a altura em que a perna subirá.  Os pontos 2 e 3 são pontos reais que um membro atinge ao se mover. <br><br>  A localização dos pontos depende apenas da sua imaginação e das capacidades do hexapod.  Talvez tudo tenha sido um pouco complicado e exista uma opção mais simples, mas, aparentemente, ainda não o alcancei. <br><br><h3>  Implementação </h3><br>  Agora vamos dar uma olhada na implementação de toda essa felicidade.  Estruturas com parâmetros de sequência são as seguintes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">point_3d_t</span></span> point_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">path_type_t</span></span> path_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> smooth_point_count; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_sequence_looped; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> main_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> finalize_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> total_iteration_count; <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span> iteration_list[<span class="hljs-number"><span class="hljs-number">15</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">sequence_id_t</span></span> available_sequences[SUPPORT_SEQUENCE_COUNT]; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_info_t</span></span>;</code> </pre> <br>  <b>sequence_iteration_t</b> - contém informações sobre a iteração da sequência: <br><br><ul><li>  point_list - uma matriz de pontos para cada membro no formato XYZ; </li><li>  path_list - uma matriz de trajetórias para cada membro; </li><li>  smooth_point_count - define o número de pontos do caminho (etapa do parâmetro t); </li></ul><br>  <b>sequence_info_t</b> - contém informações sobre toda a sequência: <br><br><ul><li>  is_sequence_looped - define o tipo de sequência: cíclica ou não; </li><li>  main_sequence_begin - define o índice inicial do bloco principal na matriz iteration_list; </li><li>  finalize_sequence_begin - define o índice inicial do bloco de conclusão na matriz iteration_list; </li><li>  total_iteration_count - define o número de iterações na sequência; </li><li>  iteration_list - uma matriz de iterações; </li><li>  available_sequences - define a lista de seqüências disponíveis para a transição da atual (por exemplo, não podemos começar a andar sem nos levantar do chão); </li></ul><br>  <i>NOTA: O índice do bloco de preparação não é intencionalmente indicado; ele está sempre localizado no início da matriz de iteração.</i> <i><br></i> <br>  Infelizmente, não consigo imaginar o código de definição de sequência aqui, porque  é bastante largo e parece terrível após as transferências.  Acabei de deixar um link para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">arquivo de definição</a> aqui. <br><br><h3>  Esquema de processamento de movimento </h3><br>  Vale a pena distinguir todos os círculos do inferno pelos quais a sequência passa em tempo de execução.  O esquema de processamento é o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hz/bd/h-/hzbdh-sihkvi9t9lmxn73igosv8.png"></div><br><ol><li>  <b>MOTOR DE MOVIMENTO</b> - organiza o processamento e a alternância entre seqüências.  Nenhum cálculo é realizado lá.  Se simplificado, este módulo desliza o próximo ponto para o módulo LIBMS DRIVER após a conclusão do processamento atual. <br>  <i>Entrada do módulo: matriz de coordenadas dos pontos de destino.</i> <i><br></i>  <i>Saída do módulo: ponto de destino para a iteração atual da sequência.</i> </li><li>  <b>O LIBMS DRIVER</b> é o mais complexo de todos os módulos.  Toda a matemática do movimento reina aqui: cinemática inversa, cálculos de trajetória e suavização de movimentos.  Este módulo possui uma sincronização estrita com o módulo PWM.  Os cálculos são realizados com uma frequência de 150Hz, respectivamente, o pulso de controle para os inversores também é fornecido com uma frequência de 150Hz. <br>  <i>Entrada do módulo: coordenadas do ponto de destino.</i> <i><br></i>  <i>Saída do módulo: ângulos de rotação do servo.</i> </li><li>  <b>MOTORISTA DO SERVO</b> .  Não há nada de especial nele, exceto vários parâmetros para instalar e ajustar os inversores. <br>  <i>Entrada do módulo: ângulos de rotação do servo.</i> <i><br></i>  <i>Saída do módulo: controle a largura do pulso.</i> </li><li>  <b>EXCITADOR DE PWM</b> .  Software de driver PWM para controle de unidade.  Aqui os pinos apenas se contraem no momento certo.  A variável de sincronização sincronizada do PWM é incrementada a cada período do PWM. <br>  <i>Entrada do módulo: controle a largura do pulso.</i> <i><br></i>  <i>Saída do módulo: pulsos nos pinos de controle.</i> </li></ol><br>  Tentei tornar os módulos independentes um do outro e consegui.  Isso permite inserir neste circuito qualquer módulo intermediário (por exemplo, o módulo de adaptação à paisagem) e nada será interrompido ao mesmo tempo, enquanto a implementação ocorrerá com alterações mínimas no código. <br><br><h2>  Últimas notícias e lagostins do projeto encontrados </h2><br><div class="spoiler">  <b class="spoiler_title">Últimas notícias</b> <div class="spoiler_text"><ol><li>  Saiu uma nova versão de teste do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">arquivo (arquivo com desenhos)</a> e eu pintei um pouco.  A montagem completa do hexapod com os bicos de acionamento na posição central leva de 7 a 8 horas de montagem contínua, e isso leva em consideração que eu já realizei esse procedimento mais de uma vez. <br><br><div class="spoiler">  <b class="spoiler_title">Fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/ux/k0/rjuxk0f6rfsfinjvlr9j8elgpna.jpeg"><br><br><img src="https://habrastorage.org/webt/53/nk/it/53nkit0njb3bc_tslbr8ql2utwe.jpeg"><br><br><img src="https://habrastorage.org/webt/1p/kj/cs/1pkjcsdujiutmq5ueqgtaeqjvxk.jpeg"><br><br><img src="https://habrastorage.org/webt/yw/ll/_0/ywll_0aat4jlvvx-ayq1byjbkz0.jpeg"><br></div></div></li><li>  Coloquei um display OLED nele para exibir algum tipo de informação, que acabou bem. <br><div class="spoiler">  <b class="spoiler_title">Fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gf/g8/q1/gfg8q1mn_1brvu8vlbl84uj2d4s.jpeg"><br><br><img src="https://habrastorage.org/webt/pb/6n/gl/pb6ngln4uduzi3ivvdea5bda4gs.jpeg"><br></div></div></li><li>  Comunicação iniciada via WIFI.  Agora é controlado pelo telefone (a ferramenta teve que escrever a sua própria) </li><li>  Tensão de alimentação reduzida de 12V para 7V devido a problemas com superaquecimento da placa de alimentação </li><li>  No lançamento da parte 5 do desenvolvimento, publicarei um link para as fontes, que finalmente adquiriram um estado em que não têm vergonha de mostrar às pessoas </li></ol><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Lagostins encontrados</b> <div class="spoiler_text"><ol><li>  HC-SR04.  Eu sabia que esse sensor estava com defeito, mas acho que não.  Em geral, você precisa de um parâmetro diferente </li><li>  O MG996R não atende às especificações declaradas.  Eles prometeram 12 kg \ cm - na verdade 5 kg \ cm no PWM com uma frequência de 300Hz, a 50Hz foi ainda pior e, além disso, eles se tornaram analógicos (prometeram uma figura).  Adequado apenas para voltas.  Eu tive que mudar para unidades digitais DS3218 mais caras a 20 kg / cm - de fato 23 kg / cm </li><li>  Compilei uma tabela de momento-ângulo a cada 10 graus e notei que as larguras de pulso de controle para o MG996R estão a distâncias diferentes uma da outra.  Eu tive que fazer tabelas de calibração para cada unidade e calcular o impulso individualmente. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/9e/my/ez9emybwzomnlc0vxeslvl0l_im.png"></div><br>  Como você pode ver, o tom de pulso de cada unidade é diferente, foi uma descoberta inesperada para mim. </li><li>  Os valores mínimo, máximo e central do impulso diferem devido aos bicos dos acionamentos (o que quer que se possa dizer, ainda não é suave).  A figura mostra os inversores nos quais o pulso 1500us é aplicado e pode ser visto que um bico não está no centro e, portanto, é necessário ajustar o pulso para que todos os bocais estejam na mesma posição. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/md/bs/qvmdbsnasfavacafddclxdbug4o.jpeg"></div><br></li></ol><br>  A propósito, fiz a calibração usando este dispositivo: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/vx/de/pbvxdeg2clwcwtnh3ynnb9zg-d8.jpeg"></div><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444070/">https://habr.com/ru/post/pt444070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444058/index.html">Quando as crianças entendem que toda a sua vida já está online</a></li>
<li><a href="../pt444060/index.html">Migrando de Nagios para Icinga2 na Austrália</a></li>
<li><a href="../pt444062/index.html">Acenda! Transformações noturnas do Centro Lakhta</a></li>
<li><a href="../pt444064/index.html">Novas idéias para um novo futuro</a></li>
<li><a href="../pt444068/index.html">Quem está assistindo?</a></li>
<li><a href="../pt444072/index.html">Android Shopping - Play Billing Library</a></li>
<li><a href="../pt444074/index.html">Internet das Coisas: Quatro Histórias de Tecnologia</a></li>
<li><a href="../pt444076/index.html">Como eu tentei derrotar o TP4056</a></li>
<li><a href="../pt444078/index.html">Kernel Linux 5.1 - o que se sabe sobre as mudanças</a></li>
<li><a href="../pt444082/index.html">O resumo de materiais interessantes para o desenvolvedor de dispositivos móveis # 290 (11 a 17 de março)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>