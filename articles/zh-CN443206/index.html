<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😇 😲 🤾🏾 性能不佳的地雷正在等待 🏻 ❣️ 🚅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将讨论埋设在地雷下的地雷，以及地雷的探测（最好是在爆炸前）和处置。 
 图片引起关注 


 什么是地雷？ 


 让我们从任何知识的源头开始-具有定义。 古人说，正确命名意味着正确理解。 我认为最好通过对比一个明显的错误来表述表现良好的地雷，例如： 


String concat(S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>性能不佳的地雷正在等待</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443206/"><p> 在本文中，我将讨论埋设在地雷下的地雷，以及地雷的探测（最好是在爆炸前）和处置。 </p><br><div class="spoiler">  <b class="spoiler_title">图片引起关注</b> <div class="spoiler_text"><p><img src="https://ic.pics.livejournal.com/ivagkin/26880913/58954/58954_original.jpg" alt="图片"></p></div></div><a name="habracut"></a><br><h4 id="chto-takoe-mina"> 什么是地雷？ </h4><br><p> 让我们从任何知识的源头开始-具有定义。 古人说，正确命名意味着正确理解。 我认为最好通过对比一个明显的错误来表述表现良好的地雷，例如： </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... strings)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : strings) { result += str; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 即使是新手开发人员也知道这些行是不可变的，并且将它们粘合成一个循环并不意味着将数据添加到现有行的尾部，而是每次通过都会创建一条<strong>新</strong>行。 如果您弄错了，请不要气--“想法”会立即警告您危险，而“声纳”肯定会淹没您的组件。 </p><br><p> 但是此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a>将吸引较少的关注，并且Idea（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2018.2之前的版本</a> ）将保持沉默： </p><br><pre> <code class="java hljs">Long total = <span class="hljs-number"><span class="hljs-number">0L</span></span>; List&lt;Long&gt; totals = query.getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long element : totals) { total += element == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : element; }</code> </pre> <br><p> 这里的问题是相同的：简单类型的包装器是不可变的，这意味着在对象编号中添加5个单位意味着创建一个新包装器并将6写入其中。 </p><br><p> 这里的笑话是在Java中存在两种表示某些类型的数据的表示形式-简单和对象，以及它们通过语言本身的自动转换。 因此，许多新手开发人员都会这样思考：“好吧，执行以某种方式将它们本身转化为一个数字。” </p><br><p> 实际上，并非一切都那么简单。 进行<a href="">基准测试</a>并尝试以指定的方式添加数字： </p><br><div class="spoiler">  <b class="spoiler_title">突然，它变得非常非常便宜（以下是JDK 11，除非另有明确说明）</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> (size) Mode Cnt Score Error Units wrapper 10 avgt 100 23,5 ± 0,1 ns/op wrapper 100 avgt 100 352,3 ± 2,1 ns/op wrapper 1000 avgt 100 4424,5 ± 25,2 ns/op wrapper 10 avgt 100 0 ± 0 B/op wrapper 100 avgt 100 1872 ± 0 B/op wrapper 1000 avgt 100 23472 ± 0 B/op</code> </pre> <br><p> 与简单类型进行比较： </p><br><pre> <code class="plaintext hljs">primitive 10 avgt 100 6,4 ± 0,0 ns/op primitive 100 avgt 100 39,8 ± 0,1 ns/op primitive 1000 avgt 100 252,5 ± 1,3 ns/op primitive 10 avgt 100 0 ± 0 B/op primitive 100 avgt 100 0 ± 0 B/op primitive 1000 avgt 100 0 ± 0 B/op</code> </pre> </div></div><br><p> 从这里我们可以得出性能欠佳的地雷的定义之一-该代码无法吸引眼球，也无法被静态分析器检测到（至少在您遇到它时），但是在某些用途中它会减慢速度。 在我们的示例中，从缓存中获取的对象总数不超过127，而<code>Long</code>仅比<code>long</code>慢4倍。 但是，对于大小为100的数组，速度几乎要低10倍。 </p><br><h4 id="bolshie-melochi"> 大件小事 </h4><br><p> 有时，在<em>几乎</em>没有改变执行含义的情况下进行小的更改，在<em>某些</em>情况下会成为一个重大障碍。 </p><br><p> 假设我们有一个代码： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); if (info == null) { info = getAlias.apply(alias); cache.put(alias, info); } return info; }</span></span></code> </pre> <br><p> 方法逻辑是什么样的？ </p><br><div class="spoiler">  <b class="spoiler_title">不要急着间谍，想想</b> <div class="spoiler_text"><p> 这是<code>ConcurrentHashMap::computeIfAbsent</code> ！ </p></div></div><br><p> 我们拥有“八”字，我们可以轻松地改进代码：用1替换6行，使代码更短，更易于理解。 顺便说一下，多线程专家们可能会指出<code>ConcurrentHashMap::computeIfAbsent</code>带来的另一项改进，但<code>ConcurrentHashMap::computeIfAbsent</code>会有所改进；） </p><br><p> 让我们实现一个伟大的想法： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { return cache.computeIfAbsent(alias, getAlias); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">聚集，开始，哭泣</b> <div class="spoiler_text"><p> 要查看完整尺寸，请右键单击图片，然后选择“在新标签页中打开图像” <br><img src="https://habrastorage.org/getpro/habr/post_images/9f0/2aa/0e0/9f02aa0e028903e85a63d08207d93509.png" alt="图片"></p></div></div><br><p> 当应用程序使用一个线程时，一切都差不多。 流变得越来越多，变得越来越差。  <code>ConcurrentHashMap::computeIfAbsent</code>证明， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">即使<strong>已将</strong>密钥添加到字典中</a> ， <code>ConcurrentHashMap::computeIfAbsent</code>被阻止。 这就是Spring Date Mongo中出现大量<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误</a>的原因。 </p><br><p> 您可以通过简单的<a href="">测量</a> （“八”）进行验证。 这是他的结论： </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 19,405 ± 0,411 ns/op getAndPut avgt 20 4,578 ± 0,045 ns/op 2 threads computeIfAbsent avgt 20 66,492 ± 2,036 ns/op getAndPut avgt 20 4,454 ± 0,110 ns/op 4 threads computeIfAbsent avgt 20 155,975 ± 8,850 ns/op getAndPut avgt 20 5,616 ± 2,073 ns/op 6 threads computeIfAbsent avgt 20 203,188 ± 10,547 ns/op getAndPut avgt 20 7,024 ± 0,456 ns/op 8 threads computeIfAbsent avgt 20 302,036 ± 31,702 ns/op getAndPut avgt 20 7,990 ± 0,144 ns/op</code> </pre> <br><p> 开发人员可以明确地认为这是一个错误吗？ 以我的拙见，不，不。 该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文件</a>说： </p><br><blockquote> 在计算进行期间，可能会阻止其他线程在此映射上进行的某些尝试的更新操作，因此计算应简短而简单，并且不得尝试更新此映射的任何其他映射 </blockquote><p> 换句话说， <code>ConcurrentHashMap::computeIfAbsent</code>关闭包含来自外界的键的单元格（与<code>ConcurrentHashMap::get</code>不同），这通常是正确的，因为当尚未添加键时，它允许您从不同的线程调用方法时躲避竞争。 </p><br><p> 另一方面，在最常见的操作模式中，值的计算及其与键的绑定仅在第一次调用时发生，而所有后续调用仅返回先前计算的值。 因此，有意义的是更改逻辑，以便仅在更改时设置锁定。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">它是在这里做的</a> 。 </p><br><p> 在较新的版本（&gt; 8）中， <code>ConcurrentHashMap::computeIfAbsent</code>变得<code>ConcurrentHashMap::computeIfAbsent</code> ： </p><br><pre> <code class="plaintext hljs">JDK 11 Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 6,983 ± 0,066 ns/op getAndPut avgt 20 5,291 ± 1,220 ns/op 2 threads computeIfAbsent avgt 20 7,173 ± 0,249 ns/op getAndPut avgt 20 5,118 ± 0,395 ns/op 4 threads computeIfAbsent avgt 20 7,991 ± 0,447 ns/op getAndPut avgt 20 5,270 ± 0,366 ns/op 6 threads computeIfAbsent avgt 20 11,919 ± 0,865 ns/op getAndPut avgt 20 7,249 ± 0,199 ns/op 8 threads computeIfAbsent avgt 20 14,360 ± 0,892 ns/op getAndPut avgt 20 8,511 ± 0,229 ns/op</code> </pre> <br><p> 请注意此示例的阴险之处：语义内容<em>并</em>没有太大变化，因为乍一看我们只是使用了更高级的语法。 同时，当应用程序在一个线程中运行时，用户几乎感觉不到差异！ 这看似无害的变化 <del> 猪 </del> 我的表现。 </p><br><div class="spoiler">  <b class="spoiler_title">为什么我写“几乎不变”</b> <div class="spoiler_text"><p>  <code>ConcurrentHashMap::computeIfAbsent</code>并不总是可以与<code>getAndPut</code>表达式互换，因为<code>ConcurrentHashMap::computeIfAbsent</code>是原子操作。 用相同的代码 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { info = getAlias.apply(alias); cache.put(alias, info); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; }</code> </pre> <br><p> 由于缺乏外部同步<strong>，种族出现了</strong> 。 如果传递给给定键的<code>ConcurrentHashMap::computeIfAbsent</code>函数始终返回相同的值，则这是一个“安全”的竞争，我们面临的最大<code>ConcurrentHashMap::computeIfAbsent</code>是两次或更多次计算相同的值。 如果没有这样的保证，那么机械更换将困扰着应用的崩溃。 小心点！ </p></div></div><br><h4 id="eti-ruki-nichego-ne-menyali"> 这些手什么都没变 </h4><br><p> 也有可能代码根本没有改变，但是突然它开始变慢了。 </p><br><p> 想象一下，我们面临着将数组元素转移到集合中的任务。 最合乎逻辑的方法是使用现成的<code>Collection::addAll</code> ，但这很不幸-它接受该集合： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span></span>; }</code> </pre> <br><p> 最简单的方法是将数组包装在<code>Arrays::asList</code> 。 结果会是 </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.addAll(Arrays.asList(items)); }</code> </pre> <br><p> 在校对期间，注重性能的同事可能会告诉我们，此代码同时存在两个问题： </p><br><ul><li> 将数组包装在列表中（额外对象） </li><li> 创建一个迭代器（另一个额外的对象）并传递给它 </li></ul><br><p> 实际上，在<code>Collection::addAll</code>的参考实现中，我们将看到以下内容： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> modified = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : c) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (add(e)) modified = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; } }</code> </pre> <br><p> 因此，这里创建了一个迭代器，并使用它对元素进行了排序。 因此，有经验的同志提供他们的解决方案： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p> 在代码内部， <em>看起来似乎</em>更有生产力： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T element : elements) result |= c.add(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 首先，不创建迭代器。 其次，该过程按通常的计数周期进行，此外，数组非常适合高速缓存，其元素顺序位于内存中（这意味着几乎没有高速缓存未命中），并且通过索引访问它们非常快。 好了，也不创建包装列表。 听起来不错。 </p><br><p> 最后，同事们引用了最后通行比例规定：文件。 那里，白色的灰色（或黑色的绿色）表示： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ... * The behavior of this convenience method is identical to that of * c.addAll(Arrays.asList(elements)), but this method is likely * to run significantly faster under most implementations. &lt;---- * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.5 */</span></span> <span class="hljs-meta"><span class="hljs-meta">@SafeVarargs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p> 也就是说，开发人员自己（如果不是，他们应该相信谁？）写道，对于大多数实现而言，实用程序方法的运行速度<em>要</em>快得多。 而且他真的更快。 有时候 </p><br><p> 我们将在G8上针对<code>HashSet</code>推出的<a href="">基准测试</a>将有助于<code>HashSet</code> ： </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 155,2 ± 2,8 ns/op addAll HashSet 100 avgt 100 1884,4 ± 37,4 ns/op addAll HashSet 1000 avgt 100 17917,3 ± 298,8 ns/op collectionsAddAll HashSet 10 avgt 100 136,1 ± 0,8 ns/op collectionsAddAll HashSet 100 avgt 100 1538,3 ± 31,4 ns/op collectionsAddAll HashSet 1000 avgt 100 15168,6 ± 289,4 ns/op</code> </pre> <br><p> 看来更有经验的同志是对的。 差不多了 </p><br><p> 在更高版本中（例如，在11中），实用程序方法的辉煌将逐渐消失： </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 143,1 ± 0,6 ns/op addAll HashSet 100 avgt 100 1738,4 ± 7,3 ns/op addAll HashSet 1000 avgt 100 16853,9 ± 101,0 ns/op collectionsAddAll HashSet 10 avgt 100 132,1 ± 1,1 ns/op collectionsAddAll HashSet 100 avgt 100 1661,1 ± 7,1 ns/op collectionsAddAll HashSet 1000 avgt 100 15450,9 ± 93,9 ns/op</code> </pre> <br><p> 可以看出，我们没有在谈论任何“快得多”的问题。 而且，如果我们对<code>ArrayList</code> -a重复该实验，那么结果发现实用程序方法开始损失很多（越强大）： </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units JDK 8 addAll ArrayList 10 avgt 100 38,5 ± 0,5 ns/op addAll ArrayList 100 avgt 100 188,4 ± 7,0 ns/op addAll ArrayList 1000 avgt 100 1278,8 ± 42,9 ns/op collectionsAddAll ArrayList 10 avgt 100 62,7 ± 0,7 ns/op collectionsAddAll ArrayList 100 avgt 100 495,1 ± 2,0 ns/op collectionsAddAll ArrayList 1000 avgt 100 4892,5 ± 48,0 ns/op JDK 11 addAll ArrayList 10 avgt 100 26,1 ± 0,0 ns/op addAll ArrayList 100 avgt 100 161,1 ± 0,4 ns/op addAll ArrayList 1000 avgt 100 1276,7 ± 3,7 ns/op collectionsAddAll ArrayList 10 avgt 100 41,6 ± 0,0 ns/op collectionsAddAll ArrayList 100 avgt 100 492,6 ± 1,5 ns/op collectionsAddAll ArrayList 1000 avgt 100 6792,7 ± 165,5 ns/op</code> </pre> <br><p> 这里没有什么意外的， <code>ArrayList</code>围绕数组构建的，因此开发人员具有远见地重新定义了<code>Collection::addAll</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ Object[] a = c.toArray(); modCount++; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numNew = a.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Object[] elementData; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew &gt; (elementData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData).length - (s = size)) elementData = grow(s + numNew); System.arraycopy(a, <span class="hljs-number"><span class="hljs-number">0</span></span>, elementData, s, numNew); &lt;---    size = s + numNew; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p> 现在回到我们的地雷。 假设我们仍然接受了校对中提出的解决方案，并保留了以下代码： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p> 暂时一切都很好，但是在添加了新功能之后，该方法有时会变得很热并且开始变慢。 我们开放源代码-代码未更改。 数据量是相同的。 而且性能下降了很多。 这是我的另一种类型。 </p><br><p> 发现调试器并找到漂亮的： </p><br><p><img src="https://habrastorage.org/webt/nw/og/mu/nwogmu0_mvl-ix_hdyoxdaoydik.png"></p><br><p> 请注意：我们没有改变算法，处理的数据量没有改变，但是它们的性质改变了，并且在我们的代码中出现了性能问题： </p><br><pre> <code class="plaintext hljs"> Java 8 Java 11  addAll 10 56,9 25,2 ns/op collectionsAddAll 10 352,2 142,9 ns/op addAll 100 159,9 84,3 ns/op collectionsAddAll 100 4607,1 3964,3 ns/op addAll 1000 1244,2 760,2 ns/op collectionsAddAll 1000 355796,9 364677,0 ns/op</code> </pre> <br><p> 在大型数组上， <code>Collections::addAll</code>和<code>Collection::addAll</code>之间的<code>Collection::addAll</code>只有500倍。 事实是， <code>COWList</code>不仅会扩展现有数组，还会在每次添加元素时创建一个新数组： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (lock) { Object[] es = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = es.length; es = Arrays.copyOf(es, len + <span class="hljs-number"><span class="hljs-number">1</span></span>); &lt;----    es[len] = e; setArray(es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p><del> 谁该怪？ </del></p><br><div class="spoiler">  <b class="spoiler_title">怎么办</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://bugs.openjdk.java.net/browse/JDK-8193031</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://cr.openjdk.java.net/~martin/webrevs/jdk/Collections-addAll/</a> </p></div></div><br><p> 这里的主要问题是<code>Collections::addAll</code>接受一个接口，而<code>addAll</code>方法没有主体。 没有内容-没有业务，因此，文档基于<code>AbstractCollection::addAll</code>存在的实现<code>AbstractCollection::addAll</code> ，这是适用于所有集合的通用算法。 这意味着处于较低抽象级别的数据结构的更具体的实现可以更改此行为。 </p><br><div class="spoiler">  <b class="spoiler_title">现在人类</b> <div class="spoiler_text"><pre> <code class="java hljs"> Collection::addAll –   AbstractCollection::addAll –   &lt;---    ArrayList::addAll HashSet::addAll –   &lt;---      COWList::addAll</code> </pre> </div></div><br><h4 id="eschyo-ob-abstrakciyah"> 有关抽象的更多信息 </h4><br><p> 由于我们在谈论抽象的层次，因此我将向您介绍生活中的一个例子。 </p><br><p> 让我们比较一下这两种在数据库中保存第n个实体的方式： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p> 乍一看，这两种方法的性能不应有很大差异，因为 </p><br><ul><li> 在两种情况下，相同数量的实体将存储在数据库中 </li><li> 如果密钥是从序列中获取的，则通话次数将相同 </li><li> 传输的数据量相同 </li></ul><br><p>  <code>SimpleJpaRepository::saveAndFlush</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveAndFlush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ S result = save(entity); flush(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ em.flush(); }</code> </pre> <br><p> 这里的黑点是<code>flush()</code>方法。 为什么傻呢？ 在我看来，它在<code>JpaRepository</code>接口中的公开是开发人员的错误。 我会尽力证明我的想法。 通常，开发人员根本不会使用此方法，因为对<code>EntityManager::flush</code>的调用与Spring控制的事务的完成相关： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     @Transactional public void method() { &lt;--  Session::open /*.*/ } &lt;--  Session::flush</span></span></code> </pre> <br><p> 请注意： <code>EntityManager</code>是在Hibernate中作为会话实现的<code>JPA</code>规范的一部分（分别为Session接口和SessionImpl类）。  Spring Date是一个在ORM（在本例中为Hibernate）之上运行的框架。 事实证明，尽管框架的任务是隐藏低级细节（该情况与JDK中的不安全故事类似），但<code>JpaRepository::saveAndFlush</code>使我们可以访问API的低级。 <br> 在我们的例子中，当使用<code>JpaRepository::saveAndFlush</code>我们进入了应用程序的较低层，从而破坏了某些内容。 </p><br><div class="spoiler">  <b class="spoiler_title">花些时间偷看，自己考虑一下</b> <div class="spoiler_text"><p>  Hibernate批量发送数据的功能已被破坏，它是<code>application.yml</code>指定的<code>jdbc.batch_size</code>设置的倍数： </p><br><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate: jdbc.batch_size: 500</code> </pre> <br><p>  Hibernate的工作基于事件，因此当您保存1000个这样的实体时 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } }</code> </pre> <br><p> 调用<code>repository.save(e)</code>不会立即保存。 而是创建一个排队的事件。 事务完成后，将使用<code>EntityManager::flush</code>合并数据，该数据将插入/更新分成<code>jdbc.batch_size</code>倍数束，并<code>jdbc.batch_size</code>创建请求。 在我们的例子中， <code>jdbc.batch_size: 500</code> ，因此实际上保存1000个实体仅意味着2个请求。 </p><br><p> 但是，在周期的每个阶段都要手动执行会话 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p> 队列已清除，保存1000个实体意味着1000个查询。 </p></div></div><br><p> 因此，干扰应用程序的较低层很容易成为地雷，而不仅仅是生产力地雷（请参阅不安全及其不受控制的使用）。 </p><br><p> 它减慢了多少？ 以最好的情况（对我们而言）-数据库与应用程序位于同一主机上。 我的<a href="">测量</a>结果如下图所示： </p><br><pre> <code class="plaintext hljs"> (entityCount) Mode Cnt Score Error Units bulkSave 10 ss 500 16,613 ± 1,714 ms/op bulkSave 100 ss 500 31,371 ± 1,453 ms/op bulkSave 1000 ss 500 35,687 ± 1,973 ms/op bulkSaveUsingFlush 10 ss 500 32,653 ± 2,166 ms/op bulkSaveUsingFlush 100 ss 500 61,983 ± 6,304 ms/op bulkSaveUsingFlush 1000 ss 500 184,814 ± 6,976 ms/op</code> </pre> <br><p> 显然，如果数据库位于远程主机上，则数据传输的成本将随着数据量的增长而逐渐降低性能。 </p><br><p> 因此，以错误的抽象级别进行工作很容易制造定时炸弹。 顺便说一下，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我以前的一篇文章中，</a>我谈到了一种改进<code>StringBuilder</code> -a的奇怪尝试：在尝试进入更抽象的代码级别时，我没有成功。 </p><br><h4 id="granicy-minnyh-poley"> 雷区边界 </h4><br><p> 让我们扮演一个工兵吗？ 查找我的： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); Assert.notNull(key, "Null key ..." + context.metadata.operation); // ... return key; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">找到了吗？</b>  <b class="spoiler_title">检查正确答案。</b> <div class="spoiler_text"><pre> <code class="java hljs"> | \ / <span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport | \ / Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); | \ / Assert.notNull(key, "Null key ..." + context.metadata.operation); return key; }</span></span></code> </pre> </div></div><br><p> 评论家大声说道：“你在开玩笑吗？但是只有两行胶合吗？在血腥的E.中意味着什么？” 让我引起您的注意的是，我不仅强调了字符串的粘合，而且还强调了类的名称和方法的名称。 确实，胶合字符串的危险不是胶合自身，而是在创建用于缓存的键的方法中发生的事情，即在某些情况下，我们将对该方法有很多访问权限，这意味着很多垃圾回收行。 <br> 因此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">仅</a>当实际抛出此错误<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时才应创建</a>错误消息： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); if (key == null) { throw new IAE("Null key ..." + context.metadata.operation); } // ... return key; }</span></span></code> </pre> <br><p> 因此，雷区具有边界-这是数据量，使用该方法的频率等定量指标，一旦达到或超过此范围，轻微的缺陷就会在统计上变得显着。 </p><br><p> 另一方面，这是一个特性，相对而言，代码的复杂性并不能带来明显的（可衡量的）改进。 </p><br><p> 这是对开发人员的另一个结论：在大多数情况下，欺骗是邪恶的，从而导致代码毫无意义的复杂化。 在100个案例中有99个案例，我们一无所获。 </p><br><p> 应该记住，总有 </p><br><h4 id="tot-samyy-sotyy-sluchay"> 一百例 </h4><br><p> 这是Nitzan Wakart在他的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">volatile读取中</a>给出的代码： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoopyBenchmarks</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({ <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"1024"</span></span>, <span class="hljs-string"><span class="hljs-string">"32768"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bunn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { <span class="hljs-comment"><span class="hljs-comment">// good old C style for (the win?) fox.consume(bunn[y]); } } @Benchmark public void sweetLoop(Blackhole fox) { for (byte bunny : bunn) { // syntactic sugar loop goodness fox.consume(bunny); } } }</span></span></code> </pre> <br><p> 建立经验后，我们将发现两种遍历数组的方式之间的惊人差异： </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoop 32 46.630 0.097 ns/op goodOldLoop 1024 1199.338 0.705 ns/op goodOldLoop 32768 37813.600 56.081 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p> 在这里，没有经验的开发人员可以得出这样一个显而易见的基准结论：使用新语法传递数组比计数周期更快。 这是错误的结论，因为值得<code>goodOldLoop</code>更改一下<code>goodOldLoop</code>方法： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoopReturns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sunn = bunn; <span class="hljs-comment"><span class="hljs-comment">// make a local copy of the field for (int y = 0; y &lt; sunn.length; y++) { fox.consume(sunn[y]); } }</span></span></code> </pre> <br><p> 其性能可与“更快”的<code>sweetLoop</code>方法相媲美： </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoopReturns 32 19.306 0.045 ns/op goodOldLoopReturns 1024 476.493 1.190 ns/op goodOldLoopReturns 32768 14292.286 16.046 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>     <code>Blackhole::consume</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//... public volatile byte b1, b2; public volatile BlackholeL2 nullBait = null; /** * Consume object. This call provides a side effect preventing JIT to eliminate dependent computations. * * @param b object to consume. */ public final void consume(byte b) { if (b == b1 &amp; b == b2) { // SHOULD NEVER HAPPEN nullBait.b1 = b; // implicit null pointer exception } }</span></span></code> </pre> <br><p>         ,    ,      .     <code>goodOldLoop</code>       <code>this.bunn</code>    ,  <code>for-each</code>     ,        (,  Java Concurrency In Practice   "  ").      . </p><br><p>    : "      ?   , <code>Blackhole::consume</code> —   JMH       .  ,  ,       ?" </p><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>   ? ?  ,    : </p><br><pre> <code class="java hljs">E[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;E&gt; fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>  <code>Iterable::forEach</code> !        ,   ,        ,       (   JDK 13): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) action.accept(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); } //Arrays$ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (E e : a) { action.accept(e); } } //CopyOnWriteArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (Object x : getArray()) { @SuppressWarnings("unchecked") E e = (E) x; action.accept(e); } } //ArrayDeque public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final Object[] es = elements; for (int i = head, end = tail, to = (i &lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i &lt; to; i++) action.accept(elementAt(es, i)); if (to == end) { if (end != tail) throw new ConcurrentModificationException(); break; } } }</span></span></code> </pre> <br><p>     ,          . ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> <code>Collections.nCopies()::forEach</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(action); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n; i++) { action.accept(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } }</code> </pre> <br><p>            , . .   <code>this.n</code>  <code>this.element</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopiesList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> E element; CopiesList(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, E e) { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n = n; element = e; }</code> </pre> <br><p>  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a> <code>@Stable</code> . </p><br><p>  :  99   100  ,     ,    1   100,             .     ,     . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a>          "  volatile". </p><br><h4 id="eho-voyny">   </h4><br><p>      ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.Integer @HotSpotIntrinsicCandidate public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); }</span></span></code> </pre> <br><p> -   ,         ( <code>java.lang.Integer</code> , <code>java.lang.Long</code> , <code>java.lang.Short</code> , <code>java.lang.Byte</code> , <code>java.lang.Character</code> ).  ,     ,     </p><br><pre> <code class="java hljs">Integer intgr = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>    . </p><br><p>      : </p><br><pre> <code class="java hljs">Integer intgr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>        ,         ,       <code>Integer::valueOf</code>   . </p><br><p>         :      .                ,   ,      ""  (         ).   ,        ,         <code>Integer::valueOf</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">"  "</a> . </p><br><p>   . ,              . ,       .      ,    ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443206/">https://habr.com/ru/post/zh-CN443206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443196/index.html">离线一分钟-选择工业LTE路由器</a></li>
<li><a href="../zh-CN443198/index.html">马克·扎克伯格（Mark Zuckerberg）说，Facebook正在研究一种用于阅读思想的神经接口</a></li>
<li><a href="../zh-CN443200/index.html">伊朗黑客从Citrix窃取了TB的数据</a></li>
<li><a href="../zh-CN443202/index.html">集会反对孤立的Runet</a></li>
<li><a href="../zh-CN443204/index.html">前端每周摘要（2019年3月4日至10日）</a></li>
<li><a href="../zh-CN443208/index.html">企业鼠标</a></li>
<li><a href="../zh-CN443210/index.html">React教程第21部分：第二课和条件渲染研讨会</a></li>
<li><a href="../zh-CN443212/index.html">React教程，第22部分：在TODO应用程序上工作的第七阶段，从外部源下载数据</a></li>
<li><a href="../zh-CN443214/index.html">React教程第23部分：第一个表单课程</a></li>
<li><a href="../zh-CN443216/index.html">上周第355期来自前端世界的新鲜材料摘要（2019年3月4日至10日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>