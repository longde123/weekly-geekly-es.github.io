<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõê üë©‚Äçüéì üßìüèº Criando um aplicativo no .NET Core e Kubernetes: Nossa experi√™ncia üßíüèª üìß ü§úüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Hoje falaremos sobre a experi√™ncia de um de nossos projetos de DevOps. Decidimos implementar um novo aplicativo para Linux usando o .N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando um aplicativo no .NET Core e Kubernetes: Nossa experi√™ncia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/420665/">  Ol√° pessoal! <br><br>  Hoje falaremos sobre a experi√™ncia de um de nossos projetos de DevOps.  Decidimos implementar um novo aplicativo para Linux usando o .Net Core em uma arquitetura de microsservi√ßo. <br><br>  Esperamos que o projeto esteja se desenvolvendo ativamente e que haja mais e mais usu√°rios.  Portanto, deve ser facilmente escal√°vel, tanto em termos de funcionalidade quanto de desempenho. <br><br>  Precisamos de um sistema tolerante a falhas - se um dos blocos de funcionalidade n√£o funcionar, o restante dever√° funcionar.  Tamb√©m queremos garantir a integra√ß√£o cont√≠nua, incluindo a implanta√ß√£o da solu√ß√£o nos servidores do cliente. <br><br>  Portanto, usamos as seguintes tecnologias: <br><br><ul><li>  .Net Core para implementa√ß√£o de microsservi√ßos.  Nosso projeto usou a vers√£o 2.0, </li><li>  Kubernetes para orquestra√ß√£o de microsservi√ßos, </li><li>  Docker para criar imagens de microsservi√ßo, </li><li>  barramento de integra√ß√£o Rabbit MQ e Mass Transit, </li><li>  Elasticsearch e Kibana para registro, </li><li>  TFS para implementar o pipeline de CI / CD. </li></ul><br>  Este artigo compartilhar√° os detalhes de nossa solu√ß√£o. <br><br><img src="https://habrastorage.org/webt/bp/r9/oo/bpr9ootyfj2tqvrmfpp6uhdnjfu.jpeg"><br><br>  Esta √© uma transcri√ß√£o do nosso discurso na reuni√£o do .NET. Aqui est√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para o v√≠deo do</a> discurso. <br><a name="habracut"></a><br><h2>  Nosso desafio comercial </h2><br>  Nosso cliente √© uma empresa federal onde existem comerciantes - essas pessoas s√£o respons√°veis ‚Äã‚Äãpor como as mercadorias s√£o apresentadas nas lojas.  E h√° supervisores - esses s√£o os l√≠deres dos comerciantes. <br><br>  A empresa possui um processo de treinamento e avalia√ß√£o do trabalho dos comerciantes pelos supervisores, que precisavam ser automatizados. <br><br><img src="https://habrastorage.org/webt/of/w5/bh/ofw5bhdvkm9ml03ofsazm3e5mzg.png"><br><br>  Veja como nossa solu√ß√£o funciona: <br><br>  1. O supervisor elabora um question√°rio - esta √© uma lista de verifica√ß√£o do que voc√™ precisa verificar no trabalho do comerciante. <br>  2. Em seguida, o supervisor seleciona o funcion√°rio cujo trabalho ser√° verificado.  A data do questionamento √© atribu√≠da. <br>  3. Em seguida, a atividade √© enviada para o dispositivo m√≥vel do supervisor. <br>  4. Em seguida, o question√°rio √© preenchido e enviado ao portal. <br>  5. O portal gera resultados e v√°rios relat√≥rios. <br><br><h3>  Os microsservi√ßos nos ajudar√£o a resolver tr√™s problemas: </h3><br>  1. No futuro, queremos expandir facilmente a funcionalidade, pois existem muitos processos de neg√≥cios semelhantes na empresa. <br>  2. Queremos que a solu√ß√£o seja tolerante a falhas.  Se alguma parte deixar de funcionar, a solu√ß√£o poder√° restaurar seu trabalho por conta pr√≥pria, e a falha de uma parte n√£o afetar√° muito a opera√ß√£o da solu√ß√£o como um todo. <br>  3. A empresa para a qual estamos implementando a solu√ß√£o possui muitas filiais.  Consequentemente, o n√∫mero de usu√°rios da solu√ß√£o est√° em constante crescimento.  Portanto, eu queria que isso n√£o afetasse o desempenho. <br><br>  Como resultado, decidimos usar microsservi√ßos neste projeto, o que exigiu v√°rias decis√µes n√£o triviais. <br><br><h3>  Quais tecnologias ajudaram a implementar esta solu√ß√£o: </h3><br>  O Docker simplifica a distribui√ß√£o da distribui√ß√£o da solu√ß√£o.  A distribui√ß√£o no nosso caso √© um conjunto de imagens de microsservi√ßo <br>  ‚Ä¢ Como existem muitos microsservi√ßos em nossa solu√ß√£o, precisamos gerenci√°-los.  Para isso, usamos o Kubernetes. <br>  ‚Ä¢ Implementamos microsservi√ßos usando o .Net Core. <br>  ‚Ä¢ Para atualizar rapidamente a solu√ß√£o no cliente, precisamos implementar uma integra√ß√£o e entrega cont√≠nua e conveniente. <br><br>  Aqui est√° todo o nosso conjunto de tecnologias: <br><br>  ‚Ä¢ .Net Core que usamos para criar microsservi√ßos, <br>  ‚Ä¢ O microsservi√ßo √© empacotado em uma imagem do Docker, <br>  ‚Ä¢ A integra√ß√£o cont√≠nua e a entrega cont√≠nua s√£o implementadas usando o TFS, <br>  ‚Ä¢ O front end √© implementado em Angular, <br>  ‚Ä¢ Para monitoramento e registro, usamos Elasticsearch e Kibana, <br>  ‚Ä¢ RabbitMQ e MassTransit s√£o usados ‚Äã‚Äãcomo barramento de integra√ß√£o. <br><br><h3>  Solu√ß√µes .NET Core para Linux </h3><br>  Todos sabemos o que √© o cl√°ssico .Net Framework.  A principal desvantagem da plataforma √© que ela n√£o √© multiplataforma.  Portanto, n√£o podemos executar solu√ß√µes no .Net Framework para Linux no Docker. <br><br>  Para fornecer a capacidade de usar C # no Docker, a Microsoft repensou o .Net Framework e criou o .Net Core.  E para usar as mesmas bibliotecas, a Microsoft criou a especifica√ß√£o .Net Standard Library.  Os assemblies da .Net Standart Library podem ser usados ‚Äã‚Äãno .Net Framework e no .Net Core. <br><br><img src="https://habrastorage.org/webt/2z/qy/s9/2zqys9n9-watdykykh0uxpbhgl8.png"><br><br><h3>  Kubernetes - para orquestra√ß√£o de microsservi√ßos </h3><br>  O Kubernetes √© usado para gerenciar e agrupar cont√™ineres do Docker.  Aqui est√£o as principais vantagens do Kubernetes das quais aproveitamos: <br><br>  - fornece a capacidade de configurar facilmente o ambiente dos microsservi√ßos, <br>  - simplifica a gest√£o ambiental (Dev, QA, Stage), <br>  - Pronto para uso, replica os microsservi√ßos e balan√ßa de carga nas r√©plicas. <br><br><img src="https://habrastorage.org/webt/jw/fu/11/jwfu11e5m-xv4rrqmy--goxcghs.png"><br><br><h2>  Arquitetura da solu√ß√£o </h2><br>  No in√≠cio do trabalho, nos perguntamos como dividir a funcionalidade em microsservi√ßos.  A divis√£o foi feita com base no princ√≠pio de uma √∫nica responsabilidade, apenas em um n√≠vel superior.  Sua principal tarefa √© fazer altera√ß√µes em um servi√ßo o menos poss√≠vel, afetar outros microsservi√ßos.  Como resultado, no nosso caso, os microsservi√ßos come√ßaram a executar uma √°rea separada de funcionalidade. <br><br>  Como resultado, apresentamos servi√ßos envolvidos no planejamento de question√°rios, um microsservi√ßo para exibi√ß√£o de resultados, um microsservi√ßo para trabalhar com um aplicativo m√≥vel e outros microsservi√ßos. <br><br><img src="https://habrastorage.org/webt/f8/by/-6/f8by-6unz3mtb-f8edbczrmvhtg.png"><br><br><h3>  Op√ß√µes para interagir com clientes externos </h3><br>  Microsoft em seu livro sobre microsservi√ßos, ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Microservices .NET.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.NET Container Application Architecture</a> ‚Äùoferece tr√™s poss√≠veis implementa√ß√µes de intera√ß√£o com microsservi√ßos.  Analisamos os tr√™s e escolhemos o mais adequado. <br><br>  ‚Ä¢ servi√ßo de gateway de API <br>  A API do servi√ßo Gateway √© uma implementa√ß√£o de fachada para solicita√ß√µes do usu√°rio por outros servi√ßos.  O problema com a solu√ß√£o √© que, se a fachada n√£o funcionar, a solu√ß√£o inteira deixar√° de funcionar.  Eles decidiram abandonar essa abordagem por toler√¢ncia a falhas. <br><br>  ‚Ä¢ Gateway de API com Gerenciamento de API do Azure <br>  A Microsoft fornece a capacidade de usar uma fachada de nuvem no Azure.  Mas essa solu√ß√£o n√£o se encaixava, porque est√°vamos implantando a solu√ß√£o n√£o na nuvem, mas nos servidores do cliente. <br><br>  ‚Ä¢ Comunica√ß√£o direta entre cliente e microsservi√ßo <br>  Como resultado, temos a √∫ltima op√ß√£o - intera√ß√£o direta do usu√°rio com microsservi√ßos.  N√≥s o escolhemos. <br><br><img src="https://habrastorage.org/webt/sc/uc/x6/scucx6-8y4bj629y967_urhsy2q.png"><br><br>  √â mais uma toler√¢ncia a falhas.  A desvantagem √© que parte da funcionalidade ter√° que ser reproduzida em cada servi√ßo separadamente.  Por exemplo, era necess√°rio configurar a autoriza√ß√£o separadamente em cada microsservi√ßo ao qual os usu√°rios t√™m acesso. <br><br>  Obviamente, surge a quest√£o de como equilibraremos a carga e como a toler√¢ncia a falhas √© implementada.  Tudo √© simples aqui - o Ingress Controller Kubernetes faz isso. <br><br><img src="https://habrastorage.org/webt/87/3p/zq/873pzqb0ffu9ugon6pa5b8bx6ao.png"><br><br>  O n√≥ 1, o n√≥ 2 e o n√≥ 3 s√£o r√©plicas do mesmo microsservi√ßo.  Se uma das r√©plicas falhar, o balanceador de carga redirecionar√° automaticamente a carga para outros microsservi√ßos. <br><br><h3>  Arquitetura f√≠sica </h3><br>  Veja como organizamos nossa infraestrutura de solu√ß√µes: <br><br>  ‚Ä¢ Cada microsservi√ßo possui seu pr√≥prio banco de dados (se ele, √© claro, precisar dele), outros servi√ßos n√£o acessam o banco de dados de outro microsservi√ßo. <br>  ‚Ä¢ Os microsservi√ßos se comunicam apenas atrav√©s do barramento RabbitMQ + Mass Transit, bem como usando solicita√ß√µes HTTP. <br>  ‚Ä¢ Cada servi√ßo tem sua pr√≥pria responsabilidade claramente definida. <br>  ‚Ä¢ Para o registro, usamos o Elasticsearch e o Kibana e a biblioteca para trabalhar com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Serilog</a> . <br><br><img src="https://habrastorage.org/webt/lu/8p/z3/lu8pz3zhxiggf1syj1btyqm9q54.png"><br><br>  O servi√ßo de banco de dados foi implantado em uma m√°quina virtual separada e n√£o no Kubernetes, porque o Microsoft DBMS n√£o recomenda o uso do Docker nos ambientes do produto. <br><br>  O servi√ßo de log tamb√©m foi implantado em uma m√°quina virtual separada por motivos de toler√¢ncia a falhas - se tivermos problemas com o Kubernetes, poderemos descobrir qual √© o problema. <br><br><h2>  Implanta√ß√£o: como organizamos os ambientes de desenvolvimento e produto </h2><br>  Nossa infraestrutura possui tr√™s namespaces no Kubernetes.  Todos os tr√™s ambientes acessam um servi√ßo de banco de dados e um servi√ßo de log.  E, √© claro, cada ambiente analisa seu pr√≥prio banco de dados. <br><br><img src="https://habrastorage.org/webt/rh/el/mz/rhelmza1dleycp5kdiylccr1aig.png"><br><br>  Na infraestrutura do cliente, tamb√©m temos dois ambientes - pr√©-produ√ß√£o e produ√ß√£o.  Na produ√ß√£o, temos servidores de banco de dados separados para pr√©-venda e ambiente do produto.  Para o registro, alocamos um servidor ELK em nossa infraestrutura e na infraestrutura do cliente. <br><br><h3>  Como implantar 5 ambientes com 10 microsservi√ßos cada? </h3><br>  Em m√©dia, temos 10 servi√ßos por projeto e tr√™s ambientes: QA, DEV, Stage, nos quais cerca de 30 microsservi√ßos s√£o implantados no total.  E isso √© apenas na infraestrutura de desenvolvimento!  Adicione mais 2 ambientes √† infraestrutura do cliente e obteremos 50 microsservi√ßos. <br><br><img src="https://habrastorage.org/webt/sq/1m/kf/sq1mkfrwc4nfuu6whyq-cja9g-m.png"><br><br>  √â claro que esse n√∫mero de servi√ßos deve, de alguma forma, ser gerenciado.  Kubernetes nos ajuda com isso. <br><br>  Para implantar um microsservi√ßo, voc√™ deve <br>  ‚Ä¢ Expandir segredo, <br>  ‚Ä¢ Implantar implanta√ß√£o, <br>  ‚Ä¢ Expandir servi√ßo. <br><br>  Sobre o segredo, escreva abaixo. <br>  A implanta√ß√£o √© uma instru√ß√£o para o Kubernetes, com base na qual ele lan√ßar√° o cont√™iner Docker do nosso microsservi√ßo.  Aqui est√° o comando no qual a implanta√ß√£o √© implantada: <br><br> <code>kubectl apply -f .\(yaml  deployment-) --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  Este arquivo descreve como a implanta√ß√£o √© chamada (imtob-etr-it-dictionary-api), qual imagem ele precisa usar para execu√ß√£o, al√©m de outras configura√ß√µes.  Na se√ß√£o secreta, personalizaremos nosso ambiente. <br><br>  Ap√≥s a implanta√ß√£o, precisamos implantar o servi√ßo, se necess√°rio. <br><br>  Os servi√ßos s√£o necess√°rios quando √© necess√°rio o acesso externo ao microsservi√ßo.  Por exemplo, quando voc√™ deseja que um usu√°rio ou outro microsservi√ßo possa fazer uma solicita√ß√£o Get para outro microsservi√ßo. <br><br> <code>kubectl apply -f .\imtob-etr-it-dictionary-api.yml --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: imtob-etr-it-dictionary-api-services spec: ports: - name: http port: 80 targetPort: 80 protocol: TCP selector: name: imtob-etr-it-dictionary-api</code> </pre> <br><br>  Geralmente a descri√ß√£o do servi√ßo √© pequena.  Nele, vemos o nome do servi√ßo, como ele pode ser acessado e o n√∫mero da porta. <br><br>  Como resultado, para implantar o ambiente, precisamos <br><br>  ‚Ä¢ um conjunto de arquivos com segredos para todos os microsservi√ßos, <br>  ‚Ä¢ um conjunto de arquivos com a implanta√ß√£o de todos os microsservi√ßos, <br>  ‚Ä¢ um conjunto de arquivos com os servi√ßos de todos os microsservi√ßos. <br><br>  Armazenamos todos esses scripts no reposit√≥rio git. <br><br>  Para implantar a solu√ß√£o, obtivemos um conjunto de tr√™s tipos de scripts: <br><br>  ‚Ä¢ pasta com segredos - s√£o configura√ß√µes para cada ambiente, <br>  ‚Ä¢ pasta com implanta√ß√£o para todos os microsservi√ßos, <br>  ‚Ä¢ pasta com servi√ßos para alguns microsservi√ßos, <br><br>  em cada - cerca de dez equipes, uma para cada microsservi√ßo.  Por conveni√™ncia, criamos uma p√°gina com scripts no Confluence, que nos ajuda a implantar rapidamente um novo ambiente. <br><br>  Aqui est√° um script de implanta√ß√£o de implanta√ß√£o (existem conjuntos semelhantes para segredo e servi√ßo): <br><br><div class="spoiler">  <b class="spoiler_title">Script de implanta√ß√£o</b> <div class="spoiler_text">  O kubectl aplica -f. \ imtob-etr-it-image-api.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-mobile-api.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-planning-api.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-result-api.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-web.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-report-api.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-template-construtor-api.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-dictionary-api.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-integration-api.yml --namespace = DEV <br>  O kubectl aplica -f. \ imtob-etr-it-identity-api.yml --namespace = DEV <br></div></div><br><br><h3>  Implementa√ß√£o de CI / CD </h3><br><br>  Cada servi√ßo est√° em sua pr√≥pria pasta, al√©m de termos uma pasta com componentes comuns. <br><br><img src="https://habrastorage.org/webt/kj/xk/zf/kjxkzf7k-qzppe0ncduxvb_dzmc.jpeg"><br><br>  H√° tamb√©m uma defini√ß√£o de compila√ß√£o e defini√ß√£o de vers√£o para cada microsservi√ßo.  Configuramos o lan√ßamento da Defini√ß√£o de Compila√ß√£o ao confirmar o servi√ßo apropriado ou ao confirmar a pasta apropriada.  Se o conte√∫do da pasta com componentes comuns for atualizado, todos os microsservi√ßos ser√£o implantados. <br><br>  Quais s√£o as vantagens de uma organiza√ß√£o Build? <br><br>  1. A solu√ß√£o est√° em um reposit√≥rio git, <br>  2. Ao mudar em v√°rios microsservi√ßos, a montagem come√ßa em paralelo com agentes de montagem livres, <br>  3. Cada defini√ß√£o de compila√ß√£o apresenta um script simples para compilar a imagem e envi√°-la para o Nexus Registry. <br><br><h3>  Defini√ß√£o de compila√ß√£o e defini√ß√£o de vers√£o </h3><br>  Como implantar um agente VSTS, descrevemos anteriormente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> . <br><br><img src="https://habrastorage.org/webt/df/3i/k6/df3ik6q87wmw9qwjsjituwvmat8.png"><br><br>  Primeiro vem a defini√ß√£o de compila√ß√£o.  No comando TFS VSTS, o agente inicia a constru√ß√£o do Dockerfile.  Como resultado, obtemos a imagem de um microsservi√ßo.  Esta imagem √© salva localmente no ambiente em que o agente VSTS est√° sendo executado. <br><br>  Ap√≥s a compila√ß√£o, o Push √© iniciado, que envia a imagem que recebemos na etapa anterior para o Registro do Nexus.  Agora pode ser usado externamente.  O Nexus Registry √© um tipo de Nuget, n√£o apenas para bibliotecas, mas para imagens do Docker e muito mais. <br><br>  Depois que a imagem estiver pronta e acess√≠vel do lado de fora, voc√™ precisar√° implant√°-la.  Para isso, temos a defini√ß√£o de vers√£o.  Tudo √© simples aqui - executamos o comando set image: <br><br> <code>kubectl set image deployment/imtob-etr-it-dictionary-api imtob-etr-it-dictionary-api=nexus3.company.ru:18085/etr-it-dictionary-api:$(Build.BuildId)</code> <br> <br>  Depois disso, ele atualizar√° a imagem para o microsservi√ßo desejado e iniciar√° um novo cont√™iner.  Como resultado, nosso servi√ßo foi atualizado. <br><br>  Vamos agora comparar a compila√ß√£o com e sem o Dockerfile. <br><br><img src="https://habrastorage.org/webt/dn/wq/j6/dnwqj6og3rbyvdojybcrvs88yq0.png"><br><br>  Sem o Dockerfile, temos v√°rias etapas, que t√™m muitas especificidades .Net.  √Ä direita, vemos uma imagem do Docker compilada.  Tudo se tornou muito mais f√°cil. <br><br>  Todo o processo de cria√ß√£o da imagem √© descrito no Dockerfile.  Este assembly pode ser depurado localmente. <br><br><img src="https://habrastorage.org/webt/hk/pd/g0/hkpdg0lafe00sbh1_afyquwwjsm.png"><br><br><h3>  Total: obtivemos um CI / CD simples e transparente </h3><br><br>  1. Separa√ß√£o de desenvolvimento e implanta√ß√£o.  A montagem √© descrita no Dockerfile e fica sobre os ombros do desenvolvedor. <br>  2. Ao configurar o CI / CD, voc√™ n√£o precisa conhecer os detalhes e os recursos da montagem - o trabalho √© feito apenas com o Dockerfile. <br>  3. Atualizamos apenas os microsservi√ßos alterados. <br><br>  Em seguida, voc√™ precisa configurar o RabbitMQ no K8S: escrevemos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo separado</a> sobre isso. <br><br><h3>  Configura√ß√£o do ambiente </h3><br>  De uma forma ou de outra, precisamos configurar microsservi√ßos.  A parte principal do ambiente est√° configurada no arquivo de configura√ß√£o raiz Appsettings.json.  Este arquivo cont√©m configura√ß√µes independentes do ambiente. <br><br>  Essas configura√ß√µes que dependem do ambiente s√£o armazenadas na pasta secrets no arquivo appsettings.secret.json.  Adotamos a abordagem descrita no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciando as configura√ß√µes principais do aplicativo ASP.NET no Kubernetes</a> . <br><br><pre> <code class="plaintext hljs">var configuration = new ConfigurationBuilder() .AddJsonFile($"appsettings.json", true) .AddJsonFile("secrets/appsettings.secrets.json", optional: true) .Build();</code> </pre> <br><br>  O arquivo appsettings.secrets.json cont√©m as configura√ß√µes para os √≠ndices do Elastic Search e a cadeia de conex√£o do banco de dados. <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Serilog"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"WriteTo"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Elasticsearch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nodeUris"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://192.168.150.114:9200"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"indexFormat"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary-{0:yyyy.MM.dd}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"templateName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"typeName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary.event"</span></span> } } ] }, <span class="hljs-attr"><span class="hljs-attr">"ConnectionStrings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"DictionaryDbContext"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=192.168.154.162;Database=DEV.ETR.IT.iField.Dictionary;User Id=it_user;Password=PASSWORD;"</span></span> } }</code> </pre><br><br><h4>  Adicionar arquivo de configura√ß√£o ao Kubernetes </h4><br>  Para adicionar esse arquivo, voc√™ precisa implant√°-lo no cont√™iner do Docker.  Isso √© feito no arquivo de implanta√ß√£o do Kubernetis.  A implanta√ß√£o descreve em qual pasta o arquivo secreto c deve ser criado e com qual segredo √© necess√°rio associ√°-lo. <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  Voc√™ pode criar um segredo no Kubernetes usando o utilit√°rio kubectl.  Vemos aqui o nome do segredo e o caminho para o arquivo.  Tamb√©m indicamos o nome do ambiente para o qual criamos um segredo. <br><br> <code>kubectl create secret generic secret-appsettings-dictionary <br> --from-file=./Dictionary/appsettings.secrets.json --namespace=DEMO</code> <br> <br><h2>  Conclus√µes </h2><br><h3>  Contras da abordagem escolhida </h3><br>  1. Limiar alto de entrada.  Se voc√™ estiver realizando esse projeto pela primeira vez, haver√° muitas informa√ß√µes novas. <br>  2. Microsservi√ßos ‚Üí projeto mais complexo.  √â necess√°rio aplicar muitas solu√ß√µes n√£o √≥bvias devido ao fato de n√£o termos uma solu√ß√£o monol√≠tica, mas uma microsservi√ßos. <br>  3. Nem tudo est√° implementado para o Docker.  Nem tudo pode ser executado na arquitetura de microsservi√ßo.  Por exemplo, enquanto o SSRS n√£o estiver na janela de encaixe. <br><br><h3>  Pr√≥s de uma abordagem auto-testada </h3><br>  1. Infraestrutura como um c√≥digo <br>  A descri√ß√£o da infraestrutura √© armazenada no controle de origem.  No momento da implanta√ß√£o, voc√™ n√£o precisa adaptar o ambiente. <br>  2. Dimensionamento no n√≠vel da funcionalidade e no n√≠vel de desempenho imediatamente. <br>  3. Os microsservi√ßos s√£o bem isolados <br>  Praticamente n√£o h√° partes cr√≠ticas, cuja falha leva √† inoperabilidade do sistema como um todo. <br>  4. Entrega r√°pida de altera√ß√µes <br>  Somente os microsservi√ßos nos quais houve atualiza√ß√µes s√£o atualizados.  Se voc√™ n√£o levar em considera√ß√£o o tempo de coordena√ß√£o e outras coisas relacionadas ao fator humano, a atualiza√ß√£o de um microsservi√ßo ocorrer√° em 2 minutos ou menos. <br><br><h3>  Conclus√µes para n√≥s </h3><br>  1. No .NET Core, voc√™ pode e deve implementar solu√ß√µes industriais. <br>  2. O K8S realmente facilitou a vida, simplificou a atualiza√ß√£o de ambientes, facilita a configura√ß√£o dos servi√ßos. <br>  3. O TFS pode ser usado para implementar o CI / CD para Linux. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420665/">https://habr.com/ru/post/pt420665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420653/index.html">Cinco coisas que voc√™ precisa fazer para equipar sua casa em Marte</a></li>
<li><a href="../pt420657/index.html">An√°lise: de quem dinheiro Elon Musk ser√° capaz de retirar Tesla da bolsa</a></li>
<li><a href="../pt420659/index.html">Campanha USB da HRF (Human Rights Foundation) ‚ÄúFlash Drives for Freedom‚Äù</a></li>
<li><a href="../pt420661/index.html">Infraestrutura de nuvem cont√≠nua</a></li>
<li><a href="../pt420663/index.html">M√©tricas simples e uma maneira de economizar tempo ao procurar problemas na infraestrutura</a></li>
<li><a href="../pt420667/index.html">Princ√≠pios de opera√ß√£o do protocolo EIGRP</a></li>
<li><a href="../pt420669/index.html">Vis√£o Geral do Mercado de Automa√ß√£o Corporativa: Solu√ß√µes para Empresas de Constru√ß√£o e Gerenciamento de Habita√ß√µes e Utilidades</a></li>
<li><a href="../pt420671/index.html">[Ekaterinburg, an√∫ncio] UralJS # 9 - tr√™s relat√≥rios sobre microsservi√ßos, testes e registro de erros na frente</a></li>
<li><a href="../pt420673/index.html">Docker para Symfony 4 - da LAN √† produ√ß√£o</a></li>
<li><a href="../pt420675/index.html">SOC s√£o pessoas. ‚ÄúOl√°, estamos procurando talentos‚Äù ou de onde v√™m os analistas do centro de monitoramento e resposta a ataques cibern√©ticos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>