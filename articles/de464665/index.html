<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📳 🌹 ⚪️ Partitionierung in SQL Server 📵 🌦️ 👩🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Partitionierung ("Partitionierung") in SQL Server mit scheinbarer Einfachheit ("Was ist da - Sie verteilen die Tabelle und die Indizes nach Dateig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Partitionierung in SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464665/"> Die Partitionierung ("Partitionierung") in SQL Server mit scheinbarer Einfachheit ("Was ist da - Sie verteilen die Tabelle und die Indizes nach Dateigruppen, Sie erzielen Gewinn bei Verwaltung und Leistung") ist ein ziemlich umfangreiches Thema.  Im Folgenden werde ich versuchen zu beschreiben, wie ein Funktions- und Partitionsschema erstellt und angewendet wird und auf welche Probleme Sie möglicherweise stoßen.  Ich werde nicht über die Vorteile sprechen, außer auf eine Sache - das Wechseln von Abschnitten, wenn Sie sofort einen großen Datensatz aus einer Tabelle entfernen oder umgekehrt - sofort einen nicht weniger großen Satz in eine Tabelle laden. <br><a name="habracut"></a><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">msdn</a> heißt es: „Daten aus partitionierten Tabellen und Indizes sind in Blöcke unterteilt, die auf mehrere Dateigruppen in der Datenbank verteilt werden können.  Die Daten werden horizontal partitioniert, sodass Zeilengruppen einzelnen Abschnitten zugeordnet werden.  Alle Abschnitte desselben Index oder derselben Tabelle müssen sich in derselben Datenbank befinden.  Eine Tabelle oder ein Index wird beim Ausführen von Abfragen oder Aktualisierungen von Daten als eine einzige logische Entität betrachtet. “ <br><br>  Dort sind auch die Hauptvorteile aufgeführt: <br><br><ul><li>  Übertragen und greifen Sie schnell und effizient auf Teilmengen von Daten zu, während die Integrität des Datensatzes erhalten bleibt </li><li>  Wartungsarbeiten können mit einem oder mehreren Abschnitten schneller durchgeführt werden. </li><li>  Sie können die Geschwindigkeit der Abfrageausführung erhöhen, abhängig von den Abfragen, die häufig in Ihrer Hardwarekonfiguration ausgeführt werden. </li></ul><br>  Mit anderen Worten wird die Partitionierung für die horizontale Skalierung verwendet.  Die Tabellen / Indizes werden von verschiedenen Dateigruppen „verteilt“, die sich auf verschiedenen physischen Datenträgern befinden können. Dies erhöht den Verwaltungskomfort erheblich und ermöglicht es Ihnen theoretisch, die Leistung von Abfragen zu diesen Daten zu verbessern. Sie können entweder nur den gewünschten Abschnitt (weniger Daten) lesen oder alles lesen parallel (Geräte sind unterschiedlich, schnell zu lesen).  In der Praxis ist alles etwas komplizierter und die Steigerung der Leistung von Abfragen an partitionierte Tabellen kann nur funktionieren, wenn Ihre Abfragen die Auswahl nach dem von Ihnen partitionierten Feld verwenden.  Wenn Sie noch keine Erfahrung mit partitionierten Tabellen haben, denken Sie daran, dass sich die Leistung Ihrer Abfragen möglicherweise nicht ändert, sich jedoch nach der Partitionierung Ihrer Tabelle verschlechtern kann. <br><br>  Lassen Sie uns über den absoluten Vorteil sprechen, den Sie definitiv mit der Partitionierung haben (den Sie aber auch nutzen müssen) - dies ist eine garantierte Steigerung des Komforts bei der Verwaltung Ihrer Datenbank.  Sie haben beispielsweise eine Tabelle mit einer Milliarde Datensätzen, von denen 900 Millionen aus alten („geschlossenen“) Zeiträumen stammen und schreibgeschützt sind.  Mithilfe von Abschnitten können Sie diese alten Daten in eine separate schreibgeschützte Dateigruppe übertragen, sichern und nicht mehr in alle Ihre täglichen Sicherungen ziehen. Die Geschwindigkeit beim Erstellen einer Sicherungskopie nimmt zu und die Größe nimmt ab.  Sie können den Index nicht über die gesamte Tabelle, sondern über ausgewählte Abschnitte neu erstellen.  Darüber hinaus steigt die Verfügbarkeit Ihrer Datenbank. Wenn eines der Geräte mit der Dateigruppe mit dem Abschnitt ausfällt, ist der Rest weiterhin verfügbar. <br><br>  Um die verbleibenden Vorteile zu erzielen (Abschnitte sofort wechseln; Produktivität steigern), müssen Sie die Datenstruktur speziell entwerfen und Abfragen schreiben. <br>  Ich schätze, ich habe den Leser schon genug in Verlegenheit gebracht und jetzt kann ich mit dem Üben fortfahren. <br><br>  Erstellen Sie zunächst eine Datenbank mit 4 Dateigruppen, in der wir Experimente durchführen werden: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> [PartitionTest] <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> primary (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestPrimary'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestPrimary.mdf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg1] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG1'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG1.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg2] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG2'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG2.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg3] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG3'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG3.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'PTest_Log'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTest_log.ldf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">2048</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB); go <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> [PartitionTest] <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">recovery</span></span> simple; go <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> partitionTest;</code> </pre> <br>  Erstellen Sie eine Tabelle, die wir quälen werden. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ptest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>));</code> </pre> <br>  Und füllen Sie es mit Daten für ein Jahr: <br><pre> <code class="sql hljs">;<span class="hljs-keyword"><span class="hljs-keyword">with</span></span> nums <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ptest(dt, dummy_int, dummy_char) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(hh, rn<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">'20180101'</span></span>) dt, rn dummy_int, <span class="hljs-string"><span class="hljs-string">'dummy char column #'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(rn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> row_number() <span class="hljs-keyword"><span class="hljs-keyword">over</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>))) rn <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nums n1, nums n2, nums n3, nums n4 )t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> rn &lt; <span class="hljs-number"><span class="hljs-number">8761</span></span></code> </pre> <br>  Jetzt enthält die pTest-Tabelle einen Datensatz für jede Stunde des Jahres 2018. <br><br>  Jetzt müssen Sie eine Partitionsfunktion erstellen, die die Randbedingungen für die Aufteilung von Daten in Abschnitte beschreibt.  SQL Server unterstützt nur die Bereichspartitionierung. <br><br>  Wir werden unsere Tabelle nach der Spalte dt (datetime) aufteilen, sodass jeder Abschnitt Daten für 4 Monate enthält (hier habe ich es vermasselt - tatsächlich enthält der erste Abschnitt Daten für 3, der zweite für 4, der dritte für 5 Monate, aber zu Demonstrationszwecken - dies ist kein Problem) <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Alles scheint normal zu sein, aber hier habe ich absichtlich einen „Fehler“ gemacht.  Wenn Sie sich die Syntax in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">msdn</a> ansehen, werden Sie feststellen, dass Sie während der Erstellung angeben können, zu welchem ​​Abschnitt der angegebene Rahmen gehören soll - links oder rechts.  Aus unbekannten Gründen bezieht sich der angegebene Rand standardmäßig auf den Abschnitt "links". In meinem Fall wäre es daher richtig, eine Partitionsfunktion wie folgt zu erstellen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Während ich tatsächlich ausgeführt habe: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Wir werden jedoch später darauf zurückkommen und unsere Partitionsfunktion neu erstellen.  In der Zwischenzeit fahren wir mit dem fort, was passiert ist, um zu verstehen, was passiert ist und warum es nicht sehr gut für uns ist. <br><br>  Nach dem Erstellen der Partitionsfunktion müssen Sie ein Partitionsschema erstellen.  Es bindet Abschnitte eindeutig an Dateigruppen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> pfTest <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ([FG1], [FG2], [FG3])</code> </pre> <br>  Wie Sie sehen können, befinden sich alle drei Abschnitte in verschiedenen Dateigruppen.  Jetzt ist es Zeit, unsere Tabelle zu partitionieren.  Dazu müssen wir einen Clustered-Index erstellen und anstelle der Dateigruppe, in der er sich befinden soll, das Partitionierungsschema angeben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_pTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> psTest(dt)</code> </pre> <br>  Und auch hier habe ich im aktuellen Schema einen „Fehler“ gemacht - ich hätte sehr gut einen eindeutigen Clustered-Index für diese Spalte erstellen können. Wenn Sie jedoch einen eindeutigen Index erstellen, sollte die zur Partitionierung verwendete Spalte in den Index aufgenommen werden.  Und ich möchte zeigen, was Sie mit dieser Konfiguration erleben können. <br><br>  Nun wollen wir sehen, was wir in der aktuellen Konfiguration haben (die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfrage wird von hier übernommen</a> ): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sc.name + N<span class="hljs-string"><span class="hljs-string">'.'</span></span> + so.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Schema.Table], si.index_id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], si.type_desc <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Structure], si.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>], stat.row_count <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Rows</span></span>], stat.in_row_reserved_page_count * <span class="hljs-number"><span class="hljs-number">8.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> GB], stat.lob_reserved_page_count * <span class="hljs-number"><span class="hljs-number">8.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">LOB</span></span> GB], p.partition_number <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Partition</span></span> <span class="hljs-comment"><span class="hljs-comment">#], pf.name as [Partition Function], CASE pf.boundary_value_on_right WHEN 1 then 'Right / Lower' ELSE 'Left / Upper' END as [Boundary Type], prv.value as [Boundary Point], fg.name as [Filegroup] FROM sys.partition_functions AS pf JOIN sys.partition_schemes as ps on ps.function_id=pf.function_id JOIN sys.indexes as si on si.data_space_id=ps.data_space_id JOIN sys.objects as so on si.object_id = so.object_id JOIN sys.schemas as sc on so.schema_id = sc.schema_id JOIN sys.partitions as p on si.object_id=p.object_id and si.index_id=p.index_id LEFT JOIN sys.partition_range_values as prv on prv.function_id=pf.function_id and p.partition_number= CASE pf.boundary_value_on_right WHEN 1 THEN prv.boundary_id + 1 ELSE prv.boundary_id END /* For left-based functions, partition_number = boundary_id, for right-based functions we need to add 1 */ JOIN sys.dm_db_partition_stats as stat on stat.object_id=p.object_id and stat.index_id=p.index_id and stat.index_id=p.index_id and stat.partition_id=p.partition_id and stat.partition_number=p.partition_number JOIN sys.allocation_units as au on au.container_id = p.hobt_id and au.type_desc ='IN_ROW_DATA' /* Avoiding double rows for columnstore indexes. */ /* We can pick up LOB page count from partition_stats */ JOIN sys.filegroups as fg on fg.data_space_id = au.data_space_id ORDER BY [Schema.Table], [Index ID], [Partition Function], [Partition #];</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/72/qu/op/72quopaqu1glcalpur92qrwy6eo.png"><br><br>  So haben wir drei nicht sehr erfolgreiche Abschnitte erhalten - der erste speichert Daten vom Beginn der Zeit bis einschließlich 04/01/2018 00:00:00, der zweite - vom 01/01/2018 00:00:01 bis einschließlich 08/01/2018 00:00:00 einschließlich der dritte vom 08/01/2018 00:00:01 bis zum Ende der Welt (ich habe absichtlich den Bruchteil einer Sekunde verpasst, weil ich mich nicht erinnere, in welche Abstufung SQL Server diese Brüche schreibt, aber die Bedeutung korrekt übertragen wird). <br>  Erstellen Sie nun einen nicht gruppierten Index für das Feld dummy_int, der nach demselben Partitionierungsschema „ausgerichtet“ ist. <br><br><div class="spoiler">  <b class="spoiler_title">Warum brauchen wir einen ausgerichteten Index?</b> <div class="spoiler_text">  Wir benötigen einen ausgerichteten Index, damit wir einen Abschnitt (Schalter) wechseln können - und dies ist eine dieser Operationen, für die sie sich häufig mit der Partitionierung beschäftigen.  Wenn die Tabelle mindestens einen nicht ausgerichteten Index enthält, können Sie den Abschnitt nicht wechseln <br></div></div><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> nonclustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> nix_pTest_dummyINT <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest(dummy_int) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> psTest(dt);</code> </pre> <br>  Und lassen Sie uns sehen, warum ich gesagt habe, dass Ihre Abfragen nach der Implementierung von Abschnitten langsamer werden können.  Führen Sie die Anforderung aus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy_int = <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und sehen wir uns die Ausführungsstatistik an: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 3, logical reads 6, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Und der Umsetzungsplan: <br><br><img src="https://habrastorage.org/webt/-i/ey/ay/-ieyay17s-rifng9eaij7bobfes.png"><br><br>  Da unser Index bedingt durch Abschnitte „ausgerichtet“ ist, hat jeder Abschnitt seinen eigenen Index, der mit Indizes für andere Abschnitte „nicht verbunden“ ist.  Wir haben dem Feld, nach dem der Index partitioniert ist, keine Bedingungen auferlegt, sodass SQL Server gezwungen ist, die Indexsuche in jedem Abschnitt auszuführen, nämlich 3 Indexsuche anstelle von einem. <br><br>  Versuchen wir, einen Abschnitt auszuschließen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy_int = <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> dt &lt; <span class="hljs-string"><span class="hljs-string">'20180801'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und sehen wir uns die Ausführungsstatistik an: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 2, logical reads 4, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Ja, ein Abschnitt wurde ausgeschlossen und die Suche nach dem gewünschten Wert wurde in nur zwei Abschnitten durchgeführt. <br>  Dies muss bei der Entscheidung für eine Partitionierung beachtet werden.  Wenn Sie Abfragen haben, die keine Einschränkung für das Feld verwenden, nach dem die Tabelle partitioniert ist, liegt möglicherweise ein Problem vor. <br><br>  Wir brauchen den nicht gruppierten Index nicht mehr, also lösche ich ihn <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> nix_pTest_dummyINT <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Und warum wurde ein Nicht-Cluster-Index benötigt?</b> <div class="spoiler_text">  Im Allgemeinen brauchte ich es nicht, ich konnte dasselbe mit dem Cluster-Index anzeigen. Ich weiß nicht, warum ich es erstellt habe, aber da ich es erstellt und Screenshots erstellt habe, verschwinden Sie nicht <br></div></div><br>  Stellen Sie sich nun das folgende Szenario vor: Wir archivieren die Daten aus dieser Tabelle alle 4 Monate - wir entfernen die alten Daten und fügen einen Abschnitt für die nächsten vier Monate hinzu (die Organisation des „Schiebefensters“ ist in msdn und dem Haufen von Blogs beschrieben). <br><br>  Wir unterteilen die Aufgabe in kleine und verständliche Unteraufgaben: <br><br><ol><li>  Fügen Sie einen Abschnitt für Daten vom 01.01.2019 bis zum 01.04.2019 hinzu </li><li>  Erstellen Sie eine leere Bühnentabelle </li><li>  Schalten Sie den Datenbereich bis zum 04/01/2018 in der Stufentabelle </li><li>  Entfernen Sie den leeren Bereich </li></ol><br>  Lass uns gehen: <br><br>  1. Wir geben bekannt, dass der neue Abschnitt in der FG1-Dateigruppe erstellt wird, da er bald von uns befreit wird: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1];</code> </pre> <br>  Ändern Sie die Partitionsfunktion, indem Sie einen neuen Rahmen hinzufügen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190101'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Wir schauen uns die Statistiken an: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 76171, physical reads 0, read-ahead reads 753, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'Worktable'. Scan count 1, logical reads 7440, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Die Tabelle enthält 8809 Seiten (Cluster-Index), sodass die Anzahl der Lesungen natürlich über Gut und Böse hinausgeht.  Mal sehen, was wir jetzt in Abschnitten haben. <br><br><img src="https://habrastorage.org/webt/s0/hy/yx/s0hyyxxh7iny_jc3t3k48ca83hs.png"><br><br>  Im Allgemeinen war alles wie erwartet - ein neuer Abschnitt mit einer oberen Grenze erschien (denken Sie daran, dass die Randbedingungen für uns zum linken Abschnitt gehören) 01/01/2019 und ein leerer Abschnitt, in dem es andere Daten mit einem längeren Datum geben wird. <br><br>  Alles scheint in Ordnung zu sein, aber warum gibt es so viele Lesungen?  Wir schauen uns die obige Abbildung genau an und sehen, dass die Daten aus dem dritten Abschnitt, die in FG3 waren, in FG1 endeten, aber der nächste Abschnitt, leer, in FG3. <br><br>  2. Erstellen Sie eine Bühnentabelle. <br><br>  Um einen Abschnitt in eine Tabelle zu wechseln und umgekehrt, benötigen wir eine leere Tabelle, in der dieselben Einschränkungen und Indizes wie in unserer partitionierten Tabelle erstellt werden.  Die Tabelle sollte sich in derselben Dateigruppe befinden wie der Abschnitt, den wir dort „wechseln“ möchten.  Der erste (archivierte) Abschnitt befindet sich in FG1, daher erstellen wir eine Tabelle und einen Clusterindex an derselben Stelle: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>)) ; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  Sie müssen diese Tabelle nicht partitionieren. <br><br>  3. Jetzt können wir wechseln: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und hier ist was wir bekommen: <br><br><pre> <code class="sql hljs"> 4947,  16,  1,  59 <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SWITCH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> failed. There <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> identical <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">source</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'PartitionTest.dbo.pTest'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">'cix_stageTest_id'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> target <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'PartitionTest.dbo.stageTest'</span></span> .</code> </pre> <br>  Lustig, mal sehen, was wir in den Indizes haben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.name tblName, i.name indexName, c.name columnName, ic.is_included_column <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.indexes i <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.objects o <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> i.object_id = o.object_id <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.index_columns ic <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ic.object_id = i.object_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.index_id = i.index_id <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.columns c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ic.column_id = c.column_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.object_id = c.object_id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'pTest'</span></span>, <span class="hljs-string"><span class="hljs-string">'stageTest'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/8e/mf/1u/8emf1uqyw18p6rghqkv3enygfx0.png"><br><br>  Denken Sie daran, ich habe geschrieben, dass es notwendig ist, einen eindeutigen Clustered-Index für eine partitionierte Tabelle zu erstellen.  Genau deshalb war es notwendig.  Beim Erstellen eines eindeutigen Clustered-Index müsste SQL Server die Spalte, nach der wir die Tabelle partitionieren, explizit in den Index aufnehmen. Daher fügte er sie selbst hinzu und vergaß, dies zu sagen.  Und ich verstehe wirklich nicht warum. <br>  Im Allgemeinen ist das Problem jedoch verständlich. Wir erstellen den Clusterindex für die Stufentabelle neu. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, dt) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (drop_existing = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  Und jetzt versuchen wir noch einmal, den Abschnitt zu wechseln: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Ta Dam!  Der Abschnitt ist gewechselt, sehen Sie, was es uns gekostet hat: <br><br><pre> <code class="sql hljs">SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 3 ms.</code> </pre> <br>  Aber nichts.  Das Umschalten eines Abschnitts in eine leere Tabelle und umgekehrt (eine vollständige Tabelle in einen leeren Abschnitt) erfolgt ausschließlich mit Metadaten, und genau deshalb ist die Partitionierung eine sehr, sehr coole Sache. <br><br>  Mal sehen, was mit unseren Abschnitten los ist: <br><br><img src="https://habrastorage.org/webt/mb/7j/pl/mb7jpl32ekb7e-vgl3mjfczd1ru.png"><br><br>  Und bei ihnen ist alles super.  Im ersten Abschnitt sind keine Datensätze mehr vorhanden, die sicher für die stageTest-Tabelle übrig bleiben.  Wir können weitermachen <br><br>  4. Wir müssen nur noch unseren leeren ersten Abschnitt löschen.  Lassen Sie es uns tun und sehen, was passiert: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Dies ist in unserem Fall auch nur eine Operation für Metadaten.  Wir schauen uns die Abschnitte an: <br><br><img src="https://habrastorage.org/webt/ju/ce/lf/jucelfzq4upnfi3fqg_8snuurho.png"><br><br>  Wir haben sozusagen nur 3 Abschnitte, jeder in einer eigenen Dateigruppe.  Mission erfüllt.  Was könnte hier verbessert werden?  Zunächst möchte ich, dass sich die Grenzwerte auf die „richtigen“ Abschnitte beziehen, damit die Abschnitte alle Daten für 4 Monate enthalten.  Und ich würde gerne sehen, dass die Erstellung eines neuen Abschnitts weniger kostet.  Lesen Sie Daten zehnmal mehr als die Tabelle selbst - Fehlschlag. <br><br>  Mit dem ersten können wir jetzt nichts machen, aber mit dem zweiten werden wir es versuchen.  Erstellen wir einen neuen Abschnitt, der Daten vom 01.01.2019 bis zum 01.04.2019 und nicht bis zum Ende der Zeit enthält: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG2]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und wir sehen: <br><br><pre> <code class="sql hljs">SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms.</code> </pre> <br>  Ha!  Also ist diese Operation jetzt nur für Metadaten?  Ja, wenn Sie einen leeren Abschnitt "teilen" - dies ist eine Operation nur für Metadaten. Daher ist es die richtige Entscheidung, sowohl den linken als auch den rechten garantierten leeren Abschnitt beizubehalten und gegebenenfalls einen neuen auszuwählen - sie von dort "auszuschneiden". <br><br>  Nun wollen wir sehen, was passiert, wenn ich die Daten von der Stufentabelle zurück in die partitionierte Tabelle zurückgeben möchte.  Dazu brauche ich: <br><br><ol><li>  Erstellen Sie links einen neuen Abschnitt für Daten </li><li>  Wechseln Sie die Tabelle in diesen Abschnitt </li></ol><br>  Wir versuchen (und erinnern uns an diesen StageTest in FG1): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Wir sehen: <br><br><pre> <code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'ptest'. Scan count 1, logical reads 2939, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Nun, nicht schlecht, d.h.  Lesen Sie nur den linken Abschnitt (den wir teilen) und das wars.  Okay  Um eine nicht partitionierte nicht leere Tabelle in einen partitionierten Tabellenabschnitt umzuwandeln, muss die Quelltabelle Einschränkungen aufweisen, damit SQL Server weiß, dass alles in Ordnung ist und das Umschalten als Vorgang für Metadaten durchgeführt werden kann (anstatt alles in einer Zeile zu lesen und zu überprüfen, ob der Abschnitt den Bedingungen entspricht oder nicht) ): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> check_dt <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (dt &lt;= <span class="hljs-string"><span class="hljs-string">'20180401'</span></span>)</code> </pre> <br>  Versuch zu wechseln: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Statistik: <br><br><pre> <code class="sql hljs"> SQL Server Execution Times: CPU time = 15 ms, elapsed time = 39 ms.</code> </pre> <br>  Auch hier erfolgt die Operation nur für Metadaten.  Wir schauen uns an, was mit unseren Abschnitten passiert: <br><br><img src="https://habrastorage.org/webt/c2/wv/xe/c2wvxe_ex2iyvv3v7l9hvxokq70.png"><br><br>  Okay  Es scheint geklärt zu sein.  Und jetzt werden wir versuchen, das Funktions- und Partitionierungsschema neu zu erstellen (ich habe das Partitionierungsschema und die Funktion gelöscht, die Tabelle neu erstellt und neu gefüllt und den Clusterindex mithilfe des neuen Partitionierungsschemas neu erstellt): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Mal sehen, welche Abschnitte wir jetzt haben: <br><br><img src="https://habrastorage.org/webt/b6/mw/j2/b6mwj2konz7su7x_ng5eonsgukw.png"><br><br>  Nun haben wir drei „logische“ Abschnitte - vom Beginn der Zeit bis zum 04/01/2018 00:00:00 (nicht inklusive), vom 04/01/2018 00:00:00 (inklusive) bis zum 08/01/2018 00:00:00 ( nicht inklusive) und drittens alles, was größer oder gleich 01/01/2018 00:00:00 ist. <br><br>  Versuchen wir nun, dieselbe Aufgabe zum Archivieren von Daten auszuführen, die wir mit der vorherigen Partitionsfunktion ausgeführt haben. <br><br>  1. Fügen Sie einen neuen Abschnitt hinzu: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190101'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Wir schauen uns die Statistiken an: <br><br><pre> <code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'ptest'. Scan count 1, logical reads 3685, physical reads 0, read-ahead reads 4, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'Worktable'. Scan count 1, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Zumindest nicht vernünftig - lesen Sie nur den letzten Abschnitt.  Wir schauen uns an, was wir in Abschnitten haben: <br><br><img src="https://habrastorage.org/webt/1l/yr/i9/1lyri90cqmu969imje4edli1e7m.png"><br><br>  Beachten Sie, dass der abgeschlossene dritte Abschnitt in FG3 weiterhin vorhanden ist und in FG1 ein neuer leerer Abschnitt erstellt wurde. <br><br>  2. Wir erstellen eine Stufentabelle und den CORRECT-Clusterindex darauf <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>)) ; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, dt) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  3. Abschnitt wechseln <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Statistiken besagen, dass die Metadatenoperation wie folgt lautet: <br><br><pre> <code class="sql hljs">SQL Server Execution Times: CPU time = 0 ms, elapsed time = 5 ms.</code> </pre> <br>  Jetzt alles ohne Überraschungen. <br><br>  4. Entfernen Sie unnötige Abschnitte <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und hier haben wir eine Überraschung: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 27057, physical reads 0, read-ahead reads 251, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Wir schauen uns an, was wir mit den Abschnitten haben: <br><br><img src="https://habrastorage.org/webt/qn/_j/xr/qn_jxrttkmls8amaycjwxqrescu.png"><br><br>  Und hier wird klar: Unser Abschnitt Nr. 2 wurde von der fg2-Dateigruppe in die fg1-Dateigruppe verschoben.  Klasse.  Können wir etwas dagegen tun? <br><br>  Vielleicht müssen wir nur immer einen leeren Abschnitt haben und die Grenze zwischen dem "immer leeren" linken Abschnitt und dem Abschnitt, den wir zu einem anderen Tisch "gewechselt" haben, "zerstören". <br><br>  <b>Fazit:</b> <br><br><ol><li>  Verwenden Sie die vollständige Syntax zum Erstellen einer Partitionsfunktion. Verlassen Sie sich nicht auf die Standardwerte. Möglicherweise erhalten Sie nicht das, was Sie möchten. </li><li>  Halten Sie sich links und rechts im leeren Bereich - sie sind sehr nützlich für Sie, wenn Sie ein "Schiebefenster" organisieren. </li><li>  Nicht leere Abschnitte teilen und zusammenführen - es tut immer weh, vermeiden Sie dies, wenn möglich. </li><li>  Überprüfen Sie Ihre Abfragen. Wenn sie den Filter nicht nach der Spalte verwenden, nach der Sie die Tabelle partitionieren möchten, und Sie die Möglichkeit benötigen, Abschnitte zu wechseln, kann sich ihre Leistung erheblich verringern. </li><li>  Wenn Sie etwas tun möchten, testen Sie zuerst nicht in der Produktion. </li></ol><br>  Hoffe das Material war hilfreich.  Vielleicht hat es sich als zerknittert herausgestellt. Wenn Sie der Meinung sind, dass etwas von dem Erklärten nicht bekannt gegeben wird, schreiben Sie, ich werde versuchen, es zu beenden.  Vielen Dank für Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464665/">https://habr.com/ru/post/de464665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464651/index.html">Assembler-Codegenerator-Bibliothek für AVR-Mikrocontroller. Teil 5</a></li>
<li><a href="../de464655/index.html">Wie sich die Gehälter und die Popularität von Programmiersprachen in den letzten 2 Jahren verändert haben</a></li>
<li><a href="../de464657/index.html">Reverse Engineering elektrisches Gesims AM82TV</a></li>
<li><a href="../de464659/index.html">Anwendungssicherheit oder Einbetten von Sicherheit in die benutzerdefinierte Entwicklung. Persönliche Erfahrung bei AGIMA</a></li>
<li><a href="../de464661/index.html">Wem soll der Entwurf der technischen Umrüstung und des Wiederaufbaus anvertraut werden?</a></li>
<li><a href="../de464671/index.html">Empfangen Sie regelmäßig SMS an Viber- und Telegramm-Instant Messenger (über GoIP-Gateways).</a></li>
<li><a href="../de464673/index.html">TinyFL - Taschenlampentreiber für Mikrocontroller</a></li>
<li><a href="../de464675/index.html">Analyse der Lokalisierungsmechanismen der Anwendungsschnittstelle in Splunk</a></li>
<li><a href="../de464677/index.html">Investitionen an der Börse und damit verbundene Kosten: Wie hoch sind die Dienstleistungen eines Maklerunternehmens?</a></li>
<li><a href="../de464679/index.html">Voxgun - ein Service zum Erstellen professioneller Videoinhalte ohne zusätzlichen Aufwand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>