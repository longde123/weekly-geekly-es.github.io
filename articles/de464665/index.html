<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≥ üåπ ‚ö™Ô∏è Partitionierung in SQL Server üìµ üå¶Ô∏è üë©üèæ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Partitionierung ("Partitionierung") in SQL Server mit scheinbarer Einfachheit ("Was ist da - Sie verteilen die Tabelle und die Indizes nach Dateig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Partitionierung in SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464665/"> Die Partitionierung ("Partitionierung") in SQL Server mit scheinbarer Einfachheit ("Was ist da - Sie verteilen die Tabelle und die Indizes nach Dateigruppen, Sie erzielen Gewinn bei Verwaltung und Leistung") ist ein ziemlich umfangreiches Thema.  Im Folgenden werde ich versuchen zu beschreiben, wie ein Funktions- und Partitionsschema erstellt und angewendet wird und auf welche Probleme Sie m√∂glicherweise sto√üen.  Ich werde nicht √ºber die Vorteile sprechen, au√üer auf eine Sache - das Wechseln von Abschnitten, wenn Sie sofort einen gro√üen Datensatz aus einer Tabelle entfernen oder umgekehrt - sofort einen nicht weniger gro√üen Satz in eine Tabelle laden. <br><a name="habracut"></a><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">msdn</a> hei√üt es: ‚ÄûDaten aus partitionierten Tabellen und Indizes sind in Bl√∂cke unterteilt, die auf mehrere Dateigruppen in der Datenbank verteilt werden k√∂nnen.  Die Daten werden horizontal partitioniert, sodass Zeilengruppen einzelnen Abschnitten zugeordnet werden.  Alle Abschnitte desselben Index oder derselben Tabelle m√ºssen sich in derselben Datenbank befinden.  Eine Tabelle oder ein Index wird beim Ausf√ºhren von Abfragen oder Aktualisierungen von Daten als eine einzige logische Entit√§t betrachtet. ‚Äú <br><br>  Dort sind auch die Hauptvorteile aufgef√ºhrt: <br><br><ul><li>  √úbertragen und greifen Sie schnell und effizient auf Teilmengen von Daten zu, w√§hrend die Integrit√§t des Datensatzes erhalten bleibt </li><li>  Wartungsarbeiten k√∂nnen mit einem oder mehreren Abschnitten schneller durchgef√ºhrt werden. </li><li>  Sie k√∂nnen die Geschwindigkeit der Abfrageausf√ºhrung erh√∂hen, abh√§ngig von den Abfragen, die h√§ufig in Ihrer Hardwarekonfiguration ausgef√ºhrt werden. </li></ul><br>  Mit anderen Worten wird die Partitionierung f√ºr die horizontale Skalierung verwendet.  Die Tabellen / Indizes werden von verschiedenen Dateigruppen ‚Äûverteilt‚Äú, die sich auf verschiedenen physischen Datentr√§gern befinden k√∂nnen. Dies erh√∂ht den Verwaltungskomfort erheblich und erm√∂glicht es Ihnen theoretisch, die Leistung von Abfragen zu diesen Daten zu verbessern. Sie k√∂nnen entweder nur den gew√ºnschten Abschnitt (weniger Daten) lesen oder alles lesen parallel (Ger√§te sind unterschiedlich, schnell zu lesen).  In der Praxis ist alles etwas komplizierter und die Steigerung der Leistung von Abfragen an partitionierte Tabellen kann nur funktionieren, wenn Ihre Abfragen die Auswahl nach dem von Ihnen partitionierten Feld verwenden.  Wenn Sie noch keine Erfahrung mit partitionierten Tabellen haben, denken Sie daran, dass sich die Leistung Ihrer Abfragen m√∂glicherweise nicht √§ndert, sich jedoch nach der Partitionierung Ihrer Tabelle verschlechtern kann. <br><br>  Lassen Sie uns √ºber den absoluten Vorteil sprechen, den Sie definitiv mit der Partitionierung haben (den Sie aber auch nutzen m√ºssen) - dies ist eine garantierte Steigerung des Komforts bei der Verwaltung Ihrer Datenbank.  Sie haben beispielsweise eine Tabelle mit einer Milliarde Datens√§tzen, von denen 900 Millionen aus alten (‚Äûgeschlossenen‚Äú) Zeitr√§umen stammen und schreibgesch√ºtzt sind.  Mithilfe von Abschnitten k√∂nnen Sie diese alten Daten in eine separate schreibgesch√ºtzte Dateigruppe √ºbertragen, sichern und nicht mehr in alle Ihre t√§glichen Sicherungen ziehen. Die Geschwindigkeit beim Erstellen einer Sicherungskopie nimmt zu und die Gr√∂√üe nimmt ab.  Sie k√∂nnen den Index nicht √ºber die gesamte Tabelle, sondern √ºber ausgew√§hlte Abschnitte neu erstellen.  Dar√ºber hinaus steigt die Verf√ºgbarkeit Ihrer Datenbank. Wenn eines der Ger√§te mit der Dateigruppe mit dem Abschnitt ausf√§llt, ist der Rest weiterhin verf√ºgbar. <br><br>  Um die verbleibenden Vorteile zu erzielen (Abschnitte sofort wechseln; Produktivit√§t steigern), m√ºssen Sie die Datenstruktur speziell entwerfen und Abfragen schreiben. <br>  Ich sch√§tze, ich habe den Leser schon genug in Verlegenheit gebracht und jetzt kann ich mit dem √úben fortfahren. <br><br>  Erstellen Sie zun√§chst eine Datenbank mit 4 Dateigruppen, in der wir Experimente durchf√ºhren werden: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> [PartitionTest] <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> primary (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestPrimary'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestPrimary.mdf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg1] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG1'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG1.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg2] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG2'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG2.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg3] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG3'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG3.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'PTest_Log'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTest_log.ldf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">2048</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB); go <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> [PartitionTest] <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">recovery</span></span> simple; go <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> partitionTest;</code> </pre> <br>  Erstellen Sie eine Tabelle, die wir qu√§len werden. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ptest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>));</code> </pre> <br>  Und f√ºllen Sie es mit Daten f√ºr ein Jahr: <br><pre> <code class="sql hljs">;<span class="hljs-keyword"><span class="hljs-keyword">with</span></span> nums <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ptest(dt, dummy_int, dummy_char) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(hh, rn<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">'20180101'</span></span>) dt, rn dummy_int, <span class="hljs-string"><span class="hljs-string">'dummy char column #'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(rn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> row_number() <span class="hljs-keyword"><span class="hljs-keyword">over</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>))) rn <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nums n1, nums n2, nums n3, nums n4 )t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> rn &lt; <span class="hljs-number"><span class="hljs-number">8761</span></span></code> </pre> <br>  Jetzt enth√§lt die pTest-Tabelle einen Datensatz f√ºr jede Stunde des Jahres 2018. <br><br>  Jetzt m√ºssen Sie eine Partitionsfunktion erstellen, die die Randbedingungen f√ºr die Aufteilung von Daten in Abschnitte beschreibt.  SQL Server unterst√ºtzt nur die Bereichspartitionierung. <br><br>  Wir werden unsere Tabelle nach der Spalte dt (datetime) aufteilen, sodass jeder Abschnitt Daten f√ºr 4 Monate enth√§lt (hier habe ich es vermasselt - tats√§chlich enth√§lt der erste Abschnitt Daten f√ºr 3, der zweite f√ºr 4, der dritte f√ºr 5 Monate, aber zu Demonstrationszwecken - dies ist kein Problem) <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Alles scheint normal zu sein, aber hier habe ich absichtlich einen ‚ÄûFehler‚Äú gemacht.  Wenn Sie sich die Syntax in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">msdn</a> ansehen, werden Sie feststellen, dass Sie w√§hrend der Erstellung angeben k√∂nnen, zu welchem ‚Äã‚ÄãAbschnitt der angegebene Rahmen geh√∂ren soll - links oder rechts.  Aus unbekannten Gr√ºnden bezieht sich der angegebene Rand standardm√§√üig auf den Abschnitt "links". In meinem Fall w√§re es daher richtig, eine Partitionsfunktion wie folgt zu erstellen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  W√§hrend ich tats√§chlich ausgef√ºhrt habe: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Wir werden jedoch sp√§ter darauf zur√ºckkommen und unsere Partitionsfunktion neu erstellen.  In der Zwischenzeit fahren wir mit dem fort, was passiert ist, um zu verstehen, was passiert ist und warum es nicht sehr gut f√ºr uns ist. <br><br>  Nach dem Erstellen der Partitionsfunktion m√ºssen Sie ein Partitionsschema erstellen.  Es bindet Abschnitte eindeutig an Dateigruppen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> pfTest <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ([FG1], [FG2], [FG3])</code> </pre> <br>  Wie Sie sehen k√∂nnen, befinden sich alle drei Abschnitte in verschiedenen Dateigruppen.  Jetzt ist es Zeit, unsere Tabelle zu partitionieren.  Dazu m√ºssen wir einen Clustered-Index erstellen und anstelle der Dateigruppe, in der er sich befinden soll, das Partitionierungsschema angeben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_pTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> psTest(dt)</code> </pre> <br>  Und auch hier habe ich im aktuellen Schema einen ‚ÄûFehler‚Äú gemacht - ich h√§tte sehr gut einen eindeutigen Clustered-Index f√ºr diese Spalte erstellen k√∂nnen. Wenn Sie jedoch einen eindeutigen Index erstellen, sollte die zur Partitionierung verwendete Spalte in den Index aufgenommen werden.  Und ich m√∂chte zeigen, was Sie mit dieser Konfiguration erleben k√∂nnen. <br><br>  Nun wollen wir sehen, was wir in der aktuellen Konfiguration haben (die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfrage wird von hier √ºbernommen</a> ): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sc.name + N<span class="hljs-string"><span class="hljs-string">'.'</span></span> + so.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Schema.Table], si.index_id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], si.type_desc <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Structure], si.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>], stat.row_count <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Rows</span></span>], stat.in_row_reserved_page_count * <span class="hljs-number"><span class="hljs-number">8.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> GB], stat.lob_reserved_page_count * <span class="hljs-number"><span class="hljs-number">8.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">LOB</span></span> GB], p.partition_number <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Partition</span></span> <span class="hljs-comment"><span class="hljs-comment">#], pf.name as [Partition Function], CASE pf.boundary_value_on_right WHEN 1 then 'Right / Lower' ELSE 'Left / Upper' END as [Boundary Type], prv.value as [Boundary Point], fg.name as [Filegroup] FROM sys.partition_functions AS pf JOIN sys.partition_schemes as ps on ps.function_id=pf.function_id JOIN sys.indexes as si on si.data_space_id=ps.data_space_id JOIN sys.objects as so on si.object_id = so.object_id JOIN sys.schemas as sc on so.schema_id = sc.schema_id JOIN sys.partitions as p on si.object_id=p.object_id and si.index_id=p.index_id LEFT JOIN sys.partition_range_values as prv on prv.function_id=pf.function_id and p.partition_number= CASE pf.boundary_value_on_right WHEN 1 THEN prv.boundary_id + 1 ELSE prv.boundary_id END /* For left-based functions, partition_number = boundary_id, for right-based functions we need to add 1 */ JOIN sys.dm_db_partition_stats as stat on stat.object_id=p.object_id and stat.index_id=p.index_id and stat.index_id=p.index_id and stat.partition_id=p.partition_id and stat.partition_number=p.partition_number JOIN sys.allocation_units as au on au.container_id = p.hobt_id and au.type_desc ='IN_ROW_DATA' /* Avoiding double rows for columnstore indexes. */ /* We can pick up LOB page count from partition_stats */ JOIN sys.filegroups as fg on fg.data_space_id = au.data_space_id ORDER BY [Schema.Table], [Index ID], [Partition Function], [Partition #];</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/72/qu/op/72quopaqu1glcalpur92qrwy6eo.png"><br><br>  So haben wir drei nicht sehr erfolgreiche Abschnitte erhalten - der erste speichert Daten vom Beginn der Zeit bis einschlie√ülich 04/01/2018 00:00:00, der zweite - vom 01/01/2018 00:00:01 bis einschlie√ülich 08/01/2018 00:00:00 einschlie√ülich der dritte vom 08/01/2018 00:00:01 bis zum Ende der Welt (ich habe absichtlich den Bruchteil einer Sekunde verpasst, weil ich mich nicht erinnere, in welche Abstufung SQL Server diese Br√ºche schreibt, aber die Bedeutung korrekt √ºbertragen wird). <br>  Erstellen Sie nun einen nicht gruppierten Index f√ºr das Feld dummy_int, der nach demselben Partitionierungsschema ‚Äûausgerichtet‚Äú ist. <br><br><div class="spoiler">  <b class="spoiler_title">Warum brauchen wir einen ausgerichteten Index?</b> <div class="spoiler_text">  Wir ben√∂tigen einen ausgerichteten Index, damit wir einen Abschnitt (Schalter) wechseln k√∂nnen - und dies ist eine dieser Operationen, f√ºr die sie sich h√§ufig mit der Partitionierung besch√§ftigen.  Wenn die Tabelle mindestens einen nicht ausgerichteten Index enth√§lt, k√∂nnen Sie den Abschnitt nicht wechseln <br></div></div><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> nonclustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> nix_pTest_dummyINT <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest(dummy_int) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> psTest(dt);</code> </pre> <br>  Und lassen Sie uns sehen, warum ich gesagt habe, dass Ihre Abfragen nach der Implementierung von Abschnitten langsamer werden k√∂nnen.  F√ºhren Sie die Anforderung aus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy_int = <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und sehen wir uns die Ausf√ºhrungsstatistik an: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 3, logical reads 6, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Und der Umsetzungsplan: <br><br><img src="https://habrastorage.org/webt/-i/ey/ay/-ieyay17s-rifng9eaij7bobfes.png"><br><br>  Da unser Index bedingt durch Abschnitte ‚Äûausgerichtet‚Äú ist, hat jeder Abschnitt seinen eigenen Index, der mit Indizes f√ºr andere Abschnitte ‚Äûnicht verbunden‚Äú ist.  Wir haben dem Feld, nach dem der Index partitioniert ist, keine Bedingungen auferlegt, sodass SQL Server gezwungen ist, die Indexsuche in jedem Abschnitt auszuf√ºhren, n√§mlich 3 Indexsuche anstelle von einem. <br><br>  Versuchen wir, einen Abschnitt auszuschlie√üen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy_int = <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> dt &lt; <span class="hljs-string"><span class="hljs-string">'20180801'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und sehen wir uns die Ausf√ºhrungsstatistik an: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 2, logical reads 4, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Ja, ein Abschnitt wurde ausgeschlossen und die Suche nach dem gew√ºnschten Wert wurde in nur zwei Abschnitten durchgef√ºhrt. <br>  Dies muss bei der Entscheidung f√ºr eine Partitionierung beachtet werden.  Wenn Sie Abfragen haben, die keine Einschr√§nkung f√ºr das Feld verwenden, nach dem die Tabelle partitioniert ist, liegt m√∂glicherweise ein Problem vor. <br><br>  Wir brauchen den nicht gruppierten Index nicht mehr, also l√∂sche ich ihn <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> nix_pTest_dummyINT <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Und warum wurde ein Nicht-Cluster-Index ben√∂tigt?</b> <div class="spoiler_text">  Im Allgemeinen brauchte ich es nicht, ich konnte dasselbe mit dem Cluster-Index anzeigen. Ich wei√ü nicht, warum ich es erstellt habe, aber da ich es erstellt und Screenshots erstellt habe, verschwinden Sie nicht <br></div></div><br>  Stellen Sie sich nun das folgende Szenario vor: Wir archivieren die Daten aus dieser Tabelle alle 4 Monate - wir entfernen die alten Daten und f√ºgen einen Abschnitt f√ºr die n√§chsten vier Monate hinzu (die Organisation des ‚ÄûSchiebefensters‚Äú ist in msdn und dem Haufen von Blogs beschrieben). <br><br>  Wir unterteilen die Aufgabe in kleine und verst√§ndliche Unteraufgaben: <br><br><ol><li>  F√ºgen Sie einen Abschnitt f√ºr Daten vom 01.01.2019 bis zum 01.04.2019 hinzu </li><li>  Erstellen Sie eine leere B√ºhnentabelle </li><li>  Schalten Sie den Datenbereich bis zum 04/01/2018 in der Stufentabelle </li><li>  Entfernen Sie den leeren Bereich </li></ol><br>  Lass uns gehen: <br><br>  1. Wir geben bekannt, dass der neue Abschnitt in der FG1-Dateigruppe erstellt wird, da er bald von uns befreit wird: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1];</code> </pre> <br>  √Ñndern Sie die Partitionsfunktion, indem Sie einen neuen Rahmen hinzuf√ºgen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190101'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Wir schauen uns die Statistiken an: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 76171, physical reads 0, read-ahead reads 753, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'Worktable'. Scan count 1, logical reads 7440, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Die Tabelle enth√§lt 8809 Seiten (Cluster-Index), sodass die Anzahl der Lesungen nat√ºrlich √ºber Gut und B√∂se hinausgeht.  Mal sehen, was wir jetzt in Abschnitten haben. <br><br><img src="https://habrastorage.org/webt/s0/hy/yx/s0hyyxxh7iny_jc3t3k48ca83hs.png"><br><br>  Im Allgemeinen war alles wie erwartet - ein neuer Abschnitt mit einer oberen Grenze erschien (denken Sie daran, dass die Randbedingungen f√ºr uns zum linken Abschnitt geh√∂ren) 01/01/2019 und ein leerer Abschnitt, in dem es andere Daten mit einem l√§ngeren Datum geben wird. <br><br>  Alles scheint in Ordnung zu sein, aber warum gibt es so viele Lesungen?  Wir schauen uns die obige Abbildung genau an und sehen, dass die Daten aus dem dritten Abschnitt, die in FG3 waren, in FG1 endeten, aber der n√§chste Abschnitt, leer, in FG3. <br><br>  2. Erstellen Sie eine B√ºhnentabelle. <br><br>  Um einen Abschnitt in eine Tabelle zu wechseln und umgekehrt, ben√∂tigen wir eine leere Tabelle, in der dieselben Einschr√§nkungen und Indizes wie in unserer partitionierten Tabelle erstellt werden.  Die Tabelle sollte sich in derselben Dateigruppe befinden wie der Abschnitt, den wir dort ‚Äûwechseln‚Äú m√∂chten.  Der erste (archivierte) Abschnitt befindet sich in FG1, daher erstellen wir eine Tabelle und einen Clusterindex an derselben Stelle: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>)) ; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  Sie m√ºssen diese Tabelle nicht partitionieren. <br><br>  3. Jetzt k√∂nnen wir wechseln: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und hier ist was wir bekommen: <br><br><pre> <code class="sql hljs"> 4947,  16,  1,  59 <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SWITCH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> failed. There <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> identical <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">source</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'PartitionTest.dbo.pTest'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">'cix_stageTest_id'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> target <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'PartitionTest.dbo.stageTest'</span></span> .</code> </pre> <br>  Lustig, mal sehen, was wir in den Indizes haben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.name tblName, i.name indexName, c.name columnName, ic.is_included_column <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.indexes i <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.objects o <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> i.object_id = o.object_id <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.index_columns ic <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ic.object_id = i.object_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.index_id = i.index_id <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.columns c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ic.column_id = c.column_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.object_id = c.object_id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'pTest'</span></span>, <span class="hljs-string"><span class="hljs-string">'stageTest'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/8e/mf/1u/8emf1uqyw18p6rghqkv3enygfx0.png"><br><br>  Denken Sie daran, ich habe geschrieben, dass es notwendig ist, einen eindeutigen Clustered-Index f√ºr eine partitionierte Tabelle zu erstellen.  Genau deshalb war es notwendig.  Beim Erstellen eines eindeutigen Clustered-Index m√ºsste SQL Server die Spalte, nach der wir die Tabelle partitionieren, explizit in den Index aufnehmen. Daher f√ºgte er sie selbst hinzu und verga√ü, dies zu sagen.  Und ich verstehe wirklich nicht warum. <br>  Im Allgemeinen ist das Problem jedoch verst√§ndlich. Wir erstellen den Clusterindex f√ºr die Stufentabelle neu. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, dt) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (drop_existing = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  Und jetzt versuchen wir noch einmal, den Abschnitt zu wechseln: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Ta Dam!  Der Abschnitt ist gewechselt, sehen Sie, was es uns gekostet hat: <br><br><pre> <code class="sql hljs">SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 3 ms.</code> </pre> <br>  Aber nichts.  Das Umschalten eines Abschnitts in eine leere Tabelle und umgekehrt (eine vollst√§ndige Tabelle in einen leeren Abschnitt) erfolgt ausschlie√ülich mit Metadaten, und genau deshalb ist die Partitionierung eine sehr, sehr coole Sache. <br><br>  Mal sehen, was mit unseren Abschnitten los ist: <br><br><img src="https://habrastorage.org/webt/mb/7j/pl/mb7jpl32ekb7e-vgl3mjfczd1ru.png"><br><br>  Und bei ihnen ist alles super.  Im ersten Abschnitt sind keine Datens√§tze mehr vorhanden, die sicher f√ºr die stageTest-Tabelle √ºbrig bleiben.  Wir k√∂nnen weitermachen <br><br>  4. Wir m√ºssen nur noch unseren leeren ersten Abschnitt l√∂schen.  Lassen Sie es uns tun und sehen, was passiert: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Dies ist in unserem Fall auch nur eine Operation f√ºr Metadaten.  Wir schauen uns die Abschnitte an: <br><br><img src="https://habrastorage.org/webt/ju/ce/lf/jucelfzq4upnfi3fqg_8snuurho.png"><br><br>  Wir haben sozusagen nur 3 Abschnitte, jeder in einer eigenen Dateigruppe.  Mission erf√ºllt.  Was k√∂nnte hier verbessert werden?  Zun√§chst m√∂chte ich, dass sich die Grenzwerte auf die ‚Äûrichtigen‚Äú Abschnitte beziehen, damit die Abschnitte alle Daten f√ºr 4 Monate enthalten.  Und ich w√ºrde gerne sehen, dass die Erstellung eines neuen Abschnitts weniger kostet.  Lesen Sie Daten zehnmal mehr als die Tabelle selbst - Fehlschlag. <br><br>  Mit dem ersten k√∂nnen wir jetzt nichts machen, aber mit dem zweiten werden wir es versuchen.  Erstellen wir einen neuen Abschnitt, der Daten vom 01.01.2019 bis zum 01.04.2019 und nicht bis zum Ende der Zeit enth√§lt: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG2]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und wir sehen: <br><br><pre> <code class="sql hljs">SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms.</code> </pre> <br>  Ha!  Also ist diese Operation jetzt nur f√ºr Metadaten?  Ja, wenn Sie einen leeren Abschnitt "teilen" - dies ist eine Operation nur f√ºr Metadaten. Daher ist es die richtige Entscheidung, sowohl den linken als auch den rechten garantierten leeren Abschnitt beizubehalten und gegebenenfalls einen neuen auszuw√§hlen - sie von dort "auszuschneiden". <br><br>  Nun wollen wir sehen, was passiert, wenn ich die Daten von der Stufentabelle zur√ºck in die partitionierte Tabelle zur√ºckgeben m√∂chte.  Dazu brauche ich: <br><br><ol><li>  Erstellen Sie links einen neuen Abschnitt f√ºr Daten </li><li>  Wechseln Sie die Tabelle in diesen Abschnitt </li></ol><br>  Wir versuchen (und erinnern uns an diesen StageTest in FG1): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Wir sehen: <br><br><pre> <code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'ptest'. Scan count 1, logical reads 2939, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Nun, nicht schlecht, d.h.  Lesen Sie nur den linken Abschnitt (den wir teilen) und das wars.  Okay  Um eine nicht partitionierte nicht leere Tabelle in einen partitionierten Tabellenabschnitt umzuwandeln, muss die Quelltabelle Einschr√§nkungen aufweisen, damit SQL Server wei√ü, dass alles in Ordnung ist und das Umschalten als Vorgang f√ºr Metadaten durchgef√ºhrt werden kann (anstatt alles in einer Zeile zu lesen und zu √ºberpr√ºfen, ob der Abschnitt den Bedingungen entspricht oder nicht) ): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> check_dt <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (dt &lt;= <span class="hljs-string"><span class="hljs-string">'20180401'</span></span>)</code> </pre> <br>  Versuch zu wechseln: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Statistik: <br><br><pre> <code class="sql hljs"> SQL Server Execution Times: CPU time = 15 ms, elapsed time = 39 ms.</code> </pre> <br>  Auch hier erfolgt die Operation nur f√ºr Metadaten.  Wir schauen uns an, was mit unseren Abschnitten passiert: <br><br><img src="https://habrastorage.org/webt/c2/wv/xe/c2wvxe_ex2iyvv3v7l9hvxokq70.png"><br><br>  Okay  Es scheint gekl√§rt zu sein.  Und jetzt werden wir versuchen, das Funktions- und Partitionierungsschema neu zu erstellen (ich habe das Partitionierungsschema und die Funktion gel√∂scht, die Tabelle neu erstellt und neu gef√ºllt und den Clusterindex mithilfe des neuen Partitionierungsschemas neu erstellt): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br>  Mal sehen, welche Abschnitte wir jetzt haben: <br><br><img src="https://habrastorage.org/webt/b6/mw/j2/b6mwj2konz7su7x_ng5eonsgukw.png"><br><br>  Nun haben wir drei ‚Äûlogische‚Äú Abschnitte - vom Beginn der Zeit bis zum 04/01/2018 00:00:00 (nicht inklusive), vom 04/01/2018 00:00:00 (inklusive) bis zum 08/01/2018 00:00:00 ( nicht inklusive) und drittens alles, was gr√∂√üer oder gleich 01/01/2018 00:00:00 ist. <br><br>  Versuchen wir nun, dieselbe Aufgabe zum Archivieren von Daten auszuf√ºhren, die wir mit der vorherigen Partitionsfunktion ausgef√ºhrt haben. <br><br>  1. F√ºgen Sie einen neuen Abschnitt hinzu: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190101'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Wir schauen uns die Statistiken an: <br><br><pre> <code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'ptest'. Scan count 1, logical reads 3685, physical reads 0, read-ahead reads 4, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'Worktable'. Scan count 1, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Zumindest nicht vern√ºnftig - lesen Sie nur den letzten Abschnitt.  Wir schauen uns an, was wir in Abschnitten haben: <br><br><img src="https://habrastorage.org/webt/1l/yr/i9/1lyri90cqmu969imje4edli1e7m.png"><br><br>  Beachten Sie, dass der abgeschlossene dritte Abschnitt in FG3 weiterhin vorhanden ist und in FG1 ein neuer leerer Abschnitt erstellt wurde. <br><br>  2. Wir erstellen eine Stufentabelle und den CORRECT-Clusterindex darauf <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>)) ; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, dt) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  3. Abschnitt wechseln <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Statistiken besagen, dass die Metadatenoperation wie folgt lautet: <br><br><pre> <code class="sql hljs">SQL Server Execution Times: CPU time = 0 ms, elapsed time = 5 ms.</code> </pre> <br>  Jetzt alles ohne √úberraschungen. <br><br>  4. Entfernen Sie unn√∂tige Abschnitte <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br>  Und hier haben wir eine √úberraschung: <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 27057, physical reads 0, read-ahead reads 251, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br>  Wir schauen uns an, was wir mit den Abschnitten haben: <br><br><img src="https://habrastorage.org/webt/qn/_j/xr/qn_jxrttkmls8amaycjwxqrescu.png"><br><br>  Und hier wird klar: Unser Abschnitt Nr. 2 wurde von der fg2-Dateigruppe in die fg1-Dateigruppe verschoben.  Klasse.  K√∂nnen wir etwas dagegen tun? <br><br>  Vielleicht m√ºssen wir nur immer einen leeren Abschnitt haben und die Grenze zwischen dem "immer leeren" linken Abschnitt und dem Abschnitt, den wir zu einem anderen Tisch "gewechselt" haben, "zerst√∂ren". <br><br>  <b>Fazit:</b> <br><br><ol><li>  Verwenden Sie die vollst√§ndige Syntax zum Erstellen einer Partitionsfunktion. Verlassen Sie sich nicht auf die Standardwerte. M√∂glicherweise erhalten Sie nicht das, was Sie m√∂chten. </li><li>  Halten Sie sich links und rechts im leeren Bereich - sie sind sehr n√ºtzlich f√ºr Sie, wenn Sie ein "Schiebefenster" organisieren. </li><li>  Nicht leere Abschnitte teilen und zusammenf√ºhren - es tut immer weh, vermeiden Sie dies, wenn m√∂glich. </li><li>  √úberpr√ºfen Sie Ihre Abfragen. Wenn sie den Filter nicht nach der Spalte verwenden, nach der Sie die Tabelle partitionieren m√∂chten, und Sie die M√∂glichkeit ben√∂tigen, Abschnitte zu wechseln, kann sich ihre Leistung erheblich verringern. </li><li>  Wenn Sie etwas tun m√∂chten, testen Sie zuerst nicht in der Produktion. </li></ol><br>  Hoffe das Material war hilfreich.  Vielleicht hat es sich als zerknittert herausgestellt. Wenn Sie der Meinung sind, dass etwas von dem Erkl√§rten nicht bekannt gegeben wird, schreiben Sie, ich werde versuchen, es zu beenden.  Vielen Dank f√ºr Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464665/">https://habr.com/ru/post/de464665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464651/index.html">Assembler-Codegenerator-Bibliothek f√ºr AVR-Mikrocontroller. Teil 5</a></li>
<li><a href="../de464655/index.html">Wie sich die Geh√§lter und die Popularit√§t von Programmiersprachen in den letzten 2 Jahren ver√§ndert haben</a></li>
<li><a href="../de464657/index.html">Reverse Engineering elektrisches Gesims AM82TV</a></li>
<li><a href="../de464659/index.html">Anwendungssicherheit oder Einbetten von Sicherheit in die benutzerdefinierte Entwicklung. Pers√∂nliche Erfahrung bei AGIMA</a></li>
<li><a href="../de464661/index.html">Wem soll der Entwurf der technischen Umr√ºstung und des Wiederaufbaus anvertraut werden?</a></li>
<li><a href="../de464671/index.html">Empfangen Sie regelm√§√üig SMS an Viber- und Telegramm-Instant Messenger (√ºber GoIP-Gateways).</a></li>
<li><a href="../de464673/index.html">TinyFL - Taschenlampentreiber f√ºr Mikrocontroller</a></li>
<li><a href="../de464675/index.html">Analyse der Lokalisierungsmechanismen der Anwendungsschnittstelle in Splunk</a></li>
<li><a href="../de464677/index.html">Investitionen an der B√∂rse und damit verbundene Kosten: Wie hoch sind die Dienstleistungen eines Maklerunternehmens?</a></li>
<li><a href="../de464679/index.html">Voxgun - ein Service zum Erstellen professioneller Videoinhalte ohne zus√§tzlichen Aufwand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>