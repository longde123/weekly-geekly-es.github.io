<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏿 🧝🏽 🐀 Konsekuensi penulisan ulang komponen Firefox di Rust 🤞🏽 💪🏿 🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya dalam seri ini, kami membahas keamanan memori dan keamanan utas di Rust. Dalam artikel terakhir ini, kita akan melihat implik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konsekuensi penulisan ulang komponen Firefox di Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445670/">  <i>Dalam artikel sebelumnya dalam seri ini, kami membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memori</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan utas</a> di Rust.</i>  <i>Dalam artikel terakhir ini, kita akan melihat implikasi aplikasi Rust nyata menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek Quantum CSS</a> .</i> <br><br>  Mesin CSS menerapkan aturan CSS ke halaman.  Ini adalah proses menurun yang menurunkan pohon DOM, setelah menghitung CSS induk, gaya anak dapat dihitung secara independen: ideal untuk komputasi paralel.  Pada 2017, Mozilla melakukan dua upaya untuk memparalelkan sistem gaya menggunakan C ++.  Keduanya gagal. <br><br>  Pengembangan CSS kuantum telah mulai meningkatkan produktivitas.  Meningkatkan keamanan hanyalah efek samping yang baik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb1/391/190/fb139119031a0bf7077a9b5dd8381b77.jpg"></div><a name="habracut"></a><br>  Ada koneksi tertentu antara perlindungan memori dan bug keamanan informasi.  Oleh karena itu, kami berharap menggunakan Rust akan mengurangi permukaan serangan di Firefox.  Artikel ini akan melihat potensi kerentanan yang telah diidentifikasi dalam mesin CSS sejak rilis awal Firefox pada tahun 2002.  Kemudian lihat apa yang bisa dan tidak bisa dicegah dengan Rust. <br><br>  Sepanjang waktu, 69 kesalahan keamanan telah terdeteksi di komponen CSS Firefox.  Jika kami memiliki mesin waktu dan kami dapat menulisnya Rust sejak awal, maka 51 (73,9%) kesalahan akan menjadi tidak mungkin.  Meskipun Rust membuat penulisan kode yang baik lebih mudah, ia juga tidak menawarkan perlindungan absolut. <br><br><h1>  Karat </h1><br>  Rust adalah bahasa pemrograman sistem modern yang aman untuk jenis dan memori.  Sebagai efek samping dari jaminan keamanan ini, program Rust juga aman saat dikompilasi.  Karenanya, Rust sangat cocok untuk: <br><br><ul><li>  pemrosesan yang aman dari data yang masuk tidak dapat diandalkan; <br></li><li>  konkurensi untuk meningkatkan kinerja; <br></li><li>  integrasi masing-masing komponen ke dalam basis kode yang ada. </li></ul><br>  Namun, Rust tidak secara eksplisit memperbaiki beberapa kelas kesalahan, terutama kesalahan kebenaran.  Bahkan, ketika teknisi kami menulis ulang Quantum CSS, mereka secara tidak sengaja mengulangi bug keamanan kritis, yang sebelumnya diperbaiki dalam kode C ++, mereka secara tidak sengaja menghapus perbaikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug 641731</a> , yang memungkinkan kebocoran sejarah global melalui SVG.  Kesalahan telah didaftarkan ulang sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug 1420001</a> .  Kebocoran riwayat dinilai sebagai kerentanan keamanan kritis.  Perbaikan awal adalah pemeriksaan tambahan untuk melihat apakah dokumen SVG adalah gambar.  Sayangnya, pemeriksaan ini tidak terjawab saat menulis ulang kode. <br><br>  Meskipun pengujian otomatis harus menemukan pelanggaran aturan <code>:visited</code> seperti ini, dalam praktiknya mereka tidak menemukan kesalahan ini.  Untuk mempercepat pengujian otomatis, kami menonaktifkan sementara mekanisme yang menguji fitur ini - tes tidak terlalu berguna jika tidak dilakukan.  Risiko menerapkan kembali kesalahan logis dapat dikurangi dengan cakupan tes yang baik.  Tetapi masih ada bahaya kesalahan logis baru. <br><br>  Ketika seorang pengembang menjadi akrab dengan Rust, kodenya menjadi lebih aman.  Meskipun Rust tidak mencegah semua kemungkinan kerentanan, ia memperbaiki seluruh kelas bug paling serius. <br><br><h1>  Kesalahan Keamanan CSS Quantum </h1><br>  Secara umum, secara default, Rust mencegah kesalahan yang terkait dengan memori, batas, variabel null / tidak diinisialisasi, dan kelebihan bilangan bulat.  Bug non-standar yang disebutkan di atas tetap memungkinkan: kerusakan terjadi karena alokasi memori yang gagal. <br><br><h3>  Kesalahan Keamanan berdasarkan Kategori </h3><br><blockquote><ul><li>  Memori: 32 <br></li><li>  Batas: 12 <br></li><li>  Implementasi: 12 <br></li><li>  Null: 7 <br></li><li>  Stack Overflow: 3 <br></li><li>  Overflow bilangan bulat: 2 <br></li><li>  Lainnya: 1 </li></ul></blockquote>  Dalam analisis kami, semua bug terkait dengan keamanan, tetapi hanya 43 yang menerima peringkat resmi (ditugaskan oleh insinyur keamanan Mozilla berdasarkan asumsi yang memenuhi syarat tentang "eksploitasi").  Bug biasa dapat menunjukkan fungsi yang hilang atau semacam kerusakan, yang tidak selalu menyebabkan kebocoran data atau perubahan perilaku.  Kesalahan keamanan resmi berkisar dari kepentingan rendah (jika ada batasan kuat pada permukaan serangan) hingga kerentanan kritis (memungkinkan penyerang menjalankan kode arbitrer pada platform pengguna). <br><br>  Kerentanan memori sering diklasifikasikan sebagai masalah keamanan serius.  Dari 34 masalah kritis / serius, 32 terkait dengan memori. <br><br><h3>  Distribusi keparahan bug keamanan </h3><br><blockquote><ul><li>  Total: 70 <br></li><li>  Kesalahan Keamanan: 43 <br></li><li>  Kritis / Serius: 34 <br></li><li>  Fixed Rust: 32 </li></ul></blockquote><h1>  Membandingkan Rust dan C ++ </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bug 955913</a> - tumpukan buffer overflow dalam fungsi <code>GetCustomPropertyNameAt</code> .  Kode menggunakan variabel yang salah untuk pengindeksan, yang menyebabkan interpretasi memori setelah akhir array.  Ini dapat menyebabkan kerusakan saat mengakses pointer buruk atau menyalin memori ke string yang diteruskan ke komponen lain. <br><br>  Urutan semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti CSS</a> (termasuk kustom, mis. Kustom) disimpan dalam larik <code>mOrder</code> .  Setiap elemen diwakili oleh nilai properti CSS, atau, dalam kasus properti khusus, nilai yang dimulai dengan <code>eCSSProperty_COUNT</code> (jumlah total properti CSS non-kustom).  Untuk mendapatkan nama properti khusus, Anda harus terlebih dahulu mendapatkan nilai dari <code>mOrder</code> , dan kemudian mengakses nama dalam indeks yang sesuai dari array <code>mVariableOrder</code> , yang menyimpan nama-nama properti kustom secara berurutan. <br><br><h3>  Kode C ++ yang Rentan: </h3><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCustomPropertyNameAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aIndex, nsAString&amp; aResult)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ MOZ_ASSERT(mOrder[aIndex] &gt;= eCSSProperty_COUNT); aResult.Truncate(); aResult.AppendLiteral(<span class="hljs-string"><span class="hljs-string">"var-"</span></span>); aResult.Append(mVariableOrder[aIndex]);</code> </pre> <br>  Masalahnya terjadi pada baris 6 saat menggunakan <code>aIndex</code> untuk mengakses elemen dari array <code>mVariableOrder</code> .  Faktanya adalah <code>aIndex</code> harus digunakan dengan array <code>mOrder</code> , bukan <code>mVariableOrder</code> .  Elemen yang sesuai untuk properti kustom yang diwakili oleh <code>aIndex</code> di <code>mOrder</code> sebenarnya adalah <code>mOrder[aIndex] - eCSSProperty_COUNT</code> . <br><br><h3>  Kode C ++ yang diperbaiki: </h3><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> Get </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomPropertyNameAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aIndex, nsAString&amp; aResult)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ MOZ_ASSERT(mOrder[aIndex] &gt;= eCSSProperty_COUNT); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> variableIndex = mOrder[aIndex] - eCSSProperty_COUNT; aResult.Truncate(); aResult.AppendLiteral(<span class="hljs-string"><span class="hljs-string">"var-"</span></span>); aResult.Append(mVariableOrder[variableIndex]); }</code> </pre> <br><h3>  Kode Rust yang sesuai </h3><br>  Meskipun Rust agak mirip dengan C ++, ia menggunakan abstraksi dan struktur data lainnya.  Kode karat akan sangat berbeda dari C ++ (lihat di bawah untuk lebih jelasnya).  Pertama, mari kita lihat apa yang terjadi jika kode rentan diterjemahkan sejelas mungkin: <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCustomPropertyNameAt</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, aIndex: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mOrder[aIndex] &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.eCSSProperty_COUNT); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-string"><span class="hljs-string">"var-"</span></span>.to_string(); result += &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mVariableOrder[aIndex]; result }</code> </pre> <br>  Compiler Rust akan menerima kode ini karena panjang vektor tidak dapat ditentukan sebelum eksekusi.  Tidak seperti array, panjang yang harus diketahui, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tipe Vec</a> di Rust memiliki ukuran dinamis.  Namun, pemeriksaan batas dibangun ke dalam implementasi vektor perpustakaan standar.  Jika indeks yang tidak valid muncul, program segera berakhir dengan cara yang terkontrol, mencegah akses yang tidak sah. <br><br>  <a href="">Kode nyata</a> Quantum CSS menggunakan struktur data yang sangat berbeda, sehingga tidak ada padanan yang pasti.  Sebagai contoh, kami menggunakan struktur data bawaan Rust yang kuat untuk menyatukan pengaturan dan nama properti.  Ini menghilangkan kebutuhan untuk mempertahankan dua array independen.  Struktur data karat juga meningkatkan enkapsulasi data dan mengurangi kemungkinan kesalahan logis semacam itu.  Karena kode harus berinteraksi dengan kode C ++ di bagian lain browser, fungsi <code>GetCustomPropertyNameAt</code> baru tidak terlihat seperti kode idiomatik Rust.  Tapi itu masih memberikan semua jaminan keamanan, sambil memberikan abstraksi yang lebih dimengerti dari data yang mendasarinya. <br><br><h1>  tl; dr </h1><br>  Karena kerentanan sering dikaitkan dengan pelanggaran keamanan memori, kode Rust harus secara signifikan mengurangi jumlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CVE</a> kritis.  Tetapi bahkan Rust tidak sempurna.  Pengembang masih perlu melacak kesalahan kebenaran dan serangan kebocoran data.  Dukungan untuk perpustakaan aman masih memerlukan tinjauan kode, tes, dan fuzzing. <br><br>  Compiler tidak dapat menangkap semua kesalahan programmer.  Namun demikian, Rust melepaskan beban keamanan memori kami, memungkinkan kami untuk fokus pada kebenaran logis dari kode. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445670/">https://habr.com/ru/post/id445670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445652/index.html">Tanggung jawab mesin pencari: cara "mengedit" pencarian di Rusia</a></li>
<li><a href="../id445658/index.html">STAX history: electrostats versus kondisi pasar</a></li>
<li><a href="../id445662/index.html">Tick-tock: waktu smartwatch hilang, tetapi sekarang mereka berpura-pura menjadi gelang</a></li>
<li><a href="../id445666/index.html">Kami membutuhkan Juni yang sudah jadi - ajarilah sendiri, atau Bagaimana kami meluncurkan kursus seminar untuk siswa</a></li>
<li><a href="../id445668/index.html">Neoquest 2019: Koneksi dengan Surga</a></li>
<li><a href="../id445672/index.html">Muon katalisis dalam hal kimia kuantum. Bagian II: elektronik vs. ikatan kimia muon</a></li>
<li><a href="../id445674/index.html">PVS-Studio untuk Jawa menyentuh jalan. Perhentian berikutnya adalah Elasticsearch</a></li>
<li><a href="../id445676/index.html">Baru di Git 3: penutupan</a></li>
<li><a href="../id445678/index.html">4. Periksa Titik Memulai R80.20. Instalasi dan inisialisasi</a></li>
<li><a href="../id445680/index.html">Fitur baru di Git 3: closures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>