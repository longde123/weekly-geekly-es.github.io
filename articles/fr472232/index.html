<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦇 🕵🏼 🐄 De «Color Extender for ZX-Spectrum» à ZX-Poly 🍪 👩🏽‍🌾 🤜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Color Extender for ZX-Spectrum" - c'est le titre de l' article publié dans le echo fido7.zx.spectrum le 3 août 1997. L'article décrivait l'idée de ré...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>De «Color Extender for ZX-Spectrum» à ZX-Poly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472232/"><p>  "Color Extender for ZX-Spectrum" - c'est le <em>titre de l'</em> article publié dans le echo <em>fido7.zx.spectrum</em> le 3 août 1997.  L'article décrivait l'idée de résoudre l'un des principaux problèmes de la plate-forme ZX-Spectrum - le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conflit d'attributs</a> .  La publication a suscité un certain intérêt à ce moment-là, et je voudrais parler des détails techniques et de l'histoire du problème. </p><br><p><img src="https://habrastorage.org/webt/ft/at/_v/ftat_vfl5fato4m_aobobohxfhm.png" alt="Logo ZX-Poly"></p><br><p>  Je n'entrerai pas dans les détails techniques et je décrirai simplement structurellement l'idée et la solution. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Partie non technique de l'histoire, vous pouvez sauter</b> <div class="spoiler_text"><p>  L'histoire du développement a commencé au début du printemps 1994, alors que le pays connaissait encore des «changements dans le projet», ce qui a conduit à la fermeture massive des reports et à l'attrait des élèves des écoles professionnelles et des écoles techniques.  J'ai eu de la chance - j'étais dans ma dernière année au Leningrad Radiotechnical College et de cette manière, l'État a accepté de donner un délai court pour la réception accélérée d'un diplôme avec le remplacement de la conception du diplôme par un examen dans toutes les matières.  Il a quitté l'armée le 1er mars 1994 en tant que technicien radio agréé. </p><br><p>  Dans les forces armées à cette époque, il y avait un afflux sans précédent des mêmes spécialistes du niveau technique moyen, bien que cela ait légèrement ruiné le système de conscription automne-printemps dans les têtes des «grands-pères» qui avaient déjà une gradation claire dans les noms, ils ont surnommé cet appel atypique «gobelin».  Parmi les «en plein essor», il y avait suffisamment de gens qui aimaient ZX-Spectrum et Alexander Gumin était dans mon unité (il a écrit des jeux sur le ZX-Spectrum sous le label ANCCAN avec Denis Markelov et est devenu connu pour son adaptation de Mortal Kombat pour cette plateforme en 1997), qui parler de programmation et de matériel. </p><br><p>  Vers la mi-avril 1994, à la fin du «cours du jeune combattant», Alexander et moi avons été transférés au bataillon de construction situé à Strelna, dans la banlieue de Saint-Pétersbourg.  Là, nous avons dû maîtriser la spécialité difficile du câble-épisseur pendant plusieurs mois.  La vie dans cette partie coulait tranquillement et l'étude alternait avec des tenues, qui tendaient principalement les mains, mais donnaient au cerveau le temps de réfléchir.  Donc, dans l'une des tenues de la cuisine, mon étage et en pensant au ZX-Spectrum et à ses capacités, j'ai eu l'idée - comment surmonter le «conflit d'attributs». </p><br><p>  J'ai réfléchi à cette idée jusqu'à la fin du service et suis devenu de plus en plus convaincu que «ça pouvait marcher».  Malheureusement, l'idée de la viabilité de la plateforme elle-même, à laquelle j'allais appliquer cette idée, m'a moins visité.  Cependant, en Russie, le ZX-Spectrum a clignoté le plus vivement dans le ciel d'environ 1991 à 1996.  Certains producteurs russes de ses clones ont tellement augmenté qu'ils ont parrainé des programmes à la télévision (par exemple, la société BiM a parrainé le programme «The Jungle's Name» pendant un certain temps).  Mais pendant le service, il y avait d'autres problèmes, j'ai donc décidé de reporter tous les problèmes liés au commerce jusqu'à ce que je sois envoyé à la réserve.  Périodiquement et sans révéler de détails, j'ai été intéressé par différents experts sur le thème de la faisabilité technique et de la validité de l'approche.  Il a gardé l'idée profondément secrète et ne l'a même pas partagée avec Alexander Gumin, lui indiquant seulement vaguement qu'il avait trouvé une solution très simple pour augmenter le nombre de couleurs tout en conservant la compatibilité descendante. </p><br><p>  Entré dans le «citoyen» en 1997 et obtenu un emploi d'ingénieur logiciel de deuxième catégorie au sein de la société de Saint-Pétersbourg «Technologies de l'information et modèles», j'ai commencé à m'intéresser un peu à la question de la commercialisation de la solution.  Pour une raison quelconque, j'étais sûr que si je faisais juste allusion à la solution que j'avais trouvée, tout le monde commencerait à se déchirer avec les mains et l'argent coulerait.  J'ai commencé à téléphoner aux plus connus, à l'époque dans le domaine des fabricants et des marchands de "Spectrum Engineering", comme Sergey Zonov, Vyacheslav Skutin (Nemo) et d'autres.  Sergey Zonov m'a simplement dit que «le train est déjà parti» et il n'y a plus de sens commercial dans cette entreprise.  Vyacheslav Skutin, étant un spektrumist orthodoxe, a pris l'hostilité avec toute idée dans laquelle ils ont essayé de changer quelque chose dans la plate-forme et c'était aussi une version complètement morte.  J'ai décidé qu'il y avait peu de discussions et qu'au moins quelque chose devait être fait et il était préférable de commencer avec un émulateur afin d'obtenir du matériel promotionnel et des données expérimentales. </p><br><p>  En 1998, en prenant comme base l'un des émulateurs open source ZX-Spectrum de l'époque écrits en Pascal, j'ai réalisé un émulateur primitif de quatre ordinateurs fonctionnant en parallèle.  J'ai partiellement adapté le jeu After The War 2 pour cela, en coloriant certains de ses sprites.  Le système a fonctionné et, en plus d'apprécier l'idée de travail, j'ai eu à ma disposition des captures d'écran confirmant l'idée de colorier les jeux existants. </p><br><p>  En 1998, j'ai visité la société Peters, qui développait alors sa nouvelle plateforme Sprinter.  Il a tenté d'intéresser leur réalisateur Nikolai Noskov.  Ils ont investi massivement dans le nouveau développement et, selon la loi de la méchanceté, l'architecture super flexible du Sprinter, capable d'émuler presque n'importe quelle plate-forme à processeur unique sur le Z80, ne pouvait pas étendre quatre processeurs.  Cependant, une visite dans cette entreprise a été très utile, car il a rencontré l'auteur de la plateforme Sprinter Ivan Makarchenko et a découvert de nouvelles opportunités dans le domaine du développement FPGA. </p><br><p>  Bientôt, la crise de 1998 a «flétri» et il y avait un espoir naïf que l'intérêt pour le ZX-Spectrum pourrait renaître.  Au début de 1999, nous (avec mon partenaire de l'époque, Andrei Savichev) avions même l'intention de créer le «National Spectrum Fund» et une réunion a eu lieu sur ce sujet dans les nouveaux bureaux de la même société Peters.  Mais ils ne pénètrent pas deux fois dans la même rivière et, bien sûr, rien n'en est sorti.  Déjà en 1999, toutes les idées sur le thème de l'implémentation matérielle de la plateforme étaient écartées (nous avons travaillé sur ce développement avec Sergey Egorov, mais nous ne sommes pas allés plus loin que les schémas).  Jusqu'en 2007, je ne m'occupais pratiquement pas de la plateforme, mais il y avait du temps et j'ai décidé de réécrire l'émulateur et de travailler sur les détails de la plateforme, en vérifiant les approches et en les laissant "virtuellement". </p></div></div><br><p>  Le mode vidéo standard ZX-Spectrum affiche 256 x 192 pixels.  En mode monochrome, cela ne nécessite que 6144 octets, soit environ 10% du champ mémoire total (contre 50% sur le BK-0010).  Les informations sur les couleurs sont stockées dans 768 octets supplémentaires situés immédiatement après les données de pixels.  La palette se compose de huit couleurs et de deux nuances.  La couleur des pixels éclairés et jetés est déterminée immédiatement pour le bloc de 8 x 8 pixels, et la teinte est déterminée immédiatement pour la couleur des pixels éclairés et jetés. </p><br><p>  Il a l'air coloré et une quantité relativement faible de données est envoyée très rapidement, mais cela nécessite des efforts et un art incroyables de la part des artistes et des programmeurs lors du développement de jeux de couleurs et d'économiseurs d'écran.  La moindre incohérence dans le graphique entraîne un conflit d'attributs.  La plupart des développeurs ont bien fait leur travail dans le contexte du BK-0010, avec ses quatre seules couleurs (mais pour chaque point!), La quasi-couleur Spectrum semblait très avantageuse et fraîche. </p><br><p><img src="https://habrastorage.org/webt/rb/wz/qv/rbwzqvjgroepwudiddfwnl9vhsi.png" alt="Exemple d'attribut ZX-Spectrum"></p><br><p>  Avec le développement de la plate-forme vers ZX-Spectrum 128, la possibilité de basculer le matériel entre deux pages de mémoire vidéo a été ajoutée.  Les programmeurs ont rapidement trouvé un moyen d'obtenir plusieurs couleurs en utilisant un changement très rapide des pages vidéo affichées et un changement dynamique des attributs de couleur. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_aeNtFCaYt8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Pour cette raison, il était même possible d'augmenter la résolution de l'écran par programme (ce qui est parfaitement illustré, par exemple, dans la démo "Dead Morose", où en même temps le texte s'exécute avec une résolution de 256, 512 et 768 points horizontalement). </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WHj4gBB612U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Mais toute solution logicielle nécessitant une augmentation du flux d'informations vidéo a entraîné une augmentation de la consommation du processeur, ce qui est très critique dans le cas des jeux dynamiques.  Il n'y avait aucune source inutilisée de réserves de puissance de calcul dans le système.  Tout dépend du processeur du ZX-Spectrum et lui donne un peu de décharge, sauf peut-être le processeur de musique dans le domaine des effets sonores. </p><br><p>  Mon idée était que vous pourriez ajouter trois processeurs supplémentaires, en jetant sur chacun d'eux le traitement de leur composante couleur.  Les données reçues de la mémoire vidéo de chaque processeur doivent être intégrées, formant une valeur YRGB <strong>pour chaque pixel</strong> .  Les attributs de couleur standard sont ignorés.  Le traitement parallèle des informations doit garantir l'absence de performances d'affaissement. </p><br><p><img src="https://habrastorage.org/webt/fs/g3/yc/fsg3ycbdz2wwt7ysrtsfpeyms1a.png" alt="Schéma de couleurs en ZX-Poly 256x192"></p><br><p>  Je ne peux pas dire qu'elle était originale dans l'idée, car elle a été inspirée par la lecture du livre de traduction "The Computer Gains Mind" (Mir Publishing House, 1990), qui décrivait une certaine plate-forme graphique Pixar développée dans Lucasfilm.  Et selon <abbr title="La théorie de la résolution de problèmes inventifs, ou TRIZ, est un ensemble de méthodes pour résoudre des problèmes techniques et améliorer les systèmes techniques">TRIZ,</abbr> c'est juste une transition d'un mono-système à un poly-système. </p><br><p><img src="https://habrastorage.org/webt/lg/7d/1k/lg7d1ktwhzyxrnzzwt2yljv8qaw.png" alt="section de la page du livre &quot;The Computer Gains Mind&quot;"></p><br><p>  Une question très douloureuse pour tout développement - et qui écrira le programme?  (en particulier, la plate-forme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sprinter</a> est tombée sur cet "écueil").  Dans mon cas, le problème avec le logiciel a été automatiquement résolu par le fait que très rarement les programmes existants vérifiaient le type de données qu'ils enregistraient dans la mémoire vidéo et travaillaient simplement avec eux "comme un facteur avec une lettre scellée".  Selon mes calculs, il s'est avéré que la plupart des programmes de jeu existants pouvaient assez facilement survivre à l'adaptation de leurs données vidéo sans changements dans le code exécutable.  Bien sûr, les jeux avec un ensemble de graphiques ou d'optimisations internes dans sa sortie à l'écran ont été coupés.  L'adaptation de tels programmes nécessiterait des recherches et une modification du code exécutable.  Le développement de ROM spécialisées n'était pas du tout nécessaire. </p><br><p>  Je pense que ce concept est applicable à toute ancienne plate-forme domestique (par exemple, AGAT, Radio86RK, BK-0010, etc.), où il n'y a pas d'accélérateur vidéo dédié et où le processeur travaille directement avec la mémoire vidéo pour former une image. </p><br><p>  Dans la première version de l'émulateur, je venais de faire fonctionner quatre synchrones ZX-Spectrum 48. Mais ce qui est facile à simuler sur l'émulateur est très difficile à répéter sur du vrai matériel.  Il est assez difficile d'assurer le chargement des données dans quatre modules informatiques et d'effectuer un démarrage synchrone à partir de la même adresse.  Une solution similaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spec256</a> introduit pour ce <abbr title="Instruction unique, données multiples - flux d'instructions unique, flux de données multiples">SIMD</abbr> Z80 virtuel 64 bits spécialisé, qui n'existe pas dans la nature.  Dans le cadre d'une solution plus réaliste (et plus complexe) à ce problème, la plateforme ZX-Poly a été formée. </p><br><h1 id="ot-cvetorasshiritelya-k-zx-poly">  De «Color Extender» à ZX-Poly </h1><br><h2 id="processornye-moduli">  Modules de processeur </h2><br><p>  ZX-Poly est une plate-forme informatique basée sur le ZX-Spectrum 128 contenant quatre modules de processeur.  Chaque module possède ses propres ports d'E / S système adressables visibles de l'extérieur.  Bien que les modules de processeur partagent les signaux de contrôle du système (RESET, NMI, CLK et INT), ils fonctionnent indépendamment. </p><br><p><img src="https://habrastorage.org/webt/9r/na/nt/9rnantil7npmty1cnmtip6hdxvg.png" alt="Schéma fonctionnel"></p><br><p>  Il y a un certain classement en fonction de l'indice du module - plus l'indice est petit, plus le rang est respectivement élevé, "module 0" est maître dans le système.  L'accès en écriture aux ports système du module n'est autorisé qu'au module de rang identique ou supérieur, il n'y a aucune restriction de lecture.  Cela a été fait parce qu'il y avait des idées sur le développement d'un système d'exploitation spécialisé. </p><br><p><img src="https://habrastorage.org/webt/hz/wg/l9/hzwgl9ajm1vcyx_cycpsmh8c3uk.png" alt="Classement des modules"></p><br><p>  Un détail très important est que tous les processeurs utilisés doivent être du même fabricant (et ce serait bien d'avoir une série de production), car la moindre différence dans leur organisation ou optimisation interne peut violer la cohérence du système. </p><br><p>  Immédiatement après le démarrage du système, seul le module maître (CPU0) est lancé, les modules restants sont en mode WAIT, donc pour l'utilisateur tout passe inaperçu. </p><br><p>  Dans l'espace IO, ZX-Poly ajoute les ports suivants disponibles pour l'écriture et la lecture: </p><br><ul><li>  port de configuration principal $ 3D00 </li><li>  module 0 - 00FF $, 10FF $, 20FF $, 30FF $ </li><li>  module 1 - 01FF $, 11FF $, 21FF $, 31FF $ </li><li>  module 2 - $ 02FF, $ 12FF, $ 22FF, $ 32FF </li><li>  module 3 - $ 03FF, $ 13FF, $ 23FF, $ 33FF </li></ul><br><p>  Le port de configuration principal ZX-Poly est de $ 3D00.  Seul le module maître peut y écrire, mais il est disponible pour lecture dans tous les modules et chacune de ses propres informations spécialisées est retournée.  En particulier, un module peut connaître son index, si sa mémoire est mappée aux ports IO du module principal, l'offset de sa mémoire dans le tas, etc.  De plus, le port de configuration de la plate-forme de base $ 7FFD a subi des modifications mineures, qui utilisent des bits inutilisés dans l'original. </p><br><h2 id="pamyat">  La mémoire </h2><br><p>  Comme dans l'architecture originale du ZX-Spectrum 128, il existe des ROM et RAM.  Si l'organisation et le travail avec la ROM n'ont pratiquement pas changé, la RAM s'est transformée en un «tas» commun de 512 Ko dans lequel chaque processeur fonctionne avec une fenêtre dédiée de 128 Ko (soit 8 pages de 16 Ko dans le ZX-Spectrum 128).  Le décalage de fenêtre peut être modifié par incréments de 64 Ko et tous les modules de processeur peuvent être projetés pour fonctionner avec un morceau de mémoire se chevauchant totalement ou partiellement dans le tas.  La ROM peut être désactivée et la page RAM0 RAM sera connectée à sa place (cela vous permet de faire une version "full-color" du système d'exploitation de base, par exemple, un interpréteur de base).  Après une réinitialisation matérielle, tous les modules reçoivent des décalages automatiques pour dissocier les fenêtres de mémoire du tas. </p><br><p>  Le module maître processeur (CPU0), a la capacité de mapper les espaces d'adressage des autres modules (CPU1-3) dans la zone de ses ports IO.  C'est-à-dire  il peut écrire sur le port, en changeant l'état de la cellule mémoire d'un module donné, et en même temps, il est possible de générer un signal NMI sur un module mappé.  Lors de la lecture à partir des cellules de mémoire d'un module mappé, la génération INT est possible.  Cela a été fait pour émuler des périphériques virtuels à l'aide des modules 1-3. </p><br><h2 id="video-kontroller">  Contrôleur vidéo </h2><br><p>  La «cerise» principale est bien sûr un contrôleur vidéo, tout a été démarré pour cela.  Au total, la plateforme prend en charge cinq modes vidéo. </p><br><h3 id="video-rezhimy-zx-spectrum-128-mode-0123">  Modes vidéo ZX-Spectrum 128 (mode 0,1,2,3) </h3><br><p>  Ces modes vidéo sont sans particularité et ne diffèrent pas du tout du mode vidéo standard ZX-Spectrum 128. La page vidéo actuelle du module de processeur sélectionné avec la coloration d'attribut s'affiche.  Immédiatement après le démarrage du système, le mode 0 est activé, c'est-à-dire  La page vidéo du module maître (CPU0) s'affiche. </p><br><p><img src="https://habrastorage.org/webt/1f/lk/vn/1flkvncwify4gom7fmw2zp-i77c.png" alt="ATW2 en mode ZX standard"></p><br><h3 id="zx-poly-256x192-mode-4">  ZX-Poly 256x192 (mode 4) </h3><br><p>  Ce mode vidéo n'utilise aucune donnée de la zone d'attribut.  Le bit de pixel de chaque module est combiné avec les données de pixel des autres modules et les quatre bits générés sont utilisés pour générer un signal YRGB de luminosité de couleur. </p><br><p>  Chaque module est responsable de sa composante: </p><br><ul><li>  module 0 (maître) pour Vert (vert). </li><li>  module 1 pour Rouge (rouge) </li><li>  module 2 pour Blue (bleu) </li><li>  module 3 pour la luminosité </li></ul><br><p><img src="https://habrastorage.org/webt/gy/kw/jx/gykwjxvnd5r_4967oxnlgo2z8gs.gif" alt="version colorisée"></p><br><p>  Si vous démarrez une partie non adaptée dans ce mode, elle sera simplement en noir et blanc. <br><img src="https://habrastorage.org/webt/jt/_i/s4/jt_is4xsowghhld2aimz0dnpplc.png" alt="jeu inadapté"></p><br><h3 id="zx-poly-256x192-s-maskirovaniem-po-inkpaper-mode-6">  ZX-Poly 256x192 avec masquage par ENCRE + PAPIER (mode 6) </h3><br><p>  Comme le précédent, il fournit 16 couleurs pour chaque point, mais il y a un «truc».  Dans certains programmes ZX-Spectrum, les éléments graphiques sont masqués en utilisant les mêmes valeurs ENCRE et PAPIER dans les attributs, en particulier dans les jeux à défilement.  Si vous supprimez cette opportunité, les éléments graphiques commencent à s'accumuler à l'écran, brisant l'image.  Par conséquent, l'état de l'encre et du papier est analysé à partir de l'attribut du module maître lu dans la mémoire vidéo (CPU0) et s'ils sont identiques, tous les points sont mis en surbrillance avec la couleur tirée de l'encre / du papier (bien sûr, en tenant compte de la luminosité). </p><br><p><img src="https://habrastorage.org/webt/ol/sy/26/olsy265bag3_dg_bnxl-grzsjlq.gif"></p><br><h3 id="zx-poly-256x192-s-maskirovaniem-po-flashinkpaper-mode-7">  ZX-Poly 256x192 avec masquage par FLASH + ENCRE + PAPIER (mode 7) </h3><br><p>  Le mode est une combinaison du mode 4 et du mode 6. Pour les attributs lisibles du module maître (CPU0), le bit FLASH est analysé et s'il est défini (ce qui est rare dans les jeux dynamiques sur le terrain), le bloc de 8 x 8 pixels est affiché en mode 6 ( avec masquage avec ENCRE et PAPIER identiques).  Si FLASH est réinitialisé, le bloc s'affiche comme sur un ZX-Spectrum normal.  Le bit FLASH n'est pas pratiqué dans son rôle direct et il n'y aura pas de clignotement. <br>  Ce mode est très pratique pour éviter de repeindre les panneaux d'informations du jeu et certains effets dans le jeu (par exemple, lorsque les développeurs de jeux clignotent sur le terrain de jeu via des attributs). </p><br><p><img src="https://habrastorage.org/webt/cs/fr/cv/csfrcvh0rtury8g_9g20t1xoecm.gif" alt="Requin volant adapté et animé"></p><br><h3 id="zx-poly-512x384-s-atributami-mode-5">  ZX-Poly 512x384 avec attributs (mode 5) </h3><br><p>  Les attributs sont utilisés presque de la même manière que dans la plate-forme d'origine, sans aucune modification (même le bit FLASH).  Les données de pixels vidéo de chaque module sont colorées avec un attribut de la mémoire vidéo de ce module et, après avoir traversé la coloration, sont affichées en damier, grâce à quoi un bloc de familiarité est de 16 par 16 points. </p><br><p><img src="https://habrastorage.org/webt/5i/gv/cl/5igvcljru-gbuybss377ujcbbr0.png" alt="formation d'échecs"></p><br><p>  Ce mode vous permet de doubler la résolution des applications, sans changer le code exécutable.  Certes, les expériences avec le même jeu «Pinocchio» ont montré que dans les jeux brillants avec de grands détails, l'effet sera mal perceptible.  Puisqu'il s'agit en quelque sorte de pixels virtuels, les jeux n'en savent rien et le mouvement minimum possible des éléments du jeu se situe au niveau de deux pixels virtuels.  Je pense que ce mode est bon pour les jeux avec de petits objets de jeu dans un endroit familier. </p><br><p><img src="https://habrastorage.org/webt/o4/25/hk/o425hkbmpkl00uju8aaon-_siui.png" alt="exemple du jeu &quot;Pinocchio&quot;"></p><br><p>  Un effet bien meilleur dans ce mode vidéo a été obtenu sur les applications de texte, par exemple, sur l'éditeur de texte ZX-Word, où la police a été traitée sans modification du code exécutable. </p><br><p><img src="https://habrastorage.org/webt/xd/ol/li/xdollinm5mle6snma7prgemgyyw.gif" alt="ZX-Word adapté"></p><br><h2 id="mnogozadachnost">  Multitâche </h2><br><p>  Malgré le fait que les processeurs du système utilisent la même source de signaux de commande, ils fonctionnent indépendamment.  Le système ne peut pas être appelé <abbr title="Single Instruction, Multiple Data -   ,   ">SIMD à</abbr> part entière, car chaque processeur traite les instructions à partir de son propre bloc de mémoire, il profite simplement de la possibilité de "supprimer" les mêmes instructions.         ,  "  "        —  . </p><br><p><img src="https://habrastorage.org/webt/gp/yg/5k/gpyg5khuq7hn9jvvbgny5hddqrs.png" alt="Exemple de désynchronisation"></p><br><p>          ,     ,         "".  ,     . </p><br><h2 id="mehanizmy-sinhronizacii">   </h2><br><h3 id="lokalnyy-reset">  RESET </h3><br><p>       RESET    ,            .     JP ADDR          . </p><br><h3 id="stop-adres"> - </h3><br><p>       master- (CPU0).       ,      (   M1),      <strong></strong>  WAIT,                RESET.       ,   ,   16     . </p><br><h1 id="emulyator-sistemy">   </h1><br><p>  2007  JavaSE     .        Z80 (      -)  FDD  181893.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JDK 1.8+</a> . </p><br><p><img src="https://habrastorage.org/webt/0m/qa/rp/0mqarpebzf0p9ewtwkojknscb_u.png" alt="Fenêtre de l'émulateur"></p><br><p>            ZX-Spectrum        ,  80%   ,    .         ZX-Spectrum 128,      <strong>Options-&gt;ZX 128 Mode</strong> ,    ZX-Poly      . </p><br><p>       -,    ZX-Spectrum —   .      ,    <strong>File-&gt;Options</strong> </p><br><p><img src="https://habrastorage.org/webt/re/3a/er/re3aerw3r_zksnkvghxn35u3n2w.gif" alt="ROM de test ZX-Poly"></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si les jeux n'utilisent aucun paquet de sprites, la coloration est assez simple. </font><font style="vertical-align: inherit;">Des précautions doivent être prises lorsqu'il y a des optimisations dans le code exécutable pour la sortie des sprites, car cela peut conduire à la désynchronisation des modules de processeur.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un chargeur de démarrage a été développé pour charger des données dans des modules à partir d'un disque et démarrer simultanément simultanément. </font><font style="vertical-align: inherit;">Son code pour TAP et TR-DOS est présenté dans le projet.</font></font></p><br><p><img src="https://habrastorage.org/webt/_o/py/bv/_opybvhjgijkprgwb2lyaipdpy4.gif" alt="Exemple de fonctionnement du chargeur de démarrage"></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avec l'émulateur, un petit utilitaire (également écrit en Java) pour les applications de coloration a été développé. </font></font></p><br><p><img src="https://habrastorage.org/webt/3b/dg/fa/3bdgfacgkovaenmlf1ewkcoiriw.png" alt="Correcteur de sprite ZX-Poly"></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ensemble du projet est publié sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sous la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">licence GNU GPLv3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p><br><p> <a href=""><img src="https://habrastorage.org/webt/xr/1n/zx/xr1nzxg1xx9xmbv0hzgdas_dmu4.png"></a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472232/">https://habr.com/ru/post/fr472232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472222/index.html">«Lisez si vous aimez écouter»: des livres pour ceux qui ne sont pas indifférents à la musique - du classique au hip-hop</a></li>
<li><a href="../fr472224/index.html">Utilisation du nouveau SSD NVMe comme disque de démarrage sur les anciens systèmes avec BIOS hérité (pour tout système d'exploitation)</a></li>
<li><a href="../fr472226/index.html">Amélioration des contrôles de formulaire dans Microsoft Edge et Chromium</a></li>
<li><a href="../fr472228/index.html">9 astuces pour travailler avec Visual Studio Code</a></li>
<li><a href="../fr472230/index.html">Chips for ML - parler de nouveaux produits</a></li>
<li><a href="../fr472234/index.html">Crypto-monnaie: est-ce toujours un freeloader ou un partenaire?</a></li>
<li><a href="../fr472240/index.html">À propos de la gamification. Qu'est-ce que c'est, pourquoi et comment le faire? Développeur Look</a></li>
<li><a href="../fr472242/index.html">Nous avons dix fois accéléré l'ordonnanceur Tokio</a></li>
<li><a href="../fr472246/index.html">React + IndexDb + mise à jour automatique = presque AsyncRedux</a></li>
<li><a href="../fr472248/index.html">Comment nous avons fusionné la programmation finale d'IT-Planet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>