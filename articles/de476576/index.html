<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§• üì• üî∂ JSON-RPC? Nimm den kniffligen REST üë¥üèæ üèè üî¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin sicher, dass die √úberschrift eine gesunde Reaktion hervorrief - ‚ÄûNun, es hat wieder angefangen ...‚Äú Aber lassen Sie mich 5-10 Minuten lang Ihr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JSON-RPC? Nimm den kniffligen REST</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476576/"><p><img src="https://habrastorage.org/webt/q0/at/ek/q0atekvadeakqoxlbkht27oxt8c.jpeg"></p><br><p>  Ich bin sicher, dass die √úberschrift eine gesunde Reaktion hervorrief - ‚ÄûNun, es hat wieder angefangen ...‚Äú Aber lassen Sie mich 5-10 Minuten lang Ihre Aufmerksamkeit erregen, und ich werde versuchen, die Erwartungen nicht zu t√§uschen. </p><br><p> Der Artikel wird wie folgt strukturiert: Es wird eine stereotype Aussage getroffen und die ‚ÄûNatur‚Äú der Entstehung dieses Stereotyps wird enth√ºllt.  Ich hoffe, dass Sie damit die Wahl des Datenaustauschparadigmas in Ihren Projekten aus einem neuen Blickwinkel betrachten k√∂nnen. </p><br><p>  Um zu verdeutlichen, was RPC ist, schlage ich vor, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON-RPC 2.0-</a> Standard zu ber√ºcksichtigen.  Es gibt keine Klarheit mit REST.  Und das sollte nicht sein.  Alles, was Sie √ºber REST wissen m√ºssen - es ist nicht von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP zu unterscheiden</a> . </p><a name="habracut"></a><br><h2 id="rpc-zaprosy-bystree-i-effektivnee-potomu-chto-pozvolyayut-delat-batch-zaprosy">  RPC-Anforderungen sind schneller und effizienter, da sie Stapelanforderungen erm√∂glichen. </h2><br><p>  Der Punkt ist, dass es in RPC m√∂glich ist, mehrere Prozeduren in einer Anforderung aufzurufen.  Erstellen Sie beispielsweise einen Benutzer, f√ºgen Sie ihm einen Avatar hinzu, und signieren Sie ihn in derselben Anforderung zu bestimmten Themen.  Nur eine Bitte und wie viel Gutes! </p><br><p>  In der Tat, wenn Sie nur einen Backend-Knoten haben, wird dies mit einer Batch-Anfrage schneller erscheinen.  Weil drei REST-Anforderungen dreimal so viele Ressourcen von einem Knoten erfordern, um Verbindungen herzustellen. </p><br><p><img src="https://habrastorage.org/webt/wd/o9/yy/wdo9yyuiainix3lto2vtfwl4jtu.jpeg"></p><br><p>  Bitte beachten Sie, dass die erste Anforderung im Fall von REST die Benutzer-ID f√ºr nachfolgende Anforderungen zur√ºckgeben sollte.  Was sich auch negativ auf das Gesamtergebnis auswirkt. </p><br><p>  Solche Infrastrukturen finden sich jedoch m√∂glicherweise in unternehmensinternen L√∂sungen und in Enterprise.  Als letzter Ausweg in kleinen WEB-Projekten.  Aber vollwertige WEB-L√∂sungen, auch HighLoad genannt, sollten nicht so gebaut werden.  Ihre Infrastruktur muss die Kriterien f√ºr hohe Verf√ºgbarkeit und Arbeitslast erf√ºllen.  Und das Bild √§ndert sich. </p><br><p><img src="https://habrastorage.org/webt/q5/x_/js/q5x_js3bh9se9vzjejgpyqfeexq.jpeg"></p><br><p>  Gr√ºn zeigt Infrastrukturaktivit√§tskan√§le im selben Szenario an.  Beachten Sie, wie sich RPC jetzt verh√§lt.  Die Anfrage nutzt die Infrastruktur nur mit einer Schulter vom Balancer bis zum Backend.  REST verliert zwar noch in der ersten Anfrage, gleicht aber verlorene Zeit mit der gesamten Infrastruktur aus. </p><br><p>  Es reicht aus, in das Skript nicht zwei Anreicherungsanfragen, sondern beispielsweise f√ºnf oder zehn einzutragen ... und die Antwort auf die Frage ‚ÄûWer gewinnt jetzt?‚Äú Wird un√ºbersehbar. </p><br><p>  Ich schlage vor, das Problem noch umfassender zu betrachten.  Das Diagramm zeigt, wie Infrastrukturkan√§le verwendet werden, die Infrastruktur ist jedoch nicht auf Kan√§le beschr√§nkt.  Ein wichtiger Bestandteil einer stark ausgelasteten Infrastruktur sind Caches.  Lassen Sie uns jetzt ein Benutzerartefakt besorgen.  Mehrmals.  Sprich 32 mal. </p><br><p><img src="https://habrastorage.org/webt/vp/ts/es/vptseszry2ujpaxxlorxj5dk3gu.jpeg"></p><br><p>  Sehen Sie, wie sich die Infrastruktur auf dem RPC sichtbar "erholt" hat, um den Anforderungen einer hohen Auslastung gerecht zu werden.  Die Sache ist, dass REST im Gegensatz zu RPC die volle Leistung des HTTP-Protokolls nutzt.  Im obigen Diagramm wird diese Leistung durch die Anforderungsmethode - GET realisiert. </p><br><p>  HTTP-Methoden verf√ºgen unter anderem √ºber Caching-Strategien.  Sie k√∂nnen sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP-</a> Dokumentation kennenlernen.  F√ºr RPC werden POST-Anforderungen verwendet, die nicht als idempotent gelten. Das hei√üt, die wiederholte Wiederholung derselben POST-Anforderungen kann unterschiedliche Ergebnisse liefern (z. B. wird nach dem Senden jedes Kommentars eine weitere Kopie dieses Kommentars angezeigt) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ). </p><br><p>  Folglich k√∂nnen RPCs Infrastruktur-Caches nicht effizient nutzen.  Dies f√ºhrt dazu, dass Sie Software-Caches ‚Äûimportieren‚Äú m√ºssen.  Das Diagramm zeigt Redis in dieser Rolle.  Der Soft-Cache erfordert vom Entwickler eine zus√§tzliche Codeschicht und wesentliche √Ñnderungen in der Architektur. </p><br><p>  Berechnen wir nun, wie viele Anforderungen REST und RPC in der betreffenden Infrastruktur ‚Äûhervorgebracht‚Äú haben. </p><br><div class="scrollable-table"><table><thead><tr><th>  Anfragen </th><th>  Posteingang </th><th>  zum Backend </th><th>  zu DBMS </th><th>  zum Soft-Cache (Redis) </th><th>  INSGESAMT </th></tr></thead><tbody><tr><td>  REST </td><td>  1/32 * </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  3/35 </td></tr><tr><td>  Rpc </td><td>  32 </td><td>  32 </td><td>  1 </td><td>  31 </td><td>  96 </td></tr></tbody></table></div><br><p>  [*] im besten Fall (wenn der lokale Cache verwendet wird) 1 Anfrage (eine!), in den schlechtesten 32 eingehenden Anfragen. </p><br><p>  Im Vergleich zum ersten Schema ist der Unterschied auff√§llig.  Der REST-Sieg ist jetzt ersichtlich.  Aber ich schlage vor, hier nicht aufzuh√∂ren.  Die entwickelte Infrastruktur umfasst CDN.  Oft l√∂st er auch das Problem der Abwehr von DDoS- und DoS-Angriffen.  Wir bekommen: </p><br><p><img src="https://habrastorage.org/webt/k2/9f/ky/k29fkywcpnld_poisd1s7g9oxhs.jpeg"></p><br><p>  Hier f√ºr RPC wird alles sehr bedauerlich.  RPC ist einfach nicht in der Lage, die Arbeit mit dem Laden von CDN zu delegieren.  Man kann sich nur auf Systeme verlassen, um Angriffen entgegenzuwirken. </p><br><p>  Ist es m√∂glich, dies zu beenden?  Und wieder nein.  HTTP-Methoden haben, wie oben erw√§hnt, ihre eigene "Magie".  Und aus gutem Grund wird die GET-Methode im Internet vollst√§ndig verwendet.  Bitte beachten Sie, dass diese Methode auf einen Teil des Inhalts zugreifen kann, Bedingungen festlegen kann, die die Infrastrukturelemente interpretieren k√∂nnen, bevor die Steuerung auf Ihren Code √ºbertragen wird usw.  All dies erm√∂glicht es Ihnen, flexible, verwaltbare Infrastrukturen zu erstellen, die wirklich gro√üe Anforderungsstr√∂me verarbeiten k√∂nnen.  Und in RPC wird diese Methode ... ignoriert. </p><br><p>  Warum ist der Mythos so hartn√§ckig, dass Stapelanforderungen (Batch Requests, RPC) schneller sind?  Pers√∂nlich scheint es mir, dass die meisten Projekte einen solchen Entwicklungsstand schlichtweg nicht erreichen, wenn REST seine St√§rke unter Beweis stellen kann.  Dar√ºber hinaus zeigt er in kleinen Projekten eher seine Schw√§che. </p><br><p>  Die Wahl von REST oder RPC ist keine freiwillige Wahl einer Person im Projekt.  Diese Auswahl sollte den Anforderungen des Projekts entsprechen.  Wenn das Projekt in der Lage ist, alles aus REST herauszuholen, was wirklich m√∂glich und notwendig ist, ist REST eine ausgezeichnete Wahl. </p><br><p>  Aber wenn Sie alle REST-Gewinne erzielen m√∂chten, m√ºssen Sie Entwickler einstellen, um die Infrastruktur schnell zu skalieren, Administratoren, die die Infrastruktur verwalten, einen Architekten, der alle Ebenen des WEB-Dienstes entwirft ... und das Projekt verkauft drei Packungen Margarine pro Tag ... I w√ºrde auf RPC da aufh√∂ren  Dieses Protokoll ist n√ºtzlicher.  Es erfordert keine gr√ºndlichen Kenntnisse √ºber den Betrieb von Caches und der Infrastruktur, sondern konzentriert den Entwickler auf einfache und verst√§ndliche Aufrufe der erforderlichen Prozeduren.  Das Gesch√§ft wird erfreut sein. </p><br><h2 id="rpc-zaprosy-nadezhnee-potomu-chto-mogut-vypolnyat-batch-zaprosy-v-ramkah-odnoy-tranzakcii">  RPC-Anforderungen sind zuverl√§ssiger, da sie Stapelanforderungen in einer einzigen Transaktion ausf√ºhren k√∂nnen </h2><br><p>  Diese Eigenschaft von RPC ist ein klares Plus  einfach, die Datenbank in einem konsistenten Zustand zu halten.  Bei REST ist jedoch alles komplizierter.  Anfragen k√∂nnen inkonsistent auf verschiedenen Backend-Knoten eintreffen. </p><br><p>  Dieser ‚ÄûNachteil‚Äú von REST ist die Kehrseite seiner oben beschriebenen Vorteile - die F√§higkeit, alle Infrastrukturressourcen effektiv zu nutzen.  Wenn die Infrastruktur schlecht ausgelegt ist und insbesondere die Architektur des Projekts und die Datenbank schlecht ausgelegt sind, ist dies ein gro√üer Schmerz. </p><br><p>  Aber sind Batch-Anfragen so zuverl√§ssig, wie sie scheinen?  Schauen wir uns den Fall an: Erstellen Sie einen Benutzer, bereichern Sie sein Profil mit einer Beschreibung und senden Sie ihm eine SMS mit einem Geheimnis, um die Registrierung abzuschlie√üen.  Das hei√üt  drei Anrufe in einer Stapelanforderung. </p><br><p><img src="https://habrastorage.org/webt/i5/ry/4k/i5ry4k9evunfpvdeowewzqkpmkm.jpeg"></p><br><p>  Betrachten wir das Schema.  Es pr√§sentiert die Infrastruktur mit Elementen hoher Verf√ºgbarkeit.  Es gibt zwei unabh√§ngige Kommunikationskan√§le mit SMS-Gateways.  Aber ... was sehen wir?  Beim Senden von SMS tritt der Fehler 503 auf - der Dienst ist vor√ºbergehend nicht verf√ºgbar.  Weil  Das Senden von SMS wird in einer Stapelanforderung verpackt. Anschlie√üend sollte die gesamte Anforderung zur√ºckgesetzt werden.  Aktionen im DBMS werden abgebrochen.  Der Client erh√§lt einen Fehler. </p><br><p>  Der n√§chste Versuch ist eine Lotterie.  Entweder geht die Anfrage erneut an denselben Knoten und gibt einen Fehler zur√ºck, oder Sie haben Gl√ºck und es wird ausgef√ºhrt.  Hauptsache ist aber, dass zumindest einmal unsere Infrastruktur bereits vergeblich funktioniert hat.  Es gab eine Ladung, aber keinen Gewinn. </p><br><p>  Stellen wir uns vor, wir haben uns angespannt (!) Und uns √ºberlegt, wo die Anfrage teilweise erfolgreich abgeschlossen werden k√∂nnte.  Und den Rest werden wir nach einiger Zeit erneut versuchen zu erf√ºllen (Welches? Entscheidet die Front?).  Aber die Lotterie blieb.  Eine Anforderung zum Senden einer SMS mit einer Wahrscheinlichkeit von 50/50 schl√§gt erneut fehl. </p><br><p>  Stimmen Sie zu, dass der Service auf Kundenseite nicht so zuverl√§ssig zu sein scheint, wie wir es uns w√ºnschen ... aber wie steht es mit REST? </p><br><p><img src="https://habrastorage.org/webt/yu/ol/yy/yuolyyficausbg8c3jgzmddc1kk.jpeg"></p><br><p>  REST verwendet wieder HTTP-Magie, jetzt jedoch mit Antwortcodes.  Wenn auf dem SMS-Gateway ein 503-Fehler auftritt, sendet das Back-End diesen Fehler an den Balancer.  Der Balancer, der diesen Fehler empf√§ngt, sendet die Anforderung an einen anderen Knoten, der die Anforderung erfolgreich verarbeitet, ohne die Verbindung zum Client zu unterbrechen.  Das hei√üt  Der Kunde erh√§lt das erwartete Ergebnis und die Infrastruktur best√§tigt seinen hohen Rang als ‚Äûhoch zug√§nglich‚Äú.  Der Benutzer ist gl√ºcklich. </p><br><p>  Und das ist nochmal nicht alles.  Der Balancer hat nicht nur den Antwortcode 503 erhalten. Es wird empfohlen, diesen Code beim Antworten mit dem Header "Retry-After" zu versehen. Der Header macht dem Balancer klar, dass Sie diesen Knoten auf dieser Route f√ºr eine bestimmte Zeit nicht st√∂ren sollten. Und die folgenden SMS-Sendeanfragen wird sofort an einen Knoten gesendet, der keine Probleme mit dem SMS-Gateway hat. </p><br><p>  Wie wir sehen k√∂nnen, wird die Zuverl√§ssigkeit von JSON-RPC √ºberbewertet.  In der Tat ist es einfacher, die Datenbankkonsistenz zu organisieren.  Das Opfer wird in diesem Fall jedoch die Zuverl√§ssigkeit des gesamten Systems sein. </p><br><p>  Die Schlussfolgerung √§hnelt weitgehend der vorherigen.  Wenn die Infrastruktur einfach ist, ist die Offensichtlichkeit von JSON-RPC zweifellos das Plus.  Wenn ein Projekt eine hohe Verf√ºgbarkeit mit einer hohen Last beinhaltet, sieht REST nach einer genaueren, wenn auch komplexeren L√∂sung aus. </p><br><h2 id="porog-vhoda-v-rest-nizhe">  REST-Eintrittsschwelle unter </h2><br><p>  Ich denke, dass die obige Analyse, die die etablierten Stereotype √ºber RPC entlarvt, eindeutig gezeigt hat, dass der Schwellenwert f√ºr die Eingabe von REST zweifellos h√∂her ist als in RPC.  Dies liegt an der Notwendigkeit eines umfassenden Verst√§ndnisses von HTTP sowie an der Notwendigkeit, ausreichende Kenntnisse √ºber die vorhandenen Infrastrukturelemente zu haben, die in WEB-Projekten verwendet werden k√∂nnen und sollten. </p><br><p>  Warum denken viele Leute, dass REST einfacher sein wird?  Meine pers√∂nliche Meinung ist, dass sich diese scheinbare Einfachheit aus dem REST manifestiert.  Das hei√üt  REST ist kein Protokoll, sondern ein Konzept ... REST hat keinen Standard, es gibt einige Empfehlungen ... REST ist nicht komplizierter als HTTP.  Scheinbare Freiheit und Anarchie ziehen ‚Äûfreie K√ºnstler‚Äú an. </p><br><p>  Zweifellos ist REST nicht komplizierter als HTTP.  HTTP selbst ist jedoch ein gut entwickeltes Protokoll, das sich seit Jahrzehnten bew√§hrt hat.  Wenn es kein tiefes Verst√§ndnis von HTTP selbst gibt, kann REST nicht beurteilt werden. </p><br><p>  Aber √ºber RPC - das k√∂nnen Sie.  Es reicht aus, seine Spezifikation zu √ºbernehmen.  Ben√∂tigen Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dummen JSON-RPC</a> ?  Oder ist es schlauer REST?  Es liegt an dir. </p><br><p>  Ich hoffe aufrichtig, dass ich Ihre Zeit nicht vergeblich verschwendet habe. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476576/">https://habr.com/ru/post/de476576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476554/index.html">Cloud-basiertes WebRTC-Streaming auf DigitalOcean</a></li>
<li><a href="../de476556/index.html">Erz√§hlung und "Dungeons": Wie kann ein Game Designer Orte mit einer Handlung verkn√ºpfen?</a></li>
<li><a href="../de476558/index.html">ONYX BOOX Max 3 Test: Maximaler Bildschirmleser</a></li>
<li><a href="../de476566/index.html">Wie kann man verstehen, ob digitale Verm√∂genswerte Wertpapiere sind? SEC-Anweisung</a></li>
<li><a href="../de476570/index.html">Private Meinung zu Yandex.Turbo</a></li>
<li><a href="../de476578/index.html">9 Hauptvorteile der Blockchain-Technologie in der Sportsoftware</a></li>
<li><a href="../de476580/index.html">Horizontal vs. vertikales Wachstum des Entwicklers. Meinungen von ivi und Yandex</a></li>
<li><a href="../de476582/index.html">DWT-Z√§hler</a></li>
<li><a href="../de476590/index.html">So packen Sie die Anwendung VueJS + NodeJS + MongoDB in Docker</a></li>
<li><a href="../de476592/index.html">CLRium 6: Noch 9 Tage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>