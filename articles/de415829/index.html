<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏻 🐩 ❣️ Einführung in Datenklassen 🙍🏼 🌉 ☕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine der neuen Funktionen, die in Python 3.7 eingeführt wurden, sind die Datenklassen. Sie sollen die Generierung von Code für Klassen automatisieren,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in Datenklassen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415829/"><p>  Eine der neuen Funktionen, die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python 3.7 eingeführt wurden,</a> sind die Datenklassen.  Sie sollen die Generierung von Code für Klassen automatisieren, die zum Speichern von Daten verwendet werden.  Trotz der Tatsache, dass sie andere Arbeitsmechanismen verwenden, können sie mit "veränderlichen benannten Tupeln mit Standardwerten" verglichen werden. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP 557 - Datenklassen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Dokumentation</a> </li></ul><br><h2 id="vvedenie">  Einführung </h2><br><blockquote>  Für alle oben genannten Beispiele ist Python 3.7 oder höher erforderlich. </blockquote><p>  Die meisten Python-Entwickler müssen diese Klassen regelmäßig schreiben: </p><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularBook</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, title, author)</span></span></span><span class="hljs-function">:</span></span> self.title = title self.author = author</code> </pre> <br><p>  Bereits in diesem Beispiel ist Redundanz sichtbar.  Die Titel- und Autorenkennungen werden mehrmals verwendet.  Die reale Klasse enthält auch überschriebene Methoden <code>__eq__</code> und <code>__repr__</code> . </p><br><p>  Das <code>dataclasses</code> enthält den <code>@dataclass</code> Dekorator.  Wenn Sie es verwenden, würde ein ähnlicher Code folgendermaßen aussehen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class">:</span></span> title: str author: str</code> </pre> <a name="habracut"></a><br><p>  Es ist wichtig zu beachten, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typanmerkungen</a> <strong>erforderlich sind</strong> .  Alle Felder ohne Typmarkierungen werden ignoriert.  Wenn Sie keinen bestimmten Typ verwenden möchten, können Sie natürlich <code>Any</code> aus dem <code>typing</code> angeben. </p><br><p>  Was bekommen Sie als Ergebnis?  Sie erhalten automatisch eine Klasse mit den implementierten Methoden <code>__init__</code> , <code>__repr__</code> , <code>__str__</code> und <code>__eq__</code> .  Außerdem handelt es sich um eine reguläre Klasse, von der Sie erben oder beliebige Methoden hinzufügen können. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>book = Book(title=<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, author=<span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book Book(title=<span class="hljs-string"><span class="hljs-string">'Fahrenheit 451'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>) &gt;&gt;&gt; book.author <span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span> &gt;&gt;&gt; other = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book == other <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><h2 id="alternativy">  Alternativen </h2><br><h3 id="kortezh-ili-slovar">  Tupel oder Wörterbuch </h3><br><p>  Wenn die Struktur recht einfach ist, können Sie die Daten natürlich in einem Wörterbuch oder Tupel speichern: </p><br><pre> <code class="python hljs">book = (<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) other = {<span class="hljs-string"><span class="hljs-string">'title'</span></span>: <span class="hljs-string"><span class="hljs-string">'Fahrenheit 451'</span></span>, <span class="hljs-string"><span class="hljs-string">'author'</span></span>: <span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>}</code> </pre> <br><p>  Dieser Ansatz hat jedoch Nachteile: </p><br><ul><li>  Es ist zu beachten, dass die Variable Daten enthält, die sich auf diese Struktur beziehen. </li><li>  Bei einem Wörterbuch müssen Sie die Namen der Schlüssel nachverfolgen.  Eine solche Initialisierung des Wörterbuchs <code>{'name': 'Fahrenheit 451', 'author': 'Bradbury'}</code> ist auch formal korrekt. </li><li>  Im Falle eines Tupels müssen Sie die Reihenfolge der Werte verfolgen, da diese keine Namen haben. </li></ul><br><p>  Es gibt eine bessere Option: </p><br><h3 id="namedtuple">  Namedtuple </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple NamedTupleBook = namedtuple(<span class="hljs-string"><span class="hljs-string">"NamedTupleBook"</span></span>, [<span class="hljs-string"><span class="hljs-string">"title"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span>])</code> </pre> <br><p>  Wenn wir die auf diese Weise erstellte Klasse verwenden, erhalten wir praktisch das Gleiche wie die Datenklasse. </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; book = NamedTupleBook("Fahrenheit 451", "Bradbury") &gt;&gt;&gt; book.author 'Bradbury' &gt;&gt;&gt; book NamedTupleBook(title='Fahrenheit 451', author='Bradbury') &gt;&gt;&gt; book == NamedTupleBook("Fahrenheit 451", "Bradbury")) True</code> </pre> <br><p>  Trotz der allgemeinen Ähnlichkeit haben benannte Tupel ihre Grenzen.  Sie kommen von der Tatsache, dass benannte Tupel immer noch Tupel sind. </p><br><p>  Erstens können Sie immer noch Instanzen verschiedener Klassen vergleichen. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Car = namedtuple(<span class="hljs-string"><span class="hljs-string">"Car"</span></span>, [<span class="hljs-string"><span class="hljs-string">"model"</span></span>, <span class="hljs-string"><span class="hljs-string">"owner"</span></span>]) &gt;&gt;&gt; book = NamedTupleBook(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>)) &gt;&gt;&gt; book == Car(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>  Zweitens sind benannte Tupel unveränderlich.  In einigen Situationen ist dies nützlich, aber ich möchte mehr Flexibilität. <br>  Schließlich können Sie sowohl ein benanntes als auch ein reguläres Tupel bearbeiten.  Zum Beispiel iterieren. </p><br><h3 id="drugie-proekty">  Andere Projekte </h3><br><p>  Wenn nicht auf die Standardbibliothek beschränkt, finden Sie andere Lösungen für dieses Problem.  Insbesondere das Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">attrs</a> .  Es kann sogar mehr als nur Datenklassen und funktioniert mit älteren Python-Versionen wie 2.7 und 3.4.  Die Tatsache, dass es nicht Teil der Standardbibliothek ist, kann jedoch unpraktisch sein </p><br><h2 id="sozdanie">  Schöpfung </h2><br><p>  <code>@dataclass</code> Dekorator <code>@dataclass</code> können Sie eine Datenklasse erstellen.  In diesem Fall werden alle Felder der mit Typanmerkung definierten Klasse in den entsprechenden Methoden der resultierenden Klasse verwendet. </p><br><p>  Alternativ gibt es die Funktion <code>make_dataclass</code> , die ähnlich wie das Erstellen benannter Tupel funktioniert. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> make_dataclass Book = make_dataclass(<span class="hljs-string"><span class="hljs-string">"Book"</span></span>, [<span class="hljs-string"><span class="hljs-string">"title"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span>]) book = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>)</code> </pre> <br><h2 id="znacheniya-po-umolchaniyu">  Standardwerte </h2><br><p>  Eine nützliche Funktion ist das einfache Hinzufügen von Standardwerten zu Feldern.  <code>__init__</code> Methode <code>__init__</code> immer noch nicht neu definiert werden. <code>__init__</code> einfach die Werte direkt in der Klasse an. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str = "Unknown" author: str = "Unknown author"</span></span></code> </pre> <br><p>  Sie werden bei der generierten <code>__init__</code> -Methode berücksichtigt </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Book() Book(title=<span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Unknown author'</span></span>) &gt;&gt;&gt; Book(<span class="hljs-string"><span class="hljs-string">"Farenheit 451"</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Farenheit 451'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Unknown author'</span></span>)</code> </pre> <br><p>  Aber wie bei regulären Klassen und Methoden müssen Sie vorsichtig sein, wenn Sie veränderbare Standardeinstellungen verwenden.  Wenn Sie beispielsweise die Liste als Standardwert verwenden müssen, gibt es einen anderen Weg, aber mehr dazu weiter unten. </p><br><p>  Darüber hinaus ist es wichtig, die Reihenfolge zu überwachen, in der Felder mit Standardwerten ermittelt werden, da diese genau mit der Reihenfolge in der Methode <code>__init__</code> </p><br><h2 id="immutabelnye-klassy-dannyh">  Unveränderliche Datenklassen </h2><br><p>  Instanzen benannter Tupel sind unveränderlich.  In vielen Situationen ist dies eine gute Idee.  Für Datenklassen können Sie dies auch tun.  <code>FrozenInstanceError</code> Sie beim Erstellen der Klasse einfach den Parameter <code>frozen=True</code> Wenn Sie versuchen, ihre Felder zu ändern, wird eine <code>FrozenInstanceError</code> Ausnahme <code>FrozenInstanceError</code> </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass(frozen=True) class Book: title: str author: str</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>book = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book.title = <span class="hljs-string"><span class="hljs-string">"1984"</span></span> dataclasses.FrozenInstanceError: cannot assign to field <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br><h2 id="nastroyka-klassa-dannyh">  Datenklasseneinstellung </h2><br><p>  Zusätzlich zum <code>frozen</code> Parameter verfügt der <code>@dataclass</code> Dekorator über weitere Parameter: </p><br><ul><li>  <code>init</code> : Wenn es <code>True</code> (Standard), wird die Methode <code>__init__</code> generiert.  Wenn für die Klasse bereits eine <code>__init__</code> -Methode definiert ist, wird der Parameter ignoriert. </li><li>  <code>repr</code> : <code>__repr__</code> (standardmäßig) die Erstellung der <code>__repr__</code> -Methode.  Die generierte Zeichenfolge enthält den Klassennamen sowie den Namen und die Darstellung aller in der Klasse definierten Felder.  In diesem Fall können einzelne Felder ausgeschlossen werden (siehe unten) </li><li>  <code>eq</code> : <code>__eq__</code> (standardmäßig) die Erstellung der <code>__eq__</code> -Methode.  Objekte werden auf die gleiche Weise verglichen, als wären sie Tupel mit den entsprechenden Feldwerten.  Zusätzlich wird die Typübereinstimmung überprüft. </li><li>  <code>order</code> aktiviert (Standard ist <code>__lt__</code> ) die Erstellung der <code>__ge__</code> <code>__lt__</code> , <code>__le__</code> , <code>__gt__</code> und <code>__ge__</code> .  Objekte werden auf die gleiche Weise wie die entsprechenden Tupel von Feldwerten verglichen.  Gleichzeitig wird auch die Art der Objekte überprüft.  Wenn <code>order</code> angegeben ist, <code>eq</code> jedoch nicht, wird eine <code>ValueError</code> Ausnahme ausgelöst.  Außerdem sollte die Klasse keine bereits definierten Vergleichsmethoden enthalten. </li><li>  <code>unsafe_hash</code> wirkt sich auf die Generierung der <code>__hash__</code> -Methode aus.  Das Verhalten hängt auch von den Werten der Parameter <code>eq</code> und <code>frozen</code> </li></ul><br><h2 id="nastroyka-otdelnyh-poley">  Passen Sie einzelne Felder an </h2><br><p>  In den meisten Standardsituationen ist dies nicht erforderlich, es ist jedoch möglich, das Verhalten der Datenklasse mithilfe der Feldfunktion an einzelne Felder anzupassen. </p><br><h3 id="izmenyaemye-znacheniya-po-umolchaniyu">  Änderbare Standardeinstellungen </h3><br><p>  Eine typische Situation, die oben erwähnt wurde, ist die Verwendung von Listen oder anderen veränderlichen Standardwerten.  Möglicherweise möchten Sie eine "Bücherregal" -Klasse mit einer Liste von Büchern.  Wenn Sie den folgenden Code ausführen: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Bookshelf: books: List[Book] = []</span></span></code> </pre> <br><p>  Der Dolmetscher meldet einen Fehler: </p><br><pre> <code class="plaintext hljs">ValueError: mutable default &lt;class 'list'&gt; for field books is not allowed: use default_factory</code> </pre> <br><p>  Bei anderen veränderlichen Werten funktioniert diese Warnung jedoch nicht und führt zu einem falschen Programmverhalten. </p><br><p>  Um Probleme zu vermeiden, wird empfohlen, den Parameter <code>default_factory</code> der <code>default_factory</code> zu verwenden.  Sein Wert kann ein beliebiges aufgerufenes Objekt oder eine Funktion ohne Parameter sein. <br>  Die richtige Version der Klasse sieht folgendermaßen aus: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Bookshelf: books: List[Book] = field(default_factory=list)</span></span></code> </pre> <br><h3 id="drugie-parametry">  Andere Optionen </h3><br><p>  Zusätzlich zur angegebenen <code>default_factory</code> verfügt die <code>default_factory</code> über die folgenden Parameter: </p><br><ul><li>  <code>default</code> : Der <code>default</code> .  Dieser Parameter ist erforderlich, da der Aufruf des <code>field</code> den Standardfeldwert ersetzt. </li><li>  <code>init</code> : <code>__init__</code> (Standard) die Verwendung eines Felds in der Methode <code>__init__</code> </li><li>  <code>repr</code> : <code>__repr__</code> (Standard) die Verwendung eines Felds in der <code>__repr__</code> -Methode </li><li>  <code>compare</code> beinhaltet (Standard) die Verwendung des Feldes in Vergleichsmethoden ( <code>__eq__</code> , <code>__le__</code> und andere) </li><li>  <code>hash</code> : Kann ein boolescher Wert oder <code>None</code> .  Wenn dies der <code>True</code> , wird das Feld zur Berechnung des Hashs verwendet.  Wenn (standardmäßig) <code>None</code> angegeben <code>None</code> , wird der Wert des <code>compare</code> verwendet. <br>  Einer der Gründe für die Angabe von <code>hash=False</code> für einen bestimmten <code>compare=True</code> kann die Schwierigkeit sein, den Feld-Hash zu berechnen, während er für den Vergleich erforderlich ist. </li><li>  <code>metadata</code> : Benutzerdefiniertes Wörterbuch oder <code>None</code> .  Der Wert wird in <code>MappingProxyType</code> sodass er unveränderlich wird.  Dieser Parameter wird von den Datenklassen selbst nicht verwendet und ist für Erweiterungen von Drittanbietern vorgesehen. </li></ul><br><h2 id="obrabotka-posle-inicializacii">  Verarbeitung nach der Initialisierung </h2><br><p>  Die automatisch generierte Methode <code>__init__</code> ruft die Methode <code>__post_init__</code> , sofern sie in der Klasse definiert ist.  In der Regel wird es in der Form <code>self.__post_init__()</code> jedoch Variablen vom Typ <code>InitVar</code> in der Klasse definiert <code>InitVar</code> , werden sie als Methodenparameter übergeben. </p><br><p>  Wenn die Methode <code>__init__</code> nicht generiert wurde, wird <code>__post_init__</code> nicht aufgerufen. </p><br><p>  Fügen Sie beispielsweise eine generierte Buchbeschreibung hinzu </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str author: str desc: str = None def __post_init__(self): self.desc = self.desc or "`%s` by %s" % (self.title, self.author)</span></span></code> </pre> <br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Book("Fareneheit 481", "Bradbury") Book(title='Fareneheit 481', author='Bradbury', desc='`Fareneheit 481` by Bradbury')</code> </pre> <br><h3 id="parametry-tolko-dlya-inicializacii">  Parameter nur zur Initialisierung </h3><br><p>  Eine der mit der Methode <code>__post_init__</code> verbundenen Möglichkeiten sind die Parameter, die nur für die Initialisierung verwendet werden.  Wenn Sie beim Deklarieren eines Felds <code>InitVar</code> als Typ angeben, wird sein Wert als Parameter der Methode <code>__post_init__</code> .  In keiner anderen Weise werden solche Felder in der Datenklasse verwendet. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str author: str gen_desc: InitVar[bool] = True desc: str = None def __post_init__(self, gen_desc: str): if gen_desc and self.desc is None: self.desc = "`%s` by %s" % (self.title, self.author)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Book(<span class="hljs-string"><span class="hljs-string">"Fareneheit 481"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Fareneheit 481'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>, desc=<span class="hljs-string"><span class="hljs-string">'`Fareneheit 481` by Bradbury'</span></span>) &gt;&gt;&gt; Book(<span class="hljs-string"><span class="hljs-string">"Fareneheit 481"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>, gen_desc=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Fareneheit 481'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>, desc=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><h2 id="nasledovanie">  Vererbung </h2><br><p>  Wenn Sie den Dekorator <code>@dataclass</code> , werden alle übergeordneten Klassen beginnend mit object durchlaufen. Für jede gefundene Datenklasse werden die Felder in einem geordneten Wörterbuch gespeichert und anschließend die Eigenschaften der verarbeiteten Klasse hinzugefügt.  Alle generierten Methoden verwenden Felder aus dem resultierenden geordneten Wörterbuch. </p><br><p>  Wenn die übergeordnete Klasse Standardwerte definiert, müssen Sie daher die Felder mit Standardwerten definieren. </p><br><p>  Da das geordnete Wörterbuch die Werte in Einfügereihenfolge für die folgenden Klassen speichert </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class BaseBook: title: Any = None author: str = None @dataclass class Book(BaseBook): desc: str = None title: str = "Unknown"</span></span></code> </pre> <br><p>  Eine <code>__init__</code> -Methode mit dieser Signatur wird generiert: </p><br><pre> <code class="plaintext hljs">def __init__(self, title: str="Unknown", author: str=None, desc: str=None)</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415829/">https://habr.com/ru/post/de415829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415815/index.html">An der Spitze der Wissenschaft: eine Analyse der Artikel von arxiv.org</a></li>
<li><a href="../de415817/index.html">Wir übertakten das Backup. Yandex Vortrag</a></li>
<li><a href="../de415819/index.html">Bericht des Club of Rome 2018, Kapitel 3.16: Globale Regierung</a></li>
<li><a href="../de415821/index.html">Der Weg, um ein "intelligentes" Haus mit einer möglichst breiten elektrischen Steuerung zu organisieren</a></li>
<li><a href="../de415823/index.html">FindFace schließt für bloße Sterbliche</a></li>
<li><a href="../de415831/index.html">Die neuen zehn Gebote des Roskosmos</a></li>
<li><a href="../de415833/index.html">Vor- und Nachteile von Xamarin</a></li>
<li><a href="../de415835/index.html">Wir schreiben GUI an 1C RAC oder wieder über Tcl / Tk</a></li>
<li><a href="../de415837/index.html">Ein kleiner Überblick über Solarlaternen</a></li>
<li><a href="../de415839/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 259 (25. Juni - 1. Juli)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>