<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèø ‚¨ÜÔ∏è üêï √úbergang vom Monolithen zum Mikrodienst: Geschichte und Praxis üé© ü§∂üèæ üë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich dar√ºber sprechen, wie sich das Projekt, in dem ich arbeite, von einem gro√üen Monolithen in eine Reihe von Mikrodiensten ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úbergang vom Monolithen zum Mikrodienst: Geschichte und Praxis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/458404/"> In diesem Artikel werde ich dar√ºber sprechen, wie sich das Projekt, in dem ich arbeite, von einem gro√üen Monolithen in eine Reihe von Mikrodiensten verwandelt hat. <br><br>  Das Projekt begann seine Geschichte vor langer Zeit, Anfang 2000. Die ersten Versionen wurden in Visual Basic 6 geschrieben. Im Laufe der Zeit wurde klar, dass die zuk√ºnftige Entwicklung dieser Sprache schwer zu unterst√ºtzen sein w√ºrde, da die IDE und die Sprache selbst schlecht entwickelt sind.  In den sp√§ten 2000er Jahren wurde beschlossen, auf ein vielversprechenderes C # umzusteigen.  Die neue Version wurde parallel zur Verfeinerung der alten Version geschrieben, nach und nach befand sich immer mehr Code in .NET.  Das Backend in C # konzentrierte sich zun√§chst auf die Dienstarchitektur. W√§hrend der Entwicklung wurden jedoch gemeinsam genutzte Bibliotheken mit Logik verwendet und Dienste in einem einzigen Prozess gestartet.  Es stellte sich heraus, dass die Anwendung, die wir "Service-Monolith" nannten. <br><br>  Einer der wenigen Vorteile dieses Bundles war die F√§higkeit der Dienste, sich gegenseitig √ºber eine externe API aufzurufen.  Es gab offensichtliche Voraussetzungen f√ºr den √úbergang zu einem korrekteren Service und in Zukunft zu einer Microservice-Architektur. <br><br>  Wir haben unsere Zersetzungsarbeiten um 2015 begonnen.  Wir haben noch keinen idealen Zustand erreicht - es gibt Teile eines gro√üen Projekts, die schwer als Monolithen zu bezeichnen sind, aber sie sehen auch nicht wie Mikrodienste aus.  Die Fortschritte sind jedoch erheblich. <br>  Ich werde im Artikel √ºber ihn sprechen. <br><br><img src="https://habrastorage.org/webt/ha/af/ct/haafctbyxepfypvukpmypyt30ji.png"><br><a name="habracut"></a><br><h3>  Inhalt </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architektur und Probleme der bestehenden L√∂sung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microservice-Erwartungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbergangsprobleme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So wechseln Sie von Monolith zu Microservices</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Weg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Weg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Weg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vierter Weg</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten Sie mit einer DB</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verzweigen Sie vorhandene Tabellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verarbeitungsabteilung</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten mit Quellcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Infrastrukturprobleme</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Manuelle Installation in Umgebungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Separate Protokollierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testen und Debuggen von verwandten Diensten</a> </li></ul></li></ul><br><br><a name="1"></a><h3>  <b>Architektur und Probleme der bestehenden L√∂sung</b> </h3><br>  Anf√§nglich sah die Architektur wie folgt aus: Die Benutzeroberfl√§che ist eine separate Anwendung, der monolithische Teil ist in Visual Basic 6 geschrieben, die Anwendung in .NET war eine Reihe verwandter Dienste, die mit einer ziemlich gro√üen Datenbank arbeiten. <br><br>  <b>Nachteile der vorherigen L√∂sung</b> <br><br>  <u>Single Point of Failure</u> <br>  Wir hatten einen einzigen Fehlerpunkt: Die .NET-Anwendung wurde in einem Prozess ausgef√ºhrt.  Wenn eines der Module abst√ºrzte, schlug die gesamte Anwendung fehl und Sie mussten sie neu starten.  Da wir eine gro√üe Anzahl von Prozessen f√ºr verschiedene Benutzer automatisieren, konnten einige aufgrund eines Fehlers in einem von ihnen f√ºr einige Zeit nicht funktionieren.  Und mit einem Softwarefehler hat auch die Redundanz nicht geholfen. <br><br>  <u>Die Aufstellung der Verbesserungen</u> <br>  Dieser Fehler ist eher organisatorisch.  Unsere Anwendung hat viele Kunden, und alle m√∂chten sie so schnell wie m√∂glich fertigstellen.  Bisher war dies nicht parallel m√∂glich, und alle Kunden standen in einer Schlange.  Dieser Prozess wirkte sich negativ auf das Gesch√§ft aus, da sie nachweisen mussten, dass ihre Aufgabe wertvoll war.  Und das Entwicklungsteam hat Zeit damit verbracht, diese Aufstellung zu organisieren.  Dies nahm viel Zeit und M√ºhe in Anspruch, und das Produkt konnte sich daher nicht so schnell √§ndern, wie es von ihm gewesen w√§re. <br><br>  <u>Unangemessener Einsatz von Ressourcen</u> <br>  Wenn Sie Services in einem einzigen Prozess platzieren, haben wir die Konfiguration immer vollst√§ndig von Server zu Server kopiert.  Wir wollten die am meisten ausgelasteten Dienste separat platzieren, um keine Ressourcen zu verschwenden und eine flexiblere Verwaltung unseres Bereitstellungsschemas zu erhalten. <br><br>  <u>Es ist schwer, moderne Technologie einzuf√ºhren</u> <br>  Ein Problem, das allen Entwicklern bekannt ist: Es besteht der Wunsch, moderne Technologien in das Projekt einzuf√ºhren, aber es gibt keine M√∂glichkeit.  Bei einer gro√üen monolithischen L√∂sung wird jede Aktualisierung der aktuellen Bibliothek, ganz zu schweigen vom √úbergang zu einer neuen, zu einer eher nicht trivialen Aufgabe.  Es dauert lange, um dem Teamleiter zu beweisen, dass es mehr Boni als verbrauchte Nerven bringt. <br><br>  <u>Schwierigkeiten beim Ausgeben von √Ñnderungen</u> <br>  Dies war das schwerwiegendste Problem - wir haben alle zwei Monate Ver√∂ffentlichungen ver√∂ffentlicht. <br>  Jede Ver√∂ffentlichung wurde trotz Tests und der Bem√ºhungen der Entwickler zu einer echten Katastrophe f√ºr die Bank.  Das Gesch√§ft verstand, dass zu Beginn der Woche einige der Funktionen f√ºr ihn nicht funktionieren w√ºrden.  Und die Entwickler haben verstanden, dass sie auf eine Woche mit schwerwiegenden Zwischenf√§llen warten. <br>  Jeder hatte den Wunsch, die Situation zu √§ndern. <br><br><a name="2"></a><h3>  <b>Microservice-Erwartungen</b> </h3><br>  <u>Lieferung der Komponenten nach Verf√ºgbarkeit.</u>  Lieferung von Komponenten, sobald diese verf√ºgbar sind, aufgrund der Zersetzung der L√∂sung und der Trennung verschiedener Prozesse. <br><br>  <u>Kleine Food-Teams.</u>  Dies ist wichtig, da ein gro√ües Team, das an einem alten Monolithen arbeitet, schwierig zu verwalten war.  Ein solches Team war gezwungen, nach einem strengen Prozess zu arbeiten, aber ich wollte mehr Kreativit√§t und Unabh√§ngigkeit.  Nur kleine Teams konnten es sich leisten. <br><br>  <u>Isolierung von Diensten in getrennten Prozessen.</u>  Im Idealfall wollte ich in Containern isolieren, aber eine gro√üe Anzahl von in .NET Framework geschriebenen Diensten wird nur unter Windows ausgef√ºhrt.  Jetzt gibt es Dienste in .NET Core, aber bisher gibt es nur wenige. <br><br>  <u>Flexibilit√§t bei der Bereitstellung.</u>  Ich m√∂chte Dienste nach Bedarf kombinieren und nicht nach den Anforderungen des Codes. <br><br>  <u>Einsatz neuer Technologien.</u>  Dies ist f√ºr jeden Programmierer interessant. <br><br><a name="3"></a><h3>  <b>√úbergangsprobleme</b> </h3><br>  Wenn es einfach w√§re, einen Monolithen in Microservices zu zerlegen, m√ºssten Sie nat√ºrlich nicht auf Konferenzen dar√ºber sprechen und Artikel schreiben.  In diesem Prozess gibt es viele Fallstricke, ich werde die wichtigsten beschreiben, die uns gest√∂rt haben. <br><br>  <b>Das erste Problem</b> ist typisch f√ºr die meisten Monolithen: die Koh√§renz der Gesch√§ftslogik.  Wenn wir einen Monolithen schreiben, m√∂chten wir unsere Klassen wiederverwenden, um keinen zus√§tzlichen Code zu schreiben.  Beim Wechsel zu Microservices wird dies zu einem Problem: Der gesamte Code ist eng miteinander verbunden, und es ist schwierig, Dienste zu trennen. <br><br>  Zu Beginn der Arbeiten verf√ºgte das Repository √ºber mehr als 500 Projekte und mehr als 700.000 Codezeilen.  Dies ist eine ziemlich gro√üe L√∂sung und das <b>zweite Problem</b> .  Es war nicht m√∂glich, es einfach in Microservices zu unterteilen. <br><br>  <b>Das dritte Problem</b> ist der Mangel an notwendiger Infrastruktur.  Tats√§chlich waren wir daran beteiligt, den Quellcode manuell auf die Server zu kopieren. <br><br><a name="4"></a><h3>  <b>So wechseln Sie von Monolith zu Microservices</b> </h3><br>  <u>Microservice-Zuordnung</u> <br><br>  Zun√§chst stellten wir sofort fest, dass die Trennung von Mikrodiensten ein iterativer Prozess ist.  Wir waren immer verpflichtet, die Entwicklung von Gesch√§ftsaufgaben parallel durchzuf√ºhren.  Wie wir dies technisch durchf√ºhren werden, ist bereits unser Problem.  Deshalb haben wir uns auf den iterativen Prozess vorbereitet.  Es funktioniert nicht anders, wenn Sie eine gro√üe Anwendung haben, und es ist nicht bereit, von Anfang an neu geschrieben zu werden. <br><br>  Mit welchen Methoden isolieren wir Microservices? <br><br><a name="5"></a>  <b>Die erste M√∂glichkeit</b> besteht darin, vorhandene Module als Dienste zu portieren.  In dieser Hinsicht hatten wir Gl√ºck: Es gab bereits formalisierte Dienste, die am WCF-Protokoll arbeiteten.  Sie wurden in separaten Baugruppen ver√∂ffentlicht.  Wir haben sie separat verschoben und jeder Baugruppe einen kleinen Launcher hinzugef√ºgt.  Es wurde mit der wunderbaren Topshelf-Bibliothek geschrieben, mit der Sie die Anwendung sowohl als Dienst als auch als Konsole ausf√ºhren k√∂nnen.  Dies ist praktisch f√ºr das Debuggen, da in der L√∂sung keine zus√§tzlichen Projekte erforderlich sind. <br><br>  Services wurden gem√§√ü der Gesch√§ftslogik verbunden, da sie gemeinsame Assemblys verwendeten und mit einer gemeinsamen Datenbank arbeiteten.  Es war schwierig, sie als Microservices in ihrer reinen Form zu bezeichnen.  Trotzdem k√∂nnten wir diese Dienstleistungen separat in verschiedenen Prozessen ausgeben.  Dies erm√∂glichte es bereits, ihren gegenseitigen Einfluss zu verringern und das Problem der parallelen Entwicklung und eines einzelnen Fehlerpunkts zu verringern. <br><br>  Das Erstellen mit einem Host ist nur eine Codezeile in der Program-Klasse.  Wir haben Topshelf in einer Helferklasse versteckt. <br><br><pre><code class="plaintext hljs">namespace RBA.Services.Accounts.Host { internal class Program { private static void Main(string[] args) { HostRunner&lt;Accounts&gt;.Run("RBA.Services.Accounts.Host"); } } }</code> </pre> <br><a name="6"></a>  <b>Der zweite Weg, um Microservices zu isolieren:</b> Erstellen Sie sie, um neue Probleme zu l√∂sen.  Wenn der Monolith nicht gleichzeitig w√§chst, ist dies bereits hervorragend, was bedeutet, dass wir uns in die richtige Richtung bewegen.  Um neue Probleme zu l√∂sen, haben wir versucht, separate Dienste bereitzustellen.  Wenn es eine solche Gelegenheit gab, haben wir mehr ‚Äûkanonische‚Äú Dienste erstellt, die ihr Datenmodell vollst√§ndig steuern, eine separate Datenbank. <br><br>  Wir haben wie viele andere mit Authentifizierungs- und Autorisierungsdiensten begonnen.  Sie sind perfekt daf√ºr.  Sie sind unabh√§ngig, haben in der Regel ein separates Datenmodell.  Sie selbst interagieren nicht mit dem Monolithen, nur er wendet sich an sie, um einige Probleme zu l√∂sen.  Bei diesen Diensten k√∂nnen Sie mit dem √úbergang zu einer neuen Architektur beginnen, die Infrastruktur auf ihnen debuggen, einige Ans√§tze im Zusammenhang mit Netzwerkbibliotheken ausprobieren usw.  In unserer Organisation gibt es keine Teams, die keinen Authentifizierungsdienst durchf√ºhren k√∂nnten. <br><br><a name="7"></a>  <b>Der dritte Weg, die von</b> uns verwendeten <b>Mikrodienste zu isolieren</b> , ist f√ºr uns ein wenig spezifisch.  Dadurch wird die Gesch√§ftslogik aus der UI-Ebene herausgezogen.  Wir haben die Hauptanwendung f√ºr die Desktop-Benutzeroberfl√§che, die wie das Backend in C # geschrieben ist.  Entwickler machten regelm√§√üig Fehler und f√ºhrten die UI-Teile der Logik aus, die im Backend h√§tten vorhanden sein und wiederverwendet werden sollen. <br><br>  Wenn Sie sich ein reales Beispiel aus dem Code des UI-Teils ansehen, k√∂nnen Sie sehen, dass der gr√∂√üte Teil dieser L√∂sung echte Gesch√§ftslogik enth√§lt, die in anderen Prozessen n√ºtzlich ist, nicht nur zum Erstellen eines UI-Formulars. <br><br><img src="https://habrastorage.org/webt/7s/_e/rb/7s_erbatvtbzompywj94igyvwho.jpeg"><br><br>  Die eigentliche UI-Logik besteht nur aus den letzten paar Zeilen.  Wir haben es auf den Server √ºbertragen, damit wir es wiederverwenden k√∂nnen, wodurch die Benutzeroberfl√§che reduziert und die richtige Architektur erreicht wird. <br><br><a name="8"></a>  <b>Die vierte, wichtigste Methode zur Isolierung von Mikrodiensten</b> , mit der Sie den Monolithen reduzieren k√∂nnen, ist das Entfernen vorhandener Dienste bei der Verarbeitung.  Wenn wir vorhandene Module so wie sie sind herausnehmen, ist das Ergebnis f√ºr Entwickler nicht immer angenehm, und der Gesch√§ftsprozess ab dem Zeitpunkt der Erstellung der Funktionalit√§t kann veraltet sein.  Dank Refactoring k√∂nnen wir einen neuen Gesch√§ftsprozess unterst√ºtzen, da sich die Gesch√§ftsanforderungen st√§ndig √§ndern.  Wir k√∂nnen den Quellcode verbessern, bekannte Fehler beseitigen und ein besseres Datenmodell erstellen.  Es gibt viele Vorteile. <br><br>  Die Abteilung Verarbeitungsdienstleistungen ist untrennbar mit dem Konzept eines begrenzten Kontexts verbunden.  Dies ist ein Konzept aus dem themenorientierten Design.  Dies bedeutet einen Dom√§nenmodellabschnitt, in dem alle Begriffe einer einzelnen Sprache eindeutig definiert sind.  Betrachten Sie als Beispiel den Kontext von Versicherungen und Rechnungen.  Wir haben eine monolithische Anwendung, und es ist notwendig, mit dem Konto in der Versicherung zu arbeiten.  Wir erwarten, dass der Entwickler die vorhandene "Account" -Klasse in einer anderen Assembly findet, einen Link von der "Insurance" -Klasse herstellt und einen Arbeitscode erh√§lt.  Das DRY-Prinzip wird eingehalten, die Aufgabe durch die Verwendung von vorhandenem Code wird schneller erledigt. <br><br>  Infolgedessen stellt sich heraus, dass die Kontexte von Konten und Versicherungen miteinander verbunden sind.  Wenn neue Anforderungen auftreten, wird diese Verbindung die Entwicklung beeintr√§chtigen und die Komplexit√§t einer bereits komplexen Gesch√§ftslogik erh√∂hen.  Um dieses Problem zu l√∂sen, m√ºssen Sie die Grenzen zwischen den Kontexten im Code finden und deren Verst√∂√üe entfernen.  Im Zusammenhang mit Versicherungen ist es beispielsweise durchaus m√∂glich, dass die 20-stellige Kontonummer der Zentralbank und das Datum der Kontoer√∂ffnung ausreichen. <br><br>  Um diese begrenzten Kontexte voneinander zu trennen und mit dem Extrahieren von Mikrodiensten aus einer monolithischen L√∂sung zu beginnen, haben wir einen Ansatz verwendet, z. B. das Erstellen externer APIs innerhalb der Anwendung.  Wenn wir wussten, dass ein Modul zu einem Microservice werden sollte, der sich im Rahmen des Prozesses irgendwie √§ndert, haben wir sofort die Logik, die zu einem anderen begrenzten Kontext geh√∂rt, durch externe Aufrufe aufgerufen.  Zum Beispiel √ºber REST oder WCF. <br><br>  Wir haben uns entschieden, Code, der verteilte Transaktionen erfordert, nicht zu vermeiden.  In unserem Fall stellte sich heraus, dass es recht einfach war, diese Regel einzuhalten.  Wir haben solche Situationen immer noch nicht erlebt, in denen hart verteilte Transaktionen wirklich ben√∂tigt werden - die endg√ºltige Konsistenz zwischen den Modulen ist v√∂llig ausreichend. <br><br>  Betrachten Sie ein bestimmtes Beispiel.  Wir haben das Konzept eines Orchesterf√∂rderers, der die Essenz der "Anwendung" verarbeitet.  Er erstellt abwechselnd einen Kunden, ein Konto und eine Bankkarte.  Wenn der Client und das Konto erfolgreich erstellt wurden und die Erstellung der Karte fehlgeschlagen ist, wechselt die Anwendung nicht in den Status "erfolgreich" und bleibt im Status "Karte nicht erstellt".  In Zukunft wird die Hintergrundaktivit√§t es aufnehmen und beenden.  Das System befindet sich seit einiger Zeit in einem Zustand der Inkonsistenz, aber dies passt insgesamt zu uns. <br><br>  Wenn dennoch eine Situation auftritt, in der ein Teil der Daten konsistent gespeichert werden muss, werden wir h√∂chstwahrscheinlich den Service erweitern, um dies in einem Prozess zu verarbeiten. <br><br>  Betrachten wir ein Beispiel f√ºr die Zuweisung von Mikroservices.  Wie kann es relativ sicher in die Produktion gebracht werden?  In diesem Beispiel haben wir einen separaten Teil des Systems - das Gehaltsservice-Modul, einen der Abschnitte des Codes, aus denen wir einen Microservice erstellen m√∂chten. <br><br><img src="https://habrastorage.org/webt/g2/kn/he/g2knhebep6zxxcl-14mfdxd6xow.jpeg"><br><br>  Zun√§chst erstellen wir einen Microservice, indem wir den Code neu schreiben.  Wir verbessern einige Punkte, die nicht zu uns passen.  Wir realisieren neue Gesch√§ftsanforderungen vom Kunden.  Wir erweitern das Bundle zwischen der Benutzeroberfl√§che und dem Gateway-API-Backend, das die Anrufweiterleitung erm√∂glicht. <br><br><img src="https://habrastorage.org/webt/g4/eo/sw/g4eoswb9nmxcoom9tbsug5quwsu.png"><br><br>  Als n√§chstes geben wir diese Konfiguration in Betrieb, jedoch im Status des Piloten.  Die meisten unserer Benutzer arbeiten immer noch mit alten Gesch√§ftsprozessen.  F√ºr neue Benutzer entwickeln wir eine neue Version einer monolithischen Anwendung, die dieser Prozess nicht mehr enth√§lt.  Tats√§chlich haben wir eine Reihe von Monolithen und Mikroservices, die in Form eines Piloten arbeiten. <br><br><img src="https://habrastorage.org/webt/vw/hn/p3/vwhnp3x9xxb1qrnz9rqe-552mvs.jpeg"><br><br>  Mit einem erfolgreichen Piloten verstehen wir, dass die neue Konfiguration wirklich funktionsf√§hig ist. Wir k√∂nnen den alten Monolithen aus der Gleichung entfernen und die neue Konfiguration anstelle der alten L√∂sung belassen. <br><br><img src="https://habrastorage.org/webt/4w/pk/a3/4wpka3wcyexlk-ohyvab4vucbts.png"><br><br>  Insgesamt verwenden wir fast alle vorhandenen Methoden zum Aufteilen des Quellcodes eines Monolithen.  All dies erm√∂glicht es uns, die Gr√∂√üe von Teilen der Anwendung zu reduzieren und sie in neue Bibliotheken zu √ºbertragen, wodurch ein besserer Quellcode entsteht. <br><br><a name="9"></a><h3>  <b>Arbeiten Sie mit einer DB</b> </h3><br>  Die Datenbank kann schlechter unterteilt werden als der Quellcode, da sie nicht nur das aktuelle Schema, sondern auch die gesammelten historischen Daten enth√§lt. <br><br>  Unsere Datenbank hatte wie viele andere einen weiteren wichtigen Nachteil - ihre enorme Gr√∂√üe.  Diese Datenbank wurde in √úbereinstimmung mit der komplizierten Gesch√§ftslogik des Monolithen entworfen, und es haben sich Verkn√ºpfungen zwischen Tabellen verschiedener begrenzter Kontexte angesammelt. <br><br>  In unserem Fall trat bei vielen gro√üen Projekten ein Problem auf, um alle Probleme zu l√∂sen (eine gro√üe Datenbank, viele Beziehungen, manchmal unverst√§ndliche Grenzen zwischen Tabellen): die Verwendung der gemeinsam genutzten Datenbankvorlage.  Daten wurden aus Tabellen durch Ansicht, durch Replikation entnommen und an andere Systeme gesendet, auf denen diese Replikation ben√∂tigt wird.  Infolgedessen konnten wir die Tabellen nicht in einem separaten Schema herausnehmen, da sie aktiv verwendet wurden. <br><br>  Die Trennung hilft uns, in begrenzte Kontexte im Code aufzubrechen.  Es gibt uns normalerweise eine ziemlich gute Vorstellung davon, wie wir Daten auf Datenbankebene aufteilen.  Wir verstehen, welche Tabellen sich auf einen begrenzten Kontext beziehen und welche sich auf einen anderen beziehen. <br><br>  Wir haben zwei globale Methoden zum Partitionieren der Datenbank angewendet: Partitionieren vorhandener Tabellen und Partitionieren mit Verarbeitung. <br><br>  Die Trennung vorhandener Tabellen ist eine Methode, die sich gut eignet, wenn die Datenstruktur von hoher Qualit√§t ist, die Gesch√§ftsanforderungen erf√ºllt und f√ºr alle geeignet ist.  In diesem Fall k√∂nnen wir vorhandene Tabellen in einem separaten Schema ausw√§hlen. <br><br>  Eine Verarbeitungsabteilung ist erforderlich, wenn sich das Gesch√§ftsmodell stark ge√§ndert hat und die Tabellen uns nicht mehr vollst√§ndig zufrieden stellen. <br><br><a name="10"></a>  <b>Separate vorhandene Tabellen.</b>  Wir m√ºssen bestimmen, was wir trennen werden.  Ohne dieses Wissen wird nichts daraus, und hier hilft uns die Trennung begrenzter Kontexte im Code.  Wenn es m√∂glich ist, die Grenzen von Kontexten im Quellcode zu verstehen, wird in der Regel klar, welche Tabellen zur Trennung in die Liste aufgenommen werden sollen. <br><br>  Stellen Sie sich vor, wir haben eine L√∂sung, bei der zwei Monolithmodule mit einer Datenbank interagieren.  Wir m√ºssen sicherstellen, dass nur ein Modul mit dem Teil der getrennten Tabellen interagiert und das andere √ºber die API mit ihm interagiert.  F√ºr den Anfang reicht es aus, dass nur ein Eintrag √ºber die API erfolgt.  Dies ist eine notwendige Bedingung, damit wir √ºber die Unabh√§ngigkeit von Mikrodiensten sprechen k√∂nnen.  Das Lesen von Links kann so lange bestehen bleiben, bis ein gro√ües Problem vorliegt. <br><br><img src="https://habrastorage.org/webt/ed/tk/ea/edtkeafsmsewkmmwbaxh-nicpou.jpeg"><br><br>  Im n√§chsten Schritt k√∂nnen wir bereits einen Codeabschnitt ausw√§hlen, der mit abnehmbaren Tabellen mit oder ohne Verarbeitung in einem separaten Microservice funktioniert, und ihn in einem separaten Prozesscontainer ausf√ºhren.  Dies ist ein separater Dienst mit Kommunikation mit der Monolith-Datenbank und den Tabellen, die nicht direkt damit zusammenh√§ngen.  Der Monolith interagiert immer noch mit dem abnehmbaren Teil zum Lesen. <br><br><img src="https://habrastorage.org/webt/39/xe/qp/39xeqpzjbsxcjtdxwh8_jgt4uxa.jpeg"><br><br>  Sp√§ter werden wir diese Verbindung entfernen, dh das Lesen der Daten der monolithischen Anwendung aus den getrennten Tabellen wird ebenfalls an die API √ºbertragen. <br><br><img src="https://habrastorage.org/webt/qu/j9/hx/quj9hx6oj3ovg71xy_lge9ziovg.png"><br><br>  Als n√§chstes w√§hlen wir aus der allgemeinen Datenbank die Tabellen aus, mit denen nur der neue Microservice arbeitet.  Wir k√∂nnen Tabellen in einem separaten Schema oder sogar in einer separaten physischen Datenbank platzieren.  Es gab eine Verbindung zum Lesen zwischen dem Microservice und der Monolith-Datenbank, aber es gibt keinen Grund zur Sorge, in dieser Konfiguration kann sie lange leben. <br><br><img src="https://habrastorage.org/webt/os/uc/zq/osuczqkdtaoxzmdmii1oni3qhlm.png"><br><br>  Der letzte Schritt besteht darin, alle Verbindungen vollst√§ndig zu entfernen.  In diesem Fall m√ºssen wir m√∂glicherweise Daten aus der Hauptdatenbank migrieren.  Manchmal m√∂chten wir einige Daten oder Verzeichnisse, die von externen Systemen repliziert wurden, in mehreren Datenbanken wiederverwenden.  Wir treffen uns regelm√§√üig. <br><br><img src="https://habrastorage.org/webt/9e/ws/m9/9ewsm976maj96yzqj_-atbml4ae.png"><br><br><a name="11"></a>  <b>Verarbeitungsabteilung.</b>  Diese Methode ist der ersten sehr √§hnlich und geht nur in umgekehrter Reihenfolge vor.  Wir haben sofort eine neue Datenbank und einen neuen Mikroservice, der √ºber die API mit dem Monolithen interagiert.  Gleichzeitig bleibt jedoch eine Reihe von Datenbanktabellen √ºbrig, die wir in Zukunft l√∂schen m√∂chten.  Wir werden es nicht mehr brauchen, in dem neuen Modell haben wir es ersetzt. <br><br><img src="https://habrastorage.org/webt/fy/ic/jx/fyicjxxkjagnsd_acgimthenabs.png"><br><br>  Damit dieses Schema funktioniert, ben√∂tigen wir h√∂chstwahrscheinlich eine √úbergangszeit. <br><br>  Es gibt zwei m√∂gliche Ans√§tze. <br><br>  <b>Erstens</b> : Wir duplizieren alle Daten in den neuen und alten Datenbanken.  In diesem Fall haben wir Datenredundanz, es kann Probleme mit der Synchronisation geben.  Aber dann k√∂nnen wir zwei verschiedene Kunden nehmen.  Einer wird mit der neuen Version arbeiten, der andere mit der alten. <br><br>  <b>Zweitens</b> : Wir teilen Daten nach bestimmten Gesch√§ftsmerkmalen.  In unserem System waren beispielsweise 5 Produkte in der alten Datenbank gespeichert.  Als sechste haben wir im Rahmen einer neuen Gesch√§ftsaufgabe eine neue Datenbank erstellt.  Wir ben√∂tigen jedoch die Gateway-API, die diese Daten synchronisiert und dem Client zeigt, wohin und was er nehmen soll. <br><br>  Beide Ans√§tze funktionieren, je nach Situation w√§hlen. <br><br>  Nachdem wir sichergestellt haben, dass alles funktioniert, kann der Teil des Monolithen, der mit den alten Datenbankstrukturen funktioniert, deaktiviert werden. <br><br><img src="https://habrastorage.org/webt/1j/tf/tg/1jtftgwoy_c-bcfa8yddp5whppc.png"><br><br>  Der letzte Schritt besteht darin, die alten Datenstrukturen zu entfernen. <br><br><img src="https://habrastorage.org/webt/4r/4o/m_/4r4om_wgj3wwxi25mf45eg_umss.png"><br><br>  Zusammenfassend k√∂nnen wir sagen, dass wir Probleme mit der Datenbank haben: Es ist schwierig, damit zu arbeiten, verglichen mit dem Quellcode, es ist schwieriger zu trennen, aber dies kann und sollte getan werden.  Wir haben einige M√∂glichkeiten gefunden, die dies ziemlich sicher erm√∂glichen, aber es ist einfacher, einen Fehler mit den Daten als mit dem Quellcode zu machen. <br><br><a name="12"></a><h3>  <b>Arbeiten mit Quellcode</b> </h3><br>  So sah das Quellcodediagramm aus, als wir mit der Analyse eines monolithischen Projekts begannen. <br><br><img src="https://habrastorage.org/webt/wx/z2/2m/wxz22mn86ej9jfyhkjww7zmvnoe.png"><br><br>  Es kann bedingt in drei Schichten unterteilt werden.  Dies ist eine Schicht aus gestarteten Modulen, Plugins, Diensten und einzelnen Aktivit√§ten.  Tats√§chlich waren dies die Eintrittspunkte innerhalb der monolithischen L√∂sung.  Alle von ihnen waren fest mit einer gemeinsamen Schicht verbunden.  Es hatte Gesch√§ftslogik, die zwischen Diensten geteilt wurde, und viele Verbindungen.  Jeder Dienst und jedes Plugin verwendete je nach Gr√∂√üe und Gewissen der Entwickler bis zu 10 oder mehr g√§ngige Assemblys. <br><br>  Wir hatten Gl√ºck, wir hatten Infrastrukturbibliotheken, die separat genutzt werden konnten. <br><br>  Manchmal trat eine Situation auf, in der einige der allgemeinen Objekte nicht zu dieser Schicht geh√∂rten, sondern Infrastrukturbibliotheken waren.  Dies wurde durch Umbenennen entschieden. <br><br>  Am meisten besorgt √ºber begrenzte Kontexte.  Fr√ºher mischten sich 3-4 Kontexte in einer gemeinsamen Assembly und verwendeten sich gegenseitig innerhalb derselben Gesch√§ftsfunktionen.  Es war notwendig zu verstehen, wo und an welchen Grenzen dies unterteilt werden kann und was als n√§chstes mit der Zuordnung dieser Trennung in Quellcode-Assemblys zu tun ist. <br><br>  Wir haben mehrere Regeln f√ºr den Codetrennungsprozess formuliert. <br><br>  <b>Erstens</b> : Wir wollten keine Gesch√§ftslogik mehr zwischen Diensten, Aktivit√§ten und Plugins teilen.  Sie wollten die Gesch√§ftslogik im Rahmen von Microservices unabh√§ngig machen.  Andererseits werden Microservices im Idealfall als Dienste wahrgenommen, die v√∂llig unabh√§ngig existieren.  Ich glaube, dass dieser Ansatz etwas verschwenderisch ist und schwer zu erreichen ist, da beispielsweise Dienste in C # auf jeden Fall durch eine Standardbibliothek verbunden werden.  Unser System ist in C # geschrieben, andere Technologien wurden noch nicht verwendet.  Aus diesem Grund haben wir beschlossen, dass wir es uns leisten k√∂nnen, gemeinsame technische Baugruppen zu verwenden.  Die Hauptsache ist, dass sie keine Fragmente der Gesch√§ftslogik haben.  Wenn Sie einen praktischen Wrapper √ºber dem von Ihnen verwendeten ORM haben, ist das Kopieren von Service zu Service sehr teuer. <br><br>  Unser Team ist ein Fan von themenorientiertem Design, daher ist die ‚ÄûZwiebelarchitektur‚Äú perfekt f√ºr uns.  Die Basis unserer Services war keine Datenzugriffsschicht, sondern eine Assembly mit Dom√§nenlogik, die nur Gesch√§ftslogik enth√§lt und keine Infrastrukturverbindungen aufweist.  Gleichzeitig k√∂nnen wir die Dom√§nenassembly unabh√§ngig √§ndern, um die mit den Frameworks verbundenen Probleme zu l√∂sen. <br><br>  Zu diesem Zeitpunkt stie√üen wir auf das erste ernsthafte Problem.  Der Dienst sollte sich auf eine Dom√§nenassembly beziehen, wir wollten die Logik unabh√§ngig machen, und hier hat uns das DRY-Prinzip stark gest√∂rt.  Um Doppelarbeit zu vermeiden, wollten die Entwickler Klassen aus benachbarten Assemblys wiederverwenden. Infolgedessen begannen die Dom√§nen wieder miteinander zu kommunizieren.  Wir haben die Ergebnisse analysiert und festgestellt, dass das Problem m√∂glicherweise auch im Bereich des Quellcode-Speicherger√§ts liegt.  Wir hatten ein gro√ües Repository, in dem alle Quellcodes lagen.  Die L√∂sung f√ºr das gesamte Projekt war auf einer lokalen Maschine sehr schwierig zu montieren.  Aus diesem Grund wurden separate kleine L√∂sungen f√ºr die Teile des Projekts erstellt, und niemand verbot, ihnen eine gemeinsame oder Dom√§nen-Assembly hinzuzuf√ºgen und sie wiederzuverwenden.  Das einzige Tool, das uns dies nicht erlaubte, war der √úberpr√ºfungscode.  Aber manchmal st√ºrzte er auch ab. <br><br>  Dann begannen wir, zu einem Modell mit separaten Repositorys zu wechseln.  Die Gesch√§ftslogik flie√üt nicht mehr von Service zu Service, Dom√§nen sind wirklich unabh√§ngig geworden.  Begrenzte Kontexte werden klarer unterst√ºtzt.  Wie verwenden wir Infrastrukturbibliotheken wieder?  Wir haben sie einem separaten Repository zugewiesen und sie dann in die Nuget-Pakete gestellt, die wir in Artifactory abgelegt haben.  Bei jeder √Ñnderung erfolgt die Zusammenstellung und Ver√∂ffentlichung automatisch. <br><br><img src="https://habrastorage.org/webt/so/tk/g_/sotkg_uskgxq41d3swhkewhkzcy.png"><br><br>  Unsere Dienstleistungen bezogen sich auf interne Infrastrukturpakete genauso wie auf externe.  Wir laden externe Bibliotheken von Nuget herunter.  Um mit Artifactory zu arbeiten, wo wir diese Pakete abgelegt haben, haben wir zwei Paketmanager verwendet.  In kleinen Repositories haben wir auch Nuget verwendet.  In Repositorys mit mehreren Diensten haben wir Paket verwendet, das mehr Versionskonsistenz zwischen Modulen bietet. <br><br><img src="https://habrastorage.org/webt/dr/0g/qe/dr0gqecxnqni4wcer4m1ogw-x70.png"><br><br>  Durch die Arbeit am Quellcode, die geringf√ºgige √Ñnderung der Architektur und die gemeinsame Nutzung von Repositorys machen wir unsere Dienste unabh√§ngiger. <br><br><a name="13"></a><h3>  <b>Infrastrukturprobleme</b> </h3><br>  Die meisten Nachteile der Umstellung auf Microservices h√§ngen mit der Infrastruktur zusammen.  Sie ben√∂tigen eine automatisierte Bereitstellung, Sie ben√∂tigen neue Bibliotheken f√ºr die Infrastruktur. <br><br><a name="16"></a>  <b>Manuelle Installation in Umgebungen</b> <br><br>  Zun√§chst haben wir die L√∂sung manuell in der Umgebung installiert.  Um diesen Prozess zu automatisieren, haben wir eine CI / CD-Pipeline erstellt.  Wir haben uns f√ºr den kontinuierlichen Lieferprozess entschieden, da eine kontinuierliche Bereitstellung f√ºr uns aus Sicht der Gesch√§ftsprozesse noch nicht akzeptabel ist.  Daher erfolgt das Senden an den Betrieb √ºber die Schaltfl√§che und zum Testen - automatisch. <br><br><img src="https://habrastorage.org/webt/vz/lp/yw/vzlpyw7h9ej1gdxvkzqwivl_gqu.png"><br><br>  Wir verwenden Atlassian, Bitbucket zum Speichern des Quellcodes und Bamboo zum Zusammenstellen.  Wir schreiben gerne Assembly-Skripte in Cake, weil es das gleiche C # ist.  Vorgefertigte Pakete kommen zu Artifactory, und Ansible gelangt automatisch zu den Testservern, wonach sie sofort getestet werden k√∂nnen. <br><br><img src="https://habrastorage.org/webt/-g/5p/dn/-g5pdnzpev-odvgxu-woy7qtcny.png"><br><br><a name="14"></a><h3>  <b>Separate Protokollierung</b> </h3><br>  Zu einer Zeit war eine der Ideen des Monolithen die Bereitstellung einer gemeinsamen Protokollierung.  Wir mussten auch verstehen, was mit den einzelnen Protokollen auf den Datentr√§gern zu tun ist.  Protokolle werden in Textdateien an uns geschrieben.  Wir haben uns f√ºr den Standard-ELK-Stack entschieden.  Wir haben nicht √ºber Anbieter direkt an die ELK geschrieben, sondern beschlossen, die Textprotokolle fertigzustellen und die darin enthaltene Ablaufverfolgungs-ID als Kennung aufzuschreiben und den Dienstnamen hinzuzuf√ºgen, damit diese Protokolle dann analysiert werden k√∂nnen. <br><br><img src="https://habrastorage.org/webt/e5/pd/ws/e5pdwsgrrb-9cpjhxabejxqdpt8.png"><br><br>  Mit Filebeat haben wir die M√∂glichkeit, unsere Protokolle von Servern zu sammeln und sie dann zu konvertieren. Mit Kibana k√∂nnen Sie Anforderungen in der Benutzeroberfl√§che erstellen und beobachten, wie der Anruf zwischen den Diensten verlaufen ist.  Die Trace-ID hilft dabei sehr. <br><br><a name="15"></a><h3>  <b>Testen und Debuggen von verwandten Diensten</b> </h3><br>  Anfangs haben wir nicht vollst√§ndig verstanden, wie entwickelte Dienste zu debuggen sind.  Mit dem Monolithen war alles einfach, wir haben ihn auf dem lokalen Computer ausgef√ºhrt.  Zuerst haben sie versucht, dasselbe mit Microservices zu tun, aber manchmal m√ºssen Sie mehrere andere ausf√ºhren, um einen Microservice vollst√§ndig zu starten, was unpraktisch ist.  ,     ,          ,   .     ,     prod.  ,  ,          .  ,     ,        . <br><br>  ,     production- .      ,         . <br><br>           Specflow.      NUnit     Ansible.     ,      .   -    .  ,      ,     Jira. <br><br>      ,       .      JMeter,    ‚Äî InfluxDB,      ‚Äî Grafana. <br><br><h3> <b>  ?</b> </h3><br> -,     ¬´¬ª.    ,      production-,    -.        1,5 ,  ,        . <br><br>      .      ,       ,      .     . <br><br>     .        ,     . <br><br>  ,        .      ,      .     Scrum-.        ,    . <br><br><h3>  <b>Zusammenfassung</b> </h3><br><ul><li>       .     ,     ,    ,    .            . </li><li>    .        ,        ,     .    ,         , ,     Scrum. </li><li>  ‚Äî   .        .      .       legacy,      ,            . <br><br> <i> :</i>       .        . ,     ,     ,     ,        , , ,  ‚Äî   ,    .   .     ,     ,          . <br><br> PS    (    ) ‚Äì  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br>    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458404/">https://habr.com/ru/post/de458404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458382/index.html">Warum unterrichten wir das?</a></li>
<li><a href="../de458384/index.html">HP 3D Strukturierter Lichtscanner Pro S3 √úberpr√ºfung und Test</a></li>
<li><a href="../de458388/index.html">Deep (Learning + Random) Wald- und Artikelanalyse</a></li>
<li><a href="../de458390/index.html">Ceph - von "auf dem Knie" bis "Produktion" Teil 2</a></li>
<li><a href="../de458400/index.html">Microservices-Architektur und -Implementierung Schritt f√ºr Schritt Teil 1</a></li>
<li><a href="../de458406/index.html">√úber 30 Fragen zu Dienstprogrammen und Nicht-Dienstprogrammen</a></li>
<li><a href="../de458408/index.html">Sicherheitswoche 27: Sicherheitsl√ºcken in der Insulinpumpe</a></li>
<li><a href="../de458410/index.html">Entwicklung einer Online-Shop-Struktur basierend auf Clustering und Lemmatisierung der Semantik</a></li>
<li><a href="../de458412/index.html">Ist Blockchain hier nur f√ºr PR und Hype?</a></li>
<li><a href="../de458414/index.html">So √§ndern Sie Ihre Karriere, werden im Alter von 30 Jahren Frontend-Entwickler und arbeiten nach Belieben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>