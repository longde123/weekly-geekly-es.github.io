<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔵 🕸️ 💪🏻 Bagaimana grafik NES diatur? 🙆🏾 🤦🏿 👩🏻‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diluncurkan pada tahun 1983, konsol rumah Nintendo Entertainment System (NES) adalah mesin murah namun kuat yang mencapai kesuksesan fenomenal. Menggu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana grafik NES diatur?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="gambar"></div><br>  Diluncurkan pada tahun 1983, konsol rumah Nintendo Entertainment System (NES) adalah mesin murah namun kuat yang mencapai kesuksesan fenomenal.  Menggunakan Picture Processing Unit (PPU), sistem dapat membuat grafik yang cukup mengesankan untuk saat-saat itu, yang bahkan saat ini terlihat cukup baik dalam konteks yang benar.  Aspek yang paling penting adalah efisiensi memori - ketika membuat grafik, kami harus mengelola dengan byte sesedikit mungkin.  Namun, seiring dengan ini, NES memberikan pengembang dengan fitur yang kuat dan mudah digunakan yang membuatnya menonjol dari konsol rumah yang lebih lama.  Setelah memahami prinsip-prinsip membuat grafik NES, Anda dapat merasakan kesempurnaan teknis sistem dan menyadari betapa lebih mudah bagi pengembang game modern untuk bekerja. <br><br>  Grafik latar belakang NES dirakit dari empat komponen terpisah, kombinasi yang membentuk gambar yang kita lihat di layar.  Setiap komponen bertanggung jawab atas aspek yang terpisah;  warna, tata letak, grafik piksel mentah, dll.  Sistem seperti itu mungkin terlihat rumit dan tidak perlu, tetapi pada akhirnya menggunakan memori jauh lebih efisien dan memungkinkan menciptakan efek sederhana dalam sejumlah kecil kode.  Jika Anda ingin memahami grafis NES, maka keempat komponen ini akan menjadi informasi utama. <br><br>  Artikel ini mengasumsikan bahwa Anda terbiasa dengan matematika komputer, dan khususnya dengan fakta bahwa 8 bit = 1 byte, dan 8 bit dapat mewakili 256 nilai.  Pemahaman tentang bagaimana notasi heksadesimal bekerja juga diperlukan.  Tetapi bahkan tanpa pengetahuan teknis ini, artikel itu mungkin tampak menarik. <br><a name="habracut"></a><br><h1>  Ulasan singkat </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/6f8/9a7/ca16f89a75e658d68c28f81e9794ff86.png" width="512" height="480"></div><br>  Di atas adalah gambar dari adegan pertama Castlevania (1986): gerbang menuju ke kastil, di mana permainan akan berlangsung.  Gambar ini berukuran 256 × 240 piksel dan menggunakan 10 warna berbeda.  Untuk menggambarkan gambar ini dalam memori, kita harus mengambil keuntungan dari palet warna terbatas, dan menghemat ruang dengan menyimpan hanya sejumlah kecil informasi.  Salah satu pendekatan naif adalah dengan menggunakan palet yang diindeks di mana setiap piksel memiliki volume 4 bit, yaitu, 2 piksel ditempatkan dalam byte.  Ini akan membutuhkan 256 * 240/2 = 30720 byte, tetapi seperti yang akan segera kita lihat, NES dapat mengatasi tugas ini dengan jauh lebih efisien. <br><br>  Konsep utama dalam tema grafis NES adalah ubin dan blok [1].  Ubin adalah area 8 × 8 piksel, dan blok adalah area 16 × 16 piksel, dan masing-masing terikat ke kisi dengan ukuran sel yang sama.  Setelah menambahkan kisi-kisi ini, kita dapat melihat struktur grafik.  Inilah pintu masuk ke kastil dengan kisi-kisi dengan pembesaran ganda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uz/de/sk/uzdeskry1wkruscxe8xsyephbnc.png"></div><br>  Di kisi ini, blok ditampilkan dalam warna hijau muda, dan ubin dalam warna hijau gelap.  Penguasa di sepanjang sumbu memiliki nilai heksadesimal yang dapat ditambahkan untuk menemukan posisi;  misalnya, jantung pada bilah status adalah $ 15 + $ 60 = $ 75, yang dalam desimal adalah 117. Setiap layar berisi 16 × 15 blok (240) dan 32 × 30 ubin (960).  Sekarang mari kita lihat bagaimana gambar ini dijelaskan dan mulai dengan grafik piksel mentah. <br><br><h1>  CHR </h1><br>  Struktur CHR menggambarkan grafis piksel "mentah" tanpa warna dan posisinya, dan diatur dalam ubin.  Seluruh halaman memori berisi 256 ubin CHR, dan setiap ubin memiliki kedalaman 2 bit.  Berikut adalah gambar jantung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/d14/fb3/ad9d14fb3cc4321c5ae65e1e7f61dd52.png" width="128" height="128"></div><br>  Dan inilah bagaimana itu dijelaskan dalam CHR [2]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/162/974/e0f/162974e0fe800447c8edecf9157d1763.png" alt="pixel-heart-chr" width="128" height="128"></div><br>  Deskripsi seperti itu membutuhkan 2 bit per pixel, yaitu, dengan ukuran 8 × 8 ternyata 8 * 8 * 2 = 128 bit = 16 byte.  Kemudian seluruh halaman membutuhkan 16 * 256 = 4096 byte.  Berikut ini semua CHR yang digunakan dalam gambar dari Castlevania. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/3ef/83d/5da3ef83d0e339ca2d91d799745157e9.png" width="271" height="101"></div><br>  Ingatlah bahwa mengisi gambar memerlukan 960 ubin, tetapi CHR memungkinkan Anda untuk hanya menggunakan 256. Ini berarti bahwa sebagian besar ubin diulang, rata-rata, 3,75 kali, tetapi lebih sering hanya sejumlah kecil dari mereka yang digunakan (misalnya, latar belakang kosong, ubin monokrom atau pola berulang).  Gambar dari Castlevania menggunakan banyak ubin kosong, serta biru pekat.  Untuk melihat bagaimana ubin diberikan, kami menggunakan kartu nama. <br><br><h1>  NAMETABLE </h1><br>  Tabel nama memberikan file CHR ke setiap posisi di layar, dan totalnya ada 960. Setiap posisi ditentukan dalam satu byte, artinya, seluruh tabel nama memakan waktu hingga 960 byte.  Ubin diberikan secara berurutan dari kiri ke kanan, dari atas ke bawah, dan sesuai dengan posisi terhitung yang ditemukan dengan menambahkan nilai-nilai dari penggaris yang ditunjukkan di atas.  Artinya, posisi di sudut kiri atas adalah $ 0, di sebelah kanan adalah $ 1, dan di bawahnya adalah $ 20. <br><br>  Nilai-nilai dalam nametable tergantung pada urutan di mana CHR diisi.  Berikut adalah salah satu opsi [3]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h_/vs/qc/h_vsqc5mxdu8ydb1o8cu4mflf9e.png"></div><br>  <i>Dalam hal ini, hati (pada posisi $ 75) memiliki nilai $ 13.</i> <br><br>  Selanjutnya, untuk menambah warna, kita perlu memilih palet. <br><br><h1>  Palet </h1><br>  NES memiliki palet sistem 64 warna [4], dan darinya kami memilih palet yang akan digunakan dalam rendering.  Setiap palet berisi 3 warna unik ditambah warna latar belakang keseluruhan.  Gambar memiliki maksimal 4 palet, yang secara total menempati 16 byte.  Berikut adalah palet untuk gambar dari Castlevania: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f03/59a/259/f0359a259c032b5f6c9048c0231ffb85.png" alt="castlevania-sobat" width="168" height="24"></div><br>  Palet tidak dapat digunakan secara sewenang-wenang.  Hanya satu palet yang diterapkan per blok.  Itu karena kebutuhan ini untuk memisahkan masing-masing area 16 × 16 sesuai dengan palet warna permainan untuk NES memiliki tampilan "blok".  Grafis yang dijalankan dengan baik, misalnya, dari layar splash Castlevania, dapat dihindari dengan mencampurkan warna di tepi blok, yang menyembunyikan keberadaan kisi-kisi. <br><br>  Pemilihan palet untuk setiap blok dilakukan dengan menggunakan komponen terakhir - atribut. <br><br><h1>  Atribut </h1><br>  Atribut menempati 2 bit per blok.  Mereka menentukan mana dari 4 palet yang akan digunakan.  Gambar ini menunjukkan palet mana yang ditentukan oleh atribut menggunakan blok yang berbeda [5]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/kj/3i/k4kj3imqlxxbwnasjcz3t60abym.png"></div><br>  Seperti yang Anda lihat, palet dibagi menjadi beberapa bagian, tetapi ini rumit karena penggunaan warna yang sama di area yang berbeda.  Merah di tengah gerbang menyatu dengan dinding yang mengelilinginya, dan latar belakang hitam mengaburkan garis di antara kastil <br>  dan gerbang. <br><br>  Dengan 2 bit per blok atau 4 blok per byte, atribut gambar hanya menempati 240/4 = 60 byte, tetapi karena cara mereka dikodekan, 4 byte lainnya terbuang, yaitu, total 64 byte diperoleh.  Ini berarti bahwa seluruh gambar, termasuk CHR, nametable, palet dan atribut, menempati 4096 + 960 + 16 + 64 = 5136 byte - jauh lebih baik daripada 30720 yang disebutkan di atas. <br><br><h1>  MAKECHR </h1><br>  Membuat empat komponen ini untuk grafik NES lebih sulit daripada menggunakan bitmap APIs biasa, tetapi alat bantu datang untuk menyelamatkan.  Pengembang NES mungkin memiliki beberapa jenis rantai alat, tetapi apa pun itu, ceritanya tidak menyelamatkannya.  Saat ini, pengembang biasanya menulis program untuk mengonversi gambar ke format NES yang diinginkan. <br><br>  Semua gambar dalam posting ini dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makechr</a> , alat yang ditulis ulang yang digunakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Star Versus</a> .  Ini adalah alat baris perintah yang dirancang untuk pembuatan otomatis dan ditujukan untuk kecepatan, kualitas pesan kesalahan, portabilitas dan kelengkapan.  Dia juga menciptakan visualisasi yang menarik seperti yang digunakan dalam pos. <br><br><h1>  Referensi </h1><br>  Sebagian besar pengetahuan tentang pemrograman untuk NES, dan terutama tentang membuat grafik, saya dapatkan dari sumber-sumber berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nintendo Age Nerdy Nights</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wiki NesDev</a> </li></ul><br><h1>  Catatan </h1><br>  [1] Terminologi - dalam beberapa dokumen, blok disebut "meta-tile", yang secara pribadi tampaknya kurang berguna bagi saya. <br><br>  [2] Pengkodean CHR - 2 bit per piksel tidak disimpan bersebelahan.  Gambar penuh pertama-tama disimpan hanya dengan bit-bit rendah, dan sekali lagi disimpan hanya dengan bit-bit tinggi. <br><br>  Artinya, jantung akan disimpan seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc5/68c/f95/cc568cf959b148d1d11a408876806ae8.png" alt="pixel-heart-low" width="128" height="128"><img src="https://habrastorage.org/getpro/habr/post_images/f87/947/070/f879470703605322e98a2582241b071e.png" alt="pixel-heart-high" width="128" height="128"><br><br>  Setiap baris adalah satu byte.  Yaitu, 01100110 adalah $ 66, 01111111 adalah $ 7f.  Secara total, byte jantung terlihat seperti ini: <br><br>  $ 66 $ 7f $ ff $ ff $ ff $ 7e $ 3c $ 18 $ 66 $ 5f $ bf $ bf $ ff $ 7e $ 3c $ 18 <br><br>  [3] Nametable - dalam bagan dalam game ini, tabel nama digunakan secara berbeda.  Biasanya, huruf-huruf alfabet disimpan dalam memori di lingkungan tersebut, termasuk Castlevania. <br><br>  [4] Palet Sistem - NES tidak menggunakan palet RGB, dan warna sebenarnya yang dihasilkan tergantung pada TV tertentu.  Emulator biasanya menggunakan palet RGB yang sangat berbeda.  Warna-warna dalam artikel ini sesuai dengan palet yang dijabarkan dalam makechr. <br><br>  [5] Pengkodean Atribut - Atribut disimpan dalam urutan yang aneh.  Mereka tidak pergi dari kiri ke kanan, dari atas ke bawah - area blok 2 × 2 dikodekan dengan satu byte, dalam bentuk huruf Z. Itulah sebabnya 4 byte terbuang sia-sia;  Intinya adalah 8 byte penuh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/951/0db/71a9510db28128bca1841689ce909c27.png" alt="sobat-blok-kelompok" width="64" height="64"></div><br>  Misalnya, blok $ 308 disimpan dengan $ 30a, $ 348, dan $ 34a.  Nilai palet mereka adalah 1, 2, 3, dan 3, dan disimpan secara berurutan dari posisi terendah ke posisi tertinggi, atau 11 :: 11 :: 10 :: 01 = 11111001. Oleh karena itu, nilai byte atribut ini adalah $ f9. <br><br><h2>  Bagian 2 </h2><br>  Pada bagian pertama, kami berbicara tentang komponen-komponen grafik latar belakang NES - CHR, nametable, palet, dan atribut.  Tapi ini baru setengah dari cerita. <br><br>  Untuk memulainya, sebenarnya ada dua tabel nama [6].  Masing-masing dari mereka memiliki atribut sendiri untuk mengatur warna, tetapi mereka memiliki CHR yang sama.  Peralatan kartrid menentukan posisinya: apakah bersebelahan, atau satu di atas lainnya.  Berikut ini adalah contoh dari dua jenis lokasi - Lode Runner (1984) dan Bubble Bobble (1988). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/7ef/7c9/7597ef7c97f3e31ed3bb4198727dee37.png" width="512" height="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/035/72a/0e703572ad771478c13bffa254a86579.png" alt="bubble-bobble-scrolling" width="532" height="480"></div><br><h1>  Bergulir </h1><br>  Untuk memanfaatkan kehadiran dua tabel nama, PPU mendukung kemampuan untuk menggulir berdasarkan piksel pada satu waktu di sepanjang sumbu X dan Y. Ia dikendalikan oleh register dengan tampilan memori pada $ 2005: menulis hanya dua byte pada alamat ini memindahkan seluruh layar ke jumlah piksel yang diinginkan [7] .  Pada saat rilis NES, ini adalah keunggulan utama dibandingkan konsol rumah lainnya, di mana untuk menggulir sering harus menulis ulang seluruh memori video.  Skema yang mudah digunakan menyebabkan munculnya sejumlah besar platformer dan penembak, dan menjadi alasan utama untuk sukses besar sistem. <br><br>  Untuk gim sederhana, bidang yang lebarnya hanya dua layar, misalnya, Load Runner, cukup hanya mengisi kedua tabel nama dan mengubah gulir yang sesuai.  Tetapi di sebagian besar gulir permainan, level memiliki lebar yang berubah-ubah.  Untuk mengimplementasikannya, gim harus memperbarui bagian di luar layar dari tabel nama sebelum muncul di layar.  Nilai gulir diulang, tetapi karena tabel nama terus diperbarui, ini menciptakan ilusi ukuran tak terbatas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/829/936/ab4/829936ab4b2855cd7f824ebd01941bb3.gif" width="512" height="500"></div><br><h1>  Sprite </h1><br>  Selain menjelajahi tabel nama, NES juga memiliki aspek grafis yang sama sekali berbeda: sprite.  Tidak seperti tabel nama yang perlu disejajarkan dalam grid, sprite dapat diposisikan secara sewenang-wenang, sehingga mereka dapat digunakan untuk menampilkan karakter pemain, hambatan, proyektil, dan benda apa pun dengan gerakan yang kompleks.  Misalnya, dalam adegan di atas dari Mega Man (1987) untuk menampilkan karakter pemain.  titik dan strip energi digunakan sprite, yang memungkinkan mereka keluar dari kotak tabel nama saat menggulir layar. <br><br>  Sprite memiliki halaman CHR mereka sendiri [8] dan satu set 4 palet.  Selain itu, mereka menempati halaman 256 byte memori.  yang mencantumkan posisi dan tampilan masing-masing sprite (ternyata, memori video NES dua setengah kali lebih besar daripada yang disebutkan di bagian pertama artikel).  Format catatan-catatan ini agak tidak biasa - pertama-tama berisi posisi dalam Y, lalu nomor ubin, lalu atribut, lalu posisi dalam X [9].  Karena setiap rekaman membutuhkan 4 byte, ada batasan ketat: di layar tidak boleh lebih dari 256/4 = 64 sprite sekaligus. <br><br>  Bytes Y dan X menentukan piksel kiri atas sprite yang ditarik.  Oleh karena itu, di sisi kanan layar, sprite dapat dipotong, tetapi di sisi kiri meninggalkan ruang kosong.  Byte ubin serupa dengan nilai dalam tabel nama, hanya untuk ubin ini sprite menggunakan CHR mereka sendiri.  Atribut byte adalah paket bit yang melakukan tiga tugas: dua bit dialokasikan ke palet, dua bit digunakan untuk mencerminkan sprite secara horizontal atau vertikal, dan satu bit menentukan apakah akan membuat sprite di bawah tabel nama [10]. <br><br><h1>  Keterbatasan </h1><br>  Sistem modern memungkinkan bekerja dengan sprite dari ukuran sembarang, tetapi pada NES sprite karena keterbatasan CHR harus memiliki ukuran 8 × 8 [11].  Objek yang lebih besar terdiri dari beberapa sprite, dan program harus memastikan bahwa semua bagian-bagian individual diuraikan satu sama lain.  Misalnya, ukuran karakter Megaman dapat mencapai 10 sprite, yang juga memungkinkan Anda menggunakan lebih banyak warna, khususnya untuk mata putih dan warna kulitnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/fea/3dc/dd8fea3dc4880761b52885c8ff83acdd.png"></div><br>  Keterbatasan utama yang terkait dengan penggunaan sprite adalah bahwa tidak boleh lebih dari 8 sprite per baris raster.  Jika lebih dari 8 sprite muncul di garis horizontal layar apa pun, maka yang muncul nanti tidak akan ditampilkan.  Ini adalah alasan untuk berkedip dalam game dengan banyak sprite;  program menukar alamat sprite dalam memori sehingga masing-masing diberikan setidaknya sekali-sekali. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/b67/13c/5f0b6713c1be1837d0da2d8213253932.gif" alt="megaman-flicker" width="332" height="128"></div><br>  Akhirnya, pengguliran tidak memengaruhi sprite: posisi sprite pada layar ditentukan oleh nilai Y dan X-nya, terlepas dari posisi pengguliran.  Kadang-kadang ini merupakan nilai tambah, misalnya, ketika level bergerak relatif ke pemain atau antarmuka tetap dalam posisi tetap.  Namun, dalam kasus lain, ini adalah minus - Anda harus memindahkan objek yang bergerak, dan kemudian mengubah posisinya dengan jumlah perubahan dalam pengguliran. <br><br><h1>  Catatan </h1><br>  [6] Secara teori, sebenarnya ada empat tabel nama, tetapi mereka dicerminkan sedemikian rupa sehingga hanya 2 dari mereka yang mengandung grafik unik.  Ketika ditempatkan berdampingan, ini disebut mirroring vertikal, dan ketika tabel nama terletak satu di atas yang lain, mirroring horizontal. <br><br>  [7] Ada juga register yang memilih tabel nama mana untuk mulai render, yaitu menggulir sebenarnya bernilai 10-bit, atau 9-bit, jika Anda ingin membuat mirror. <br><br>  [8] Ini tidak selalu terjadi.  PPU dapat dikonfigurasi untuk menggunakan halaman CHR yang sama untuk tabel nama seperti untuk sprite. <br><br>  [9] Mungkin urutan ini digunakan karena sesuai dengan data yang perlu diproses oleh PPU untuk rendering yang efisien. <br><br>  [10] Bit ini digunakan untuk berbagai efek, misalnya, untuk memindahkan Mario di bawah balok putih di Super Mario Bros 3, atau untuk membuat kabut di sprite di Castlevania 3. <br><br>  [11] PPU juga memiliki opsi untuk mengaktifkan spanduk 8 × 16, yang digunakan dalam gim seperti Contra, di mana ada karakter tinggi.  Namun, semua batasan lainnya berlaku. <br><br><h2>  Bagian 3 </h2><br>  Di bagian sebelumnya, kami berbicara tentang data CHR, latar belakang berdasarkan tabel nama, sprite dan pengguliran.  Dan itu hampir semua yang dapat dilakukan oleh kartrid NES sederhana tanpa perangkat keras tambahan.  Tetapi untuk melangkah lebih jauh, kita perlu menjelaskan secara rinci bagaimana cara kerja rendering. <br><br><h1>  Rendering </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/0d4/0ad/12b0d40ad74d27ce6d8ff2499c6df163.gif" width="200" height="200"></div><br>  <i>Rendering raster dengan jeda untuk vblank</i> <br><br>  Seperti komputer lama lainnya, NES dirancang untuk bekerja dengan televisi CRT.  Mereka menggambar garis pindai di layar, satu per satu, dari kiri ke kanan, dari atas ke bawah, menggunakan senjata elektron yang secara fisik bergerak ke titik di layar tempat garis ini digambar.  Setelah mencapai sudut bawah, periode waktu yang disebut "vertikal kosong" (atau vblank) terjadi: pistol elektron kembali ke sudut kiri atas untuk mempersiapkan menggambar bingkai berikutnya.  Di dalam NES, PPU (Picture Processing Unit) melakukan raster render secara otomatis, di setiap frame, dan kode yang bekerja di CPU melakukan semua tugas yang harus dilakukan gim.  Vblank memungkinkan program untuk mengganti data dalam memori PPU, karena jika tidak data ini akan digunakan untuk rendering.  Paling sering, perubahan pada tabel nama dan palet PPU dilakukan selama jendela kecil ini. <br><br>  Namun, beberapa perubahan dalam kondisi PPU dapat dilakukan selama rendering layar.  Mereka disebut "efek raster."  Tindakan paling umum yang dilakukan selama rendering layar adalah mengatur posisi gulir.  Berkat ini, sebagian gambar tetap statis (misalnya, antarmuka game), dan yang lainnya terus bergulir.  Untuk mencapai efek ini, perlu memilih waktu yang tepat untuk mengubah nilai gulir sehingga terjadi pada garis raster yang diinginkan.  Ada banyak teknik untuk menerapkan sinkronisasi semacam ini antara kode game dan PPU. <br><br><h1>  Layar terpisah </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/4bf/c1e/36e4bfc1e8e92ae1dbfb83225946dc0f.png" width="512" height="480"></div><br>  <i>Level bergulir, dan antarmuka di bagian atas layar tetap diam</i> <br><br>  Pertama, PPU memiliki perangkat keras bawaan yang memproses sprite dalam posisi nol memori dengan cara khusus.  Saat merender sprite ini, jika salah satu pikselnya tumpang tindih dengan bagian latar belakang yang terlihat, bit ditetapkan bernama “sprite0 flag”.  Kode gim pertama-tama dapat menempatkan sprite ini di mana pemisahan layar harus terjadi, dan kemudian menunggu dalam satu lingkaran, memeriksa nilai bendera sprite0.  Oleh karena itu, ketika loop keluar, game akan tahu pasti garis raster mana yang saat ini diberikan.  Teknik ini digunakan untuk menerapkan berbagi layar sederhana di banyak game NES, termasuk Ninja Gaiden (1989), yang ditunjukkan di atas [12] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/acd/f19/66bacdf196bab83b91ea70c2657dd497.png" alt="ninja-hud" width="256" height="240"></div><br>  <i>Sprite0 terletak di Y $ 26, X $ a0.</i>  <i>Ketika baris paling bawah dari pikselnya diberikan, bendera sprite0 diatur</i> <br><br>  Dalam beberapa permainan, sprite0 flag dikombinasikan dengan teknik lain - perulangan yang dapat diprediksi waktunya (“sebuah siklus dengan waktu yang dapat diprediksi”): program menunggu hingga beberapa baris tambahan diberikan untuk membagi layar menjadi lebih banyak bagian.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, teknik ini digunakan di banyak screensaver Ninja Gaiden untuk membuat efek dramatis, misalnya, bidang yang digerakkan angin atau gambar kastil di kejauhan. Gim melakukan tugas-tugas seperti memutar musik dan menunggu pemain masuk, pada awal rendering frame, kemudian menggunakan sprite0 untuk mencari divisi pertama, dan untuk semua yang lain ia menggunakan loop waktu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/19a/bfd/cf919abfdd1c0d786440e0af2c99bb24.gif" alt="ninja di lapangan" width="512" height="480"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/fab/d51/f77fabd51c4431db2c98ee1bf64e0eb2.gif" alt="pemandangan kastil" width="512" height="480"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, sebagian besar game tidak mampu menghabiskan waktu menunggu dalam siklus, terutama dalam adegan aktif di mana waktu CPU bernilai emas. Dalam kasus seperti itu, peralatan khusus yang dipasang dalam kartrid digunakan (disebut mapper, karena menggunakan pemetaannya sendiri dalam memori (memory mapping)), yang dapat menerima pemberitahuan tentang saat render garis raster tertentu [13], yang sepenuhnya menghilangkan kebutuhan siklus menunggu. Kode permainan dapat melakukan salah satu tugasnya dan pada waktu yang diinginkan, sehingga prosesor digunakan lebih optimal. Sebagian besar game yang lebih modern untuk NES, yang memiliki banyak divisi layar, menggunakan pemetaan dengan cara ini.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/9c3/f4f/6189c3f4fa79e5c31b80b2c14df75dcb.gif" alt="train-level" width="512" height="480"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah contoh dari Ninja Gaiden 2, yang menggunakan mapper untuk melakukan beberapa partisi dan mensimulasikan pengguliran paralaks, yang menciptakan perasaan kecepatan tinggi, terlepas dari sifat statis level tersebut. </font><font style="vertical-align: inherit;">Perhatikan bahwa semua bagian yang bergerak masing-masing menempati garis horizontal yang ketat; </font><font style="vertical-align: inherit;">artinya, tidak ada lapisan latar belakang yang bisa saling tumpang tindih. </font><font style="vertical-align: inherit;">Ini karena pemisahan sebenarnya dilaksanakan dengan mengubah pengguliran garis raster individual.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengalihan bank </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemetaan dapat melakukan banyak fungsi lainnya, tetapi yang paling umum adalah beralih bank. Ini adalah operasi di mana seluruh blok ruang alamat ditugaskan untuk menunjuk ke bagian lain dari memori [14]. Switching bank dapat dilakukan dengan kode program (yang memungkinkan Anda membuat banyak level dan musik di game), serta dengan data CHR, sehingga Anda dapat langsung mengganti ubin yang dirujuk dalam tabel nama atau sprite. Jika Anda menggunakan peralihan bank antar bingkai, Anda dapat menghidupkan seluruh latar belakang sekaligus. Tetapi ketika digunakan sebagai efek raster, ini memungkinkan Anda untuk menggambar grafik yang sangat berbeda di berbagai bagian layar. Dalam game seri Ninja Gaiden, pendekatan ini digunakan selama proses game untuk membuat antarmuka secara terpisah dari level, serta selama screensaver,yang memungkinkan Anda untuk menyimpan teks dan adegan visual di berbagai bank CHR.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69f/896/804/69f8968042bded347183e35af32c16ae.gif" alt="goofall-bg" width="512" height="480"></div><br> <i> ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/882/f90/290882f90bb731af9e98f7ee65b4e64f.png" alt="goofall-nt" width="512" height="480"></div><br> <i>  ,        </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/077/b23/cf7077b23ea5242b4f27d308b7514077.png" width="512" height="480"></div><br> <i>      CHR.     ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/335/28e/7a233528e53b01341d21112b3651310e.png" alt="who-are-they-bottom-bank" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian bawah, bank CHR lain digunakan. Saat berpindah bank, nilai pengguliran juga diatur ulang.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peralihan bank juga dapat digunakan untuk pengguliran paralaks, dalam bentuk terbatas (namun tetap mengesankan). Jika adegan memiliki bagian latar belakang yang terdiri dari pola pengulangan pendek, maka pola yang sama ini dapat dimuat di beberapa bank dengan offset dengan jumlah yang berbeda. Kemudian pola ini dapat digulir ke nilai tertentu dengan beralih ke bank dengan offset yang sesuai. Teknik semacam itu dapat digunakan untuk pengguliran paralaks bahkan dengan latar belakang yang tumpang tindih karena adanya ubin yang tidak terpengaruh oleh pergantian memori [15]. Kerugian dari metode ini adalah bahwa secara total, semua bank perlu mengambil banyak ruang CHR.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/6b4/281/5016b4281a88523177dffef3f8de4250.gif" alt="metal-storm-bg" width="512" height="464"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal Storm (1991) menggunakan switching bank untuk pengguliran lapis demi lapis</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c05/7d4/6cb/c057d46cbf7f4d2cfb3e401d1658692f.png" alt="metal-storm-nt" width="512" height="464"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengulang tabel nama memungkinkan Anda untuk membuat efek</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CHR </font><i><font style="vertical-align: inherit;">ini</font></i><font style="vertical-align: inherit;"> dengan berpindah bank - ini adalah alat yang sangat kuat, tetapi memiliki keterbatasan. </font><font style="vertical-align: inherit;">Meskipun berguna untuk menjiwai seluruh layar, teknik ini tidak terlalu cocok untuk mengganti hanya sebagian kecil layar; </font><font style="vertical-align: inherit;">ini juga membutuhkan perubahan tabel nama. </font><font style="vertical-align: inherit;">Selain itu, jumlah CHR dalam kartrid terbatas, dan untuk beralih ke data, mereka harus terlebih dahulu ada. </font><font style="vertical-align: inherit;">Akhirnya, dengan pengecualian efek raster berbasis gulir, gim selalu memiliki kisi-kisi tabel nama yang ketat, yang membatasi rentang dinamis efek grafis.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contoh lainnya </font></font></h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="vice-fire" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permainan Wakil: Project Doom (1991) menciptakan efek api ini dengan berulang kali mengatur posisi gulir di setiap baris raster. </font><font style="vertical-align: inherit;">Karakter di latar depan dibuat dari sprite yang tidak terpengaruh oleh pengguliran.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/25b/9b9/25325b9b935359508dc420aa35ef1748.gif" alt="sword-master" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sword Master (1990) menggunakan peralihan bank untuk menggulir gunung di kejauhan, serta membagi layar untuk antarmuka dan rumput di latar depan.</font></font></i> <br><br><h1>  Ucapan Terima Kasih </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak akan dapat menghasilkan semua gambar ini untuk artikel tanpa fungsi debug yang kuat yang disediakan oleh emulator FCEUX. </font><font style="vertical-align: inherit;">Selain itu, situs wiki NesDev telah menjadi sumber informasi yang berguna tentang sprite0:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fceux</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki NesDev</font></font></a> </li></ul><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Catatan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12] Faktanya, situasi dengan Ninja Gaiden sedikit lebih rumit. Gim ini menggunakan spanduk 8 × 16 sprite - mode khusus yang disediakan oleh PPU yang menjadikan sprite sebagai pasangan yang dilapis secara vertikal. Yaitu, sprite0 sepenuhnya transparan, dan sprite1 memiliki deretan piksel di bagian paling bawah. Dia juga mengatur z-layer sprite-sprite ini sehingga mereka ditampilkan di balik kegelapan antarmuka, yang membuat semuanya tidak terlihat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] Ini cukup sulit untuk diterapkan. Kode permainan menulis garis raster yang diinginkan ke ruang alamat mapper. Mapper kemudian memotong permintaan akses memori PPU, menghitung ketika baris raster baru diberikan. Setelah mencapai garis raster yang diinginkan, ia menghasilkan program interrupt (IRQ), di mana kode permainan dijalankan, melakukan apa yang diperlukan selama garis raster khusus ini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14] Switching dilakukan dengan memetakan peralatan ke memori, mencegat operasi akses memori, dan mendefinisikan ulang lokasi fisik dari mana data diperoleh. </font><font style="vertical-align: inherit;">Hasilnya seketika, tetapi memiliki fraksionalitas yang besar, karena itu interval alamat bervariasi 4 KB atau 8 KB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15] Satu-satunya cara untuk mengganti bank CHR tanpa mempengaruhi setiap ubin adalah dengan menduplikasi data ubin antara bank, atau memiliki mapper dengan lebih sedikit biji-bijian. </font><font style="vertical-align: inherit;">Dengan mapper ini, Anda dapat mengganti bagian yang lebih kecil dari bank, misalnya, hanya 1 KB pada suatu waktu, dan yang lainnya akan tetap tidak berubah.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470614/">https://habr.com/ru/post/id470614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470602/index.html">Seperti apa metro Moskow di dunia tiga dimensi</a></li>
<li><a href="../id470604/index.html">Kecepatan pemuatan situs dalam e-commerce: analisis 48 toko online top di Rusia</a></li>
<li><a href="../id470608/index.html">Optimasi UI Unity</a></li>
<li><a href="../id470610/index.html">Suatu hari dalam kehidupan seorang pengembang</a></li>
<li><a href="../id470612/index.html">Apa yang ditunjukkan voltmeter, atau soket matematika</a></li>
<li><a href="../id470616/index.html">Solusi baru untuk paradoks Fermi (mengapa kita sendirian di alam semesta)</a></li>
<li><a href="../id470618/index.html">Pemodelan tematik berita menggunakan analisis faktor</a></li>
<li><a href="../id470620/index.html">Infrastruktur sebagai Kode: Cara Mengatasi Masalah dengan XP</a></li>
<li><a href="../id470622/index.html">Tinjauan Umum Metode Pemilihan Fitur</a></li>
<li><a href="../id470628/index.html">Pembuatan kapal simulator ruang angkasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>