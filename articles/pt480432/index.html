<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîñ üèáüèª üöå O problema do primeiro visualizador ou a dif√≠cil convers√£o de fluxos de v√≠deo WebRTC em HLS ‚öíÔ∏è üßö üñåÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Egor fechou a tampa do laptop e esfregou os olhos vermelhos por falta de sono. "Os clientes continuam reclamando sobre o congelamento do fluxo, o novo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O problema do primeiro visualizador ou a dif√≠cil convers√£o de fluxos de v√≠deo WebRTC em HLS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/480432/"><p><img src="https://habrastorage.org/webt/af/bt/ar/afbtarp3iizqyc4vnhqj2dxxmte.jpeg"></p><br><p>  Egor fechou a tampa do laptop e esfregou os olhos vermelhos por falta de sono.  "Os clientes continuam reclamando sobre o congelamento do fluxo, o novo fix pack n√£o ajudou em nada! Ent√£o, o que fazer com esse HLS (censurado)?"  Ele disse no vazio do estudo. </p><a name="habracut"></a><br><h2 id="brauzer-eto-ne-tolko-gipertekst-no-i-strimer">  O navegador n√£o √© apenas um hipertexto, mas tamb√©m uma serpentina </h2><br><p>  Os navegadores adquirem players h√° muito tempo, mas com um codificador de v√≠deo e a transmiss√£o da hist√≥ria √© diferente.  Agora, em quase qualquer navegador da vers√£o mais recente, voc√™ pode encontrar m√≥dulos para codifica√ß√£o, streaming, decodifica√ß√£o e reprodu√ß√£o.  Essas fun√ß√µes est√£o dispon√≠veis atrav√©s da API JavaScript e a implementa√ß√£o √© chamada Web Real Time Communications ou WebRTC.  Essa biblioteca incorporada nos navegadores pode fazer bastante: capturar v√≠deo de uma c√¢mera embutida, virtual ou USB, compactar com os codecs H.264, VP8, VP9, ‚Äã‚Äãenvi√°-lo √† rede via protocolo SRTP, ou seja,  funciona como um codificador de streamer de v√≠deo de software.  Como resultado, vemos um navegador que possui algo semelhante ao ffmpeg ou gstreamer, que comprime bem o v√≠deo, transmite em RTP e reproduz fluxos de v√≠deo. </p><br><p>  O WebRTC oferece a liberdade de implementar uma variedade de casos de streaming em JavaScript: </p><br><ul><li>  transmitir o fluxo do navegador para o servidor para grava√ß√£o e distribui√ß√£o subsequente </li><li>  ponto a ponto </li><li>  reproduza o stream de outro usu√°rio e envie o seu pr√≥prio (chat por v√≠deo) </li><li>  converter outros protocolos pelo servidor, por exemplo, RTMP, RTSP, etc., e reproduzir no navegador como WebRTC </li></ul><br><p>  Os scripts de controle de fluxo refinados podem ter esta apar√™ncia: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      session.createStream({name:‚Äùmystream‚Äù}).publish(); //   session.createStream({name:‚Äùmystream‚Äù}).play();</span></span></code> </pre> <br><h2 id="hls-rabotaet-tam-gde-ne-rabotaet-webrtc">  O HLS funciona onde o WebRTC n√£o funciona </h2><br><p>  O WebRTC funciona nas vers√µes mais recentes dos navegadores, no entanto, existem dois dos seguintes fatores: 1) Nem todos os usu√°rios atualizam os navegadores em tempo h√°bil e podem ficar em algum tipo de Chrome por tr√™s anos.  2) Quase uma vez por semana s√£o lan√ßadas atualiza√ß√µes e novos navegadores, o WebView, al√©m de outros clientes e mensageiros instant√¢neos que podem navegar na Internet.  Desnecess√°rio dizer que nem todos eles t√™m suporte para WebRTC e, se houver, podem ser completamente truncados.  Veja como est√£o as coisas agora: </p><br><p><img src="https://habrastorage.org/webt/r8/wf/y8/r8wfy8p3nvyulliesmqnwhurhcw.png"></p><br><p>  Dor de cabe√ßa separada - os dispositivos Apple favoritos de todos.  Recentemente, eles receberam suporte para o WebRTC e, √†s vezes, s√£o surpreendentes em seu comportamento em compara√ß√£o com os navegadores ortodoxos.  E onde o WebRTC n√£o funciona ou n√£o funciona muito bem, o HLS funciona bem.  Nesse sentido, √© necess√°ria compatibilidade, e algo como um conversor que converte WebRTC em HLS e o reproduz em quase qualquer dispositivo. </p><br><p>  Inicialmente, o HLS n√£o foi concebido para fluxos em tempo real.  De fato, qual pode ser o tempo do v√≠deo em HTTP?  A tarefa do HLS √© cortar o v√≠deo em peda√ßos e entreg√°-lo ao player sem problemas, sem pressa, baixando um por um.  O HLS player espera um fluxo de v√≠deo estritamente formado e suave.  E aqui surge um conflito, j√° que o WebRTC, ao contr√°rio, pode se permitir perder pacotes devido a requisitos em tempo real e baixa lat√™ncia e ter um FPS / GOP flutuante e uma taxa de bits vari√°vel - para ser exatamente o oposto do HLS em termos de previsibilidade e dimensionalidade do fluxo. </p><br><p>  Uma abordagem √≥bvia - a despacketization do WebRTC (SRTP) e a subsequente <a href="https://flashphoner.com/vosproizvedenie-webrtc-i-rtmp-videopotokov-po-hls/%3Flang%3Dru">convers√£o</a> para HLS, podem n√£o funcionar no player Apple HLS nativo ou de forma inadequada para produ√ß√£o com frisos.  Um player nativo aqui significa um player usado no Apple iOS Safari, Mac OS Safari e Apple TV. </p><br><p>  Portanto, se voc√™ notar o friso HLS no player nativo, talvez seja isso, e a origem do fluxo √© o WebRTC ou outro fluxo din√¢mico com marca√ß√£o irregular.  Al√©m disso, na implementa√ß√£o de players nativos da Apple, existe um comportamento que s√≥ pode ser entendido empiricamente.  Por exemplo, o servidor deve come√ßar a enviar segmentos HLS imediatamente, imediatamente ap√≥s o retorno da lista de reprodu√ß√£o m3u8.  Atraso por segundo amea√ßa com um congelamento.  Se a configura√ß√£o do fluxo de bits tiver sido alterada no processo (que √© uma ocorr√™ncia bastante comum no streaming do WebRTC), tamb√©m haver√° um friso. </p><br><h2 id="borba-s-frizami-v-nativnyh-pleerah">  Lute contra frisos em jogadores nativos </h2><br><p>  Portanto, a despacketiza√ß√£o e a embalagem direta e honesta do WebRTC no HLS geralmente n√£o funcionam.  No <a href="https://flashphoner.com/">servidor de</a> streaming de v√≠deo do <a href="https://flashphoner.com/">Web Call Server (WCS)</a> , resolvemos o problema de duas maneiras e oferecemos o terceiro como alternativa: </p><br><p>  1) Transcodifica√ß√£o. </p><br><p>  Essa √© a maneira mais confi√°vel de alinhar o fluxo do WebRTC com os requisitos de HLS, definir o GOP, o FPS desejado, etc.  No entanto, em alguns casos, a transcodifica√ß√£o n√£o √© uma boa solu√ß√£o, por exemplo, a transcodifica√ß√£o de fluxos de 4K de v√≠deo em VR √© uma id√©ia mais ou menos.  Esses fluxos pesados ‚Äã‚Äãs√£o muito caros para transcodificar em termos de tempo da CPU ou recursos da GPU. </p><br><p><img src="https://habrastorage.org/webt/lk/sb/ap/lksbapmjw9cmefbwccx6l7vx3xs.png"></p><br><p>  2) Adapta√ß√£o e alinhamento do fluxo do WebRTC em tempo real, de acordo com os requisitos do HLS. </p><br><p>  Esses s√£o analisadores especiais que analisam o fluxo de bits H.264 e o corrigem para os recursos / bugs dos players Apple HLS nativos.  Aqui, devemos admitir que players n√£o nativos, como video.js e hls.js, s√£o mais tolerantes a fluxos com taxa de bits din√¢mica e FPS, que √© o WebRTC e n√£o diminui a velocidade onde a implementa√ß√£o de refer√™ncia do Apple HLS cai essencialmente em congelamento permanente. </p><br><p><img src="https://habrastorage.org/webt/hh/c0/0j/hhc00j_fa7tj6frr5tme-rkqojg.png"></p><br><p>  3) Use RTMP como uma fonte de fluxo em vez de WebRTC. </p><br><p>  Apesar do flash ser retirado, o protocolo RTMP √© usado ativamente para streaming, fa√ßa o mesmo OBS Studio.  E devo admitir que os codificadores RTMP geralmente produzem fluxos mais uniformes que o WebRTC e, portanto, praticamente n√£o produzem frisos no HLS, ou seja,  Converter RTMP&gt; HLS do ponto de vista de frisos parece muito mais adequado, inclusive em players nativos de HLS.  Portanto, se o streaming for realizado a partir da √°rea de trabalho e do OBS, √© melhor us√°-lo para a convers√£o em HLS.  Se a fonte for um navegador Chrome, o RTMP n√£o poder√° ser usado sem a instala√ß√£o de plug-ins, e aqui apenas o WebRTC. </p><br><p><img src="https://habrastorage.org/webt/tm/ne/i2/tmnei2sj-cuw2fpw0wajlyxuz7m.png"></p><br><p>  Todos os tr√™s m√©todos descritos acima s√£o testados e funcionam, portanto, h√° uma oportunidade de escolha com base nas condi√ß√µes da tarefa. </p><br><h2 id="webrtc-v-hls-na-cdn">  WebRTC para HLS na CDN </h2><br><p>  Alguns problemas podem aguardar em um sistema distribu√≠do quando v√°rios servidores de entrega de fluxo WebRTC est√£o localizados entre a fonte de fluxo WebRTC e o player HLS, ou seja, <a href="https://flashphoner.com/cdn-dlya-striminga-webrtc-s-nizkoj-zaderzhkoj/%3Flang%3Dru">CDN</a> , no nosso caso, com base no servidor WCS.  √â assim: existe o Origin - um servidor que recebe um fluxo WebRTC, h√° Edge - servidores que distribuem esse fluxo, incluindo o HLS.  Pode haver muitos servidores, o que permite o dimensionamento horizontal do sistema.  Por exemplo, 1000 servidores HLS podem ser conectados a um servidor Origin, nesse caso, a capacidade do sistema √© dimensionada 1000 vezes. </p><br><p><img src="https://habrastorage.org/webt/nq/hq/fq/nqhqfqm9_lzyrpxtofqk89jzw6u.png"></p><br><p>  O problema j√° foi identificado um pouco mais alto, e esse problema geralmente surge em players nativos: iOS Safari, Mac OS Safari, Apple TV.  Por nativo, queremos dizer um player que trabalha com uma indica√ß√£o direta do URL da lista de reprodu√ß√£o na tag, por exemplo, <code>&lt;video src="https://host/test.m3u8"/&gt;</code> .  Assim que o player solicita uma lista de reprodu√ß√£o, e essa a√ß√£o √© realmente o primeiro passo na reprodu√ß√£o do fluxo HLS, o servidor deve imediatamente, sem demora, come√ßar a enviar segmentos de v√≠deo HLS.  Se o servidor n√£o come√ßar a dar segmentos imediatamente, o jogador decide que ele foi enganado e para de jogar.  Novamente, esse comportamento √© t√≠pico dos players HLS nativos da Apple, mas n√£o podemos dizer aos usu√°rios: "por favor, n√£o use o iPhone Mac e o Apple TV para reproduzir fluxos HLS", os usu√°rios n√£o entender√£o. </p><br><p>  Portanto, quando voc√™ tenta reproduzir o fluxo HLS no servidor de Borda, o servidor deve come√ßar imediatamente a retornar segmentos, mas como o far√° se n√£o tiver um fluxo?  De fato, ao tentar reproduzir um fluxo neste servidor est√° ausente.  A l√≥gica da CDN funciona com o princ√≠pio Lazy Loading - n√£o direcionaremos o fluxo para o servidor at√© que algu√©m solicite esse fluxo neste servidor.  H√° um problema com a primeira conex√£o - o primeiro que solicitou o fluxo HLS do servidor Edge e teve a imprud√™ncia de fazer isso com o player nativo da Apple receber√° um friso pelo motivo que leva algum tempo para solicitar esse fluxo no servidor Origin, para obt√™-lo no Edge e continue com o fatiamento HLS.  Mesmo que demore tr√™s segundos, o jogador n√£o o salvar√°.  Ele entrar√° no friso. </p><br><p><img src="https://habrastorage.org/webt/g9/he/wh/g9hewhbfu04ypt81daubg0qouvy.png"></p><br><p>  Aqui, novamente, duas decis√µes se aproximam: uma √© normal, a outra n√£o √© muito.  Pode-se abandonar a abordagem Lazy Loading na CDN e enviar tr√°fego para todos os n√≥s, independentemente de haver ou n√£o espectadores.  Uma solu√ß√£o, possivelmente adequada para quem n√£o est√° limitado em recursos de tr√°fego e computa√ß√£o.  O Origin direcionar√° o tr√°fego para todos os servidores de Borda; como resultado, todos os servidores e a rede entre eles ser√£o carregados constantemente.  Talvez esse esquema seja adequado apenas para algumas solu√ß√µes espec√≠ficas com um pequeno n√∫mero de fluxos de entrada.  Ao replicar um grande n√∫mero de threads, esse esquema ser√° claramente ineficiente em termos de recursos.  E se voc√™ se lembra de que estamos apenas resolvendo o ‚Äúproblema da primeira conex√£o do navegador nativo‚Äù, fica claro que n√£o vale a pena. </p><br><p><img src="https://habrastorage.org/webt/dx/n4/yf/dxn4yf28u8gtrczrshxc-smjjuq.png"></p><br><p>  A segunda op√ß√£o √© mais elegante, mas tamb√©m alternativa.  Damos ao primeiro usu√°rio conectado uma imagem de v√≠deo, mas ainda n√£o √© o fluxo que ele deseja ver - este √© um pr√©-carregador.  Como devemos fornecer algo agora e faz√™-lo imediatamente, mas n√£o temos o fluxo de origem (ele ainda √© solicitado e entregue pela Origin), decidimos pedir ao cliente que espere um pouco e mostre a ele um v√≠deo do pr√©-carregador com anima√ß√£o em movimento.  O usu√°rio espera alguns segundos, o pr√©-carregador gira e, quando o fluxo real chega, o usu√°rio come√ßa a mostrar o fluxo real.  Como resultado, o primeiro usu√°rio viu o pr√©-carregador e os subsequentes que se conectaram finalmente viram o fluxo HLS normal vindo da CDN, trabalhando no princ√≠pio do Lazy Loading.  Problema de engenharia resolvido. </p><br><h2 id="no-ne-do-konca">  Mas n√£o at√© o fim </h2><br><p>  Parece que tudo funciona muito bem.  A CDN est√° funcionando, os fluxos HLS s√£o obtidos dos servidores de borda e o problema da primeira conex√£o √© resolvido.  E aqui est√° outra armadilha: fornecemos o pr√©-carregador em uma propor√ß√£o fixa de 16: 9, e a CDN pode incluir fluxos de qualquer formato: 16: 9, 4: 3, 2: 1 (v√≠deo em VR).  E isso √© um problema, porque se voc√™ der ao pr√©-carregador um player no formato 16: 9 e o fluxo ordenado estiver no formato 4: 3, o player nativo aguardar√° novamente o friso. </p><br><p>  Portanto, surge uma nova tarefa - voc√™ precisa saber com qual propor√ß√£o o fluxo entra na CDN e fornecer o pr√©-carregador na mesma propor√ß√£o.  Um recurso dos fluxos WebRTC √© a preserva√ß√£o da propor√ß√£o ao alterar a resolu√ß√£o e durante a transcodifica√ß√£o - se o navegador decide diminuir a resolu√ß√£o, ele a reduz na mesma propor√ß√£o.  Se o servidor decidir transcodificar o fluxo, ele manter√° a propor√ß√£o na mesma propor√ß√£o.  Portanto, √© l√≥gico que, se queremos mostrar o pr√©-carregador para HLS, mostramos na mesma propor√ß√£o em que o fluxo entra. </p><br><p><img src="https://habrastorage.org/webt/kn/ee/dr/kneedrbpqw4mfyrvrnpxufev0ui.png"></p><br><p>  A CDN funciona da seguinte maneira: quando o tr√°fego entra no servidor Origin, ele informa os outros servidores da rede, incluindo os servidores de Borda, sobre o novo fluxo.  O problema √© que, neste ponto, a resolu√ß√£o do fluxo de origem ainda n√£o pode ser conhecida.  A resolu√ß√£o √© realizada pelas configura√ß√µes de fluxo de bits H.264 junto com o quadro-chave.  Portanto, pode ser que o servidor de Borda receba informa√ß√µes de que h√° um fluxo, mas n√£o saber√° sobre sua resolu√ß√£o e propor√ß√£o, o que n√£o permitir√° gerar corretamente o pr√©-carregador.  Nesse sentido, √© necess√°rio sinalizar a presen√ßa de um fluxo na CDN apenas se houver um quadro-chave - isso garante informa√ß√µes ao tamanho do servidor Edge e permite que o pr√©-carregador correto seja gerado para evitar ‚Äúo problema do primeiro visualizador conectado‚Äù. </p><br><p><img src="https://habrastorage.org/webt/vh/uy/aw/vhuyawuhtqsmyc8zg806egppu6i.png"></p><br><h2 id="itogi">  Sum√°rio </h2><br><p>  A convers√£o do WebRTC para HLS geralmente fornece frisos quando reproduzidos em players nativos da Apple.  O problema √© resolvido analisando e ajustando o fluxo de bits H.264 aos requisitos de HLS da Apple, transcodificando ou usando a migra√ß√£o para o protocolo RTMP e o codificador como fonte de fluxo.  Em uma rede distribu√≠da com carregamento lento de fluxos, h√° um problema do primeiro visualizador conectado, que √© resolvido usando o pr√©-carregador e determinando a resolu√ß√£o no lado do servidor Origin - o ponto de entrada do fluxo na CDN. </p><br><h2 id="ssylki">  Refer√™ncias </h2><br><p>  <a href="https://flashphoner.com/">Servidor de Chamada pela Web</a> - Servidor WebRTC </p><br><p>  CDN de <a href="https://flashphoner.com/cdn-dlya-striminga-webrtc-s-nizkoj-zaderzhkoj/%3Flang%3Dru">fluxo cont√≠nuo WebRTC de baixa lat√™ncia</a> - CDN baseado em WCS </p><br><p>  <a href="https://flashphoner.com/vosproizvedenie-webrtc-i-rtmp-videopotokov-po-hls/%3Flang%3Dru">Reproduzir fluxos de v√≠deo WebRTC e RTMP sobre HLS</a> - Fun√ß√µes de servidor para converter fluxos de v√°rias fontes em HLS </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480432/">https://habr.com/ru/post/pt480432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480420/index.html">Entrevista com Matthew "Oki" O'Connor sobre aterosclerose e seu tratamento</a></li>
<li><a href="../pt480422/index.html">Guia de estilo do Google em C ++. Parte 1</a></li>
<li><a href="../pt480424/index.html">Guia de estilo do Google em C ++. Parte 9</a></li>
<li><a href="../pt480428/index.html">O m√©todo da taquigrafia mais simples. Alfabeto e fonte para ela.</a></li>
<li><a href="../pt480430/index.html">Como o codec de v√≠deo funciona. Parte 2. O que, por que, como</a></li>
<li><a href="../pt480438/index.html">Eventos digitais em Moscou, de 16 a 22 de dezembro</a></li>
<li><a href="../pt480444/index.html">Detetive Habra: 24 horas a partir da vida de 24 publica√ß√µes</a></li>
<li><a href="../pt480446/index.html">Gravando o proxy reverso Grafana em Go</a></li>
<li><a href="../pt480452/index.html">OWASP Moscow Meetup # 9: Registros de desempenho</a></li>
<li><a href="../pt480458/index.html">Assista "Cell of time"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>