<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ 🔑 🚘 Secara singkat tentang jenis arsitektur perangkat lunak, dan mana yang kami pilih untuk penyedia IaaS 🤾🏽 🧘🏻 🕶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak jenis arsitektur perangkat lunak dengan pro dan kontra mereka. Selanjutnya, kita akan berbicara tentang fitur-fitur yang paling populer di ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Secara singkat tentang jenis arsitektur perangkat lunak, dan mana yang kami pilih untuk penyedia IaaS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1cloud/blog/424911/">  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak jenis arsitektur perangkat lunak</a> dengan pro dan kontra mereka.  Selanjutnya, kita akan berbicara tentang fitur-fitur yang paling populer di antara mereka dan berbicara tentang transisi kita ke layanan-layanan mikro. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/xy/c4/0n/xyc40n4lngvgriexbx9vviubxki.jpeg"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i>/ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libreshot</a> / PD</i></font> <br><br><h2>  Jenis Arsitektur Perangkat Lunak </h2><br><h5>  Arsitektur berlapis </h5><br>  Ini adalah salah satu arsitektur yang paling umum.  Atas dasar itu, banyak kerangka kerja besar dibangun - Java EE, Drupal, Express.  Mungkin contoh paling terkenal dari arsitektur ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model</a> jaringan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OSI</a> . <br><br>  Sistem ini dibagi menjadi beberapa level, yang masing-masing berinteraksi dengan hanya dua yang bertetangga.  Oleh karena itu, permintaan ke database, yang biasanya terletak di bagian paling akhir dari rantai interaksi, melewati secara berurutan melalui setiap "lapisan". <br><br>  Arsitektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak menyiratkan</a> jumlah level wajib - mungkin ada tiga, empat, lima atau lebih.  Paling sering, sistem tiga-tier digunakan: dengan tingkat presentasi (klien), tingkat logika, dan tingkat data. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nn/qa/b8/nnqab847wdvsg0sbvwph-yumd3e.png" width="300"></div><br>  Banyak buku dan artikel telah ditulis tentang arsitektur bertingkat.  Dan ada perbedaan pendapat tentang kelebihan dan kekurangannya. <br><br>  <i>Pro:</i> <br><br>  Setiap tingkat arsitektur ini melakukan serangkaian fungsi yang sangat terbatas (yang tidak diulang dari lapisan ke lapisan) dan tidak tahu bagaimana tingkat lainnya diatur.  Oleh karena itu, "isi" level dapat diubah tanpa risiko konflik global antar lapisan. <br><br>  Secara umum, aplikasi bertingkat begitu luas sehingga generator template khusus dibuat untuk pengembangannya.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LASG untuk Visual Studio</a> menawarkan beberapa metode pembuatan kode yang mengotomatiskan tugas-tugas rutin dan membantu membangun tingkatan aplikasi. <br><br>  <i>Kekurangan:</i> <br><br>  Dalam pemrograman, ada pepatah yang mengatakan bahwa masalah apa pun dapat diselesaikan dengan menambahkan tingkat abstraksi lain.  Namun, pendekatan ini pada akhirnya dapat menyebabkan organisasi yang buruk dari kode dan membingungkan pengembang. <br><br>  Masalah lain muncul dari ini - kecepatan rendah.  Banyak informasi mulai berlalu sia-sia dari lapisan ke lapisan, tanpa menggunakan logika bisnis.  Masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> kadang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-</a> kadang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disebut</a> anti-pola sinkhole, pola desain ketika jumlah operasi yang tidak berguna mulai menang atas yang berguna. <br><br>  Menemukan bug pada sistem multi-tier juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bisa sulit</a> .  Sebelum memasukkan basis data, informasi melewati semua tingkatan (karena basis data adalah komponen terakhir).  Jika karena alasan tertentu informasi ini rusak (atau hilang di sepanjang jalan), maka untuk menemukan kesalahan, Anda harus menganalisis setiap level secara terpisah. <br><br>  <i>Cocok:</i> <br><br><ul><li>  Untuk membuat aplikasi baru yang perlu digunakan dengan cepat.  Ini adalah semacam "template tujuan umum." <br><br><blockquote>  Ketika kami mulai bekerja pada sistem internal penyedia infrastruktur virtual kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1cloud</a> , kami menggunakan jenis arsitektur khusus ini.  Pada awalnya, kami tidak memiliki tugas untuk menciptakan layanan IaaS yang mampu memproses lalu lintas puluhan atau ratusan ribu pengguna.  Kami memutuskan untuk segera meluncurkan produk di pasar dan mulai mengembangkan basis pelanggan, dan menyelesaikan masalah penskalaan saat tersedia (dan sekarang kami mentransfer semua sistem ke arsitektur layanan mikro, yang akan dibahas nanti). </blockquote><br>  Di antara para pengembang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada pendapat</a> bahwa tidak perlu sejak hari-hari pertama proyek untuk mempersiapkannya untuk muatan kolosal (tulis perangkat lunak bukti masa depan).  Persyaratan aktual untuk aplikasi atau layanan mungkin berbeda dari harapan, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tujuan bisnis dapat berubah</a> .  Oleh karena itu, kode yang ditulis dengan memperhatikan risiko masa depan yang jauh menjadi hutang teknis. </li><li>  Menurut O'Reilly, arsitektur berlapis adalah pilihan alami untuk banyak aplikasi perusahaan.  Karena perusahaan (terutama yang besar) sering berbagi kompetensi: ada tim yang bertanggung jawab untuk front-end, ada orang yang bertanggung jawab untuk back-end, dan sebagainya.  Ini menyiratkan pembagian alami aplikasi ke tingkat: beberapa pengembang bekerja pada klien, yang lain pada logika. <br><br>  Hubungan serupa antara struktur organisasi dan pendekatan pengembangan aplikasi juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditentukan oleh hukum Conway</a> , yang dirumuskan kembali pada tahun 1967.  Bunyinya: "Ketika mengembangkan suatu sistem, organisasi dipaksa untuk mematuhi skema yang mengulangi struktur komunikasi dalam perusahaan." </li></ul><br><h5>  Arsitektur Berorientasi Kejadian </h5><br>  Dalam hal ini, pengembang menentukan perilaku (reaksi) untuk program ketika terjadi peristiwa.  Suatu peristiwa dalam sistem dianggap sebagai perubahan yang signifikan di negaranya. <br><br>  Anda dapat menggambar analogi dengan membeli mobil di kabin.  Ketika sebuah mobil menemukan pemilik baru, kondisinya berubah dari "dijual" menjadi "dijual".  Acara ini meluncurkan proses persiapan pra-penjualan - pemasangan peralatan tambahan, memeriksa kondisi teknis, mencuci, dll. <br><br>  Sistem yang digerakkan oleh peristiwa biasanya mengandung dua komponen: sumber acara (agen) dan konsumennya (tenggelam).  Biasanya ada dua jenis acara juga: acara awal dan acara yang ditanggapi konsumen. <br><br>  Contoh implementasi arsitektur seperti itu adalah perpustakaan Java Swing.  Jika kelas membutuhkan peringatan tentang suatu peristiwa, pengembang mengimplementasikan apa yang disebut pendengar - ActionListener (dia "menangkap" peristiwa terkait), dan menambahkannya ke objek yang dapat dihasilkan oleh peristiwa ini. <br><br>  Kode implementasi berikut untuk mekanisme ini disediakan di Wiki: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooPanel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); JButton btn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JButton(<span class="hljs-string"><span class="hljs-string">"Click Me!"</span></span>); btn.addActionListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(btn); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionPerformed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ActionEvent ae)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Button has been clicked!"</span></span>); } }</code> </pre> <br>  <i>Keuntungan arsitektur:</i> <br><br>  Karena aplikasi terdiri dari sejumlah besar modul asinkron (yang tidak memiliki informasi tentang implementasi satu sama lain), mereka mudah untuk diukur.  Sistem seperti itu dirakit sebagai konstruktor - Anda tidak perlu mendaftarkan dependensi, cukup terapkan modul baru.  Selain itu, model asinkron memungkinkan kinerja aplikasi yang tinggi. <br><br>  <i>Kekurangan:</i> <br><br>  Sifat asinkron dari aplikasi semacam itu mempersulit proses debug.  Satu peristiwa dapat memicu beberapa rantai tindakan sekaligus.  Jika ada banyak rantai seperti itu, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bisa sulit untuk</a> memahami apa yang sebenarnya menyebabkan kegagalan.  Untuk mengatasi masalah, kita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">harus</a> mengatasi kondisi sulit untuk penanganan kesalahan.  Dari sini masalah dengan mengikuti logging - log <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sulit untuk</a> struktur. <br><br>  <i>Cocok untuk:</i> <br><br><ul><li>  Pembuatan sistem asinkron.  Ini jelas karena arsitektur itu sendiri terdiri dari sejumlah besar modul asinkron. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dapat digunakan</a> untuk membuat UI.  Halaman web bertindak sebagai wadah di mana masing-masing komponennya diisolasi dan merespons tindakan pengguna tertentu. </li><li>  Untuk mengatur pengiriman pesan antara berbagai sistem informasi. </li></ul><br><h5>  Arsitektur mikrokernel </h5><br>  Jenis arsitektur ini terdiri dari dua komponen: inti dari sistem dan plugin.  Plugin bertanggung jawab atas logika bisnis, dan kernel mengelola pemuatan dan pembongkarannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5t/fm/sy/5tfmsyjhqdngpuld3y-8feeurxs.png" width="400"></div><br>  Sebagai contoh arsitektur microkernel, buku O'Reilly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyediakan</a> Eclipse IDE.  Ini adalah editor sederhana yang membuka file, memungkinkan mereka untuk diedit dan menjalankan proses latar belakang.  Tetapi dengan penambahan plugin (misalnya, Java compiler), fungsinya meluas. <br><br>  Arsitektur microkernel pada suatu waktu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan</a> sistem operasi Symbian untuk perangkat seluler (pengembangan dihentikan pada 2012).  Dalam microkernel-nya adalah penjadwal tugas, sistem dan driver manajemen memori, dan sistem file serta komponen yang bertanggung jawab untuk komunikasi telepon bertindak sebagai plug-in. <br><br>  <i>Keuntungan arsitektur:</i> <br><br>  Mudah untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mem-port</a> aplikasi dari satu lingkungan ke lingkungan yang lain, karena hanya microkernel yang perlu dimodifikasi.  Pemisahan kebijakan tingkat tinggi dan mekanisme tingkat rendah menyederhanakan dukungan sistem dan memastikan ekstensibilitasnya. <br><br>  <i>Kekurangan:</i> <br><br>  Kinerja aplikasi berkurang jika Anda memasukkan terlalu banyak modul.  Namun, dapat menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah untuk menemukan keseimbangan</a> antara jumlah plugin dan jumlah tugas mikronukleus (biasanya hanya berisi kode yang sering digunakan). <br><br>  Juga sulit untuk menentukan terlebih dahulu (sebelum pengembangan aplikasi) tingkat optimal fragmentasi kode mikronukleus.  Dan mengubah pendekatan nanti hampir mustahil. <br><br>  <i>Baik untuk:</i> <br><br><ul><li>  Buat aplikasi yang dapat dikembangkan yang digunakan oleh banyak orang.  Sebagai contoh, iPhone OS memiliki akar "microkernel" - pengembangnya mengambil inspirasi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mach</a> (ini adalah salah satu contoh pertama dari microkernel). </li><li>  Pembuatan aplikasi dengan pemisahan yang jelas dari metode dasar dan aturan tingkat tinggi. </li><li>  Pengembangan sistem dengan seperangkat aturan yang berubah secara dinamis yang harus sering diperbarui. </li></ul><br><h5>  Layanan microser </h5><br>  Mirip dengan arsitektur yang digerakkan oleh peristiwa dan mikrokernel.  Tetapi mereka digunakan ketika tugas aplikasi individual dapat dengan mudah dibagi menjadi fungsi-fungsi kecil - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layanan independen</a> .  Layanan ini dapat ditulis dalam berbagai bahasa pemrograman karena mereka berkomunikasi satu sama lain menggunakan REST API (misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hemat</a> ). <br><br>  Dalam proporsi apa kode dibagi, pengembang memutuskan, tetapi Sam Newman, penulis buku " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat Layanan Mikro,</a> " merekomendasikan agar Anda mengalokasikan sebanyak mungkin baris kode ke layanan mikro karena tim dapat mereproduksi dalam dua minggu.  Menurutnya, ini akan memungkinkan untuk menghindari "kembung" berlebihan dari arsitektur. <br><br>  Paling sering, layanan mikro diluncurkan dalam wadah yang disebut.  Wadah-wadah ini dapat diakses melalui jaringan ke layanan dan aplikasi microser lainnya, dan sistem orkestrasi mengelola semuanya: contohnya termasuk Kubernetes, Docker Swarm, dll. <br><br>  <i>Keuntungan:</i> <br><br>  Arsitektur microservice menyederhanakan penskalaan aplikasi.  Untuk mengimplementasikan fitur baru, cukup tulis layanan baru.  Jika fungsi tidak lagi diperlukan, layanan microsoft dapat dinonaktifkan.  Setiap layanan mikro adalah proyek terpisah, oleh karena itu mudah untuk mendistribusikan pekerjaan mereka di antara tim pengembangan. <br><br>  Baca lebih lanjut tentang mekanisme penskalaan sistem layanan mikro dalam buku oleh Martin L. Abbott, The Art of Skalability. <br><br>  <i>Kekurangan:</i> <br><br>  Sulit untuk mencari kesalahan.  Tidak seperti sistem monolitik (ketika semua fungsi berada di kernel yang sama), mungkin sulit untuk menentukan mengapa permintaan "jatuh".  Untuk perincian, Anda harus masuk ke log dari proses "bersalah" (jika ada beberapa, masalahnya diperburuk). <br><br>  Ini menciptakan overhead tambahan untuk pengiriman pesan antar layanan microser.  Menurut perkiraan kami, pertumbuhan biaya jaringan dapat mencapai 25%. <br><br>  Kelemahan lain adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perlunya bertahan</a> dengan konsep konsistensi akhirnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koherensi dalam jangka panjang</a> ).  Layanan Microsoft memiliki gudang data mereka sendiri, yang diakses oleh layanan Microsoft lainnya.  Informasi tentang perubahan pada data ini tidak didistribusikan secara instan melalui sistem.  Oleh karena itu, situasi muncul ketika beberapa layanan mikro (meskipun untuk periode waktu yang sangat singkat) memiliki data yang sudah usang. <br><br>  <i>Tempat menggunakan:</i> <br><br><ul><li>  Dalam proyek besar dengan beban tinggi.  Misalnya, layanan microser digunakan oleh platform streaming.  Sistem pengiriman konten dan layanan dukungan lainnya dapat diskalakan secara independen satu sama lain, beradaptasi untuk memuat perubahan. </li><li>  Dalam sistem yang menggunakan sumber daya "campuran".  Jika salah satu bagian dari aplikasi membutuhkan lebih banyak waktu prosesor, dan yang kedua - memori, maka masuk akal untuk membaginya menjadi layanan microser.  Kemudian mereka dapat di-host di mesin yang berbeda - dengan CPU yang kuat atau sejumlah besar memori, masing-masing. </li><li>  Ketika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan dibutuhkan</a> .  Karena layanan mikro diisolasi dan berkomunikasi dengan API, dapat dijamin bahwa hanya informasi yang diperlukan layanan tertentu yang ditransmisikan.  Ini penting ketika bekerja dengan kata sandi atau data kartu pembayaran. </li></ul><br><h2>  Mengapa kita beralih ke layanan microser di 1cloud </h2><br>  Seperti yang telah kami katakan, dasar layanan yang kami sediakan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud pribadi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server virtual</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyimpanan cloud objek</a> , dll.) Didasarkan pada arsitektur multi-level.  Dia menunjukkan dirinya di sisi yang baik, tetapi sekarang kemampuannya untuk skala mulai habis. <br><br>  Kami menjadi semakin banyak mitra yang memberikan solusi berdasarkan platform waralaba kami.  Ada situs dan layanan jarak jauh yang sulit dikelola dari satu titik (khususnya, peralatan kami terletak di beberapa pusat data <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Rusia, Kazakhstan, dan Belarus</a> ). <br><br>  Untuk mempermudah skala fungsi yang ada dan memperkenalkan fitur baru, kami mentransfer seluruh infrastruktur kami ke layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">microsoft</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1cloud</a> . <br><br><img src="https://habrastorage.org/webt/qc/en/nv/qcennvcdxbriz_2it7sf3jhtpv8.png"><br><br>  Kami ingin memisahkan mereka menjadi modul-modul terpisah dan alih-alih satu basis data yang kompleks mendapatkan N yang sederhana.  Dengan demikian, dalam arsitektur baru, setiap fitur akan memiliki basis data terpisah.  Ini jauh lebih nyaman dan efisien dalam dukungan dan pengembangan. <br><br>  Kami akan dapat membagi pekerjaan pada layanan antara beberapa pengembang (sorot spesialisasi di perusahaan) dan skala efektif secara horizontal - bila perlu, kami hanya menghubungkan layanan microser baru. <br><br>  Pelanggan kami juga akan menerima sejumlah keuntungan.  Karena layanan Microsoft tidak terhubung satu sama lain, maka ketika layanan tertentu gagal, hanya saja layanan itu tidak tersedia, semua yang lain akan terus berfungsi secara normal.  Selain itu, bahkan jika penurunan global dalam layanan kami terjadi, panel kontrol akan terus bekerja. <br><br>  Pelanggan dari Kazakhstan dan Belarus (dan negara-negara lain tempat kami akan membuka kantor perwakilan) akan melihat peningkatan signifikan dalam kecepatan dan responsif antarmuka, karena panel kontrol akan berlokasi secara lokal. <br><br><h5>  Apa yang sudah dilakukan </h5><br>  Sejauh ini kami hanya menerapkan pilot pertama: "Layanan Pemantauan".  Layanan yang tersisa akan ditransfer ke trek baru pada akhir 2018 - awal 2019. <br><br>  Pada saat yang sama, arsitektur baru meletakkan dasar teknologi untuk tahap selanjutnya - migrasi ke wadah.  Sekarang kita menggunakan infrastruktur Windows, dan untuk beralih ke wadah, kita perlu menulis ulang semua kode yang terakumulasi ke .NetCore dan mentransfernya ke Linux. <br><br>  Kami berencana untuk memulai transisi baru pada awal 2019 dan menyelesaikannya pada akhir tahun depan. <br><br><div class="spoiler">  <b class="spoiler_title">Dengan kata-kata sederhana tentang apa yang layak diingat tentang arsitektur</b> <div class="spoiler_text"><ul><li>  <b>Arsitektur bertingkat</b> - aplikasi dibagi menjadi beberapa tingkatan, yang masing-masing menjalankan serangkaian fungsi yang didefinisikan secara ketat.  Setiap level dapat dimodifikasi secara individual.  Di antara kekurangannya adalah kecepatan rendah kode dan kesulitan menemukan bug. <br><br>  Cocok untuk mengembangkan aplikasi yang perlu cepat dibawa ke pasar.  Sering digunakan untuk membuat layanan perusahaan. </li><li>  <b>Arsitektur berorientasi peristiwa</b> - di sini pengembang menentukan reaksi sistem terhadap peristiwa apa pun.  Misalnya, jika data diterima, tulis ke file.  Aplikasi yang didasarkan pada arsitektur berorientasi peristiwa mudah untuk diukur, karena semua penangan acara tidak tahu apa-apa tentang implementasi satu sama lain.  Namun, men-debug sistem seperti itu sulit - tindakan tunggal dapat menyebabkan beberapa rangkaian tindakan sekaligus (sulit untuk memahami mana yang menyebabkan kegagalan). <br><br>  Digunakan untuk membuat sistem asinkron, pengaturan antarmuka grafis dan sistem pengiriman pesan. </li><li>  <b>Arsitektur mikrokernel</b> - terdiri dari dua komponen utama: plugin dan kernel.  Pengaya bertanggung jawab atas logika bisnis, dan kernel bertanggung jawab untuk memuat dan menurunkannya.  Pemisahan tugas ini menyederhanakan dukungan sistem.  Namun, ini dapat mempengaruhi kinerja - secara langsung tergantung pada jumlah modul yang terhubung dan aktif. <br><br>  Sangat cocok untuk mengembangkan aplikasi yang dapat dikembangkan yang digunakan oleh banyak orang, dan sistem dengan seperangkat aturan yang sering harus diperbarui (plugin menjamin kemudahan memperbarui). </li><li>  <b>Arsitektur microservice</b> - aplikasi dibagi menjadi fungsi - microservice.  Setiap layanan mikro adalah komponen independen dengan logika bisnisnya sendiri.  Komponen-komponen ini saling berkomunikasi menggunakan API.  Aplikasi semacam itu mudah dikembangkan (dimungkinkan untuk mendistribusikan pekerjaan di antara tim pengembangan), tetapi sulit untuk di-debug. <br><br>  Digunakan dalam proyek besar dengan beban tinggi, yang membutuhkan peningkatan keamanan. </li></ul><br><br></div></div><br><h5>  Apa lagi yang kami tulis di Blog 1cloud: </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1cloud Cloud Architecture Evolution: Tantangan Modulasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana IaaS membantu franchisee 1C: pengalaman 1cloud</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa pemantauan perlu dilakukan?</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424911/">https://habr.com/ru/post/id424911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424897/index.html">Pertemuan yang tidak terduga. Bab 18</a></li>
<li><a href="../id424899/index.html">Apa yang harus didengarkan tentang audio: 15 podcast</a></li>
<li><a href="../id424901/index.html">Intisari materi menarik untuk pengembang seluler # 272 (24 September - 30 September)</a></li>
<li><a href="../id424905/index.html">Mengembangkan hexapod dari awal (bagian 2) - build</a></li>
<li><a href="../id424907/index.html">DEFCON Conference 22. GTVHacker Group. Retas semuanya: 20 perangkat dalam 45 menit. Bagian 1</a></li>
<li><a href="../id424913/index.html">Badan Energi Internasional: energi angin akan berlaku di Eropa pada tahun 2027</a></li>
<li><a href="../id424915/index.html">DEFCON Conference 22. GTVHacker Group. Retas semuanya: 20 perangkat dalam 45 menit. Bagian 2</a></li>
<li><a href="../id424917/index.html">Bagaimana kami membuat kembali perkiraan yang buruk menjadi sedikit lebih baik</a></li>
<li><a href="../id424919/index.html">Mutiara dari pasar loak atau rekayasa terbalik IP-camera DCS-5220A1</a></li>
<li><a href="../id424921/index.html">Bagaimana matematika jaringan dapat membantu Anda mendapatkan teman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>