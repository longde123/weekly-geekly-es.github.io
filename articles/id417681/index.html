<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛸 ✍🏿 🛷 Pencelupan dalam pengembangan pada Ethereum. Bagian 5: Oraclize 👧 👨🏼‍🎤 💒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Akses ke file besar dan berbagai data dinamis eksternal seringkali merupakan bagian yang sangat penting dari aplikasi yang didesentralisasi. Pada saat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pencelupan dalam pengembangan pada Ethereum. Bagian 5: Oraclize</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417681/">  Akses ke file besar dan berbagai data dinamis eksternal seringkali merupakan bagian yang sangat penting dari aplikasi yang didesentralisasi.  Pada saat yang sama, Ethereum sendiri tidak menyediakan mekanisme untuk berbelok ke luar - kontrak pintar hanya dapat dibaca dan ditulis dalam blockchain itu sendiri.  Pada artikel ini, kami akan mempertimbangkan Oraclize, yang hanya memungkinkan untuk berinteraksi dengan dunia luar dengan menanyakan hampir semua sumber daya Internet.  Topik terkait adalah IPFS, dan menyebutkannya secara singkat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/_k/1m/sp_k1m_ob9-qh3_yiiyhmtecypu.jpeg"></div><br><a name="habracut"></a><br><h2>  IPFS </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IPFS</a> adalah sistem file terdistribusi dengan pengalamatan konten.  Ini berarti bahwa untuk konten file apa pun yang ditambahkan di sana, hash unik dipertimbangkan.  Hash yang sama kemudian digunakan untuk mencari dan mengambil konten ini dari jaringan. <br>  Informasi dasar telah dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> dan beberapa lainnya, jadi kami tidak melihat alasan untuk mengulanginya. <br><br><h3>  Mengapa menggunakan IPFS bersamaan dengan Ethereum? </h3><br>  Untuk menyimpan konten volume apa pun di blockchain terlalu mahal dan berbahaya bagi jaringan.  Oleh karena itu, opsi terbaik adalah menyimpan beberapa jenis tautan ke file yang terletak di penyimpanan off-chain, belum tentu IPFS.  Tetapi IPFS memiliki sejumlah keunggulan: <br><br><ul><li>  Tautan file adalah hash yang unik untuk konten spesifik file, jadi jika kita meletakkan hash ini di blockchain, kita dapat yakin bahwa file yang diterima darinya adalah yang awalnya ditambahkan, file tidak dapat diganti </li><li>  Sistem terdistribusi menjamin terhadap tidak tersedianya server tertentu (karena pemblokiran atau alasan lain) </li><li>  Tautan ke file dan konfirmasi hash digabungkan dalam satu baris, yang berarti Anda dapat menulis lebih sedikit ke blockchain dan menghemat bensin </li></ul><br>  Di antara kekurangannya, orang dapat menyebutkan bahwa karena tidak ada server pusat, maka untuk aksesibilitas file perlu bahwa setidaknya satu file "didistribusikan".  Tetapi jika Anda memiliki file tertentu, maka menghubungkan ke distributor itu mudah - mulai daemon ipfs Anda dan tambahkan file melalui <code>ipfs add</code> . <br><br>  Teknologi ini sangat cocok untuk ideologi desentralisasi, oleh karena itu, mengingat Oraclize sekarang, kita akan sering menghadapi penggunaan IPFS dalam mekanisme oracle yang berbeda. <br><br><h2>  Oraclize </h2><br>  Untuk melakukan hampir semua pekerjaan yang bermanfaat, kontrak yang cerdas perlu menerima data baru.  Namun, tidak ada kemampuan bawaan untuk memenuhi permintaan dari blockchain ke dunia luar.  Tentu saja, Anda dapat menambahkan semua yang diperlukan oleh transaksi secara manual, tetapi tidak mungkin untuk memverifikasi dari mana data ini berasal dan keandalannya.  Plus, Anda mungkin perlu mengatur infrastruktur tambahan untuk memperbarui data dinamis dengan cepat, seperti nilai tukar.  Dan pembaruan dengan interval tetap akan menyebabkan kelebihan gas. <br><br>  Oleh karena itu, layanan yang disediakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oraclize</a> sangat berguna: dalam kontrak pintar, Anda dapat mengirim permintaan ke hampir semua API atau sumber daya di Internet, pastikan bahwa data yang diterima dari sumber daya yang ditentukan tidak berubah, dan gunakan hasilnya dalam kontrak pintar yang sama. <br><br>  Oraclize bukan hanya layanan Ethereum, fungsionalitas serupa disediakan untuk blockchain lainnya, tetapi kami hanya akan menjelaskan bundel dengan Ethereum. <br><br><h3>  Memulai </h3><br>  Semua yang diperlukan untuk memulai adalah menambahkan salah satu file oraclizeAPI dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> ke proyek.  Anda hanya perlu memilih yang cocok untuk versi kompiler Anda (solc): oraclizeAPI_0.5.sol untuk versi mulai dari 0.4.18, oraclizeAPI_0.4.sol untuk versi dari 0.4.1, oraclizeAPI_pre0.4.sol untuk semua yang lebih tua, dukungan Versi ini sudah dihentikan.  Jika Anda menggunakan truffle, maka jangan lupa untuk mengganti nama file menjadi usingOraclize - ini mengharuskan nama file dan kontrak yang cocok. <br><br>  Dengan memasukkan file yang sesuai dalam proyek Anda, Anda mewarisi kontrak dari <code>usingOraclize</code> .  Dan Anda dapat mulai menggunakan Oracle, yang bermuara pada dua hal utama: mengirim permintaan menggunakan penolong <code>oraclize_query</code> , dan kemudian memproses hasilnya dalam fungsi <code>__callback</code> .  Kontrak pintar paling sederhana (untuk mendapatkan harga airtime saat ini dalam dolar) mungkin terlihat seperti ini: <br><br><pre> <code class="javascript hljs">pragma solidity <span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./usingOraclize.sol"</span></span>; contract ExampleContract is usingOraclize { string public ETHUSD; event updatedPrice(string price); event newOraclizeQuery(string description); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ updatePrice(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (msg.sender == oraclize_cbAddress()); ETHUSD = result; updatedPrice(result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updatePrice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oraclize_getPrice(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>) &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance) { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was NOT sent, please add some ETH to cover for the query fee"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newOraclizeQuery(<span class="hljs-string"><span class="hljs-string">"Oraclize query was sent, standing by for the answer.."</span></span>); oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>); } } }</code> </pre> <br>  Fungsi mengirim permintaan adalah <code>updatePrice</code> .  Anda dapat melihat bahwa pertama-tama ada cek bahwa <code>oraclize_getPrice(“URL”)</code> lebih besar dari saldo kontrak saat ini.  Ini karena panggilan <code>oraclize_query</code> harus dibayar, harga dihitung sebagai jumlah dari komisi tetap dan pembayaran gas untuk menelepon kembali.  <code>“URL”</code> adalah sebutan dari salah satu jenis sumber data, dalam hal ini adalah permintaan sederhana melalui https, maka kami akan mempertimbangkan opsi lain.  Jawaban berdasarkan permintaan dapat diuraikan di muka sebagai json (seperti dalam contoh) dan dalam beberapa cara lain (kami akan mempertimbangkan lebih lanjut).  Baris <code>__callback</code> dikembalikan dalam <code>__callback</code> .  Pada awalnya, diverifikasi bahwa panggilan tersebut dilewatkan dari alamat tepercaya oraclize <br><br>  Semua opsi untuk menggunakan oraclize dibangun berdasarkan satu skema, hanya sumber data dan kemampuan untuk menambahkan otentikasi ke <code>__callback</code> .  Oleh karena itu, dalam contoh di masa mendatang kami hanya akan mengutip perbedaan yang signifikan. <br><br><h3>  Gunakan harga </h3><br>  Seperti yang telah disebutkan, eter ekstra dibayarkan untuk permintaan oraclize, dan itu dihapus dari saldo kontrak, dan bukan alamat panggilan.  Pengecualian hanya permintaan pertama dari setiap kontrak baru, itu diberikan secara gratis.  Menarik juga bahwa mekanisme yang sama dipertahankan dalam jaringan uji, tetapi pembayaran dilakukan dengan menyiarkan jaringan yang sesuai, yaitu, dalam permintaan testnet praktis gratis. <br><br>  Telah disebutkan bahwa harga permintaan terdiri dari dua nilai: komisi tetap dan pembayaran untuk panggilan balik gas.  Komisi tetap didefinisikan dalam dolar, dan jumlah eter dihitung dari kurs saat ini.  Komisi tergantung pada sumber data dan mekanisme pendukung tambahan, yang akan kita bahas.  Tabel harga saat ini terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/w2/xv/d9w2xvqkoi2laplioqc377xydxm.png"></div><br>  Seperti yang Anda lihat, harga per permintaan URL adalah beberapa sen.  Apakah banyak atau sedikit?  Untuk melakukan ini, mari kita pertimbangkan berapa biaya bagian kedua - biaya gas panggilan balik. <br>  Ini bekerja sesuai dengan skema berikut: jumlah eter yang dibutuhkan untuk membayar jumlah gas tetap pada harga tetap ditransfer terlebih dahulu dengan permintaan dari kontrak.  Jumlah ini harus cukup untuk membuat panggilan balik, dan harganya harus memadai untuk pasar, jika tidak transaksi tidak akan melalui atau akan menggantung untuk waktu yang sangat lama.  Pada saat yang sama, jelas bahwa tidak selalu mungkin untuk mengetahui jumlah gas di muka, oleh karena itu, dewan harus memiliki margin (margin tidak dikembalikan).  Nilai standarnya adalah batas 200 ribu gas dengan harga 20 gwei.  Ini cukup untuk panggilan balik rata-rata dengan beberapa entri dan semacam logika.  Dan harga 20 gwei, meskipun mungkin tampak terlalu besar pada saat ini (pada saat penulisan, rata-rata adalah 4 gwei), tetapi pada saat masuknya transaksi, harga pasar tiba-tiba bisa melompat dan bahkan lebih tinggi, sehingga secara umum nilai-nilai ini dekat dengan yang sebenarnya digunakan.  Jadi, dengan nilai-nilai seperti itu dan harga udara di wilayah $ 500, pembayaran gas akan mendekati $ 2, jadi kita dapat mengatakan bahwa komisi tetap memakan sebagian kecil. <br><br>  Jika Anda tahu apa yang Anda lakukan, maka ada opsi untuk mengubah batas dan harga gas, sehingga menghemat permintaan secara signifikan. <br><br>  Harga gas dapat diatur oleh fungsi terpisah - <code>oraclize_setCustomGasPrice(&lt;  wei&gt;)</code> .  Setelah panggilan, harga disimpan dan digunakan dalam semua permintaan berikutnya. <br>  Batas itu dapat diatur dalam kueri <code>oraclize_query</code> , menetapkannya dengan argumen terakhir, misalnya seperti ini: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span>);</code> </pre> <br>  Jika Anda memiliki logika kompleks dalam <code>__callback</code> dan gas dikonsumsi lebih dari 200rb, maka Anda pasti perlu menetapkan batas yang mencakup kasus konsumsi gas terburuk.  Kalau tidak, jika batas terlampaui, <code>__callback</code> hanya <code>__callback</code> memutar kembali. <br><br>  Ngomong-ngomong, baru-baru ini oraclize mendapatkan informasi yang dapat Anda bayar untuk permintaan di luar blockchain, yang akan memungkinkan Anda untuk tidak menghabiskan seluruh batas atau mengembalikan saldo (dan pembayaran tidak datang dari kontrak).  Kami belum harus menggunakan ini, tetapi oraclize penawaran untuk menghubungi mereka di info@oraclize.it, jika opsi ini menarik.  Karena itu, perlu diingat. <br><br><h3>  Bagaimana cara kerjanya </h3><br>  Mengapa, setelah mewarisi dari kontrak pintar biasa, apakah kita mendapatkan fungsionalitas yang pada awalnya tidak didukung oleh mekanisme blockchain?  Bahkan, layanan oracle tidak hanya terdiri dari kontrak dengan fungsi pembantu.  Pekerjaan utama untuk mendapatkan data dilakukan oleh layanan eksternal.  Kontrak pintar membentuk aplikasi untuk akses ke data eksternal dan menempatkannya di blockchain.  Layanan eksternal - memonitor blok-blok baru dari blockchain dan, jika mendeteksi suatu aplikasi, mengeksekusinya.  Secara skematis, ini dapat direpresentasikan sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/th/b0/ka/thb0kan1hwm75ijixmdrqtiwvum.png"></div><br><h3>  Sumber data </h3><br>  Selain <code>URL</code> dipertimbangkan, oraclize menyediakan 4 opsi lagi (yang Anda lihat di bagian penetapan harga): <code>WolframAlpha</code> , <code>IPFS</code> , <code>random</code> dan <code>computation</code> .  Mari kita pertimbangkan masing-masing. <br><br><h4>  1. URL </h4><br>  Contoh sudah dibahas menggunakan sumber data ini.  Ini adalah sumber permintaan HTTP ke berbagai API.  Contohnya adalah sebagai berikut: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"</span></span>);</code> </pre> <br>  Ini mendapatkan harga eter, dan karena api menyediakan string json dengan kumpulan data, permintaan tersebut dibungkus dengan parser json dan hanya mengembalikan bidang yang kita butuhkan.  Dalam hal ini, GET, tetapi URL sumber juga mendukung permintaan POST.  Jenis permintaan ditentukan secara otomatis oleh argumen tambahan.  Jika ada json yang valid seperti pada contoh ini: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"URL"</span></span>, <span class="hljs-string"><span class="hljs-string">"json(https://shapeshift.io/sendamount).success.deposit"</span></span>, <span class="hljs-string"><span class="hljs-string">'{"pair":"eth_btc","amount":"1","withdrawal":"1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}'</span></span>)</code> </pre> <br>  maka permintaan diproses sebagai POST (api yang digunakan dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , jika tertarik) <br><br><h4>  2. WolframAlpha </h4><br>  Sumber data ini memungkinkan Anda untuk mengakses layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WolframAlpha</a> , yang dapat memberikan jawaban atas berbagai permintaan fakta atau perhitungan, misalnya <br><br><pre> <code class="javascript hljs">oraclize_query(“WolframAlpha”, “president <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Russia”)</code> </pre> <br>  akan mengembalikan <code>Vladimir Putin</code> , dan meminta <br><br><pre> <code class="javascript hljs">oraclize_query(“WolframAlpha”, “solve x^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>”)</code> </pre> <br>  akan mengembalikan <code>x = 2</code> . <br>  Seperti yang Anda lihat, hasilnya tidak lengkap karena simbol ± hilang.  Karena itu, sebelum menggunakan sumber ini, Anda perlu memeriksa bahwa nilai permintaan tertentu dapat digunakan dalam kontrak pintar.  Selain itu, otentikasi tidak didukung untuk tanggapan, jadi oraclize sendiri merekomendasikan agar sumber ini hanya digunakan untuk pengujian. <br><br><h4>  3. IPFS </h4><br>  Seperti yang Anda tebak, ini memungkinkan Anda untuk mengambil konten file di IPFS menggunakan multi-hash.  Batas waktu untuk menerima konten adalah 20 detik. <br><br><pre> <code class="javascript hljs">oraclize_query(“IPFS”, “QmTL5xNq9PPmwvM1RhxuhiYqoTJcmnaztMz6PQpGxmALkP”)</code> </pre> <br>  akan kembali <code>Hello, Habr!</code>  (jika file dengan konten ini masih tersedia) <br><br><h4>  4. acak </h4><br>  Pembuatan angka acak bekerja dengan cara yang sama dengan sumber lain, tetapi jika Anda menggunakan <code>oraclize_query</code> , dibutuhkan persiapan argumen yang memakan waktu.  Untuk menghindari hal ini, Anda dapat menggunakan <code>oraclize_newRandomDSQuery(delay, nbytes, customGasLimit)</code> pembantu <code>oraclize_newRandomDSQuery(delay, nbytes, customGasLimit)</code> , mengatur hanya penundaan eksekusi (dalam detik), jumlah byte yang dihasilkan dan batas gas untuk memanggil <code>__callback</code> . <br>  Menggunakan <code>random</code> memiliki beberapa hal yang perlu diingat: <br><br><ul><li>  Untuk mengkonfirmasi bahwa nomor tersebut sebenarnya acak, jenis verifikasi khusus digunakan - Buku Besar, yang dapat dilakukan pada blockchain (tidak seperti orang lain, tetapi lebih lanjut tentang itu nanti).  Ini berarti bahwa dalam konstruktor kontrak pintar, Anda perlu mengatur metode verifikasi ini berdasarkan fungsinya: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_Ledger);</code> </pre> <br>  Dan di awal panggilan balik harus ada cek itu sendiri: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 _queryId, string _result, bytes _proof</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) == <span class="hljs-number"><span class="hljs-number">0</span></span>) ); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  Pemeriksaan ini memerlukan jaringan nyata dan tidak akan bekerja pada Ganache, jadi untuk pengujian lokal Anda dapat menghapus sementara garis ini.  Omong-omong, argumen ketiga untuk <code>__callback</code> sini adalah parameter opsional <code>_proof</code> .  Itu selalu diperlukan ketika salah satu jenis konfirmasi digunakan. </li><li>  Jika Anda menggunakan nomor acak untuk saat-saat kritis, misalnya, untuk menentukan pemenang dalam lotre, tangkap input pengguna sebelum mengirimRandomDSQuery baru.  Kalau tidak, situasi ini dapat terjadi: oraclize panggilan _callback dan transaksi terlihat oleh semua orang dalam daftar yang tertunda.  Bersamaan dengan ini, angka acak itu sendiri terlihat.  Jika pengguna dapat melanjutkan, secara kasar, untuk membuat taruhan, maka mereka akan dapat menentukan harga gas yang lebih tinggi dan mendorong tarif mereka sebelum _callback dijalankan, mengetahui sebelumnya bahwa itu akan menang. </li></ul><br><br><h4>  5. perhitungan </h4><br>  Ini adalah sumber yang paling fleksibel.  Ini memungkinkan Anda untuk menulis skrip Anda sendiri dan menggunakannya sebagai sumber data.  Komputasi terjadi pada AWS.  Untuk eksekusi, Anda perlu mendeskripsikan Dockerfile dan menggabungkannya dengan file tambahan sewenang-wenang dalam arsip zip, dan mengunduh arsip di IPFS.  Implementasi harus memenuhi ketentuan berikut: <br><br><ul><li>  Tulis jawaban yang ingin Anda kembalikan dengan baris terakhir di stdout </li><li>  Jawabannya tidak boleh lebih dari 2500 karakter </li><li>  Inisialisasi dan eksekusi tidak boleh lebih dari 5 menit total </li></ul><br>  Sebagai contoh bagaimana hal ini dilakukan, kami akan mempertimbangkan bagaimana melakukan penyatuan paling sederhana dari baris yang ditransmisikan dan mengembalikan hasilnya. <br><br>  Dockerfile: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 MAINTAINER <span class="hljs-string"><span class="hljs-string">"info@rubyruby.ru"</span></span> CMD <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG0</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG1</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG2</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ARG3</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  Variabel lingkungan <code>ARG0</code> , <code>ARG1</code> , dll.  - Ini adalah parameter yang diteruskan bersama dengan permintaan. <br>  Tambahkan dockerfile ke arsip, mulai server ipfs dan tambahkan arsip ini di sana <br><br><pre> <code class="bash hljs">$ zip concatenation.zip Dockerfile $ ipfs daemon &amp; $ ipfs add concatenation.zip QmWbnw4BBFDsh7yTXhZaTGQnPVCNY9ZDuPBoSwB9A4JNJD</code> </pre> <br>  Kami menggunakan hash yang dihasilkan untuk mengirim permintaan melalui <code>oraclize_query</code> dalam kontrak pintar: <br><br><pre> <code class="javascript hljs">oraclize_query(<span class="hljs-string"><span class="hljs-string">"computation"</span></span>, [<span class="hljs-string"><span class="hljs-string">"QmVAS9TNKGqV49WTEWv55aMCTNyfd4qcGFFfgyz7BYHLdD"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s2"</span></span>, <span class="hljs-string"><span class="hljs-string">"s3"</span></span>, <span class="hljs-string"><span class="hljs-string">"s4"</span></span>]);</code> </pre> <br>  Array digunakan sebagai argumen, di mana elemen pertama adalah multihash arsip, dan sisanya adalah parameter yang termasuk dalam variabel lingkungan. <br><br>  Jika Anda menunggu permintaan selesai, maka <code>__callback</code> akan <code>__callback</code> hasilnya <code>s1 s2 s3 s4</code> . <br><br><h3>  Pembantu Parser dan Subqueries </h3><br>  Dari respons yang dikembalikan oleh sumber apa pun, Anda dapat memilih sebelumnya hanya informasi yang diperlukan menggunakan sejumlah pembantu, seperti: <br><br><h4>  1. JSON parser </h4><br>  Anda melihat metode ini dalam contoh pertama, di mana hanya harga dikembalikan dari hasil yang dikembalikan oleh coinmarketcap: <br><br><pre> <code class="bash hljs">json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd</code> </pre> <br>  Kasingnya cukup jelas, contohnya kembali: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ethereum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"symbol"</span></span>: <span class="hljs-string"><span class="hljs-string">"ETH"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rank"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"462.857"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price_btc"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0621573"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"24h_volume_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"1993200000.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"market_cap_usd"</span></span>: <span class="hljs-string"><span class="hljs-string">"46656433775.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"available_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"total_supply"</span></span>: <span class="hljs-string"><span class="hljs-string">"100800968.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_supply"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_1h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-0.5"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_24h"</span></span>: <span class="hljs-string"><span class="hljs-string">"-3.02"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"percent_change_7d"</span></span>: <span class="hljs-string"><span class="hljs-string">"5.93"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last_updated"</span></span>: <span class="hljs-string"><span class="hljs-string">"1532064934"</span></span> } ]</code> </pre> <br>  Karena ini adalah array, kami mengambil elemen <code>0</code> , dan dari sana - bidang <code>price_usd</code> <br><br><h4>  2. XML </h4><br>  Penggunaannya mirip dengan JSON, misalnya: <br><br><pre> <code class="bash hljs">xml(https://informer.kovalut.ru/webmaster/getxml.php?kod=7701).Exchange_Rates.Central_Bank_RF.USD.New.Exch_Rate</code> </pre> <br><h4>  3. HTML </h4><br>  Anda dapat menguraikan XHTML menggunakan XPath.  Misalnya, dapatkan kapitalisasi pasar dengan etherscan: <br><br><pre> <code class="bash hljs">html(https://etherscan.io/).xpath(string(//*[contains(@href, <span class="hljs-string"><span class="hljs-string">'/stat/supply'</span></span>)]/font))</code> </pre> <br>  <code>MARKET CAP OF $46.148 BillionB</code> <br><br><h4>  4. Pembantu Biner </h4><br>  Memungkinkan Anda memotong potongan dari data mentah menggunakan fungsi slice (offset, length).  Misalnya, kami memiliki file dengan konten "abc": <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span> &gt; example.bin</code> </pre> <br>  Letakkan di IPFS: <br><br><pre> <code class="bash hljs">$ ipfs add example.bin added Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE</code> </pre> <br>  Sekarang potong 1 karakter dari tengah: <br><br><pre> <code class="javascript hljs">binary(Qme4u9HfFqYUhH4i34ZFBKi1ZsW7z4MYHtLxScQGndhgKE).slice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Dalam jawaban yang kita dapatkan <code>b</code> <br><br>  Seperti yang mungkin Anda perhatikan, dalam kasus pembantu biner, bukan sumber IP yang digunakan, tetapi IPFS.  Bahkan, parser dapat diterapkan ke sumber apa pun, katakanlah JSON tidak perlu menerapkan apa yang mengembalikan URL, Anda dapat menambahkan konten tersebut ke file: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"one"</span></span>:<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"two"</span></span>:<span class="hljs-string"><span class="hljs-string">"2"</span></span> }</code> </pre> <br>  Tambahkan ke IPFS: <br><br><pre> <code class="bash hljs">$ ipfs add test.json added QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp</code> </pre> <br>  Dan kemudian bongkar seperti ini: <br><br><pre> <code class="bash hljs">json(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one</code> </pre> <br>  Kami mendapat <code>1</code> <br><br>  Dan kasus penggunaan yang sangat menarik adalah menggabungkan sumber data dan pengurai dalam satu permintaan.  Ini dimungkinkan menggunakan sumber data <code>nested</code> terpisah.  Kami menggunakan file yang baru saja kami buat dalam permintaan yang lebih kompleks (menambahkan nilai dalam dua bidang): <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">WolframAlpha</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">IPFS</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">json</span></span></span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).one} to <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">IPFS</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">json</span></span></span></span>(QmZinLwAq5fy4imz8ZNgupWeNFTneUqHjPiTPX9tuR7Vxp).two}</code> </pre> <br>  Kami mendapat <code>3</code> <br>  Permintaan dibentuk sebagai berikut: tentukan sumber data <code>nested</code> , lalu untuk setiap permintaan tambahkan nama sumber di depannya dalam kurung siku, dan tambahan bingkai semua subqueries dalam <code>${..}</code> . <br><br><h3>  Pengujian </h3><br>  Oraclize menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layanan</a> validasi kueri yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berguna</a> tanpa perlu kontrak pintar.  Cukup masuk, pilih sumber data, metode verifikasi dan Anda dapat melihat bahwa itu akan kembali ke __callback jika Anda mengirim permintaan yang sesuai <br><br>  Untuk verifikasi lokal bersamaan dengan kontrak pintar, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi khusus dari Remix IDE</a> yang mendukung permintaan oraclize. <br><br>  Dan untuk mengecek secara lokal dengan Ganache, Anda akan memerlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ethereum bridge</a> , yang akan menggunakan oraclize kontrak pintar ke testnet Anda.  Untuk pengujian, pertama-tama tambahkan baris berikut ke konstruktor kontrak Anda: <br><br><pre> <code class="javascript hljs">OAR = OraclizeAddrResolverI(<span class="hljs-number"><span class="hljs-number">0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475</span></span>);</code> </pre> <br>  lari <br><br><pre> <code class="bash hljs">ganache-cli</code> </pre> <br>  Lalu <br><br><pre> <code class="bash hljs">node bridge --dev</code> </pre> <br>  Tunggu sampai kontraknya mati dan Anda dapat menguji.  Dalam output dari <code>node bridge</code> Anda dapat melihat permintaan yang dikirim dan respons yang diterima. <br><br>  Bantuan lain tidak hanya selama pengujian, tetapi juga dalam penggunaan aktual adalah kemampuan untuk memonitor permintaan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Jika Anda meminta pada jaringan publik, maka Anda dapat menggunakan hash dari transaksi di mana permintaan dieksekusi.  Jika Anda menggunakan otentikasi, maka perlu diingat bahwa mereka dijamin akan dikirim hanya ke mainnet, untuk jaringan lain dapat mengembalikan 0. Jika permintaan berada di jaringan lokal, Anda dapat menggunakan id permintaan, yang mengembalikan <code>oraclize_query</code> .  Ngomong-ngomong, disarankan untuk selalu menyimpan id ini, misalnya, dalam pemetaan serupa: <br><br><pre> <code class="javascript hljs">mapping(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32</span></span></span><span class="hljs-function">=&gt;</span></span>bool) validIds;</code> </pre> <br>  Pada saat permintaan, tandai id yang dikirim sebagai <code>true</code> : <br><br><pre> <code class="javascript hljs">bytes32 queryId = oraclize_query(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">); validIds[queryId] = true;</span></span></code> </pre><br>  Dan kemudian di <code>__callback</code> periksa bahwa permintaan dengan id ini belum diproses: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes32 myid, string result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(validIds[myid] != bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(msg.sender == oraclize_cbAddress()); validIds[myid] = bytes32(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">...</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Ini diperlukan karena <code>__callback</code> pada satu permintaan dapat dipanggil lebih dari sekali karena kekhasan mekanisme Oraclize. <br><br><h3>  Otentikasi </h3><br>  Di tabel dengan sumber, Anda dapat melihat bahwa sumber yang berbeda dapat mendukung berbagai jenis konfirmasi, dan biaya yang berbeda mungkin dibebankan.  Ini adalah bagian yang sangat penting dari oraclize, tetapi deskripsi rinci tentang mekanisme ini adalah topik yang terpisah. <br><br>  Mekanisme yang paling umum digunakan, setidaknya oleh kami, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TLSNotary</a> dengan penyimpanan di IPFS.  Penyimpanan di IPFS lebih efisien karena <code>__callback</code> tidak mengembalikan bukti itu sendiri (mungkin di wilayah 4-5 kilobyte), tetapi multi-hash yang jauh lebih kecil.  Untuk menentukan tipe ini, tambahkan baris dalam konstruktor: <br><br><pre> <code class="javascript hljs">oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);</code> </pre> <br>  Kita hanya dapat mengatakan bahwa tipe ini, secara kasar, melindungi kita dari ketidakakuratan data yang diterima dari Oraclize.  Tetapi Oraclize menggunakan server Amazon, yang bertindak sebagai auditor, sehingga mereka hanya harus percaya. <br><br>  Baca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Kesimpulan </h2><br>  Oraclize menyediakan alat yang secara signifikan meningkatkan jumlah kasus penggunaan untuk kontrak pintar, serta IPFS, yang dapat dilihat di beberapa versi permintaan Oracle.  Masalah utama adalah bahwa kita lagi menggunakan data eksternal yang tunduk pada ancaman yang seharusnya dilindungi oleh blockchain: sentralisasi, kemampuan memblokir, perubahan kode, spoofing.  Tetapi sementara ini semua tidak terhindarkan, dan opsi untuk memperoleh data sangat berguna dan layak, Anda hanya perlu menyadari mengapa penggunaan blockchain diperkenalkan ke dalam proyek dan apakah penggunaan sumber eksternal yang tidak dipercaya mengurangi manfaat menjadi nol. <br><br>  Jika Anda tertarik pada beberapa topik pengembangan pada Ethereum yang belum diungkapkan dalam artikel ini - tulis di komentar, mungkin kami akan membahasnya di berikut ini. <br><br>  Pencelupan dalam pengembangan pada Ethereum: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: Web3.js dan gas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: aplikasi pengguna</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4: deploy dan debug di truffle, ganache, infura</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417681/">https://habr.com/ru/post/id417681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417671/index.html">Fitur-fitur baru dari bahasa pemrograman ABAP di webinar dari SAP</a></li>
<li><a href="../id417673/index.html">Penyelidikan mengarah Solar Dozor: 5 kasus non-standar yang diungkapkan DLP</a></li>
<li><a href="../id417675/index.html">Lokalisasi game dan aplikasi di Unity. Cepat dan mudah</a></li>
<li><a href="../id417677/index.html">Memigrasi proyek dari yii1 ke yii2 melalui pekerjaan satu kali</a></li>
<li><a href="../id417679/index.html">Warisan kuburan masa lalu. Masalah Baris Perintah Windows</a></li>
<li><a href="../id417683/index.html">Kode usang - Kode Pihak Ketiga</a></li>
<li><a href="../id417685/index.html">Webinar Skillbox Friday: Melanjutkan Pembelajaran Gratis</a></li>
<li><a href="../id417687/index.html">Asimetri kehidupan</a></li>
<li><a href="../id417689/index.html">Mobio Talks dengan Appnext CEO tentang CPI Market dan Tren Aplikasi Mobile</a></li>
<li><a href="../id417691/index.html">Rak buku kami adalah programmer C #. Bagaimana dengan kamu?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>