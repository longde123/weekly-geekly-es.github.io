<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛤️ 🐴 🤳🏻 Introduction à la programmation réactive 🔸 😑 👋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour Dans cet article je galoperai à travers l'Europe, à savoir, je vais vous dire ce qu'ils entendent par programmation réactive, vous présenter l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction à la programmation réactive</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/432004/">  Bonjour  Dans cet article je galoperai à travers l'Europe, à savoir, je vais vous dire ce qu'ils entendent par programmation réactive, vous présenter les acteurs, les flux réactifs, et enfin, en utilisant les flux réactifs, nous reconnaîtrons les gestes de la souris, comme dans l'ancien Opéra et son successeur spirituel - Vivaldi . <br><br>  L'objectif est d'introduire les concepts de base de la programmation réactive et de montrer que tout n'est pas aussi compliqué et effrayant que cela puisse paraître à première vue. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/858/157/0c68581574002383d90367c3e6b996c9.jpg" alt="image"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a></i> <br><a name="habracut"></a><br><h2>  Qu'est-ce que la programmation réactive? </h2><br>  Pour répondre à cette question, nous nous tournons vers le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site</a> .  Il a une belle image qui montre 4 critères principaux auxquels les applications réactives doivent répondre. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e5/092/390/6e5092390fa27e7843b59d57da94b8b3.svg" alt="image"><br><br>  L'application doit être rapide, tolérante aux pannes et bien évolutive. <br>  Il semble que «nous sommes pour tous bons contre tous mauvais», non? <br><br>  Que signifient ces mots: <br><br><ol><li> <b>Réactivité</b> <br><br>  L'application doit donner à l'utilisateur le résultat en une demi-seconde.  Cela inclut également le principe de l'échec rapide - c'est-à-dire qu'en cas de problème, il est préférable de renvoyer à l'utilisateur un message d'erreur tel que «Désolé, il y a eu un problème.  Réessayez plus tard que d'attendre le temps au bord de la mer.  Si l'opération est longue, nous montrons à l'utilisateur une barre de progression.  S'il est très long - «votre demande sera satisfaite provisoirement le 18 mars 2042.  Nous vous enverrons une notification par la poste. " </li><li>  <b>L'évolutivité</b> est un moyen de fournir une réactivité sous charge.  Imaginez le cycle de vie d'un service relativement réussi: <br><ol><li>  Lancement - le flux de demandes est petit, le service s'exécute sur une machine virtuelle avec un cœur. </li><li>  Le flux de demandes augmente - les noyaux sont ajoutés à la machine virtuelle et les demandes sont traitées dans plusieurs threads. </li><li>  Encore plus de charge - nous connectons le traitement par lots - les demandes à la base de données et au disque dur sont regroupées. </li><li>  Encore plus de charge - vous devez augmenter le nombre de serveurs et fournir du travail dans le cluster. <br>  Idéalement, le système lui-même devrait augmenter ou diminuer en fonction de la charge. </li></ol></li><li>  <b>Tolérance aux pannes</b> <br><br>  Nous acceptons que nous vivons dans un monde imparfait et tout se passe.  En cas de problème dans notre système, nous devons fournir des méthodes de gestion des erreurs et de récupération </li><li>  Et enfin, nous sommes invités à réaliser tout cela en utilisant un système dont l'architecture est basée sur la messagerie <b>pilotée par les</b> messages </li></ol><br>  Avant de continuer, je veux m'attarder sur la différence entre les systèmes pilotés par les événements et les systèmes pilotés par les messages. <br><br>  <b>Evénementiel:</b> <br><br><ul><li>  Événement - le système signale qu'il a atteint un certain état. </li><li>  Il peut y avoir de nombreux abonnés à l'événement. </li><li>  La chaîne d'événements est généralement courte et les gestionnaires d'événements sont proches (physiquement et en code) de la source. </li><li>  La source d'événement et ses gestionnaires ont généralement un état commun (physiquement - ils utilisent le même morceau de RAM pour l'échange d'informations). </li></ul><br>  <b>Contrairement à l'événementiel, dans un système axé sur les messages:</b> <br><br><ul><li>  Chaque message n'a qu'un seul destinataire. </li><li>  Les messages sont immuables: vous ne pouvez rien changer dans le message reçu afin que l'expéditeur en soit informé et puisse lire les informations. </li><li>  Les éléments du système répondent (ou ne répondent pas) à la réception de messages et peuvent envoyer des messages à d'autres éléments du système. </li></ul><br>  Tout cela nous offre <br><br><h1>  Modèle d'acteur </h1><br>  Jalons de développement: <br><br><ul><li>  La première mention d'acteurs est dans un article scientifique de 1973 - Carl Hewitt, Peter Bishop et Richard Steiger, «Un formalisme universel modulaire ACTOR pour l'intelligence artificielle», </li><li>  1986 - Erlang apparaît.  Ericson avait besoin d'un langage pour les équipements de télécommunications qui fournirait une tolérance aux pannes et une propagation sans erreur.  Dans le cadre de cet article, ses principales caractéristiques sont: <br><br><ul><li>  Tout est un processus </li><li>  Les messages sont le seul moyen de communication (Erlang est un langage fonctionnel et les messages qu'il contient sont immuables). </li></ul></li><li>  .. </li><li>  2004 - la première version de la langue Scala.  Ses caractéristiques: <ul><li>  Propulsé par JVM, </li><li>  Fonctionnel </li><li>  Pour le multi-threading, un modèle d'acteur a été sélectionné. </li></ul><br></li><li>  2009 - la mise en œuvre des acteurs a été allouée dans une bibliothèque séparée - Akka </li><li>  2014 - Akka.net - il a été porté sur .Net. </li></ul><br><h1>  Que peuvent faire les acteurs? </h1><br>  Les acteurs sont les mêmes objets, mais: <br><br><ul><li>  Contrairement aux objets ordinaires, les acteurs ne peuvent pas s'appeler les uns les autres. </li><li>  Les acteurs ne peuvent transmettre des informations <b>que par le biais de messages immuables</b> . </li><li>  Dès réception du message, l'acteur peut <br><ul><li>  Créer de nouveaux acteurs (ils seront plus bas dans la hiérarchie), </li><li>  Envoyer des messages à d'autres acteurs, </li><li>  Arrêtez les acteurs ci-dessous dans la hiérarchie et vous-même. </li></ul></li></ul><br>  Regardons un exemple. <br><br><img src="https://habrastorage.org/webt/ql/wj/cj/qlwjcjyygaw5s7iub_mshc1rbry.jpeg" alt="image"><br><br>  L'acteur A veut envoyer un message à l'acteur B. Tout ce qu'il a, c'est ActorRef (une adresse).  L'acteur B peut être n'importe où. <br>  L'acteur A envoie une lettre B via le système (ActorSystem).  Le système place la lettre dans la boîte aux lettres de l'acteur B et «réveille» l'acteur B. L'acteur B prend la lettre de la boîte aux lettres et fait quelque chose. <br><br>  Comparé aux méthodes d'appel sur un autre objet, cela semble inutilement compliqué, mais le modèle des acteurs s'intègre parfaitement dans le monde réel, si vous imaginez que les acteurs sont des personnes formées à faire quelque chose en réponse à certains stimuli. <br><br>  Imaginez un père et un fils: <br><br><img src="https://habrastorage.org/webt/gk/o9/s5/gko9s5syabkkpdkg0_v_aimwwis.jpeg"><br><br>  Le père envoie son fils SMSku «Nettoyer dans la chambre» et continue de faire son propre truc.  Le fils lit SMSku et commence le nettoyage.  Père, quant à lui, joue au poker.  Le fils termine le nettoyage et envoie un SMS "Terminer".  Ça a l'air simple, non? <br><br>  Imaginez maintenant que le père et le fils ne sont pas des acteurs, mais des objets ordinaires qui peuvent tirer les méthodes l'un de l'autre.  Le père tire son fils pour la méthode «nettoyer la chambre» et le suit sur ses talons, attendant que le fils termine le nettoyage et transfère le contrôle à son père.  Père ne peut pas jouer au poker pour le moment.  Dans ce contexte, le modèle d'acteur devient plus attractif. <br><br>  Passons maintenant à <br><br><h1>  Akka.NET </h1><br>  Tout ce qui est écrit ci-dessous est vrai pour l'Akka d'origine pour la JVM, mais pour moi, C # est plus proche que Java, donc je vais utiliser Akka.NET comme exemple. <br><br><h3>  Quels sont donc les avantages d'Akka? </h3><br><ul><li>  Multithreading via la messagerie.  Vous n'avez plus à souffrir de toutes sortes de verrous, sémaphores, mutex et autres charmes caractéristiques du multithreading classique avec mémoire partagée. </li><li>  Communication transparente entre le système et ses composants.  Pas besoin de vous soucier du code réseau complexe - le système lui-même trouvera la destination du message et garantira la livraison du message (ici vous pouvez insérer une blague sur UDP vs TCP). </li><li>  Architecture flexible pouvant évoluer automatiquement vers le haut ou vers le bas.  Par exemple, sous charge, le système peut augmenter les nœuds de cluster supplémentaires et répartir uniformément la charge. </li></ul><br>  Mais le sujet de la mise à l'échelle est très vaste et mérite une publication séparée.  Par conséquent, je ne parlerai plus en détail que de la fonctionnalité, qui sera utile dans tous les projets: <br><br><h2>  Gestion des erreurs </h2><br>  Les acteurs ont une hiérarchie - elle peut être représentée comme un arbre.  Chaque acteur a un parent et peut avoir des «enfants». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99e/57e/919/99e57e919cbea8e6761b75537c3f507a.png" alt="image"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation Akka.NET</a> Copyright 2013-2018 Projet Akka.NET</i> <br><br>  Pour chaque acteur, vous pouvez définir une stratégie de supervision - que faire si quelque chose ne va pas pour les «enfants».  Par exemple, «battre» un acteur qui a des problèmes, puis créer un nouvel acteur du même type et lui confier le même travail. <br><br>  Par exemple, j'ai réalisé une application sur Akka.net CRUD, dans laquelle la couche de "logique métier" est implémentée sur les acteurs.  L'objectif de ce projet était de savoir si les acteurs devaient être utilisés dans des systèmes non évolutifs - rendront-ils la vie meilleure ou ajouteront-ils plus de douleur. <br><br>  Comment la gestion intégrée des erreurs d'Akka peut aider: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1f/oz/ou/1fozoulh0ufwzuyufofz4n8pvbi.gif"><br></div></div><br><ol><li>  tout va bien, l'application fonctionne, </li><li>  quelque chose est arrivé au référentiel, et maintenant il ne donne le résultat qu'une seule fois sur 5, </li><li>  J'ai défini la stratégie de supervision pour "essayer 10 fois par seconde", </li><li>  l'application fonctionne à nouveau (quoique plus lentement), et j'ai le temps de comprendre quel est le problème. </li></ol><br>  Il y a une tentation de dire: "Allez, je vais écrire moi-même une telle erreur, pourquoi certains acteurs doivent-ils faire une erreur?"  Bonne remarque, mais seulement si les points d'échec sont peu nombreux. <br><br>  Et du code.  Voici à quoi ressemble l'initialisation du système d'acteur dans le conteneur IoC: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Container</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { system = ActorSystem.Create(<span class="hljs-string"><span class="hljs-string">"MySystem"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> echo = system.ActorOf&lt;EchoActor&gt;(<span class="hljs-string"><span class="hljs-string">"Echo"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//stop initialization if something is wrong with actor system var alive = echo.Ask&lt;bool&gt;(true, TimeSpan.FromMilliseconds(100)).Result; container = new WindsorContainer(); //search for dependencies //register controllers //register ActorSystem propsResolver = new WindsorDependencyResolver(container, (ActorSystem)system); system.AddDependencyResolver(propsResolver); actorSystemWrapper = new ActorSystemWrapper(system, propsResolver); container.Register(Component.For&lt;IActorRefFactory&gt;().Instance(actorSystemWrapper)); container.Register(Component.For&lt;IDependencyResolver&gt;().Instance(propsResolver)); }</span></span></code> </pre> <br>  EchoActor est l'acteur le plus simple qui renvoie une valeur à l'expéditeur: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EchoActor</span></span> : <span class="hljs-title"><span class="hljs-title">ReceiveActor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EchoActor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(flag =&gt; { Sender.Tell(flag); }); } }</code> </pre><br>  Pour connecter les acteurs avec le code «normal», la commande Ask est utilisée: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;ActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ViewBag.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Model); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CrudActorRef.Ask&lt;IEnumerable&lt;Model&gt;&gt;(DataMessage.GetAll&lt;Model&gt;(), maxDelay); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(res); }</code> </pre> <br><h3>  Total </h3><br>  En ricanant avec les acteurs, je peux dire: <br><br><ul><li>  Regardez-les si vous avez besoin d'évolutivité. </li><li>  Pour une logique métier complexe, il vaut mieux ne pas les utiliser car <ul><li>  injection de dépendance étrange.  Pour initialiser un acteur avec les dépendances nécessaires, vous devez d'abord créer un objet Props, puis le donner à ActorSystem pour créer un acteur du type souhaité.  Pour créer des accessoires à l'aide de conteneurs IoC (par exemple Castle Windsor ou Autofac), il existe des wrappers prêts à l'emploi - DependencyResolvers.  Mais j'étais confronté au fait que le conteneur IoC essayait de contrôler la durée de vie de la dépendance, et après un certain temps, le système est tombé en panne. <br><br>  * Peut-être, au lieu d'injecter une dépendance dans un objet, vous devriez placer cette dépendance en tant qu'acteur enfant. </li><li>  problèmes de frappe.  ActorRef ne sait rien du type d'acteur auquel il se réfère.  Autrement dit, au moment de la compilation, on ne sait pas si un acteur peut traiter un message de ce type ou non. </li></ul></li></ul><br><h1>  Partie 2: Jet streams </h1><br>  Passons maintenant à un sujet plus populaire et utile - les flux de jets.  Si vous ne pouvez jamais rencontrer des acteurs en cours de travail, les flux Rx seront certainement utiles à la fois dans le frontend et dans le backend.  Leur implémentation est dans presque tous les langages de programmation modernes.  Je vais donner des exemples sur RxJs, car de nos jours même les programmeurs back-end doivent parfois faire quelque chose en JavaScript. <br><br><img src="https://habrastorage.org/webt/ru/yn/g9/ruyng9clvfa1gh8bd5ai3lpnc5m.jpeg"><br>  <i>Les flux Rx sont disponibles pour tous les langages de programmation populaires.</i> <br><br>  <i>« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction à la programmation réactive que vous avez manquée</a> » par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andre Staltz</a> , sous licence CC BY-NC 4.0</i> <br><br>  Pour expliquer ce qu'est le jet stream, je vais commencer par les collections pull and push. <br><table><tbody><tr><th></th><th>  Valeur de retour unique </th><th>  Valeurs de retour multiples </th></tr><tr><td>  Tirer <br>  Synchrone <br>  Interactif </td><td>  T </td><td>  IEnumerable &lt;T&gt; </td></tr><tr><td>  Poussez <br>  Asynchrone <br>  Réactif </td><td>  Tâche &lt;T&gt; </td><td>  IObservable &lt;T&gt; </td></tr></tbody></table><br>  Les collections de tirages sont ce à quoi nous sommes tous habitués en programmation.  L'exemple le plus frappant est un tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Il dispose déjà de données, il ne modifiera pas lui-même ces données, mais il peut les fournir sur demande. <br><br><pre> <code class="javascript hljs">arr.forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  De plus, avant de faire quelque chose avec les données, vous pouvez en quelque sorte les traiter. <br><br><pre> <code class="javascript hljs">arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">I</span></span></span><span class="hljs-function"> =&gt;</span></span> “my number is ”+i).forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Imaginons maintenant qu'au départ, il n'y ait pas de données dans la collection, mais cela vous informera certainement qu'elles sont apparues (Push).  Et en même temps, nous pouvons toujours appliquer les transformations nécessaires à cette collection. <br><br>  Par exemple: <br><br><pre> <code class="javascript hljs">source.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">I</span></span></span><span class="hljs-function"> =&gt;</span></span> “my number is ”+i).forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Lorsqu'une valeur telle que 1 apparaît dans la source, console.log affichera «mon numéro est 1». <br><br>  Comment ça marche: <br><br>  Une nouvelle entité apparaît - Sujet (ou observable): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = Rx.Observable.create(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) </span></span>{ observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">3</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">4</span></span>); observer.complete(); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); });</code> </pre> <br>  Il s'agit d'une collection push qui enverra des notifications sur les modifications de son état. <br><br>  Dans ce cas, les numéros 1, 2 et 3 y apparaîtront immédiatement, dans un second 4, puis la collection «se terminera».  Il s'agit d'un type d'événement si particulier. <br><br>  La deuxième entité est Observer.  Il peut s'abonner aux événements Sujet et faire quelque chose avec les données reçues.  Par exemple: <br><br><pre> <code class="javascript hljs">observable.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x)); observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'got value '</span></span> + x), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'something wrong occurred: '</span></span> + err), <span class="hljs-attr"><span class="hljs-attr">complete</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>), }); observable .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'This is '</span></span> + x) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x));</code> </pre> <br>  On peut voir qu'un sujet peut avoir plusieurs abonnés. <br><br>  Cela semble facile, mais on ne sait pas encore pourquoi cela est nécessaire.  Je donnerai 2 définitions supplémentaires que vous devez connaître lorsque vous travaillez avec des flux réactifs, puis je montrerai en pratique comment ils fonctionnent et dans quelles situations leur plein potentiel est révélé. <br><br><h4>  Observables à froid </h4><br><ul><li>  Avertissez des événements lorsque quelqu'un s'y abonne. </li><li>  L'ensemble du flux de données est envoyé à nouveau à chaque abonné, quel que soit le moment de l'abonnement. </li><li>  Les données sont copiées pour chaque abonné. </li></ul><br>  Qu'est-ce que cela signifie: disons que l'entreprise (Sujet) a décidé d'organiser la distribution de cadeaux.  Chaque employé (Observateur) vient travailler et reçoit sa copie du cadeau.  Personne ne reste privé. <br><br><h4>  Observables chauds </h4><br><ul><li>  Ils essaient de notifier l'événement indépendamment de la présence d'abonnés.  Si au moment de l'événement il n'y avait pas d'abonnés, les données sont perdues. </li></ul><br>  Exemple: le matin, des petits pains chauds pour les employés sont apportés à l'entreprise.  Lorsqu'elles sont introduites, toutes les alouettes volent à l'odeur et distinguent les tartes pour le petit déjeuner.  Mais les hiboux qui sont venus plus tard n’ont plus de tartes. <br><br><h4>  Dans quelles situations les jet streams sont-ils utilisés? </h4><br>  Lorsqu'il existe un flux de données réparti dans le temps.  Par exemple, entrée utilisateur.  Ou les journaux de n'importe quel service.  Dans l'un des projets, j'ai vu un enregistreur self-made qui collectait les événements en N secondes, puis enregistrait simultanément l'ensemble du pack.  Le code de la batterie occupait la page.  Si des flux Rx étaient utilisés, ce serait beaucoup plus simple: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6e/b1a/396/b6eb1a3960bd8b422c01b6c0a5dd97f0.png" alt="image"><br>  <i>« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RxJs Reference / Observable</a> , documentation sous licence CC BY 4.0</i> . <br>  <i>(il existe de nombreux exemples et images expliquant ce que font différentes opérations avec des flux réactifs)</i> <br><br><pre> <code class="javascript hljs">source.bufferTime(<span class="hljs-number"><span class="hljs-number">2000</span></span>).subsribe(doThings);</code> </pre> <br>  Et enfin, un exemple d'utilisation. <br><br><h2>  Reconnaître les gestes de la souris avec les flux Rx </h2><br>  Dans l'ancien Opéra ou son successeur spirituel - Vivaldi - il y avait un contrôle de navigateur utilisant des gestes de souris. <br><br><div class="spoiler">  <b class="spoiler_title">Gif - gestes de la souris dans Vivaldi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/xs/ok/eq/xsokeqelkjbtvgrcurbv-wffmog.gif"><br></div></div><br>  Autrement dit, vous devez reconnaître les mouvements de la souris vers le haut / le bas, la droite / la gauche et leurs combinaisons.  Il peut être écrit sans flux Rx, mais le code sera complexe et difficile à maintenir. <br><br><h4>  Et voici à quoi cela ressemble avec les flux Rx: </h4><br>  Je vais commencer par la fin - je vais définir quelles données et dans quel format je vais rechercher dans la séquence d'origine: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//gestures to look for const gestures = Rx.Observable.from([ { name: "Left", sequence: Rx.Observable.from([{ x: -1, y: 0 }]) }, { name: "Right", sequence: Rx.Observable.from([{ x: 1, y: 0 }]) }, { name: "Up", sequence: Rx.Observable.from([{ x: 0, y: -1 }]) }, { name: "Down", sequence: Rx.Observable.from([{ x: 0, y: 1 }]) }, { name: "Down+Up", sequence: Rx.Observable.from([{ x: 0, y: 1 }, { x: 0, y: -1 }]) }, { name: "Up+Right", sequence: Rx.Observable.from([{ x: 0, y: -1 }, { x: 1, y: 0 }]) } ]);</span></span></code> </pre> <br>  Ce sont des vecteurs unitaires et leurs combinaisons. <br><br>  Ensuite, vous devez convertir les événements de souris en flux Rx.  Toutes les bibliothèques Rx ont des outils intégrés pour transformer des événements standard en observables. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseMoves = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>), mouseDowns = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mousedown'</span></span>), mouseUps = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mouseup'</span></span>);</code> </pre> <br>  Ensuite, je regroupe les coordonnées de la souris par 2 et trouve leur différence, obtenant le décalage de la souris. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseDiffs = mouseMoves .map(getOffset) .pairwise() .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pair</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>].x-pair[<span class="hljs-number"><span class="hljs-number">0</span></span>].x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>].y-pair[<span class="hljs-number"><span class="hljs-number">0</span></span>].y } });</code> </pre> <br>  Et regroupez ces mouvements en utilisant les événements «mousedown» et «mouseup». <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseGestures = mouseDiffs .bufferToggle(mouseDowns, x =&gt; mouseUps) .map(concat);</code> </pre> <br>  La fonction concat supprime les mouvements trop courts et regroupe les mouvements à peu près alignés en direction. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-comment"><span class="hljs-comment">//summarize move in same direction return values.reduce((a, v) =&gt; { if (!a.length) { a.push(v); } else { const last = a[a.length - 1]; const lastAngle = Math.atan2(last.x, last.y); const angle = Math.atan2(vx, vy); const angleDiff = normalizeAngle(angle - lastAngle); const dist = Math.hypot(vx, vy); if (dist &lt; 1) return a;//move is too short – ignore //moving in same direction =&gt; adding vectors if (Math.abs(angleDiff) &lt;= maxAngleDiff) { last.x += vx; last.y += vy; } else { a.push(v); } } return a; }, []); }</span></span></code> </pre> <br>  Si le mouvement sur l'axe X ou Y est trop court, il est remis à zéro.  Et puis seul le signe reste des coordonnées de déplacement obtenues.  Ainsi, les vecteurs unitaires que nous recherchions sont obtenus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> normalizedMouseGestures = mouseGestures.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function"> =&gt;</span></span> arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dist = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.hypot(vx, vy);<span class="hljs-comment"><span class="hljs-comment">//length of vector vx = Math.abs(vx) &gt; minMove &amp;&amp; Math.abs(vx) * treshold &gt; dist ? vx : 0; vy = Math.abs(vy) &gt; minMove &amp;&amp; Math.abs(vy) * treshold &gt; dist ? vy : 0; return v; }) ).map(arr =&gt; arr .map(v =&gt; { return { x: Math.sign(vx), y: Math.sign(vy) }; }) .filter(v =&gt; Math.hypot(vx, vy) &gt; 0) );</span></span></code> </pre> <br>  Résultat: <br><br><pre> <code class="javascript hljs">gestures.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gesture</span></span></span><span class="hljs-function"> =&gt;</span></span> normalizedMouseGestures.mergeMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moves</span></span></span><span class="hljs-function"> =&gt;</span></span> Rx.Observable.from(moves) .sequenceEqual(gesture.sequence, comparer) ).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x).mapTo(gesture.name) ).mergeAll().subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gestureName</span></span></span><span class="hljs-function"> =&gt;</span></span> actions[gestureName]());</code> </pre> <br>  En utilisant sequenceEqual, vous pouvez comparer les mouvements reçus avec ceux d'origine et, s'il y a une correspondance, effectuer une certaine action. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lp/bx/fe/lpbxfeq_bq-mdfybskn0v7wwen8.gif"><br></div></div><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous pouvez jouer avec des gestes ici</a> <br><br>  Veuillez noter qu'en plus de la reconnaissance des gestes, il existe également un dessin des mouvements initiaux et normalisés de la souris sur le canevas HTML.  La lisibilité du code n'en souffre pas. <br><br>  D'où un avantage supplémentaire: les fonctionnalités écrites à l'aide de flux Rx peuvent être facilement complétées et étendues. <br><br><h2>  Résumé </h2><br><ul><li>  Les bibliothèques avec des flux Rx sont disponibles pour presque tous les langages de programmation. </li><li>  Les flux Rx doivent être utilisés lorsqu'il existe un flux d'événements étalés dans le temps (par exemple, entrée utilisateur). </li><li>  Les fonctionnalités écrites à l'aide de flux Rx peuvent être facilement complétées et étendues. </li><li>  Je n'ai trouvé aucun défaut significatif. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Liens utiles</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.introtorx.com</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">getakka.net/articles/intro/what-is-akka.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reactivex.io/rxjs/class/es6/Observable.js~Observable.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reactivex.io/languages.html</a> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432004/">https://habr.com/ru/post/fr432004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431992/index.html">Biométrie: comment ça se passe avec nous et avec eux</a></li>
<li><a href="../fr431994/index.html">Discussion sur la licence PVS-Studio gratuite pour les projets hébergés sur GitHub</a></li>
<li><a href="../fr431996/index.html">Smart Engines Science Corporate (ou comment nous avons conduit à ICMV 2018)</a></li>
<li><a href="../fr431998/index.html">Rencontrez Yandex.Phone - maintenant officiellement</a></li>
<li><a href="../fr432002/index.html">Microsoft développe un navigateur basé sur Chromium, qui sera livré par défaut à la place d'Edge</a></li>
<li><a href="../fr432006/index.html">L'histoire de comment je suis entré dans le sujet de la santé des femmes</a></li>
<li><a href="../fr432008/index.html">Chasing Web Standards</a></li>
<li><a href="../fr432012/index.html">Comment tester les contrats intelligents</a></li>
<li><a href="../fr432014/index.html">Kali Linux pour les débutants</a></li>
<li><a href="../fr432016/index.html">Comment la musique et le dessin m'ont appris à programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>