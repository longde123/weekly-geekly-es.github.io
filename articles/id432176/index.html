<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐭 🏄 🗑️ Bagaimana kami menggandakan kecepatan bekerja dengan Float di Mono 🧤 📂 💑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teman saya Aras baru-baru ini menulis pelacak sinar yang sama dalam berbagai bahasa, termasuk C ++, C #, dan kompiler Unity Burst. Tentu saja, wajar j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menggandakan kecepatan bekerja dengan Float di Mono</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432176/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/c69/c73/49ac69c73ac3a6c124f04b468dfb90d5.png"></div><br>  Teman saya Aras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baru-baru ini menulis</a> pelacak sinar yang sama dalam berbagai bahasa, termasuk C ++, C #, dan kompiler Unity Burst.  Tentu saja, wajar jika mengharapkan bahwa C # akan lebih lambat daripada C ++, tetapi tampaknya menarik bagi saya bahwa Mono lebih lambat dari .NET Core. <br><br>  <a href="">Indikator yang</a> dipublikasikannya buruk: <br><br><ul><li>  C # (.NET Core): Mac 17.5 Mray / s, </li><li>  C # (Unity, Mono): Mac 4.6 Mray / s, </li><li>  C # (Unity, IL2CPP): Mac 17.1 Mray / s </li></ul><br>  Saya memutuskan untuk melihat apa yang terjadi dan mendokumentasikan tempat-tempat yang dapat ditingkatkan. <br><br>  Sebagai hasil dari tolok ukur ini dan mempelajari masalah ini, kami menemukan tiga bidang yang memungkinkan peningkatan: <br><br><ul><li>  Pertama, Anda perlu meningkatkan pengaturan Mono default, karena pengguna biasanya tidak mengonfigurasi pengaturan mereka </li><li>  Kedua, kita perlu secara aktif memperkenalkan dunia kepada backend optimasi kode LLVM di Mono </li><li>  Ketiga, kami meningkatkan penyetelan beberapa parameter Mono. </li></ul><br>  Titik referensi dari tes ini adalah hasil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelacak ray yang</a> dijalankan pada mesin saya, dan karena saya memiliki perangkat keras yang berbeda, kami tidak dapat membandingkan jumlahnya. <br><br>  Hasil di rumah saya iMac untuk Mono dan .NET Core adalah sebagai berikut: <br><br><table><thead><tr><th>  Lingkungan kerja </th><th>  Hasil, MRay / dtk </th></tr></thead><tbody><tr><td> .NET Core 2.1.4, build build <code>dotnet run</code> debug </td><td>  3.6 </td></tr><tr><td>  .NET Core 2.1.4 rilis build <code>dotnet run -c Release</code> </td><td>  21.7 </td></tr><tr><td>  Vanilla Mono, <code>mono Maths.exe</code> </td><td>  6.6 </td></tr><tr><td>  Vanilla Mono dengan LLVM dan float32 </td><td>  15.5 </td></tr></tbody></table><a name="habracut"></a><br>  Dalam proses mempelajari masalah ini, kami menemukan beberapa masalah, setelah koreksi di mana hasil berikut diperoleh: <br><br><table><thead><tr><th>  Lingkungan kerja </th><th>  Hasil, MRay / dtk </th></tr></thead><tbody><tr><td>  Mono dengan LLVM dan float32 </td><td>  15.5 </td></tr><tr><td>  Advanced Mono dengan LLVM, float32, dan fixed inline </td><td>  29.6 </td></tr></tbody></table><br>  Gambaran besar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/407/ecf/385/407ecf385de6261087b4395928076e02.png"></div><br>  Hanya dengan menerapkan LLVM dan float32, Anda dapat meningkatkan kinerja kode floating point hampir 2,3 kali.  Dan setelah penyetelan, yang kami tambahkan ke Mono sebagai hasil dari percobaan ini, Anda dapat meningkatkan produktivitas sebesar 4,4 kali dibandingkan dengan Mono standar - parameter ini dalam versi Mono yang akan datang akan menjadi parameter default. <br><br>  Pada artikel ini saya akan menjelaskan temuan kami. <br><br><h2>  Float 32-bit dan 64-bit </h2><br>  Aras menggunakan angka floating-point 32-bit untuk bagian utama perhitungan (ketik <code>float</code> di C # atau <code>System.Single</code> in .NET).  Di Mono, kami membuat kesalahan sejak lama - semua perhitungan floating point 32-bit dilakukan sebagai 64-bit, dan data masih disimpan di area 32-bit. <br><br>  Hari ini, ingatan saya tidak setajam sebelumnya, dan saya tidak ingat persis mengapa kami membuat keputusan seperti itu. <br><br>  Saya hanya dapat berasumsi bahwa itu dipengaruhi oleh tren dan ide saat itu. <br><br>  Kemudian aura positif melayang di sekitar komputasi float dengan peningkatan akurasi.  Sebagai contoh, prosesor Intel x87 menggunakan presisi 80-bit untuk perhitungan floating point, bahkan ketika operan ganda, yang memberikan pengguna dengan hasil yang lebih akurat. <br><br>  Pada saat itu, gagasan itu juga relevan bahwa di salah satu proyek saya sebelumnya - spreadsheet Gnumerik - fungsi statistik diimplementasikan lebih efisien daripada di Excel.  Oleh karena itu, banyak komunitas sangat menyadari gagasan bahwa hasil yang lebih akurat dengan peningkatan akurasi dapat digunakan. <br><br>  Pada tahap awal pengembangan Mono, sebagian besar operasi matematika yang dilakukan pada semua platform hanya dapat menerima dua kali lipat pada input.  Versi 32-bit ditambahkan ke C99, Posix dan ISO, tetapi pada masa itu tidak tersedia secara luas untuk seluruh industri (misalnya, <code>sinf</code> adalah versi float dari <code>sin</code> , <code>fabsf</code> adalah versi <code>fabs</code> , dan sebagainya). <br><br>  Singkatnya, awal 2000-an adalah masa optimisme. <br><br>  Aplikasi membayar mahal untuk meningkatkan waktu komputasi, tetapi Mono terutama digunakan untuk aplikasi Linux desktop yang melayani halaman HTTP dan beberapa proses server, jadi kecepatan floating-point bukanlah masalah yang kami temui setiap hari.  Itu menjadi nyata hanya di beberapa tolok ukur ilmiah, dan pada tahun 2003 mereka jarang dikembangkan di .NET. <br><br>  Saat ini, game, aplikasi 3D, pemrosesan gambar, VR, AR, dan pembelajaran mesin telah menjadikan operasi floating point sebagai tipe data yang lebih umum.  Masalahnya tidak datang sendiri, dan tidak ada pengecualian.  Float bukan lagi tipe data ramah yang digunakan dalam kode hanya di beberapa tempat.  Mereka berubah menjadi longsoran salju, dari mana tidak ada tempat untuk bersembunyi.  Ada banyak dari mereka dan penyebarannya tidak dapat dihentikan. <br><br><h2>  Bendera ruang kerja float32 </h2><br>  Oleh karena itu, beberapa tahun yang lalu kami memutuskan untuk menambahkan dukungan untuk melakukan operasi float 32-bit menggunakan operasi 32-bit, seperti dalam semua kasus lainnya.  Kami menyebut fitur ruang kerja ini "float32".  Di Mono, ini diaktifkan dengan menambahkan opsi <code>--O=float32</code> di lingkungan kerja, dan dalam aplikasi Xamarin, parameter ini diubah dalam pengaturan proyek. <br><br>  Bendera baru ini diterima dengan baik oleh pengguna seluler kami, karena pada dasarnya perangkat seluler masih belum terlalu kuat, dan mereka lebih baik memproses data lebih cepat daripada meningkatkan akurasi.  Kami menyarankan agar pengguna seluler mengaktifkan compiler optimalisasi LLVM dan bendera float32 secara bersamaan. <br><br>  Meskipun bendera ini telah diterapkan selama beberapa tahun, kami tidak menjadikannya bawaan untuk menghindari kejutan yang tidak menyenangkan bagi pengguna.  Namun, kami mulai menghadapi kasus-kasus di mana kejutan muncul karena perilaku 64-bit standar, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan bug</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diajukan oleh pengguna Unity</a> . <br><br>  Sekarang kita akan menggunakan Mono <code>float32</code> , kemajuan dapat dilacak di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/mono/mono/issues/6985</a> . <br><br>  Sementara itu, saya kembali ke proyek teman saya Aras.  Dia menggunakan API baru yang ditambahkan ke .NET Core.  Meskipun .NET Core selalu melakukan operasi float 32-bit sebagai float 32-bit, API <code>System.Math</code> masih melakukan konversi dari <code>float</code> menjadi <code>double</code> dalam proses.  Misalnya, jika Anda perlu menghitung fungsi sinus untuk nilai float, maka satu-satunya pilihan adalah memanggil <code>Math.Sin (double)</code> , dan Anda harus mengonversi dari float ke double. <br><br>  Untuk memperbaikinya, tipe baru <code>System.MathF</code> ditambahkan ke .NET Core, yang berisi operasi matematika floating-point presisi tunggal, dan sekarang kami hanya mem-porting <code>[System.MathF]</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ke Mono</a> . <br><br>  Transisi dari float 64-bit ke 32-bit secara signifikan meningkatkan kinerja, yang dapat dilihat dari tabel ini: <br><br><table><thead><tr><th>  <strong>Lingkungan kerja dan opsi</strong> </th><th>  Tuan / detik </th></tr></thead><tbody><tr><td>  Mono dengan System.Math </td><td>  6.6 </td></tr><tr><td>  Mono dengan System.Math dan <code>-O=float32</code> </td><td>  8.1 </td></tr><tr><td>  Mono dengan System.MathF </td><td>  6.5 </td></tr><tr><td>  Mono dengan System.MathF dan <code>-O=float32</code> </td><td>  8.2 </td></tr></tbody></table><br>  Artinya, menggunakan <code>float32</code> dalam tes ini benar-benar meningkatkan kinerja, dan MathF tidak banyak berpengaruh. <br><br><h1>  Pengaturan LLVM </h1><br>  Dalam proses penelitian ini, kami menemukan bahwa meskipun kompiler Fast JIT Mono memiliki dukungan <code>float32</code> , kami tidak menambahkan dukungan ini ke backend LLVM.  Ini berarti bahwa Mono dengan LLVM masih melakukan konversi mahal dari float menjadi double. <br><br>  Oleh karena itu, Zoltan menambahkan dukungan <code>float32</code> ke mesin pembuatan kode LLVM. <br><br>  Kemudian ia memperhatikan bahwa inliner kami menggunakan heuristik yang sama untuk Fast JIT seperti yang digunakan untuk LLVM.  Ketika bekerja dengan Fast JIT, perlu untuk menyeimbangkan antara kecepatan JIT dan kecepatan eksekusi, oleh karena itu kami membatasi jumlah kode tertanam untuk mengurangi jumlah pekerjaan mesin JIT. <br><br>  Tetapi jika Anda memutuskan untuk menggunakan LLVM di Mono, maka Anda berusaha untuk kode secepat mungkin, jadi kami mengubah pengaturannya.  Hari ini, parameter ini dapat diubah menggunakan <code>MONO_INLINELIMIT</code> lingkungan <code>MONO_INLINELIMIT</code> , tetapi sebenarnya perlu ditulis dengan nilai default. <br><br>  Berikut adalah hasil dengan pengaturan LLVM yang dimodifikasi: <br><br><table><thead><tr><th>  Lingkungan kerja dan opsi </th><th>  Tuan / detik </th></tr></thead><tbody><tr><td>  Mono dengan System.Math <code>--llvm -O=float32</code> </td><td>  16.0 </td></tr><tr><td>  Mono dengan System.Math <code>--llvm -O=float32</code> , heuristik konstan </td><td>  29.1 </td></tr><tr><td>  Mono dengan System.MathF <code>--llvm -O=float32</code> , heuristik konstan </td><td>  29.6 </td></tr></tbody></table><br><h1>  Langkah selanjutnya </h1><br>  Dibutuhkan sedikit upaya untuk melakukan semua perbaikan ini.  Perubahan ini dipimpin oleh diskusi berkala di Slack.  Saya bahkan berhasil membuat beberapa jam suatu malam ke port <code>System.MathF</code> ke Mono. <br><br>  Kode pelacak sinar Aras telah menjadi subjek yang ideal untuk dipelajari karena mandiri, merupakan aplikasi nyata, dan bukan tolok ukur sintetis.  Kami ingin menemukan perangkat lunak serupa lainnya yang dapat digunakan untuk mempelajari kode biner yang kami hasilkan, dan memastikan bahwa kami memberikan LLVM data terbaik untuk pelaksanaan pekerjaannya yang optimal. <br><br>  Kami juga mempertimbangkan untuk memperbarui LLVM kami, dan menggunakan optimasi tambahan yang baru. <br><br><h1>  Catatan terpisah </h1><br>  Ketelitian ekstra memiliki efek samping yang bagus.  Sebagai contoh, membaca permintaan kumpulan mesin Godot, saya melihat bahwa ada diskusi aktif tentang apakah membuat akurasi operasi floating point disesuaikan pada waktu kompilasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/godotengine/godot/pull/17134</a> ). <br><br>  Saya bertanya kepada Juan mengapa ini mungkin perlu bagi seseorang, karena saya percaya bahwa operasi floating-point 32-bit cukup untuk permainan. <br><br>  Juan menjelaskan bahwa dalam kasus umum, mengapung berfungsi dengan baik, tetapi jika Anda "menjauh" dari pusat, katakanlah, pindah 100 kilometer dari pusat permainan, kesalahan perhitungan mulai menumpuk, yang dapat menyebabkan gangguan grafis yang menarik.  Anda dapat menggunakan strategi berbeda untuk mengurangi dampak masalah ini, dan salah satunya adalah bekerja dengan akurasi yang lebih tinggi, yang harus Anda bayar kinerjanya. <br><br>  Tak lama setelah percakapan kami di feed Twitter saya, saya melihat sebuah pos yang menunjukkan masalah ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://pharr.org/matt/blog/2018/03/02/rendering-in-camera-space.html</a> <br><br>  <em>Masalahnya ditunjukkan pada gambar di bawah ini.</em>  <em>Di sini kita melihat model mobil sport dari paket</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>pbrt-v3-scenes</em></a> ** <em>.</em>  <em>Baik kamera dan pemandangannya dekat asal, dan semuanya tampak hebat.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f1/702/725/4f1702725634faa3ba94aa930230fb6d.png"></div><br>  ** <em>(Penulis</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Yasutoshi Mori</em></a> <em>.)</em> <br><br>  Kemudian kami memindahkan kamera dan tempat kejadian 200.000 unit di xx, yy dan zz dari asal.  Dapat dilihat bahwa model mesin telah menjadi sangat terfragmentasi;  ini semata-mata karena kurangnya presisi dalam angka floating point. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/4b0/658/8424b065878f52bcd83b5d2de19321e5.png"></div><br>  <em>Jika kita bergerak lebih jauh 5x5x5 kali, 1 juta unit dari asalnya, modelnya mulai hancur;</em>  <em>mesin berubah menjadi perkiraan voxel yang sangat kasar, menarik dan menakutkan.</em>  <em>(Keanu mengajukan pertanyaan: Apakah Minecraft begitu kubik hanya karena semuanya dirender sangat jauh dari asalnya?)</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/c69/c73/49ac69c73ac3a6c124f04b468dfb90d5.png"></div><br>  ** <em>(Saya minta maaf kepada</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Yasutoshi Mori</em></a> <em>atas apa yang kami lakukan dengan model cantiknya.)</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432176/">https://habr.com/ru/post/id432176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432166/index.html">Apache NiFi: apa itu dan gambaran umum singkat fitur-fiturnya</a></li>
<li><a href="../id432168/index.html">Otoritas Tiongkok mengumpulkan informasi dari kendaraan listrik warga negara</a></li>
<li><a href="../id432170/index.html">Transport pusat data dalam 14.400 detik</a></li>
<li><a href="../id432172/index.html">Undangan berbahaya, atau Cara pertempuran memuat untuk email phishing</a></li>
<li><a href="../id432174/index.html">Bagaimana mengembangkan produk perangkat lunak secara kompeten dan efektif</a></li>
<li><a href="../id432178/index.html">... dan jaminan untuk proyektor - meningkat</a></li>
<li><a href="../id432180/index.html">Cara memompa karir Anda melalui GitHub</a></li>
<li><a href="../id432182/index.html">Kami mengambil surat tanpa sms dan registrasi</a></li>
<li><a href="../id432184/index.html">Identitas Masalah Di Antara Penguji</a></li>
<li><a href="../id432186/index.html">Menggunakan STP untuk membuat saluran p2p</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>