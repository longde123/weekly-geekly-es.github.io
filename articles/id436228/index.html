<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😲 👩‍👧‍👧 💃 Pengembangan perintah untuk meminta data dari database 🚹 🧗🏼 🤲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini saya terlibat dalam implementasi interaksi dengan penyedia layanan KYC. Seperti biasa, tidak ada yang kosmik. Anda hanya perlu memilih satu s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan perintah untuk meminta data dari database</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436228/"><p>  Saat ini saya terlibat dalam implementasi interaksi dengan penyedia layanan KYC.  Seperti biasa, tidak ada yang kosmik.  Anda hanya perlu memilih satu set salinan dari berbagai catatan dari basis data Anda, mengunggahnya ke penyedia layanan dan meminta penyedia rekaman untuk memeriksanya. </p><br><p> Tahap awal pemrosesan berisi selusin operasi yang identik dengan mengirim permintaan untuk mengambil data dari pengguna tertentu dari berbagai tabel database.  Ada asumsi bahwa dalam kasus ini sebagian besar kode dapat digunakan kembali sebagai abstraksi <code>Request</code> .  Saya akan mencoba menyarankan bagaimana ini bisa digunakan.  Saya akan menulis tes pertama: </p><a name="habracut"></a><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'Request'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Request = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./Request'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'execute should return promise'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(); request.execute().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result).toBeNull(); }); }); });</code> </pre> <br><p>  Terlihat bagus?  Mungkin tidak sempurna, tetapi pada pandangan pertama sepertinya <code>Request</code> pada dasarnya adalah <code></code> yang mengembalikan <code>Promise</code> dengan hasilnya?  Dari sini, sangat mungkin untuk memulai.  Saya akan membuat sketsa kode sehingga tes dapat dijalankan. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){} execute(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = Request;</code> </pre> <br><p>  Saya menjalankan <code>npm test</code> dan mengamati titik hijau dari tes yang selesai di konsol. </p><br><p>  Jadi  Saya punya permintaan, dan itu bisa dieksekusi.  Pada kenyataannya, bagaimanapun, saya akan perlu untuk entah bagaimana menginformasikan permintaan saya tentang di meja mana dia harus mencari data yang diperlukan dan kriteria apa yang harus dipenuhi oleh data ini.  Saya akan mencoba menulis tes baru: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should configure request'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }; request.configure(options); expect(request.options).toEqual(options); });</code> </pre> <br><p>  Ok  Menurut saya, cukup.  Karena saya sudah memiliki dua tes yang menggunakan turunan dari variabel <code>request</code> , saya akan menginisialisasi variabel ini dalam metode khusus yang berjalan sebelum setiap tes berjalan.  Dengan demikian, dalam setiap pengujian, saya akan memiliki contoh baru dari objek permintaan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(); });</code> </pre> <br><p>  Saya menerapkan fungsi ini di kelas permintaan, menambahkan metode untuk itu yang menyimpan pengaturan dalam variabel instance kelas, seperti yang ditunjukkan oleh tes. </p><br><pre> <code class="javascript hljs">configure(options){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options = options; }</code> </pre> <br><p>  Saya menjalankan tes dan sekarang saya melihat dua titik hijau.  Dua dari tes saya berhasil diselesaikan.  Namun demikian.  Diasumsikan, bagaimanapun, bahwa pertanyaan saya akan ditujukan ke database.  Sekarang mungkin layak untuk mencoba melihat sisi mana permintaan akan menerima informasi tentang basis data.  Saya akan kembali ke tes dan menulis beberapa kode: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DbMock = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./DbMock'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMock(); request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(db); });</code> </pre> <br><p>  Sepertinya saya bahwa versi klasik inisialisasi melalui konstruktor sepenuhnya memenuhi persyaratan saya saat ini. </p><br><p>  Secara alami, saya tidak akan menggunakan unit test untuk menggunakan antarmuka ke database MySQL nyata yang digunakan proyek kami.  Mengapa  Karena: </p><br><ol><li>  Jika, alih-alih saya, salah satu kolega saya perlu mengerjakan bagian proyek ini dan melakukan tes unit, maka sebelum mereka dapat melakukan apa pun, mereka harus menghabiskan waktu dan upaya untuk menginstal dan mengatur instance mereka sendiri dari server MySQL. </li><li>  Keberhasilan unit test akan tergantung pada kebenaran pengisian data awal yang digunakan oleh database server MySQL. </li><li>  Waktu untuk menjalankan tes menggunakan database MySQL akan jauh lebih lama. </li></ol><br><p>  Baiklah  Dan mengapa, misalnya, tidak menggunakan basis data dalam memori dalam pengujian unit?  Ini akan bekerja dengan cepat, dan proses konfigurasi dan inisialisasi dapat otomatis.  Itu semua benar, tetapi saat ini saya tidak melihat keuntungan dari menggunakan alat tambahan ini.  Tampaknya bagi saya bahwa kebutuhan saya saat ini lebih cepat dan lebih murah (tidak perlu menghabiskan waktu belajar) menggunakan kelas dan metode <code></code> dan <code></code> -objects, yang hanya akan mensimulasikan perilaku antarmuka yang seharusnya digunakan dalam kondisi pertempuran. </p><br><p>  Ngomong-ngomong.  Dalam pertarungan, saya sarankan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rak buku</a> bersama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">knex</a> .  Mengapa  Karena mengikuti dokumentasi tentang penginstalan, konfigurasi, dan menggunakan dua alat ini, saya berhasil membuat dan menjalankan kueri ke database dalam beberapa menit. </p><br><p>  Apa yang mengikuti dari ini?  Dari sini saya harus memodifikasi kode kelas <code>Request</code> sehingga eksekusi permintaan cocok dengan antarmuka yang diekspor oleh alat tempur saya.  Jadi sekarang kodenya akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(db){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db = db; } configure(options){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options = options; } execute(){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.tableName }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> table.where(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.options.query).fetch(); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = Request;</code> </pre> <br><p>  Saya akan menjalankan tes dan melihat apa yang terjadi.  Ya  <code>DbMock</code> saja, saya tidak memiliki modul <code>DbMock</code> , jadi hal pertama yang saya lakukan adalah mengimplementasikan rintisan untuk itu: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){} } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = DbMock;</code> </pre> <br><p>  Saya akan menjalankan tes lagi.  Apa sekarang?  Princess <code>Jasmine</code> memberi tahu saya bahwa <code>DbMock</code> saya tidak mengimplementasikan properti <code>Model</code> .  Saya akan mencoba membuat sesuatu: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Model = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} }; } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = DbMock;</code> </pre> <br><p>  Menjalankan tes lagi.  Sekarang kesalahannya adalah bahwa dalam pengujian unit saya, saya menjalankan kueri tanpa terlebih dahulu mengatur parameternya menggunakan metode <code>configure</code> .  Saya memperbaiki ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }; it(<span class="hljs-string"><span class="hljs-string">'execute should return promise'</span></span>, () =&gt; { request.configure(options); request.execute().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result).toBeNull(); }); });</code> </pre> <br><p>  Karena saya sudah menggunakan contoh variabel <code>options</code> dalam dua tes, saya memasukkannya ke dalam kode inisialisasi seluruh test suite dan menjalankan tes lagi. </p><br><p>  Seperti yang diharapkan, metode <code>DbMock</code> , properti <code>Model</code> , dari kelas <code>DbMock</code> mengembalikan kita <code>undefined</code> , jadi tentu saja permintaan kami tidak memiliki cara untuk memanggil metode <code>where</code> . </p><br><p>  Saya sudah mengerti bahwa properti <code>Model</code> dari kelas <code>DbMock</code> harus diimplementasikan di luar kelas <code>DbMock</code> .  Pertama-tama, karena fakta bahwa implementasi <code></code> diperlukan untuk menjalankan tes yang ada, itu akan memerlukan terlalu banyak ruang bersarang ketika menginisialisasi properti <code>Model</code> langsung di kelas <code>DbMock</code> .  Akan sangat mustahil untuk membaca dan memahami ... Dan ini, bagaimanapun, tidak akan menghentikan saya dari upaya seperti itu, karena saya ingin memastikan bahwa saya masih memiliki kesempatan untuk menulis hanya beberapa baris kode dan membuat tes berjalan dengan sukses. </p><br><p>  Jadi  Tarik napas, hembuskan, jantung yang samar meninggalkan ruangan.  Melengkapi implementasi konstruktor <code>DbMock</code> .  Ta-daaaammmmm .... </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Model = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">where</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">fetch</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); } }; } }; } }; } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = DbMock;</code> </pre> <br><p>  Timah!  Namun, dengan tangan yang kuat, jalankan tes dan pastikan bahwa <code>Jasmine</code> lagi menunjukkan kepada kita titik-titik hijau.  Dan itu berarti kita masih di jalur yang benar, meskipun ada sesuatu yang membengkak dengan tidak tepat. </p><br><p>  Apa selanjutnya  Dapat dilihat dengan mata telanjang bahwa properti <code>Model</code> pseudo-database harus diimplementasikan sebagai sesuatu yang benar-benar terpisah.  Meskipun begitu saja tidak jelas bagaimana itu harus dilaksanakan. </p><br><p>  Tapi saya tahu pasti bahwa saya akan menyimpan catatan dalam pseudo-database ini sekarang di array yang paling umum.  Dan karena untuk tes yang ada saya hanya perlu mensimulasikan tabel <code>users</code> , untuk permulaan saya akan mengimplementasikan array pengguna, dengan satu catatan.  Tapi pertama-tama, saya akan menulis tes: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'Users'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./Users'</span></span>); it(<span class="hljs-string"><span class="hljs-string">'should contain one user'</span></span>, () =&gt; { expect(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(users)).toBeTruthy(); expect(users.length).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = users[<span class="hljs-number"><span class="hljs-number">0</span></span>]; expect(user.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(user.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Saya menjalankan tes.  Saya memastikan bahwa mereka tidak lulus, dan saya menerapkan wadah sederhana saya dengan pengguna: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Users = [ { <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">Name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span> } ]; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = Users;</code> </pre> <br><p>  Sekarang tes sedang dieksekusi, dan terpikir oleh saya bahwa secara semantik <code>Model</code> , dalam paket <code>bookshell</code> , adalah penyedia antarmuka untuk mengakses isi tabel dalam database.  Tidak sia-sia kita melewatkan objek dengan nama tabel ke metode <code>extend</code> .  Kenapa disebut <code>extend</code> , dan bukan misalnya <code>get</code> , saya tidak tahu.  Mungkin ini hanya kurangnya pengetahuan tentang API <code>bookshell</code> . </p><br><p>  Ya Tuhan memberkati dia, untuk saat ini saya punya ide di kepala saya pada topik tes berikut: </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'TableMock'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> container = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./Users'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Table = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMock'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Table(container); it(<span class="hljs-string"><span class="hljs-string">'should return first item'</span></span>, () =&gt; { users.fetch({ <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(item.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(item.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); }); });</code> </pre> <br><p>  Karena pada saat ini saya membutuhkan implementasi yang hanya mensimulasikan fungsi driver penyimpanan nyata, saya memberi nama kelas yang sesuai, menambahkan akhiran <code>Mock</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(container){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container = container; } fetch() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = TableMock;</code> </pre> <br><p>  Tetapi <code>fetch</code> bukan satu-satunya metode yang ingin saya gunakan dalam versi pertarungan, jadi saya menambahkan satu tes lagi: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'where-fetch chain should return first item'</span></span>, () =&gt; { users.where({ <span class="hljs-attr"><span class="hljs-attr">Id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).fetch().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">)=&gt;</span></span> { expect(item.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(item.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Peluncuran yang, seperti yang diharapkan, menampilkan pesan kesalahan kepada saya.  Jadi saya melengkapi implementasi <code>TableMock</code> dengan metode di <code>where</code> : </p><br><pre> <code class="javascript hljs">where(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Sekarang tes dilakukan dan Anda dapat beralih ke topik penerapan properti <code>Model</code> di kelas <code>DbMock</code> .  Seperti yang sudah saya sarankan, ini akan menjadi penyedia objek contoh jenis <code>TableMock</code> : </p><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'TableMockMap'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TableMock = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMock'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TableMockMap = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMockMap'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableMockMap(); it(<span class="hljs-string"><span class="hljs-string">'extend should return existent TableMock'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = map.extend({<span class="hljs-attr"><span class="hljs-attr">tableName</span></span>: <span class="hljs-string"><span class="hljs-string">'users'</span></span>}); expect(users <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> TableMock).toBeTruthy(); }); });</code> </pre> <br><p>  Kenapa <code>TableMockMap</code> , karena semantik ini dia.  Hanya alih-alih nama metode <code>get</code> , nama metode extended digunakan. </p><br><p>  Karena tes macet, kami membuat implementasi: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Users = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./Users'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TableMock = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMock'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableMockMap</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set(<span class="hljs-string"><span class="hljs-string">'users'</span></span>, Users); } extend(options){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.get(options.tableName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableMock(container); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = TableMockMap;</code> </pre> <br><p>  Jalankan tes dan lihat enam titik hijau di konsol.  Hidup itu indah. </p><br><p>  Tampaknya bagi saya sekarang bahwa Anda sudah dapat menyingkirkan <code> </code> inisialisasi yang <code> </code> di konstruktor kelas <code>DbMock</code> , menggunakan <code>TableMockMap</code> luar <code>TableMockMap</code> .  Kami tidak akan menundanya, terutama karena sudah baik untuk minum teh.  Implementasi baru ini sangat elegan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TableMockMap = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./TableMockMap'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableMockMap(); } } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = DbMock;</code> </pre> <br><p>  Jalankan tes ... dan oops!  Tes kami yang paling penting jatuh.  Tapi ini bahkan bagus, karena itu adalah rintisan pengujian dan sekarang kita hanya perlu memperbaikinya: </p><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'execute should return promise'</span></span>, () =&gt; { request.configure(options); request.execute().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result.Id).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>); expect(result.Name).toEqual(<span class="hljs-string"><span class="hljs-string">'Jack'</span></span>); }); });</code> </pre> <br><p>  Tes berhasil diselesaikan.  Dan sekarang Anda dapat beristirahat, dan kemudian kembali untuk menyelesaikan kode permintaan yang dihasilkan, karena masih sangat, sangat jauh dari sempurna, tetapi bahkan dari hanya antarmuka yang mudah digunakan, terlepas dari kenyataan bahwa data yang menggunakannya berasal dari basis sudah bisa diterima. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436228/">https://habr.com/ru/post/id436228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436216/index.html">Repositori Spring JPA di CUBA</a></li>
<li><a href="../id436218/index.html">Pemasaran Konten di Media Online Populer: 5 Kesalahan Startup yang Harus Dihindari</a></li>
<li><a href="../id436220/index.html">Cara penilaian bekerja di industri berbagi mobil. Bagian 2. Identifikasi driver yang agresif dalam 5 detik</a></li>
<li><a href="../id436224/index.html">Kami menulis bahasa pemrograman kami, bagian 4: Representasi struktur dan kelas, generasi pengalokasi</a></li>
<li><a href="../id436226/index.html">Panduan dan lembar contekan untuk Wireshark</a></li>
<li><a href="../id436230/index.html">Bagaimana mengendalikan infrastruktur jaringan Anda. Bab Tiga Keamanan jaringan. Bagian dua</a></li>
<li><a href="../id436232/index.html">Strategi Telepati</a></li>
<li><a href="../id436234/index.html">Parsers Aplikatif Haskell</a></li>
<li><a href="../id436236/index.html">Kami menggunakan ilmu data untuk menentukan siklus hidup klien</a></li>
<li><a href="../id436238/index.html">Otentikasi di Kubernetes dengan GitHub OAuth dan Dex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>