<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„äôÔ∏è üëî üë©üèΩ‚Äçüè≠ 63 c≈ìurs verrouill√©s par sept instructions üåæ üëåüèª üõµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je semble avoir l'habitude d'√©crire sur des machines puissantes , o√π de nombreux c≈ìurs sont inactifs en raison de verrous incorrects. Alors ... oui. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>63 c≈ìurs verrouill√©s par sept instructions</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472552/"> Je semble avoir l'habitude d'√©crire sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des machines puissantes</a> , o√π de nombreux c≈ìurs sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inactifs en</a> raison de verrous incorrects.  Alors ... oui.  Encore une fois √† ce sujet. <br><br>  Cette histoire est particuli√®rement impressionnante.  En fait, √† quelle fr√©quence avez-vous un spin de fil pendant quelques secondes dans un cycle de sept commandes, tenant un verrou qui arr√™te le travail de 63 autres processeurs?  C'est tout simplement incroyable, dans un sens terrible. <br><br>  Contrairement √† la croyance populaire, je n'ai en fait pas de machine avec 64 processeurs logiques et je n'ai jamais vu ce probl√®me particulier.  Mais mon ami est tomb√© dessus, <s><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce nerd m'a accroch√©,</a></s> il a demand√© de l'aide et j'ai d√©cid√© que le probl√®me √©tait assez int√©ressant.  Il a envoy√© une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trace ETW</a> avec suffisamment d'informations pour que l'esprit collectif sur Twitter ait rapidement r√©solu le probl√®me. <br><a name="habracut"></a><br>  La plainte de l'ami √©tait assez simple: il a r√©cup√©r√© la construction en utilisant un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ninja</a> .  En r√®gle g√©n√©rale, ninja fait un excellent travail en augmentant la charge, en prenant constamment en charge n + 2 processus pour √©viter les temps d'arr√™t.  Mais ici, l'utilisation du CPU dans les 17 premi√®res secondes de l'assemblage ressemblait √† ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/708/9d6/808/7089d68083b016688e6ec980981f52a4.png"><br><br>  Si vous regardez de plus pr√®s (une blague), vous pouvez voir une ligne mince o√π la charge totale du processeur passe de 100% √† 0% en quelques secondes.  En seulement une demi-seconde, la charge est r√©duite de 64 √† deux ou trois fils.  Voici un fragment agrandi de l'une de ces chutes - les secondes sont marqu√©es le long de l'axe horizontal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14a/f7a/6c3/14af7a6c3dbdb7563fa6e316ad7a21e2.png"><br><br>  La premi√®re pens√©e √©tait que le ninja ne peut pas cr√©er rapidement des processus.  Je l'ai vu plusieurs fois, g√©n√©ralement en raison de l'intervention d'un logiciel antivirus.  Mais quand j'ai tri√© les graphiques √† la fin, j'ai constat√© que lors de tels plantages, aucun processus n'√©tait termin√©, donc ninja n'est pas √† bl√¢mer. <br><br>  Le tableau d' <i>utilisation du processeur (pr√©cis)</i> est id√©al pour identifier la cause des temps d'arr√™t.  Les journaux de tous les changements de contexte y sont stock√©s, y compris des enregistrements pr√©cis de chaque d√©but de flux, y compris le lieu et le d√©lai d'expiration. <br><br>  L'astuce est qu'il n'y a rien de mal avec les temps d'arr√™t.  Le probl√®me se pose lorsque nous voulons vraiment que le thread fasse le travail, mais √† la place, il est inactif.  Par cons√©quent, vous devez s√©lectionner certains moments d'arr√™t. <br><br>  Lors de l'analyse, il est important de comprendre que le changement de contexte se produit lorsqu'un thread reprend l'op√©ration.  Si nous regardons ces endroits o√π la charge du processeur commence √† tomber, nous ne trouverons rien.  Au lieu de cela, concentrez-vous sur le moment o√π le syst√®me a recommenc√© √† fonctionner.  Cette phase de trace est encore plus dramatique.  Alors que la baisse de charge du processeur prend une demi-seconde, le processus inverse d'un thread utilis√© √† une charge compl√®te ne prend que douze millisecondes!  Le graphique ci-dessous est assez fortement agrandi, et pourtant la transition du ralenti au chargement est presque une ligne verticale: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/cd4/cc6/d7fcd4cc68e55c5d6c7ff16cc8a5b32d.png"><br><br>  J'ai zoom√© sur douze millisecondes et trouv√© 500 changements de contexte, une analyse minutieuse est requise ici. <br><br>  La table de changement de contexte a de nombreuses colonnes que j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">document√©es ici</a> .  Lorsqu'un processus se bloque, pour en trouver la raison, je fais un regroupement par nouveaux processus, nouveaux threads, nouvelles piles de threads, etc. ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discut√© ici</a> ), mais cela ne fonctionne pas sur des centaines de processus arr√™t√©s.  Si j'ai √©tudi√© un mauvais processus, il est clair qu'il a √©t√© pr√©par√© par le processus pr√©c√©dent, qui a √©t√© pr√©par√© par le pr√©c√©dent, et je balayerais une longue cha√Æne pour trouver le premier maillon qui (vraisemblablement) d√©tient un verrou important pendant longtemps. <br><br>  J'ai donc essay√© une disposition de colonne diff√©rente dans le programme: <br><br><ul><li>  <i>Heure d'entr√©e</i> (lorsque le changement de contexte s'est produit) <br></li><li>  <i>Processus de pr√©paration</i> (qui a lib√©r√© le verrou apr√®s avoir attendu) <br></li><li>  <i>Nouveau processus</i> (qui a commenc√© √† travailler) <br></li><li>  <i>Temps depuis la derni√®re</i> (depuis combien de temps le nouveau processus attend) </li></ul><br>  Cela donne une liste chronologique de changements de contexte avec une note de qui a pr√©par√© qui et combien de temps les processus √©taient pr√™ts √† fonctionner. <br><br>  Il s'est av√©r√© que cela suffisait.  Le tableau ci-dessous parle de lui-m√™me si vous savez le lire.  Les premiers changements de contexte ne sont pas int√©ressants, car le temps d'attente pour un nouveau processus (Time Since Last) est assez petit, mais sur la ligne en surbrillance (# 4) une chose int√©ressante commence: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d7/106/72f/0d710672f2cafc1bd7a2953a42ea55dd.png"><br><br>  Cette ligne indique que <i>System (4) a</i> pr√©par√© le <i>cl Exe (3032)</i> , qui a attendu 3,386 secondes.  La ligne suivante indique qu'en moins de 0,1 ms, <i>cl. Exe (3032) a</i> pr√©par√© <i>cl.exe (16232)</i> , qui a attendu 3,367 secondes.  Et ainsi de suite. <br><br>  Plusieurs commutateurs de contexte, comme dans la ligne # 7, ne sont pas inclus dans la cha√Æne d'attente, mais refl√®tent simplement d'autres travaux dans le syst√®me, mais en g√©n√©ral, la cha√Æne est √©tendue √† plusieurs dizaines d'√©l√©ments. <br><br>  Cela signifie que tous ces processus attendent la lib√©ration du m√™me verrou.  Lorsque le processus <i>System (4)</i> lib√®re le verrou (apr√®s l'avoir maintenu pendant 3.368 secondes!), Les processus en attente, √† leur tour, le capturent, font leur petit travail et transmettent le verrou.  La file d'attente comporte une centaine de processus, ce qui montre le degr√© d'influence d'un seul verrou. <br><br>  Une petite √©tude de <i>Ready Thread Stacks a</i> montr√© que la plupart des attentes proviennent de <i>KernelBase.dllWriteFile</i> .  J'ai demand√© √† WPA d'afficher les appelants de cette fonction, avec regroupement.  L√†, vous pouvez voir qu'en 12 millisecondes de cette catharsis 174 threads sortent de <i>WriteFile en</i> attente, et ils ont attendu en moyenne 1184 secondes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c63/a77/73d/c63a7773d08b42f2def485247d57e916.png"><br>  <i><font color="gray">174 threads en attente de WriteFile, temps d'attente moyen de 1 184 secondes</font></i> <br><br>  Il s'agit d'un d√©calage √©tonnant, et en fait, m√™me pas toute l'√©tendue du probl√®me, car de nombreux threads d'autres fonctions, telles que <i>KernelBase.dll! GetQueuedCompletionStatus,</i> attendent la lib√©ration du m√™me verrou. <br><br><h2>  Que fait le syst√®me (4) </h2><br>  √Ä ce stade, je savais que la progression de la construction s'arr√™tait car tous les processus du compilateur et d'autres attendaient <i>WriteFile</i> , car <i>System (4)</i> d√©tenait le verrou.  Une autre colonne <i>Ready Thread Id a</i> montr√© que le thread 3276 a d√©verrouill√© le processus syst√®me. <br><br>  Pendant tous les ¬´blocages¬ª de l'assemblage, le thread 3276 √©tait charg√© √† 100%, il est donc clair qu'il a fait un peu de travail sur le CPU tout en maintenant le verrou.  Pour savoir o√π le temps processeur est d√©pens√©, regardons le <i>graphique</i> d' <i>utilisation</i> du <i>processeur (√©chantillonn√©)</i> pour le thread 3276. Les donn√©es d'utilisation du processeur √©taient √©tonnamment claires.  Presque tout le temps n√©cessaire au travail d'une fonction <i>ntoskrnl.exe! RtlFindNextForwardRunClear</i> (le nombre d'√©chantillons est indiqu√© dans la colonne avec des nombres): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fc/0ce/2fc/0fc0ce2fc4485818ba45f9504f4c8181.png"><br>  <i><font color="gray">La pile d'appels m√®ne √† ntoskrnl.exe! RtlFindNextForwardRunClear</font></i> <br><br>  La visualisation de la pile de <i>threads Readying Thread Id a</i> confirm√© que <i>NtfsCheckpointVolume a</i> lib√©r√© le verrou apr√®s 3,368 s: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a43/225/a97/a43225a974de7651a6b51dc04b339364.png"><br>  <i><font color="gray">Pile d'appels de NtfsCheckpointVolume √† ExReleaseResourceLite</font></i> <br><br>  En ce moment, il m'a sembl√© qu'il √©tait temps d'utiliser la riche connaissance de mes followers sur Twitter, j'ai donc post√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette question</a> et montr√© une pile compl√®te d'appels.  Les tweets contenant de telles questions peuvent √™tre tr√®s efficaces si vous fournissez suffisamment d'informations. <br><br>  Dans ce cas, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bonne r√©ponse</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Caitlin Gadd</a> est arriv√©e tr√®s rapidement, ainsi que de nombreuses autres excellentes suggestions.  Elle a d√©sactiv√© la fonction de r√©cup√©ration du syst√®me - et soudain, la construction est all√©e deux √† trois fois plus vite! <br><br><h2>  Mais attendez, plus c'est encore mieux </h2><br>  Bloquer l'ex√©cution dans tout le syst√®me pendant plus de 3 secondes est assez impressionnant, mais la situation est encore plus impressionnante si vous ajoutez la colonne <i>Adresse</i> √† la table <i>Utilisation</i> du <i>processeur (√©chantillonn√©e)</i> et triez-la.  Il montre o√π exactement les √©chantillons <i>RtlFindNextForwardRunClear</i> obtiennent - et 99% d'entre eux tombent sur une instruction! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aec/1e3/9b6/aec1e39b65cddb3473242514e7cea1a9.png"><br><br>  J'ai pris les <i>fichiers</i> <i>ntoskrnl.exe</i> et <i>ntkrnlmp.pdb</i> (la m√™me version que mon ami) et <code>dumpbin /disasm</code> ex√©cut√© <code>dumpbin /disasm</code> pour afficher la fonction d'int√©r√™t dans l'assembleur.  Les premiers chiffres des adresses sont diff√©rents car le code se d√©place au d√©marrage, mais les quatre derni√®res valeurs hexad√©cimales sont les m√™mes (elles ne changent pas apr√®s ASLR): <br><br><pre>  RtlFindNextForwardRunClear:
 ...
 14006464F: 4C 3B C3 cmp r8, rbx
 140064652: 73 0F jae 0000000140064663
 140064654: 41 39 28 cmp dword ptr [r8], ebp
 140064657: 75 0A jne 0000000140064663
 140064659: 49 83 C0 04 add r8.4
 14006465D: 41 83 C1 20 add r9d, 20h
 140064661: EB EC jmp 000000014006464F
 ... </pre><br>  Nous voyons que l'instruction sur ... 4657 est incluse dans un cycle de sept instructions, qui se trouvent dans d'autres exemples.  Le nombre de ces √©chantillons est indiqu√© √† droite: <br><br><pre>  RtlFindNextForwardRunClear:
 ...
 14006464F: 4C 3B C3 cmp r8, rbx 4
 140064652: 73 0F jae 0000000140064663 41
 140064654: 41 39 28 cmp dword ptr [r8], ebp     
 140064657: 75 0A jne 0000000140064663 7498
 140064659: 49 83 C0 04 add r8.4 2
 14006465D: 41 83 C1 20 add r9d, 20h 1
 140064661: EB EC jmp 000000014006464F 1
 ... </pre><br>  En tant qu'exercice pour le lecteur, laissons l'interpr√©tation du nombre d'√©chantillons sur un processeur superscalaire avec une ex√©cution extraordinaire des instructions, bien que quelques bonnes id√©es puissent √™tre trouv√©es dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> .  Dans ce cas, nous avons un AMD Ryzen Threadripper √† 32 c≈ìurs 2990WX.  Apparemment, la fonction de processeur de Micro-Up Fusion avec l'ex√©cution de cinq instructions √† la fois permet en fait de terminer chaque cycle sur jne, car l'instruction apr√®s l'instruction la plus ch√®re tombe dans la majorit√© des interruptions de la s√©lection. <br><br>  Il s'av√®re donc qu'une machine avec 64 processeurs logiques s'arr√™te dans un cycle de sept commandes dans le processus syst√®me, tout en maintenant un verrou NTFS vital, qui est corrig√© en d√©sactivant la r√©cup√©ration du syst√®me. <br><br><h2>  Coda </h2><br>  Il n'est pas clair pourquoi ce code s'est mal comport√© sur cette machine particuli√®re.  Je suppose que cela est en quelque sorte li√© √† la distribution des donn√©es sur un disque de 2 To presque vide.  Lorsque la r√©cup√©ration du syst√®me a √©t√© r√©activ√©e, le probl√®me est √©galement revenu, mais pas si grave.  Peut-√™tre existe-t-il une sorte de pathologie pour les disques avec d'√©normes fragments d'espace vide? <br><br>  Un autre abonn√© sur Twitter a mentionn√© le bogue Volume Shadow Copy de Windows 7, qui permet l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ex√©cution pendant O (n ^ 2)</a> .  Cette erreur aurait √©t√© corrig√©e dans Windows 8, mais elle aurait pu √™tre conserv√©e sous une forme ou une autre.  Mes traces de pile montrent clairement que <i>VspUpperFindNextForwardRunClearLimited</i> (recherche d'un bit utilis√© dans cette zone de 16 m√©gaoctets) appelle <i>VspUpperFindNextForwardRunClear</i> (recherche le prochain bit utilis√© n'importe o√π, mais ne le renvoie pas s'il se trouve en dehors de la zone sp√©cifi√©e).  Bien s√ªr, cela provoque un certain sentiment de d√©j√†-vu.  Comme je l'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit r√©cemment</a> , O (n ^ 2) est un point faible d'algorithmes peu √©volutifs.  Deux facteurs co√Øncident ici: un tel code est assez rapide pour entrer en production, mais assez lent pour abandonner cette production. <br><br>  Il y a eu des rapports qu'un probl√®me similaire se produit avec une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suppression massive de fichiers</a> , mais notre trace ne montre pas beaucoup de suppressions, donc le probl√®me, apparemment, n'est pas celui-l√†. <br><br>  En conclusion, je vais dupliquer le calendrier de charge du processeur √† l'√©chelle du syst√®me depuis le d√©but de l'article, mais cette fois en indiquant l'utilisation du processeur par le processus de probl√®me <i>syst√®me</i> (en vert ci-dessous).  Dans une telle image, le probl√®me est compl√®tement √©vident.  Le processus du syst√®me est techniquement visible sur le graphique du haut, mais √† cette √©chelle, il est facile de le manquer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fb/ca1/9ff/4fbca19ffabb57dd7f17d40417eee0ca.png"><br><br>  Bien que le probl√®me soit clairement visible sur le graphique, il ne prouve en fait rien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comme on dit</a> , la corr√©lation n'est pas une relation causale.  Seule une analyse des √©v√©nements de changement de contexte montre que c'est ce flux qui d√©tient le verrou critique - et alors vous pouvez √™tre s√ªr que nous avons trouv√© la cause r√©elle, et pas seulement une corr√©lation al√©atoire. <br><br><h2>  Demandes </h2><br>  Comme d'habitude, je termine cette enqu√™te par un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appel √† mieux nommer les threads</a> .  Le processus syst√®me a des dizaines de threads, dont beaucoup ont un but sp√©cial, et aucun n'a de nom.  Le thread syst√®me le plus occup√© dans cette trace √©tait <i>MiZeroPageThread</i> .  J'ai plong√© √† plusieurs reprises dans sa pile, et √† chaque fois je me suis rappel√© que √ßa ne m'int√©ressait pas.  Le compilateur VC ++ ne nomme pas non plus ses threads.  Il ne faut pas beaucoup de temps pour renommer les flux, et c'est vraiment utile.  Donnez simplement le nom.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C'est simple</a> .  Chromium inclut m√™me un outil pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©pertorier les noms de flux dans un processus</a> . <br><br>  Si quelqu'un de l'√©quipe NTFS de Microsoft souhaite parler de ce sujet, faites-le moi savoir et je pourrai vous mettre en relation avec l'auteur du rapport d'origine et fournir une trace ETW. <br><br><h2>  Les r√©f√©rences </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fil Twitter</a> original <br></li><li>  Annonce sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a> <br></li><li>  Discussion chez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hacker News</a> <br></li><li>  Discussion sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reddit</a> <br></li><li>  Tirade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows / NTFS</a> √©ventuellement pertinente </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472552/">https://habr.com/ru/post/fr472552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472536/index.html">SDK Smart IdReader - int√©grer la reconnaissance dans les projets en Python et PHP</a></li>
<li><a href="../fr472540/index.html">Ils se r√©veillent! (n.-f. histoire, partie 2 et derni√®re)</a></li>
<li><a href="../fr472544/index.html">Astuces de marketing de Pornhub: ce que le site Web le plus touchant d'aujourd'hui dit</a></li>
<li><a href="../fr472548/index.html">Comment nous sommes all√©s sur le march√© (et n'avons rien r√©alis√© de sp√©cial)</a></li>
<li><a href="../fr472550/index.html">Lancement d'une entreprise informatique: les 4 meilleures franchises technologiques de 2019</a></li>
<li><a href="../fr472556/index.html">Le secret du bonheur des employ√©s est la nature au bureau?</a></li>
<li><a href="../fr472560/index.html">Test de Gestalt: une nouvelle approche pour l'optimisation des listes de diffusion bas√©e sur la th√©orie bay√©sienne et l'apprentissage automatique</a></li>
<li><a href="../fr472562/index.html">Tendances financi√®res: les grandes entreprises ont besoin de plus en plus de professionnels de l'informatique</a></li>
<li><a href="../fr472566/index.html">L'enfer personnel de l'√©crivain Fraerman, ou le conte du premier amour</a></li>
<li><a href="../fr472568/index.html">D√©ploiement d'Apache Ignite Zero: exactement z√©ro?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>