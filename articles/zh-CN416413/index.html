<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍👩 ✋🏿 🤶🏿 来了，看到了，概括了：沉浸在Java Generics中 😪 🎦 ✋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java泛型是Java语言历史上最重要的变化之一。 Java 5可用的泛型使Java收集框架的使用变得更加容易，便捷和安全。 现在在编译阶段检测到与错误使用类型相关的错误。 是的，Java语言本身已经变得更加安全。 尽管泛型类型看起来很简单，但是许多开发人员仍难以使用它们。 在这篇文章中，我将讨论使...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>来了，看到了，概括了：沉浸在Java Generics中</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/416413/">  Java泛型是Java语言历史上最重要的变化之一。  Java 5可用的泛型使Java收集框架的使用变得更加容易，便捷和安全。 现在在编译阶段检测到与错误使用类型相关的错误。 是的，Java语言本身已经变得更加安全。 尽管泛型类型看起来很简单，但是许多开发人员仍难以使用它们。 在这篇文章中，我将讨论使用Java泛型的功能，以便使您减少这些困难。 如果您不是通用专家，则很有用，并且可以帮助您避免陷入主题时的很多困难。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/63e/016/77063e016a04378dbffb1372c68e33cc.png"><br><a name="habracut"></a><br><h2> 处理收藏 </h2><br> 假设一家银行需要计算客户帐户中的储蓄金额。 在“泛型”出现之前，计算总和的方法如下所示： <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List accounts)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = accounts.size(); i &lt; n; i++) {       Object account = accounts.get(i);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) {           sum += ((Account) account).getAmount();       }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br> 我们进行了迭代，遍历了帐户列表，并检查了该列表中的元素是否确实是<code>Account</code>类的实例-即用户的帐户。 我们将<code>Account</code>类的对象类型和<code>getAmount</code>方法进行了<code>getAmount</code> ，它们返回了该帐户中的金额。 然后他们将它们加总并返回总数。 需要两个步骤： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) { <span class="hljs-comment"><span class="hljs-comment">// (1)</span></span></code> </pre> <br><pre> <code class="java hljs">sum += ((Account) account).getAmount(); <span class="hljs-comment"><span class="hljs-comment">// (2)</span></span></code> </pre> <br> 如果不检查（ <code>instanceof</code> ）是否属于<code>Account</code>类，则在第二阶段可能会发生<code>ClassCastException</code>即程序崩溃。 因此，这种检查是强制性的。 <br><br> 随着泛型的问世，对类型检查和强制转换的需求已消失： <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Account&gt; accounts)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Account account : accounts) {      sum += account.getAmount();  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br> 现在方法 <pre> <code class="hljs lisp">getSum2(<span class="hljs-name"><span class="hljs-name">List&lt;Account&gt;</span></span> accounts)</code> </pre> 仅接受<code>Account</code>类的对象列表作为参数。 此限制在方法本身中表示，在其签名中，程序员根本无法转移任何其他列表-仅客户帐户列表。 <br><br> 我们不需要检查此列表中的元素的类型：method参数的类型描述暗含了它。 <pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Account</span></span></span><span class="hljs-tag">&gt;</span></span> accounts</code> </pre>  （可以读取为<code>   Account</code> ）。 如果出现问题，即如果有人尝试将<code>Account</code>类以外的对象列表传递给此方法，则编译器将引发错误。 <br><br> 在检查的第二行中，需求也消失了。 如有必要，将在编译阶段进行转换。 <br><br><h2> 替代原则 </h2><br>  Barbara Liskov的替换原理是面向对象编程中子类型的特定定义。  Liskov的“子类型”概念定义了替换的概念：如果<code>S</code>是<code>T</code>的子类型，则程序中类型<code>T</code>的对象可以用类型<code>S</code>的对象替换，而无需更改该程序的所需属性。 <br><br><table><tbody><tr><td>  <b>型式</b> <br></td><td>  <b>亚型</b> <br></td></tr><tr><td>  <i>编号</i> <br></td><td>  <i>整数</i> <br></td></tr><tr><td>  <i>列出</i> &lt;E&gt; <br></td><td>  <i>ArrayList</i> &lt;E&gt; <br></td></tr><tr><td>  <i>集合</i> &lt;E&gt; <br></td><td>  <i>列出</i> &lt;E&gt; <br></td></tr><tr><td>  <i>可迭代</i> &lt;E&gt; <br></td><td>  <i>集合</i> &lt;E&gt; <br></td></tr></tbody></table><br>  <i>类型/子类型关系示例</i> <br><br> 这是在Java中使用替换原理的示例： <br><pre> <code class="java hljs">Number n = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>); List&lt;Number&gt; aList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Collection&lt;Number&gt; aCollection = aList; Iterable&lt;Number&gt; iterable = aCollection;</code> </pre> <br>  <code>Integer</code>是<code>Number</code>的子类型，因此，可以为<code>Number</code>类型的变量<code>n</code>分配<code>Integer.valueOf(42)</code>方法返回的值。 <br><br><h2> 协方差，协方差和不变性 </h2><br> 首先，一点理论。 协方差是在相同类型的派生类型中保留源类型的继承层次结构。 例如，如果<i>Cat</i>是<i>Animals</i>的子类型，则<i>&lt;Cats&gt;</i>的<i>集合是&lt;Animals&gt;</i>的<i>集合的</i>子类型。 因此，考虑到替代原则，可以执行以下分配： <br><br>  <i>许多&lt;动物&gt; =许多&lt;猫&gt;</i> <br><br> 矛盾是派生类型中源类型层次结构的反转。 例如，如果<i>Cat</i>是<code></code>的子类型，则<i>Set &lt;Animals&gt;</i>是<i>&lt;Cats&gt;</i>的<i>Set的</i>子类型。 因此，考虑到替代原则，可以执行以下分配： <br><br>  <i>许多&lt;猫&gt; =许多&lt;动物&gt;</i> <br><br> 不变性-派生类型之间缺乏继承。 如果<i>Cat</i>是<i>Animals</i>的子类型，则<i>&lt;Cats&gt;</i>的<i>集合</i>不是<i>&lt;Animals&gt;</i>的<i>集合的</i>子类型，并且<i>&lt;Animals&gt;</i>的<i>集合</i>不是<i>&lt;Cats&gt;</i>的<i>集合的</i>子类型。 <br><br>  <b>Java中的数组是协变的</b> 。 如果<code>S</code>是<code>T[]</code>的子类型，则类型<code>S[]</code>是<code>T[]</code>的子类型<code>T</code> 分配示例： <br><pre> <code class="java hljs">String[] strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[] {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Object[] arr = strings;</code> </pre><br> 我们为变量<code>arr</code>分配了一个字符串数组链接，其类型为<code>« »</code> 。 如果数组不是协变的，我们将无法做到这一点。  Java允许您执行此操作，程序可以编译并运行而不会出错。 <br><br><pre> <code class="java hljs">arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ArrayStoreException.      </span></span></code> </pre> <br> 但是，如果我们尝试通过<code>arr</code>变量更改数组的内容并在其中写入数字42，则由于程序不是字符串，而是数字， <code>ArrayStoreException</code>在程序执行阶段将获得<code>ArrayStoreException</code> 。 这是Java数组协方差的缺点：我们无法在编译阶段执行检查，并且某些东西可能在运行时已经损坏。 <br><br>  <b>“泛型”是不变的。</b> 这是一个例子： <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); List&lt;Number&gt; nums = ints; <span class="hljs-comment"><span class="hljs-comment">// compile-time error.      nums.set(2, 3.14); assert ints.toString().equals("[1, 2, 3.14]");</span></span></code> </pre> <br> 如果采用整数列表，则它将不是<code>Number</code>类型的子类型，也不会是任何其他子类型。 他只是他自己的一个亚型。 也就是说， <code>List &lt;Integer&gt;</code>是<code>List&lt;Integer&gt;</code> ，仅此而已。 编译器将确保声明为<i>Integer</i>类的对象列表的<code>ints</code>变量仅包含<i>Integer</i>类的对象， <i>而不</i>包含其他任何对象。 在编译阶段，将执行检查，并且运行时不会出错。 <br><br><h2> 通配符 </h2><br> 泛型总是不变的吗？ 不行 我将举一些例子： <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); List&lt;? extends Number&gt; nums = ints;</code> </pre> <br> 这就是协方差。  <code>List&lt;Integer&gt;</code> - <code>List&lt;? extends Number&gt;</code>子类型 <code>List&lt;? extends Number&gt;</code> <br><br><pre> <code class="java hljs">List&lt;Number&gt; nums = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;(); List&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Integer&gt; ints = nums;</code> </pre> <br> 这是矛盾的。  <code>List&lt;Number&gt;</code>是<code>List&lt;? super Integer&gt;</code>的子类型<code>List&lt;? super Integer&gt;</code>  <code>List&lt;? super Integer&gt;</code> 。 <br><br> 诸如<code>"? extends ..."</code>或<code>"? super ..."</code>的记录称为通配符或通配符，具有上限（ <code>extends</code> ）或下限（ <code>super</code> ）。 <code>List&lt;? extends Number&gt;</code>  <code>List&lt;? extends Number&gt;</code>可能包含其类为<code>Number</code>或从<code>Number</code>继承的对象。 <code>List&lt;? super Number&gt;</code>  <code>List&lt;? super Number&gt;</code>可能包含其类为<code>Number</code>或<code>Number</code>为继承者（ <code>Number</code>超类型）的对象。 <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/e86/5e1/836/e865e18363e605bc801e70474241d458.png"><br></td><td> 扩展<i>B-</i>具有上限的通配符 <br> 超级<i>B-</i>下限通配符 <br> 其中<i>B-</i>代表边界 <br><br> 形式为T <sub>2</sub> &lt;= T <sub>1的记录</sub>表示T <sub>2</sub>描述的类型集合是T <sub>1</sub>描述的类型集合的子集 <br><br> 即 <br> 数字&lt;=？ 扩展对象 <br>  ？ 扩展数字&lt;=？ 扩展对象 <br> 和 <br>  ？ 超级对象&lt;=？ 超级号码 <br><br></td></tr></tbody></table><br>  <i>对主题的更多数学解释</i> <br><br> 一对测试知识的任务： <br><br>  1.为什么在下面的示例中出现编译时错误？ 我可以在<code>nums</code>列表中添加什么值？ <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); ints.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); ints.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); List&lt;? extends Number&gt; nums = ints; nums.add(<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"> 是否应使用通配符声明容器<code>? extends</code>  <code>? extends</code> ，您只能读取值。 除了<code>null</code>之外，什么都不能添加到列表中。 为了将对象添加到列表中，我们需要另一种通配符- <code>? super</code> <code>? super</code> <br></div></div><br><br>  2.为什么我无法从下面的列表中获得商品？ <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"> 无法从带有通配符的容器中读取项目<code>? super</code>  <code>? super</code> ，但<code>Object</code>类的<code>Object</code>除外 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br></div></div><br><br><h3> 获取和放置原则或PECS（生产者扩展了超级消费者） </h3><br> 具有上限和下限的通配符功能提供了与类型的安全使用相关的其他功能。 您只能从一种类型的变量中读取，而只能写入另一种类型（例外是，可以为<code>extends</code>写入<code>null</code> ，为<code>super</code>读取<code>Object</code> ）。 为了更容易记住何时使用哪个通配符，有PECS原理-生产者扩展了超级用户。 <br><br><ul><li> 如果我们声明一个<i>带有extends</i>的<i>通配符</i> ，那么这就是<i>生产者</i> 。 他仅“生产”，从容器中提供元素，并且不接受任何东西。 <br></li><li> 如果我们宣布<i>使用super</i>作为<i>通配符</i> ，那么这就是<i>消费者</i> 。 他只接受但不能提供任何东西。 <br></li></ul><br> 以java.util.Collections类中的copy方法为例，考虑使用通配符和PECS原理。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br> 该方法将元素从原始<code>src</code>列表复制到<code>dest</code>列表。  <code>src</code>使用通配符声明<code>? extends</code>  <code>? extends</code>并且是生产者，并且<code>dest</code>用通配符声明<code>? super</code>  <code>? super</code> ，是消费者。 给定通配符的协变量和协变量，您可以将元素从<code>ints</code>列表复制到<code>nums</code>列表： <br><pre> <code class="java hljs">List&lt;Number&gt; nums = Arrays.&lt;Number&gt;asList(<span class="hljs-number"><span class="hljs-number">4.1F</span></span>, <span class="hljs-number"><span class="hljs-number">0.2F</span></span>); List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Collections.copy(nums, ints);</code> </pre> <br><br> 如果我们错误地误认为复制方法参数，并尝试从<code>nums</code>列表复制到<code>ints</code>列表，编译器将不允许我们这样做： <br><pre> <code class="java hljs">Collections.copy(ints, nums); <span class="hljs-comment"><span class="hljs-comment">// Compile-time error</span></span></code> </pre> <br><br><h3>  &lt;？&gt;和Raw类型 </h3><br> 以下是带有无限通配符的通配符。 我们只放入<code>&lt;?&gt;</code> ，不带<code>super</code>或<code>extends</code>关键字： <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// a wildcard collection  for (Object o : c) {      System.out.println(o);  } }</span></span></code> </pre><br><br> 实际上，从上方看，这样的“无限”通配符仍然受到限制。  <code>Collection&lt;?&gt;</code>也是通配符，例如“ <code>? extends Object</code> ”。 形式为<code>Collection&lt;?&gt;</code>记录等效于<code>Collection&lt;? extends Object&gt;</code>  <code>Collection&lt;? extends Object&gt;</code> ，这意味着该集合可以包含任何类的对象，因为Java中的所有类都继承自<code>Object</code>因此替换称为无限制。 <br><br> 例如，如果我们省略类型指示，例如： <br><pre> <code class="java hljs">ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList();</code> </pre> <br> 然后他们说<code>ArrayList</code>是参数化<i>ArrayList &lt;T&gt;</i>的<code>Raw</code>类型。 使用原始类型，我们回到了泛型时代，有意识地放弃了参数化类型固有的所有功能。 <br><br> 如果尝试在Raw类型上调用参数化方法，则编译器将向我们发出警告“未检查的调用”。 如果我们尝试将对参数化Raw类型的引用分配给类型，则编译器将发出警告“未检查的分配”。 稍后我们将看到，忽略这些警告可能会导致我们的应用程序执行期间出错。 <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// Ok strings = arrayList; // Unchecked assignment arrayList.add(1); //unchecked call</span></span></code> </pre><br><br><h3> 通配符捕获 </h3><br> 现在，让我们尝试实现一种以相反顺序排列列表元素的方法。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ! public static void reverse(List&lt;?&gt; list) { List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list); for (int i = 0; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-1)); // compile-time error } }</span></span></code> </pre> <br> 发生编译错误是因为<code>reverse</code>方法将具有无限通配符<code>&lt;?&gt;</code>作为参数。 <br>  <code>&lt;?&gt;</code>含义与<code>&lt;? extends Object&gt;</code>  <code>&lt;? extends Object&gt;</code> 。 因此，根据PECS原理， <code>list</code>为<code>producer</code> 。  <code>producer</code>只生产元素。 然后我们在<code>for</code>循环中调用<code>set()</code>方法，即 试图写<code>list</code> 。 因此，我们反对Java保护，因为Java保护不允许我们通过索引设置某些值。 <br><br> 怎么办  <code>Wildcard Capture</code>模式将为我们提供帮助。 在这里，我们创建一个通用的<code>rev</code>方法。 使用类型<code>T</code>的变量声明它<code>T</code> 此方法接受<code>T</code>类型的列表，我们可以进行设置。 <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ rev(list); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(list); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-<span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre> <br> 现在一切都会与我们一起编译。 通配符捕获在此处捕获。 当调用<code>reverse(List&lt;?&gt; list)</code>方法时<code>reverse(List&lt;?&gt; list)</code> ，一些对象（例如，字符串或整数）的列表作为参数传递。 如果我们可以捕获这些对象的类型并将其分配给类型<code>X</code>的变量，则可以得出<code>T</code>为<code>X</code>结论<code>X</code> <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读有关<code>Wildcard Capture</code>更多信息。 <br><br><h3> 结论 </h3><br> 如果您需要从容器中读取内容，则使用通配符，其上边框为“ <code>? extends</code> ”。 如果需要写入容器，请使用下边框为“ <code>? super</code> ”的通配符。 如果需要记录和读取，请不要使用通配符。 <br><br> 不要使用<code>Raw</code>类型！ 如果未定义type参数，则使用通配符<code>&lt;?&gt;</code> 。 <br><br><h2> 类型变量 </h2><br> 当我们在尖括号中写下标识符时，例如，在声明类或方法时，例如<code>&lt;T&gt;</code>或<code>&lt;E&gt;</code> ，我们将创建<i>一个类型变量</i> 。 类型变量是一种不合格的标识符，可以用作类或方法主体中的类型。 类型变量可以在上面限制。 <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><span class="hljs-function"> </span></span>{ T candidate = coll.iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T elt : coll) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.compareTo(elt) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) candidate = elt; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidate; }</code> </pre> <br> 在此示例中，表达式<code>T extends Comparable&lt;T&gt;</code>定义了上面由类型<code>Comparable&lt;T&gt;</code>界定的<code>T</code> （类型变量）。 与通配符不同，类型变量只能在顶部限制（仅<code>extends</code> ）。 不能写<code>super</code> 。 另外，在此示例中， <code>T</code>依赖于自身，它称为<code>recursive bound</code> -递归边界。 <br><br> 这是Enum类的另一个示例： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;&gt;</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span></span></code> </pre> <br> 在这里，Enum类由类型E（它是<code>Enum&lt;E&gt;</code>的子类型）进行参数化。 <br><br><h3> 多重界限 </h3><br>  <code>Multiple Bounds</code> -多个约束。 它是通过“ <code>&amp;</code> ”字符写的，也就是说，我们说由类型<code>T</code>的变量表示的类型应由<code>Object</code>类和<code>Comparable</code>接口从上方限制。 <br><br><pre> <code class="java hljs">&lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span></span></code> </pre> <br> 记录<code>Object &amp; Comparable&lt;? super T&amp;gt</code>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code>形成相交类型“ <code>Multiple Bounds</code> 。 第一个限制-在这种情况下为<code>erasure</code>用于<code>erasure</code> ，即重写类型的过程。 它由编译器在编译阶段执行。 <br><br><h3> 结论 </h3><br> 类型变量只能限制在一个或多个类型的顶部。 在多个约束的情况下，在重写（类型擦除）过程中使用左边框（第一个约束）。 <br><br><h2> 类型擦除 </h2><br> 类型擦除是类型（可能包括参数化类型和类型变量）到永不参数化类型或变​​量类型的类型的映射。 我们将<code>T</code>型混搭写为<code>|T|</code>  。 <br><br> 混搭显示的定义如下： <br><ul><li> 混合参数化类型<i>G</i> &lt; <i>T1</i> ，...， <i>Tn</i> &gt;是|  <i>G</i> | </li><li> 拼凑嵌套类型<i>TC</i>是|  <i>T</i> |。  <i>ç</i> </li><li> 哈希数组类型<i>T []</i>是|  <i>T</i> | [] </li><li> 混搭类型变量会混搭其左边框 </li><li> 混搭任何其他类型就是该类型本身 </li></ul><br><br> 在执行Type Erasure（类型混搭）期间，编译器执行以下操作： <br><ul><li> 添加类型转换以在必要时提供类型安全 </li><li> 生成Bridge方法以保持多态 </li></ul><br><br><table><tbody><tr><td>  <b>T（类型）</b> <br></td><td>  <b>| T |</b>  <b>（混搭类型）</b> <br></td></tr><tr><td>  <i>列表&lt;整数&gt;，列表&lt;String&gt;，列表&lt;列表&lt;String &gt;&gt;</i> <br></td><td>  <i>清单</i> <br></td></tr><tr><td>  <i>列出&lt;整数&gt; []</i> <br></td><td>  <i>清单[]</i> <br></td></tr><tr><td>  <i>清单</i> <br></td><td>  <i>清单</i> <br></td></tr><tr><td>  <i>整型</i> <br></td><td>  <i>整型</i> <br></td></tr><tr><td>  <i>整数</i> <br></td><td>  <i>整数</i> <br></td></tr><tr><td>  <i>&lt;T扩展了可比性&lt;T &gt;&gt;</i> <br></td><td>  <i>可比</i> <br></td></tr><tr><td>  <i>&lt;T扩展了对象和可比对象&lt;？</i>  <i>超级T &gt;&gt;</i> <br></td><td>  <i>对象</i> <br></td></tr><tr><td>  <i>LinkedCollection &lt;E&gt; .Node</i> <br></td><td>  <i>LinkedCollection.Node</i> <br></td></tr></tbody></table><br> 下表显示了混搭过程中不同类型变成什么类型​​“擦除”。 <br><br> 在下面的屏幕截图中，是该程序的两个示例： <br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/de2/396/3a3de23965478fc627221a1c20f4d600.png"><br><br> 两者之间的区别在于，左侧会发生编译时错误，而右侧会编译所有错误而没有错误。 怎么了 <br><br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text"> 在Java中，两个不同的方法不能具有相同的签名。 在类型清除过程中，编译器将添加桥接方法<code>public int compareTo(Object o)</code> 。 但是该类已经包含一个带有签名的方法，它将在编译期间导致错误。 <br><br> 通过删除<code>compareTo(Object o)</code>方法来编译Name类，并使用javap查看生成的字节码： <br><pre> <code class="java hljs"># javap Name.class Compiled from <span class="hljs-string"><span class="hljs-string">"Name.java"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ru.sberbank.training.generics.Name(java.lang.String); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ru.sberbank.training.generics.Name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.Object)</span></span></span></span>; }</code> </pre><br> 尽管我们从源代码中删除了该类，但我们看到该类包含一个<code>int compareTo(java.lang.Object)</code>方法<code>int compareTo(java.lang.Object)</code> 。 这是编译器添加的桥接方法。 <br></div></div><br><br><h3> 可更改的类型 </h3><br> 在Java中，我们说类型是可<code>reifiable</code>只要它的信息在运行时就可以完全访问。 可更改的类型包括： <br><ul><li> 基本类型（ <i>int</i> ， <i>long</i> ， <i>boolean</i> ） </li><li> 非参数化（非泛型）类型（ <i>String</i> ， <i>Integer</i> ） </li><li> 参数化类型，其参数表示为无界通配符（无限通配符）（ <i>List &lt;？&gt;</i> ， <i>Collection &lt;？&gt;</i> ） </li><li>  <i>原始</i> （未格式化的）类型（ <i>List</i> ， <i>ArrayList</i> ） </li><li> 组件为可更改类型的数组（ <i>int []</i> ， <i>Number []</i> ， <i>List &lt;？&gt; []</i> ， <i>List [</i> ] </li></ul><br><br> 为什么可以获得有关某些类型的信息，而没有有关其他类型的信息？ 事实是，由于编译器覆盖类型的过程，有关某些类型的信息可能会丢失。 如果丢失，则此类型将不再是可修复的。 也就是说，它在运行时不可用。 如果可用-分别是可更改的。 <br><br> 不让所有通用类型在运行时可用的决定是Java类型系统中最重要且相互冲突的设计决定之一。 首先，这样做是为了与现有代码兼容。 我必须为迁移兼容性付费-在运行时无法完全访问通用类型的系统。 <br><br> 哪些类型不合理？ <br><ul><li> 类型变量（ <i>T</i> ） </li><li> 具有指定参数类型的参数化类型（ <i>List &lt;Number&gt;</i> <i>ArrayList &lt;String&gt;</i> ， <i>List &lt;List &lt;String &gt;&gt;</i> ） </li><li> 具有指定上限或下限的参数化类型（ <i>列表&lt;？扩展数&gt;，可比较的&lt;？超级字符串&gt;</i> ）。 但这是一个保留： <i>列表&lt;？</i>  <i>扩展对象&gt;</i> - <b>不</b>可靠，但<i>列表&lt;？&gt;</i> -有效 </li></ul><br><br> 还有一项任务。 为什么在下面的示例中无法创建参数化的Exception？ <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{  T t; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text">  try-catch中的每个catch表达式分别在程序执行期间检查接收到的异常的类型（等效于instanceof），该类型必须是可更改的。 因此，Throwable及其子类型无法参数化。 <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">// Generic class may not extend 'java.lang.Throwable'  T t; }</span></span></code> </pre> <br></div></div><br><br><h3> 未经检查的警告 </h3><br> 编译我们的应用程序可能会产生所谓的“ <code>Unchecked Warning</code> ，即警告编译器无法正确确定使用我们的类型的安全级别。 这不是错误，而是警告，因此您可以跳过它。 但是建议将其全部修复以避免将来出现问题。 <br><br><h3> 堆污染 </h3><br> 如前所述，将对Raw类型的引用分配给参数化类型的变量会导致警告“未检查的分配”。 如果我们忽略它，则可能会出现“ <code>Heap Pollution</code> ”（堆污染）情况。 这是一个例子： <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  List l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;();  l.add(<span class="hljs-number"><span class="hljs-number">1</span></span>);  List&lt;String&gt; ls = l; <span class="hljs-comment"><span class="hljs-comment">// (1)  ls.add("");  return ls; }</span></span></code> </pre> <br> 在第（1）行中，编译器警告“未检查的分配”。 <br><br> 我们需要举另一个“堆污染”的例子-当我们使用参数化对象时。 下面的代码片段清楚地表明，不允许将参数化类型用作使用<code>Varargs</code>的方法的参数。 在这种情况下，方法参数m是<code>List&lt;String&gt;…</code> ，即 实际上，是<code>List&lt;String&gt;</code>类型的元素数组。 给定在混搭期间显示类型的规则，则<code>stringLists</code>类型将变成原始列表的数组（ <code>List[]</code> ），即 可以完成分配<code>Object[] array = stringLists;</code> 然后将除字符串列表（1）之外的对象写入<code>array</code> ，这将在字符串（2）中<code>ClassCastException</code> 。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt;... stringLists)</span></span></span><span class="hljs-function"> </span></span>{  Object[] array = stringLists;  List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number"><span class="hljs-number">42</span></span>);  array[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tmpList; <span class="hljs-comment"><span class="hljs-comment">// (1)  String s = stringLists[0].get(0); // (2) }</span></span></code> </pre> <br><br> 考虑另一个示例： <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// (1) Ok arrayList.add(1); // (2) unchecked call</span></span></code> </pre> <br>  Java允许在第（1）行中进行赋值。 这是向后兼容所必需的。 但是，如果尝试执行第（2）行中的<code>add</code>方法，则会收到<code>Unchecked call</code>警告-编译器会警告我们可能的错误。 实际上，我们正在尝试将一个整数添加到字符串列表中。 <br><br><h3> 倒影 </h3><br> 尽管在编译过程中，参数化类型会经历类型擦除过程，但是我们可以使用反射来获得一些信息。 <br><br><ul><li> 所有可修改的内容都可以通过反射机制获得。 <br></li><li> 有关类字段类型，方法参数以及它们返回的值的信息可通过反射获得。 <br></li></ul><br>     Reflection          <code>Reifiable</code> ,      . , , ,     - ,         : <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getGenericReturnType</span></span>()</code> </pre> <br>   Generics  <code>java.lang.Class</code>  .    : <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); Class&lt;? extends List&gt; k = ints.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> k == ArrayList.class;</code> </pre> <br><br>  <code>ints</code>   <code>List&lt;Integer&gt;</code>        <code>ArrayList&lt; Integer&gt;</code> .  <code>ints.getClass()</code>    <code>Class&lt;ArrayLis&gt;</code> ,   <code>List&lt;Integer&gt;</code>   <code>List</code> .   <code>Class&lt;ArrayList&gt;</code>    <code>k</code>  <code>Class&lt;? extends List&gt;</code> ,    ? <code>extends</code> .  <code>ArrayList.class</code>    <code>Class&lt;ArrayList&gt;</code> . <br><br><h3> 结论 </h3><br>         ,     Reifiable.  Reifiable  :  ,  ,      , Raw   ,    reifiable. <br><br>  Unchecked Warnings    « »      . <br><br> Reflection       ,    Reifiable.  Reflection        ,         . <br><br><h2> Type Inference </h2><br>     « ».     ()   .   : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br>   -   Java 7       <code>ArrayList</code> : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br>    <code>ArrayList</code>   – <code>List&lt;Integer&gt;</code> .     <code>type inference</code> . <br><br>  Java 8       JEP 101. <br>             Type Inference.          : <br><ul><li>  (reduction) <br></li><li>  (incorporation) <br></li><li>  (resolution) <br></li></ul><br>    :    ,      ,   —   . <br>         ,     .     JEP 101      . <br><br>       ,    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z head, List&lt;Z&gt; tail)</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-function"><span class="hljs-function">E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>    <code>List.nil()</code>      : <br><pre> <code class="java hljs">List&lt;String&gt; ls = List.nil();</code> </pre> <br>     ,      <code>List.nil()</code>  <code>String</code> —    JDK 7,  . <br><br>  ,        ,            , : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.nil()); <span class="hljs-comment"><span class="hljs-comment">//error: expected List&lt;Integer&gt;, found List&lt;Object&gt;</span></span></code> </pre> <br>  JDK 7    compile-time error.   JDK 8 .      JEP-101,    —     .        JDK 8 —        : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.&lt;Integer&gt;nil());</code> </pre> <br><br>   JEP-101   ,          , : <br><pre> <code class="java hljs">String s = List.nil().head(); <span class="hljs-comment"><span class="hljs-comment">//error: expected String, found Object</span></span></code> </pre> <br>        ,         . ,    JDK    ,      : <br><pre> <code class="java hljs">String s = List.&lt;String&gt;nil().head();</code> </pre> <br><br>   JEP 101  StackOverflow     .  ,  ,    7- ,  8-   –    ?    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"one"</span></span>);  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"two"</span></span>);  }  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{      m(g());  } }</code> </pre> <br><br>   -    JDK1.8: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   descriptor: ([Ljava/lang/String;)V   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: checkcast     #7   // class "[Ljava/lang/String;"        6: invokestatic  #8   // Method m:([Ljava/lang/String;)V        9: return     LineNumberTable:       line 15: 0       line 16: 9</span></span></code> </pre><br><br>    0    <code>g:()Ljava/lang/Object;</code>   <code>java.lang.Object</code> . ,  3    («») ,        <code>java.lang.String</code> ,   6   <code>m:([Ljava/lang/String;)</code> ,      «two». <br><br>   -    JDK1.7 –    Java 7: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: invokestatic  #7   // Method m:(Ljava/lang/Object;)V        6: return            LineNumberTable:       line 15: 0       line 16: 6</span></span></code> </pre><br><br>  ,     <code>checkcast</code> ,   Java 8,     <code>m:(Ljava/lang/Object;)</code> ,     «one». <code>Checkcast</code> –    ,      Java 8. <br><br>    , Oracle  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>    JDK1.7  JDK 1.8    ,         Java,  ,     . <br><br>    ,        Java 8    ,    Java 7,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ m((Object)g()); }</code> </pre><br><br><h2> 结论 </h2><br>      Java Generics   .   ,      : <br><br><ul><li> Naftalin, Maurice; Wadler, Philip. Java Generics and Collections. O'Reilly Media. ISBN-13: 978-0596527754 <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a> <br></li><li>   Java SE 8. Addison-Wesley. ISBN: 978-5-8459-1875-8 <br></li></ul><br><ul><li> Bloch, Joshua. Effective Java. Third Edition. Addison-Wesley. ISBN-13: 978-0-13-468599-1 <br></li></ul><br>      ,        Java Generics. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416413/">https://habr.com/ru/post/zh-CN416413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416403/index.html">金融科技摘要：攻击PIR银行，联邦税收服务和从卡到卡转移的税收以及一些区块链和加密货币</a></li>
<li><a href="../zh-CN416405/index.html">与Yandex合作的学士学位课程</a></li>
<li><a href="../zh-CN416407/index.html">节省来自Mikrotik嗅探器的流量</a></li>
<li><a href="../zh-CN416409/index.html">制定策略和应对方法的5个常见错误</a></li>
<li><a href="../zh-CN416411/index.html">用数据讲故事</a></li>
<li><a href="../zh-CN416415/index.html">我们将所有组件移至测试组件Vivaldi 1.16.1230.3中</a></li>
<li><a href="../zh-CN416417/index.html">“天河”-中国将制造一场前所未有的人工降雨</a></li>
<li><a href="../zh-CN416419/index.html">随机二维洞穴发生器</a></li>
<li><a href="../zh-CN416421/index.html">在维修区散步，或IaaS技术如何帮助赛车队</a></li>
<li><a href="../zh-CN416423/index.html">俄罗斯人如何想到美国处理器，或对AdvoCam-FD8 Gold-II DVR（GPS + GLONASS）的评论</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>