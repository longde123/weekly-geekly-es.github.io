<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôíÔ∏è üë®üèª‚Äçüé® üë©üèø‚Äçü§ù‚Äçüë©üèΩ M√©moire et √©tendue pt.1 ü§úüèª üßìüèª üèè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä partir de .NET Core 2.0 et .NET Framework 4.5, nous pouvons utiliser de nouveaux types de donn√©es: Span et Memory . Pour les utiliser, il vous suffi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©moire et √©tendue pt.1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443974/"><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  √Ä partir de .NET Core 2.0 et .NET Framework 4.5, nous pouvons utiliser de nouveaux types de donn√©es: <code>Span</code> et <code>Memory</code> .  Pour les utiliser, il vous suffit d'installer le package nuget <code>System.Memory</code> : </p><br><blockquote> <code>PM&gt; Install-Package System.Memory</code> </blockquote> <p>  Ces types de donn√©es sont remarquables parce que l'√©quipe CLR a fait un excellent travail pour impl√©menter leur prise en charge sp√©ciale dans le code du compilateur JIT .NET Core 2.1+ en incorporant ces types de donn√©es directement dans le noyau.  De quels types de donn√©es s'agit-il et pourquoi valent-elles un chapitre entier? </p><br><p>  Si nous parlons de probl√®mes qui ont fait appara√Ætre ces types, je devrais en nommer trois.  Le premier est du code non manag√©. </p><br><p>  Le langage et la plate-forme existent depuis de nombreuses ann√©es ainsi que les moyens de travailler avec du code non manag√©.  Alors, pourquoi publier une autre API pour travailler avec du code non manag√© si la premi√®re existait essentiellement depuis de nombreuses ann√©es?  Pour r√©pondre √† cette question, nous devons comprendre ce qui nous manquait auparavant. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Les d√©veloppeurs de la plateforme ont d√©j√† essay√© de faciliter l'utilisation de ressources non g√©r√©es pour nous.  Ils ont impl√©ment√© des wrappers automatiques pour les m√©thodes import√©es et le marshaling qui fonctionne automatiquement dans la plupart des cas.  Ici aussi appartient √† <code>stackalloc</code> , mentionn√© dans le chapitre sur une pile de threads.  Cependant, √† mon avis, les premiers d√©veloppeurs C # sont venus du monde C ++ (mon cas), mais maintenant ils passent de langages plus avanc√©s (je connais un d√©veloppeur qui a d√©j√† √©crit en JavaScript).  Cela signifie que les gens deviennent de plus en plus suspects envers le code non manag√© et les constructions C / C +, d'autant plus pour Assembler. </p><br><p>  En cons√©quence, les projets contiennent de moins en moins de code dangereux et la confiance dans l'API de la plate-forme augmente de plus en plus.  Il est facile de v√©rifier si nous recherchons des cas d'utilisation <code>stackalloc</code> dans les r√©f√©rentiels publics - ils sont rares.  Cependant, prenons tout code qui l'utilise: </p><br><p>  <strong>Classe Interop.ReadDir</strong> <br>  <a href="">/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs</a> </p><br><pre> <code class="plaintext hljs">unsafe { // s_readBufferSize is zero when the native implementation does not support reading into a buffer. byte* buffer = stackalloc byte[s_readBufferSize]; InternalDirectoryEntry temp; int ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, out temp); // We copy data into DirectoryEntry to ensure there are no dangling references. outputEntry = ret == 0 ? new DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } : default(DirectoryEntry); return ret; }</code> </pre> <br><p>  Nous pouvons voir pourquoi il n'est pas populaire.  Parcourez simplement ce code et demandez-vous si vous lui faites confiance.  Je suppose que la r√©ponse est ¬´non¬ª.  Ensuite, demandez-vous pourquoi.  C'est √©vident: non seulement nous voyons le mot <code>Dangerous</code> , ce qui sugg√®re que quelque chose peut mal tourner, mais il y a le mot-cl√© <code>unsafe</code> et l' <code>byte* buffer = stackalloc byte[s_readBufferSize];</code>  (sp√©cifiquement - <code>byte*</code> ) qui changent notre attitude.  C'est un d√©clencheur pour vous de penser: "N'y avait-il pas une autre fa√ßon de le faire"?  Alors, approfondissons la psychanalyse: pourquoi pensez-vous ainsi?  D'une part, nous utilisons des constructions de langage et la syntaxe propos√©e ici est loin, par exemple, de C ++ / CLI, qui permet tout (m√™me l'insertion de code Assembleur pur).  D'un autre c√¥t√©, cette syntaxe semble inhabituelle. </p><br><p>  Le deuxi√®me probl√®me auquel les d√©veloppeurs pensaient implicitement ou explicitement est l'incompatibilit√© des types cha√Æne et char [].  Bien que, logiquement, une cha√Æne soit un tableau de caract√®res, mais vous ne pouvez pas convertir une cha√Æne en char []: vous pouvez uniquement cr√©er un nouvel objet et copier le contenu d'une cha√Æne dans un tableau.  Cette incompatibilit√© est introduite pour optimiser les cha√Ænes en termes de stockage (il n'y a pas de tableaux en lecture seule).  Cependant, des probl√®mes apparaissent lorsque vous commencez √† travailler avec des fichiers.  Comment les lire?  En tant que cha√Æne ou tableau?  Si vous choisissez un tableau, vous ne pouvez pas utiliser certaines m√©thodes con√ßues pour fonctionner avec des cha√Ænes.  Et la lecture sous forme de cha√Æne?  Cela peut √™tre trop long.  Si vous devez ensuite l'analyser, quel analyseur devez-vous choisir pour les types de donn√©es primitifs: vous ne voulez pas toujours les analyser manuellement (entiers, flottants, donn√©s dans diff√©rents formats).  Nous avons beaucoup d'algorithmes √©prouv√©s qui le font plus rapidement et plus efficacement, n'est-ce pas?  Cependant, ces algorithmes fonctionnent souvent avec des cha√Ænes qui ne contiennent rien d'autre qu'un type primitif lui-m√™me.  Il y a donc un dilemme. </p><br><p>  Le troisi√®me probl√®me est que les donn√©es requises par un algorithme font rarement une tranche de donn√©es continue et solide dans une section d'un tableau lu √† partir d'une source.  Par exemple, dans le cas de fichiers ou de donn√©es lus √† partir d'un socket, nous avons une partie de ceux d√©j√† trait√©s par un algorithme, suivis d'une partie de donn√©es qui doivent √™tre trait√©es par notre m√©thode, puis de donn√©es non encore trait√©es.  Id√©alement, notre m√©thode ne veut que les donn√©es pour lesquelles cette m√©thode a √©t√© con√ßue.  Par exemple, une m√©thode qui analyse des entiers ne sera pas satisfaite d'une cha√Æne contenant certains mots avec un nombre attendu quelque part parmi eux.  Cette m√©thode veut un nombre et rien d'autre.  Ou, si nous passons un tableau entier, il est n√©cessaire d'indiquer, par exemple, le d√©calage d'un nombre depuis le d√©but du tableau. </p><br><pre> <code class="plaintext hljs">int ParseInt(char[] input, int index) { while(char.IsDigit(input[index])) { // ... index++; } }</code> </pre> <br><p>  Cependant, cette approche est mauvaise, car cette m√©thode obtient des donn√©es inutiles.  En d'autres termes, <em>la m√©thode est appel√©e pour des contextes pour lesquels elle n'a pas √©t√© con√ßue</em> et doit r√©soudre certaines t√¢ches externes.  C'est une mauvaise conception.  Comment √©viter ces probl√®mes?  En option, nous pouvons utiliser le type <code>ArraySegment&lt;T&gt;</code> qui peut donner acc√®s √† une section d'un tableau: </p><br><pre> <code class="plaintext hljs">int ParseInt(IList&lt;char&gt;[] input) { while(char.IsDigit(input.Array[index])) { // ... index++; } } var arraySegment = new ArraySegment(array, from, length); var res = ParseInt((IList&lt;char&gt;)arraySegment);</code> </pre> <br><p>  Cependant, je pense que c'est trop √† la fois en termes de logique et de diminution des performances.  <code>ArraySegment</code> est mal con√ßu et ralentit l'acc√®s aux √©l√©ments 7 fois plus par rapport aux m√™mes op√©rations effectu√©es avec un tableau. </p><br><p>  Alors, comment pouvons-nous r√©soudre ces probl√®mes?  Comment amener les d√©veloppeurs √† utiliser du code non manag√© et leur donner un outil unifi√© et rapide pour travailler avec des sources de donn√©es h√©t√©rog√®nes: tableaux, cha√Ænes et m√©moire non manag√©e.  Il √©tait n√©cessaire de leur donner un sentiment de confiance qu'ils ne pouvaient pas faire une erreur sans le savoir.  Il √©tait n√©cessaire de leur donner un instrument qui ne diminue pas les types de donn√©es natives en termes de performances mais r√©sout les probl√®mes r√©pertori√©s.  <code>Span&lt;T&gt;</code> types <code>Span&lt;T&gt;</code> et <code>Memory&lt;T&gt;</code> sont exactement ces instruments. </p><br><h2 id="spanlttgt-readonlyspanlttgt">  Span &lt;T&gt;, ReadOnlySpan &lt;T&gt; </h2><br><p>  <code>Span</code> type <code>Span</code> est un instrument permettant de travailler avec des donn√©es dans une section d'un tableau de donn√©es ou avec une sous-plage de ses valeurs.  Comme dans le cas d'un tableau, il permet √† la fois de lire et d'√©crire sur les √©l√©ments de cette sous-gamme, mais avec une contrainte importante: vous obtenez ou cr√©ez un <code>Span&lt;T&gt;</code> uniquement pour un travail <em>temporaire</em> avec un tableau, juste pour appeler un groupe de m√©thodes .  Cependant, pour obtenir une compr√©hension g√©n√©rale, comparons les types de donn√©es pour lesquels <code>Span</code> est con√ßu et examinons ses sc√©narios d'utilisation possibles. </p><br><p>  Le premier type de donn√©es est un tableau habituel.  Les tableaux fonctionnent avec <code>Span</code> de la mani√®re suivante: </p><br><pre> <code class="plaintext hljs"> var array = new [] {1,2,3,4,5,6}; var span = new Span&lt;int&gt;(array, 1, 3); var position = span.BinarySearch(3); Console.WriteLine(span[position]); // -&gt; 3</code> </pre> <br><p>  Dans un premier temps, nous cr√©ons un tableau de donn√©es, comme le montre cet exemple.  Ensuite, nous cr√©ons <code>Span</code> (ou un sous-ensemble) qui fait r√©f√©rence au tableau et rend une plage de valeurs pr√©c√©demment initialis√©e accessible au code qui utilise le tableau. </p><br><p>  Nous voyons ici la premi√®re caract√©ristique de ce type de donn√©es, √† savoir la possibilit√© de cr√©er un certain contexte.  D√©veloppons notre id√©e des contextes: </p><br><pre> <code class="plaintext hljs">void Main() { var array = new [] {'1','2','3','4','5','6'}; var span = new Span&lt;char&gt;(array, 1, 3); if(TryParseInt32(span, out var res)) { Console.WriteLine(res); } else { Console.WriteLine("Failed to parse"); } } public bool TryParseInt32(Span&lt;char&gt; input, out int result) { result = 0; for (int i = 0; i &lt; input.Length; i++) { if(input[i] &lt; '0' || input[i] &gt; '9') return false; result = result * 10 + ((int)input[i] - '0'); } return true; } ----- 234</code> </pre> <br><p>  Comme nous le voyons, <code>Span&lt;T&gt;</code> fournit un acc√®s abstrait √† une plage de m√©moire √† la fois pour la lecture et l'√©criture.  Que nous apporte-t-il?  Si nous nous souvenons √† quoi d'autre nous pouvons utiliser <code>Span</code> , nous penserons aux ressources et cha√Ænes non g√©r√©es: </p><br><pre> <code class="plaintext hljs">// Managed array var array = new[] { '1', '2', '3', '4', '5', '6' }; var arrSpan = new Span&lt;char&gt;(array, 1, 3); if (TryParseInt32(arrSpan, out var res1)) { Console.WriteLine(res1); } // String var srcString = "123456"; var strSpan = srcString.AsSpan(); if (TryParseInt32(strSpan, out var res2)) { Console.WriteLine(res2); } // void * Span&lt;char&gt; buf = stackalloc char[6]; buf[0] = '1'; buf[1] = '2'; buf[2] = '3'; buf[3] = '4'; buf[4] = '5'; buf[5] = '6'; if (TryParseInt32(buf, out var res3)) { Console.WriteLine(res3); } ----- 234 234 234</code> </pre> <br><p>  Cela signifie que <code>Span&lt;T&gt;</code> est un outil pour unifier les fa√ßons de travailler avec la m√©moire, √† la fois g√©r√©e et non g√©r√©e.  Il garantit la s√©curit√© lors de l'utilisation de ces donn√©es lors de la collecte des ordures.  C'est-√†-dire que si les plages de m√©moire avec des ressources non g√©r√©es commencent √† se d√©placer, ce sera s√ªr. </p><br><p>  Cependant, devrions-nous √™tre si excit√©s?  Pourrions-nous y parvenir plus t√¥t?  Par exemple, dans le cas de tableaux g√©r√©s, cela ne fait aucun doute: il vous suffit d'envelopper un tableau dans une autre classe (par exemple, [ArraySegment] existant depuis longtemps ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://referencesource.microsoft.com/#mscorlib/system/ arraysegment.cs, 31</a> )) donnant ainsi une interface similaire et c'est tout.  De plus, vous pouvez faire de m√™me avec des cha√Ænes - elles ont les m√©thodes n√©cessaires.  Encore une fois, il vous suffit d'encapsuler une cha√Æne du m√™me type et de fournir des m√©thodes pour travailler avec.  Cependant, pour stocker une cha√Æne, un tampon et un tableau dans un type, vous aurez beaucoup √† faire avec la conservation des r√©f√©rences √† chaque variante possible dans une seule instance (avec une seule variante active, √©videmment). </p><br><pre> <code class="plaintext hljs">public readonly ref struct OurSpan&lt;T&gt; { private T[] _array; private string _str; private T * _buffer; // ... }</code> </pre> <br><p>  Ou, en fonction de l'architecture, vous pouvez cr√©er trois types qui impl√©mentent une interface uniforme.  Ainsi, il n'est pas possible de cr√©er une interface uniforme entre ces types de donn√©es diff√©rente de <code>Span&lt;T&gt;</code> et de conserver les performances maximales. </p><br><p>  Ensuite, il y a une question de ce qui est <code>ref struct</code> en ce qui concerne <code>Span</code> ?  Ce sont exactement ces ¬´structures qui n'existent que sur pile¬ª dont on entend si souvent parler lors des entretiens d'embauche.  Cela signifie que ce type de donn√©es peut √™tre allou√© uniquement sur la pile et ne peut pas aller au segment de m√©moire.  C'est pourquoi <code>Span</code> , qui est une structure ref, est un type de donn√©es contextuelles qui permet le travail des m√©thodes mais pas celui des objets en m√©moire.  C'est sur cela que nous devons nous baser pour essayer de le comprendre. </p><br><p>  Nous pouvons maintenant d√©finir le type <code>Span</code> et le type <code>ReadOnlySpan</code> associ√©: </p><br><blockquote>  L'√©tendue est un type de donn√©es qui impl√©mente une interface uniforme pour fonctionner avec des types h√©t√©rog√®nes de tableaux de donn√©es et permet de passer un sous-ensemble d'un tableau √† une m√©thode de sorte que la vitesse d'acc√®s au tableau d'origine soit constante et la plus √©lev√©e quelle que soit la profondeur de la contexte. </blockquote><p>  En effet, si nous avons un code comme </p><br><pre> <code class="plaintext hljs">public void Method1(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method2(buffer.Slice(1,2)); } Method2(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method3(buffer.Slice(1,1)); } Method3(Span&lt;byte&gt; buffer) { buffer[0] = 0; }</code> </pre> <br><p>  la vitesse d'acc√®s au tampon d'origine sera la plus √©lev√©e lorsque vous travaillez avec un pointeur g√©r√© et non un objet g√©r√©.  Cela signifie que vous travaillez avec un type non s√©curis√© dans un wrapper manag√©, mais pas avec un type manag√© .NET. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a √©t√© traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure fa√ßon de le faire est de nous donner une √©toile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443974/">https://habr.com/ru/post/fr443974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443962/index.html">Mod√®le jetable (principe de conception jetable) pt.3</a></li>
<li><a href="../fr443964/index.html">Kolesa Conf est la plus grande conf√©rence informatique au Kazakhstan. Annonce des rapports</a></li>
<li><a href="../fr443966/index.html">Google Docs - un chat pr√©f√©r√© des √©tudiants</a></li>
<li><a href="../fr443968/index.html">Comment nous avons achet√© une maison avec des panneaux solaires et ce qui en est arriv√©</a></li>
<li><a href="../fr443972/index.html">Yandex recherchera des pirates √† l'aide d'un robot</a></li>
<li><a href="../fr443976/index.html">M√©moire et √©tendue pt.2</a></li>
<li><a href="../fr443978/index.html">ATtiny13 vs PLC, ou comment obtenir 14 E / S √† partir d'un contr√¥leur de 8 pieds</a></li>
<li><a href="../fr443980/index.html">M√©moire et √©tendue pt.3</a></li>
<li><a href="../fr443984/index.html">La nouvelle norme sur la base de PCIe 5.0 ¬´connectera¬ª le CPU et le GPU - ce que l'on sait</a></li>
<li><a href="../fr443986/index.html">Comme un √©cureuil dans une roue ou un peu sur la recherche d'utilisateurs dans un contexte de handicap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>