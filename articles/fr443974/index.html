<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♒️ 👨🏻‍🎨 👩🏿‍🤝‍👩🏽 Mémoire et étendue pt.1 🤜🏻 🧓🏻 🏏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À partir de .NET Core 2.0 et .NET Framework 4.5, nous pouvons utiliser de nouveaux types de données: Span et Memory . Pour les utiliser, il vous suffi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mémoire et étendue pt.1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443974/"><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  À partir de .NET Core 2.0 et .NET Framework 4.5, nous pouvons utiliser de nouveaux types de données: <code>Span</code> et <code>Memory</code> .  Pour les utiliser, il vous suffit d'installer le package nuget <code>System.Memory</code> : </p><br><blockquote> <code>PM&gt; Install-Package System.Memory</code> </blockquote> <p>  Ces types de données sont remarquables parce que l'équipe CLR a fait un excellent travail pour implémenter leur prise en charge spéciale dans le code du compilateur JIT .NET Core 2.1+ en incorporant ces types de données directement dans le noyau.  De quels types de données s'agit-il et pourquoi valent-elles un chapitre entier? </p><br><p>  Si nous parlons de problèmes qui ont fait apparaître ces types, je devrais en nommer trois.  Le premier est du code non managé. </p><br><p>  Le langage et la plate-forme existent depuis de nombreuses années ainsi que les moyens de travailler avec du code non managé.  Alors, pourquoi publier une autre API pour travailler avec du code non managé si la première existait essentiellement depuis de nombreuses années?  Pour répondre à cette question, nous devons comprendre ce qui nous manquait auparavant. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a été traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure façon de le faire est de nous donner une étoile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Les développeurs de la plateforme ont déjà essayé de faciliter l'utilisation de ressources non gérées pour nous.  Ils ont implémenté des wrappers automatiques pour les méthodes importées et le marshaling qui fonctionne automatiquement dans la plupart des cas.  Ici aussi appartient à <code>stackalloc</code> , mentionné dans le chapitre sur une pile de threads.  Cependant, à mon avis, les premiers développeurs C # sont venus du monde C ++ (mon cas), mais maintenant ils passent de langages plus avancés (je connais un développeur qui a déjà écrit en JavaScript).  Cela signifie que les gens deviennent de plus en plus suspects envers le code non managé et les constructions C / C +, d'autant plus pour Assembler. </p><br><p>  En conséquence, les projets contiennent de moins en moins de code dangereux et la confiance dans l'API de la plate-forme augmente de plus en plus.  Il est facile de vérifier si nous recherchons des cas d'utilisation <code>stackalloc</code> dans les référentiels publics - ils sont rares.  Cependant, prenons tout code qui l'utilise: </p><br><p>  <strong>Classe Interop.ReadDir</strong> <br>  <a href="">/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs</a> </p><br><pre> <code class="plaintext hljs">unsafe { // s_readBufferSize is zero when the native implementation does not support reading into a buffer. byte* buffer = stackalloc byte[s_readBufferSize]; InternalDirectoryEntry temp; int ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, out temp); // We copy data into DirectoryEntry to ensure there are no dangling references. outputEntry = ret == 0 ? new DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } : default(DirectoryEntry); return ret; }</code> </pre> <br><p>  Nous pouvons voir pourquoi il n'est pas populaire.  Parcourez simplement ce code et demandez-vous si vous lui faites confiance.  Je suppose que la réponse est «non».  Ensuite, demandez-vous pourquoi.  C'est évident: non seulement nous voyons le mot <code>Dangerous</code> , ce qui suggère que quelque chose peut mal tourner, mais il y a le mot-clé <code>unsafe</code> et l' <code>byte* buffer = stackalloc byte[s_readBufferSize];</code>  (spécifiquement - <code>byte*</code> ) qui changent notre attitude.  C'est un déclencheur pour vous de penser: "N'y avait-il pas une autre façon de le faire"?  Alors, approfondissons la psychanalyse: pourquoi pensez-vous ainsi?  D'une part, nous utilisons des constructions de langage et la syntaxe proposée ici est loin, par exemple, de C ++ / CLI, qui permet tout (même l'insertion de code Assembleur pur).  D'un autre côté, cette syntaxe semble inhabituelle. </p><br><p>  Le deuxième problème auquel les développeurs pensaient implicitement ou explicitement est l'incompatibilité des types chaîne et char [].  Bien que, logiquement, une chaîne soit un tableau de caractères, mais vous ne pouvez pas convertir une chaîne en char []: vous pouvez uniquement créer un nouvel objet et copier le contenu d'une chaîne dans un tableau.  Cette incompatibilité est introduite pour optimiser les chaînes en termes de stockage (il n'y a pas de tableaux en lecture seule).  Cependant, des problèmes apparaissent lorsque vous commencez à travailler avec des fichiers.  Comment les lire?  En tant que chaîne ou tableau?  Si vous choisissez un tableau, vous ne pouvez pas utiliser certaines méthodes conçues pour fonctionner avec des chaînes.  Et la lecture sous forme de chaîne?  Cela peut être trop long.  Si vous devez ensuite l'analyser, quel analyseur devez-vous choisir pour les types de données primitifs: vous ne voulez pas toujours les analyser manuellement (entiers, flottants, donnés dans différents formats).  Nous avons beaucoup d'algorithmes éprouvés qui le font plus rapidement et plus efficacement, n'est-ce pas?  Cependant, ces algorithmes fonctionnent souvent avec des chaînes qui ne contiennent rien d'autre qu'un type primitif lui-même.  Il y a donc un dilemme. </p><br><p>  Le troisième problème est que les données requises par un algorithme font rarement une tranche de données continue et solide dans une section d'un tableau lu à partir d'une source.  Par exemple, dans le cas de fichiers ou de données lus à partir d'un socket, nous avons une partie de ceux déjà traités par un algorithme, suivis d'une partie de données qui doivent être traitées par notre méthode, puis de données non encore traitées.  Idéalement, notre méthode ne veut que les données pour lesquelles cette méthode a été conçue.  Par exemple, une méthode qui analyse des entiers ne sera pas satisfaite d'une chaîne contenant certains mots avec un nombre attendu quelque part parmi eux.  Cette méthode veut un nombre et rien d'autre.  Ou, si nous passons un tableau entier, il est nécessaire d'indiquer, par exemple, le décalage d'un nombre depuis le début du tableau. </p><br><pre> <code class="plaintext hljs">int ParseInt(char[] input, int index) { while(char.IsDigit(input[index])) { // ... index++; } }</code> </pre> <br><p>  Cependant, cette approche est mauvaise, car cette méthode obtient des données inutiles.  En d'autres termes, <em>la méthode est appelée pour des contextes pour lesquels elle n'a pas été conçue</em> et doit résoudre certaines tâches externes.  C'est une mauvaise conception.  Comment éviter ces problèmes?  En option, nous pouvons utiliser le type <code>ArraySegment&lt;T&gt;</code> qui peut donner accès à une section d'un tableau: </p><br><pre> <code class="plaintext hljs">int ParseInt(IList&lt;char&gt;[] input) { while(char.IsDigit(input.Array[index])) { // ... index++; } } var arraySegment = new ArraySegment(array, from, length); var res = ParseInt((IList&lt;char&gt;)arraySegment);</code> </pre> <br><p>  Cependant, je pense que c'est trop à la fois en termes de logique et de diminution des performances.  <code>ArraySegment</code> est mal conçu et ralentit l'accès aux éléments 7 fois plus par rapport aux mêmes opérations effectuées avec un tableau. </p><br><p>  Alors, comment pouvons-nous résoudre ces problèmes?  Comment amener les développeurs à utiliser du code non managé et leur donner un outil unifié et rapide pour travailler avec des sources de données hétérogènes: tableaux, chaînes et mémoire non managée.  Il était nécessaire de leur donner un sentiment de confiance qu'ils ne pouvaient pas faire une erreur sans le savoir.  Il était nécessaire de leur donner un instrument qui ne diminue pas les types de données natives en termes de performances mais résout les problèmes répertoriés.  <code>Span&lt;T&gt;</code> types <code>Span&lt;T&gt;</code> et <code>Memory&lt;T&gt;</code> sont exactement ces instruments. </p><br><h2 id="spanlttgt-readonlyspanlttgt">  Span &lt;T&gt;, ReadOnlySpan &lt;T&gt; </h2><br><p>  <code>Span</code> type <code>Span</code> est un instrument permettant de travailler avec des données dans une section d'un tableau de données ou avec une sous-plage de ses valeurs.  Comme dans le cas d'un tableau, il permet à la fois de lire et d'écrire sur les éléments de cette sous-gamme, mais avec une contrainte importante: vous obtenez ou créez un <code>Span&lt;T&gt;</code> uniquement pour un travail <em>temporaire</em> avec un tableau, juste pour appeler un groupe de méthodes .  Cependant, pour obtenir une compréhension générale, comparons les types de données pour lesquels <code>Span</code> est conçu et examinons ses scénarios d'utilisation possibles. </p><br><p>  Le premier type de données est un tableau habituel.  Les tableaux fonctionnent avec <code>Span</code> de la manière suivante: </p><br><pre> <code class="plaintext hljs"> var array = new [] {1,2,3,4,5,6}; var span = new Span&lt;int&gt;(array, 1, 3); var position = span.BinarySearch(3); Console.WriteLine(span[position]); // -&gt; 3</code> </pre> <br><p>  Dans un premier temps, nous créons un tableau de données, comme le montre cet exemple.  Ensuite, nous créons <code>Span</code> (ou un sous-ensemble) qui fait référence au tableau et rend une plage de valeurs précédemment initialisée accessible au code qui utilise le tableau. </p><br><p>  Nous voyons ici la première caractéristique de ce type de données, à savoir la possibilité de créer un certain contexte.  Développons notre idée des contextes: </p><br><pre> <code class="plaintext hljs">void Main() { var array = new [] {'1','2','3','4','5','6'}; var span = new Span&lt;char&gt;(array, 1, 3); if(TryParseInt32(span, out var res)) { Console.WriteLine(res); } else { Console.WriteLine("Failed to parse"); } } public bool TryParseInt32(Span&lt;char&gt; input, out int result) { result = 0; for (int i = 0; i &lt; input.Length; i++) { if(input[i] &lt; '0' || input[i] &gt; '9') return false; result = result * 10 + ((int)input[i] - '0'); } return true; } ----- 234</code> </pre> <br><p>  Comme nous le voyons, <code>Span&lt;T&gt;</code> fournit un accès abstrait à une plage de mémoire à la fois pour la lecture et l'écriture.  Que nous apporte-t-il?  Si nous nous souvenons à quoi d'autre nous pouvons utiliser <code>Span</code> , nous penserons aux ressources et chaînes non gérées: </p><br><pre> <code class="plaintext hljs">// Managed array var array = new[] { '1', '2', '3', '4', '5', '6' }; var arrSpan = new Span&lt;char&gt;(array, 1, 3); if (TryParseInt32(arrSpan, out var res1)) { Console.WriteLine(res1); } // String var srcString = "123456"; var strSpan = srcString.AsSpan(); if (TryParseInt32(strSpan, out var res2)) { Console.WriteLine(res2); } // void * Span&lt;char&gt; buf = stackalloc char[6]; buf[0] = '1'; buf[1] = '2'; buf[2] = '3'; buf[3] = '4'; buf[4] = '5'; buf[5] = '6'; if (TryParseInt32(buf, out var res3)) { Console.WriteLine(res3); } ----- 234 234 234</code> </pre> <br><p>  Cela signifie que <code>Span&lt;T&gt;</code> est un outil pour unifier les façons de travailler avec la mémoire, à la fois gérée et non gérée.  Il garantit la sécurité lors de l'utilisation de ces données lors de la collecte des ordures.  C'est-à-dire que si les plages de mémoire avec des ressources non gérées commencent à se déplacer, ce sera sûr. </p><br><p>  Cependant, devrions-nous être si excités?  Pourrions-nous y parvenir plus tôt?  Par exemple, dans le cas de tableaux gérés, cela ne fait aucun doute: il vous suffit d'envelopper un tableau dans une autre classe (par exemple, [ArraySegment] existant depuis longtemps ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://referencesource.microsoft.com/#mscorlib/system/ arraysegment.cs, 31</a> )) donnant ainsi une interface similaire et c'est tout.  De plus, vous pouvez faire de même avec des chaînes - elles ont les méthodes nécessaires.  Encore une fois, il vous suffit d'encapsuler une chaîne du même type et de fournir des méthodes pour travailler avec.  Cependant, pour stocker une chaîne, un tampon et un tableau dans un type, vous aurez beaucoup à faire avec la conservation des références à chaque variante possible dans une seule instance (avec une seule variante active, évidemment). </p><br><pre> <code class="plaintext hljs">public readonly ref struct OurSpan&lt;T&gt; { private T[] _array; private string _str; private T * _buffer; // ... }</code> </pre> <br><p>  Ou, en fonction de l'architecture, vous pouvez créer trois types qui implémentent une interface uniforme.  Ainsi, il n'est pas possible de créer une interface uniforme entre ces types de données différente de <code>Span&lt;T&gt;</code> et de conserver les performances maximales. </p><br><p>  Ensuite, il y a une question de ce qui est <code>ref struct</code> en ce qui concerne <code>Span</code> ?  Ce sont exactement ces «structures qui n'existent que sur pile» dont on entend si souvent parler lors des entretiens d'embauche.  Cela signifie que ce type de données peut être alloué uniquement sur la pile et ne peut pas aller au segment de mémoire.  C'est pourquoi <code>Span</code> , qui est une structure ref, est un type de données contextuelles qui permet le travail des méthodes mais pas celui des objets en mémoire.  C'est sur cela que nous devons nous baser pour essayer de le comprendre. </p><br><p>  Nous pouvons maintenant définir le type <code>Span</code> et le type <code>ReadOnlySpan</code> associé: </p><br><blockquote>  L'étendue est un type de données qui implémente une interface uniforme pour fonctionner avec des types hétérogènes de tableaux de données et permet de passer un sous-ensemble d'un tableau à une méthode de sorte que la vitesse d'accès au tableau d'origine soit constante et la plus élevée quelle que soit la profondeur de la contexte. </blockquote><p>  En effet, si nous avons un code comme </p><br><pre> <code class="plaintext hljs">public void Method1(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method2(buffer.Slice(1,2)); } Method2(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method3(buffer.Slice(1,1)); } Method3(Span&lt;byte&gt; buffer) { buffer[0] = 0; }</code> </pre> <br><p>  la vitesse d'accès au tampon d'origine sera la plus élevée lorsque vous travaillez avec un pointeur géré et non un objet géré.  Cela signifie que vous travaillez avec un type non sécurisé dans un wrapper managé, mais pas avec un type managé .NET. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Ce chapitre a été traduit du russe conjointement par l'auteur et par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des traducteurs professionnels</a> .  Vous pouvez nous aider avec la traduction du russe ou de l'anglais dans n'importe quelle autre langue, principalement en chinois ou en allemand. <br><br>  Aussi, si vous voulez nous remercier, la meilleure façon de le faire est de nous donner une étoile sur github ou sur fork repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443974/">https://habr.com/ru/post/fr443974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443962/index.html">Modèle jetable (principe de conception jetable) pt.3</a></li>
<li><a href="../fr443964/index.html">Kolesa Conf est la plus grande conférence informatique au Kazakhstan. Annonce des rapports</a></li>
<li><a href="../fr443966/index.html">Google Docs - un chat préféré des étudiants</a></li>
<li><a href="../fr443968/index.html">Comment nous avons acheté une maison avec des panneaux solaires et ce qui en est arrivé</a></li>
<li><a href="../fr443972/index.html">Yandex recherchera des pirates à l'aide d'un robot</a></li>
<li><a href="../fr443976/index.html">Mémoire et étendue pt.2</a></li>
<li><a href="../fr443978/index.html">ATtiny13 vs PLC, ou comment obtenir 14 E / S à partir d'un contrôleur de 8 pieds</a></li>
<li><a href="../fr443980/index.html">Mémoire et étendue pt.3</a></li>
<li><a href="../fr443984/index.html">La nouvelle norme sur la base de PCIe 5.0 «connectera» le CPU et le GPU - ce que l'on sait</a></li>
<li><a href="../fr443986/index.html">Comme un écureuil dans une roue ou un peu sur la recherche d'utilisateurs dans un contexte de handicap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>