<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏽 🍠 👨🏼‍🚀 Wir segmentieren täglich 600 Millionen Benutzer in Echtzeit 💆🏿 ⤴️ 👨🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeden Tag führen Benutzer Millionen von Online-Aktivitäten durch. Das FACETz DMP-Projekt muss diese Daten strukturieren und segmentieren, um Benutzerp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir segmentieren täglich 600 Millionen Benutzer in Echtzeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/421125/">  Jeden Tag führen Benutzer Millionen von Online-Aktivitäten durch.  Das FACETz DMP-Projekt muss diese Daten strukturieren und segmentieren, um Benutzerpräferenzen zu identifizieren.  In dem Artikel werden wir darüber sprechen, wie das Team ein Publikum von 600 Millionen Menschen segmentierte, täglich 5 Milliarden Ereignisse verarbeitete und mit Statistiken unter Verwendung von Kafka und HBase arbeitete. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5Ybt_k53CIE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Das Material basiert auf einer Abschrift eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichts von Artyom Marinov</a> , einem Big-Data-Spezialisten bei Directual, von der SmartData 2017-Konferenz. <br><a name="habracut"></a><br>  Mein Name ist Artyom Marinov. Ich möchte darüber sprechen, wie wir die Architektur des FACETz DMP-Projekts neu gestaltet haben, als ich bei Data Centric Alliance gearbeitet habe.  Warum wir es getan haben, wozu es geführt hat, welchen Weg wir gegangen sind und auf welche Probleme wir gestoßen sind. <br><br>  DMP (Data Management Platform) ist eine Plattform zum Sammeln, Verarbeiten und Aggregieren von Benutzerdaten.  Daten sind viele verschiedene Dinge.  Die Plattform hat ungefähr 600 Millionen Benutzer.  Dies sind Millionen von Cookies, die ins Internet gehen und verschiedene Ereignisse auslösen.  Im Allgemeinen sieht ein Tag im Durchschnitt ungefähr so ​​aus: Wir sehen ungefähr 5,5 Milliarden Ereignisse pro Tag, sie sind irgendwie nach Tag verteilt und erreichen auf dem Höhepunkt ungefähr 100.000 Ereignisse pro Sekunde. <img src="https://habrastorage.org/getpro/habr/post_images/f66/f4d/915/f66f4d9154b1ddad3c3bb8af7e5ba860.png">  Ereignisse sind verschiedene Benutzersignale.  Zum Beispiel ein Besuch auf einer Site: Wir sehen, von welchem ​​Browser der Benutzer geht, von welchem ​​Useragent und von allem, was wir extrahieren können.  Manchmal sehen wir, wie und für welche Suchanfragen er auf die Website kam.  Es können auch verschiedene Daten aus der Offline-Welt sein, zum Beispiel was es mit Rabattgutscheinen bezahlt und so weiter. <br><br>  Wir müssen diese Daten speichern und den Benutzer in die sogenannten Gruppen von Zielgruppensegmenten einordnen.  Zum Beispiel können die Segmente eine "Frau" sein, die "Katzen liebt" und nach "Autoservice" sucht, sie "hat ein Auto, das älter als drei Jahre ist". <br><br>  Warum einen Benutzer segmentieren?  Hierfür gibt es viele Anwendungen, zum Beispiel Werbung.  Verschiedene Werbenetzwerke können Algorithmen für die Anzeigenschaltung optimieren.  Wenn Sie für Ihren Autoservice werben, können Sie eine Kampagne so einrichten, dass nur Personen mit einem alten Auto Informationen anzeigen, ausgenommen Besitzer neuer.  Sie können den Inhalt der Website dynamisch ändern, Sie können die Daten für die Bewertung verwenden - es gibt viele Anwendungen. <br><br>  Daten werden von vielen völlig unterschiedlichen Orten erhalten.  Dies können direkte Pixeleinstellungen sein. Wenn der Kunde sein Publikum analysieren möchte, platziert er das Pixel auf der Website, ein unsichtbares Bild, das von unserem Server heruntergeladen wird.  Unter dem Strich sehen wir den Besuch des Benutzers auf dieser Website: Sie können ihn speichern, mit der Analyse und dem Verständnis des Porträts des Benutzers beginnen. Alle diese Informationen stehen unserem Kunden zur Verfügung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad9/ebf/849/ad9ebf84913e17fb9e84a947b256a810.png"><br>  Daten können von verschiedenen Partnern abgerufen werden, die viele Daten sehen und diese auf verschiedene Weise monetarisieren möchten.  Partner können Daten sowohl in Echtzeit bereitstellen als auch regelmäßig in Form von Dateien hochladen. <br><br>  Hauptanforderungen: <br><br><ul><li>  Horizontale Skalierbarkeit; </li><li>  Einschätzung des Publikumsvolumens; </li><li>  Bequemlichkeit der Überwachung und Entwicklung; </li><li>  Gute Reaktionsgeschwindigkeit auf Ereignisse. </li></ul><br>  Eine der Hauptanforderungen des Systems ist die horizontale Skalierbarkeit.  Es gibt einen solchen Moment, in dem Sie bei der Entwicklung eines Portals oder Online-Shops die Anzahl Ihrer Benutzer schätzen können (wie es wachsen wird, wie es sich ändern wird) und ungefähr verstehen können, wie viel Ressourcen benötigt werden und wie das Geschäft im Laufe der Zeit leben und sich entwickeln wird. <br><br>  Wenn Sie eine Plattform entwickeln, die DMP ähnlich ist, müssen Sie darauf vorbereitet sein, dass jede große Site - die bedingte Amazon - Ihre Pixel darin platzieren kann, und Sie müssen mit dem Verkehr dieser gesamten Site arbeiten, während Sie nicht fallen sollten, und den Indikatoren Systeme sollten sich davon irgendwie nicht ändern. <br><br>  Es ist auch sehr wichtig, das Volumen eines bestimmten Publikums zu verstehen, damit ein potenzieller Werbetreibender oder eine andere Person einen Medienplan ausarbeiten kann.  Zum Beispiel kommt eine Person zu Ihnen und fragt Sie, wie viele schwangere Frauen aus Nowosibirsk nach einer Hypothek suchen, um zu beurteilen, ob es sinnvoll ist, sie gezielt anzusprechen oder nicht. <br><br>  Unter dem Gesichtspunkt der Entwicklung müssen Sie in der Lage sein, alles, was in Ihrem System geschieht, kühl zu überwachen, einen Teil des tatsächlichen Datenverkehrs zu debuggen und so weiter. <br><br>  Eine der wichtigsten Systemanforderungen ist eine gute Reaktionsgeschwindigkeit auf Ereignisse.  Je schneller die Systeme auf Ereignisse reagieren, desto besser ist dies offensichtlich.  Wenn Sie nach Theaterkarten suchen, dann sehen Sie nach einem Tag, zwei Tagen oder sogar einer Stunde ein Rabattangebot - dies kann irrelevant sein, da Sie bereits Tickets kaufen oder zu einer Aufführung gehen könnten.  Wenn Sie nach einem Bohrer suchen - Sie suchen danach, finden, kaufen, hängen ein Regal auf und nach ein paar Tagen beginnt das Bombardement: „Kaufen Sie einen Bohrer!“. <br><br><h3>  Wie zuvor </h3><br>  Der gesamte Artikel befasst sich mit dem Recycling von Architektur.  Ich möchte Ihnen sagen, was unser Ausgangspunkt war, wie alles vor den Änderungen funktioniert hat. <br><br>  Alle Daten, die wir hatten, ob es sich um einen direkten Datenstrom oder um Protokolle handelte, wurden in einem HDFS-verteilten Dateispeicher gespeichert.  Dann gab es einen bestimmten Prozess, der regelmäßig gestartet wurde, alle unverarbeiteten Dateien aus HDFS nahm und sie in Datenanreicherungsanforderungen in HBase konvertierte („PUT-Anforderungen“). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c6/902/3eb/3c69023eb0fc851d8acc327a7b57fb22.png"><br><br><h3>  Wie speichern wir Daten in HBase? </h3><br>  Dies ist eine spaltenweise Zeitreihendatenbank.  Sie hat das Konzept eines Zeilenschlüssels - dies ist der Schlüssel, unter dem Sie Ihre Daten speichern.  Wir verwenden die Benutzer-ID als Schlüssel, die Benutzer-ID, die wir generieren, wenn wir den Benutzer zum ersten Mal sehen.  In jedem Schlüssel sind die Daten in Spaltenfamilien unterteilt - Entitäten, auf deren Ebene Sie die Metainformationen Ihrer Daten verwalten können.  Sie können beispielsweise tausend Versionen von Datensätzen für „Daten“ der Spaltenfamilie speichern und diese zwei Monate lang speichern, und für die „Rohdaten“ der Spaltenfamilie - optional ein Jahr. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89f/fb5/46e/89ffb546efcad40cd08d140df54ac6a4.png"><br>  Innerhalb der Spaltenfamilie gibt es viele Spaltenqualifizierer (im Folgenden Spalte).  Wir verwenden verschiedene Benutzerattribute als Spalte.  Es könnte die URL sein, zu der er gegangen ist, IP-Adresse, Suchanfrage.  Und am wichtigsten ist, dass in jeder Spalte viele Informationen gespeichert sind.  Innerhalb der Spalten-URL kann angegeben werden, dass der Benutzer zu smartdataconf.ru und dann zu einigen anderen Websites gegangen ist.  Als Version wird der Zeitstempel verwendet. Sie sehen einen geordneten Verlauf der Benutzerbesuche.  In unserem Fall können wir feststellen, dass der Benutzer mit dem Schlüsselwort "Konferenz" auf die smartdataconf-Website gelangt ist, da er denselben Zeitstempel hat. <br><br><h3>  Arbeite mit HBase </h3><br>  Es gibt verschiedene Möglichkeiten, mit HBase zu arbeiten.  Dies können PUT-Anforderungen (Anforderung zur Datenänderung), GET-Anforderung ("Geben Sie mir alle Daten zum Benutzer Vasya" usw.) sein.  Sie können SCAN-Anforderungen ausführen - sequentielles Multithread-Scannen aller Daten in HBase.  Wir haben dies früher zum Markieren in Zielgruppensegmenten verwendet. <br><br>  Es gab eine Aufgabe namens Analytics Engine, die einmal am Tag ausgeführt und HBase in mehreren Threads gescannt wurde.  Für jeden Benutzer hat sie die gesamte Geschichte aus HBase entfernt und eine Reihe von Analyseskripten durchlaufen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fba/b4c/674/fbab4c674fabf2f07e0dc8553e8b6cfc.png"><br>  Was ist ein Analyseskript?  Dies ist eine Art Black Box (Java-Klasse), die alle Benutzerdaten als Eingabe empfängt und eine Reihe von Segmenten angibt, die sie als Ausgabe als geeignet erachtet.  Wir geben alles an das Skript, das wir sehen - IP, Besuche, UserAgent usw., und in der Ausgabe geben die Skripte Folgendes aus: „Dies ist eine Frau, liebt Katzen, mag keine Hunde“. <br><br>  Diese Daten wurden an Partner weitergegeben, Statistiken wurden berücksichtigt.  Für uns war es wichtig zu verstehen, wie viele Frauen im Allgemeinen sind, wie viele Männer, wie viele Menschen Katzen lieben, wie viele ein Auto haben oder nicht und so weiter. <br><br>  Wir haben Statistiken in MongoDB gespeichert und geschrieben, indem wir für jeden Tag einen bestimmten Segmentzähler erhöht haben.  Wir hatten eine grafische Darstellung des Volumens jedes Segments für jeden Tag. <br><br>  Dieses System war gut für seine Zeit.  Es erlaubte, horizontal zu skalieren, zu wachsen, das Volumen des Publikums zu schätzen, aber es hatte eine Reihe von Nachteilen. <br><br>  Es war nicht immer möglich zu verstehen, was im System vor sich ging, um die Protokolle zu betrachten.  Während wir beim vorherigen Hoster waren, fiel die Aufgabe aus verschiedenen Gründen ziemlich oft.  Es gab einen Hadoop-Cluster mit mehr als 20 Servern, einmal am Tag stürzte einer der Server stabil ab.  Dies führte dazu, dass die Aufgabe teilweise fallen konnte und die Daten nicht berechnet wurden.  Es war notwendig, Zeit zu haben, um es neu zu starten, und da es mehrere Stunden funktionierte, gab es eine Reihe bestimmter Nuancen. <br><br>  Das Grundlegendste, was die vorhandene Architektur nicht erfüllte, war, dass die Reaktionszeit auf das Ereignis zu lang war.  Es gibt sogar eine Geschichte zu diesem Thema.  Es gab ein Unternehmen, das der Bevölkerung in den Regionen Mikrokredite gewährte, und wir haben mit ihnen zusammengearbeitet.  Ihr Kunde kommt auf die Website, füllt einen Antrag auf Mikrokredit aus, das Unternehmen muss innerhalb von 15 Minuten eine Antwort geben: Sind sie bereit, einen Kredit zu vergeben oder nicht?  Wenn Sie bereit sind, haben sie sofort Geld auf die Karte überwiesen. <br><br>  Alles hat irgendwie gut funktioniert.  Der Kunde entschied sich zu überprüfen, wie es im Allgemeinen passiert: Er nahm einen separaten Laptop, installierte ein sauberes System, besuchte viele Seiten im Internet und ging zu seiner Website.  Sie sehen, dass es eine Anfrage gibt, und als Antwort sagen wir, dass es noch keine Daten gibt.  Der Kunde fragt: "Warum gibt es keine Daten?" <br><br>  Wir erklären: Es gibt eine gewisse Verzögerung, bevor der Benutzer eine Aktion ausführt.  Daten werden an HBase gesendet, verarbeitet und erst dann erhält der Client das Ergebnis.  Es scheint, dass nichts Schlimmes passieren wird, wenn der Benutzer die Werbung nicht gesehen hat - alles ist in Ordnung.  In dieser Situation erhält der Benutzer aufgrund der Verzögerung möglicherweise kein Darlehen. <br><br>  Dies ist kein Einzelfall, und es musste auf ein Echtzeitsystem umgestellt werden.  Was wollen wir von ihr? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad8/103/d08/ad8103d08bb70410bcc51c8fdd99b3f5.png"><br>  Wir möchten Daten in HBase schreiben, sobald wir sie sehen.  Wir haben einen Besuch gesehen, alles, was wir wissen, bereichert und an Storage gesendet.  Sobald sich die Daten im Speicher geändert haben, müssen Sie sofort alle vorhandenen Analyseskripts ausführen.  Wir möchten die Bequemlichkeit der Überwachung und Entwicklung, die Fähigkeit, neue Skripte zu schreiben und sie in Teile des realen Datenverkehrs zu debuggen.  Wir möchten verstehen, was das System gerade beschäftigt. <br><br>  Das erste, mit dem wir begonnen haben, ist die Lösung des zweiten Problems: Segmentieren Sie den Benutzer unmittelbar nach dem Ändern der Daten über ihn in HBase.  Anfänglich hatten wir Worker-Knoten (auf denen Kartenreduzierungsaufgaben gestartet wurden) am selben Ort wie HBase.  In einigen Fällen war es sehr gut - die Berechnungen werden neben den Daten durchgeführt, Aufgaben funktionieren recht schnell, wenig Verkehr geht durch das Netzwerk.  Es ist klar, dass die Aufgabe einige Ressourcen verbraucht, da sie komplexe Analyseskripte ausführt. <br><br>  Wenn wir in Echtzeit zur Arbeit gehen, ändert sich die Art der Belastung von HBase.  Wir gehen zu zufälligen statt zu sequentiellen Messwerten über.  Es ist wichtig, dass die Belastung von HBase erwartet wird. Wir können nicht zulassen, dass jemand die Aufgabe auf dem Hadoop-Cluster ausführt und die HBase-Leistung beeinträchtigt. <br><br>  Als erstes haben wir HBase auf separate Server verschoben.  Außerdem wurden BlockCache und BloomFilter optimiert.  Dann haben wir gute Arbeit geleistet, um Daten in HBase zu speichern.  Sie haben das System, über das ich am Anfang gesprochen habe, ziemlich überarbeitet und die Daten selbst geerntet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/191/f68/3c9/191f683c9cddf8d90f43cafc5c1163a3.png"><br>  Aus dem Offensichtlichen: Wir haben IP als Zeichenfolge gespeichert und sind in Zahlen lang geworden.  Einige Daten wurden klassifiziert, Vokabeln ausgeführt und so weiter.  Unter dem Strich konnten wir HBase deshalb etwa zweimal schütteln - von 10 TB auf 5 TB.  HBase hat einen ähnlichen Mechanismus wie Trigger in einer regulären Datenbank.  Dies ist ein Coprozessormechanismus.  Wir haben einen Coprozessor geschrieben, der beim Wechsel eines Benutzers zu HBase die Benutzer-ID an Kafka sendet. <br><br>  Die Benutzer-ID befindet sich in Kafka.  Weiterhin gibt es einen bestimmten Service "Segmentator".  Es liest den Strom von Benutzerkennungen und führt auf ihnen dieselben Skripte wie zuvor aus und fordert Daten von HBase an.  Der Prozess wurde bei 10% des Datenverkehrs gestartet. Wir haben uns angesehen, wie er funktioniert.  Alles war ziemlich gut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c1/589/928/8c15899287c8a623bb63df3f85ba84e6.png"><br>  Als nächstes begannen wir, die Last zu erhöhen und sahen eine Reihe von Problemen.  Das erste, was wir sahen, war, dass der Service funktioniert, segmentiert und dann von Kafka abfällt, eine Verbindung herstellt und wieder funktioniert.  Mehrere Dienste - sie helfen sich gegenseitig.  Dann fällt der nächste ab, ein anderer und so weiter im Kreis.  Gleichzeitig wird die Aufstellung der Benutzer für die Segmentierung fast nicht geharkt. <br><br>  Dies lag an der Besonderheit des Herzschlagmechanismus in Kafka, damals war es noch Version 0.8.  Herzschlag ist, wenn die Verbraucher dem Broker mitteilen, ob sie am Leben sind oder nicht, in unserem Fall berichtet der Segmentierer.  Folgendes ist passiert: Wir haben ein ziemlich großes Datenpaket erhalten und zur Verarbeitung gesendet.  Für eine Weile funktionierte es, während es funktionierte - es wurde kein Herzschlag gesendet.  Makler glaubten, dass der Verbraucher tot war, und schalteten ihn aus. <br><br>  Der Verbraucher arbeitete bis zum Ende, verschwendete wertvolle CPUs und versuchte zu sagen, dass das Datenpaket ausgearbeitet wurde und das nächste genommen werden konnte, aber er wurde abgelehnt, weil der andere wegnahm, womit er arbeitete.  Wir haben es behoben, indem wir unseren Hintergrund-Heatbeat gemacht haben. Dann kam die Wahrheit zu einer neueren Version von Kafka, bei der wir dieses Problem behoben haben. <br><br>  Dann stellte sich die Frage: Auf welcher Hardware sollten unsere Segmentatoren installiert werden?  Die Segmentierung ist ein ressourcenintensiver Prozess (CPU-gebunden).  Es ist wichtig, dass der Dienst nicht nur viel CPU verbraucht, sondern auch das Netzwerk lädt.  Jetzt erreicht der Verkehr 5 Gbit / s.  Die Frage war: Wo sollen die Dienste auf vielen kleinen oder kleinen Servern abgelegt werden? <br><br>  Zu diesem Zeitpunkt sind wir bereits auf Bare Metal zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">servers.com gewechselt</a> .  Wir haben mit den Jungs von den Servern gesprochen, sie haben uns geholfen und es ermöglicht, die Arbeit unserer Lösung sowohl auf einer kleinen Anzahl teurer Server als auch auf vielen kostengünstigen Servern mit leistungsstarken CPUs zu testen.  Wir haben die entsprechende Option ausgewählt und die Stückkosten für die Verarbeitung eines Ereignisses pro Sekunde berechnet.  Übrigens fiel die Wahl auf ausreichend leistungsfähiges und gleichzeitig äußerst erschwingliches Dell R230, sie haben es auf den Markt gebracht - alles hat funktioniert. <br><br>  Es ist wichtig, dass, nachdem der Segmentierer den Benutzer in Segmente markiert hat, das Ergebnis seiner Analyse in einem bestimmten Thema Segmentierungsergebnis auf Kafka zurückgreift. <br><br>  Darüber hinaus können wir unabhängig voneinander verschiedene Verbraucher mit diesen Daten verbinden, die sich nicht gegenseitig stören.  Auf diese Weise können wir jedem Partner unabhängig Daten geben, sei es einigen externen Partnern, internen DSP, Google oder Statistiken. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e7/051/526/1e705152621996ed538a6a3910e8db47.png"><br>  Bei Statistiken gibt es auch einen interessanten Punkt: Früher konnten wir den Wert von Zählern in MongoDB erhöhen, wie viele Benutzer sich an einem bestimmten Tag in einem bestimmten Segment befanden.  Dies ist jetzt nicht möglich, da wir jetzt jeden Benutzer analysieren, nachdem er ein Ereignis abgeschlossen hat, d. H.  mehrmals am Tag. <br><br>  Daher mussten wir das Problem lösen, die eindeutige Anzahl von Benutzern im Stream zu zählen.  Zu diesem Zweck haben wir die HyperLogLog-Datenstruktur und ihre Implementierung in Redis verwendet.  Die Datenstruktur ist probabilistisch.  Dies bedeutet, dass Sie dort Benutzerkennungen hinzufügen können. Die Kennungen selbst werden nicht gespeichert, sodass Sie Millionen von eindeutigen Kennungen in HyperLogLog äußerst kompakt speichern können. Dies dauert bis zu 12 Kilobyte pro Schlüssel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a6/572/614/2a6572614da5ccffd52271292e646e9d.png"><br><br>  Sie können die Bezeichner nicht selbst erhalten, aber Sie können die Größe dieses Satzes herausfinden.  Da die Datenstruktur probabilistisch ist, liegt ein Fehler vor.  Wenn Sie beispielsweise ein Segment haben, das Katzen mag und für einen bestimmten Tag eine Anfrage nach der Größe dieses Segments stellt, erhalten Sie 99,2 Millionen und dies bedeutet etwa „von 99 Millionen auf 100 Millionen“. <br><br>  Auch in HyperLogLog können Sie die Größe der Vereinigung mehrerer Sätze ermitteln.  Angenommen, Sie haben zwei Segmente: "liebt Robben" und "liebt Hunde".  Sagen wir die ersten 100 Millionen, die zweiten 1 Million. Man kann fragen: "Wie viele Tiere mögen sie?"  und erhalten Sie die Antwort "ungefähr 101 Millionen" mit einem Fehler von 1%.  Es wäre interessant zu berechnen, wie sehr Katzen und Hunde gleichzeitig geliebt werden, aber dies zu tun ist ziemlich schwierig. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/380/74d/500/38074d5004513c86015c8d2770047f56.png"><br>  Einerseits können Sie die Größe jedes Satzes ermitteln, die Größe der Vereinigung ermitteln, addieren, voneinander subtrahieren und den Schnittpunkt ermitteln.  Aufgrund der Tatsache, dass die Größe des Fehlers größer sein kann als die Größe des endgültigen Schnittpunkts, kann das Endergebnis die Form "von -50 bis 50.000" haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/3ba/520/08d3ba520f5c91efd84822d63f299c83.png"><br>  Wir haben viel daran gearbeitet, die Leistung beim Schreiben von Daten in Redis zu steigern.  Anfangs erreichten wir 200.000 Operationen pro Sekunde.  Wenn jedoch jeder Benutzer mehr als 50 Segmente hat - Informationen über jeden Benutzer aufzeichnen - 50 Vorgänge.  Es stellt sich heraus, dass wir nur eine begrenzte Bandbreite haben und in diesem Beispiel keine Informationen über mehr als 4.000 Benutzer pro Sekunde schreiben können. Dies ist um ein Vielfaches weniger als erforderlich. <br><br>  Wir haben über Lua eine separate „gespeicherte Prozedur“ in Redis erstellt, dort geladen und eine Zeichenfolge mit der gesamten Liste der Segmente eines Benutzers übergeben.  Die darin enthaltene Prozedur schneidet die übergebene Zeichenfolge in die erforderlichen HyperLogLog-Updates und speichert die Daten, sodass wir ungefähr 1 Million Updates pro Sekunde erreicht haben. <br><br>  Ein bisschen Hardcore: Redis ist Single-Threaded, Sie können es an einen Prozessorkern und eine Netzwerkkarte an einen anderen anheften und eine weitere Leistung von 15% erzielen, wodurch Kontextwechsel eingespart werden.  Darüber hinaus ist der wichtige Punkt, dass Sie die Datenstruktur nicht einfach gruppieren können, da die Operationen zum Erhalten der Leistung der Gruppenvereinigungen nicht gruppiert werden <br><br><h3>  Kafka ist ein großartiges Werkzeug </h3><br>  Sie sehen, dass Kafka unser Haupttransportinstrument im System ist. <br>  Es hat die Essenz von "Thema".  Hier schreiben Sie die Daten, aber im Wesentlichen die Warteschlange.  In unserem Fall gibt es mehrere Warteschlangen.  Eine davon sind Kennungen von Benutzern, die segmentiert werden müssen.  Das zweite sind Segmentierungsergebnisse. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f35/eb3/8c2/f35eb38c205fec791ea2f42d41a8c875.png"><br>  Ein Thema ist eine Reihe von Partitionen.  Es ist in einige Teile unterteilt.  Jede Partition ist eine Datei auf der Festplatte.  Wenn Ihre Produzenten Daten schreiben, schreiben sie Textstücke an das Ende der Partition.  Wenn Ihre Kunden die Daten lesen, lesen sie einfach von diesen Partitionen. <br><br>  Wichtig ist, dass Sie mehrere Verbrauchergruppen unabhängig voneinander verbinden können. Diese verbrauchen Daten, ohne sich gegenseitig zu stören.  Dies wird durch den Namen der Verbrauchergruppe bestimmt und wie folgt erreicht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/157/5f7/23d/1575f723d77042fd058b9c30bc050247.png"><br>  Es gibt so etwas wie einen Versatz, die Position, an der sich die Verbrauchergruppe jetzt auf jeder Partition befindet.  Beispielsweise verwendet Gruppe A die siebte Nachricht von Partition1 und die fünfte von Partition2.  Gruppe B, unabhängig von A, hat einen anderen Versatz. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8a/10f/1a0/f8a10f1a04b8614f6b9a437142b0db7b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können Ihre Verbrauchergruppe horizontal skalieren, einen weiteren Prozess oder Server hinzufügen. Dies geschieht durch eine Neuzuweisung von Partitionen (Kafka Broker weist jedem Verbraucher eine Liste von Partitionen für den Verbrauch zu). Dies bedeutet, dass die erste Verbrauchergruppe nur Partition 1 und die zweite nur Partition 2 verbraucht. Wenn einige der Verbraucher sterben (z. B. kommt kein Hearthbeat), erfolgt eine neue Neuzuweisung Jeder Verbraucher erhält eine aktuelle Partitionsliste zur Verarbeitung.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/56b/40b/bde/56b40bbde5b1890d35f67a481c4a6462.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist sehr praktisch. Zunächst können Sie den Offset für jede Verbrauchergruppe bearbeiten. Stellen Sie sich vor, es gibt einen Partner, an den Sie Daten aus diesem Thema mit den Ergebnissen der Segmentierung übertragen. Er schreibt, dass er versehentlich den letzten Tag der Daten infolge eines Fehlers verloren hat. Und Sie, für die Verbrauchergruppe dieses Kunden, rollen einfach einen Tag zurück und gießen den gesamten Datentag darauf. Wir können auch eine eigene Verbrauchergruppe haben, eine Verbindung zum Produktionsverkehr herstellen, beobachten, was passiert, und reale Daten debuggen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also erreicht, dass wir begonnen haben, Benutzer beim Wechsel zu segmentieren, neue Verbraucher unabhängig voneinander zu verbinden, Statistiken zu schreiben und sie zu beobachten. Jetzt müssen Sie die Daten sofort nach Eingang bei uns in HBase schreiben lassen.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4e/eec/d6c/c4eeecd6ce987e902fee723a089ab780.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wir es gemacht haben. Früher wurden Batch-Daten geladen. Es gab einen Batch Loader, der Benutzeraktivitätsprotokolldateien verarbeitete: Wenn ein Benutzer 10 Besuche machte, kam der Batch für 10 Ereignisse und wurde in einem Vorgang in HBase aufgezeichnet. Es gab nur ein Ereignis pro Segmentierung. Jetzt wollen wir jedes einzelne Ereignis in den Speicher schreiben. Wir werden den Schreib- und den Lesestream stark erhöhen. Die Anzahl der Ereignisse pro Segmentierung wird ebenfalls erhöht.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/79a/849/910/79a8499101ac2cb58ccf272abb668f6f.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als erstes haben wir HBase auf die SSD portiert. Standardmäßig wird dies nicht besonders durchgeführt. Dies wurde mit HDFS durchgeführt. Sie können sagen, dass sich ein bestimmtes Verzeichnis in HDFS auf einer solchen Gruppe von Festplatten befinden muss. Es gab ein cooles Problem mit der Tatsache, dass, als wir HBase zur SSD brachten und sie stoppten, alle Schnappschüsse dort ankamen und unsere SSDs ziemlich schnell endeten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist auch gelöst. Wir haben begonnen, regelmäßig Snapshots in eine Datei zu exportieren, in ein anderes HDFS-Verzeichnis zu schreiben und alle Metainformationen zu Snapshots zu löschen. Wenn Sie wiederherstellen müssen - nehmen Sie die gespeicherte Datei, importieren und wiederherstellen. Diese Operation ist zum Glück sehr selten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch auf der SSD haben sie Write Ahead Log, Twisted MemStore, herausgenommen und den Cache-Block beim Schreiben aktiviert. Sie können sie beim Aufzeichnen von Daten sofort in den Blockcache stellen. Das ist sehr praktisch, weil In unserem Fall ist es sehr wahrscheinlich, dass die Daten sofort gelesen werden, wenn wir sie aufgezeichnet haben. Dies gab auch einige Vorteile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes haben wir alle unsere Datenquellen auf das Schreiben von Daten in Kafka umgestellt. Bereits von Kafka aus haben wir Daten in HDFS aufgezeichnet, um die Abwärtskompatibilität aufrechtzuerhalten, einschließlich der Möglichkeit, dass unsere Analysten mit Daten arbeiten, MapReduce-Aufgaben ausführen und deren Ergebnisse analysieren können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine separate Verbrauchergruppe verbunden, die Daten in HBase schreibt. Dies ist in der Tat ein Wrapper, der aus Kafka liest und die PUTs in HBase bildet.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d53/267/0b3/d532670b344a70dadf97c5c4674b1596.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben zwei Schaltkreise parallel gestartet, um die Abwärtskompatibilität nicht zu beeinträchtigen und die Systemleistung nicht zu beeinträchtigen. Ein neues System wurde nur bei einem bestimmten Prozentsatz des Verkehrs eingeführt. Mit 10% war alles ziemlich cool. Bei größerer Belastung konnten die Segmentierer den Segmentierungsfluss jedoch nicht bewältigen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/3fa/78c/d203fa78c3d0b80ee7c7a5dce34f558b.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sammeln die Metrik "Wie viele Nachrichten lagen in Kafka, bevor sie von dort gelesen wurden?". Dies ist eine gute Metrik. Anfangs haben wir die Metrik "Wie viele Rohnachrichten sind jetzt" gesammelt, aber sie sagt nichts Besonderes aus. Sie sehen aus: "Ich habe eine Million Rohnachrichten", na und? Um diese Million zu interpretieren, müssen Sie wissen, wie schnell der Segmentator (Verbraucher) arbeitet, was nicht immer klar ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dieser Metrik sehen Sie sofort, dass die Daten in die Warteschlange geschrieben und daraus entnommen werden, und Sie sehen, wie viel sie voraussichtlich verarbeiten werden. </font><font style="vertical-align: inherit;">Wir haben festgestellt, dass wir keine Zeit zum Segmentieren hatten und die Nachricht einige Stunden vor dem Lesen in der Warteschlange stand. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie könnten einfach Kapazität hinzufügen, aber es wäre einfach zu </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teuer</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Deshalb haben wir versucht zu optimieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selbstskalierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben HBase. Der Benutzer ändert sich, seine Kennung fliegt in Kafka. Das Thema ist in Partitionen unterteilt, die Zielpartition wird anhand der Benutzer-ID ausgewählt. Dies bedeutet, dass wenn Sie den Benutzer "Vasya" sehen - er geht zu Partition 1. Wenn Sie "Petya" sehen - zu Partition 2. Dies ist praktisch - Sie können erreichen, dass Sie einen Verbraucher auf einer Instanz Ihres Dienstes sehen, und den zweiten - auf der anderen Seite. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/299/573/aef/299573aefcae8b909623e246d4a2cf80.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir begannen zu beobachten, was los war. Ein typisches Benutzerverhalten im Internet besteht darin, auf eine Website zu gehen und mehrere Hintergrundregisterkarten zu öffnen. Die zweite Möglichkeit besteht darin, zur Website zu gehen und mit wenigen Klicks zur Zielseite zu gelangen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen uns die Segmentierungswarteschlange an und sehen Folgendes: Benutzer A hat die Seite besucht. 5 weitere Ereignisse kommen von diesem Benutzer - jedes bedeutet ein Öffnen der Seite. Wir verarbeiten jedes Ereignis vom Benutzer. Tatsächlich enthalten die Daten in HBase jedoch alle 5 Besuche. Wir verarbeiten alle 5 Besuche zum ersten Mal, zum zweiten Mal usw. - wir verschwenden CPU-Ressourcen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6df/eba/fbf/6dfebafbf435cfb43e5b71cc7d2016fd.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus diesem Grund haben wir begonnen, auf jedem Segmentierer einen bestimmten lokalen Cache mit dem Datum zu speichern, an dem wir diesen Benutzer zuletzt analysiert haben. Das heißt, wir haben es verarbeitet, seine Benutzer-ID und seinen Zeitstempel in den Cache geschrieben. Jede Kafka-Nachricht hat auch einen Zeitstempel - wir vergleichen ihn einfach: Wenn der Zeitstempel in der Warteschlange kleiner als das Datum der letzten Segmentierung ist - haben wir den Benutzer bereits auf diese Daten analysiert, und Sie können dieses Ereignis einfach überspringen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerereignisse (rotes A) können unterschiedlich sein und sind nicht in Ordnung. Der Benutzer kann mehrere Hintergrundregisterkarten öffnen, mehrere Links hintereinander öffnen. Möglicherweise hat die Site mehrere unserer Partner gleichzeitig, von denen jeder diese Daten sendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Pixel kann den Besuch des Benutzers und dann eine andere Aktion sehen - wir werden seinen Helm an uns selbst senden. Wenn fünf Ereignisse eintreffen, verarbeiten wir das erste rote A. Wenn das Ereignis eingetroffen ist, befindet es sich bereits in HBase. Wir sehen Ereignisse, durchlaufen eine Reihe von Skripten. Wir sehen das folgende Ereignis und dort alle die gleichen Ereignisse, weil sie bereits aufgezeichnet sind. Wir führen es erneut aus, speichern den Cache mit dem Datum und vergleichen ihn mit dem Zeitstempel des Ereignisses.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f5/a41/48b/3f5a4148b5b8f14067816cda7b7bfade.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank dessen erhielt das System die Eigenschaft der Selbstskalierbarkeit. Die y-Achse ist der Prozentsatz dessen, was wir mit Benutzer-IDs tun, wenn sie zu uns kommen. Grün - die Arbeit, die wir ausgeführt haben, hat das Segmentierungsskript gestartet. Gelb - das haben wir nicht gemacht, weil Bereits genau diese Daten segmentiert. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/902/e54/03d/902e5403d2dc07b5f2a4ceaf57ea3e47.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist ersichtlich, dass nachts Ressourcen vorhanden sind, weniger Daten fließen und Sie jedes zweite Ereignis segmentieren können. Ein kleinerer Ressourcentag, und wir segmentieren nur 20% der Ereignisse. Ein Sprung am Ende des Tages - der Partner hat Datendateien hochgeladen, die wir zuvor noch nicht gesehen hatten, und sie mussten „ehrlich“ segmentiert werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das System selbst passt sich dem Lastwachstum an. Wenn wir einen sehr großen Partner haben, verarbeiten wir dieselben Daten, jedoch etwas seltener. In diesem Fall verschlechtern sich die Eigenschaften des Systems am Abend, die Segmentierung wird nicht um 2-3 Sekunden, sondern um eine Minute verzögert. Fügen Sie am Morgen die Server hinzu und kehren Sie zu den gewünschten Ergebnissen zurück. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So haben wir ca. 5 mal auf den Servern gespart. Jetzt arbeiten wir auf 10 Servern, und so würde es 50-60 dauern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das kleine blaue Ding oben sind die Bots. Dies ist der schwierigste Teil der Segmentierung. Sie haben eine große Anzahl von Besuchen, sie erzeugen eine sehr große Last auf dem Eisen. Wir sehen jeden Bot auf einem separaten Server. Wir können darauf einen lokalen Cache mit einer schwarzen Liste von Bots sammeln. Einführung eines einfachen Betrugs: Wenn ein Benutzer für eine bestimmte Zeit zu viele Besuche macht, stimmt etwas nicht mit ihm, wir fügen ihn für eine Weile der schwarzen Liste hinzu. Dies ist ein kleiner blauer Streifen, ungefähr 5%. Sie gaben uns weitere 30% Einsparungen bei der CPU. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit haben wir in jeder Phase das erreicht, was wir für die gesamte Pipeline der Datenverarbeitung sehen. Wir sehen Metriken, wie viel die Nachricht in Kafka war. Abends trübte sich irgendwo etwas, die Bearbeitungszeit erhöhte sich auf eine Minute, dann wurde es freigegeben und wieder normalisiert.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/58e/fed/411/58efed411c7c5a4348b9280b3c963c16.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können überwachen, wie sich unsere Aktionen mit dem System auf den Durchsatz auswirken. Wir können sehen, wie viel das Skript ausgeführt wird, wo es optimiert werden muss und wie viel gespeichert werden kann. </font><font style="vertical-align: inherit;">Wir können die Größe der Segmente sehen, die Dynamik der Größe der Segmente, ihre Assoziation und Schnittmenge bewerten. </font><font style="vertical-align: inherit;">Dies kann für mehr oder weniger gleiche Segmentgrößen erfolgen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was möchten Sie verfeinern? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben einen Hadoop-Cluster mit einigen Computerressourcen. Er ist beschäftigt - Analysten arbeiten tagsüber daran, aber nachts ist er praktisch frei. Im Allgemeinen können wir den Segmentierer als separaten Prozess in unserem Cluster containerisieren und ausführen. Wir möchten Statistiken genauer speichern, um das Volumen der Kreuzung genauer berechnen zu können. Wir brauchen auch eine Optimierung der CPU. Dies wirkt sich direkt auf die Kosten der Entscheidung aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassend: Kafka ist gut, aber wie bei jeder anderen Technologie müssen Sie verstehen, wie es im Inneren funktioniert und was damit passiert. Beispielsweise funktioniert die Garantie für die Nachrichtenpriorität nur innerhalb der Partition. Wenn Sie eine Nachricht senden, die an verschiedene Partitionen gesendet wird, ist nicht klar, in welcher Reihenfolge diese verarbeitet werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reale Daten sind sehr wichtig. </font><font style="vertical-align: inherit;">Wenn wir nicht auf echten Datenverkehr getestet hätten, hätten wir höchstwahrscheinlich keine Probleme mit Bots und Benutzersitzungen gesehen. </font><font style="vertical-align: inherit;">Würde etwas im luftleeren Raum entwickeln, rennen und sich hinlegen. </font><font style="vertical-align: inherit;">Es ist wichtig zu überwachen, was Sie für notwendig halten, um zu überwachen, und nicht zu überwachen, was Sie nicht denken.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minute der Werbung. </font><font style="vertical-align: inherit;">Wenn Ihnen dieser Bericht von der SmartData-Konferenz gefallen hat, beachten Sie bitte, dass </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SmartData 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> am 15. Oktober in St. Petersburg stattfindet, einer </font><font style="vertical-align: inherit;">Konferenz für diejenigen, die in die Welt des maschinellen Lernens, der Analyse und der Datenverarbeitung eintauchen. </font><font style="vertical-align: inherit;">Das Programm wird viele interessante Dinge enthalten, die Seite hat bereits ihre ersten Redner und Berichte.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421125/">https://habr.com/ru/post/de421125/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421113/index.html">Einführung in DJI Mavic 2 Pro / Zoom</a></li>
<li><a href="../de421115/index.html">Kontext in einer Android-Anwendung</a></li>
<li><a href="../de421119/index.html">SmartTV-Entwicklung für Unterwasserschwader</a></li>
<li><a href="../de421121/index.html">Video-Streaming über einen Browser mit extrem geringer Latenz (und WebRTC!)</a></li>
<li><a href="../de421123/index.html">Zusammenfassung der IT-Veranstaltungen für September</a></li>
<li><a href="../de421127/index.html">Skillbox Friday Webinare: Design & Entwickler</a></li>
<li><a href="../de421129/index.html">So reduzieren Sie die Codeüberprüfung von zwei Wochen auf mehrere Stunden. Die Erfahrung des Yandex.Market-Teams</a></li>
<li><a href="../de421131/index.html">Kritische Sicherheitsanfälligkeit von 1Cloud-Servern</a></li>
<li><a href="../de421133/index.html">LINKa. Papiertastatur. Extra große Knöpfe</a></li>
<li><a href="../de421135/index.html">Au / Ni / MgO: Wärmeübertragung im Nanomaßstab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>