<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📴 💋 💈 Répartissez une liste liée individuellement. Édition Swift 👨🏿‍🚀 🖖🏻 🔌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ce n'est un secret pour personne que l'un des passe-temps préférés d'un développeur de logiciels est d'interviewer des employeurs. Nous le faisons tou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Répartissez une liste liée individuellement. Édition Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455842/"> Ce n'est un secret pour personne que l'un des passe-temps préférés d'un développeur de logiciels est d'interviewer des employeurs.  Nous le faisons tous de temps en temps et pour des raisons complètement différentes.  Et la plus évidente d'entre elles - la recherche d'emploi - n'est pas, je pense, la plus courante.  Assister à un entretien est un bon moyen de rester en forme, de répéter les bases oubliées et d'apprendre quelque chose de nouveau.  Et en cas de succès, augmentez également la confiance en soi.  Nous nous ennuyons, nous nous fixons le statut «ouvert aux offres» dans une sorte de réseau social «professionnel» comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«LinkedIn»</a> - et l'armée de gestionnaires des ressources humaines attaque déjà nos boîtes de réception pour les messages entrants. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/bw/9r/mc/bw9rmcigk0k9beg-50tdq74sadw.jpeg" alt="image"><br><br>  Dans le processus, alors que tout ce débat se déroule, nous sommes confrontés à de nombreuses questions qui, comme ils le disent de l'autre côté du rideau implicitement effondré, «sonnent la cloche» et leurs détails sont cachés derrière le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">brouillard de la guerre</a> .  Ils ne sont le plus souvent rappelés que dans des tests par des algorithmes et des structures de données (personnellement, je n'avais pas de telles données du tout) et en fait des entretiens. <br><br>  L'une des questions les plus courantes dans une interview pour un programmeur de toute spécialisation est les listes.  Par exemple, des listes liées individuellement.  Et les algorithmes de base associés.  Par exemple, un demi-tour.  Et généralement, cela se produit en quelque sorte comme ceci: "Bien, mais comment développeriez-vous une liste liée individuellement?"  L'essentiel est de surprendre le demandeur par cette question. <br><br>  En fait, tout cela m'a amené à écrire cette courte critique pour rappel constant et édification.  Alors, blague à part, voici! <br><br><h2>  Liste liée individuellement </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une liste chaînée</a> est l'une des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structures de données de</a> base.  Chaque élément (ou nœud) de celui-ci se compose en fait de données stockées et de liens vers des éléments voisins.  Une liste liée individuellement stocke uniquement le lien vers l'élément suivant dans la structure, et une liste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">doublement liée</a> contient le suivant et le précédent.  Une telle organisation des données permet de les localiser dans n'importe quelle zone mémoire (contrairement, par exemple, à un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau</a> dont tous les éléments doivent être localisés en mémoire les uns après les autres). <br><br>  Il y a bien sûr beaucoup plus à dire sur les listes: elles peuvent être circulaires (c'est-à-dire que le dernier élément stocke un lien vers le premier) ou non (c'est-à-dire qu'il n'y a pas de lien vers le dernier élément).  Les listes peuvent être saisies, c.-à-d.  contiennent des données du même type ou non.  Et ainsi de suite et ainsi de suite. <br><br>  Mieux vaut essayer d'écrire du code.  Par exemple, vous pouvez en quelque sorte imaginer un nœud de liste: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(payload: <span class="hljs-type"><span class="hljs-type">T</span></span>, nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payload = payload <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.nextNode = nextNode } }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Générique» est un</a> type capable de stocker des charges utiles de tout type dans le champ de <code>payload</code> . <br><br>  La liste elle-même est exhaustivement identifiée par son premier nœud: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.firstNode = firstNode } }</code> </pre><br>  Le premier nœud est déclaré facultatif, car la liste peut très bien être vide. <br><br>  <i>En théorie, bien sûr, dans la classe, vous devez implémenter toutes les méthodes nécessaires - insérer, supprimer, accéder aux nœuds, etc., mais nous le ferons une autre fois.</i>  <i>Dans le même temps, nous vérifierons si l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>struct</code></a> (avec laquelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apple</a> nous encourage activement par notre exemple) est un meilleur choix, et nous rappellerons peut-être l'approche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Copier sur écriture»</a> .</i> <br><br><h2>  Propagation de liste à lien unique </h2><br><h3>  La première façon.  Cycle </h3><br>  Il est temps de passer aux affaires pour lesquelles nous sommes ici aujourd'hui!  Et le moyen le plus efficace pour y faire face est de deux manières.  Le premier est une simple boucle, du premier au dernier nœud. <br><br>  Le cycle fonctionne avec trois variables qui, avant le début, se voient attribuer la valeur du nœud précédent, actuel et suivant.  (À ce moment, la valeur du nœud précédent est naturellement vide.) Le cycle commence par vérifier que le nœud suivant n'est pas vide, et si c'est le cas, le corps du cycle est exécuté.  Aucune magie ne se produit dans la boucle: au nœud actuel, le champ qui fait référence à l'élément suivant se voit attribuer un lien vers le précédent (à la première itération, la valeur du lien, respectivement, est réinitialisée, ce qui correspond à la situation dans le dernier nœud).  Eh bien et plus loin, les variables correspondant aux nœuds précédent, actuel et suivant reçoivent de nouvelles valeurs.  Après avoir quitté la boucle, le nœud actuel (c'est-à-dire le dernier itérable en général) se voit attribuer une nouvelle valeur de lien vers le nœud suivant, car  la sortie de la boucle se produit juste au moment où le dernier nœud de la liste devient courant. <br><br>  En mots, bien sûr, tout cela semble étrange et incompréhensible, il est donc préférable de regarder le code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previousNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentNode = firstNode <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode = firstNode?.nextNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nextNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { currentNode?.nextNode = previousNode previousNode = currentNode currentNode = nextNode nextNode = currentNode?.nextNode } currentNode?.nextNode = previousNode firstNode = currentNode } }</code> </pre><br>  Pour la vérification, nous utilisons une liste de nœuds dont les charges utiles sont de simples identifiants <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">entiers</a> .  Créez une liste de dix éléments: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(payload: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// T == Int let list = SinglyLinkedList(firstNode: node) var currentNode = node var nextNode: Node&lt;Int&gt; for id in 1..&lt;10 { nextNode = Node(payload: id) currentNode.nextNode = nextNode currentNode = nextNode }</span></span></code> </pre><br>  Tout semble aller bien, mais nous sommes des personnes, pas des ordinateurs, et il serait bien pour nous d'obtenir une preuve visuelle de l'exactitude de la liste créée et de l'algorithme décrit ci-dessus.  Peut-être qu'une simple impression suffira.  Pour rendre la sortie lisible, ajoutez l'implémentation du protocole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>CustomStringConvertible</code></a> nœud avec un identifiant entier: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstPart = <span class="hljs-string"><span class="hljs-string">""" Node \(Unmanaged.passUnretained(self).toOpaque()) has id \(payload) and """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nextNode = nextNode { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" next node \(nextNode.payload)."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" no next node."</span></span> } } }</code> </pre><br>  ... Et la liste correspondante pour afficher tous les nœuds dans l'ordre: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description = <span class="hljs-string"><span class="hljs-string">""" List \(Unmanaged.passUnretained(self).toOpaque()) """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += <span class="hljs-string"><span class="hljs-string">" has nodes:\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += (node!.description + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) node = node!.nextNode } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description + <span class="hljs-string"><span class="hljs-string">" has no nodes."</span></span> } } }</code> </pre><br>  La représentation sous forme de chaîne de nos types contiendra une adresse en mémoire et un identifiant entier.  A partir de ceux-ci, nous organisons l'impression de la liste générée de dix nœuds: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br>  Développez cette liste et imprimez-la à nouveau: <br><br><pre> <code class="swift hljs">list.<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e8820 has id 9 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 6. Node 0x00006000012e8900 has id 6 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 0. Node 0x00006000012e2380 has id 0 and no next node. */</span></span></code> </pre><br>  Vous pouvez remarquer que les adresses dans la mémoire de la liste et des nœuds n'ont pas changé et que les nœuds de la liste sont imprimés dans l'ordre inverse.  Les références à l'élément suivant du nœud pointent maintenant vers le précédent (c'est-à-dire, par exemple, que l'élément suivant du nœud "5" n'est plus "6", mais "4").  Et cela signifie que nous l'avons fait! <br><br><h3>  La deuxième façon.  Récursivité </h3><br>  La deuxième façon connue de faire le même demi-tour est basée sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récursivité</a> .  Pour l'implémenter, nous allons déclarer une fonction qui prend le premier noeud de la liste, et retourne le «nouveau» premier noeud (qui était le dernier avant). <br><br>  Le paramètre et la valeur de retour sont facultatifs, car à l'intérieur de cette fonction, elle est appelée à plusieurs reprises sur chaque nœud suivant jusqu'à ce qu'elle soit vide (c'est-à-dire jusqu'à ce que la fin de la liste soit atteinte).  En conséquence, dans le corps de la fonction, il est nécessaire de vérifier si le noeud sur lequel la fonction est appelée est vide et si ce noeud possède les éléments suivants.  Sinon, la fonction renvoie ce qui a été passé à l'argument. <br><br>  En fait, j'ai honnêtement essayé de décrire l'algorithme complet avec des mots, mais au final j'ai effacé presque tout, car le résultat serait impossible à comprendre.  Pour dessiner des organigrammes et décrire officiellement les étapes de l'algorithme - aussi, dans ce cas, je pense que cela n'a aucun sens, car il sera plus pratique pour vous et moi de simplement lire et essayer de comprendre le code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Swift</a> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverseRecursively</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node&lt;T&gt;?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = node <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> head.nextNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> head } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reversedHead = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(head.nextNode) head.nextNode?.nextNode = head head.nextNode = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reversedHead } firstNode = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(firstNode) } }</code> </pre><br>  L'algorithme lui-même est «encapsulé» par une méthode du type liste lui-même, pour la commodité de l'appel. <br><br>  Il semble plus court, mais, à mon avis, plus difficile à comprendre. <br><br>  Nous appelons cette méthode sur le résultat du spread précédent et imprimons un nouveau résultat: <br><br><pre> <code class="swift hljs">list.reverseRecursively() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br>  Il peut être vu à partir de la sortie que toutes les adresses dans la mémoire n'ont pas changé à nouveau, et les nœuds suivent maintenant dans l'ordre d'origine (c'est-à-dire qu'ils sont à nouveau «déployés»).  Et cela signifie que nous avons à nouveau raison! <br><br><h3>  Conclusions </h3><br>  Si vous regardez attentivement les méthodes d'inversion (ou effectuez une expérience avec le comptage des appels), vous remarquerez que la boucle dans le premier cas et l'appel de méthode interne (récursif) dans le second cas se produisent une fois de moins que le nombre de nœuds dans la liste (dans notre cas, neuf fois).  Vous pouvez également faire attention à ce qui se passe autour de la boucle dans le premier cas - la même séquence d'affectations - et au premier appel de méthode non récursif dans le second cas.  Il s'avère que dans les deux cas le «cercle» est répété exactement dix fois pour une liste de dix nœuds.  Ainsi, nous avons une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complexité</a> linéaire pour les deux algorithmes - <i>O (n)</i> . <br><br>  De manière générale, les deux algorithmes décrits sont considérés comme les plus efficaces pour résoudre ce problème.  En ce qui concerne la complexité de calcul, il n'est pas possible de trouver un algorithme avec une valeur inférieure: d'une manière ou d'une autre, vous devez «visiter» chaque nœud pour attribuer une nouvelle valeur au lien stocké à l'intérieur. <br><br>  Une autre caractéristique qui mérite d'être mentionnée est la «complexité de la mémoire allouée».  Les deux algorithmes proposés créent un nombre fixe de nouvelles variables (trois dans le premier cas et une dans le second).  Cela signifie que la quantité de mémoire allouée ne dépend pas des caractéristiques quantitatives des données d'entrée et est décrite par une fonction constante - O (1). <br><br>  Mais, en fait, dans le deuxième cas, ce n'est pas le cas.  Le danger de récursivité est que de la mémoire supplémentaire est allouée pour chaque appel récursif sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pile</a> .  Dans notre cas, la profondeur de récursivité correspond à la quantité de données d'entrée. <br><br>  Et finalement, j'ai décidé d'expérimenter un peu plus: de manière simple et primitive, j'ai mesuré le temps d'exécution absolu de deux méthodes pour une quantité différente de données d'entrée.  Comme ça: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startDate = <span class="hljs-type"><span class="hljs-type">Date</span></span>().timeIntervalSince1970 <span class="hljs-comment"><span class="hljs-comment">// list.reverse() / list.reverseRecursively() let finishDate = Date().timeIntervalSince1970 let runningTime = finishDate – startDate // Seconds</span></span></code> </pre><br>  Et voici ce que j'ai obtenu (ce sont les données brutes du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Playground</a> ): <br><br><img src="https://habrastorage.org/webt/kf/at/bf/kfatbfsxar9clyyokzu6beu3ios.png" alt="image"><br><br>  (Malheureusement, mon ordinateur n'a pas maîtrisé les plus grandes valeurs.) <br><br>  Que peut-on voir sur la table?  Rien de spécial pour le moment.  Bien qu'il soit déjà visible que la méthode récursive se comporte un peu moins bien avec un nombre relativement petit de nœuds, mais quelque part entre 100 et 1000, elle commence à montrer mieux. <br><br>  J'ai également essayé le même test simple dans un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Xcode» à</a> part entière.  Les résultats sont les suivants: <br><br><img src="https://habrastorage.org/webt/sr/vj/0d/srvj0dqmtgtse2wfuqq6llutte4.png" alt="image"><br><br>  Tout d'abord, il convient de mentionner que les résultats ont été obtenus après l'activation du mode d'optimisation «agressif» visant à la vitesse d'exécution ( <code>-Ofast</code> ), ce qui explique en partie pourquoi les nombres sont si petits.  Il est également intéressant de noter que dans ce cas la méthode récursive s'est montrée un peu mieux, au contraire, que sur de très petites tailles de données d'entrée, et déjà sur une liste de 100 nœuds, la méthode perd.  Sur 100 000, il a mis fin anormalement au programme. <br><br><h2>  Conclusion </h2><br>  J'ai essayé de couvrir un sujet plutôt classique du point de vue de mon langage de programmation préféré en ce moment, et j'espère que vous étiez curieux de suivre les progrès aussi bien que moi-même.  Et je suis très heureux si vous avez réussi à apprendre quelque chose de nouveau également - alors j'ai définitivement perdu mon temps sur cet article (au lieu de m'asseoir et de regarder des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">émissions de télévision</a> ). <br><br>  <i>Si quelqu'un a envie de suivre mon activité sociale, voici un lien vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon «Twitter»</a> , où tout d'abord il y a des liens vers mes nouveaux posts et un peu plus.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455842/">https://habr.com/ru/post/fr455842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455828/index.html">Les scientifiques ont découvert de nouvelles formes de synchronisation exotiques</a></li>
<li><a href="../fr455830/index.html">Un regard sur Passer par les yeux d'un développeur .NET. Semaine # 1</a></li>
<li><a href="../fr455832/index.html">Historique d'une seule enquête SQL</a></li>
<li><a href="../fr455834/index.html">Benchmarks pour les serveurs Linux: 5 outils ouverts</a></li>
<li><a href="../fr455840/index.html">Comment travailler avec plusieurs requêtes. Composition, réducteur, FP</a></li>
<li><a href="../fr455844/index.html">Création d'un analyseur Roslyn en utilisant les tests d'encapsulation comme exemple</a></li>
<li><a href="../fr455846/index.html">Informatique distribuée dans Julia</a></li>
<li><a href="../fr455848/index.html">Technique pour éviter un comportement indéfini lors de l'accès à un singleton</a></li>
<li><a href="../fr455850/index.html">Boîte à outils pour les chercheurs - Troisième édition: recherche et utilisation de sources</a></li>
<li><a href="../fr455852/index.html">Levée de sinus et implantation simultanée</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>