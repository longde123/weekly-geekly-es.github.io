<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—ï¸ ğŸ•µï¸ ğŸ¤¦ğŸ¼ Ù†Ø§Ù‚Ù„ "Ù…ÙˆØ³ÙŠÙ‚Ù‰" Ø±Ù‚Ù…ÙŠ Ù…Ø¹ ÙˆØ§Ø¬Ù‡Ø© UART ğŸ’¦ ğŸ‘©ğŸ¾â€âš•ï¸ ğŸ‘…</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ù…Ø±Ø­Ø¨Ù‹Ø§ Geektimes! Ù‡Ù„ ØªØ³Ø§Ø¡Ù„Øª ÙŠÙˆÙ…Ù‹Ø§ ÙƒÙŠÙ ØªØ¨Ø¯Ùˆ "Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©" Ø¹Ù„Ù‰ Ø·ÙˆÙ„ Ù…Ø³Ø§Ø±Ø§Øª Ù„ÙˆØ­Ø§Øª Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ù…Ø·Ø¨ÙˆØ¹Ø© Ø¨ÙŠÙ† Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ù„ØªØ±Ø§Ù†Ø²Ø³ØªÙˆØ±Ø§Øª ÙˆØ§Ù„Ø«Ù†Ø§Ø¦ÙŠØ§Øª ÙˆØ§...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ù†Ø§Ù‚Ù„ "Ù…ÙˆØ³ÙŠÙ‚Ù‰" Ø±Ù‚Ù…ÙŠ Ù…Ø¹ ÙˆØ§Ø¬Ù‡Ø© UART</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408485/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/hw/tj/x4/hwtjx4znykkrp5_poz3bx1xfpae.jpeg" alt="Ø§Ù„ØµÙˆØ±Ø©"></div><br>  Ù…Ø±Ø­Ø¨Ù‹Ø§ Geektimes!  Ù‡Ù„ ØªØ³Ø§Ø¡Ù„Øª ÙŠÙˆÙ…Ù‹Ø§ ÙƒÙŠÙ ØªØ¨Ø¯Ùˆ "Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ©" Ø¹Ù„Ù‰ Ø·ÙˆÙ„ Ù…Ø³Ø§Ø±Ø§Øª Ù„ÙˆØ­Ø§Øª Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ù…Ø·Ø¨ÙˆØ¹Ø© Ø¨ÙŠÙ† Ø§Ù„Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ù„ØªØ±Ø§Ù†Ø²Ø³ØªÙˆØ±Ø§Øª ÙˆØ§Ù„Ø«Ù†Ø§Ø¦ÙŠØ§Øª ÙˆØ§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø§Øª ÙˆØ§Ù„Ù…ÙƒØ«ÙØ§ØªØŸ  Ø£Ø­Ø¯ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© ÙÙŠ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ§Øª Ø§Ù„Ø­Ø¯ÙŠØ«Ø© Ù‡Ùˆ Ù†Ø§Ù‚Ù„ Ø±Ù‚Ù…ÙŠ ØŒ ÙˆÙˆØ§Ø­Ø¯Ø© Ù…Ù† Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© Ù„ØªØ¨Ø§Ø¯Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø¨Ø± Ø§Ù„Ù†Ø§Ù‚Ù„ Ù‡ÙŠ UART.  ÙˆØºØ§Ù„Ø¨Ù‹Ø§ Ù…Ø§ ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙÙŠ ÙˆØ­Ø¯Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø© Ù„Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø¬Ù‡Ø§Ø² ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ø£Ùˆ Ù†ÙˆØ¹ Ù…Ù† Ø§Ù„Ø£Ø·Ø±Ø§Ù.  Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØµÙˆØª ÙÙŠ Ø§Ù„Ø­Ø§ÙÙ„Ø© ØŒ Ù„ÙŠØ³ Ù…Ù† Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ ØªÙˆØµÙŠÙ„ Ù…ÙƒØ¨Ø± ØµÙˆØª Ø¨Ù…Ø¶Ø®Ù… Ø¥Ù„Ù‰ Ù†Ø§Ù‚Ù„ Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… <i>UART</i> Ø£ÙˆÙ… ØŒ Ù„Ø£Ù†Ù‡ ÙŠÙ…ÙƒÙ† Ù…Ø­Ø§ÙƒØ§ØªÙ‡ ÙÙŠ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬.  Ù‡Ù„ Ø£Ù†Øª Ù…Ù‡ØªÙ… Ø¨Ø§Ù„Ø£ØµÙˆØ§Øª Ø§Ù„ØªÙŠ Ø§Ù†ØªÙ‡ÙŠØª Ø¨Ù‡Ø§ ØŒ Ø£Ù… ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù„ØªØ¬Ø±Ø¨Ø© Ù†ÙØ³ÙƒØŸ  Ø«Ù… Ø£Ø·Ù„Ø¨ Ø§Ù„Ù‚Ø·. <br><a name="habracut"></a><br><h3 style=";text-align:right;direction:rtl">  <b>Ù†Ø³ØªÙ…Ø¹ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù„ÙØ§Øª ÙÙŠ Ø§Ù„Ø­Ø§ÙÙ„Ø© Ù…Ø¹ UART</b> </h3><br>  Ù…Ø§ Ø§Ù„ØµÙˆØª Ø§Ù„Ø°ÙŠ Ø³ÙŠÙ†ØªØ¬ Ø¥Ø°Ø§ Ù‚Ù…Øª Ø¨Ù†Ù‚Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¹Ø¨Ø± <i>UART</i> ØŸ  ÙÙŠÙ…Ø§ ÙŠÙ„ÙŠ Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ù…Ø«Ù„Ø© Ø§Ù„ØªÙŠ ØªÙ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„ÙŠÙ‡Ø§ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¹Ù„Ù…Ø§Øª <i>UART</i> Ø§Ù„ØªØ§Ù„ÙŠØ©: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  115200 Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨Ø§ÙˆØ¯ </li><li style=";text-align:right;direction:rtl">  Ø¨Øª 8 Ø¨Øª </li><li style=";text-align:right;direction:rtl">  Ø¨Øª Ø§Ù„ØªÙƒØ§ÙØ¤: Ø¨Ù„Ø§ </li><li style=";text-align:right;direction:rtl">  Ø·ÙˆÙ„ Ø¨Øª Ø§Ù„ØªÙˆÙ‚Ù: 1 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ØµÙˆØª Ù„Ø¹Ø¨Ø© Stalker Shadow of Chernobyl</a> (Ù…Ù„Ù XR_3DA.exe ØŒ ÙÙŠ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø³Ø§Ø± ØŒ Ø¨Ø¯Ø¡Ù‹Ø§ Ù…Ù† 2:36 ØŒ Ù‡Ù†Ø§Ùƒ Ù„Ø­Ù†). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ØµÙˆØª Ù†Øµ ÙˆØ±Ù…Ø² Ø§Ù„Ù…Ù‚Ø§Ù„Ø© Ø­ÙˆÙ„ Ù…ÙØ±ÙƒÙÙ‘Ø¨ Ø§Ù„ÙƒÙ„Ø§Ù…</a> (Ø§Ù„Ù…Ù‚Ø§Ù„Ø© Ù†ÙØ³Ù‡Ø§ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Ù‡Ù†Ø§</a> ). <br><br>  ÙƒÙŠÙ ØªØ¨Ø¯Ùˆ ØµÙˆØ±Ø© Ù„ÙŠÙ†Ø§ØŸ <br><br><img src="https://habrastorage.org/storage2/d1e/664/833/d1e6648335210462583267c43d4d3941.png" alt="Ø§Ù„ØµÙˆØ±Ø©"><br><br>  ÙƒØ§Ù†Øª Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù…Ø¬Ø±Ø¯ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Ø¶Ø¬ÙŠØ¬</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ØµÙˆØª ÙƒØªØ§Ø¨ "Ø§Ù„Ø§Ù†ØªØ±ÙˆØ¨ÙŠØ§ ÙˆØªÙˆÙ‚Ø¹ Ø§Ù„Ø³Ù„Ø§Ø³Ù„ Ø§Ù„Ø²Ù…Ù†ÙŠØ© ÙÙŠ Ù†Ø¸Ø±ÙŠØ© Ø§Ù„Ù†Ø¸Ù… Ø§Ù„Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©" Ø¨ØªÙ†Ø³ÙŠÙ‚ pdf.</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ØµÙˆØª Ø§Ù„Ø¨Ø±Ø§Ù…Ø¬ Ø§Ù„Ø«Ø§Ø¨ØªØ© Ù„Ø³Ù„Ø³Ù„Ø© Ù…ØªØ­ÙƒÙ… Ø³Ù„Ø³Ù„Ø© Atmega Ù„Ù…Ø´ØºÙ„ wav.</a> <br><br><h3 style=";text-align:right;direction:rtl">  <b>Ù…Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ØŸ</b> </h3><br>  Ù†Ø¸Ø±ÙŠÙ‹Ø§ ØŒ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ù…Ø«Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ÙÙŠ Ø´ÙƒÙ„ Ù†Øµ ØŒ Ø£Ùˆ ØµÙˆØ±Ø© ØŒ Ø£Ùˆ ÙÙŠØ¯ÙŠÙˆ ØŒ Ø£Ùˆ ÙÙŠ Ø´ÙƒÙ„ Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù„Ù† ÙŠÙƒÙˆÙ† Ù„Ù‡ Ù…Ø¹Ù†Ù‰ ÙˆØ¸ÙŠÙÙŠ Ø£Ùˆ Ø£Ù‡Ù…ÙŠØ© Ø¬Ù…Ø§Ù„ÙŠØ© ÙØ­Ø³Ø¨ ØŒ Ø¨Ù„ Ø£ÙŠØ¶Ù‹Ø§ Ø§Ù„ØµÙˆØª "Ø§Ù„Ø¬Ù…ÙŠÙ„" Ù„Ù„Ø­Ø§ÙÙ„Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ© ØŒ Ø«Ù… ÙŠØªØ­ÙˆÙ„ Ø¥Ù„Ù‰ Ù†ÙˆØ¹ Ù…Ù† Ø§Ù„Ø´Ø¹Ø± "Ø§Ù„Ø±Ù‚Ù…ÙŠ" .  <s>ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ù‹Ø§ ØªÙ†ÙˆÙŠØ¹ Ø¹ÙŠÙ†Ø§Øª dubstep</s> Ø¨Ø´ÙƒÙ„ Ø¹Ø§Ù… ØŒ ÙÙŠ Ø±Ø£ÙŠÙŠ ØŒ ÙØ¥Ù† Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ø¥Ù„Ù‰ Ø£ØµÙˆØ§Øª Ø§Ù„Ø­Ø§ÙÙ„Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ© Ø£Ù…Ø± Ù…Ø«ÙŠØ± Ù„Ù„Ø§Ù‡ØªÙ…Ø§Ù… Ù…Ø«Ù„ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ø¥Ù„Ù‰ Ø¶Ø¬ÙŠØ¬ Ø§Ù„Ù…ÙˆØ¬Ø§Øª Ø§Ù„Ø±Ø§Ø¯ÙŠÙˆÙŠØ© ÙÙŠ Ø§Ù„Ù…ÙˆØ¬Ø§Øª Ø§Ù„Ù‚ØµÙŠØ±Ø© ØŒ Ø¨Ø´ÙƒÙ„ Ø¹Ø§Ù… ØŒ Ù„Ù„Ù‡ÙˆØ§Ø©. <br><br><h3 style=";text-align:right;direction:rtl">  <b>ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ Ø£Ùˆ Ù‚Ù„ÙŠÙ„Ø§ Ø¹Ù† UART</b> </h3><br>  Ù…Ø§ Ù‡Ùˆ <i>UART</i> ÙŠÙ…ÙƒÙ† Ù‚Ø±Ø§Ø¡ØªÙ‡ Ø¹Ù„Ù‰ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ÙˆÙŠÙƒÙŠØ¨ÙŠØ¯ÙŠØ§</a> .  <i>Ù…Ù†</i> Ø§Ù„Ø³Ù‡Ù„ Ø¬Ø¯Ù‹Ø§ Ù…Ø­Ø§ÙƒØ§Ø© <i>UART</i> ÙÙŠ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬.  ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ ØŒ Ù…Ø§ Ø¹Ù„ÙŠÙƒ Ø³ÙˆÙ‰ Ø£Ù† ØªÙƒÙˆÙ† Ù‚Ø§Ø¯Ø±Ù‹Ø§ Ø¹Ù„Ù‰ Ø¥Ù†Ø´Ø§Ø¡ ÙØ±Ù‚ Ø¥Ø´Ø§Ø±Ø© Ù…Ù† 0 Ø¥Ù„Ù‰ 1 ÙˆØ§Ù„Ø¹ÙƒØ³ ØµØ­ÙŠØ­ (ÙÙŠ Ø­Ø§Ù„Ø© Ù…Ù„Ù <i>WAV</i> Ø¨Ø³Ø¹Ø© Ø¨Øª 16 Ø¨Øª ØŒ Ù‡Ø°Ù‡ Ù‚ÙŠÙ… Ù…Ù† - <i>A</i> Ø¥Ù„Ù‰ + <i>A</i> ØŒ Ø­ÙŠØ« <i>A</i> Ù‡ÙŠ Ø³Ø¹Ø© Ø§Ù„Ø¥Ø´Ø§Ø±Ø©) ÙˆØªØ³Ø¬ÙŠÙ„Ù‡Ø§ ÙÙŠ Ù…Ù„Ù ØµÙˆØªÙŠ.  ØªØ¹Ù…Ù„ ÙˆØ§Ø¬Ù‡Ø© <i>UART</i> Ø¨Ø´ÙŠØ¡ Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø¨ÙŠÙ„: Ø¨Ø¹Ø¯ Ø¨Øª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ØŒ ÙˆÙ‡Ùˆ "ØµÙØ±" Ù…Ù†Ø·Ù‚ÙŠ ØŒ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ø¹ØªÙ…Ø§Ø¯Ù‹Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ù‚Ø¯Ù…Ø© ØŒ Ù…Ù† Ø§Ù„Ø£Ø¯Ù†Ù‰ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø¹Ù„Ù‰.  ÙŠØ£ØªÙŠ Ø¨Ø¹Ø¯ Ø°Ù„Ùƒ Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„ØªÙƒØ§ÙØ¤ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡.  ÙŠÙˆØ¬Ø¯ ÙÙŠ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Øª ØªÙˆÙ‚Ù ("ÙˆØ­Ø¯Ø©" Ù…Ù†Ø·Ù‚ÙŠØ©) ØŒ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠØ®ØªÙ„Ù Ø·ÙˆÙ„Ù‡Ø§.  ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø«Ø§Ù„ Ù…Ù† Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© ÙÙŠ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ© Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ù‚Ø§Ù„Ø©.  ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­ÙˆÙ„ UART Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø¨ÙƒØ© ØŒ ÙˆØ§Ù„ÙƒØ«ÙŠØ± Ù…Ù† Ø§Ù„Ù…ÙˆØ§Ø¯.  ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… UART Ù„Ø£ØºØ±Ø§Ø¶ Ø£Ø®Ø±Ù‰ ØŒ Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„ PWM ØŒ ÙˆÙ„ÙƒÙ† ÙÙŠ Ø­Ø§Ù„ØªÙ†Ø§ ØŒ Ù‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù†Ù‡ Ù…Ù† Ø§Ù„Ù…Ù…ÙƒÙ† Ù†Ø¸Ø±ÙŠÙ‹Ø§ Ù†Ù‚Ù„ Ø¥Ø´Ø§Ø±Ø© ØµÙˆØªÙŠØ© ÙƒØ§Ù…Ù„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø³Ù…Ø§Ø¹Ø© ØŒ ÙƒÙ…Ø§ Ù‡Ùˆ Ø§Ù„Ø­Ø§Ù„ ÙÙŠ Ù…Ø´ØºÙ„Ø§Øª wav Ø¹Ù„Ù‰ ÙˆØ­Ø¯Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©.  ÙˆÙ…Ø¹ Ø°Ù„Ùƒ ØŒ Ø£ÙˆØ¯ Ø£Ù† Ø£Ù‚ØªØ±Ø­ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙƒÙ…ÙˆÙ„Ø¯ Ù…ØªØ¹Ø±Ø¬.  ÙŠÙ…ÙƒÙ† ØªÙˆÙÙŠØ± ØªØ±Ø¯Ø¯ Ø§Ù„Ù†ØºÙ…Ø© ÙˆØ·ÙˆØ± Ø§Ù„Ø¥Ø´Ø§Ø±Ø© ÙÙŠ Ø´ÙƒÙ„ Ø¨ØªØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØŒ Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„ ØŒ Ø³ÙˆÙ ÙŠØ®Ù„Ù‚ <i>00001111 Ù…ØªØ¹Ø±Ø¬Ù‹Ø§</i> ØªÙƒÙˆÙ† ÙØªØ±ØªÙ‡ Ù…Ø³Ø§ÙˆÙŠØ© Ù„Ù€ 10 ÙØªØ±Ø§Øª Ù…Ù† ÙˆÙ‚Øª Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨ØªØ© ÙˆØ§Ø­Ø¯Ø© (Ø­ÙŠØ« ÙŠÙˆØ¬Ø¯ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø­Ø§Ù„Ø© Ø£ÙŠØ¶Ù‹Ø§ Ø¨Øª Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ ÙŠØ³Ø§ÙˆÙŠ 0 ÙˆØªÙˆÙ‚Ù ØªÙˆÙ‚Ù ÙŠØ³Ø§ÙˆÙŠ 1).  Ù†Ø¸Ø±Ù‹Ø§ Ù„Ø¨ØªØ§Øª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„ØªÙˆÙ‚Ù ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù†Ù‚Ù„ Ø¬Ù…ÙŠØ¹ ÙØªØ±Ø§Øª Ø§Ù„ØªØ¹Ø±Ø¬ ØŒ Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„ ØŒ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø­Ø§Ù„Ø© <i>01100110</i> ØŒ Ø­ÙŠØ« Ø³Ù†Ø³ØªÙ…Ø¹ ÙÙŠ Ø§Ù„Ø£Ø³Ø§Ø³ Ø¥Ù„Ù‰ Ù…Ø«Ù„ Ù‡Ø°Ø§ Ø§Ù„ØªØ³Ù„Ø³Ù„ ÙÙŠ Ø§Ù„Ø­Ø§ÙÙ„Ø© <i>0011001101</i> .  Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ³ØªØ®Ø¯Ù… Ù…Ø¹Ø¯Ù„ Ù†Ù‚Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ø§Ù„ÙŠÙ‹Ø§ ØŒ Ø¹Ù„Ù‰ Ø³Ø¨ÙŠÙ„ Ø§Ù„Ù…Ø«Ø§Ù„ 115200 Ø¨ÙˆØ¯ ØŒ ÙÙ…Ù† Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠ Ø¥Ù†Ø´Ø§Ø¡ ØªØ±Ø¯Ø¯Ø§Øª ØµÙˆØªÙŠØ© Ù…Ø³Ù…ÙˆØ¹Ø© Ø¹Ù† Ø·Ø±ÙŠÙ‚ ØªÙ…Ø¯ÙŠØ¯ ÙØªØ±Ø§Øª meadras Ø¨Ø¹Ø¯Ø© Ø¨Ø§ÙŠØª. <br><br><h3 style=";text-align:right;direction:rtl">  <b>...</b> </h3><br>  Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Ø§Ù„Ø±Ø§Ø¨Ø·</a> ÙŠÙ…ÙƒÙ†Ùƒ ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ ØµÙˆØª Ù†Ø§Ù‚Ù„ <i>UART</i> .  Ù‡Ù†Ø§Ùƒ Ø£ÙŠØ¶Ù‹Ø§ Ø¥ØµØ¯Ø§Ø± ÙŠØ³ØªØ®Ø¯Ù… OpenAL Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙˆØª Ø£Ø«Ù†Ø§Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ ØŒ ÙˆÙ‡Ù†Ø§ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Ø§Ù„Ø±Ø§Ø¨Ø·</a> . <br><br>  ÙŠØªÙ… ØªÙˆÙÙŠØ± Ø±Ù…Ø² Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø§Ù„Ù…ØµØ¯Ø± Ø£Ø¯Ù†Ø§Ù‡: <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">Ù…Ù„Ù Ø§Ù„Ø±Ø£Ø³ SoundsDigitalBus.h</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SOUNDS_DIGITAL_BUS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOUNDS_DIGITAL_BUS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_WAV_FILE_NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sdb_output.wav"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BIT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_PARITY 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_STOP_BIT 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BAUDRATE 9600 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BAUDRATE_MAX 921600 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///   ()   #define SDB_MAX_DATA 30000 ///    #define SDB_CANNEL 1 /// -  ()  #define SDB_BIT 16 ///    #define SDB_FREQUENCY 96000 ///     OpenAL #define OPENAL_NUM_OF_DYNBUF 32 ///  OpenAL #define SDB_OPENAL_BIT SDB_BIT #define SDB_OPENAL_CANNEL SDB_CANNEL #define SDB_OPENAL_FREQUENCY SDB_FREQUENCY #define SDB_OPENAL_FORMAT AL_FORMAT_MONO16 ///     #define SDB_BUFFER_MAX 4800 ///  OpenAL    ( ,   1) #define SDB_WITH_OPENAL 1 ///   ( ,   1) #define SDB_WITH_DEBUG_MODE 0 #if SDB_WITH_OPENAL == 1 //   OpenAL    #include &lt;openal/al.h&gt; #include &lt;openal/alc.h&gt; #endif #if SDB_WITH_DEBUG_MODE == 1 //    #include &lt;stdio.h&gt; #include &lt;locale.h&gt; #endif //    #include &lt;stdio.h&gt; //    #include &lt;string.h&gt; class sdb { private: #if SDB_WITH_OPENAL == 1 //   openAl    //   speesy ALCdevice* openAlDevice; ALCcontext* openAlContext; ALuint openAlSource; signed char openAlnBuf; //  #endif // ---------------------------------------- //    WAV  FILE *fpSave; unsigned short wavBlockAlign; unsigned long wavSubchunk2Size; unsigned long wavChunkSize; unsigned char wavLenDataType; // ---------------------------------------- //      double dTime; //    ,  . double allTime; //    short busState; //   ( ) short busDataOne[SDB_BUFFER_MAX]; // ,   wav short busDataTwo[SDB_BUFFER_MAX]; unsigned char switchBuffer; //    unsigned int posBufferOne, posBufferTwo; //    unsigned int posAllBuffer; //   char wavFileName[512]; //  wav  char isCreateWavFileFlag; // ,  wav    char isBufferOneFlag; // ,     char isBufferTwoFlag; unsigned int uartBaudrate; //  UART   unsigned int uartT; unsigned char uartBit; //   unsigned char uartStopBit; //    unsigned char uartParityBit; unsigned char isAudioOutput; unsigned char isWavFileOutput; #if SDB_WITH_OPENAL == 1 ALboolean CheckALCError(void); ALboolean CheckALError(void); char initOpenAL(void); void destroyOpenAL(void); void playOpenAlSound(void); void stopOpenAlSound(void); void closeOpenAlSound(void); int getBufferStatusOpenAl(void); void setBufferOpenAl(signed short *buf,unsigned long siz); char updateOpenAl(void); #endif char createWavFile(char * filename,unsigned long sampleRate,unsigned short bitsPerSample, unsigned short numChannels); void writeSampleWavFile(void *data); void writeDataBlockWavFile(void *data,unsigned long len); void closeWavFile(void); void busDelay(unsigned short us); public: sdb(void); ~sdb(void); /** @brief       1-wire @param[in] data     1-wire */ void oneWireSendByte(unsigned char data); /** @brief     1-wire */ void oneWireReset(void); /** @brief    1- wire */ void oneWireStop(void); /** @brief      UART @param[in] data    UART */ void uartSendByte(unsigned char data); /** @brief     UART @param[in] data    UART */ void uartSend(unsigned long data); /** @brief   UART @param[in] baudrate   UART */ void uartSetBaudrate(unsigned long baudrate); /** @brief     @param[in] bit  ,   UART    */ void uartSetBit(unsigned char bit); /** @brief          .     1. @param[in] bit    */ void uartSetStopBit(unsigned char bit); /** @brief          UART  .   1,     ,   0,     UART     . @param[in] state ,   . */ void uartSetParityBit(unsigned char state); /** @brief    UART     UART,     .         . */ void uartStop(void); /** @brief    wav  @param[in] filename  wav  */ void setWavFileName(char* filename); /** @brief     OpenAL */ void playAudioOn(void); /** @brief     OpenAL */ void playAudioOff(void); /** @brief     wav  */ void recordOn(void); /** @brief     wav  */ void recordOff(void); }; #endif // MUSICDIGITALBUS_H_INCLUDED</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">ÙƒÙˆØ¯ Ø§Ù„Ù…ØµØ¯Ø± Ù„Ù…Ù„Ù SoundsDigitalBus.cpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SoundsDigitalBus.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SDB_WITH_OPENAL == 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   ALboolean sdb::CheckALCError(void) { ALenum ErrCode; ErrCode = alcGetError(openAlDevice); if (ErrCode != ALC_NO_ERROR) { return AL_FALSE; } return AL_TRUE; } ALboolean sdb::CheckALError(void) { ALenum ErrCode; if ((ErrCode = alGetError()) != AL_NO_ERROR) { return AL_FALSE; } return AL_TRUE; } //  OpenAL char sdb::initOpenAL(void) { ALfloat SourcePos[] = {0.0, 0.0, 0.0}; ALfloat SourceVel[] = {0.0, 0.0, 0.0}; //  . ALfloat ListenerPos[] = { 0.0, 0.0, 0.0 }; //  . ALfloat ListenerVel[] = { 0.0, 0.0, 0.0 }; //  . ( 3  â€“  Â«Â»,  3 â€“ Â«Â») ALfloat ListenerOri[] = { 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 }; #if SDB_WITH_DEBUG_MODE == 1 printf("alcOpenDevice\n"); #endif openAlDevice = alcOpenDevice(0); // open default device if (openAlDevice != 0) { openAlContext = alcCreateContext(openAlDevice,0); // create context if (openAlContext != 0) { #if SDB_WITH_DEBUG_MODE == 1 printf("alcMakeContextCurrent\n"); #endif alcMakeContextCurrent(openAlContext); // set active context } else { #if SDB_WITH_DEBUG_MODE == 1 printf("Error context\n"); #endif return 0; } } else { #if SDB_WITH_DEBUG_MODE == 1 printf("Error Open Device\n"); #endif return 0; } //  alListenerfv(AL_POSITION, ListenerPos); //  alListenerfv(AL_VELOCITY, ListenerVel); //  alListenerfv(AL_ORIENTATION, ListenerOri); alGenSources(1, &amp;openAlSource); if (!CheckALError()) return false; alSourcef (openAlSource, AL_PITCH, 1.0f); alSourcef (openAlSource, AL_GAIN, 1.0f); alSourcefv(openAlSource, AL_POSITION, SourcePos); alSourcefv(openAlSource, AL_VELOCITY, SourceVel); alSourcei (openAlSource, AL_LOOPING, AL_FALSE); alSourcei(openAlSource, AL_LOOPING, AL_FALSE); openAlnBuf = 0; return 1; } void sdb::destroyOpenAL(void) { alSourceStop(openAlSource); //    alcMakeContextCurrent(0); //   alcDestroyContext(openAlContext); //    alcCloseDevice(openAlDevice); } void sdb::playOpenAlSound(void) { alSourcePlay(openAlSource); } void sdb::stopOpenAlSound(void) { alSourceStop(openAlSource); } void sdb::closeOpenAlSound(void) { alSourceStop(openAlSource); if (alIsSource(openAlSource)) alDeleteSources(1, &amp;openAlSource); } int sdb::getBufferStatusOpenAl(void) { int processed = 0; if (openAlnBuf == 0) return 1; alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); CheckALError(); #if SDB_WITH_DEBUG_MODE == 1 printf("getBufferStatus: %d\n",processed); #endif if (processed != 0) { return processed; } return 0; } void sdb::setBufferOpenAl(signed short* buf, unsigned long siz) { int processed = 0; ALuint BufID = 0; #if _OPENAL_FORMAT == AL_FORMAT_MONO16 siz = siz*2; #endif // _OPENAL_FORMAT #if _OPENAL_FORMAT == AL_FORMAT_STEREO16 siz = siz*4; #endif // _OPENAL_FORMAT #if _OPENAL_FORMAT == AL_FORMAT_STEREO8 siz = siz*2; #endif // _OPENAL_FORMAT //     alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); CheckALError(); //   ,          if ((processed == 0) &amp;&amp; (openAlnBuf &lt; OPENAL_NUM_OF_DYNBUF)) { openAlnBuf++; //   alGenBuffers(1, &amp;BufID); //   alBufferData(BufID,SDB_OPENAL_FORMAT,buf,siz,SDB_OPENAL_FREQUENCY); //     alSourceQueueBuffers(openAlSource, 1, &amp;BufID); //    if (openAlnBuf == 1) alSourcePlay(openAlSource); } else { #if SDB_WITH_DEBUG_MODE == 1 printf("processed: %d openAlnBuf: %d\n",processed,openAlnBuf); #endif // ,        while (getBufferStatusOpenAl() == 0); //     alSourceUnqueueBuffers(openAlSource, 1, &amp;BufID); CheckALError(); //    alBufferData(BufID,SDB_OPENAL_FORMAT,buf,siz,SDB_OPENAL_FREQUENCY); CheckALError(); alSourceQueueBuffers(openAlSource, 1, &amp;BufID); CheckALError(); } } //        ,    //  1       char sdb::updateOpenAl(void) { int processed = 0; ALuint BufID; //     alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); #if SDB_WITH_DEBUG_MODE == 1 printf("updateOpenAl: %d\n",processed); #endif //     if (openAlnBuf == processed) { //     while (processed--) { //     alSourceUnqueueBuffers(openAlSource, 1, &amp;BufID); if (!CheckALError()) return 0; alDeleteBuffers(1, &amp;BufID); openAlnBuf--; } alSourceStop(openAlSource); #if SDB_WITH_DEBUG_MODE == 1 printf("alSourceStop: %d\n",openAlnBuf); #endif return 0; } return 1; } #endif //    .    void sdb::busDelay(unsigned short us) { double Time = (double)us/1000000.0; double locTime = allTime; char isFlag = 0; //  wav ,       if (isCreateWavFileFlag == 0) { if (isWavFileOutput == 1) { isFlag = createWavFile(wavFileName,SDB_FREQUENCY,SDB_BIT,SDB_CANNEL); //     ,    if (isFlag == 1) isCreateWavFileFlag = 1; } if (isAudioOutput == 1) { initOpenAL(); if (isWavFileOutput == 0) isCreateWavFileFlag = 1; } } allTime = allTime + Time; //     if (isCreateWavFileFlag == 1) //     while(locTime &lt; allTime) { if (switchBuffer == 0) { if (posBufferOne &gt;= SDB_BUFFER_MAX) { posBufferOne = 0; posBufferTwo = 0; busDataTwo[posBufferTwo++] = busState; isBufferOneFlag = 1; switchBuffer = 1; if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,SDB_BUFFER_MAX); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,SDB_BUFFER_MAX); #endif } else { busDataOne[posBufferOne++] = busState; } } else if (switchBuffer == 1) { if (posBufferTwo &gt;= SDB_BUFFER_MAX) { posBufferOne = 0; posBufferTwo = 0; busDataOne[posBufferOne++] = busState; isBufferTwoFlag = 1; switchBuffer = 0; if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,SDB_BUFFER_MAX); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,SDB_BUFFER_MAX); #endif } else { busDataTwo[posBufferTwo++] = busState; } } posAllBuffer++; locTime = locTime + dTime; } } char sdb::createWavFile(char * filename,unsigned long sampleRate,unsigned short bitsPerSample, unsigned short numChannels) { char type[4]; const unsigned long subchunk1Size = 16; unsigned long byteRate; const unsigned short audioFormat = 1; unsigned short len_str = 0; char str_filename[512] = {0}; unsigned short i; //        wavLenDataType = bitsPerSample/8; wavSubchunk2Size = 0; wavChunkSize = wavSubchunk2Size + 44 - 8; //      wavBlockAlign = bitsPerSample / (8 * numChannels); // ,    . byteRate = sampleRate * wavBlockAlign; strcpy(str_filename,filename); len_str = strlen(str_filename); if (len_str &lt; 4) return 0; //       .wav i = 0; while(i &lt; len_str) { if (filename[i] == '.' &amp;&amp; (i + 3) &lt; len_str) { if (((filename[i + 1] == 'w') &amp;&amp; (filename[i + 2] == 'a') &amp;&amp; (filename[i + 3] == 'v')) || ((filename[i + 1] == 'W') &amp;&amp; (filename[i + 2] == 'A') &amp;&amp; (filename[i + 3] == 'V'))) { //     wav break; } else { if ((i + 3) &gt;= 512) return 0; filename[i + 1] = 'w'; filename[i + 2] = 'a'; filename[i + 3] = 'v'; len_str = i + 4; break; } } else if ((i + 1) == len_str) { if ((i + 3) &gt;= 512) return 0; filename[i + 1] = '.'; filename[i + 2] = 'w'; filename[i + 3] = 'a'; filename[i + 4] = 'v'; len_str = i + 5; break; } i++; } type[0] = filename[len_str - 4]; type[1] = filename[len_str - 3]; type[2] = filename[len_str - 2]; type[3] = filename[len_str - 1]; if (type[0]!='.'||type[1]!='w'||type[2]!='a'||type[3]!='v') { if (type[0]!='.'||type[1]!='W'||type[2]!='A'||type[3]!='V') { return 0; } } fpSave=fopen(str_filename,"wb"); type[0]='R'; type[1]='I'; type[2]='F'; type[3]='F'; fwrite(&amp;type,sizeof(char),4,fpSave); fwrite(&amp;wavChunkSize,sizeof(unsigned long),1,fpSave); type[0]='W'; type[1]='A'; type[2]='V'; type[3]='E'; fwrite(&amp;type,sizeof(char),4,fpSave); type[0]='f'; type[1]='m'; type[2]='t'; type[3]=' '; fwrite(&amp;type,sizeof(char),4,fpSave); fwrite(&amp;subchunk1Size,sizeof(unsigned long),1,fpSave); fwrite(&amp;audioFormat,sizeof(unsigned short),1,fpSave); fwrite(&amp;numChannels,sizeof(unsigned short),1,fpSave); fwrite(&amp;sampleRate,sizeof(unsigned long),1,fpSave); fwrite(&amp;byteRate,sizeof(unsigned long),1,fpSave); fwrite(&amp;wavBlockAlign,sizeof(unsigned short),1,fpSave); //    .   â€œâ€   . 8 , 16   .. fwrite(&amp;bitsPerSample,sizeof(unsigned short),1,fpSave); type[0]='d'; type[1]='a'; type[2]='t'; type[3]='a'; // subchunk2Id //   â€œdataâ€ (0x64617461  big-endian ) fwrite(&amp;type, sizeof(char), 4,fpSave); wavSubchunk2Size = 0; //    . fwrite(&amp;wavSubchunk2Size, sizeof(unsigned long), 1,fpSave); return 1; } void sdb::writeSampleWavFile(void* data) { fwrite(data, wavLenDataType, wavBlockAlign, fpSave); wavSubchunk2Size = wavSubchunk2Size + wavLenDataType*wavBlockAlign; } void sdb::writeDataBlockWavFile(void* data, unsigned long len) { fwrite(data, wavLenDataType, len, fpSave); wavSubchunk2Size = wavSubchunk2Size + len*wavLenDataType; } //         . void sdb::closeWavFile(void) { wavChunkSize = wavSubchunk2Size + 44 - 8; fseek(fpSave,4,SEEK_SET); fwrite(&amp;wavChunkSize,4,1,fpSave); fseek(fpSave,40,SEEK_SET); fwrite(&amp;wavSubchunk2Size,4,1,fpSave); fclose(fpSave); } //  sdb::sdb(void) { openAlnBuf = 0; wavBlockAlign = 0; wavSubchunk2Size = 0; wavChunkSize = 0; wavLenDataType = 0; fpSave = NULL; strcat(wavFileName,SDB_WAV_FILE_NAME); dTime = 1.0/(double)SDB_OPENAL_FREQUENCY; allTime = 0.0; //      switchBuffer = 0; //    () posAllBuffer = 0; //     posBufferOne = 0; posBufferTwo = 0; isBufferOneFlag = 0; isBufferTwoFlag = 0; isCreateWavFileFlag = 0; busState = SDB_MAX_DATA; uartSetBaudrate(SDB_UART_BAUDRATE); uartSetBit(SDB_UART_BIT); uartSetStopBit(SDB_UART_STOP_BIT); uartSetParityBit(SDB_UART_PARITY); recordOn(); playAudioOn(); } //  sdb::~sdb() { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferTwo); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) { while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); } #endif } } //      one wire void sdb::oneWireSendByte(unsigned char data) { for (register unsigned char i = 0; i &lt; 8; i++) { if((data &amp; (1 &lt;&lt; i)) == 1 &lt;&lt; i) { busState = 0; busDelay(12); busState = SDB_MAX_DATA; busDelay(65); } else { busState = 0; busDelay(65); busState = SDB_MAX_DATA; busDelay(12); } } busState = SDB_MAX_DATA; } //       uart void sdb::uartSendByte(unsigned char data) { unsigned short pBit = 0; //     //   busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; //  for (register unsigned char i = 0; i &lt; 8; i++) { if((data &amp; (1&lt;&lt;i)) == 1&lt;&lt;i) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; pBit++; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   if (uartParityBit != 0) { if ((pBit &amp; 0x0001) == 0) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   busState = -SDB_MAX_DATA; for (register unsigned char i = 0; i &lt; uartStopBit; i++) busDelay(uartT); busState = -SDB_MAX_DATA; } //      uart void sdb::uartSend(unsigned long data) { unsigned short pBit = 0; //     //   busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; //  for (register unsigned char i = 0; i &lt; uartBit; i++) { if((data &amp; (1&lt;&lt;i)) == 1&lt;&lt;i) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   if (uartParityBit != 0) { if ((pBit &amp; 0x0001) == 0) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   busState = -SDB_MAX_DATA; for (register unsigned char i = 0; i &lt; uartStopBit; i++) busDelay(uartT); busState = -SDB_MAX_DATA; } //    UART void sdb::uartSetBaudrate(unsigned long baudrate) { if (baudrate &gt; SDB_UART_BAUDRATE_MAX) baudrate = SDB_UART_BAUDRATE_MAX; uartBaudrate = baudrate; uartT = 1000000 / baudrate; } void sdb::uartSetBit(unsigned char bit) { if (bit &gt; 32) bit = 32; if (bit == 0) bit = 1; if (bit &lt; 8) bit = 8; uartBit = bit; } void sdb::uartSetStopBit(unsigned char bit) { if (bit == 0) bit = 1; uartStopBit = bit; } void sdb::uartSetParityBit(unsigned char state) { if (state &gt; 1) state = 1; uartParityBit = state; } //       void sdb::oneWireReset(void) { busState = SDB_MAX_DATA; busDelay(100); busState = 0;// "0" busDelay(485);//  480 busState = SDB_MAX_DATA; busDelay(65);//  60      busState = 0;// "0" busDelay(400); busState = SDB_MAX_DATA; busDelay(100); } //    1-wire void sdb::oneWireStop(void) { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferOne); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } #if SDB_WITH_OPENAL == 1 while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); #endif if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; } } void sdb::uartStop(void) { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferOne); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) { while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); } #endif if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; } } void sdb::setWavFileName(char* filename) { strcat(wavFileName,filename); } void sdb::playAudioOn(void) { if (isCreateWavFileFlag == 0) isAudioOutput = 1; } void sdb::playAudioOff(void) { if (isCreateWavFileFlag == 0) isAudioOutput = 0; } void sdb::recordOn(void) { if (isCreateWavFileFlag == 0) isWavFileOutput = 1; } void sdb::recordOff(void) { if (isCreateWavFileFlag == 0) { if (isAudioOutput == 1) isWavFileOutput = 0; else isWavFileOutput = 1; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">Ø§Ù„Ù…Ù„Ù main.h</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LINUX 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WINDOWS 0x01 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RU 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EN 0x01 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///    #define TYPE_OS WINDOWS ///   #define LANGUAGE_PROGRAM RU #define UART_BUS 0x01 #define ONE_WIRE_BUS 0x02 #include &lt;iostream&gt; #include "SoundsDigitalBus.h" #include "stdlib.h" #include &lt;stdio.h&gt; #endif // MAIN_H_INCLUDED</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">Ù…Ù„Ù main.cpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> sdb soundsDigitalBus; int main() { static FILE *fp = NULL; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    char strData[512]; //    char strChar = 0; //  unsigned char busType; //    int strPos = 0; //    int uartBaudrate = 0; //  UART int uartBit = 8; int uartStopBit = 0; //int uartParityBit = 0; #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU setlocale(LC_ALL, "Russian"); printf("  UART  ,   0,   1-wire.\n"); #else printf("Enter the UART baud rate, or specify 0 if you want 1-wire.\n"); #endif printf("UART Baudrate: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartBaudrate = atoi(strData); if (uartBaudrate == 0) { busType = ONE_WIRE_BUS; } else { busType = UART_BUS; soundsDigitalBus.uartSetBaudrate(uartBaudrate); } printf("\n"); if (busType == UART_BUS) { #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("   UART\n"); #else printf("Enter the number of bits UART.\n"); #endif printf("UART bit: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartBit = atoi(strData); soundsDigitalBus.uartSetBit(uartBit); printf("\n"); #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("    UART\n"); #else printf("Enter the number of stop bits UART.\n"); #endif printf("UART stop bit: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartStopBit = atoi(strData); soundsDigitalBus.uartSetStopBit(uartStopBit); printf("\n"); #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("    UART? (Y/n)\n"); #else printf("Use the parity bit in the UART? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.uartSetParityBit(0); printf("not used\n"); } else { soundsDigitalBus.uartSetParityBit(1); printf("Yes, use\n"); } getchar(); printf("\n"); } FILE_M: printf("\n"); #if TYPE_OS==WINDOWS printf("        .\n"); printf(": D: \\ Games \\ SR2 \\ Rangers.txt\n"); printf(": "); #else printf("Specify the file to convert it to record digital bus.\n"); printf("For example: D: \\ Games \\ SR2 \\ Rangers.txt\n"); printf("File: "); #endif memset(strData,0,512); strPos = 0; while(1) { strChar = getchar(); if (strChar != '\n') { strData[strPos++] = strChar; } else break; } fp = fopen(strData,"rb"); if (fp == NULL) { printf("\n"); #if TYPE_OS==WINDOWS printf("!  %s  !\n",strData); printf("     .\n"); printf("...\n"); #else printf("Error! File %s not found!\n",strData); printf("Try to correctly specify the path to the file.\n"); printf("...\n"); #endif getchar(); goto FILE_M; } //soundsDigitalBus.setWavFileName(strData); printf("\n"); #if SDB_WITH_OPENAL == 1 #if TYPE_OS==WINDOWS printf("      ? (Y/n)\n"); #else printf("Play audio while working digital bus? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.playAudioOff(); printf("not used\n"); } else { soundsDigitalBus.playAudioOn(); printf("Yes, use\n"); } getchar(); printf("\n"); #if TYPE_OS==WINDOWS printf("      ? (Y/n)\n"); #else printf("Record audio while working digital bus? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.recordOff(); printf("not used\n"); } else { soundsDigitalBus.recordOn(); printf("Yes, use\n"); } getchar(); #else soundsDigitalBus.recordOn(); #endif printf("\n"); #if TYPE_OS==WINDOWS printf(" .\n"); #else printf("The transformation started.\n"); #endif unsigned char uartData[8]; if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireReset(); } while(1) { if (fread(uartData,sizeof(unsigned char),1,fp) &gt; 0) { if (busType == UART_BUS) { if (uartBit == 8) { soundsDigitalBus.uartSendByte(uartData[0]); } else { soundsDigitalBus.uartSend(uartData[0]); } } else if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireSendByte(uartData[0]); } } else break; } fclose(fp); if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireStop(); } else if (busType == UART_BUS) { soundsDigitalBus.uartStop(); } #if TYPE_OS==WINDOWS printf(" .\n"); #else printf("Conversion completed.\n"); #endif return 0; //soundsDigitalBus.oneWireReset(); soundsDigitalBus.uartSetBaudrate(1200); for (int i = 0; i &lt; 256; i ++) { for (int len = 0; len &lt; 8; len++) { soundsDigitalBus.uartSendByte(i); } printf("%d\n",i); } soundsDigitalBus.oneWireStop(); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  <b>Ù…Ù„Ø§Ø­Ø¸Ø©</b> Ù„Ø§Ø­Ø¸Øª Ø®Ø·Ø£ ÙÙŠ Ø´ÙØ±Ø© Ø§Ù„Ù…ØµØ¯Ø± Ø£Ù† Ø¨Øª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ù‡Ùˆ Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠ 1 ØŒ ÙˆÙ„ÙŠØ³ 0 ØŒ ÙˆØ£Ù† Ø¨Øª Ø§Ù„ØªÙˆÙ‚Ù Ù‡ÙŠ 0 ØŒ ÙˆÙ„ÙŠØ³ 1. Ù…Ù† ÙŠØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ ØªØ·Ø§Ø¨Ù‚ Ø£Ø³Ø§Ø³ÙŠ Ù„Ø¥Ø´Ø§Ø±Ø© ØµÙˆØª Ø§Ù„ÙˆØ§Ù‚Ø¹ ÙŠÙ…ÙƒÙ†Ù‡ Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø®Ø·Ø£ Ù†ÙØ³Ù‡. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar408485/">https://habr.com/ru/post/ar408485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar408475/index.html">ÙƒÙŠÙ ÙˆØµÙ„Øª Ø¥Ù„Ù‰ Ø§Ù„Ø¯Ø±Ø§Ø¬Ø© Ø§Ù„Ù‡ÙˆØ§Ø¦ÙŠØ© Ø§Ù„Ø£Ø­Ø§Ø¯ÙŠØ© Ø§Ù„Ø¹Ø¬Ù„Ø©</a></li>
<li><a href="../ar408477/index.html">"Ø§Ù„Ù„Ø¹Ù†Ø© ØŒ Ø­Ù„Ù‚Øª Ø­Ø´Ø±Ø© Ø¹Ù…Ù„Ø§Ù‚Ø© ÙÙˆÙ‚ÙŠ": Ø¥ØµØ¯Ø§Ø± SDK Ù„Ù„ØµÙˆØª Ø§Ù„Ù…Ø­ÙŠØ·ÙŠ</a></li>
<li><a href="../ar408479/index.html">Ø§Ù„Ø¹Ù„Ù…Ø§Ø¡: Ø¨Ø³Ø¨Ø¨ Ø¨ÙˆÙƒÙŠÙ…ÙˆÙ† Ø¬Ùˆ ÙÙŠ Ø­Ø§Ø¯Ø« Ù…Ø±ÙˆØ±ÙŠ Ù‚ØªÙ„ Ø§Ù„Ø¢Ù„Ø§Ù Ù…Ù† Ø§Ù„Ù†Ø§Ø³ Ø­ÙˆÙ„ Ø§Ù„Ø¹Ø§Ù„Ù…</a></li>
<li><a href="../ar408481/index.html">Ø§Ù„Ù†Ø¸Ø±ÙŠØ§Øª ÙˆØ§Ù„ÙØ±Ø§ØºØ§Øª</a></li>
<li><a href="../ar408483/index.html">Ù†ØªØ¹Ù„Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© Ù…Ù† Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±</a></li>
<li><a href="../ar408487/index.html">Ù„Ù† ØªÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø£Ø®ØªØ§Ù… Ø¨Ø¯ÙˆÙ† Ø£Ø¯ÙˆØ§Øª Ø¬Ø¯ÙŠØ¯Ø©: Ø³ÙŠØªÙˆÙ‚Ù YouTube Ø¹Ù† Ø§Ù„Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© -2</a></li>
<li><a href="../ar408489/index.html">Ù„Ø¹Ø¨Ø© Ø§Ù… Ù„Ø§. Ù…Ø§Ø°Ø§ Ø¹Ù† Ø§Ù„Ø³ÙŠÙ†Ù…Ø§ Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©ØŸ</a></li>
<li><a href="../ar408491/index.html">Ø¥Ø·Ù„Ø§Ù‚ ICO Descrow Ø§Ù„ÙŠÙˆÙ…</a></li>
<li><a href="../ar408493/index.html">Ø£ÙƒØ«Ø± Ø¯ÙˆÙ„ Ø§Ù„Ø¹Ø§Ù„Ù… "ØµØ¯ÙŠÙ‚Ø© Ù„Ù„Ø¨ÙŠØªÙƒÙˆÙŠÙ†"</a></li>
<li><a href="../ar408495/index.html">Ø§Ù„Ø¶Ù…Ø§Ù† ÙˆØªØ·ÙˆØ±Ù‡ Ø¥Ù„Ù‰ Ø§Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ù„Ø§Ù…Ø±ÙƒØ²ÙŠ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>