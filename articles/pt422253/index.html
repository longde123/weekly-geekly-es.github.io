<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÆ üëàüèº üòä Estrutura de front-end do Yew - Rust & WebAssembly ‚Ü©Ô∏è üëÜüèΩ üëåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yew √© um an√°logo de React and Elm, escrito inteiramente em Rust e compilado em um WebAssembly honesto. No artigo, Denis Kolodin, desenvolvedor do Yew,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estrutura de front-end do Yew - Rust & WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422253/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Yew</a> √© um an√°logo de React and Elm, escrito inteiramente em Rust e compilado em um WebAssembly honesto.  No artigo, Denis Kolodin, desenvolvedor do Yew, fala sobre como voc√™ pode criar uma estrutura sem um coletor de lixo, garantir efetivamente a imutabilidade, sem a necessidade de copiar o estado devido √†s regras de propriedade dos dados do Rust e quais s√£o os recursos ao converter o Rust para o WebAssembly. <br><br><img src="https://habrastorage.org/webt/dc/ro/wt/dcrowtesfnjfmpr7wl9j0suzjug.jpeg"><br><br>  <i>A publica√ß√£o foi preparada com base no relat√≥rio de Denis na confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HolyJS 2018 Piter</a> .</i>  <i>Sob o recorte - transcri√ß√£o de v√≠deo e texto do relat√≥rio.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OqFOXMIwzTc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Denis Kolodin trabalha para o Bitfury Group, uma empresa que desenvolve v√°rias solu√ß√µes de blockchain.</i>  <i>H√° mais de dois anos, ele codifica o Rust, uma linguagem de programa√ß√£o da Mozilla Research.</i>  <i>Durante esse per√≠odo, Denis conseguiu estudar completamente essa linguagem e us√°-la para desenvolver v√°rios aplicativos de sistema, um back-end.</i>  <i>Agora, em conex√£o com o advento do padr√£o WebAssembly, comecei a olhar para o front-end.</i> <br><br><h2>  Agenda </h2><br>  Hoje vamos aprender sobre o que √© Yew (o nome da estrutura l√™ o mesmo que a palavra em ingl√™s "voc√™" - voc√™; "yew" √© um teixo traduzido do ingl√™s). <br><br>  Vamos falar um pouco sobre aspectos arquitet√¥nicos, sobre quais id√©ias a estrutura √© constru√≠da, sobre as possibilidades incorporadas nela, bem como sobre os recursos que o Rust tamb√©m nos oferece em compara√ß√£o com outros idiomas. <br><br>  No final, mostrarei como come√ßar a usar o Yew e o WebAssembly hoje. <br><br><h2>  O que √© o teixo? </h2><br>  Antes de tudo, este √© o WebAssembly, ou seja,  bytecode execut√°vel que funciona em navegadores.  √â necess√°rio para executar algoritmos complexos no lado do usu√°rio, por exemplo, criptografia, codifica√ß√£o / decodifica√ß√£o.  √â mais f√°cil implementar isso nas linguagens do sistema do que aparafusar muletas. <br><br>  O WebAssembly √© um padr√£o claramente descrito, compreendido e suportado por todos os navegadores modernos.  Permite usar v√°rias linguagens de programa√ß√£o.  E isso √© interessante principalmente porque voc√™ pode reutilizar o c√≥digo criado pela comunidade em outros idiomas. <br><br>  Se desejar, voc√™ pode escrever completamente um aplicativo no WebAssembly, e o Yew pode fazer isso, mas √© importante n√£o esquecer que, mesmo nesse caso, o JavaScript permanece no navegador.  √â necess√°rio preparar o WebAssembly - pegue o m√≥dulo (WASM), inclua o ambiente e execute-o.  I.e.  JavaScript √© indispens√°vel.  Portanto, vale a pena considerar o WebAssembly como uma extens√£o e n√£o uma alternativa revolucion√°ria ao JS. <br><br><h3>  Como √© o desenvolvimento </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/9ef/8d5/b7f/9ef8d5b7ffb36029d2a4d840f9432980.png"><br><br>  Voc√™ tem uma fonte, h√° um compilador.  Voc√™ traduz tudo isso em um formato bin√°rio e o executa em um navegador.  Se o navegador for antigo, sem o suporte do WebAssembly, o emscripten ser√° necess√°rio.  Este √©, aproximadamente, um emulador do WebAssembly para um navegador. <br><br><h3>  Yew - pronto para usar framework wasm </h3><br>  Vamos para o Yew.  Eu desenvolvi essa estrutura no final do ano passado.  Ent√£o, escrevi algum tipo de aplicativo de criptomoeda no Elm e enfrentei o fato de que, devido a restri√ß√µes de idioma, n√£o posso criar uma estrutura recursiva.  E naquele momento pensei: em Rust, meu problema seria resolvido com muita facilidade.  E como em 99% do tempo eu escrevo no Rust e adoro essa linguagem precisamente por seus recursos, decidi experimentar - compilar o aplicativo com a mesma fun√ß√£o de atualiza√ß√£o no Rust. <br><br>  O primeiro esbo√ßo levou v√°rias horas, eu tive que descobrir como compilar o WebAssembly.  Eu o lancei e percebi que em apenas algumas horas havia estabelecido o n√∫cleo, o que √© muito f√°cil de desenvolver.  Levei apenas alguns dias para trazer tudo para o mecanismo de estrutura m√≠nimo. <br><br>  Publiquei em c√≥digo aberto, mas n√£o esperava que fosse popular.  No entanto, hoje ele colecionou mais de 4 mil estrelas no GitHub.  Voc√™ pode ver o projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Existem muitos exemplos. <br><br>  A estrutura est√° completamente escrita em Rust.  O Yew suporta compila√ß√£o diretamente no WebAssembly (destino wasm32-unknown-unknown) sem emscripten.  Se necess√°rio, voc√™ pode trabalhar com o emscripten. <br><br><h2>  Arquitetura </h2><br>  Agora, algumas palavras sobre como a estrutura difere das abordagens tradicionais existentes no mundo JavaScript. <br><br>  Primeiro, mostrarei quais restri√ß√µes de idioma encontrei no Elm.  Tome o caso quando houver um modelo e houver uma mensagem que permita transformar esse modelo. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Model =    { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>    }  <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Msg    = <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span>    | Decrement</code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> -&gt;     { value = model.value + <span class="hljs-number"><span class="hljs-number">1</span></span> }   Decrement -&gt;     { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = model.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  No Elm, simplesmente criamos um novo modelo e o exibimos na tela.  A vers√£o anterior do modelo permanece inalterada.  Por que estou focando nisso?  Porque no Yew, o modelo √© mut√°vel, e essa √© uma das perguntas mais comuns.  A seguir, explicarei por que isso √© feito. <br><br>  Inicialmente, segui o caminho cl√°ssico quando o modelo foi recriado.  Mas, √† medida que a estrutura se desenvolveu, vi que n√£o faz sentido armazenar a vers√£o anterior do modelo.  O Rust permite rastrear a vida √∫til de todos os dados, modificados ou n√£o.  E assim posso mudar o modelo com seguran√ßa, sabendo que Rust controla a aus√™ncia de conflito. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span></span> {   value: <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span></span> {   Increment,   Decrement, }</code> </pre><br><pre> <code class="hljs php">match msg {   Msg::Increment =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value += <span class="hljs-number"><span class="hljs-number">1</span></span>;   }   Msg::Decrement =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value -= <span class="hljs-number"><span class="hljs-number">1</span></span>;   } }</code> </pre><br>  Este √© o primeiro momento.  O segundo ponto: por que precisamos da vers√£o antiga do modelo?  No mesmo olmo, dificilmente existe um problema de algum tipo de acesso competitivo.  O modelo antigo √© necess√°rio apenas para entender quando renderizar.  A consci√™ncia desse momento me permitiu me livrar completamente do imut√°vel e n√£o manter a vers√£o antiga. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/ff5/d94/c98ff5d946992d46ba910e36375b4fc7.png"><br><br>  Veja a op√ß√£o quando tivermos a fun√ß√£o de <code>update</code> e dois campos - <code>value</code> e <code>name</code> .  H√° um valor que √© salvo quando inserimos dados no campo de <code>input</code> .  O modelo est√° mudando. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/a12/d41/140a12d4106fb15b17204d547de29b82.png"><br><br>  √â importante que o <code>value</code> n√£o <code>value</code> envolvido na renderiza√ß√£o.  E assim podemos mudar o quanto quisermos.  Mas n√£o precisamos influenciar a √°rvore DOM e n√£o precisamos iniciar essas altera√ß√µes. <br><br>  Isso me levou √† ideia de que apenas o desenvolvedor pode saber o momento certo em que a renderiza√ß√£o realmente precisa ser iniciada.  Para iniciar, comecei a usar o sinalizador - apenas um valor booleano - <code>ShouldRender</code> , que sinaliza que o modelo mudou e precisamos iniciar a renderiza√ß√£o.  Ao mesmo tempo, n√£o h√° sobrecarga para compara√ß√µes constantes, n√£o h√° consumo de mem√≥ria - os aplicativos escritos em Yew s√£o mais eficazes. <br><br>  No exemplo acima, n√£o havia aloca√ß√£o de mem√≥ria, exceto a mensagem que foi gerada e enviada.  O modelo manteve seu estado, e isso foi refletido na renderiza√ß√£o apenas com a ajuda de uma bandeira. <br><br><h2>  As possibilidades </h2><br>  Escrever uma estrutura que funcione no WebAssembly n√£o √© uma tarefa f√°cil.  Temos JavaScript, mas ele deve criar algum tipo de ambiente que precisa ser interagido, e isso √© uma enorme quantidade de trabalho.  A vers√£o inicial desses pacotes tinha algo parecido com isto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ab/5aa/f25/3ab5aaf257e0a6a9f611e885dba4bd8d.png"><br><br>  Tirei uma demo de outro projeto.  Existem muitos projetos que seguem esse caminho, mas rapidamente levam a um beco sem sa√≠da.  Afinal, a estrutura √© um desenvolvimento bastante grande e voc√™ precisa escrever muito c√≥digo de encaixe.  Comecei a usar bibliotecas em Rust, chamadas caixas, em particular a <code>Stdweb</code> . <br><br><h3>  JS Integrado </h3><br>  Com a ajuda das macros do Rust, voc√™ pode expandir o idioma - podemos incorporar partes de JavaScript no c√≥digo do Rust, esse √© um recurso muito √∫til do idioma. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = js! {   var callback = @{callback};   var action = function() {       callback();   };   var delay = @{ms};   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       interval_id: setInterval(action, delay),       callback: callback,   }; };</code> </pre><br>  O uso de macros e o Stdweb me permitiu escrever com rapidez e efici√™ncia todos os links necess√°rios. <br><br><h3>  Modelos jsx </h3><br>  No come√ßo, eu segui o caminho Elm e comecei a usar modelos implementados usando c√≥digo. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {   nav(<span class="hljs-string"><span class="hljs-string">"nav"</span></span>, (<span class="hljs-string"><span class="hljs-string">"menu"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[       button(<span class="hljs-string"><span class="hljs-string">"button"</span></span>, (), (<span class="hljs-string"><span class="hljs-string">"onclick"</span></span>, || Msg::Clicked)),       tag(<span class="hljs-string"><span class="hljs-string">"section"</span></span>, (<span class="hljs-string"><span class="hljs-string">"ontop"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[           p(<span class="hljs-string"><span class="hljs-string">"My text..."</span></span>)       ])   ]) }</code> </pre><br>  Eu nunca fui um defensor do React.  Mas quando comecei a escrever minha estrutura, percebi que o JSX no React √© uma coisa muito legal.  Aqui est√° uma apresenta√ß√£o muito conveniente de modelos de c√≥digo. <br><br>  Como resultado, peguei uma macro no Rust e implementei diretamente dentro do Rust a capacidade de escrever a marca√ß√£o HTML que gera imediatamente elementos da √°rvore virtual. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Renderable&lt;Context, Model&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Model {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {       html! {           &lt;div&gt;               &lt;nav class=<span class="hljs-string"><span class="hljs-string">"menu"</span></span>,&gt;                   &lt;button onclick=|_| Msg::Increment,&gt;{ <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> }&lt;/button&gt;                   &lt;button onclick=|_| Msg::Decrement,&gt;{ <span class="hljs-string"><span class="hljs-string">"Decrement"</span></span> }&lt;/button&gt;               &lt;/nav&gt;               &lt;p&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value }&lt;/p&gt;               &lt;p&gt;{ Local::now() }&lt;/p&gt;           &lt;/div&gt;       }   } }</code> </pre><br>  Podemos dizer que modelos do tipo JSX s√£o modelos de c√≥digo puro, mas com ester√≥ides.  Eles s√£o apresentados em um formato conveniente.  Observe tamb√©m que aqui insiro uma express√£o Rust diretamente no bot√£o (a express√£o Rust pode ser inserida dentro desses modelos).  Isso permite que voc√™ integre muito de perto. <br><br><h3>  Componentes bastante estruturados </h3><br>  Ent√£o comecei a desenvolver modelos e percebi a possibilidade de usar componentes.  Este √© o primeiro problema que foi feito no reposit√≥rio.  Eu implementei componentes que podem ser usados ‚Äã‚Äãno c√≥digo do modelo.  Voc√™ simplesmente declara uma estrutura honesta no Rust e escreve algumas propriedades para ele.  E essas propriedades podem ser definidas diretamente no modelo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b9/3d0/d37/9b93d0d3797e46f73650b00689315009.png"><br><br>  Mais uma vez, noto o importante: esses modelos s√£o honestamente gerados pelo c√≥digo Rust.  Portanto, qualquer erro aqui ser√° percebido pelo compilador.  I.e.  voc√™ n√£o pode estar enganado, como costuma acontecer no desenvolvimento do JavaScript. <br><br><h3>  √Åreas digitadas </h3><br>  Outro recurso interessante √© que, quando um componente √© colocado dentro de outro componente, ele pode ver o tipo de mensagem do pai. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/933/831/4cb/9338314cb1560b2172c6ab11bbff7977.png"><br><br>  O compilador vincula rigidamente esses tipos e n√£o oferece a oportunidade de cometer um erro.  Ao processar eventos, as mensagens que o componente espera ou pode enviar devem corresponder totalmente ao pai. <br><br><h3>  Outros recursos </h3><br>  Transferi uma implementa√ß√£o do Rust diretamente para a estrutura que permite usar convenientemente v√°rios formatos de serializa√ß√£o / desserializa√ß√£o (fornecendo wrappers adicionais).  Abaixo est√° um exemplo: vamos ao armazenamento local e, restaurando os dados, especificamos um determinado inv√≥lucro - o que esperamos aqui √© json. <br><br><pre> <code class="rust hljs">Msg::Store =&gt; {   context.local_storage.store(KEY, Json(&amp;model.clients)); } Msg::Restore =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Json(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(clients)) = context.local_storage.restore(KEY) {        model.clients = clients;   } }</code> </pre><br>  Pode ser qualquer formato, incluindo bin√°rio.  Por conseguinte, a serializa√ß√£o e a desserializa√ß√£o tornam-se transparentes e convenientes. <br><br>  A ideia de outra oportunidade que implementei veio dos usu√°rios da estrutura.  Eles pediram para fazer fragmentos.  E aqui me deparei com uma coisa interessante.  Vendo em JavaScript a capacidade de inserir fragmentos na √°rvore DOM, primeiro decidi que seria muito f√°cil implementar essa fun√ß√£o em minha estrutura.  Mas eu tentei essa op√ß√£o, e acabou que n√£o funciona.  Eu tive que descobrir, andar nesta √°rvore, ver o que havia mudado ali, etc. <br><br>  A estrutura do Yew usa uma √°rvore DOM virtual, tudo existe inicialmente nela.  De fato, quando h√° algumas altera√ß√µes no modelo, elas se transformam em patches que j√° alteram a √°rvore DOM renderizada. <br><br><pre> <code class="hljs xml">html! {   <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/&gt;</span></span> }</code> </pre><br><h2>  Benef√≠cios adicionais </h2><br>  Ferrugem fornece muitos recursos poderosos mais diferentes, vou falar apenas sobre o mais importante. <br><br><h3>  Servi√ßos: intera√ß√£o com o mundo exterior </h3><br>  A primeira oportunidade sobre a qual quero falar √© sobre servi√ßos.  Voc√™ pode descrever a funcionalidade necess√°ria na forma de algum servi√ßo, public√°-la como uma caixa e reutiliz√°-la. <br><br>  No Rust, a capacidade de criar bibliotecas, sua integra√ß√£o, encaixe e colagem √© muito bem implementada.  De fato, voc√™ pode criar v√°rias APIs para interagir com seu servi√ßo, incluindo JavaScript.  Ao mesmo tempo, a estrutura pode interagir com o mundo externo, apesar de funcionar dentro do tempo de execu√ß√£o do WebAssembly. <br><br>  Exemplos de servi√ßos: <br><br><ul><li>  TimeOutService; <br></li><li>  IntervalService; <br></li><li>  FetchService; <br></li><li>  WebSocketService; <br></li><li>  Servi√ßos personalizados ... <br></li></ul><br>  Servi√ßos e caixas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferrugem</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crates.io</a> . <br><br><h3>  Contexto: requisitos de estado </h3><br>  Outra coisa que eu implementei no framework n√£o √© totalmente tradicional, √© o contexto.  O React possui uma API de contexto, mas eu usei o Contexto em um sentido diferente.  A estrutura Yew consiste nos componentes que voc√™ cria e o Contexto √© um estado global.  Os componentes podem n√£o levar em considera√ß√£o esse estado global, mas podem fazer algumas exig√™ncias - para que a entidade global atenda a alguns crit√©rios. <br><br>  Digamos que nosso componente abstrato exija a capacidade de fazer upload de algo para o S3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f6/477/776/3f6477776d227c4b7abcf64be2f17f5c.png"><br><br>  Pode ser visto abaixo que ele usa esse upload, ou seja,  envia dados para o S3.  Esse componente pode ser disposto na forma de um rack.  O usu√°rio que baixa esse componente e o adiciona dentro do modelo ao seu aplicativo encontrar√° um erro - o compilador perguntar√° a ele onde est√° o suporte do S3.  O usu√°rio ter√° que implementar esse suporte.  Depois disso, o componente come√ßa automaticamente a viver uma vida plena. <br><br>  Onde √© necess√°rio?  Imagine: voc√™ est√° criando um componente com criptografia inteligente.  Ele tem requisitos para que o contexto ao redor permita que ele entre em algum lugar.  Tudo o que voc√™ precisa fazer √© adicionar um formul√°rio de autoriza√ß√£o ao modelo e, no seu contexto, implementar a conex√£o com o seu servi√ßo.  I.e.  ser√£o literalmente tr√™s linhas de c√≥digo.  Depois disso, o componente come√ßa a funcionar. <br><br>  Imagine que temos dezenas de componentes diferentes.  E todos eles t√™m o mesmo requisito.  Isso permite implementar algum tipo de funcionalidade uma vez para reviver todos os componentes e acessar os dados necess√°rios.  Fora de contexto.  E o compilador n√£o permitir√° que voc√™ cometa um erro: se voc√™ n√£o tiver uma interface que exija um componente, nada funcionar√°. <br><br>  Portanto, voc√™ pode criar facilmente bot√µes muito exigentes que solicitar√£o alguma API ou outros recursos.  Gra√ßas ao Rust e ao sistema dessas interfaces (eles s√£o chamados de caracter√≠stica no Rust), torna-se poss√≠vel declarar os requisitos dos componentes. <br><br><h3>  O compilador n√£o permitir√° que voc√™ cometa um erro </h3><br>  Imagine que estamos criando um componente com algumas propriedades, uma das quais √© a capacidade de definir retorno de chamada.  E, por exemplo, definimos a propriedade e perdemos uma letra em seu nome. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/829/d84/93d/829d8493d52ccff0299dc030661c5b37.png"><br><br>  Tentando compilar, Rust responde rapidamente.  Ele diz que est√°vamos enganados e n√£o existe essa propriedade: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02d/08d/ef7/02d08def74b01670bc6b4b0695f5cc2f.png"><br><br>  Como voc√™ pode ver, o Rust usa diretamente esse modelo e pode renderizar todos os erros dentro da macro.  Ele diz como a propriedade deve realmente ser chamada.  Se voc√™ passou no compilador, n√£o ter√° erros de execu√ß√£o parvos, como erros de digita√ß√£o. <br><br>  Agora imagine, temos um bot√£o que solicita que nosso contexto global seja capaz de se conectar ao S3.  E crie um contexto que n√£o implemente o suporte S3.  Vamos ver o que acontece. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a50/8d6/c7e/a508d6c7e4470c16f7890f36f0bd4135.png"><br><br>  O compilador relata que inserimos um bot√£o, mas essa interface n√£o est√° implementada para o contexto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/63b/4f9/790/63b4f97902e2460ced9cbbdd0f820f23.png"><br><br>  Resta apenas entrar no editor, adicionar um link para a Amazon no contexto e tudo come√ßar√°.  Voc√™ pode criar servi√ßos prontos com algum tipo de API e simplesmente adicionar ao contexto, substituir um link para ele e o componente ganha vida imediatamente.  Isso permite que voc√™ fa√ßa coisas muito legais: adicione componentes, crie um contexto, encha-o de servi√ßos.  E tudo isso funciona de forma totalmente autom√°tica; s√£o necess√°rios esfor√ßos m√≠nimos para unir tudo. <br><br><h2>  Como come√ßar a usar o Yew? </h2><br>  Por onde come√ßar, se voc√™ quiser tentar compilar um aplicativo WebAssembly?  E como isso pode ser feito usando a estrutura Yew? <br><br><h3>  Compila√ß√£o de ferrugem para wasm </h3><br>  Primeiro, voc√™ precisa instalar o compilador.  Existe uma ferramenta de ferrugem para isso: <br><br> <code>curl https://sh.rustup.rs -sSf | sh <br></code> <br>  Al√©m disso, voc√™ pode precisar do emscripten.  Para que pode ser √∫til?  A maioria das bibliotecas criadas para linguagens de programa√ß√£o do sistema, especialmente para o Rust (originalmente um sistema), s√£o desenvolvidas para Linux, Windows e outros sistemas operacionais completos.  Obviamente, o navegador n√£o possui muitos recursos. <br><br>  Por exemplo, a gera√ß√£o aleat√≥ria de n√∫meros em um navegador n√£o √© feita da mesma maneira que no Linux.  O emscripten √© √∫til se voc√™ deseja usar bibliotecas que requerem uma API do sistema. <br><br>  As bibliotecas e toda a infraestrutura est√£o mudando silenciosamente para WebAssembly honesto, e o emscripten n√£o √© mais necess√°rio (voc√™ usa recursos baseados em JavaScript para gerar n√∫meros aleat√≥rios e outras coisas), mas se precisar criar algo que n√£o √© suportado no navegador, n√£o √© poss√≠vel sem o emscripten . <br><br>  Eu tamb√©m recomendo usar a web de carga: <br><br> <code>cargo install cargo-web <br></code> <br>  √â poss√≠vel compilar o WebAssembly sem utilit√°rios adicionais.  Mas o cargo-web √© uma ferramenta interessante que fornece v√°rias coisas √∫teis para desenvolvedores de JavaScript.  Em particular, ele monitorar√° os arquivos: se voc√™ fizer altera√ß√µes, ele come√ßar√° a compilar imediatamente (o compilador n√£o fornece essas fun√ß√µes).  Nesse caso, o Cargo-web permitir√° acelerar o desenvolvimento.  Existem diferentes sistemas de constru√ß√£o para o Rust, mas a carga representa 99,9% de todos os projetos. <br><br>  Um novo projeto √© criado da seguinte maneira: <br><br> <code>cargo new --bin my-project <br></code> <br> <code>[package] <br> name = "my-project" <br> version = "0.1.0" <br> <br> [dependencies] <br> yew = "0.3.0" <br></code> <br>  Em seguida, basta iniciar o projeto: <br><br> <code>cargo web start --target wasm32-unknown-unknown <br></code> <br>  Dei um exemplo de WebAssembly honesto.  Se voc√™ precisar compilar em emscripten (o compilador rust pode conectar o pr√≥prio emscripten), poder√° inserir a palavra <code>emscripten</code> no √∫ltimo elemento <code>unknown</code> , o que permite usar mais caixas.  N√£o esque√ßa que o emscripten √© um kit adicional bastante grande para o seu arquivo.  Portanto, √© melhor escrever um c√≥digo WebAssembly honesto. <br><br><h3>  Restri√ß√µes existentes </h3><br>  Qualquer pessoa com experi√™ncia em codifica√ß√£o em linguagens de programa√ß√£o do sistema pode ficar frustrada com as limita√ß√µes existentes na estrutura.  Nem todas as bibliotecas podem ser usadas no WebAssembly.  Por exemplo, em um ambiente JavaScript, n√£o h√° threads.  O WebAssembly, em princ√≠pio, n√£o declara isso e, √© claro, voc√™ pode us√°-lo em um ambiente com v√°rios threads (essa √© uma pergunta em aberto), mas o JavaScript ainda √© um ambiente de thread √∫nico.  Sim, existem trabalhadores, mas isso √© isolamento, ent√£o n√£o haver√° fluxos por l√°. <br><br>  Parece que voc√™ pode viver sem fluxos.  Mas se voc√™ deseja usar bibliotecas baseadas em encadeamento, por exemplo, deseja adicionar algum tipo de tempo de execu√ß√£o, isso pode n√£o decolar. <br><br>  Al√©m disso, n√£o h√° API do sistema, exceto a que voc√™ transferir√° do JavaScript para o WebAssembly.  Portanto, muitas bibliotecas n√£o ser√£o portadas.  Voc√™ n√£o pode gravar e ler arquivos diretamente, os soquetes n√£o podem ser abertos e n√£o √© poss√≠vel gravar na rede.  Se voc√™ deseja criar um soquete da Web, por exemplo, √© necess√°rio arrast√°-lo do JavaScript. <br><br>  Outra desvantagem √© que o depurador WASM existe, mas ningu√©m o viu.  Ainda est√° em um estado t√£o bruto que √© improv√°vel que seja √∫til para voc√™.  Portanto, depurar o WebAssembly √© uma quest√£o complicada. <br><br>  Ao usar o Rust, quase todos os problemas de tempo de execu√ß√£o ser√£o associados a erros na l√≥gica de neg√≥cios, eles ser√£o f√°ceis de corrigir.  Mas raramente ocorrem erros de baixo n√≠vel - por exemplo, uma das bibliotecas faz o encaixe errado - e essa j√° √© uma pergunta dif√≠cil.  Por exemplo, no momento, existe um problema: se eu compilar a estrutura com o emscripten e houver uma c√©lula de mem√≥ria vari√°vel, cuja posse √© retirada, √© dada, o emscripten est√° desmoronando em algum lugar no meio (e nem tenho certeza se √© emscripten).  Se voc√™ se deparar com um problema em algum lugar do middleware em um n√≠vel baixo, ser√° dif√≠cil corrigi-lo no momento. <br><br><h2>  O futuro da estrutura </h2><br>  Como o Yew se desenvolver√° mais?  Eu vejo seu principal objetivo na cria√ß√£o de componentes monol√≠ticos.  Voc√™ ter√° um arquivo WebAssembly compilado e simplesmente o colar√° no aplicativo.  Por exemplo, ele pode fornecer recursos criptogr√°ficos, renderiza√ß√£o ou edi√ß√£o. <br><br><h3>  Integra√ß√£o JS </h3><br>  A integra√ß√£o com JavaScript ser√° refor√ßada.  O JavaScript criou um grande n√∫mero de bibliotecas legais que s√£o f√°ceis de usar.  E h√° exemplos no reposit√≥rio onde mostro como voc√™ pode usar a biblioteca JavaScript existente diretamente da estrutura Yew. <br><br><h3>  CSS digitado </h3><br>  Como o Rust √© usado, √© √≥bvio que voc√™ pode adicionar CSS digitado que pode ser gerado com a mesma macro que no exemplo de um mecanismo de modelo semelhante a JSX.  Nesse caso, o compilador verificar√°, por exemplo, se voc√™ atribuiu algum outro atributo em vez de cor.  Isso economizar√° muito tempo. <br><br><h3>  Componentes prontos </h3><br>  Tamb√©m busco criar componentes prontos para uso.  Na estrutura, voc√™ pode criar rachaduras que fornecer√£o, por exemplo, um conjunto de alguns bot√µes ou elementos que ser√£o conectados como uma biblioteca, adicionados aos modelos e usados. <br><br><h3>  Melhoria de desempenho em casos particulares </h3><br>  O desempenho √© uma quest√£o muito delicada e complexa.  O WebAssembly √© mais r√°pido que o JavaScript?  N√£o tenho provas que confirmem uma resposta positiva ou negativa.  Parece que, e de acordo com alguns testes muito simples que eu conduzi, o WebAssembly √© muito r√°pido.  E tenho total confian√ßa de que seu desempenho ser√° maior que o do JavaScript, apenas porque √© um c√≥digo de byte de baixo n√≠vel em que a aloca√ß√£o de mem√≥ria n√£o √© necess√°ria e h√° muitos outros momentos que exigem recursos. <br><br><h3>  Mais colaboradores </h3><br>  Eu gostaria de atrair mais colaboradores.  As portas para participar da estrutura est√£o sempre abertas.  Qualquer pessoa que queira modernizar algo, entender o kernel e transformar as ferramentas com as quais trabalha um grande n√∫mero de desenvolvedores, pode se conectar e oferecer suas pr√≥prias edi√ß√µes com facilidade. <br><br>  O projeto j√° teve a participa√ß√£o de muitos colaboradores.  Mas n√£o h√° colaboradores principais no momento, pois para isso voc√™ precisa entender o vetor de desenvolvimento da estrutura, mas ainda n√£o foi claramente formulado.  Mas h√° uma espinha dorsal, caras que s√£o muito versados ‚Äã‚Äãem Yew - cerca de 30 pessoas.  Se voc√™ tamb√©m quiser adicionar algo √† estrutura, sempre envie uma solicita√ß√£o de recebimento. <br><br><h3>  A documenta√ß√£o </h3><br>  Um ponto obrigat√≥rio em meus planos √© a cria√ß√£o de uma grande quantidade de documenta√ß√£o sobre como escrever aplicativos no Yew.  Obviamente, a abordagem de desenvolvimento nesse caso √© diferente da que vimos em React e Elm. <br><br>  √Äs vezes, os caras me mostram casos interessantes de como usar o framework.  Ainda assim, criar uma estrutura n√£o √© o mesmo que escrever profissionalmente nela.  Pr√°ticas para usar a estrutura ainda est√£o sendo formadas. <br><br>  Experimente, instale o Rust, expanda seus recursos como desenvolvedor.  O dom√≠nio do WebAssembly ser√° √∫til para cada um de n√≥s, porque a cria√ß√£o de aplicativos muito complexos √© o momento que estamos esperando h√° muito tempo.  Em outras palavras, o WebAssembly n√£o √© apenas um navegador da Web, mas geralmente √© um tempo de execu√ß√£o que est√° definitivamente se desenvolvendo e se desenvolver√° ainda mais ativamente. <br><br><blockquote>  Se voc√™ gostou do relat√≥rio, preste aten√ß√£o: de 24 a 25 de novembro, um novo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HolyJS</a> ser√° realizado em Moscou e tamb√©m haver√° muitas coisas interessantes por l√°.      ‚Äî  ,       ( <b>  </b>  ). </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt422253/">https://habr.com/ru/post/pt422253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt422239/index.html">Como iniciar a entrega para milh√µes de usu√°rios</a></li>
<li><a href="../pt422241/index.html">KPI - Tr√™s Cartas de Trope√ßo</a></li>
<li><a href="../pt422243/index.html">CRM para pequenas empresas. Voc√™ precisa disso?</a></li>
<li><a href="../pt422247/index.html">OK Copa dos Jogos Instant√¢neos. Competi√ß√£o para desenvolvedores de jogos HTML5</a></li>
<li><a href="../pt422251/index.html">"Um alto n√≠vel de autodisciplina." Jeffrey Richter sobre como codificar, escrever livros e criar suas pr√≥prias empresas</a></li>
<li><a href="../pt422255/index.html">Cria√ß√£o de Personagem no Blender e Unity</a></li>
<li><a href="../pt422257/index.html">Revis√£o do leitor PocketBook 627: classe m√©dia com luz de fundo, Wi-Fi e servi√ßo de nuvem</a></li>
<li><a href="../pt422259/index.html">Estruturas de dados b√°sicas. Material. O b√°sico</a></li>
<li><a href="../pt422261/index.html">Zextras Powerstore e sistemas de classifica√ß√£o por n√≠veis</a></li>
<li><a href="../pt422263/index.html">‚ÄúDormammu, cheguei a um acordo‚Äù: um algoritmo para coopera√ß√£o mutuamente ben√©fica com uma pessoa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>