<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèø üîû üë¶üèΩ Kami menulis bahasa pemrograman kami, bagian 1: kami menulis bahasa VM üé≠ üéÖ ‚òùüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Hari baik untuk semua habrachitateli! 

 Jadi, mungkin layak untuk dikatakan bahwa tujuan dari pekerjaan saya, yang menjadi dasar penuli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis bahasa pemrograman kami, bagian 1: kami menulis bahasa VM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435202/"><h3>  Pendahuluan </h3><br>  Hari baik untuk semua habrachitateli! <br><br>  Jadi, mungkin layak untuk dikatakan bahwa tujuan dari pekerjaan saya, yang menjadi dasar penulisan sejumlah patung, adalah untuk membuat YP sepenuhnya berfungsi mulai dari 0 dan kemudian membagikan pengetahuan, praktik terbaik, dan pengalaman saya kepada mereka yang tertarik. <br><br>  Saya akan menjelaskan penciptaan bahasa yang saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jelaskan sebelumnya di sini</a> . <br><br>  Dia tertarik banyak orang dan memicu diskusi panas di komentar.  Oleh karena itu - topik ini menarik bagi banyak orang. <br><br>  Saya pikir ada baiknya segera memposting informasi tentang proyek: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs</a> (akan diisi dengan dokumentasi sedikit kemudian). <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori</a> <br><br>  Untuk menyentuh proyek sendiri dan melihat segala sesuatu dalam tindakan, lebih baik untuk mengunduh repositori dan menjalankan semuanya dari folder bin.  Dalam rilisnya, saya tidak terburu-buru untuk mengunggah versi terbaru bahasa dan runtime, karena  terkadang terlalu malas bagi saya untuk melakukannya. <br><br>  Saya dapat kode dalam C / C ++ dan Object Pascal.  Saya menulis proyek di FPC sejak itu  menurut saya bahasa ini jauh lebih sederhana dan lebih cocok untuk menulis seperti itu.  Faktor penentu kedua adalah bahwa FPC mendukung sejumlah besar platform target, dan Anda dapat membangun kembali proyek untuk platform yang diinginkan dengan minimum perubahan.  Jika karena alasan tertentu saya tidak suka Obyek Pascal, maka jangan terburu-buru untuk menutup pos dan lari untuk melempar batu pada komentar.  Bahasa ini sangat indah dan intuitif, tetapi saya tidak akan memberikan banyak kode.  Apa yang Anda butuhkan. <br><br>  Jadi, mungkin aku akan memulai ceritaku. <br><a name="habracut"></a><br><h3>  Kami menetapkan tujuan </h3><br>  Pertama-tama, setiap proyek membutuhkan tujuan dan TK-nya, yang harus diimplementasikan di masa depan.  Penting untuk memutuskan terlebih dahulu jenis bahasa apa yang akan dibuat untuk menulis VM utama untuknya. <br><br>  Poin-poin penting yang menentukan pengembangan lebih lanjut dari VM saya adalah sebagai berikut: <br><br><ul><li>  Pengetikan dinamis dan tipe casting.  Saya memutuskan untuk mengatur dukungannya pada tahap pengembangan VM. </li><li>  Dukungan multithreading.  Saya memasukkan item ini dalam daftar ini sebelumnya untuk mendesain arsitektur VM dengan benar dan mengatur dukungan untuk multithreading pada level inti VM, dan tidak lebih baru dengan kruk. </li><li>  Ekspor metode eksternal.  Tanpa ini, bahasa tidak akan berguna.  Kecuali untuk menanamkannya dalam proyek apa pun. </li><li>  Kompilasi bahasa (menjadi satu file abstrak yang dapat dieksekusi).  Dikompilasi atau ditafsirkan sebagian?  Sangat tergantung pada ini. </li><li>  Arsitektur VM umum.  Apakah tumpukan atau daftar menjadi VM kami?  Saya mencoba menerapkan ini dan itu.  Saya memilih VM yang ditumpuk untuk dukungan. </li><li>  Bagaimana Anda melihat bekerja dengan variabel, array, struktur?  Secara pribadi, pada saat itu saya ingin mengimplementasikan bahasa di mana hampir semuanya terkait dengan pointer implisit, karena pendekatan seperti itu akan sangat menghemat memori dan menyederhanakan kehidupan pengembang.  Jika kita membiarkan sesuatu yang besar diteruskan ke metode, maka hanya sebuah pointer ke yang besar yang akan ditransfer secara otomatis. </li></ul><br>  Jadi, saya telah memilih prioritas di atas dan saya mulai menerapkan mesin virtual bahasa.  Ini aneh tentu saja, biasanya parser / penerjemah ditulis terlebih dahulu, dan kemudian VM.  Yah, saya mulai mengembangkan proyek dalam urutan ini dan saya akan menjelaskannya lebih lanjut dalam urutan di mana saya mengembangkannya. <br><br>  Saya harus segera mengatakan bahwa saya memanggil VM dengan fasih mungkin - SVM (Stack-based Virtual Machine). <br><br><h3>  Mari kita mulai dengan implementasi kelas variabel </h3><br>  Awalnya, saya hanya menggunakan tipe varian, karena lebih sederhana dan lebih cepat.  Itu adalah penopang, tetapi menopang proyek dan memungkinkan saya untuk dengan cepat mengimplementasikan versi pertama VM dan bahasa.  Kemudian saya duduk di kode dan menulis implementasi "varian" saya.  Intinya, Anda perlu menulis kelas yang menyimpan pointer ke nilai dalam memori, dalam implementasi saya ini adalah <code>null/cardinal/int64/double/string/array</code> .  Orang bisa menggunakan pengetikan kasus, tetapi saya pikir akan lebih baik untuk menerapkan cara saya menerapkan. <br><br>  Sebelum mulai menulis kode kelas, saya memutuskan untuk segera meletakkan direktif {$ H +} di header modul untuk dukungan yang lebih fleksibel untuk string dalam bahasa yang akan datang. <br><blockquote>  P.S.  bagi mereka yang mungkin tidak menyadari perbedaan antara mode H- dan H + FPC. <br><br>  Saat menyusun kode dalam mode-H, string akan disajikan sebagai array karakter.  Ketika H + - sebagai penunjuk ke sepotong memori.  Dalam kasus pertama, panjang garis awalnya akan tetap dan dibatasi secara default hingga 256 karakter.  Dalam kasus kedua, garis akan diperluas secara dinamis dan lebih banyak karakter dapat dijejalkan ke dalamnya.  Mereka akan bekerja sedikit lebih lambat, tetapi lebih fungsional.  Dengan H +, Anda juga dapat mendeklarasikan string sebagai array karakter, misalnya dengan cara ini: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>];</code> </pre></blockquote>  Jadi, sebagai permulaan, kami akan mendeklarasikan tipe Enum, yang akan kami gunakan sebagai flag tertentu untuk menentukan tipe data dengan pointer: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVMType = (svmtNull, svmtWord, svmtInt, svmtReal, svmtStr, svmtArr);</code> </pre><br>  Selanjutnya, kami menggambarkan struktur dasar dari tipe variabel kami dan beberapa metode: <br><br><pre> <code class="delphi hljs"> TSVMMem = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> m_val: pointer; m_type: TSVMType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> m_val := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; m_type := svmtNull; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Clear; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtNull: <span class="hljs-comment"><span class="hljs-comment">{ nop }</span></span>; svmtWord: Dispose(PCardinal(m_val)); svmtInt: Dispose(PInt64(m_val)); svmtReal: Dispose(PDouble(m_val)); svmtStr: Dispose(PString(m_val)); svmtArr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(PMemArray(m_val)^, <span class="hljs-number"><span class="hljs-number">0</span></span>); Dispose(PMemArray(m_val)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Kelas tidak mewarisi dari apa pun, sehingga panggilan yang diwariskan di konstruktor dan destruktor dapat dihilangkan.  Saya akan memperhatikan arahan inline.  Lebih baik menambahkan {$ inline on} ke header file, pasti.  Penggunaan aktifnya di VMs secara signifikan meningkatkan produktivitas (Mb di suatu tempat sebanyak 15-20%!).  Dia mengatakan kepada kompiler bahwa tubuh metode paling baik ditanamkan di tempat permohonannya.  Kode output akan sedikit lebih besar pada akhirnya, tetapi akan bekerja lebih cepat.  Dalam hal ini, disarankan menggunakan inline. <br><br>  Ok, pada tahap ini kita telah menghancurkan fondasi kelas kita.  Sekarang kita perlu menjelaskan sejumlah setter dan getter (setter &amp; getter) di kelas kita. <br><br>  Tugasnya adalah menulis beberapa metode yang akan memungkinkan Anda menjejalkan dan kemudian mendapatkan kembali nilai-nilai dari kelas kami. <br><br>  Pertama, mari kita cari tahu penugasan nilai untuk kelas kita.  Pertama, Anda dapat menulis setter umum, dan kemudian, untuk tipe data individual: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value; t:TSVMType)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = t) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: PCardinal(m_val)^ := Cardinal(value); svmtInt: PInt64(m_val)^ := Int64(value); svmtReal: PDouble(m_val)^ := Double(value); svmtStr: PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := t; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PCardinal(m_val)); PCardinal(m_val)^ := Cardinal(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PInt64(m_val)); PInt64(m_val)^ := Int64(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PDouble(m_val)); PDouble(m_val)^ := Double(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> New(PString(m_val)); PString(m_val)^ := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:cardinal)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (m_type = svmtWord) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PCardinal(m_val)^ := value <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m_val &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeMem(m_val); m_type := svmtWord; New(PCardinal(m_val)); PCardinal(m_val)^ := value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Sekarang Anda dapat menulis kode untuk beberapa pengambil: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetW</span></span></span><span class="hljs-function">:</span></span>cardinal; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: Result := PCardinal(m_val)^; svmtInt: Result := PInt64(m_val)^; svmtReal: Result := Trunc(PDouble(m_val)^); svmtStr: Result := StrToQWord(PString(m_val)^); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarTypeCast); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Oke, bagus, sekarang setelah Anda menghabiskan waktu menatap IDE dan dengan antusias mengetik kode untuk setter dan getter, kami dihadapkan pada tugas untuk mengimplementasikan dukungan untuk jenis operasi matematika dan logis kami.  Sebagai contoh, saya akan memberikan implementasi operasi tambahan: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m:TSVMMem)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetW(GetW + m.GetW); svmtInt: SetI(GetW + m.GetI); svmtReal: SetD(GetW + m.GetD); svmtStr: SetD(GetW + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtInt: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetI(GetI + m.GetW); svmtInt: SetI(GetI + m.GetI); svmtReal: SetD(GetI + m.GetD); svmtStr: SetD(GetI + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtReal: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetD(GetD + m.GetW); svmtInt: SetD(GetD + m.GetI); svmtReal: SetD(GetD + m.GetD); svmtStr: SetD(GetD + StrToFloat(m.GetS)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m.m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtWord: SetS(GetS + IntToStr(m.GetW)); svmtInt: SetS(GetS + IntToStr(m.GetI)); svmtReal: SetS(GetS + FloatToStr(m.GetD)); svmtStr: SetS(GetS + m.GetS); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reVarInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Semuanya sederhana.  Operasi lebih lanjut dapat dijelaskan dengan cara yang sama, dan sekarang kelas kami siap. <br>  Untuk array, tentu saja, Anda masih memerlukan beberapa metode, contoh untuk mendapatkan elemen berdasarkan indeks: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSVMMem</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: cardinal; grabber:PGrabber)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> m_type <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> svmtArr: Result := PMemArray(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; svmtStr: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TSVMMem.CreateFW(Ord(PString(m_val)^[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>])); grabber^.AddTask(Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Error(reInvalidOp); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Bagus  Sekarang kita bisa melanjutkan. <br><br><h3>  Kami menyadari setumpuk </h3><br>  Setelah beberapa saat, saya berpikir seperti itu.  Tumpukan harus statis (untuk kecepatan) dan dinamis (untuk fleksibilitas) secara bersamaan. <br><br>  Oleh karena itu, tumpukan diimplementasikan dalam blok.  Yaitu  bagaimana seharusnya bekerja - awalnya susunan tumpukan memiliki ukuran tertentu (saya memutuskan untuk mengatur ukuran blok ke 256 elemen sehingga itu indah dan tidak kecil).  Dengan demikian, penghitung disertakan dengan array, yang menunjukkan bagian atas tumpukan saat ini.  Realokasi memori adalah operasi ekstra panjang, yang dapat dilakukan lebih jarang.  Jika lebih banyak nilai didorong ke tumpukan, maka ukurannya selalu dapat diperluas ke ukuran blok lain. <br><br>  Saya membawa seluruh implementasi stack: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TStack = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> items: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pointer; size, i_pos: cardinal; parent_vm: pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PStack = ^TStack; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; size := StackBlockSize; parent_vm := vm; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> items[i_pos] := p; inc(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i_pos &gt;= size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size + StackBlockSize; SetLength(items, size) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popv</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dec(i_pos); Result := items[i_pos]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size - i_pos &gt; StackBlockSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> size := size - StackBlockSize; SetLength(items, size); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swp</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">2</span></span>] := items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>]; items[i_pos - <span class="hljs-number"><span class="hljs-number">1</span></span>] := p; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TStack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(items, StackBlockSize); size := StackBlockSize; i_pos := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Dalam metode eksternal, VM akan melewatkan sebuah pointer ke stack sehingga mereka dapat mengambil argumen yang diperlukan dari sana.  Pointer ke aliran VM ditambahkan kemudian, sehingga panggilan panggilan balik dari metode eksternal dapat diimplementasikan dan, secara umum, untuk mentransfer lebih banyak kekuatan atas metode VM. <br><br>  Jadi, bagaimana Anda berkenalan dengan bagaimana tumpukan disusun.  Tumpukan panggilan balik diatur dengan cara yang sama, untuk kesederhanaan dan kenyamanan operasi panggilan &amp; pengembalian dan tumpukan pengumpul sampah.  Satu-satunya hal adalah ukuran lain dari balok. <br><br><h3>  Bicara tentang sampah </h3><br>  Biasanya banyak, banyak.  Dan Anda perlu melakukan sesuatu dengannya. <br><br>  Pertama-tama, saya ingin berbicara tentang bagaimana pengumpul sampah diatur dalam bahasa lain, misalnya, dalam Lua, Ruby, Java, Perl, PHP, dll.  Mereka bekerja pada prinsip penghitungan pointer ke objek dalam memori. <br><br>  Yaitu  jadi kami mengalokasikan memori untuk sesuatu, itu logis - penunjuk langsung ditempatkan di variabel / array / di tempat lain.  Kolektor sampah runtime segera menambahkan pointer ini ke dirinya sendiri dengan daftar objek sampah yang mungkin.  Di latar belakang, pemulung terus-menerus memonitor semua variabel, array, dll.  Jika tidak ada pointer ke sesuatu dari daftar kemungkinan sampah, maka itu berarti sampah dan memori dari bawahnya harus dihilangkan. <br><br>  Saya memutuskan untuk menjual sepeda saya.  Saya lebih terbiasa bekerja dengan ingatan pada prinsip Taras Bulba.  Saya melahirkan Anda - saya akan membunuh Anda, maksud saya, ketika saya memanggil Gratis berikutnya di kelas berikutnya.  Oleh karena itu, pengumpul sampah VM saya semi-otomatis.  Yaitu  perlu dipanggil dalam mode manual dan bekerja dengannya sesuai itu.  Pada gilirannya, pointer ke objek sementara dinyatakan ditambahkan (peran ini terutama terletak pada penerjemah dan sedikit dengan pengembang).  Untuk membebaskan memori dari benda-benda lain, Anda dapat menggunakan opcode terpisah. <br><br>  Yaitu  pemulung pada saat panggilan memiliki daftar petunjuk yang sudah jadi yang perlu Anda datangi dan membebaskan memori. <br><br><h3>  Jadi, sekarang kita akan berurusan dengan kompilasi menjadi file executable abstrak </h3><br>  Idenya awalnya bahwa aplikasi yang ditulis dalam bahasa saya dapat berjalan tanpa sumber, seperti halnya dengan banyak bahasa serupa.  Yaitu  dapat digunakan untuk tujuan komersial. <br><br>  Untuk melakukan ini, Anda perlu menentukan format file yang dapat dieksekusi.  Saya mendapat yang berikut: <br><br><ol><li>  Header, misalnya "SVMEXE_CNS". </li><li>  Bagian yang berisi daftar pustaka dari mana metode akan diimpor. </li><li>  Bagian impor dari metode yang diperlukan, perpustakaan tempat metode diimpor ditunjukkan oleh nomor mereka di bagian di atas. </li><li>  Bagian dari konstanta. </li><li>  Bagian Kode </li></ol><br>  Saya pikir tidak ada gunanya memberikan langkah-langkah terperinci untuk mengimplementasikan parser untuk bagian ini, karena Anda dapat melihat semuanya sendiri di repositori saya. <br><br><h3>  Eksekusi kode </h3><br>  Setelah menguraikan bagian di atas dan menginisialisasi VM, kami memiliki satu bagian dengan kode.  Dalam VM saya, bytecode yang tidak selaras dieksekusi, mis.  instruksi bisa panjang sewenang-wenang. <br><br>  Serangkaian opcode - instruksi untuk mesin virtual dengan komentar kecil yang saya tunjukkan sebelumnya di bawah ini: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TComand = ( <span class="hljs-comment"><span class="hljs-comment">{** for stack **}</span></span> bcPH, <span class="hljs-comment"><span class="hljs-comment">// [top] = [var] bcPK, // [var] = [top] bcPP, // pop bcSDP, // stkdrop bcSWP, // [top] &lt;-&gt; [top-1] {** jump's **} bcJP, // jump [top] bcJZ, // [top] == 0 ? jp [top-1] bcJN, // [top] &lt;&gt; 0 ? jp [top-1] bcJC, // jp [top] &amp; push callback point as ip+1 bcJR, // jp to last callback point &amp; rem last callback point {** for untyped's **} bcEQ, // [top] == [top-1] ? [top] = 1 : [top] = 0 bcBG, // [top] &gt; [top-1] ? [top] = 1 : [top] = 0 bcBE, // [top] &gt;= [top-1] ? [top] = 1 : [top] = 0 bcNOT, // [top] = ![top] bcAND, // [top] = [top] and [top-1] bcOR, // [top] = [top] or [top-1] bcXOR, // [top] = [top] xor [top-1] bcSHR, // [top] = [top] shr [top-1] bcSHL, // [top] = [top] shl [top-1] bcNEG, // [top] = -[top] bcINC, // [top]++ bcDEC, // [top]-- bcADD, // [top] = [top] + [top-1] bcSUB, // [top] = [top] - [top-1] bcMUL, // [top] = [top] * [top-1] bcDIV, // [top] = [top] / [top-1] bcMOD, // [top] = [top] % [top-1] bcIDIV, // [top] = [top] \ [top-1] bcMV, // [top]^ = [top-1]^ bcMVBP, // [top]^^ = [top-1]^ bcGVBP, // [top]^ = [top-1]^^ bcMVP, // [top]^ = [top-1] {** memory operation's **} bcMS, // memory map size = [top] bcNW, // [top] = @new bcMC, // copy [top] bcMD, // double [top] bcRM, // rem @[top] bcNA, // [top] = @new array[ [top] ] of pointer bcTF, // [top] = typeof( [top] ) bcSF, // [top] = sizeof( [top] ) {** array's **} bcAL, // length( [top] as array ) bcSL, // setlength( [top] as array, {stack} ) bcPA, // push ([top] as array)[top-1] bcSA, // peek [top-2] -&gt; ([top] as array)[top-1] {** memory grabber **} bcGPM, // add pointer to TMem to grabber task-list bcGC, // run grabber {** constant's **} bcPHC, // push copy of const bcPHCP, // push pointer to original const {** external call's **} bcPHEXMP, // push pointer to external method bcINV, // call external method bcINVBP, // call external method by pointer [top] {** for thread's **} bcPHN, // push null bcCTHR, // [top] = thread(method = [top], arg = [top+1]):id bcSTHR, // suspendthread(id = [top]) bcRTHR, // resumethread(id = [top]) bcTTHR, // terminatethread(id = [top]) {** for try..catch..finally block's **} bcTR, // try @block_catch = [top], @block_end = [top+1] bcTRS, // success exit from try/catch block bcTRR, // raise exception, message = [top] {** for string's **} bcSTRD, // strdel bcCHORD, bcORDCH, {** [!] directly memory operations **} bcALLC, //alloc memory bcRALLC, //realloc memory bcDISP, //dispose memory bcGTB, //get byte bcSTB, //set byte bcCBP, //mem copy bcRWBP, //read word bcWWBP, //write word bcRIBP, //read int bcWIBP, //write int bcRFBP, //read float bcWFBP, //write float bcRSBP, //read string bcWSBP, //write string bcTHREXT,//stop code execution bcDBP //debug method call );</span></span></code> </pre><br>  Jadi, Anda terbiasa dengan operasi apa yang dapat dilakukan oleh VM yang ditulis oleh saya.  Sekarang saya ingin berbicara tentang cara kerjanya. <br><br>  VM diimplementasikan sebagai objek, sehingga Anda dapat dengan mudah mengimplementasikan dukungan multithreading. <br><br>  Ini memiliki pointer ke array dengan opcodes, IP (Instruction Pointer) - offset dari instruksi yang dieksekusi dan pointer ke struktur VM lainnya. <br><br>  Eksekusi kode adalah switch-case yang besar. <br><br>  Berikan deskripsi VM: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TSVM = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ip, end_ip: TInstructionPointer; mainclasspath: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; mem: PMemory; stack: TStack; cbstack: TCallBackStack; bytes: PByteArr; grabber: TGrabber; consts: PConstSection; extern_methods: PImportSection; try_blocks: TTRBlocks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunThread</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadByteCodeFromArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b: TByteArr)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><h3>  Sedikit tentang penanganan pengecualian </h3><br>  Untuk melakukan ini, VM memiliki setumpuk penangan pengecualian dan blok coba / tangkap besar di mana eksekusi kode dibungkus.  Dari tumpukan, Anda dapat menempatkan struktur yang memiliki titik masuk offset pada tangkapan dan akhirnya / akhir blok penanganan pengecualian.  Saya juga menyediakan trs opcode, yang ditempatkan sebelum menangkap dan melemparkan kode ke akhirnya / akhirnya jika berhasil, secara bersamaan menghapus blok dengan informasi tentang penangan pengecualian dari atas tumpukan yang sesuai.  Apakah ini sederhana?  Sederhana  Apakah itu nyaman?  Dengan nyaman. <br><br><h3>  Mari kita bicara tentang metode dan perpustakaan eksternal </h3><br>  Saya sudah menyebutkannya sebelumnya.  Impor, perpustakaan ... Tanpa mereka, bahasa tidak akan memiliki fleksibilitas dan fungsionalitas yang diinginkan. <br><br>  Pertama-tama, dalam implementasi VM, kami akan mendeklarasikan jenis metode eksternal dan protokol untuk memanggilnya. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TExternalFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PStack: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; PExternalFunction = ^TExternalFunction;</code> </pre><br>  Saat mengimpor VM, parser bagian impor mengisi array pointer ke metode eksternal.  Oleh karena itu, setiap metode memiliki alamat statis, yang dihitung pada tahap perakitan aplikasi di bawah VM dan metode yang diinginkan dapat dipanggil. <br><br>  Panggilan nanti terjadi dengan cara ini selama eksekusi kode: <br><br><pre> <code class="delphi hljs">TExternalFunction(self.extern_methods^.GetFunc(TSVMMem(self.stack.popv).GetW))(@self.stack);</code> </pre><br><h3>  Mari menulis perpustakaan sederhana untuk VM kami </h3><br>  Dan biarkan dia pertama menerapkan metode Tidur: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> bf; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> SysUtils, svm_api <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\svm_api.pas'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stack:PStack)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sleep(TSVMMem(Stack^.popv).GetW); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> DSleep <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-string"><span class="hljs-string">'SLEEP'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><h3>  Ringkasan </h3><br>  Mengenai hal ini saya mungkin akan mengakhiri artikel pertama saya dari siklus yang dikandung. <br><br>  Hari ini saya menjelaskan pembuatan runtime bahasa secara rinci.  Saya percaya bahwa artikel ini akan sangat berguna bagi orang-orang yang memutuskan untuk mencoba menulis bahasa mereka sendiri atau untuk memahami cara kerja bahasa pemrograman yang serupa. <br><br>  Kode VM lengkap tersedia di repositori, di cabang / runtime / svm. <br><br>  Jika Anda menyukai artikel ini, maka jangan malas melemparkan nilai tambah dalam karma dan menaikkannya di atas, saya mencoba dan akan mencoba untuk Anda. <br><br>  Jika ada sesuatu yang tidak jelas bagi Anda, selamat datang di komentar atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">forum</a> . <br><br>  Mungkin pertanyaan dan jawaban Anda akan menarik bukan hanya untuk Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435202/">https://habr.com/ru/post/id435202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435186/index.html">Rolls-Royce mengembangkan pesawat listrik tercepat di dunia</a></li>
<li><a href="../id435190/index.html">Google telah berhasil menarik pajak dari $ 22,7 miliar melalui Irlandia dan Bermuda</a></li>
<li><a href="../id435194/index.html">Sederhanakan menulis resume pengembang</a></li>
<li><a href="../id435196/index.html">Peneliti lulus ReCAPTCHA menggunakan layanan Google</a></li>
<li><a href="../id435198/index.html">Arduin dan LED, atau cara meningkatkan perancang anak-anak</a></li>
<li><a href="../id435204/index.html">Penerimaan untuk pengembang untuk mengatasi penundaan</a></li>
<li><a href="../id435206/index.html">Eropa menyetujui arahan hak cipta - mengapa platform streaming menentang</a></li>
<li><a href="../id435208/index.html">Internet hal-hal ... yang menangis untuk UI / UX yang bagus</a></li>
<li><a href="../id435210/index.html">Pekerjaan Xamarin dengan C SDK</a></li>
<li><a href="../id435212/index.html">Bagaimana melupakan kartu nama kertas di tahun baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>