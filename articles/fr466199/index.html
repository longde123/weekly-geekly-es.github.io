<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóª üßó üßñüèΩ Verrous dans PostgreSQL: 4. Verrous en m√©moire üçç üìã üåì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Permettez-moi de vous rappeler que nous avons d√©j√† parl√© des verrous de relation, des verrous de niveau ligne , des verrous d'autres objets (y compris...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verrous dans PostgreSQL: 4. Verrous en m√©moire</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/466199/">  Permettez-moi de vous rappeler que nous avons d√©j√† parl√© des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">verrous de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">relation, des</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">verrous de niveau ligne</a> , des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">verrous d'autres objets</a> (y compris les pr√©dicats) et de la relation entre les diff√©rents types de verrous. <br><br>  Aujourd'hui, je termine cette s√©rie avec un article sur <strong>les verrous m√©moire</strong> .  Nous parlerons des verrous tournants, des verrous l√©gers et du verrouillage des tampons, ainsi que des outils de surveillance et d'√©chantillonnage des attentes. <br><br><img src="https://habrastorage.org/webt/2y/vt/2g/2yvt2gpimbdqmnibpzaiuf8qu0q.png"><br><a name="habracut"></a><br><h1>  Verrou rotatif </h1><br>  Contrairement aux verrous conventionnels ¬´lourds¬ª, des verrous plus l√©gers et moins chers (en termes de surcharge) sont utilis√©s pour prot√©ger les structures dans la RAM partag√©e. <br><br>  Les plus simples d'entre eux sont <em>les verrous tournants</em> ou les <em>verrous</em> <em>tournants</em> .  Ils sont con√ßus pour capturer pendant un temps tr√®s court (plusieurs instructions de processeur) et prot√©ger des sections individuelles de la m√©moire des changements simultan√©s. <br><br>  Les verrous tournants sont impl√©ment√©s sur la base d'instructions atomiques du processeur, telles que comparer et √©changer.  Ils prennent en charge un seul mode exclusif.  Si le verrou est occup√©, le processus d'attente effectue une attente active - la commande est r√©p√©t√©e (¬´rotation¬ª dans la boucle, d'o√π le nom) jusqu'√† ce qu'elle soit ex√©cut√©e avec succ√®s.  Cela a du sens, car les verrous tournants sont utilis√©s lorsque la probabilit√© de conflit est estim√©e tr√®s faible. <br><br>  Les verrous tournants ne permettent pas de d√©tecter les blocages (les d√©veloppeurs PostgreSQL le surveillent) et ne fournissent aucun outil de surveillance.  Dans l'ensemble, la seule chose que nous pouvons faire avec les verrous tournants est de conna√Ætre leur existence. <br><br><h1>  Serrures l√©g√®res </h1><br>  Viennent ensuite les <em>serrures</em> dites <em>l√©g√®res</em> (serrures l√©g√®res, lwlocks). <br><br>  Ils sont captur√©s pour le court laps de temps n√©cessaire pour travailler avec la structure de donn√©es (par exemple, une table de hachage ou une liste de pointeurs).  En r√®gle g√©n√©rale, un verrou l√©ger n'est pas maintenu longtemps, mais dans certains cas, un verrou l√©ger prot√®ge les op√©rations d'E / S, donc en principe, le temps peut s'av√©rer important. <br><br>  Deux modes sont pris en charge: exclusif (pour la modification des donn√©es) et partag√© (lecture seule).  Ainsi, il n'y a pas de file d'attente: si plusieurs processus attendent la lib√©ration du verrou, l'un d'entre eux y aura acc√®s plus ou moins al√©atoirement.  Dans les syst√®mes √† degr√© de parall√©lisme √©lev√© et √† forte charge, cela peut entra√Æner des effets d√©sagr√©ables (voir, par exemple, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion</a> ). <br><br>  Un m√©canisme de v√©rification des blocages n'est pas fourni, cela reste dans la conscience des d√©veloppeurs du noyau.  Cependant, les verrous l√©gers ont des outils de surveillance, par cons√©quent, contrairement aux verrous tournants, ils peuvent √™tre ¬´vus¬ª (un peu plus tard, je montrerai comment). <br><br><h1>  Tampon de clip </h1><br>  Un autre type de verrou dont nous avons d√©j√† parl√© dans l'article sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cache de</a> <em>tampon</em> est l' <em>√©pinglage de tampon</em> . <br><br>  Avec un tampon fixe, vous pouvez effectuer diverses actions, y compris la modification des donn√©es, mais √† condition que ces modifications ne soient pas visibles pour les autres processus en raison de la multi-version.  Autrement dit, vous pouvez ajouter une nouvelle ligne √† la page, mais vous ne pouvez pas remplacer la page du tampon par une autre. <br><br>  Si le processus est entrav√© par la liaison, il ignore g√©n√©ralement un tel tampon et en s√©lectionne un autre.  Mais dans certains cas, lorsque ce tampon particulier est requis, le processus fait la queue et s'endort - le syst√®me le r√©veille lorsque la fixation est retir√©e. <br><br>  Les attentes de consolidation sont disponibles pour le suivi. <br><br><h1>  Exemple: cache tampon </h1><br><img src="https://habrastorage.org/webt/gt/z8/gy/gtz8gylhroqbvj7jmwemqbd4jys.png"><br><br>  Maintenant, pour obtenir un aper√ßu (incomplet!) De la fa√ßon et du lieu d'utilisation des verrous, consid√©rons un exemple de cache de tampon. <br><br>  Pour acc√©der √† une table de hachage contenant des r√©f√©rences aux tampons, le processus doit capturer un verrou de mappage de tampon l√©ger en mode partag√©, et si la table doit √™tre modifi√©e, puis en mode exceptionnel.  Pour r√©duire la granularit√©, cette serrure est agenc√©e en <em>tranche</em> , compos√©e de 128 serrures distinctes, chacune prot√©geant sa propre partie de la table de hachage. <br><br>  Le processus acc√®de √† l'en-t√™te du tampon √† l'aide de spin-lock.  Des op√©rations individuelles (telles que l'incr√©mentation du compteur) peuvent √©galement √™tre effectu√©es sans verrous explicites √† l'aide d'instructions atomiques du processeur. <br><br>  Pour lire le contenu d'un tampon, un verrou de contenu de tampon est requis.  Habituellement, il n'est captur√© que le temps n√©cessaire pour lire les pointeurs vers la version des lignes, puis la protection fournie par le clip tampon est suffisante.  Pour modifier le contenu du tampon, ce verrou doit √™tre captur√© en mode exceptionnel. <br><br>  Lors de la lecture d'un tampon √† partir du disque (ou de l'√©criture sur le disque), le verrou d'E / S en cours est √©galement captur√©, ce qui signale aux autres processus que la page est en cours de lecture (ou d'√©criture) - ils peuvent faire la queue s'ils doivent √©galement faire quelque chose avec cette page. <br><br>  Les pointeurs vers les tampons libres et vers la victime suivante sont prot√©g√©s par un verrou de rotation de verrouillage de strat√©gie de tampon unique. <br><br><h1>  Exemple: tampons de journal </h1><br><img src="https://habrastorage.org/webt/_f/mu/ub/_fmuubhon3hualbtorx4rmjgur4.png"><br>  Un autre exemple: les tampons de journaux. <br><br>  Pour le cache de journal, une table de hachage est √©galement utilis√©e qui contient le mappage des pages aux tampons.  Contrairement au cache de tampon, cette table de hachage est prot√©g√©e par le seul verrou l√©ger de WALBufMappingLock, car la taille du cache de journal est plus petite (g√©n√©ralement 1/32 du cache de tampon) et l'acc√®s aux tampons est plus rationalis√©. <br><br>  L'√©criture de pages sur le disque est prot√©g√©e par un verrou WALWriteLock l√©ger afin qu'un seul processus puisse effectuer cette op√©ration √† la fois. <br><br>  Pour cr√©er une entr√©e de journal, le processus doit d'abord r√©server un espace sur la page WAL.  Pour ce faire, il capture le verrou de position d'insertion de verrouillage de rotation.  Une fois qu'un lieu est r√©serv√©, le processus copie le contenu de son dossier √† l'endroit d√©sign√©.  La copie peut √™tre effectu√©e par plusieurs processus en m√™me temps, pour lesquels l'enregistrement est prot√©g√© par une tranche de 8 verrous √† insertion facile (le processus doit capturer l' <em>un</em> d'entre eux). <br><br>  La figure ne montre pas tous les verrous li√©s au journal de pr√©-enregistrement, mais cela et l'exemple pr√©c√©dent devraient donner une id√©e de l'utilisation des verrous dans la RAM. <br><br><h1>  Suivi des attentes </h1><br>  √Ä partir de PostgreSQL 9.6, des outils de surveillance d'attente sont int√©gr√©s √† la vue pg_stat_activity.  Lorsqu'un processus (syst√®me ou maintenance) ne peut pas faire son travail et attend quelque chose, cette attente peut √™tre vue dans la vue: la colonne wait_event_type indique le type d'attente et la colonne wait_event indique le nom d'une attente sp√©cifique. <br><br>  Gardez √† l'esprit qu'une vue affiche uniquement les attentes qui sont correctement g√©r√©es dans le code source.  Si la vue ne montre pas l'attente, cela ne signifie g√©n√©ralement pas avec une probabilit√© de 100% que le processus n'attend vraiment rien. <br><br>  Malheureusement, les seules informations disponibles sur les attentes sont <em>les</em> informations <em>actuelles</em> .  Aucune statistique n'est conserv√©e.  La seule fa√ßon d'obtenir une image des attentes au fil du temps est d' <em>√©chantillonner l'</em> √©tat de la vue √† un intervalle sp√©cifique.  Il n'y a pas de moyen int√©gr√© pour cela, mais vous pouvez utiliser des extensions, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_wait_sampling</a> . <br><br>  Il est n√©cessaire de prendre en compte la nature probabiliste de l'√©chantillonnage.  Pour obtenir une image plus ou moins fiable, le nombre de mesures doit √™tre suffisamment important.  L'√©chantillonnage √† basse fr√©quence peut ne pas donner une image fiable, et l'augmentation de la fr√©quence entra√Ænera une augmentation des frais g√©n√©raux.  Pour la m√™me raison, l'√©chantillonnage est inutile pour analyser des sessions de courte dur√©e. <br><br>  Toutes les attentes peuvent √™tre divis√©es en plusieurs types. <br><br>  Les attentes des verrous consid√©r√©s constituent une grande cat√©gorie: <br><br><ul><li>  en attente de verrous d'objet (valeur de verrouillage dans la colonne wait_event_type); </li><li>  attente de verrous l√©gers (LWLock); </li><li>  en attente d'un tampon √©pingl√© (BufferPin). </li></ul><br>  Mais les processus peuvent s'attendre √† d'autres √©v√©nements: <br><br><ul><li>  Les attentes d'E / S (E / S) se produisent lorsqu'un processus doit √©crire ou lire des donn√©es; </li><li>  le processus peut attendre les donn√©es n√©cessaires au travail du client (Client) ou d'un autre processus (IPC); </li><li>  les extensions peuvent enregistrer leurs attentes sp√©cifiques (Extension). </li></ul><br>  Il y a des situations o√π un processus ne fait tout simplement pas de travail utile.  Cette cat√©gorie comprend: <br><br><ul><li>  attendre les processus d'arri√®re-plan dans sa boucle principale (activit√©); </li><li>  en attente d'une minuterie (Timeout). </li></ul><br>  En r√®gle g√©n√©rale, ces attentes sont ¬´normales¬ª et ne parlent d'aucun probl√®me. <br><br>  Le type d'attente est suivi du nom de l'attente particuli√®re.  Le tableau complet se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la documentation</a> . <br><br>  Si aucun nom d'attente n'est sp√©cifi√©, le processus n'est pas dans un √©tat d'attente.  Un tel moment doit √™tre consid√©r√© comme <em>inexpliqu√©</em> , car en fait on ne sait pas exactement ce qui se passe en ce moment. <br><br>  Cependant, il est temps de regarder. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, backend_type, wait_event_type, wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <pre> <code class="plaintext hljs"> pid | backend_type | wait_event_type | wait_event -------+------------------------------+-----------------+--------------------- 28739 | logical replication launcher | Activity | LogicalLauncherMain 28736 | autovacuum launcher | Activity | AutoVacuumMain 28963 | client backend | | 28734 | background writer | Activity | BgWriterMain 28733 | checkpointer | Activity | CheckpointerMain 28735 | walwriter | Activity | WalWriterMain (6 rows)</code> </pre><br>  On peut voir que tous les processus de service en arri√®re-plan ¬´d√©connent¬ª. Des valeurs vides dans wait_event_type et wait_event indiquent que le processus n'attend rien - dans notre cas, le processus de desserte est occup√© √† ex√©cuter la demande. <br><br><h2>  √âchantillonnage </h2><br>  Pour obtenir une image plus ou moins compl√®te des attentes √† l'aide de l'√©chantillonnage, nous utilisons l'extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_wait_sampling</a> .  Il doit √™tre compil√© √† partir du code source;  Je vais omettre cette partie.  Ensuite, nous enregistrons la biblioth√®que dans le param√®tre <em>shared_preload_libraries</em> et red√©marrons le serveur. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_wait_sampling'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Installez maintenant l'extension dans la base de donn√©es. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_wait_sampling;</code> </pre><br>  L'extension vous permet de visualiser l'historique des attentes, qui est stock√© dans un tampon circulaire.  Mais la chose la plus int√©ressante est de voir le profil des attentes - les statistiques accumul√©es pour toute la dur√©e du travail. <br><br>  Voici ce que nous verrons dans quelques secondes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile;</code> </pre><pre> <code class="plaintext hljs"> pid | event_type | event | queryid | count -------+------------+---------------------+---------+------- 29074 | Activity | LogicalLauncherMain | 0 | 220 29070 | Activity | WalWriterMain | 0 | 220 29071 | Activity | AutoVacuumMain | 0 | 219 29069 | Activity | BgWriterMain | 0 | 220 29111 | Client | ClientRead | 0 | 3 29068 | Activity | CheckpointerMain | 0 | 220 (6 rows)</code> </pre><br>  √âtant donn√© que rien ne s'est produit depuis le d√©marrage du serveur, les principales attentes sont de type Activit√© (les processus de service attendent que le travail apparaisse) et Client (psql attend que l'utilisateur envoie une demande). <br><br>  Avec les param√®tres par d√©faut (param√®tre <em>pg_wait_sampling.profile_period</em> ), la p√©riode d'√©chantillonnage est de 10 millisecondes, c'est-√†-dire que les valeurs sont enregistr√©es 100 fois par seconde.  Par cons√©quent, pour estimer la dur√©e de l'attente en secondes, la valeur de count doit √™tre divis√©e par 100. <br><br>  Pour comprendre √† quoi appartiennent les attentes de processus, nous ajoutons la vue pg_stat_activity √† la demande: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+------------------------------+------+------------+----------------------+------- 29068 | checkpointer | | Activity | CheckpointerMain | 222 29069 | background writer | | Activity | BgWriterMain | 222 29070 | walwriter | | Activity | WalWriterMain | 222 29071 | autovacuum launcher | | Activity | AutoVacuumMain | 221 29074 | logical replication launcher | | Activity | LogicalLauncherMain | 222 29111 | client backend | psql | Client | ClientRead | 4 29111 | client backend | psql | IPC | MessageQueueInternal | 1 (7 rows)</code> </pre><br>  Chargeons pgbench et voyons comment l'image change. <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><br>  Nous remettons √† z√©ro le profil collect√© et ex√©cutons le test pendant 30 secondes dans un processus distinct. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br>  La demande doit √™tre termin√©e avant la fin du processus pgbench: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+------------+------- 29148 | client backend | pgbench | IO | WALWrite | 8 29148 | client backend | pgbench | Client | ClientRead | 1 (2 rows)</code> </pre><br>  Bien s√ªr, les attentes du processus pgbench se r√©v√©leront l√©g√®rement diff√©rentes selon le syst√®me sp√©cifique.  Dans notre cas, il est tr√®s probable que l'attente d'une entr√©e de journal (IO / WALWrite) soit pr√©sent√©e, mais la plupart du temps, le processus ne s'est pas arr√™t√©, mais a fait quelque chose de vraisemblablement utile. <br><br><h2>  Serrures l√©g√®res </h2><br>  Vous devez toujours vous rappeler que l'absence de toute attente lors de l'√©chantillonnage ne signifie pas qu'il n'y avait aucune attente.  Si elle √©tait plus courte que la p√©riode d'√©chantillonnage (le centi√®me de seconde dans notre exemple), elle ne pourrait tout simplement pas tomber dans l'√©chantillon. <br><br>  Par cons√©quent, les verrous lumineux n'apparaissaient pas dans le profil - mais ils appara√Ætront si vous collectez des donn√©es pendant une longue p√©riode.  Pour garantir un aper√ßu, vous pouvez ralentir artificiellement le syst√®me de fichiers, par exemple, utiliser le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">slowfs</a> construit sur le syst√®me de fichiers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FUSE</a> . <br><br>  C'est ce que nous pouvons voir dans le m√™me test si une op√©ration d'E / S prend 1/10 de seconde. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+----------------+------- 29240 | client backend | pgbench | IO | WALWrite | 1445 29240 | client backend | pgbench | LWLock | WALWriteLock | 803 29240 | client backend | pgbench | IO | DataFileExtend | 20 (3 rows)</code> </pre><br>  Maintenant, l'attente principale du processus pgbench est li√©e aux E / S, ou plut√¥t √† une entr√©e de journal qui est ex√©cut√©e en mode synchrone √† chaque validation.  Puisque (comme illustr√© dans l'exemple ci-dessus), l'√©criture d'un journal sur le disque est prot√©g√©e par le verrou lumineux WALWriteLock, ce verrou est √©galement pr√©sent dans le profil - nous voulions le regarder. <br><br><h2>  Tampon de clip </h2><br>  Pour voir l'√©pinglage du tampon, nous profitons du fait que les curseurs ouverts maintiennent l'√©pingle afin que la lecture de la ligne suivante soit plus rapide. <br><br>  Nous commen√ßons la transaction, ouvrons le curseur et s√©lectionnons une ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgbench_history; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> tid | bid | aid | delta | mtime | filler -----+-----+-------+-------+----------------------------+-------- 9 | 1 | 35092 | 477 | 2019-09-04 16:16:18.596564 | (1 row)</code> </pre><br>  V√©rifiez que le tampon est √©pingl√© (pinning_backends): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relforknumber = <span class="hljs-number"><span class="hljs-number">0</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------ bufferid | 190 relfilenode | 47050 reltablespace | 1663 reldatabase | 16386 relforknumber | 0 relblocknumber | 0 isdirty | t usagecount | 1 pinning_backends | 1 &lt;--   1 </code> </pre><br>  Maintenant, nous allons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vider le</a> tableau: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 29367 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><pre> <code class="plaintext hljs">| INFO: vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 0 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 1 page due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. | VACUUM</code> </pre><br>  Comme nous pouvons le voir, la page a √©t√© ignor√©e (page ignor√©e 1 en raison des broches du tampon).  En effet, le nettoyage ne peut pas le g√©rer, car il est interdit de supprimer physiquement les versions de ligne d'une page dans un tampon √©pingl√©.  Mais le nettoyage n'attendra pas - la page sera trait√©e la prochaine fois. <br><br>  Et maintenant, nous allons effectuer le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nettoyage avec cong√©lation</a> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><br>  Avec un gel clairement demand√©, vous ne pouvez pas ignorer une seule page qui n'est pas marqu√©e dans la carte de gel - sinon il est impossible de r√©duire l'√¢ge maximal des transactions non gel√©es dans pg_class.relfrozenxid.  Par cons√©quent, l'effacement se bloque jusqu'√† la fermeture du curseur. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 27 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre><br><pre> <code class="plaintext hljs">| INFO: aggressively vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 26 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 0 pages due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 3.01 s. | VACUUM</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 0 (1 row)</code> </pre><br>  Eh bien, regardons le profil des attentes de la deuxi√®me session psql dans laquelle les commandes VACUUM ont √©t√© ex√©cut√©es: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.pid = <span class="hljs-number"><span class="hljs-number">29367</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+------+------------+------------+------- 29367 | client backend | psql | BufferPin | BufferPin | 294 29367 | client backend | psql | Client | ClientRead | 10 (2 rows)</code> </pre><br>  Le type d'attente BufferPin indique que le vidage attendait que le tampon soit lib√©r√©. <br><br>  Sur cela, nous supposerons que nous avons termin√© les √©cluses.  Merci √† tous pour votre attention et vos commentaires! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466199/">https://habr.com/ru/post/fr466199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466187/index.html">√âditeur de logique visuelle pour Unity3d. 2e partie</a></li>
<li><a href="../fr466191/index.html">L'essentiel de la bataille pour la neutralit√© du r√©seau aux √âtats-Unis est la chronologie des √©v√©nements et l'√©tat actuel des choses</a></li>
<li><a href="../fr466193/index.html">Alimentation automatique MailChimp personnalis√©e √† partir du flux RSS</a></li>
<li><a href="../fr466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../fr466197/index.html">PVS-Studio 7.04</a></li>
<li><a href="../fr466201/index.html">Comment quitter la science en informatique et devenir testeur: l'histoire d'une carri√®re</a></li>
<li><a href="../fr466203/index.html">Journ√©e Techdir √† Saint-P√©tersbourg. Bi√®re, pizza, deux microphones</a></li>
<li><a href="../fr466211/index.html">Projet Mainline dans Android 10</a></li>
<li><a href="../fr466213/index.html">4 √©tapes pour cr√©er un profil de candidat</a></li>
<li><a href="../fr466215/index.html">Conception orient√©e mod√®le. Cr√©ation d'un mod√®le fiable, √† partir de l'exemple d'un √©changeur de chaleur aviation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>