<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游꾼游낕 游游낖 游뛈 Primer vistazo a la FoundationDB de Apple 游눓 游냂 游볶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el 칰ltimo art칤culo, examinamos las limitaciones y obst치culos que surgen cuando necesita escalar datos horizontalmente y tener una garant칤a de las p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primer vistazo a la FoundationDB de Apple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441270/"> En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">칰ltimo art칤culo,</a> examinamos las limitaciones y obst치culos que surgen cuando necesita escalar datos horizontalmente y tener una garant칤a de las propiedades ACID de las transacciones.  En este art칤culo, hablamos sobre la tecnolog칤a FoundationDB y entendemos c칩mo ayuda a superar estas limitaciones al desarrollar aplicaciones de misi칩n cr칤tica. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FoundationDB</a> es una base de datos distribuida NoSQL con transacciones ACID serializables que almacena pares ordenados de valores clave-valor.  Las claves y los valores pueden ser secuencias arbitrarias de bytes.  No tiene un solo punto de incidencia: todas las m치quinas de cl칰ster son iguales.  Distribuye los datos entre los servidores del cl칰ster y se escala sobre la marcha: cuando necesita agregar recursos al cl칰ster, simplemente agrega la direcci칩n de la nueva m치quina en los servidores de configuraci칩n y la base de datos la recoge por s칤 misma. <a name="habracut"></a><br><br>  En FoundationDB, las transacciones nunca se bloquean entre s칤.  La lectura se implementa a trav칠s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del control de versiones multiversion</a> (MVCC), y la lectura se implementa a trav칠s del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">control de concurrencia optimista</a> (OCC).  Los desarrolladores afirman que cuando todas las m치quinas de cl칰ster est치n en el mismo centro de datos, la latencia de escritura es de 2-3 ms, y la latencia de lectura es inferior a un milisegundo.  La documentaci칩n contiene estimaciones de 10-15 ms, lo que probablemente est칠 m치s cerca de los resultados en condiciones reales. <br><br><img src="https://habrastorage.org/webt/ob/9m/jt/ob9mjtfiyqpvxfjpjc1tp48ujho.png">  <font color="#777777">* No admite propiedades ACID en varios fragmentos.</font> <br><br>  FoundationDB tiene una ventaja 칰nica: la reorganizaci칩n autom치tica.  El propio DBMS asegura una carga uniforme de las m치quinas en el cl칰ster: cuando un servidor est치 lleno, redistribuye los datos a los vecinos en segundo plano.  Al mismo tiempo, se preserva la garant칤a del nivel de Serializable para todas las transacciones, y el 칰nico efecto notable para los clientes es un ligero aumento en la latencia de las respuestas.  La base de datos garantiza que la cantidad de datos en los servidores de cl칰ster m치s y menos cargados difiere en no m치s del 5%. <br><br><h2>  Arquitectura </h2><br>  L칩gicamente, un cl칰ster FoundationDB es un conjunto de procesos del mismo tipo en diferentes m치quinas f칤sicas.  Los procesos no tienen sus propios archivos de configuraci칩n, por lo que son intercambiables.  Varios procesos fijos tienen un rol dedicado: coordinadores, y cada proceso de cl칰ster al inicio conoce sus direcciones.  Es importante que los bloqueos de los coordinadores sean lo m치s independientes posible, por lo que es mejor colocarlos en diferentes m치quinas f칤sicas o incluso en diferentes centros de datos. <br><br><img src="https://habrastorage.org/webt/ai/sx/qv/aisxqvwfakb618b27cl_vyjnc5a.png"><br><br>  Los coordinadores acuerdan entre s칤 a trav칠s del algoritmo de consenso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paxos</a> .  Seleccionan el proceso del Cluster Controller, que luego asigna roles al resto de los procesos del cl칰ster.  Cluster Controller informa continuamente a todos los coordinadores que est치 vivo.  Si la mayor칤a de los coordinadores piensan que est치 muerto, simplemente eligen uno nuevo.  Ni Cluster Controller ni Coordinators est치n involucrados en el procesamiento de transacciones; su tarea principal es eliminar la situaci칩n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cerebro dividido</a> . <br><br>  Cuando un cliente desea conectarse a la base de datos, se contacta inmediatamente con todos los coordinadores para obtener la direcci칩n del controlador de cl칰ster actual.  Si la mayor칤a de las respuestas coinciden, recibe del Cluster Controller la configuraci칩n de cl칰ster actual completa (si no coincide, vuelve a llamar a los Coordinadores). <br><br><img src="https://habrastorage.org/webt/ig/g6/qq/igg6qqffqlxbbrd-cpchddyktbu.png"><br><br>  Cluster Controller conoce el n칰mero total de procesos disponibles y distribuye roles: estos 5 ser치n Proxy, estos 2 ser치n Resolver, este ser치 Master.  Y si alguno de ellos muere, inmediatamente encontrar치 un reemplazo para 칠l, asignando el papel necesario a un proceso libre arbitrario.  Todo esto sucede en segundo plano, invisible para el programador de la aplicaci칩n. <br><br>  El proceso maestro es responsable del n칰mero de la versi칩n actual del conjunto de datos (aumenta cada vez que se escribe en la base de datos), as칤 como de la distribuci칩n de muchas claves entre servidores de almacenamiento y aceleraci칩n de velocidad (rendimiento artificialmente bajo bajo cargas pesadas: si el cl칰ster sabe que el cliente har치 muchas peque침as solicitudes, esperar치, las agrupar치 y responder치 todo el paquete de una vez). <br><br>  El registro de transacciones y el almacenamiento son dos subsistemas de almacenamiento independientes.  El primero es el almacenamiento temporal para escribir datos r치pidamente en el disco en el orden de recepci칩n, el segundo es el almacenamiento permanente, donde los datos en el disco se ordenan en orden ascendente de claves.  Cada confirmaci칩n de transacci칩n, al menos tres procesos tLog deben guardar datos antes de que el cl칰ster informe el 칠xito al cliente.  Paralelamente, los datos en segundo plano se mueven de los servidores tLog a los servidores de almacenamiento (almacenamiento en el que tambi칠n es redundante). <br><br><h2>  Procesamiento de solicitudes </h2><br>  Todas las solicitudes de clientes procesan procesos proxy.  Al abrir una transacci칩n, el cliente accede a cualquier Proxy, sondea a todos los otros Proxies y devuelve el n칰mero de versi칩n actual de los datos del cl칰ster.  Todas las lecturas posteriores ocurren en este n칰mero de versi칩n.  Si otro cliente escribi칩 los datos despu칠s de que abr칤 la transacci칩n, simplemente no ver칠 sus cambios. <br><br>  Grabar una transacci칩n es un poco m치s complicado ya que necesita resolver conflictos.  Esto incluye el proceso Resolver, que almacena en la memoria todas las claves modificadas durante un cierto per칤odo de tiempo.  Cuando el cliente completa la transacci칩n de confirmaci칩n, el Resolver verifica si los datos que estaba leyendo no est치n actualizados.  (Es decir, si la transacci칩n que se abri칩 m치s tarde que la m칤a se complet칩 y cambi칩 las claves que le칤). Si esto sucede, la transacci칩n se revierte y la propia biblioteca del cliente (!) Hace un segundo intento de confirmaci칩n.  Lo 칰nico en lo que el desarrollador debe pensar es que las transacciones son idempotentes, es decir, el uso repetido deber칤a dar un resultado id칠ntico.  Una forma de lograr esto es guardar un valor 칰nico dentro de la transacci칩n y, al comienzo de la transacci칩n, verificar su presencia en la base de datos. <br><br><img src="https://habrastorage.org/webt/h6/sl/tn/h6sltnc7mmauiguiymix7msytv0.png"><br><br>  Como en cualquier sistema cliente-servidor, hay situaciones en las que la transacci칩n se completa con 칠xito, pero el cliente no recibi칩 confirmaci칩n debido a una desconexi칩n.  La biblioteca del cliente los trata como a cualquier otro error: simplemente vuelve a intentarlo.  Esto podr칤a conducir a la re-ejecuci칩n de toda la transacci칩n.  Sin embargo, si la transacci칩n es idempotente, no hay problema con esto, no afectar치 el resultado final. <br><br><h2>  Escalamiento </h2><br>  Puede haber miles de servidores en un subsistema de almacenamiento.  쮺on cu치l de ellos debe contactarse un cliente cuando necesita datos sobre una clave determinada?  Desde Cluster Controller, el cliente conoce la configuraci칩n completa de todo el cl칰ster e incluye rangos de claves en cada servidor de almacenamiento.  Por lo tanto, simplemente accede a los servidores de almacenamiento deseados directamente sin ninguna solicitud intermedia. <br><br>  Si el servidor de almacenamiento deseado no est치 disponible, la biblioteca del cliente toma una nueva configuraci칩n de Cluster Controller.  Si, como resultado de un bloqueo del servidor, el cl칰ster comprende que la redundancia es insuficiente, inmediatamente comienza a recopilar un nuevo nodo de piezas de otro Almacenamiento. <br><br>  Suponga que guarda un gigabyte de datos en una transacci칩n.  쮺칩mo puede proporcionar una respuesta r치pida?  De ninguna manera, y por lo tanto, FoundationDB simplemente limit칩 el tama침o de una transacci칩n a 10 megabytes.  Adem치s, esta es una restricci칩n de todos los datos que <i>conciernen a</i> la transacci칩n: lecturas o escrituras.  Cada entrada en la base de datos tambi칠n est치 limitada: la clave no puede exceder los 10 kilobytes, el valor es de 100 kilobytes.  (Al mismo tiempo, para un rendimiento 칩ptimo, los desarrolladores recomiendan claves con una longitud de 32 bytes y valores con una longitud de 10 kilobytes). <br><br>  Cualquier transacci칩n puede convertirse potencialmente en una fuente de conflicto, y luego tendr치 que revertirse.  Por lo tanto, en aras de la velocidad, hasta que llegue el comando commit, tiene sentido mantener los cambios actuales en la RAM y no en el disco.  Suponga que est치 escribiendo datos en una base de datos con una carga de 1 GB / segundo.  Luego, en un caso extremo, su cl칰ster asignar치 3 GB de RAM cada segundo (escribimos transacciones en 3 m치quinas).  쮺칩mo limitar un crecimiento semejante a una avalancha de memoria usada?  Es muy simple limitar el tiempo m치ximo de transacci칩n.  En FoundationDB, una transacci칩n no puede durar m치s de 5 segundos.  Si el cliente intenta acceder a la base de datos 5 segundos despu칠s de que se abre la transacci칩n, el cl칰ster ignorar치 todos sus comandos hasta que abra uno nuevo. <br><br><h2>  칈ndices </h2><br>  Supongamos que mantiene una lista de personas, cada persona tiene un identificador 칰nico, lo usamos como clave y en el valor escribimos todos los dem치s atributos: nombre, g칠nero, edad, etc. <br><table><tbody><tr><td>  Clave </td><td>  Valor </td></tr><tr><td>  12345 </td><td>  (Ivanov Ivan Ivanovich, M, 35 a침os) </td></tr></tbody></table><br>  쮺칩mo obtener una lista de todas las personas que tienen 30 a침os sin una b칰squeda exhaustiva?  Por lo general, se crea un 칤ndice en la base de datos para esto.  Un 칤ndice es otra vista de datos dise침ada para buscar r치pidamente atributos adicionales.  Simplemente podemos agregar entradas del formulario: <br><table><tbody><tr><td>  Clave </td><td>  Valor </td></tr><tr><td>  (35, 12345) </td><td>  '' </td></tr></tbody></table><br>  Ahora, para obtener la lista que necesita, solo tiene que buscar el rango de teclas (30, *).  Como FoundationDB almacena datos ordenados por clave, dicha consulta se ejecutar치 muy r치pidamente.  Por supuesto, el 칤ndice ocupa espacio en disco adicional, pero muy poco.  Tenga en cuenta que no todos los atributos est치n duplicados, sino solo la edad y el identificador. <br><br>  Es importante que las operaciones de agregar el registro en s칤 y el 칤ndice se realicen en una transacci칩n. <br><br><h2>  Fiabilidad </h2><br>  FoundationDB est치 escrito en C ++.  Los autores comenzaron a trabajar en 칠l en 2009, la primera versi칩n se lanz칩 en 2013, y en marzo de 2015, Apple los compr칩.  Tres a침os despu칠s, Apple abri칩 inesperadamente el c칩digo fuente.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se rumorea</a> que Apple lo usa, entre otras cosas, para almacenar datos de servicio de iCloud. <br><br>  Los desarrolladores experimentados generalmente no conf칤an de inmediato en las nuevas soluciones.  Pueden pasar a침os antes de que la tecnolog칤a se establezca de manera confiable y comience a usarse masivamente en productos.  Para reducir este tiempo, los autores hicieron una extensi칩n interesante del lenguaje C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flow</a> .  Le permite emular con gracia el trabajo con componentes externos poco confiables con la posibilidad de una repetici칩n predecible completa de la ejecuci칩n del programa.  Cada llamada a una red o disco est치 envuelta en alg칰n contenedor (Actor), y cada Actor tiene varias implementaciones.  La implementaci칩n est치ndar escribe datos en el disco o en la red, seg칰n lo previsto.  Y el otro escribe en el disco 999 veces de 1000, y pierde 1 de 1000.  Una implementaci칩n de red alternativa puede, por ejemplo, intercambiar bytes en paquetes de red.  Incluso hay actores que imitan el trabajo de un administrador de sistema descuidado.  Esto puede eliminar la carpeta de datos o intercambiar dos carpetas.  Los desarrolladores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manejan miles de simulaciones</a> , sustituyen a diferentes actores y utilizan Flow para lograr una reproducibilidad del 100%: si alguna prueba falla, pueden reiniciar la simulaci칩n y obtener un bloqueo en el mismo lugar.  En particular, para eliminar la incertidumbre introducida por los hilos de conmutaci칩n del planificador del sistema operativo, cada proceso de FoundationDB es estrictamente de un solo subproceso. <br><br>  Cuando se le pidi칩 al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">investigador</a> , que descubri칩 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escenarios de p칠rdida de datos en casi todas las soluciones populares de NoSQL</a> , que probara FoundationDB, se neg칩, se침alando que no ve칤a el punto, porque los autores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hicieron un trabajo gigante</a> y los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">probaron</a> mucho m치s profundamente y m치s a fondo que el suyo. <br><br>  Es habitual pensar que las fallas de cl칰ster son aleatorias, pero los desarrolladores experimentados saben que esto est치 lejos de ser el caso.  Si tiene 10 mil discos del mismo fabricante y el mismo n칰mero de otros, entonces la tasa de fallas ser치 diferente.  En FoundationDB, es posible una configuraci칩n denominada de m치quina en la que puede decirle al cl칰ster qu칠 m치quinas est치n en el mismo centro de datos y qu칠 procesos est치n en la misma m치quina.  La base de datos tendr치 esto en cuenta al distribuir la carga entre las m치quinas.  Y las m치quinas en un cl칰ster generalmente tienen caracter칤sticas diferentes.  FoundationDB tambi칠n tiene esto en cuenta, analiza la longitud de las colas de solicitudes y redistribuye la carga de manera equilibrada: las m치quinas m치s d칠biles reciben menos solicitudes. <br><br>  Por lo tanto, FoundationDB proporciona transacciones ACID y el m치s alto nivel de aislamiento, serializable, en un grupo de miles de m치quinas.  Junto con una incre칤ble flexibilidad y alto rendimiento, suena m치gico.  Pero hay que pagar por todo, por lo que existen algunas limitaciones tecnol칩gicas. <br><br><h2>  Limitaciones </h2><br>  Adem치s de los l칤mites ya mencionados en el tama침o y la duraci칩n de la transacci칩n, es importante tener en cuenta las siguientes caracter칤sticas: <br><br><ul><li>  El lenguaje de consulta no es SQL, es decir, los desarrolladores con experiencia en SQL tendr치n que volver a aprender. <br></li><li>  La biblioteca del cliente solo admite 5 lenguajes de alto nivel (Phyton, Ruby, Java, Golang y C).  Todav칤a no hay un cliente oficial para C #.  Como no hay una API REST, la 칰nica forma de admitir otro lenguaje es escribir un contenedor encima de la biblioteca C est치ndar. <br></li><li>  No existen mecanismos para compartir, su aplicaci칩n debe proporcionar toda esta l칩gica. <br></li><li>  El formato de almacenamiento de datos no est치 documentado (aunque generalmente tampoco est치 documentado en bases de datos comerciales).  Esto es un riesgo, porque si de repente el cl칰ster no se ensambla, no est치 claro de inmediato qu칠 hacer y tendr치 que profundizar en los archivos de origen. <br></li><li>  Un modelo de programaci칩n estrictamente asincr칩nico puede parecer complicado para los desarrolladores novatos. <br></li><li>  Debe pensar constantemente en la idempotencia de las transacciones. <br></li><li>  Si tiene que dividir las transacciones largas en peque침as, entonces usted mismo debe cuidar la integridad a nivel global. <br></li></ul><br>  Traducido del ingl칠s, "Fundaci칩n" significa "Fundaci칩n" y los autores de este DBMS ven su funci칩n de esta manera: proporcionan un alto nivel de confiabilidad a nivel de registros simples, y cualquier otra base de datos puede implementarse como un complemento sobre la funcionalidad b치sica.  Por lo tanto, adem치s de FoundationDB, puede crear otras capas diferentes: documentos, gr치ficos, etc.  La pregunta sigue siendo c칩mo se escalar치n estas capas sin perder rendimiento.  Por ejemplo, los autores de CockroachDB ya han tomado este camino: al construir una capa SQL sobre RocksDB (almac칠n de valores de clave local) y obtener problemas de rendimiento inherentes a las uniones relacionales. <br><br>  Hasta la fecha, Apple ha desarrollado y publicado 2 capas sobre FoundationDB: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Document Layer</a> (admite MongoDB API) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Record Layer</a> (almacena registros como conjuntos de campos en formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Protocol Buffers</a> , admite 칤ndices, solo est치 disponible en Java).  Es agradable y gratamente sorprendente que la empresa hist칩ricamente cerrada de Apple siga hoy los pasos de Google y Microsoft y publique el c칩digo fuente de las tecnolog칤as utilizadas en su interior. <br><br><h2>  Perspectivas </h2><br>  Existe un conflicto existencial en el desarrollo de software: la empresa constantemente quiere cambios, mejoras del producto.  Pero al mismo tiempo quiere un software confiable.  Y estos dos requisitos se contradicen entre s칤, porque cuando el software cambia, aparecen errores y la empresa sufre esto.  Por lo tanto, si en su producto puede confiar en alguna tecnolog칤a confiable y probada y escribir menos c칩digo usted mismo, siempre vale la pena hacerlo.  En este sentido, a pesar de ciertas restricciones, es genial no poder esculpir muletas en diferentes bases de datos NoSQL, sino utilizar una soluci칩n probada en producci칩n con propiedades ACID. <br><br>  Hace un a침o, est치bamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimistas</a> acerca de otra tecnolog칤a: CockroachDB, pero no cumpli칩 con nuestras expectativas de rendimiento.  Desde entonces, hemos perdido el apetito por la idea de una capa SQL sobre un almac칠n de valores clave distribuido y, por lo tanto, no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizamos</a> cuidadosamente, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TiDB</a> .  Planeamos probar cuidadosamente FoundationDB como una base de datos secundaria para los conjuntos de datos m치s grandes de nuestro proyecto.  Si ya tiene experiencia en el uso real de FoundationDB o TiDB en la producci칩n, estaremos encantados de escuchar su opini칩n en los comentarios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441270/">https://habr.com/ru/post/441270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441260/index.html">C칩mo ayudaron los gr치ficos de redes neuronales</a></li>
<li><a href="../441262/index.html">Las tareas simples y largas eliminan a los candidatos mejor que los cortos y complejos</a></li>
<li><a href="../441264/index.html">Gu칤a del usuario de Kibana. Visualizaci칩n. Parte 2</a></li>
<li><a href="../441266/index.html">C칩mo funciona el marco tiOPF para delphi / lazarus. Plantilla de visitante</a></li>
<li><a href="../441268/index.html">Ceedling + Eclipse o pruebas unitarias para microcontroladores</a></li>
<li><a href="../441274/index.html">C칩mo convertirse en un probador: los conocimientos y habilidades necesarios</a></li>
<li><a href="../441278/index.html">C칩mo crear una hermosa paleta de colores</a></li>
<li><a href="../441280/index.html">Configuraci칩n de GAL en Zimbra Collaboration Suite</a></li>
<li><a href="../441282/index.html">Gran entrevista con el creador de Jenkins, Kohsuke Kawaguchi</a></li>
<li><a href="../441284/index.html">Carga masiva de datos o C칩mo alimentar a un pueblo chino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>