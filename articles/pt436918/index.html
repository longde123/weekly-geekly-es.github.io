<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèø üñ±Ô∏è ‚úÖ Criando um jogo para o Game Boy, parte 2 üëà üëµüèΩ üöß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algumas semanas atr√°s, eu decidi trabalhar em um jogo para o Game Boy, cuja cria√ß√£o me deu um grande prazer. Seu nome de trabalho √© Aqua and Ashes. O ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando um jogo para o Game Boy, parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436918/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/849/ccb/9b1/849ccb9b1062f45b917d8771b08bf2c0.png" alt="imagem"></div><br>  Algumas semanas atr√°s, eu decidi trabalhar em um jogo para o Game Boy, cuja cria√ß√£o me deu um grande prazer.  Seu nome de trabalho √© Aqua and Ashes.  O jogo tem c√≥digo aberto e √© postado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  A parte anterior do artigo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  Sprites fant√°sticos e onde eles moram </h2><br>  Na √∫ltima parte, terminei de renderizar v√°rios sprites na tela.  Isso foi feito de maneira muito arbitr√°ria e ca√≥tica.  Na verdade, eu tive que indicar no c√≥digo o que e onde eu quero exibir.  Isso tornou quase imposs√≠vel a cria√ß√£o de anima√ß√£o, gastou muito tempo de CPU e suporte complicado a c√≥digos.  Eu precisava de um caminho melhor. <br><br>  Especificamente, eu precisava de um sistema no qual pudesse simplesmente iterar o n√∫mero da anima√ß√£o, o n√∫mero do quadro e o timer de cada anima√ß√£o individual.  Se eu precisasse alterar a anima√ß√£o, alteraria a anima√ß√£o e redefiniria o contador de quadros.  O procedimento de anima√ß√£o realizado em cada quadro deve simplesmente escolher os sprites apropriados para exibi√ß√£o e jog√°-los na tela sem nenhum esfor√ßo da minha parte. <br><a name="habracut"></a><br>  E, como se viu, essa tarefa est√° praticamente resolvida.  O que eu estava procurando √© chamado de <em>mapeamento de sprites</em> .  Os mapas de sprites s√£o estruturas de dados que (grosso modo) cont√™m uma lista de sprites.  Cada mapa de sprites cont√©m todos os sprites para renderizar um √∫nico objeto.  Tamb√©m est√£o associados a eles os <em>mapas de anima√ß√£o (mapeamentos de anima√ß√£o)</em> , que s√£o listas de mapas de sprites com informa√ß√µes sobre como fazer um loop. <br><br>  √â bem engra√ßado que, em maio, eu adicionei um editor de mapas de anima√ß√£o ao editor de mapas de sprite pronto para jogos de 16 bits do Sonic sobre o Sonic.  (Ele est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , voc√™ pode estudar) Ainda n√£o est√° conclu√≠do, porque √© bastante dif√≠cil, dolorosamente lento e inconveniente de usar.  Mas, do ponto de vista t√©cnico, funciona.  E <em>me</em> parece que √© bem legal ... (Uma das raz√µes para a aspereza foi que eu literalmente trabalhei com a estrutura JavaScript.) Sonic √© um jogo antigo, por isso √© ideal como base para o meu novo jogo. <br><br><h2>  Sonic 2 Card Format </h2><br>  Eu pretendia usar o editor no Sonic 2 porque queria criar um hack para o Genesis.  Sonic 1 e 3K s√£o basicamente quase os mesmos, mas, para n√£o complicar, vou me limitar √† hist√≥ria da segunda parte. <br><br>  Primeiro, vejamos os mapas de sprite.  Aqui est√° um sprite t√≠pico do Tails, parte da anima√ß√£o piscada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a1/5c7/1a0/6a15c71a0607d906333fe5e189c3b223.png"></div><br>  O console do Genesis cria sprites um pouco diferente.  O bloco Genesis (a maioria dos programadores chama de "padr√£o") √© 8x8, assim como no Game Boy.  O sprite consiste em um ret√¢ngulo de at√© 4x4 pe√ßas, muito parecido com o modo de sprite 8x16 no Game Boy, mas mais flex√≠vel.  O truque aqui √© que, na mem√≥ria, esses blocos devem estar pr√≥ximos um do outro.  Os desenvolvedores do Sonic 2 queriam reutilizar o maior n√∫mero poss√≠vel de pe√ßas para um quadro Tails piscando de um quadro permanente do Tails.  Portanto, o Tails √© dividido em dois sprites de hardware, consistindo em pe√ßas de 3x2 - uma para a cabe√ßa e a outra para o corpo.  Eles s√£o mostrados na figura abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f35/4fd/b3cf354fd7f9f482b3e04ca5ab6b7ad3.png"></div><br>  A parte superior desta caixa de di√°logo s√£o os atributos de sprite de hardware.  Ele cont√©m sua posi√ß√£o em rela√ß√£o ao ponto inicial (n√∫meros negativos s√£o cortados; na verdade, s√£o -16 e -12 para o primeiro sprite e -12 para o segundo), o bloco inicial usado no VRAM, a largura e a altura do sprite, al√©m de v√°rios bits de status para imagem em espelho de sprite e paleta. <br><br>  Os blocos s√£o mostrados na parte inferior, √† medida que s√£o carregados da ROM para a VRAM.  N√£o h√° espa√ßo suficiente para armazenar todos os sprites do Tails na VRAM, portanto, os blocos necess√°rios devem ser copiados para a mem√≥ria em cada quadro.  Eles s√£o chamados de <em>dicas de carregamento de padr√£o din√¢mico</em> .  No entanto, embora possamos ignor√°-los, porque eles s√£o quase independentes dos mapas de sprites e, portanto, podem ser facilmente adicionados posteriormente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e7/fc5/33b/8e7fc533b1b25a0ea1edcc785163f1ba.png"></div><br>  Quanto √† anima√ß√£o, tudo aqui √© um pouco mais f√°cil.  Um mapa de anima√ß√£o no Sonic √© uma lista de mapas de sprites com dois peda√ßos de metadados - o valor da velocidade e a a√ß√£o a ser tomada ap√≥s o t√©rmino da anima√ß√£o.  As tr√™s a√ß√µes mais usadas s√£o: um loop sobre todos os quadros, um loop sobre os √∫ltimos N quadros ou uma transi√ß√£o para uma anima√ß√£o completamente diferente (por exemplo, ao alternar de uma anima√ß√£o de um Sonic em p√© para uma anima√ß√£o de seu impaciente toque com o p√©).  Existem alguns comandos que especificam sinalizadores internos na mem√≥ria dos objetos, mas poucos objetos os utilizam.  (Agora me ocorreu que voc√™ pode definir o bit na RAM do objeto para um valor ao fazer um loop na anima√ß√£o. Isso ser√° √∫til para efeitos sonoros e outras coisas.) <br><br>  Se voc√™ observar o c√≥digo do <a href="">Sonic 1 desmontado</a> (o c√≥digo do Sonic 2 √© muito grande para vincular), voc√™ perceber√° que o link para as anima√ß√µes n√£o √© criado por nenhum ID.  Cada objeto recebe uma lista de anima√ß√µes e o √≠ndice de anima√ß√£o √© armazenado na mem√≥ria.  Para renderizar uma anima√ß√£o espec√≠fica, o jogo pega um √≠ndice, procura-o na lista de anima√ß√µes e o renderiza.  Isso facilita um pouco o trabalho, porque voc√™ n√£o precisa digitalizar anima√ß√µes para encontrar a que voc√™ precisa. <br><br><h2>  Limpamos a sopa das estruturas </h2><br>  Vejamos os tipos de cart√µes: <br><br><ol><li>  Mapas de sprites: uma lista de sprites que consistem em um bloco inicial, o n√∫mero de blocos, posi√ß√£o, estado de reflex√£o (o sprite √© espelhado ou n√£o) e uma paleta. </li><li>  DPLC: uma lista de blocos de ROM que precisam ser carregados no VRAM.  Cada item em um DPLC consiste em um bloco inicial e um comprimento;  cada item √© colocado na VRAM ap√≥s o √∫ltimo. </li><li>  Mapas de anima√ß√£o: uma lista de anima√ß√µes que consiste em uma lista de mapas de sprites, valores de velocidade e a√ß√µes de ciclo. </li><li>  Lista de anima√ß√£o: uma lista de ponteiros para a a√ß√£o de cada anima√ß√£o. </li></ol><br>  Dado que estamos trabalhando com o Game Boy, algumas simplifica√ß√µes podem ser feitas.  Sabemos que em mapas de sprite em um sprite de 8x16 sempre haver√° dois blocos.  No entanto, tudo o mais deve ser preservado.  Por enquanto, podemos abandonar completamente o DPLC e apenas armazenar tudo em VRAM.  Essa √© uma solu√ß√£o tempor√°ria, mas, como eu disse, esse problema ser√° f√°cil de resolver.  Por fim, podemos descartar o valor da velocidade se assumirmos que cada anima√ß√£o funciona na mesma velocidade. <br><br>  Vamos come√ßar a descobrir como implementar um sistema semelhante no meu jogo. <br><br>  Verifique com commit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2e5e5b7</a> ! <br><br>  Vamos come√ßar com mapas de sprite.  Cada elemento no mapa deve espelhar o OAM (Object Attribute Memory - sprite VRAM) e, portanto, um loop simples e um memcpy ser√£o suficientes para exibir o objeto.  Deixe-me lembr√°-lo de que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um elemento no OAM consiste em Y, X, um bloco inicial e um byte de atributo</a> .  Eu s√≥ preciso criar uma lista deles.  Usando o pseudo-operador EQU montado, preparei o byte de atributo antecipadamente para ter um nome leg√≠vel para todas as combina√ß√µes poss√≠veis de atributos.  (Voc√™ pode perceber que no commit anterior, substitu√≠ o bloco Y / X nos cart√µes. Isso aconteceu porque li as especifica√ß√µes do OAM de forma desatenta. Tamb√©m adicionei um contador de sprite para saber quanto tempo o loop levaria.) <br><br>  Voc√™ notar√° que o corpo e a cauda da raposa polar s√£o armazenados separadamente.  Se eles fossem armazenados juntos, haveria <em>muita</em> redund√¢ncia, pois cada anima√ß√£o teria que ser duplicada para cada estado de cauda.  E a escala de redund√¢ncia aumentaria rapidamente.  No Sonic 2, o mesmo problema surgiu com o Tails.  Eles o resolveram l√°, fazendo do Tails caudas um objeto separado com seu pr√≥prio estado de anima√ß√£o e timer.  N√£o quero fazer isso porque n√£o tento resolver o problema de manter a posi√ß√£o correta da cauda em rela√ß√£o √† raposa. <br><br>  Eu resolvi o problema atrav√©s de mapas de anima√ß√£o.  Se voc√™ olhar para o meu mapa (√∫nico) de anima√ß√£o, h√° tr√™s partes de metadados nele.  Ele mostra o n√∫mero de cart√µes de anima√ß√£o, ent√£o eu sei quando eles terminar√£o.  (No Sonic, verifica-se que a anima√ß√£o a seguir √© inv√°lida, semelhante ao conceito de zero byte nas linhas C. Uma solu√ß√£o da Sonic libera o caso, mas adiciona uma compara√ß√£o que funcionaria contra mim.) Obviamente, ainda existe uma a√ß√£o de loop.  (Transformei o circuito do Sonic de 2 bytes em um n√∫mero de 1 byte no qual o bit 7 √© o bit do modo.) Mas tamb√©m tenho o n√∫mero <em>de placas de sprite</em> , mas n√£o estava no Sonic.  Ter v√°rios mapas de sprite por quadro de anima√ß√£o me permite reutilizar anima√ß√µes em v√°rias anima√ß√µes, o que, na minha opini√£o, economizar√° muito espa√ßo precioso.  Voc√™ tamb√©m pode perceber que as anima√ß√µes s√£o duplicadas para cada dire√ß√£o.  Isso ocorre porque os mapas para cada dire√ß√£o s√£o diferentes e voc√™ precisa adicion√°-los. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png" alt="imagem"></div><br><h2>  Dan√ßando com registros </h2><br>  Consulte <a href="">este arquivo</a> em 1713848. <br><br>  Vamos come√ßar desenhando um √∫nico sprite na tela.  Ent√£o, eu confesso, eu menti.  Deixe-me lembr√°-lo de que n√£o podemos gravar na tela fora do VBlank.  E todo esse processo √© longo demais para caber no VBlank.  Portanto, precisamos registrar a √°rea de mem√≥ria que alocaremos para o DMA.  No final, isso n√£o muda nada, √© importante gravar no lugar certo. <br><br>  Vamos come√ßar a contar registros.  O processador GBZ80 possui 6 registros, de A a E, H e L. H e L s√£o registros especiais, portanto, s√£o adequados para executar itera√ß√µes a partir da mem√≥ria.  (Como eles s√£o usados ‚Äã‚Äãjuntos, eles s√£o chamados HL.) Em um c√≥digo de opera√ß√£o, eu posso escrever no endere√ßo de mem√≥ria contido no HL e adicionar um a ele.  Isso √© dif√≠cil de lidar.  Voc√™ pode us√°-lo como fonte ou como destino.  Usei-o como endere√ßos e a combina√ß√£o de registros BC como fonte, porque era mais conveniente.  N√≥s temos apenas A, D e E. Eu preciso do registro A para opera√ß√µes matem√°ticas e similares.  Para que o DE pode ser usado?  Eu uso D como um contador de loop e E como um espa√ßo de trabalho.  E foi a√≠ que os registros terminaram. <br><br>  Digamos que temos 4 sprites.  Definimos o registro D (contador de ciclo) como 4, o registro HL (destino) o endere√ßo do buffer OAM e BC (a fonte) o local na ROM onde nossos cart√µes est√£o armazenados.  Agora eu gostaria de ligar para memcpy.  No entanto, um pequeno problema surge.  Lembra das coordenadas X e Y?  Eles s√£o indicados em rela√ß√£o ao ponto de partida, o centro do objeto √© usado para colis√µes e similares.  Se os gravarmos como est√£o, cada objeto ser√° exibido no canto superior esquerdo da tela.  Isso n√£o nos conv√©m.  Para corrigir isso, precisamos adicionar as coordenadas X e Y do objeto em X e Y do sprite. <br><br>  Nota curta: falo de "objetos", mas n√£o expliquei esse conceito para voc√™.  Um objeto √© simplesmente um conjunto de atributos associados a um objeto em um jogo.  Os atributos s√£o uma posi√ß√£o, velocidade, dire√ß√£o.  descri√ß√£o do item, etc.  Falo sobre isso porque preciso extrair dados X e Y desses objetos. Para fazer isso, precisamos de um terceiro conjunto de registros apontando para o local na RAM dos objetos em que as coordenadas est√£o localizadas.  E ent√£o precisamos armazenar X e Y em algum lugar. O mesmo se aplica √† dire√ß√£o, porque nos ajuda a determinar em qual dire√ß√£o os sprites est√£o olhando.  Al√©m disso, precisamos renderizar <em>todos os</em> objetos, para que eles tamb√©m precisem de um contador de loop.  E ainda n√£o chegamos √†s anima√ß√µes!  Tudo rapidamente sai do controle ... <br><br><h2>  Revis√£o da decis√£o </h2><br>  Ent√£o, estou correndo muito √† frente.  Vamos voltar e pensar sobre cada dado que preciso rastrear e onde escrev√™-lo. <br><br>  Para come√ßar, vamos dividir isso em "etapas".  Cada etapa deve receber apenas dados para a pr√≥xima, com exce√ß√£o da √∫ltima que executa a c√≥pia. <br><br><ol><li>  Objeto (loop) - descobre se o objeto deve ser renderizado e o renderiza. </li><li>  Lista de anima√ß√µes - determina qual anima√ß√£o exibir.  Tamb√©m obt√©m os atributos de um objeto. </li><li>  Anima√ß√£o (loop) - determina qual lista de mapas usar e renderiza cada mapa a partir dela. </li><li>  Mapa (ciclo) - percorre iterativamente cada sprite na lista de sprites </li><li>  Sprite - copia atributos de sprite para o buffer do OAM </li></ol><br>  Para cada um dos est√°gios, listei as vari√°veis ‚Äã‚Äãde que precisam, os pap√©is que desempenham e os locais para armazen√°-las.  Essa tabela se parece com isso. <br><br><table><tbody><tr><th>  Descri√ß√£o do produto </th><th>  Tamanho </th><th>  Est√°gio </th><th>  Use </th><th>  De onde </th><th>  Local </th><th>  Para onde </th></tr><tr><td>  Buffer OAM </td><td>  2 </td><td>  Sprite </td><td>  Ponteiro </td><td>  Hl </td><td>  Hl </td><td></td></tr><tr><td>  Origem do mapa </td><td>  2 </td><td>  Sprite </td><td>  Ponteiro </td><td>  BC </td><td>  BC </td><td></td></tr><tr><td>  Byte atual </td><td>  1 </td><td>  Sprite </td><td>  Espa√ßo de trabalho </td><td>  Origem do mapa </td><td>  E </td><td></td></tr><tr><td>  X </td><td>  1 </td><td>  Sprite </td><td>  Vari√°vel </td><td>  Hiram </td><td>  Um </td><td></td></tr><tr><td>  Y </td><td>  1 </td><td>  Sprite </td><td>  Vari√°vel </td><td>  Hiram </td><td>  Um </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  In√≠cio do mapa de anima√ß√£o </td><td>  2 </td><td>  Mapa de Sprite </td><td>  Ponteiro </td><td>  Stack3 </td><td>  DE </td><td></td></tr><tr><td>  Origem do mapa </td><td>  2 </td><td>  Mapa de Sprite </td><td>  Ponteiro </td><td>  [DE] </td><td>  BC </td><td></td></tr><tr><td>  Sprites restantes </td><td>  1 </td><td>  Mapa de Sprite </td><td>  Scratch </td><td>  Origem do mapa </td><td>  D </td><td></td></tr><tr><td>  Buffer OAM </td><td>  1 </td><td>  Mapa de Sprite </td><td>  Ponteiro </td><td>  Hl </td><td>  Hl </td><td>  Stack1 </td></tr><tr><td colspan="7"></td></tr><tr><td>  In√≠cio do mapa de anima√ß√£o </td><td>  2 </td><td>  Anima√ß√£o </td><td>  Espa√ßo de trabalho </td><td>  BC / Stack3 </td><td>  BC </td><td>  Stack3 </td></tr><tr><td>  Cart√µes restantes </td><td>  1 </td><td>  Anima√ß√£o </td><td>  Espa√ßo de trabalho </td><td>  In√≠cio da anima√ß√£o </td><td>  Hiram </td><td></td></tr><tr><td>  N√∫mero total de cart√µes </td><td>  1 </td><td>  Anima√ß√µes </td><td>  Vari√°vel </td><td>  In√≠cio da anima√ß√£o </td><td>  Hiram </td><td></td></tr><tr><td>  Dire√ß√£o do objeto </td><td>  1 </td><td>  Anima√ß√£o </td><td>  Vari√°vel </td><td>  Hiram </td><td>  Hiram </td><td></td></tr><tr><td>  Cart√µes por moldura </td><td>  1 </td><td>  Anima√ß√£o </td><td>  Vari√°vel </td><td>  In√≠cio da anima√ß√£o </td><td>  N√ÉO USADO !!! </td><td></td></tr><tr><td>  N√∫mero do quadro </td><td>  1 </td><td>  Anima√ß√£o </td><td>  Vari√°vel </td><td>  Hiram </td><td>  Um </td><td></td></tr><tr><td>  Ponteiro de mapa </td><td>  2 </td><td>  Anima√ß√£o </td><td>  Ponteiro </td><td>  AnimStart + Dir * TMC + MpF * F # </td><td>  BC </td><td>  DE </td></tr><tr><td>  Buffer OAM </td><td>  2 </td><td>  Anima√ß√£o </td><td>  Ponteiro </td><td>  Stack1 </td><td>  Hl </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  In√≠cio da tabela de anima√ß√£o </td><td>  2 </td><td>  Lista de Anima√ß√£o </td><td>  Espa√ßo de trabalho </td><td>  Conjunto r√≠gido </td><td>  DE </td><td></td></tr><tr><td>  Origem do Objeto </td><td>  2 </td><td>  Lista de Anima√ß√£o </td><td>  Ponteiro </td><td>  Hl </td><td>  Hl </td><td>  Stack2 </td></tr><tr><td>  N√∫mero do quadro </td><td>  1 </td><td>  Lista de Anima√ß√£o </td><td>  Vari√°vel </td><td>  Origem do Objeto </td><td>  Hiram </td><td></td></tr><tr><td>  N√∫mero da anima√ß√£o </td><td>  1 </td><td>  Lista de Anima√ß√£o </td><td>  Espa√ßo de trabalho </td><td>  Origem do Objeto </td><td>  Um </td><td></td></tr><tr><td>  Objeto X </td><td>  1 </td><td>  Lista de objetos </td><td>  Vari√°vel </td><td>  Origem do Objeto </td><td>  Hiram </td><td></td></tr><tr><td>  Objeto Y </td><td>  1 </td><td>  Lista de Anima√ß√£o </td><td>  Vari√°vel </td><td>  Origem do Objeto </td><td>  Hiram </td><td></td></tr><tr><td>  Dire√ß√£o do objeto </td><td>  1 </td><td>  Lista de Anima√ß√£o </td><td>  Vari√°vel </td><td>  Obj src </td><td>  Hiram </td><td></td></tr><tr><td>  In√≠cio do mapa de anima√ß√£o </td><td>  2 </td><td>  Lista de Anima√ß√£o </td><td>  Ponteiro </td><td>  [Tabela de Anim + N¬∫ de Anim] </td><td>  BC </td><td></td></tr><tr><td>  Buffer OAM </td><td>  2 </td><td>  Lista de Anima√ß√£o </td><td>  Ponteiro </td><td>  DE </td><td>  Stack1 </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Origem do Objeto </td><td>  2 </td><td>  Ciclo de objetos </td><td>  Placa de sinaliza√ß√£o </td><td>  Conjunto Duro / Pilha2 </td><td>  Hl </td><td></td></tr><tr><td>  Objetos restantes </td><td>  1 </td><td>  Ciclo de objetos </td><td>  Vari√°vel </td><td>  Calculado </td><td>  B </td><td></td></tr><tr><td>  Campo de bit ativo de um objeto </td><td>  1 </td><td>  Ciclo de objetos </td><td>  Vari√°vel </td><td>  Calculado </td><td>  C </td><td></td></tr><tr><td>  Buffer OAM </td><td>  2 </td><td>  Ciclo de objetos </td><td>  Ponteiro </td><td>  Conjunto r√≠gido </td><td>  DE </td><td></td></tr></tbody></table><br>  Sim, muito confuso.  Para ser completamente honesto, criei esta tabela apenas para publica√ß√£o, para explicar mais claramente, mas ela j√° come√ßou a ser √∫til.  Vou tentar explicar: vamos come√ßar do final e chegar ao come√ßo.  Voc√™ ver√° todos os dados com os quais come√ßo: a origem do objeto, o buffer do OAM e as vari√°veis ‚Äã‚Äãde loop pr√©-computadas.  Em cada ciclo, come√ßamos com isso e somente isso, exceto que a fonte do objeto √© atualizada em cada ciclo. <br><br>  Para cada objeto que renderizamos, √© necess√°rio definir a anima√ß√£o exibida.  Enquanto fazemos isso, tamb√©m podemos salvar os atributos X, Y, Quadro # e Dire√ß√£o antes de incrementar o ponteiro do objeto para o pr√≥ximo objeto e salv√°-los na pilha para recuperar quando sair.  Usamos o n√∫mero da anima√ß√£o em combina√ß√£o com a tabela de anima√ß√£o codificada no c√≥digo para determinar onde o mapa da anima√ß√£o come√ßa.  (Aqui simplifico, assumindo que cada objeto tenha a mesma tabela de anima√ß√£o. Isso me limita a 256 anima√ß√µes por jogo, mas √© improv√°vel que exceda esse valor.) Tamb√©m podemos escrever um buffer OAM para salvar alguns registros. <br><br>  Ap√≥s extrair o mapa de anima√ß√£o, precisamos descobrir onde est√° localizada a lista de mapas de sprites para o quadro e a dire√ß√£o especificados, bem como quantos mapas precisam ser renderizados.  Voc√™ pode perceber que a vari√°vel do cart√£o por quadro n√£o √© usada.  Isso aconteceu porque eu n√£o pensei e defini o valor constante 2. Preciso corrigi-lo.  Tamb√©m precisamos extrair o buffer do OAM da pilha.  Voc√™ tamb√©m pode notar uma completa falta de controle do ciclo.  √â realizado em um subprocedimento separado, muito mais simples, que permite que voc√™ se livre do malabarismo com os registros. <br><br>  Depois disso, tudo se torna bastante simples.  Um mapa √© um monte de sprites, ent√£o n√≥s os contornamos em um loop e desenhamos com base nas coordenadas X e Y armazenadas. No entanto, salvamos novamente o ponteiro OAM no final da lista de sprites, para que o pr√≥ximo mapa comece onde terminamos. <br><br>  Qual foi o resultado final de tudo isso?  Exatamente o mesmo de antes: uma raposa polar balan√ßando a cauda no escuro.  Mas adicionar novas anima√ß√µes ou sprites agora √© muito mais f√°cil.  Na pr√≥xima parte, falarei sobre planos de fundo complexos e rolagem de paralaxe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/cc5/431/19fcc54315854aa3dd7eafcad60c7c38.png" alt="imagem"></div><br><h2>  Parte 4. Parallax Background </h2><br>  Deixe-me lembr√°-lo, no est√°gio atual, temos sprites animados em um fundo preto s√≥lido.  Se eu n√£o pretendo fazer um jogo de arcade dos anos 70, isso claramente n√£o ser√° suficiente.  Eu preciso de algum tipo de imagem de fundo. <br><br>  Na primeira parte, quando eu estava desenhando gr√°ficos, tamb√©m criei v√°rios blocos de fundo.  √â hora de us√°-los.  Teremos tr√™s tipos "b√°sicos" de ladrilhos (c√©u, grama e terra) e dois ladrilhos de transi√ß√£o.  Todos eles est√£o carregados no VRAM e prontos para uso.  Agora s√≥ precisamos escrev√™-los em segundo plano. <br><br><h2>  Antecedentes </h2><br>  Os fundos do Game Boy s√£o armazenados na mem√≥ria em uma matriz de 32 x 32 de blocos de 8 x 8.  A cada 32 bytes corresponde a uma linha de blocos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/f70/972/3d4f70972bfc10421deaf1d18809e4f6.png"></div><br>  At√© agora, pretendo repetir a mesma <em>coluna de</em> pe√ßas em todo o espa√ßo 32x32.  Isso √© √≥timo, mas cria um pequeno problema: precisarei definir <em>cada</em> bloco 32 vezes seguidas.  Vai demorar muito tempo para escrever. <br><br>  Instintivamente, decidi usar o comando REPT para adicionar 32 bytes / linha e, em seguida, usar o memcpy para copiar o plano de fundo na VRAM. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">REPT</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_SKY ENDR REPT <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_GRASS ENDR ...</code> </pre> <br>  No entanto, isso significa que voc√™ precisa alocar 256 bytes para apenas um plano de fundo, o que √© bastante.  Esse problema √© agravado se voc√™ se lembrar de que copiar um mapa de plano de fundo criado anteriormente com o memcpy n√£o permitir√° adicionar outros tipos de colunas (por exemplo, port√µes, obst√°culos) sem complexidade significativa e montes de ROM desperdi√ßada do cartucho. <br><br>  Ent√£o, em vez disso, decidi configurar uma √∫nica coluna da seguinte maneira: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">db</span></span> BG_SKY, BG_SKY, BG_SKY, ..., BG_GRASS</code> </pre> <br>  e use um loop simples para copiar cada item desta lista 32 vezes.  (consulte <a href=""><code> LoadGFX</code> arquivo <code> LoadGFX</code> do commit 739986a</a> .) <br><br>  A conveni√™ncia dessa abordagem √© que mais tarde eu posso adicionar uma fila para escrever algo como isto: <br><br><pre> <code class="hljs perl">BGCOL_Field: db BG_SKY, ... BGCOL_LeftGoal: db BG_SKY, ... BGCOL_RightGoal: db BG_SKY, ... ... BGMAP_overview: db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_LeftGoal db <span class="hljs-number"><span class="hljs-number">30</span></span> dw BGCOL_Field db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_RightGoal db $FF</code> </pre> <br>  Se eu decidir renderizar BGMAP_overview, ele desenhar√° 1 coluna do LeftGoal, ap√≥s o que haver√° 30 colunas do Field e 1 coluna do RightGoal.  Se <code>BGMAP_overview</code> estiver na RAM, eu posso alter√°-lo <code>BGMAP_overview</code> , dependendo da posi√ß√£o da c√¢mera em X. <br><br><h2>  C√¢mera e posi√ß√£o </h2><br>  Ah sim, a c√¢mera.  Este √© um conceito importante sobre o qual ainda n√£o falei.  Aqui estamos lidando com uma infinidade de coordenadas; portanto, antes de falar sobre a c√¢mera, primeiro analisaremos tudo isso. <br><br>  Precisamos trabalhar com dois sistemas de coordenadas.  O primeiro s√£o as <em>coordenadas</em> da <em>tela</em> .  Essa √© uma √°rea de 256x256 que pode estar contida no VRAM do console do Game Boy.  Podemos rolar a parte vis√≠vel da tela dentro desses 256x256, mas quando vamos al√©m das bordas, ca√≠mos. <br><br>  Em largura, preciso de mais de 256 pixels, ent√£o adiciono <em>coordenadas do mundo</em> , que neste jogo ter√£o dimens√µes de 65536x256.  (N√£o preciso de altura extra em Y, porque o jogo ocorre em um campo plano.) Esse sistema √© completamente separado do sistema de coordenadas da tela.  Toda f√≠sica e colis√µes devem ser executadas em coordenadas mundiais, porque, caso contr√°rio, os objetos colidir√£o com objetos em outras telas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/557/fd6/56c557fd66ec77707c4083b6f38565f4.png"></div><br>  <i>Compara√ß√£o de coordenadas de tela e mundo</i> <br><br>  Como as posi√ß√µes de todos os objetos s√£o representadas em coordenadas mundiais, elas devem ser convertidas em coordenadas da tela antes da renderiza√ß√£o.  Na extremidade esquerda do mundo, as coordenadas do mundo coincidem com as da tela.  Se precisarmos exibir as coisas √† direita na tela, precisamos pegar tudo nas coordenadas do mundo e mov√™-lo para a esquerda para que elas estejam nas coordenadas da tela. <br><br>  Para fazer isso, definiremos a vari√°vel ‚Äúcamera X‚Äù, que √© definida como a borda esquerda da tela no mundo.  Por exemplo, se a <code>camera X</code> √© 1000, podemos ver as coordenadas mundiais 1000-1192, porque a tela vis√≠vel tem uma largura de 192 pixels. <br><br>  Para processar objetos, simplesmente tomamos sua posi√ß√£o em X (por exemplo, 1002), subtra√≠mos a posi√ß√£o da c√¢mera igual a 1000 e desenhamos o objeto na posi√ß√£o dada pela diferen√ßa (no nosso caso, 2).  Para um fundo que <em>n√£o</em> est√° nas coordenadas do mundo, mas j√° descrito nas coordenadas da tela, definimos a posi√ß√£o igual ao byte inferior da vari√°vel <code>camera X</code> da <code>camera X</code> .  Gra√ßas a isso, o fundo rolar√° para a esquerda e para a direita com a c√¢mera. <br><br><h2>  Parallax </h2><br>  O sistema que criamos parece bastante plano.  Cada camada de fundo se move na mesma velocidade.  N√£o parece tridimensional e precisamos corrigi-lo. <br><br>  Uma maneira simples de adicionar simula√ß√£o 3D √© chamada rolagem de paralaxe.  Imagine que voc√™ est√° dirigindo por uma estrada e est√° muito cansado.  O Game Boy ficou sem pilhas e voc√™ deve olhar pela janela do carro.  Se voc√™ olhar para o ch√£o ao seu lado, ver√°.  que ela est√° se movendo a uma velocidade de 70 milhas por hora.  No entanto, se voc√™ observar os campos √† dist√¢ncia, parece que eles est√£o se movendo muito mais devagar.  E se voc√™ olhar para as montanhas muito distantes, elas parecem mal se mover. <br><br>  Podemos simular esse efeito com tr√™s folhas de papel.  Se voc√™ desenhar uma cadeia de montanhas em uma folha, o campo na segunda e a estrada na terceira e coloc√°-las umas sobre as outras como esta.  para que cada camada fique vis√≠vel, ser√° uma imita√ß√£o do que vemos na janela do carro.  Se queremos mover o ‚Äúcarro‚Äù para a esquerda, movemos a folha superior (com a estrada) para a direita, a pr√≥xima √© um pouco para a direita e a √∫ltima √© para a direita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/b52/691/d4db5269121565e6eda63ce5e240d96e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/c39/8db/ce4c398dbae155b1da618016c83d440f.png"></div><br>  No entanto, ao implementar esse sistema no Game Boy, surge um pequeno problema.  O console possui apenas uma camada de plano de fundo.  Isso √© semelhante ao fato de termos apenas uma folha de papel.  Voc√™ n√£o pode criar um efeito de paralaxe com apenas uma folha de papel.  Ou √© poss√≠vel? <br><br><h2>  H-blank </h2><br>  A tela do Game Boy √© renderizada linha por linha.  Como resultado da emula√ß√£o do comportamento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TVs CRT antigas,</a> h√° um pequeno atraso entre cada linha.  E se pudermos us√°-lo de alguma forma?  Acontece que o Game Boy tem uma interrup√ß√£o de hardware especial especificamente para esse fim. <br><br>  Semelhante √† interrup√ß√£o do VBlank, que costum√°vamos esperar at√© o final do quadro para gravar em VRAM, h√° uma interrup√ß√£o do HBlank.  Definindo o bit 6 do registro em <code>$FF41</code> , ligando a interrup√ß√£o do <code>LCD STAT</code> e escrevendo o n√∫mero da linha em <code>$FF45</code> , podemos dizer ao Game Boy que inicie a interrup√ß√£o do <code>LCD STAT</code> quando estiver prestes a desenhar a linha especificada (e quando estiver em seu HBlank). <br><br>  Durante esse per√≠odo, podemos alterar qualquer vari√°vel VRAM.  Como n√£o √© <em>muito</em> tempo, n√£o podemos alterar mais do que alguns registros, mas ainda temos algumas possibilidades.  Queremos alterar o registro de rolagem horizontal em <code>$FF43</code> .  Nesse caso, tudo na tela abaixo da linha especificada se mover√° em uma certa quantidade de turno, criando um efeito de paralaxe. <br><br>  Se voc√™ voltar ao exemplo da montanha, poder√° perceber um problema em potencial.  Montanhas, nuvens e flores n√£o s√£o linhas planas!  N√£o podemos mover a linha selecionada para cima e para baixo durante o processo de renderiza√ß√£o;  se escolhermos, permanecer√° o mesmo pelo menos at√© o pr√≥ximo HBlank.  Ou seja, s√≥ podemos cortar em linhas retas. <br><br>  Para resolver esse problema, temos que ser um pouco mais inteligentes.  Podemos declarar alguma linha em segundo plano como uma linha que nada pode cruzar, o que significa alterar os modos dos objetos acima e abaixo dela, e o jogador n√£o poder√° perceber nada.  Por exemplo, √© aqui que essas linhas est√£o em cena com a montanha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f3/371/46a/7f337146a97de76d1c7647ec0d0d78db.png"></div><br>  Aqui eu fiz fatias logo acima e abaixo da montanha.  Tudo, do topo √† primeira linha, move-se lentamente, tudo √† segunda linha, a uma velocidade m√©dia, e tudo abaixo dessa linha, move-se rapidamente.  Este √© um truque simples, mas inteligente.  E aprendendo sobre isso, voc√™ pode notar isso em muitos jogos retr√¥, principalmente no Genesis / Mega Drive, mas tamb√©m em outros consoles.  Um dos exemplos mais √≥bvios √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte da caverna</a> de Mickey Mania.  Voc√™ pode notar que as estalagmites e estalactites no fundo s√£o separadas <em>exatamente</em> ao longo de uma linha horizontal com uma borda preta √≥bvia entre as camadas. <br><br>  Eu percebi a mesma coisa no meu passado.  No entanto, h√° um truque.  Suponha que o primeiro plano se mova a uma velocidade um em um, coincidindo com o movimento da c√¢mera, e a velocidade do plano de fundo seja um ter√ßo do movimento de pixels da c√¢mera, ou seja, o plano de fundo se mova como um ter√ßo do primeiro plano.  Mas, √© claro, um ter√ßo do pixel n√£o existe.  Portanto, preciso mover o pixel de segundo plano para cada tr√™s pixels de movimento. <br><br>  Se voc√™ trabalhava com computadores capazes de c√°lculos matem√°ticos, voc√™ usaria a posi√ß√£o da c√¢mera, dividiria por 3 e tornaria esse valor um deslocamento de fundo.  Infelizmente, o Game Boy n√£o √© capaz de fazer a divis√£o, sem mencionar o fato de que a divis√£o do programa √© um processo muito lento e doloroso.  Adicionar um dispositivo para dividir (ou multiplicar) a uma CPU fraca para um console de entretenimento port√°til nos anos 80 n√£o parecia ser um passo econ√¥mico, portanto, temos que inventar outra maneira. <br><br>  No c√≥digo, fiz o seguinte: em vez de ler a posi√ß√£o da c√¢mera de uma vari√°vel, exigi que ela aumentasse ou diminu√≠sse.  Gra√ßas a isso, com cada terceiro incremento, eu posso executar um incremento da posi√ß√£o de segundo plano e com cada primeiro incremento - um incremento da posi√ß√£o de primeiro plano.  Isso complica um pouco a rolagem para uma posi√ß√£o a partir da outra extremidade do campo (a maneira mais f√°cil √© simplesmente redefinir as posi√ß√µes das camadas ap√≥s uma certa transi√ß√£o), mas evita que tenhamos que dividir. <br><br><h2>  Resultado </h2><br>  Depois de <em>tudo isso,</em> consegui o seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif"></div><br>  Para um jogo no Game Boy, isso √© realmente muito legal.  Tanto quanto eu sei, nem todos eles t√™m rolagem de paralaxe implementada assim. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436918/">https://habr.com/ru/post/pt436918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436908/index.html">6 maneiras de ocultar dados em um aplicativo Android</a></li>
<li><a href="../pt436910/index.html">Dicas para criar fluxos de trabalho personalizados no GitLab CI</a></li>
<li><a href="../pt436912/index.html">Tend√™ncias de CRM de 2019: divertido de ler, perigoso de acreditar</a></li>
<li><a href="../pt436914/index.html">Problemas de crescimento de inicializa√ß√£o - Monitoramento</a></li>
<li><a href="../pt436916/index.html">VShard - escala horizontal em Tarantool</a></li>
<li><a href="../pt436920/index.html">Transpiler PAS2JS de Pascal para JavaScript: incompat√≠vel com Delphi e solu√ß√µes alternativas</a></li>
<li><a href="../pt436922/index.html">Otimizando o tempo de inicializa√ß√£o do Prometheus 2.6.0 com pprof</a></li>
<li><a href="../pt436924/index.html">Algumas palavras sobre a organiza√ß√£o de competi√ß√µes rob√≥ticas</a></li>
<li><a href="../pt436926/index.html">Her√≥is da autentica√ß√£o de dois fatores ou como "andar no lugar dos outros"</a></li>
<li><a href="../pt436928/index.html">WebRTC - ainda mais f√°cil (EasyRTC)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>