<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöâ üöò üÜé EFORTH para calculadora programable üò§ üíÜüèæ ü§úüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este es el primer art√≠culo de la serie 161eForth v0.5b, que termina aqu√≠: habr.com/en/post/452572 

 ¬°El traductor EFORTH ahora tambi√©n est√° en la cal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH para calculadora programable</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452398/">  <i>Este es el primer art√≠culo de la serie 161eForth v0.5b, que termina aqu√≠:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/en/post/452572</a> <br><br>  ¬°El traductor EFORTH ahora tambi√©n est√° en la calculadora electr√≥nica electr√≥nica MK-161!  El 17 de mayo, la versi√≥n v0.5b super√≥ con √©xito mis pruebas, as√≠ como cinco pruebas de autor√≠a TEST-TEST4.  He logrado lo que se puede hacer solo, pero creo que esto es solo la mitad de la batalla.  Es hora de presentar una nueva herramienta a la comunidad abriendo el c√≥digo 161eForth para pruebas p√∫blicas.  Tengo una lista de qu√© mejorar y d√≥nde "trabajar en la estabilidad".  Sus sugerencias y comentarios se tendr√°n en cuenta al completar el trabajo y la versi√≥n 1.0 <br><br>  Al portar la √∫ltima versi√≥n de eForth a la plataforma dom√©stica, se superaron con √©xito dos obst√°culos: la velocidad relativamente baja de la m√°quina de 8 bits, que est√° programada en su propio idioma de entrada, y la modesta cantidad de memoria binaria disponible (ver 2.4.1), solo 4096 bytes. <br><img src="https://habrastorage.org/webt/lx/76/pw/lx76pw2yfjmfnqz4wxg9pp_m6ya.jpeg"><br><a name="habracut"></a><br>  Al escribir 161eForth, se utilizaron soluciones preparadas para Callisto, el lenguaje de entrada de pr√≥xima generaci√≥n para PMK dom√©stico.  Esta es una tecnolog√≠a para implementar una m√°quina fuerte en la parte superior de la ALU decimal y la arquitectura "Harvard", controladores de consola y un dise√±o de teclado alfanum√©rico, as√≠ como un terminal de software basado en ellos, que funciona a trav√©s del puerto serie RS-232.  Adem√°s de Electronics MK-161 y la distribuci√≥n 161eForth, es posible que necesite un teclado de parche casero donde las letras de los alfabetos ruso e ingl√©s est√©n firmadas en las teclas.  Las letras est√°n ordenadas alfab√©ticamente l√≠nea por l√≠nea, de izquierda a derecha y de arriba a abajo. <br><img src="https://habrastorage.org/webt/ff/pu/ry/ffpury7pflujlbysn28jipoylgg.png"><br><br>  El Dr. Chen-Hanson Ting, autor de versiones modernas de eForth, enfatiza en su libro [1] la importancia de comprender los dos componentes del Fuerte.  Este es un int√©rprete interno ("direcci√≥n") que permite que el equipo ejecute el c√≥digo cosido de Fort, y un int√©rprete externo ("texto") responsable del di√°logo con una persona. <br><br>  En dos art√≠culos, me detendr√© en detalle sobre las soluciones m√°s radicales utilizadas en la implementaci√≥n de cada uno de estos dos int√©rpretes en Electr√≥nica.  Aprender estas soluciones puede ser √∫til e inspirador para migrar eForth a otros dispositivos con memoria y rendimiento limitados.  Comprender los art√≠culos ayudar√° con una introducci√≥n inicial a los microcalculadores programables (PMC) y Fort.  Explicar√© momentos dif√≠ciles exclusivos de Electronics MK y el traductor eForth. <br><br>  Para empezar, las palabras eForth se dividen en generales y sist√©micas.  <b>El tama√±o de las letras es importante.</b>  <b>Los nombres de las palabras ordinarias se definen en letras may√∫sculas y sistema - min√∫sculas.</b>  Tambi√©n hice mis innovaciones en eForth en min√∫sculas.  El autor de eForth sugiere llevar a cabo el di√°logo principal en modo CAPS.  Cuando necesite usar la palabra del sistema, cambie el tiempo a letras min√∫sculas (combinaci√≥n de teclas FP). <br><br>  En el art√≠culo, todas las palabras est√°n escritas en may√∫sculas para destacar del texto.  En varias implementaciones tempranas de eForth, los encabezados de palabras del sistema se excluyeron y el comando WORDS no los gener√≥.  Esto ayud√≥ a simplificar la apariencia de eForth y a salvar la atenci√≥n de quienes usan Fort por primera vez.  En 161eForth, los encabezados de estas palabras se guardaron principalmente debido a la presencia del descompilador de palabras SEE de dos puntos (ver video No. 3 al final del art√≠culo), que no mostrar√° los nombres de las palabras del sistema si se eliminan sus encabezados. <br><br>  Para simplificar el art√≠culo y hacerlo √∫til como referencia, tuve que usar varios t√©rminos antes de definirlos.  Los profesionales de Fort y PMK deben estar familiarizados con estos t√©rminos.  Los principiantes a veces tienen que buscar en las secciones vecinas (pongo los enlaces en los lugares correctos) o volver a leer el art√≠culo un par de veces. <br><br>  161eForth se presenta aqu√≠, junto con el texto fuente, un teclado gr√°fico en pantalla y palabras de ayuda.txt con una descripci√≥n de todas las palabras implementadas: <a href="">http://the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  Tambi√©n publiqu√© 5 videos peque√±os en YouTube que ilustran el funcionamiento del 161eForth para aquellos que no tienen el MK-161.  Puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver toda la lista de reproducci√≥n en YouTube</a> .  A continuaci√≥n se muestra el primero de ellos, los 4 restantes al final del art√≠culo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RxarUWHdNTE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  eForth y su implementaci√≥n </h2><br>  eForth fue dise√±ado como un reemplazo moderno para el conocido traductor fig-Fort.  Para transferir al MK-161, eleg√≠ una versi√≥n 5.2 de 32 bits del traductor 86eForth con c√≥digo indirecto cosido, escrito en 2016 en el ensamblador MASM para el sistema operativo Windows.  Esta versi√≥n se describe en detalle en la tercera edici√≥n de eForth y Zen [1].  Aquellos que saben ingl√©s, les aconsejo que encuentren y estudien este libro, es muy √∫til para comprender 161eForth. <br><br>  En una carta personal, el autor confirm√≥ que 86eForth502.asm de este libro es la √∫ltima versi√≥n de eForth.  En Internet puede encontrar mucha informaci√≥n en ingl√©s sobre esto y sobre versiones anteriores de eForth. <br><br>  El desarrollo de eForth sigui√≥ un camino cient√≠fico ense√±ado por el profesor Wirth utilizando el ejemplo de su lenguaje de programaci√≥n Oberon.  Cada versi√≥n posterior de eForth fue una simplificaci√≥n de la versi√≥n anterior.  Todo lo que se puede prescindir se elimin√≥ de la lengua.  Queda un conjunto cuidadosamente pensado de construcciones de lenguaje fuerte y expresivo, cuyo poder ha sido probado en m√°s de 40 implementaciones de eForth para varias plataformas.  Ahora en la calculadora! <br><br>  Al ser un dialecto minimalista de Fort, eForth no tiene como objetivo ganar la carrera contra el Fort m√°s peque√±o.  El conjunto de palabras que ofrece es bastante pr√°ctico y el programador puede ampliarlo f√°cilmente en la direcci√≥n necesaria para sus tareas. <br><br>  La primera versi√≥n de eForth se lanz√≥ en 1990 en el ensamblador MASM para procesadores 8086 y funcion√≥ bajo MS-DOS.  Conten√≠a 31 palabras centrales dependientes de la m√°quina y 191 palabras de alto nivel.  La idea era simple: traduce solo 31 palabras en su ensamblador e inmediatamente obtiene eForth en su computadora. <br><br>  Este enfoque ha sido criticado en Internet, ya que la forma de minimizar la cantidad de palabras en ensamblador ha llevado a un rendimiento extremadamente bajo para los sistemas integrados.  Ya en la segunda versi√≥n de eForth, el n√∫mero m√°ximo de palabras comenz√≥ a implementarse en ensamblador, lo que enderez√≥ la inclinaci√≥n no solo hacia un sistema de programaci√≥n f√°cil de transportar, sino tambi√©n pr√°ctico. <br><br>  Durante varios a√±os, Bill Munch, el autor original de eForth, y su colega el Dr. Chen-Hanson Ting lanzaron sus lanzamientos de eForth en paralelo.  Cada versi√≥n ten√≠a sus propias caracter√≠sticas.  Las opciones de eForth para diferentes plataformas tambi√©n han sido implementadas por otros programadores. <br><br>  La versi√≥n 5.2, lanzada en 2016, contiene 71 palabras de "c√≥digo" y 110 palabras de "colon".  Un cuarto de siglo de b√∫squeda del ideal ha llevado a una reducci√≥n significativa en el n√∫mero total de palabras.  Al mismo tiempo, por razones de rendimiento, aument√≥ el porcentaje de palabras implementadas en un nivel bajo. <br><br>  El 161eForth propuesto disfruta de los generosos beneficios de este progreso, pero no pretende desarrollar m√°s la l√≠nea troncal.  Mi implementaci√≥n proporciona al programador todas las herramientas presentes en la versi√≥n 5.2.  Cuando la arquitectura MK-161 hace que la implementaci√≥n de algunas palabras 86eForth sea imposible o no tenga sentido, en lugar de tirar el exceso, les doy a los programadores un reemplazo completo, tom√°ndolo del est√°ndar ANSI / ISO [4].  Aquellos que buscan el minimalismo pueden arrojar independientemente palabras "extra", porque por tradici√≥n 161eForth viene con c√≥digo fuente. <br><br>  Al implementar eForth, me adhir√≠ a la comprensi√≥n del autor.  Por ejemplo, en mi opini√≥n, un bucle FOR NEXT con un valor inicial de n deber√≠a ejecutarse exactamente n veces.  La misma conclusi√≥n finalmente lleg√≥ a Chuck Moore, el autor de los idiomas Forth y colorForth.  Desafortunadamente, eForth usa una convenci√≥n desactualizada y ejecuta dicho ciclo n + 1 veces, con un contador de n a 0. No solucion√© este y muchos otros defectos, prefiriendo la compatibilidad de 161eForth con implementaciones para otras plataformas. <br><br>  Dado que 161eForth es el primer sistema pr√°ctico de programaci√≥n a bordo para la electr√≥nica MK-161, con la excepci√≥n del lenguaje de f√°brica, trac√© la larga historia de eForth y devolv√≠ algunas palabras al lenguaje que fueron √∫tiles en otras plataformas y que ahora pueden ser muy demandadas. <br><br>  Por ejemplo, la nueva y antigua variable 'BOOT contiene el token (ver 3.1) de la palabra, que se ejecuta primero despu√©s de que se inicializa el entorno, pero antes de que comience el di√°logo.  Por defecto, 'BOOT contiene un token TLOAD para interpretar el c√≥digo del "√°rea de texto" (ver 2.4.2).  Esto permite al programador personalizar eForth por s√≠ mismo sin volver a compilar el entorno, que a√∫n es imposible de producir a bordo de la "Electr√≥nica". <br><br>  Las tareas prioritarias de la implementaci√≥n fueron ahorrar memoria binaria (ver 2.4.1) y mejorar el rendimiento.  Su soluci√≥n condujo a una disminuci√≥n dram√°tica en el n√∫mero de palabras de alto nivel, porque su c√≥digo ocupa esta preciosa memoria, debido a un aumento en el n√∫mero de palabras r√°pidas del n√∫cleo implementadas en la memoria barata del programa (ver 2.4.3). <br><br>  Como resultado, 161eForth contiene 129 palabras de c√≥digo, 78 palabras de alto nivel y ocupa 1816 bytes de memoria binaria MK-161, es decir, menos de la mitad.  Esto da esperanza para la metacompilaci√≥n de su parte de alto nivel directamente a bordo de la electr√≥nica. <br><br>  El c√≥digo fuente de eForth MK-161 se divide en dos partes grandes.  El n√∫cleo escrito en el sistema de comando MK-161 est√° contenido en el archivo eForth0.mkl.  Las palabras de alto nivel se definen en SP-Forth y se colocan en el archivo eForth.f. <br><br>  La distribuci√≥n tambi√©n tiene un archivo de ayuda words.txt, que documenta todas las palabras 161eForth con notaci√≥n de pila y una breve explicaci√≥n, en una l√≠nea. <br><br><h3>  1.1 El c√≥digo fuente del n√∫cleo eForth0.mkl </h3><br>  El n√∫cleo eForth contiene c√≥digo ejecutable que opera en la memoria de los programas MK-161 (ver 2.4.3), que se compila en una computadora en el archivo eForth0.mkp por medios est√°ndar, por ejemplo, el compilador MKL2MKP patentado. <br><br>  El c√≥digo fuente del n√∫cleo contenido en el archivo eForth0.mkl est√° escrito en <i>mnemotecnia latina</i> .  Por ejemplo, un comando IPE para leer el registro E (tambi√©n conocido como R14) se escribe en esta mnemotecnia como RME.  Al ser inusual para los propietarios del PMK sovi√©tico, la mnemotecnia latina es conveniente para escribir desde el teclado de una computadora.  De hecho, es m√°s f√°cil escribir FX ^ 2 extra√±o que familiar de Fx¬≤ infantil. <br><br>  El archivo eForth0.mkp es un preajuste del n√∫cleo.  Adem√°s del c√≥digo de primitivas, contiene un encabezado de n√∫cleo y una tabla de nombres tblNames, que eForth.f transfiere durante la decodificaci√≥n a registros decimales (ver 2.4.4).  Es sobre la base de eForth0.mkp que se crear√° el n√∫cleo eForth.mkp (ver 2.4.3), por lo que eForth0.mkl debe compilarse primero. <br><br><h3>  1.2 C√≥digo fuente para palabras de alto nivel eForth.f </h3><br>  El archivo eForth.f se alimenta a la entrada del maravilloso compilador dom√©stico SP-Forth [5].  El archivo contiene definiciones de todas las palabras de alto nivel.  Con el tiempo, pueden identificarse en el eForth y posiblemente compilarse directamente a bordo del Electronics MK-161. <br><br>  Durante la compilaci√≥n, eForth.f lee el n√∫cleo en blanco eForth0.mkp y con su ayuda crea tres archivos en el directorio actual para su posterior carga en MK-161: eForth.mkp, eForth.mkd y eForth.mkb.  Es eForth.mkb que contiene los cuerpos de las palabras de alto nivel, aunque sus encabezados se encuentran en el archivo eForth.mkd. <br><br>  El cuarto archivo, eForth.mkt, se escribe manualmente en eForth y se puede editar a bordo del MK-161 utilizando el editor de texto incorporado.  Analizar√© cada uno de estos cuatro archivos con m√°s detalle a continuaci√≥n (ver 2.4). <br><br><h2>  2. Electr√≥nica MK-161 </h2><br>  Un fabricante de Novosibirsk llama al MK-161 un antiguo acr√≥nimo.  Ese era el nombre de las primeras calculadoras en la URSS.  El sistema de instrucci√≥n MK-161 hereda el sistema de comando de las calculadoras sovi√©ticas "Electr√≥nica B3-34" y "Electr√≥nica MK-61".  Esto significa que los programas escritos para calculadoras sovi√©ticas ir√°n en el MK-161 sin cambios o con cambios menores. <br><br>  Lo contrario no es cierto.  eForth no ir√° a la PMK sovi√©tica, porque  utiliza muchos recursos que aparecieron por primera vez en el MK-152/161 y no estaban disponibles en modelos anteriores de la serie. <br><br>  Considere las caracter√≠sticas del lenguaje de entrada y la arquitectura del MK-161, que influyeron en 161eForth (en adelante, simplemente eForth) y le dieron a la implementaci√≥n discutida de eForth un "acento ruso". <br><br>  La primera de estas caracter√≠sticas es el acuerdo <b>"senior at junior address", que</b> se mantiene de manera consistente en MK-161.  Por ejemplo, el n√∫mero 1000 = 3 √ó 256 + 232 se escribir√° en dos bytes consecutivos, como 3 y 232. <br><br><h3>  2.1 Direccionamiento indirecto </h3><br>  La programaci√≥n sovi√©tica PMK escuch√≥ sobre direccionamiento indirecto.  Para <i>el direccionamiento directo,</i> indicamos expl√≠citamente el n√∫mero de registro al que nos referimos.  Por ejemplo, P IP 44 considera el contenido del registro 44. La clave P que apareci√≥ en MK-152 se usa para acceder a los registros con el n√∫mero 15 o m√°s; estos registros estaban ausentes en el PMK sovi√©tico. <br><br>  En <i>el direccionamiento indirecto, el</i> n√∫mero del registro requerido no se conoce de antemano.  Este n√∫mero est√° en un registro diferente.  Por ejemplo, si el registro 8 contiene el n√∫mero 44, el comando K PI 8 considera el contenido del registro 44 (R44). <br><br>  Las teclas K y P se pueden combinar.  Por ejemplo, el comando R K BP 20 transferir√° el control (GOTO en mnemotecnia latina) a la direcci√≥n almacenada en R20. <br><br>  La caracter√≠stica que result√≥ ser importante para el int√©rprete interno eForth est√° relacionada con el aumento / disminuci√≥n preliminar de registros durante el direccionamiento indirecto.  Esta caracter√≠stica se hereda de la PMK sovi√©tica. <br><br>  Por ejemplo, los comandos de lectura indirecta KI 0, KI 1, KI 2 y KI 3 reducen el contenido de los registros 0, 1, 2 o 3 en uno al registro deseado. Los comandos KI 4, KI 5 y KI 6 antes de leer, aumente el contenido de los registros 4, 5 o 6 en uno. <br><br>  Esta "modificaci√≥n" del registro de direcciones le permite procesar grupos enteros de registros en un bucle.  Es similar a ++ R y --R en C.  El n√∫mero de registro es importante.  Es √©l quien determina si aumentar√° (registros 4-6) o disminuir√° (registros 0-3) con direccionamiento indirecto. <br><br>  La arquitectura 161eForth se vio afectada por el hecho de que el aumento en los registros 4-6 con direccionamiento indirecto es <i>preliminar</i> .  Como resultado, el puntero de interpretaci√≥n (IP) ubicado en R6 siempre <i>apunta al √∫ltimo byte del</i> c√≥digo cosido.  En 86eForth, IP siempre indica un byte posterior que a√∫n no se ha le√≠do. <br><br>  Esto tambi√©n es cierto para el puntero de pila de retorno (RP) almacenado en el registro 2. R2 siempre apunta a la parte superior de la pila de retorno. <br><br>  Una caracter√≠stica √∫til del MK-161 es la ausencia de un aumento / disminuci√≥n en el registro si se produce un direccionamiento indirecto con la nueva tecla R. Por ejemplo, RKIP02 cuenta el n√∫mero desde la parte superior de la pila de retorno sin cambiar el puntero.  Este es un equipo Fort R @ ya hecho.  De lo anterior se deduce que el valor de lectura es uno menos que la direcci√≥n del siguiente token, que se ejecutar√° despu√©s de regresar de la palabra "dos puntos". <br><br>  Cuando tenga que desarrollar o estudiar palabras que interact√∫en estrechamente con el int√©rprete interno eForth, aseg√∫rese de comprender completamente este punto sutil asociado con la <b>exageraci√≥n</b> . <br><br><h3>  2.2 Tablas ordenadas y asociativas </h3><br>  Las tablas MK-161 se encuentran en la memoria del programa (consulte 2.4.3).  Aparecieron en el Novosibirsk "Electronics MK" y son completamente desconocidos para los expertos en PMK sovi√©tico.  La direcci√≥n de la tabla utilizada siempre se almacena en el registro 9042, pero el acceso a ellas es diferente. <br><br>  <i>Una tabla ordenada</i> es una matriz de enteros de 16 bits sin signo.  eForth contiene dicha tabla tblTokens con las direcciones de primitivas (ver 3.1.1) - Fort palabras escritas en el sistema de comando MK-161.  El int√©rprete de direcciones (ver 3.2) usa tblTokens para ejecutar r√°pidamente el c√≥digo cosido, por lo que eForth siempre trata de contener la direcci√≥n de esta tabla en R9042. <br><br>  Para acceder a una tabla ordenada, debe escribir el n√∫mero del art√≠culo deseado en R9210.  El n√∫mero n en el registro X ser√° reemplazado por el valor del elemento de la tabla con el n√∫mero n, el recuento comienza desde cero. <br><br>  <i>Las tablas asociativas</i> ("b√∫squeda por valor") son utilizadas activamente por eForth, principalmente por la primitiva (ENCONTRAR), buscando una palabra por su nombre.  Adem√°s, la tabla asociativa tblCHPUT se usa al imprimir letras en la pantalla para procesar avances de l√≠nea y otros c√≥digos de control. <br><br>  Para buscar el elemento n en la tabla asociativa, escriba n en R9212.  El n√∫mero n en el registro X (la administraci√≥n lo llama el "√≠ndice") ser√° reemplazado por el valor de 16 bits registrado en la tabla inmediatamente despu√©s de su "√≠ndice" n. <br><br>  La presencia de esta funci√≥n de b√∫squeda r√°pida, aunque simple, implementada en lenguaje ensamblador en el "firmware" MK-161 ayud√≥ a eForth a lograr un rendimiento aceptable al reconocer nombres de palabras y compilar programas.  Por supuesto, para esto no tuve que desarrollar las tablas de reconocimiento de nombres m√°s simples, "afiladas" para esta funci√≥n.  Hablaremos de esto con m√°s detalle en el segundo art√≠culo. <br><br><h3>  2.3 Interrupciones y consola </h3><br>  "MK Electronics" permite a sus propietarios escribir programas en el idioma de entrada que responden a ciertos eventos, como presionar o soltar un bot√≥n, finalizando el conteo del temporizador. <br><br>  eForth utiliza activamente este <i>sistema de interrupci√≥n</i> tanto para la entrada del teclado como para la visualizaci√≥n del cursor parpadeante cuando se le solicita dicha entrada y para la entrada / salida a trav√©s de un puerto serie universal (RS-232). <br><br>  Las letras ingresadas desde el teclado se colocan en la cola bufKbd mientras presiona las teclas.  Esto es muy conveniente y ahorra tiempo en sistemas con baja velocidad.  La interrupci√≥n de KeyPress maneja el alfabeto y el cambio de may√∫sculas y no ocupan espacio en la cola.  Una pulsaci√≥n larga en la tecla llama a la repetici√≥n autom√°tica. <br><br>  Cuando la l√≠nea de 8 letras est√° llena y eForth a√∫n no est√° listo para procesar la entrada (la situaci√≥n es muy rara), el MK-161 emitir√° un chirrido infeliz.  Por supuesto, me gustar√≠a no implementar todo este trabajo natural del teclado en el traductor, sino obtener el MK-161 "fuera de la caja" como un servicio del firmware (firmware).  Pero lo que, como dicen, es rico. <br><br>  Despu√©s del inicio del trabajo, toda la salida de eForth se dirige a <i>la pantalla gr√°fica</i> MK-161.  La salida de letras en √©l se lleva a cabo mediante una rutina relativamente simple de la CNCut.  La √∫nica dificultad aqu√≠ es la implementaci√≥n del c√≥digo de control de BS, el "espacio de regreso".  MK-161 usa una fuente proporcional.  Por lo tanto, en un b√∫fer especial tblBS, debe recordar las posiciones de los caracteres mostrados, desde donde los toma el c√≥digo de salida BS. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante el di√°logo, el usuario puede usar la palabra IO&gt; para redirigir todas las E / S al puerto serie RS-232, lo que permite </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programar el MK-161 desde un teclado de computadora familiar o desde otro MK-161</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La palabra CON&gt; devuelve el control a la consola de la calculadora.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4 √Åreas de memoria e instalaci√≥n de eForth en el MK-161 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La memoria "MK-161 Electronics" consta de memoria de programa direccionable por separado y memoria de registro de datos. A su vez, la memoria de registro es heterog√©nea y se divide en tres grandes √°reas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los registros con n√∫meros del 0 al 999 almacenan "n√∫meros decimales". Estos son registros ordinarios, como en "Electr√≥nica B3-34" y otras calculadoras. Simplemente son capaces de almacenar no 8, sino 12 decimales de la "mantisa". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los registros con n√∫meros del 1000 al 8167 almacenan enteros del 0 al 255. Los √∫ltimos 3 Kbytes de esta √°rea con direcciones del 5096 al 8167 se denominan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°rea de texto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los registros con n√∫meros del 9000 al 9999 se denominan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registros de funciones.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta √°rea de servicio del espacio de direcciones se asemeja a los puertos de E / S del microprocesador. </font><font style="vertical-align: inherit;">Con la ayuda de comandos de escritura y lectura, estas direcciones se utilizan para acceder a dispositivos de E / S, sistemas de interrupci√≥n, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para instalar eForth en Electronics MK-161, es suficiente transferir cuatro archivos a la calculadora, por ejemplo, utilizando el programa del fabricante MK.EXE:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escriba eForth.mkp en la memoria del programa a partir de la p√°gina 0. La versi√≥n 0.5b ocupa 74 p√°ginas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escriba eForth.mkd en la memoria de datos decimales </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escriba eForth.mkb en la memoria de datos binarios </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escriba eForth.mkt en la memoria de texto </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de transferir a la calculadora, recomiendo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guardar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inmediatamente </font><b><font style="vertical-align: inherit;">estos cuatro archivos en un directorio separado del</font></b><font style="vertical-align: inherit;"> "disco electr√≥nico" incorporado. </font><font style="vertical-align: inherit;">Como tienen el mismo nombre, puede descargar eForth de inmediato a la vez como un "paquete".</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.1 Memoria binaria ("byte") MK-161: eForth.mkb </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los registros de Electronics MK con n√∫meros del 1000 al 5095 se utilizan para almacenar n√∫meros del 0 al 255. Esta √°rea de la memoria de registro de la calculadora se llama binaria. Se puede acceder a dos registros binarios consecutivos desde eForth como una √∫nica "celda" de 16 bits y (como en todas partes en el MK-161), los 8 bits superiores est√°n en el registro con un n√∫mero m√°s bajo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth utiliza esta peque√±a "memoria binaria" como su principal. Las palabras funcionan con ella! y @, AQU√ç y ALLOT, solo desde aqu√≠ el int√©rprete de direcciones ejecuta el c√≥digo cosido (ver 3.2). Aqu√≠ est√°n las variables eForth, el b√∫fer de entrada de texto (TIB), el diccionario y la pila de reversi√≥n tblBS para implementar el retroceso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4096 bytes es muy modesto, seg√∫n los est√°ndares modernos. Por lo tanto, se han realizado enormes esfuerzos para llevar a otras √°reas de la memoria todo lo posible.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.2 √Årea de texto: eForth.mkt </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inmediatamente despu√©s de que la memoria binaria es un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°rea de texto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , los registros con n√∫meros del 5095 al 8167. T√©cnicamente, son los mismos registros de bytes, pero la capacidad de escribirlos en el disco y leerlos como un archivo separado hace que esta √°rea sea especial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La palabra CARGAR se utiliza para trabajar con "texto" en eForth. </font><font style="vertical-align: inherit;">Alimenta toda esta √°rea a la entrada del int√©rprete de texto, como una cadena, 3072 letras de largo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe desacuerdo sobre c√≥mo dividir el texto en l√≠neas. </font><font style="vertical-align: inherit;">Un editor integrado en MK Electronics insiste en una longitud de l√≠nea de 24 caracteres. </font><font style="vertical-align: inherit;">Callisto usa la convenci√≥n Fort, donde la cadena contiene 64 caracteres. </font><font style="vertical-align: inherit;">eForth ofrece al usuario la opci√≥n de contar todo el texto como una l√≠nea larga. </font><font style="vertical-align: inherit;">Puede usar el editor incorporado MK-161. </font><font style="vertical-align: inherit;">Puedes escribir el tuyo, compatible con Callisto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ est√° el contenido inicial de eForth.mkt, por conveniencia, dividido en tres l√≠neas: </font></font><br><br><pre><code class="plaintext hljs">: hi ." , %user%!" CR ; ' hi 'boot ! hi \</code> </pre> <br>  La primera l√≠nea define la nueva palabra hola que saluda al usuario.  La segunda l√≠nea toma el token de esta palabra (ver 3.1) y lo coloca en la variable 'BOOT (ver 1).  Ahora el √°rea de texto dejar√° de compilarse cada vez que se inicie eForth.  En su lugar, se ejecutar√° el saludo ya compilado. <br><br>  La √∫ltima l√≠nea comienza la palabra hola, mostrando un saludo en la pantalla.  La palabra \ completa la interpretaci√≥n del texto, devolviendo el control a la consola. <br><br>  Para compilar un archivo de texto arbitrario, debe ir a la calculadora con el comando BYE, ir al men√∫ principal y cargar el archivo deseado en modo DOS.  Tambi√©n puede transferir el archivo mkt desde una computadora.  La tecla C / P lo regresar√° a eForth, luego de lo cual con el comando TLOAD puede compilar el archivo cargado en el √°rea de texto. <br><br><h4>  2.4.3 Memoria de programa: eForth.mkp </h4><br>  La memoria de programa MK-161 es un espacio de direcciones aislado.  Tambi√©n almacena bytes, pero son de solo lectura.  La memoria del programa contiene 10,000 "pasos", que resultaron ser redundantes para eForth.  M√°s de una cuarta parte de la memoria del programa result√≥ ser libre, lo que ofrece una buena reserva para el desarrollo del traductor. <br><br>  Solo en la memoria del programa se pueden implementar "palabras de c√≥digo".  Adem√°s, las tablas de reconocimiento de nombres y todas las cadenas de texto conocidas se representan aqu√≠, lo que ahorra memoria binaria. <br><br>  Algunas palabras, como C @, COUNT y TYPE, pueden direccionar la memoria del programa si la direcci√≥n no es un n√∫mero positivo.  Por ejemplo, la frase 0 C @ cuenta como un "paso" (byte) de la direcci√≥n 0 de la memoria del programa. <br><br><h4>  2.4.4 Memoria decimal: eForth.mkd </h4><br>  Los registros de MK Electronics con n√∫meros del 0 al 999 se denominan decimales y contienen n√∫meros utilizados para c√°lculos ordinarios en la calculadora: 12 d√≠gitos decimales de la "mantisa" y 2 d√≠gitos decimales del "orden".  El fuerte est√° dise√±ado para trabajar con enteros de hasta 4 bytes de longitud, un recurso de este tipo es claramente redundante para eForth. <br><br>  La memoria decimal se usa para guardar una preciosa memoria binaria.  Las pilas de datos y devoluciones se realizan aqu√≠.  Aqu√≠ se almacenan los encabezados de las palabras: definidas por el usuario e incrustadas, un registro por t√≠tulo.  Este enfoque le permite redefinir incluso palabras con nombres est√°ndar. <br><br>  La pila en la memoria decimal conduce a una serie de caracter√≠sticas caracter√≠sticas del Fuerte en el MK-161.  En primer lugar, el rango de valores de los elementos de la pila es enorme; puede acomodar enteros de 32 bits.  La necesidad de "enteros dobles" en el MK-161 desaparece, aunque en aras de la compatibilidad, he implementado las palabras correspondientes eForth.  Los "enteros dobles" se presentan en MK-161, como dos elementos de la pila que contienen n√∫meros del 0 al 65535, que codifican un entero de 32 bits con un signo en el c√≥digo adicional.  Los 16 bits m√°s altos de este n√∫mero se colocan en la parte superior, es decir, en la direcci√≥n m√°s baja. <br><br>  Las operaciones l√≥gicas bit a bit AND, OR, XOR y NOT tratan sus argumentos como enteros de 16 bits.  Un resultado de 32768 a 65535 se convierte en n√∫meros negativos de -32768 a -1.  En eForth, falso se codifica con cero y la verdad menos uno.  Tambi√©n es cierto cualquier valor que no sea cero. <br><br>  La segunda caracter√≠stica de la pila de datos 161eForth es que contiene n√∫meros con signo.  Cuando la palabra @ lee el n√∫mero 65535 de una "celda" de 16 bits, se convierte autom√°ticamente a -1.  Se proporciona <b>una palabra especial "sin signo" U @</b> para contar directamente 65535, con un signo m√°s. <br><br>  Recuerdo que, en aras de la velocidad, los <b>dos elementos superiores de la pila de</b> datos no se encuentran en la memoria decimal, sino directamente <b>en los registros X e Y.</b> <br><br>  EForth no utiliza el hecho de que los registros decimales pueden contener n√∫meros fraccionarios y n√∫meros de coma flotante.  La m√°quina virtual eForth utiliza estos registros para almacenar enteros decimales de 12 bits con signo.  Se accede a los registros decimales con las palabras C @ y C!  - los mismos que funcionan con cualquier registro individual. <br><br><h2>  3. El int√©rprete interno. </h2><br>  El n√∫cleo eForth es un programa escrito en el lenguaje de entrada MK-161.  Su primer comando PRINCIPAL transfiere el control al c√≥digo PRINCIPAL, que primero descubre las circunstancias del reinicio.  Si fue causado por el token incorrecto, MK-161 chillar√°.  En la primera puesta en marcha, y tambi√©n despu√©s de encender el MK-161, la pantalla se borra.  Luego, MAIN llama a la subrutina Init para inicializar el sistema de interrupci√≥n y todo lo que necesitan los controladores de consola MK-161. <br><br>  Despu√©s de inicializar las pilas de datos y las devoluciones, se completa la parte de bajo nivel del inicio.  Suceden cosas incre√≠bles para las m√°quinas con arquitectura Harvard: eForth ejecuta el "c√≥digo cableado" desde la memoria de bytes.  El honor de ser el primero pertenece a una palabra cuya direcci√≥n de encabezado se registra en R43.  Esta suele ser la palabra FR√çO. <br><br>  ¬øC√≥mo se organizan <i>las palabras de alto nivel</i> (IED)?  Cualquier palabra consta de dos partes, un cuerpo y un encabezado.  <i>El encabezado</i> se almacena en decimal.  Ayuda al int√©rprete externo y al descompilador a encontrar el nombre y el cuerpo de la palabra.  El encabezado tambi√©n contiene <i>un campo de "l√©xico"</i> : un conjunto de indicadores que ayudan al int√©rprete externo a procesar correctamente la palabra encontrada.  El int√©rprete interno es mucho m√°s importante para el cuerpo VCA ubicado en la memoria binaria y almacenado en el diccionario.  Incluso puede ejecutar palabras que no tienen encabezado. <br><br>  <i>El cuerpo del</i> VCA comienza con el byte del <i>campo de c√≥digo</i> , que contiene la direcci√≥n del <i>procesador de la</i> palabra dada.  Cuatro controladores VCA est√°n escritos en el lenguaje de entrada MK-161 y comienzan en la primera p√°gina de la memoria del programa.  Los analizaremos todos (ver 3.3), pero el principal se llama DOLST y se encuentra en la direcci√≥n 02, inmediatamente despu√©s del comando MAIN BP ya considerado.  Este controlador ejecuta palabras Fort definidas con dos puntos. <br><br>  Despu√©s del byte del <i>campo de</i> c√≥digo <i>hay un campo de par√°metro de</i> longitud arbitraria.  En las "palabras de dos puntos", el campo de par√°metro contiene un "c√≥digo cosido", una secuencia de tokens de 16 bits, cada uno de los cuales indica una acci√≥n asignada a √©l. <br><br>  Primero, consideraremos el token con m√°s detalle.  Luego estudiaremos el int√©rprete interno INEXT, que transfiere de un token a la ejecuci√≥n del siguiente.  EForth llama a INEXT un manejador primitivo.  Concluimos este recorrido por el int√©rprete interno analizando los cuatro procesadores IED. <br><br><h3>  3.1 fichas </h3><br>  <i>El token</i> representa la palabra en el c√≥digo cosido y la pila, lo que permite que se ejecute r√°pidamente.  El token es un puntero al cuerpo de la palabra, pero la dura arquitectura del MK-161 hizo sus propios ajustes a esta idea simple.  Analicemos todos los tipos de tokens, comenzando con el token primitivo. <br><br><h4>  3.1.1 Token primitivo </h4><br>  Todas las palabras incluidas en la distribuci√≥n eForth est√°n numeradas del 0 al 206. Esta numeraci√≥n es de extremo a extremo, teniendo en cuenta tanto las primitivas como el VCA.  Esto se hace para que por el n√∫mero de la palabra sea f√°cil restaurar su <i>nombre</i> .  Estos nombres se almacenan en la memoria del programa.  El enlace al nombre deseado se encuentra f√°cilmente a trav√©s de la tabla de encabezado. <br><br>  <b>El n√∫mero primitivo es su token</b> .  Como cualquier token, la primitiva toma dos bytes en el c√≥digo cosido.  El primero es cero.  El segundo contiene su n√∫mero.  La tabla tblTokens le permite encontrar r√°pidamente la direcci√≥n del c√≥digo primitivo por este n√∫mero.  La direcci√≥n tblTokens se almacena permanentemente en R9042 (ver 2.2), es decir, todo est√° siempre a mano para ejecutar la primitiva. <br><br>  La palabra XT&gt; le permite encontrar la direcci√≥n de un c√≥digo primitivo por su n√∫mero (token).  Como el c√≥digo de primitivas siempre se encuentra en la memoria del programa, la direcci√≥n recibida siempre es negativa (ver 2.4.3). <br><br><h4>  3.1.2 token VCA </h4><br>  VCA puede tener su propio n√∫mero y nombre est√°ndar asociado, o puede ser completamente nuevo, creado por el usuario.  En todos los casos, el <b>token VCA es la direcci√≥n de su campo de c√≥digo</b> (ver 3), es decir, un n√∫mero de 1000 a 5095. <br><br>  En el c√≥digo cosido, el token VCA est√° escrito de una manera muy inusual.  El n√∫mero de cientos (un n√∫mero del 10 al 50) se escribe en el primer byte, el resto de dividir el token por 100 (un n√∫mero del 0 al 99) en el segundo byte. <br><br>  Por ejemplo, el token 1234 estar√° representado por dos bytes 12 y 34. La compilaci√≥n de este, y cualquier otro token, se lleva a cabo utilizando la palabra COMPILAR tomada del est√°ndar ANSI.  Para escribir y leer tokens VCA en el c√≥digo cosido, las palabras XT!  y XT @.  Acceden a las direcciones (ver 3.1.4), y la palabra XT @ tambi√©n puede leer el token primitivo. <br><br><h4>  3.1.3 Literales enteros </h4><br>  <i>Los literales enteros</i> son una especie de tokens primitivos.  Son lo suficientemente inusuales como para considerarse por separado. <br><br>  En el c√≥digo cosido, los tokens DOLIT y DOLITM ocupan cuatro bytes.  Los primeros dos bytes contienen el token primitivo ya considerado, es decir, 0 y el n√∫mero del primitivo.  Los siguientes dos bytes contienen un n√∫mero entero que el literal dado colocar√° en la pila de datos durante la ejecuci√≥n. <br><br>  DOLITM difiere en que cambia el signo del n√∫mero antes de colocarlo en la pila.  Est√° dise√±ado para implementar n√∫meros negativos. <br><br><h4>  3.1.4 Literales de direcci√≥n </h4><br>  Al igual que los literales completos, los tres <i>literales de direcci√≥n</i> BRANCH,? BRANCH y DONXT ocupan 4 bytes cada uno en el c√≥digo cosido.  Los primeros 2 bytes contienen el token primitivo, los dos √∫ltimos bytes son la direcci√≥n de salto. <br><br>  La direcci√≥n se registra en el mismo formato que el token VCA (consulte 3.1.2).  El primer byte contiene el n√∫mero de cientos, el segundo contiene el resto de dividir la direcci√≥n por 100. Recuerdo que debido a la exageraci√≥n (ver 2.1), la direcci√≥n de transici√≥n no contiene la direcci√≥n del token deseado, sino un n√∫mero menos por uno. <br><br>  El token DONXT ayuda a implementar el "ciclo final" FOR-NEXT (ver 1).  El salto incondicional BRANCH es necesario para implementar el ciclo infinito BEGIN-AGAIN.  Rama condicional? BRANCH transfiere el control si cero est√° en la parte superior de la pila de datos (falso).  Sirve para implementar la instrucci√≥n condicional IF-THEN, salidas de "bucles indefinidos" BEGIN-UNTIL y BEGIN-WHILE-REPEAT. <br><br><h4>  3.1.5 Literales de cadena </h4><br>  <i>Los literales de cadena</i> son un tipo de tokens VCA.  En el c√≥digo cosido de un literal de cadena, despu√©s de un token, hay un byte con una longitud de cadena, despu√©s de lo cual es la cadena en s√≠, desde el primer byte hasta el √∫ltimo. <br><br>  EForth tiene tres literales de cadena: $ "| ,." |  y abortar "|. Se definen en el archivo eForth0.mkl como tokens STRQP, DOTQP y ABORQ, respectivamente. El trabajo" literal "principal se realiza para ellos con la palabra do $, el token DOSTR. <br><br>  Para que el tama√±o del art√≠culo sea razonable, no puedo detenerme demasiado en este interesante tema, pero es bueno saber acerca de su disponibilidad en eForth. <br><br><h3>  3.2 Int√©rprete de direcciones </h3><br>  Es hora de considerar <i>el int√©rprete de tokens</i> , cuya direcci√≥n siempre se escribe en el registro 9. La mayor√≠a de las primitivas terminan su trabajo con el comando K BP 9, que transfiere el control a la etiqueta INEXT. <br><br><pre> <code class="plaintext hljs">INEXT: 6 Fx‚â†0 NPrime NData:  2 6 + 7 F‚ü≥ 7 8 F‚ü≥ 8</code> </pre> <br>  Primero, el int√©rprete de direcciones lee el primer byte del siguiente token con el comando KIP6.  Si es cero, este es un primitivo y el c√≥digo bajo la etiqueta NPrime manejar√° el token. <br><br>  La etiqueta NData denota el procesamiento del token VCA.  El primer byte se multiplica por cien por el comando VP 2, despu√©s de lo cual KIP6 + agrega el segundo byte del token al resultado (ver 3.1.2).  El equipo P7 ingresa el token de lectura en el WP "registro de trabajo" (R7). <br><br>  Sabemos que el token VCA es la direcci√≥n de su campo de c√≥digo, que contiene la direcci√≥n del procesador.  Los comandos KIP7 P8 leen el byte del campo de c√≥digo en R8, y el comando KBP8 transfiere el control al procesador VCA.  El controlador sabe que R7 contiene un n√∫mero uno menos que la direcci√≥n del campo de par√°metro de la palabra que se procesa. <br><br>  Las instrucciones F‚ü≥ con el c√≥digo 25 est√°n "ordenadas" en la pila.  El hecho es que eForth almacena los dos elementos superiores de la pila de datos directamente en los registros X e Y de la pila MK-161.  Tal soluci√≥n acelera el trabajo, pero hace que sea necesario asegurarse de que estos datos importantes no se pierdan. <br><br>  Queda por comprender c√≥mo el int√©rprete de direcciones ejecuta las primitivas. <br><br><pre> <code class="plaintext hljs">NPrime: F‚ü≥ 6 9210 8 F‚ü≥ 8</code> </pre> <br>  El comando KIP6 lee el segundo byte del token primitivo.  Los comandos RRP9210 P8 leen la direcci√≥n de esta primitiva de la tabla tblTokens (ver 2.2 y 3.1.1), y KBP8 transfiere el control a esta primitiva. <br><br>  Como anteriormente, F‚ü≥ elimina el exceso de la pila, restaurando el contenido de los registros X e Y. <br><br>  El int√©rprete de direcciones eForth es tan peque√±o que se duplica varias veces en la memoria del programa.  La copia principal se ejecuta mediante el comando K BP 9, que completa la mayor√≠a de las primitivas. <br><br>  Como ejercicio, recomiendo estudiar la implementaci√≥n de la palabra EJECUTAR, colocada despu√©s de la etiqueta EXECU.  Esta es una variante INEXT, que lee el token no del c√≥digo cosido, sino que lo toma de la pila de datos. <br><br><h3>  3.3 controladores VCA </h3><br>  Cuatro variedades de VCA tienen cuatro controladores diferentes: DOLST, DOVAR, DOCON y DOCONM.  Ya hemos visto anteriormente que el int√©rprete de direcciones antes de llamar al controlador deja en R7 la direcci√≥n del campo de c√≥digo de la palabra que se est√° procesando. <br><br>  eForth.f aprende las direcciones de estos manejadores leyendo el encabezado del n√∫cleo del archivo eForth0.mkp.  Esto le ayuda a compilar el VCA para la Electr√≥nica MK-161 correctamente colocando el resultado en el archivo eForth.mkb. <br><br><h4>  3.3.1 Palabras de dos puntos: DOLST y EXIT </h4><br>  El siguiente tema importante despu√©s de INEXT es lo que hace el int√©rprete interno cuando encuentra el token de una palabra definida a trav√©s de dos puntos.  El campo de c√≥digo de dicha palabra contiene el n√∫mero 2, por lo que INEXT transfiere el control al controlador DOLST, que hace el trabajo necesario para comenzar a interpretar la nueva lista de tokens. <br><br><pre> <code class="plaintext hljs">DOLST: 6 2 F‚ü≥ 7 6 F‚ü≥ INEXT:</code> </pre> <br>  El registro 2, como ya hemos discutido (ver 2.1), contiene un puntero de pila de retorno RP.  Los comandos IP6 KP2 escriben el valor de R6, el puntero de interpretaci√≥n (IP), en la pila de retorno.  M√°s tarde, esto ayudar√° a recordar la posici√≥n actual en la antigua lista de tokens, donde INEXT encontr√≥ una palabra de dos puntos.  Ahora IP7 P6 reorganiza IP al comienzo de una nueva lista. <br><br>  Inmediatamente despu√©s del c√≥digo DOLST, se coloca el c√≥digo INEXT, que ejecutar√° la primera palabra de la nueva lista de tokens.  Como en otros lugares, los comandos F  ayudan a mantener los dos elementos superiores de la pila de datos. <br><br>  Las palabras de dos puntos generalmente terminan con un token EXITT, que hace lo contrario, en comparaci√≥n con DOLST: toma el antiguo valor de IP de la pila de retorno y vuelve a la interpretaci√≥n de la lista de tokens anterior. <br><br><pre> <code class="plaintext hljs">EXITT: 02 6 x 1 2 + 2 F‚ü≥ INEXT:</code> </pre> <br>  Los comandos RKIP02 P6 leen el antiguo valor de IP desde la parte superior de la pila de retorno (ver 2.1).  Despu√©s de eso, los comandos Cx 1 IP2 + P2 corrigen el valor de RP, increment√°ndolo en uno.  El comando F‚ü≥ restaura la pila, despu√©s de lo cual INEXT ejecuta la siguiente palabra de la lista de tokens anterior. <br><br>  Por supuesto, INEXT no puede ir despu√©s de DOLST y EXITT al mismo tiempo.  Para hacer esto, apliqu√© un antiguo truco de la √©poca de la URSS.  Tambi√©n puede dominarlo examinando las l√≠neas correspondientes en el archivo eForth0.mkl. <br><br><h4>  3.3.2 DOVAR, variable y controlador de matriz </h4><br>  Las palabras generadas por las palabras CREATE y VARIABLE usan el mismo controlador DOVAR.  Este controlador empuja en la pila la direcci√≥n de la variable ubicada en el campo de par√°metro, que va inmediatamente despu√©s del byte del campo de c√≥digo.  Las variables VARIABLES ocupan 2 bytes, y las matrices creadas usando CREATE contienen tantos bytes como el programador quiera. <br><br><pre> <code class="plaintext hljs">DOVAR: ‚áî 3 x 1 7 + 9</code> </pre> <br>  Los comandos ‚áî KP3 guardan el contenido del registro Y en la pila de datos. Al mismo tiempo, el n√∫mero desde la parte superior de la pila se ingresa en RY, liberando RX al nuevo valor.  Despu√©s de los comandos Cx 1 IP7 +, este nuevo valor en la parte superior de la pila se convierte en la direcci√≥n del campo de par√°metro de la palabra ejecutable.  KBP9 transfiere el control a INEXT, sin ning√∫n truco, pasando a la siguiente palabra. <br><br><h4>  3.3.3 Manejadores constantes: DOCON y DOCONM </h4><br>  A diferencia de DOVAR, <i>el controlador constante</i> accede al campo de par√°metros de su propia palabra.  DOCON lee un valor constante de 16 bits.  Este valor siempre es positivo. <br><br><pre> <code class="plaintext hljs">DOCON: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + 9</code> </pre> <br>  Los comandos ‚áî KP3 ‚áî guardan RY en la pila de datos.  Pero esta vez, la parte superior de la pila de datos vuelve a RX.  Los comandos IP7 P5 lo obligan a regresar a RY, mientras preparan el registro de puntero R5 para leer el valor de la constante.  A continuaci√≥n, Cx 256 reemplaza la basura en el registro X con el n√∫mero 256. <br><br>  Los instrumentos KIP5 √ó KIP5 + leen una constante desde el campo de par√°metros hasta la parte superior de la pila de datos, es decir, en RX.  Como recordamos, en MK-161 el primer byte siempre es alto.  Se multiplica por 256, despu√©s de lo cual el byte menos significativo de la constante se agrega al producto.  Todo el trabajo est√° hecho, KBP9 transfiere el control a la siguiente palabra. <br><br>  DOCONM funciona exactamente de la misma manera, solo el signo constante despu√©s de leer cambia a lo opuesto.  Las constantes negativas se implementan en el MK-161 como un procesador separado en aras de la velocidad: <br><br><pre> <code class="plaintext hljs">DOCONM: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + /-/ 9</code> </pre> <br>  Ahora hemos descubierto completamente c√≥mo eForth ejecuta su c√≥digo en la electr√≥nica MK-161 desde el √°rea de datos, incluso tocando un tema m√°s profundo de los literales de cadena (ver 3.1.5). <br><br>  En el segundo art√≠culo de la serie, hablar√© sobre el int√©rprete externo de "texto" 161eForth, analizar√© la estructura de las tablas de encabezado y el reconocimiento de nombres.  Esta parte del traductor me exigi√≥ que desarrollara soluciones mucho m√°s radicales, en cuyo contexto lo mencionado anteriormente es el Fuerte tradicional, antiguo y bueno. <br><br>  ¬°Programaci√≥n Happy Fort! <br><br><h2>  Literatura </h2><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth and Zen - 3rd Edition, 2017. Disponible en Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Fuerte lenguaje y su implementaci√≥n.  - L .: Ingenier√≠a mec√°nica.  Leningrado  Departamento, 1988. </li><li>  Semenov Yu.A.  Programaci√≥n en el lenguaje FORT.  - M .: Radio y comunicaciones, 1991. </li><li>  ANS Cuarto est√°ndar.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Traducci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n SP-Forth</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Offete Store (Actas del Dr. Chen-Hanson Ting)</a> , donde puede descargar 86eForth v5.2 para Windows, documentaci√≥n en ingl√©s. </li></ol><br><br><h2>  Ilustraciones de video </h2><br>  Estos cuatro peque√±os videos 161eForth contin√∫an.  El primer video al comienzo del art√≠culo. <br><br>  Parte 2 de 5. Pruebas TEST-TEST4 del libro "eForth and Zen", tercera edici√≥n, en el MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7UuQSozjuJ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Parte 3 de 5. VER descompilador. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/K-mWJuL1fiQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Parte 4 de 5. Breakpoint BYE, terminal RS-232 y acceso remoto a MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Cfj60ICJrHU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Parte 5 de 5. Palabras finales. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oAAX29TpH9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452398/">https://habr.com/ru/post/452398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452384/index.html">El procesador acelerar√° la √≥ptica a 800 Gb / s: c√≥mo funciona</a></li>
<li><a href="../452388/index.html">Tamiz de Erat√≥stenes m√°s all√° de O (n). Prueba</a></li>
<li><a href="../452390/index.html">Radio definida por software: ¬øc√≥mo funciona? Parte 3</a></li>
<li><a href="../452392/index.html">Una selecci√≥n de conjuntos de datos de aprendizaje autom√°tico</a></li>
<li><a href="../452394/index.html">Opus sobre Su Majestad Clay. Segunda parte: ¬°Viva, cianoacrilato! Viva, superpegamento</a></li>
<li><a href="../452400/index.html">Negocio ineficaz</a></li>
<li><a href="../452402/index.html">Experimentos con un diodo de t√∫nel anal√≥gico</a></li>
<li><a href="../452404/index.html">Cinco tendencias clave de ITSM para este a√±o</a></li>
<li><a href="../452408/index.html">Ba√±o de Maine Coon</a></li>
<li><a href="../452410/index.html">Bash lanzamiento en detalle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>