<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèæ ü§òüèæ ü•å Jipes de v√≠deo de redimensionamento r√°pido üë¢ üëÇüèø üë∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em aplicativos para trabalhar com imagens, a tarefa de redimensionar jipes (imagens compactadas usando o algoritmo JPEG) √© bastante comum. Nesse caso,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jipes de v√≠deo de redimensionamento r√°pido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424575/">  Em aplicativos para trabalhar com imagens, a tarefa de redimensionar jipes (imagens compactadas usando o algoritmo JPEG) √© bastante comum.  Nesse caso, voc√™ n√£o pode redimensionar imediatamente e primeiro decodificar os dados originais.  N√£o h√° nada de novo e complicado nisso, mas se voc√™ precisar fazer isso muitos milh√µes de vezes por dia, √© particularmente importante otimizar o desempenho de uma solu√ß√£o desse tipo, que deve ser muito r√°pida. <br><br><img src="https://habrastorage.org/webt/ty/1c/gm/ty1cgmvqp5rt915vpx9whsdr5gw.jpeg"><br><a name="habracut"></a><br>  Esse problema costuma ser encontrado ao organizar a hospedagem remota para um reposit√≥rio de imagens, pois a maioria das c√¢meras e telefones filma no formato JPEG.  Todos os dias, os arquivos de fotos dos principais servi√ßos da Web (redes sociais, f√≥runs, hospedagem de fotos e muitos outros) s√£o reabastecidos com um n√∫mero significativo dessas imagens; portanto, a quest√£o de como armazenar essas imagens √© extremamente importante.  Para reduzir o tamanho do tr√°fego de sa√≠da e melhorar o tempo de resposta √† solicita√ß√£o de um usu√°rio, muitos servi√ßos da Web armazenam dezenas de arquivos para uma √∫nica imagem em diferentes resolu√ß√µes.  A velocidade de resposta √© boa, mas essas c√≥pias ocupam muito espa√ßo.  Esse √© um grande problema, embora haja outras desvantagens nessa abordagem. <br><br>  A id√©ia de resolver esse problema n√£o √© armazenar no servidor muitas op√ß√µes para a imagem original em diferentes resolu√ß√µes, mas criar dinamicamente a imagem desejada com as dimens√µes especificadas no original preparado anteriormente e o mais r√°pido poss√≠vel.  Assim, em tempo real, voc√™ pode criar uma imagem da resolu√ß√£o desejada e envi√°-la imediatamente ao usu√°rio.  √â muito importante que a resolu√ß√£o dessa imagem possa ser feita imediatamente para que o dispositivo do usu√°rio n√£o redimensione a tela, pois isso simplesmente n√£o ser√° necess√°rio. <br><br>  Usar formatos diferentes do JPEG como base para organizar esse reposit√≥rio de imagens n√£o parece justificado.  Obviamente, existem formatos padr√£o e amplamente usados ‚Äã‚Äãque oferecem melhor compacta√ß√£o com a mesma qualidade (JPEG2000, WebP), mas a velocidade de codifica√ß√£o e decodifica√ß√£o dessas imagens √© muito baixa em compara√ß√£o com o JPEG; portanto, faz sentido escolher o JPEG como o formato base para armazenar fotos originais, que, se necess√°rio, ser√° dimensionado em tempo real ap√≥s o recebimento de uma solicita√ß√£o do usu√°rio. <br><br>  Obviamente, al√©m dos jipes, cada site costuma ter imagens PNG e GIF, mas geralmente seu n√∫mero relativo √© pequeno e as fotos nesses formatos s√£o extremamente raras.  Portanto, esses formatos n√£o ter√£o um impacto significativo na tarefa em quest√£o na maioria dos casos. <br><br><h2>  Descri√ß√£o do algoritmo de redimensionamento em tempo real </h2><br>  Portanto, os dados de entrada s√£o arquivos JPEG e, para obter uma decodifica√ß√£o r√°pida (isso √© verdade tanto para a CPU quanto para a GPU), as imagens compactadas devem ter marcadores de reinicializa√ß√£o embutidos.  Esses marcadores s√£o descritos no padr√£o JPEG e parte dos codecs pode trabalhar com eles; os demais sabem como n√£o not√°-los.  Se os jipes n√£o tiverem esses marcadores, eles poder√£o ser adicionados antecipadamente usando o utilit√°rio jpegtran.  Quando marcadores s√£o adicionados, a imagem n√£o muda, mas o tamanho do arquivo se torna um pouco maior.  Como resultado, obtemos o seguinte esquema de trabalho: <br><br><ol><li>  Obter dados de imagem da mem√≥ria da CPU </li><li>  Se houver um perfil de cores, obtenha-o na se√ß√£o EXIF ‚Äã‚Äãe salve </li><li>  Copie a imagem para a placa de v√≠deo </li><li>  Decodificar JPEG </li><li>  Fazemos um redimensionamento de acordo com o algoritmo de Lanczos (diminui√ß√£o) </li><li>  Nitidez </li><li>  Codificamos a imagem usando JPEG </li><li>  Copiar imagem para o host </li><li>  Adicione o perfil de cores original ao arquivo resultante. </li></ol><br>  Voc√™ pode tomar uma decis√£o mais precisa quando, antes do redimensionamento, a gama inversa √© sobreposta em cada componente do pixel, para que o redimensionamento fique no espa√ßo linear e, em seguida, a gama √© aplicada novamente, mas ap√≥s o sharpe.  A diferen√ßa real para o usu√°rio √© pequena, mas existe, e o custo computacional para essa modifica√ß√£o √© m√≠nimo.  √â apenas necess√°rio inserir a superposi√ß√£o da gama inversa e direta no esquema de processamento geral. <br><br>  Tamb√©m existe uma solu√ß√£o poss√≠vel quando a decodifica√ß√£o de jipes √© executada em uma CPU multin√∫cleo usando a biblioteca libjpeg-turbo.  Nesse caso, cada imagem √© decodificada em um fluxo de CPU separado e todas as outras a√ß√µes s√£o executadas na placa de v√≠deo.  Com um grande n√∫mero de n√∫cleos de CPU, isso pode acontecer ainda mais rapidamente, mas haver√° uma s√©ria perda de lat√™ncia.  Se a lat√™ncia ao decodificar um jipe ‚Äã‚Äãem um √∫nico n√∫cleo da CPU for aceit√°vel, essa op√ß√£o poder√° ser muito r√°pida, especialmente no caso em que os jipes originais tenham uma resolu√ß√£o pequena.  √Ä medida que a resolu√ß√£o da imagem original aumenta, o tempo de decodifica√ß√£o do jipe ‚Äã‚Äãem um fluxo da CPU aumenta, portanto essa op√ß√£o pode ser adequada apenas para pequenas resolu√ß√µes. <br><br><h2>  Requisitos b√°sicos para a tarefa de redimensionamento da web </h2><br><ul><li>  √â aconselh√°vel n√£o armazenar dezenas de c√≥pias de cada imagem em diferentes resolu√ß√µes no servidor, mas criar rapidamente a imagem desejada com a resolu√ß√£o correta imediatamente ap√≥s o recebimento da solicita√ß√£o.  Isso √© importante para reduzir o tamanho do armazenamento, caso contr√°rio voc√™ ter√° que armazenar muitas c√≥pias diferentes de cada imagem. </li><li>  O problema deve ser resolvido o mais r√°pido poss√≠vel.  Esta √© uma pergunta sobre a qualidade do servi√ßo fornecido em termos de redu√ß√£o do tempo de resposta a uma solicita√ß√£o do usu√°rio. </li><li>  A qualidade da imagem enviada deve ser alta. </li><li>  O tamanho do arquivo para a imagem enviada deve ser o menor poss√≠vel e sua resolu√ß√£o deve corresponder exatamente ao tamanho da janela em que aparece.  Os seguintes pontos s√£o importantes aqui: </li></ul><br>  a) Se o tamanho da imagem n√£o corresponder ao tamanho da janela, o dispositivo do usu√°rio (telefone, tablet, laptop) redimensionar√° o hardware ap√≥s a decodifica√ß√£o antes de exibir a imagem na tela.  No OpenGL, esse redimensionamento de hardware √© feito apenas de acordo com o algoritmo bilinear, que geralmente causa o aparecimento de moir√© (manchas) e outros artefatos em imagens contendo pequenos detalhes. <br><br>  b) O redimensionamento da tela consome adicionalmente energia do dispositivo. <br><br>  c) Se voc√™ usar uma s√©rie de imagens pr√©-dimensionadas para resolver o problema, nem sempre √© poss√≠vel obter o tamanho exato, o que significa que voc√™ precisar√° enviar uma imagem com uma resolu√ß√£o mais alta.  O aumento do tamanho da imagem gera mais tr√°fego, o que eu tamb√©m gostaria de evitar. <br><br><h2>  Descri√ß√£o do esquema geral de trabalho </h2><br><ol><li>  Recebemos imagens de usu√°rios em qualquer formato e resolu√ß√£o.  Os originais s√£o armazenados em um banco de dados separado (se necess√°rio). </li><li>  Off-line, usando o ImageMagick ou software similar, salve o perfil de cores, converta as imagens originais originais no formato BMP ou PPM padr√£o, redimensione para resolu√ß√£o 1K ou 2K e comprima-as para JPEG e adicione marcadores de reinicializa√ß√£o com o intervalo fixo especificado usando o utilit√°rio jpegtran. </li><li>  Compomos um banco de dados com essas imagens de 1K ou 2K. </li><li>  Ap√≥s o recebimento de uma solicita√ß√£o do usu√°rio, obtemos informa√ß√µes sobre a imagem e o tamanho da janela em que essa imagem deve ser exibida. </li><li>  Encontramos a imagem no banco de dados e a enviamos para o redimensionador. </li><li>  O redimensionador recebe o arquivo de imagem, decodifica, redimensiona, afia, codifica e insere o perfil de cores original no jipe ‚Äã‚Äãresultante.  Depois disso, ele fornece a imagem para um programa externo. </li><li>  Em cada placa de v√≠deo, voc√™ pode executar v√°rios threads e instalar v√°rias placas de v√≠deo no seu computador - alcan√ßando, assim, a escala de desempenho. </li><li>  Tudo isso pode ser feito com base nas placas de v√≠deo NVIDIA Tesla (por exemplo, P40 ou V100), j√° que as placas de v√≠deo NVIDIA GeForce n√£o foram projetadas para opera√ß√£o cont√≠nua a longo prazo, e a NVIDIA Quadro possui muitas sa√≠das de v√≠deo que n√£o s√£o necess√°rias neste caso.  Para resolver esse problema, os requisitos para o tamanho da mem√≥ria da GPU s√£o m√≠nimos. </li><li>  Al√©m disso, no banco de dados com imagens preparadas, voc√™ pode alocar dinamicamente um cache para arquivos usados ‚Äã‚Äãcom freq√º√™ncia.  L√°, faz sentido armazenar imagens usadas com frequ√™ncia de acordo com as estat√≠sticas do per√≠odo anterior. </li></ol><br><img src="https://habrastorage.org/webt/po/zo/tq/pozotq70cgopg1_g3wvqd8wyzis.jpeg"><br><br><h2>  Par√¢metros do programa </h2><br><ol><li>  Largura e altura da nova imagem.  Eles podem ser qualquer um e √© melhor defini-los explicitamente. </li><li>  Modo de afinamento JPEG (subamostragem).  Existem tr√™s op√ß√µes: 4: 2: 0, 4: 2: 2 e 4: 4: 4, mas eles geralmente usam 4: 4: 4 ou 4: 2: 0.  A qualidade m√°xima √© 4: 4: 4, o tamanho m√≠nimo de quadro √© 4: 2: 0.  O afinamento √© feito para componentes de diferen√ßa de cor, que a vis√£o de uma pessoa n√£o percebe, assim como a lumin√¢ncia.  Cada modo de dizima√ß√£o possui seu pr√≥prio intervalo ideal para os marcadores de reinicializa√ß√£o atingirem a velocidade m√°xima de codifica√ß√£o ou decodifica√ß√£o. </li><li>  Qualidade de compress√£o JPEG e modo de dizima√ß√£o ao criar um banco de dados de imagens. </li><li>  O Sharp √© feito em uma janela 3x3, o sigma (raio) pode ser controlado. </li><li>  Qualidade de compress√£o JPEG e modo de dizima√ß√£o ao codificar a imagem final.  Normalmente, uma qualidade de pelo menos 90% significa que essa compress√£o √© "visualmente sem perdas", ou seja,  usu√°rios n√£o treinados n√£o devem ver artefatos do algoritmo JPEG sob condi√ß√µes de exibi√ß√£o padr√£o.  Acredita-se que, para um usu√°rio treinado, 93 a 95% sejam necess√°rios.  Quanto maior esse valor, maior o tamanho do quadro enviado ao usu√°rio e maior o tempo de decodifica√ß√£o e codifica√ß√£o. </li></ol><br><h2>  Limita√ß√µes importantes </h2><br>  Reinicie os marcadores.  Podemos decodificar rapidamente imagens JPEG em uma placa de v√≠deo somente se houver marcadores de reinicializa√ß√£o dentro dela.  No padr√£o oficial do JPEG, esses marcadores s√£o descritos, este √© um par√¢metro padr√£o.  Se n√£o houver marcadores de reinicializa√ß√£o, √© imposs√≠vel paralelizar a decodifica√ß√£o da imagem na placa de v√≠deo, o que levar√° a uma velocidade muito baixa do decodificador.  Portanto, precisamos de um banco de dados de imagens preparadas nas quais existem esses marcadores. <br><br>  Algoritmo fixo para codec de imagem.  Decodificar e codificar imagens usando o algoritmo JPEG √© de longe a op√ß√£o mais r√°pida. <br><br>  A resolu√ß√£o das imagens no banco de dados preparado pode ser qualquer, mas, como op√ß√µes, consideraremos 1K e 2K (voc√™ pode fazer 4K).  Voc√™ tamb√©m pode fazer n√£o apenas uma diminui√ß√£o, mas tamb√©m um aumento nas imagens ao redimensionar. <br><br><h2>  Desempenho de redimensionamento r√°pido </h2><br>  Testamos o aplicativo para redimensionamento r√°pido do Fastvideo SDK na placa de v√≠deo NVIDIA Tesla V100 (SO Windows Server 2016, 64 bits, driver 24.21.13.9826) em imagens de 24 bits 1k_wild.ppm e 2k_wild.ppm com resolu√ß√£o de 1K e 2K (1280x720 e 1920 x 1080).  Os testes foram realizados para um n√∫mero diferente de threads em execu√ß√£o na mesma placa de v√≠deo.  Isso requer n√£o mais que 110 MB de mem√≥ria na placa de v√≠deo por fluxo.  4 fluxos n√£o precisam mais do que 440 MB. <br><br>  Primeiro, compactamos a imagem original em JPEG com 90% de qualidade, com redu√ß√£o de 4: 2: 0 ou 4: 4: 4.  Em seguida, decodificamos e redimensionamos 2 vezes em largura e altura, fazemos uma nitidez e, em seguida, codificamos novamente com 90% de qualidade em 4: 2: 0 ou 4: 4: 4.  Os dados de origem est√£o na RAM, a imagem final √© colocada l√°. <br><br>  O tempo de opera√ß√£o √© contado desde o in√≠cio do carregamento da imagem original da RAM para salvar a imagem processada na RAM.  O tempo de inicializa√ß√£o do programa e a aloca√ß√£o de mem√≥ria na placa de v√≠deo n√£o est√£o inclu√≠dos nas medi√ß√µes. <br><br>  Exemplo de linha de comando para uma imagem 1K de 24 bits <br>  PhotoHostingSample.exe -i 1k_wild.90.444.jpg -o 1k_wild.640.jpg -outputWidth 640 -q 90 -s 444 -sharp_after 0.95 -repeti√ß√£o 200 <br><br><h4>  Refer√™ncia para processar uma imagem 1K em uma thread </h4><br>  Decodifica√ß√£o (incluindo transfer√™ncia de dados para a placa de v√≠deo): 0,70 ms <br>  Redimensionar duas vezes (em largura e altura): 0,27 ms <br>  N√≠tido: 0,02 ms <br>  Codifica√ß√£o JPEG (incluindo transfer√™ncia de dados da placa de v√≠deo): 0,20 ms <br>  <b>Tempo total por quadro: 1,2 ms</b> <br><br><h2>  Desempenho para 1K </h2><br><table border="1"><tbody><tr><td></td><td>  Qualidade </td><td>  Dilui√ß√£o </td><td>  Redimensionar </td><td>  Streams </td><td align="center">  Taxa de quadros (Hz) </td></tr><tr><td>  1 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 vezes </td><td>  1 </td><td align="center">  868/682 </td></tr><tr><td>  2 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 vezes </td><td>  2 </td><td align="center">  <strong>1039/790</strong> </td></tr><tr><td>  3 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 vezes </td><td>  3 </td><td align="center">  <strong>993/831</strong> </td></tr><tr><td>  4 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 vezes </td><td>  4 </td><td align="center">  1003/740 </td></tr></tbody></table><br><br><h2>  Desempenho para 2K </h2><br><table border="1"><tbody><tr><td></td><td>  Qualidade </td><td>  Dilui√ß√£o </td><td>  Redimensionar </td><td>  Streams </td><td align="center">  Taxa de quadros (Hz) </td></tr><tr><td>  1 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 vezes </td><td>  1 </td><td align="center">  732/643 </td></tr><tr><td>  2 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 vezes </td><td>  2 </td><td align="center">  913/762 </td></tr><tr><td>  3 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 vezes </td><td>  3 </td><td align="center">  891/742 </td></tr><tr><td>  4 </td><td>  90% </td><td>  4: 4: 4/4: 2: 0 </td><td>  2 vezes </td><td>  4 </td><td align="center">  <strong>923/763</strong> </td></tr></tbody></table><br><br>  A dilui√ß√£o de 4: 2: 0 para a imagem de origem reduz a velocidade, mas o tamanho dos arquivos de origem e de destino fica menor.  Ao alternar para 4: 2: 0, o grau de paralelismo diminui 4 vezes, j√° que agora o bloco 16x16 √© considerado como uma √∫nica unidade, portanto, nesse modo, a velocidade √© menor que para 4: 4: 4. <br><br>  O desempenho √© determinado principalmente pelo est√°gio de decodifica√ß√£o JPEG, porque nesse est√°gio a imagem possui a resolu√ß√£o m√°xima e a complexidade computacional desse est√°gio de processamento √© superior a todas as outras. <br><br><h2>  Sum√°rio </h2><br>  Os resultados do teste mostraram que, para a placa de v√≠deo NVIDIA Tesla V100, a velocidade de processamento de imagens de 1K e 2K √© m√°xima quando 2-4 fluxos s√£o lan√ßados ao mesmo tempo e varia de 800 a 1000 quadros por segundo por placa de v√≠deo.  O processamento de imagens 1K √© mais r√°pido que 2K e o trabalho com imagens 4: 2: 0 √© sempre mais lento que com 4: 4: 4.  Para obter o resultado final do desempenho, voc√™ precisa determinar com precis√£o todos os par√¢metros do programa e otimiz√°-lo para um modelo espec√≠fico da placa de v√≠deo. <br><br>  A lat√™ncia da ordem de um milissegundo √© um bom resultado.  At√© onde sabemos, essa lat√™ncia n√£o pode ser obtida para uma tarefa de redimensionamento semelhante na CPU (mesmo que n√£o seja necess√°rio codificar e decodificar jipes), ent√£o esse √© outro argumento importante a favor do uso de placas de v√≠deo em solu√ß√µes de processamento de imagem de alto desempenho. <br><br>  Podem ser necess√°rias at√© 16 placas gr√°ficas NVIDIA Tesla V100 para processar um bilh√£o de jipes por dia com resolu√ß√µes de 1K ou 2K.  Alguns de nossos clientes j√° usam essa solu√ß√£o, enquanto outros a testam em suas tarefas. <br><br>  Redimensionar jipes em uma placa de v√≠deo pode ser muito √∫til, n√£o apenas para servi√ßos da web.  H√° um grande n√∫mero de aplicativos de processamento de imagem de alto desempenho em que essa funcionalidade pode estar em demanda.  Por exemplo, muitas vezes √© necess√°rio um redimensionamento r√°pido para quase qualquer esquema de processamento de imagens recebidas das c√¢meras antes de exibir uma imagem em um monitor.  Esta solu√ß√£o pode funcionar para Windows / Linux em qualquer placa de v√≠deo NVIDIA: Tegra K1 / X1 / X2 / Xavier, GeForce GT / GTX / RTX, Quadro, Tesla. <br><br><h2>  Vantagens de uma solu√ß√£o de redimensionamento r√°pido em uma placa gr√°fica </h2><br><ul><li>  Redu√ß√£o significativa no tamanho do armazenamento para imagens de origem </li><li>  Reduzindo os custos prim√°rios dos custos de infraestrutura (hardware e software) </li><li>  Melhorando a qualidade do servi√ßo devido ao curto tempo de resposta </li><li>  Redu√ß√£o de tr√°fego de sa√≠da </li><li>  Menor consumo de energia nos dispositivos do usu√°rio </li><li>  Confiabilidade e velocidade da solu√ß√£o apresentada, que j√° foi testada em grandes conjuntos de dados </li><li>  Tempo de desenvolvimento reduzido para comercializar esses aplicativos para Linux e Windows </li><li>  Escalabilidade de uma solu√ß√£o que pode funcionar em uma √∫nica placa de v√≠deo e como parte de um cluster </li><li>  R√°pido retorno do investimento para esses projetos </li></ul><br><h2>  Quem pode estar interessado </h2><br>  A biblioteca para redimensionamento r√°pido de jipes pode ser usada em servi√ßos da Web altamente carregados, grandes lojas online, redes sociais, sistemas de gerenciamento de fotos on-line, com√©rcio eletr√¥nico, em quase todos os grandes softwares de gerenciamento corporativo. <br><br>  Os desenvolvedores de software podem usar essa biblioteca, que fornece lat√™ncia da ordem de v√°rios milissegundos para redimensionar jipes com uma resolu√ß√£o de 1K, 2K e 4K em uma placa de v√≠deo. <br><br>  Aparentemente, essa abordagem pode ser mais r√°pida que a solu√ß√£o NVIDIA DALI para decodifica√ß√£o r√°pida de jipes, redimensionamento e prepara√ß√£o de imagens no est√°gio de treinamento de redes neurais para o Deep Learning. <br><br><h2>  O que mais pode ser feito </h2><br><ul><li>  Al√©m de redimensionar e afiar, voc√™ pode adicionar recorte ao algoritmo existente, girar 90/180/270, aplicar uma marca d'√°gua, controlar o brilho e o contraste. </li><li>  Otimiza√ß√£o da solu√ß√£o para placas de v√≠deo NVIDIA Tesla P40 e V100. </li><li>  Desempenho de otimiza√ß√£o adicional decodificador JPEG. </li><li>  Modo Burst para decodificar jipes em uma placa de v√≠deo. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424575/">https://habr.com/ru/post/pt424575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424565/index.html">Vis√£o geral: digitaliza√ß√£o 3D de instala√ß√µes imobili√°rias</a></li>
<li><a href="../pt424567/index.html">A experi√™ncia de bloquear a publicidade on-line na rede local da empresa</a></li>
<li><a href="../pt424569/index.html">Contrata√ß√£o de programadores. Dicas para programadores</a></li>
<li><a href="../pt424571/index.html">Corporate Das Experiment</a></li>
<li><a href="../pt424573/index.html">Vida e morte das mitoc√¥ndrias</a></li>
<li><a href="../pt424577/index.html">JUG.EKB: mesclando usando mitaps de desenvolvedor Java</a></li>
<li><a href="../pt424579/index.html">N√£o caia na armadilha usando o Oracle JDK 11</a></li>
<li><a href="../pt424581/index.html">Quer ganhar uma corrida de her√≥is? Obtenha uma receita da LANIT</a></li>
<li><a href="../pt424583/index.html">Voc√™ n√£o se tornar√° um her√≥i se for um desenvolvedor</a></li>
<li><a href="../pt424585/index.html">CryEngine 5.5 lan√ßado pela Crytek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>