<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è© üë©üèæ‚Äçü§ù‚Äçüë®üèª üë©üèª‚Äçüç≥ Quadrantenb√§ume und Kollisionserkennung üë©‚Äçüéì üà≥ üßòüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Woche war kurz, am Montag und Dienstag arbeitete ich weiter an einem 2D-Beleuchtungssystem . Den Rest der Zeit habe ich mit der Implementierung ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quadrantenb√§ume und Kollisionserkennung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473066/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/237/20a/59e23720a19b3109d80e62c6d2d539a0.gif" alt="Bild"></div><br>  Diese Woche war kurz, am Montag und Dienstag arbeitete ich weiter an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem 2D-Beleuchtungssystem</a> .  Den Rest der Zeit habe ich mit der Implementierung von Quadtree-B√§umen verbracht. <br><br>  In diesem Artikel werde ich meine Implementierung und Gedanken teilen, die w√§hrend des Entwurfs entstanden sind. <br><br>  Zun√§chst muss ich sagen, warum ich mich entschieden habe, einen Quadrantenbaum zu implementieren. <br><br>  Quadtree ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Space-Partition-Datenstruktur</a> .  Der Hauptvorteil gegen√ºber anderen Datenstrukturen ist die Anpassungsf√§higkeit.  Es bietet eine gute Leistung beim Einf√ºgen, L√∂schen und Suchen.  Das hei√üt, wir k√∂nnen diesen Baum in einem dynamischen Kontext verwenden, in dem sich Daten h√§ufig √§ndern.  Dar√ºber hinaus ist diese Struktur recht einfach zu verstehen und zu implementieren. <br><br>  Wenn die Speicherpartitionierung ein neues Thema f√ºr Sie ist, empfehle ich, diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von</a> Robert Nistrom zu lesen.  Wenn Sie mehr √ºber Quadrantenb√§ume erfahren m√∂chten, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> Artikel. <br><a name="habracut"></a><br>  Es gibt Bereiche in meinem Spiel, in denen sich die Verwendung von Quadtree sofort auszahlt: <br><br><ul><li>  Bei der Erkennung von Kollisionen ist der Quadrantenbaum viel effizienter als die Brute-Force-Methode (Testen aller Paare).  Dies ist jedoch nicht der effektivste Ansatz. In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> kann ein √úberblick √ºber verschiedene Techniken und Benchmarks gegeben werden.  F√ºr die erste Version meiner Physik-Engine verwende ich sie jedoch.  Vielleicht werde ich sp√§ter, falls n√∂tig, einen spezielleren Algorithmus w√§hlen. </li><li>  Im Szenendiagramm kann ich beim Ausschneiden mit quadtree nach allen sichtbaren Knoten suchen. </li><li>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Beleuchtungssystem k√∂nnen</a> Sie mit quadtree W√§nde finden, die das Polygon der Sichtbarkeit der Lichtquelle schneiden. </li><li>  Im KI-System k√∂nnen Sie mit quadtree nach allen Objekten oder Feinden suchen, die der Essenz nahe stehen. </li><li>  Usw... </li></ul><br>  Wie Sie sehen k√∂nnen, sind Quadrantenb√§ume ziemlich vielseitig.  Sie sind eine gute Erg√§nzung in Ihrem Toolkit. <br><br>  Der gesamte im Artikel gezeigte Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> zu finden. <br><br><h1>  Vorbereitende Vorbereitung </h1><br>  Bevor wir den Quadtree-Code detaillieren, ben√∂tigen wir kleine Klassen f√ºr geometrische <code>Vector2</code> : die <code>Vector2</code> Klasse zum Definieren von Punkten und die <code>Box</code> Klasse zum Definieren von Rechtecken.  Beide werden Boilerplate sein. <br><br><h2>  Vektor2 </h2><br>  Die <a href=""><code>Vector2</code></a> Klasse <a href=""><code>Vector2</code></a> minimalistisch.  Es enth√§lt nur Konstruktoren sowie <code>+</code> und <code>/</code> Operatoren.  Das ist alles was wir brauchen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T x; T y; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;(TX = <span class="hljs-number"><span class="hljs-number">0</span></span>, TY = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : x(X), y(Y) { } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x += other.x; y += other.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/=(T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x /= t; y /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vector2&lt;T&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { lhs += rhs; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/(Vector2&lt;T&gt; vec, T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { vec /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec; }</code> </pre> <br><h2>  Box </h2><br>  Die <a href=""><code>Box</code></a> Klasse ist nicht viel komplizierter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T left; T top; T width; <span class="hljs-comment"><span class="hljs-comment">// Must be positive T height; // Must be positive constexpr Box(T Left = 0, T Top = 0, T Width = 0, T Height = 0) noexcept : left(Left), top(Top), width(Width), height(Height) { } constexpr Box(const Vector2&lt;T&gt;&amp; position, const Vector2&lt;T&gt;&amp; size) noexcept : left(position.x), top(position.y), width(size.x), height(size.y) { } constexpr T getRight() const noexcept { return left + width; } constexpr T getBottom() const noexcept { return top + height; } constexpr Vector2&lt;T&gt; getTopLeft() const noexcept { return Vector2&lt;T&gt;(left, top); } constexpr Vector2&lt;T&gt; getCenter() const noexcept { return Vector2&lt;T&gt;(left + width / 2, top + height / 2); } constexpr Vector2&lt;T&gt; getSize() const noexcept { return Vector2&lt;T&gt;(width, height); } constexpr bool contains(const Box&lt;T&gt;&amp; box) const noexcept { return left &lt;= box.left &amp;&amp; box.getRight() &lt;= getRight() &amp;&amp; top &lt;= box.top &amp;&amp; box.getBottom() &lt;= getBottom(); } constexpr bool intersects(const Box&lt;T&gt;&amp; box) const noexcept { return !(left &gt;= box.getRight() || getRight() &lt;= box.left || top &gt;= box.getBottom() || getBottom() &lt;= box.top); } };</span></span></code> </pre> <br>  Es enth√§lt einige n√ºtzliche Getter. <br><br>  Interessanter ist, dass es die Methode enth√§lt enth√§lt, die pr√ºft, ob sich das Rechteck in einem anderen befindet, und die Methode <code>intersects</code> , die pr√ºft, ob sich das Rechteck mit einem anderen schneidet. <br><br>  Wir werden beim Einf√ºgen und L√∂schen Includes verwenden und beim Erkennen von Schnittpunkten √ºberschneiden. <br><br><h1>  Quadtree </h1><br>  Hier ist das <a href=""><code>Quadtree</code></a> der <a href=""><code>Quadtree</code></a> Klasse: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GetBox, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Equal = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::equal_to&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Float = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; class Quadtree { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;GetBox, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, Box&lt;Float&gt;&gt;, <span class="hljs-string"><span class="hljs-string">"GetBox must be a callable of signature Box&lt;Float&gt;(const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Equal, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;, <span class="hljs-string"><span class="hljs-string">"Equal must be a callable of signature bool(const T&amp;, const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt;Float&gt;); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Quadtree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GetBox&amp; getBox = GetBox(), <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Equal&amp; equal = Equal()) : mBox(box), mRoot(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Node&gt;()), mGetBox(getBox), mEqual(equal) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Threshold = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> MaxDepth = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt;, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; children; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; values; }; Box&lt;Float&gt; mBox; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt; mRoot; GetBox mGetBox; Equal mEqual; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLeaf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Node* node)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(node-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } };</code> </pre> <br>  Wie Sie sehen k√∂nnen, ist <code>Quadtree</code> eine Vorlagenklasse.  Auf diese Weise k√∂nnen wir die Klasse f√ºr verschiedene Zwecke verwenden, √ºber die ich zu Beginn gesprochen habe. <br><br>  Vorlagenoptionen: <br><br><ul><li>  <code>T</code> : Die Art der Werte, die in quadtree enthalten sein werden.  <code>T</code> sollte eine einfache Klasse sein, da sie in einem Quadtree gespeichert wird.  Idealerweise sollte dies ein Zeiger oder eine kleine einfache Datenstruktur (POD) sein. </li><li>  <code>GetBox</code> : Der Typ des aufgerufenen Objekts, der den Wert an der Eingabe empf√§ngt und ein Rechteck <code>GetBox</code> . </li><li>  <code>Equal</code> : Der Typ des aufgerufenen Objekts, um zu √ºberpr√ºfen, ob zwei Werte gleich sind.  Standardm√§√üig verwenden wir den Standard-Gleichheitsoperator. </li><li>  <code>Float</code> : Der in Berechnungen verwendete arithmetische Typ.  Standardm√§√üig verwenden wir <code>float</code> . </li></ul><br>  Zu Beginn der Klassendefinition gibt es drei statische Zusicherungen zum √úberpr√ºfen der G√ºltigkeit der Vorlagenparameter. <br><br>  Werfen wir einen Blick auf die Definition eines Knotens.  Ein Knoten speichert einfach Zeiger auf seine vier untergeordneten Knoten und eine Liste der darin enthaltenen Werte.  Wir speichern darin weder den Begrenzungsrahmen noch die Tiefe, sie werden im laufenden Betrieb berechnet. <br><br>  Ich f√ºhrte Benchmarks f√ºr beide Ans√§tze durch (Beibehalten eines Rechtecks ‚Äã‚Äãmit Tiefe und ohne Beibehalten) und stellte bei der Berechnung im laufenden Betrieb keine Leistungseinbu√üen fest.  Au√üerdem spart es ein wenig Speicher. <br><br>  Um einen internen Knoten von einem Blatt unterscheiden zu k√∂nnen, <code>isLeaf</code> die Methode <code>isLeaf</code> .  Es wird nur √ºberpr√ºft, ob das erste Kind nicht null ist.  Da null entweder alle untergeordneten Knoten oder keiner von ihnen sind, reicht es aus, nur den ersten zu √ºberpr√ºfen. <br><br>  Jetzt k√∂nnen wir uns die <code>Quadtree</code> Mitgliedsvariablen <code>Quadtree</code> : <br><br><ul><li>  <code>mBox</code> ist ein globaler Begrenzungsrahmen.  Alle in quadtree eingef√ºgten Werte m√ºssen darin enthalten sein. </li><li>  <code>mRoot</code> ist die Wurzel von quadtree. </li><li>  <code>mGetBox</code> ist das aufgerufene Objekt, mit dem wir das Rechteck aus dem Wert <code>mGetBox</code> . </li><li>  <code>mEqual</code> ist das aufgerufene Objekt, mit dem wir die Gleichheit der beiden Werte √ºberpr√ºfen. </li></ul><br>  Der Konstruktor setzt einfach <code>mBox</code> , <code>mGetBox</code> und <code>mEqual</code> und erstellt auch einen Wurzelknoten. <br><br>  Die letzten beiden Parameter, √ºber die wir noch nicht gesprochen haben, sind <code>Threshold</code> und <code>MaxDepth</code> .  <code>Threshold</code> ist die maximale Anzahl von Werten, die ein Knoten enthalten kann, bevor wir ihn teilen.  <code>MaxDepth</code> ist die maximale Tiefe eines Knotens. Wir versuchen nicht mehr, die Knoten in <code>MaxDepth</code> zu <code>MaxDepth</code> . Wenn Sie zu viel teilen, kann dies die Leistung beeintr√§chtigen.  Ich habe diesen Konstanten vern√ºnftige Werte gegeben, die f√ºr die meisten F√§lle geeignet sind.  Sie k√∂nnen versuchen, sie f√ºr Ihre Konfiguration zu optimieren. <br><br>  Jetzt sind wir bereit, weitere interessante Operationen zu starten. <br><br><h1>  Einf√ºgen und l√∂schen </h1><br>  Bevor ich den Einf√ºgecode zeige, m√ºssen wir diskutieren, welche Knoten die Werte enthalten.  Es gibt zwei Strategien: <br><br><ul><li>  Werte werden nur in Bl√§ttern gespeichert.  Da der Begrenzungsrahmen eines Werts mit mehreren Bl√§ttern interagieren kann, wird der Wert in allen diesen Bl√§ttern gespeichert. </li><li>  Werte k√∂nnen in allen Knoten gespeichert werden.  Wir speichern den Wert im kleinsten Knoten, der seinen Begrenzungsrahmen vollst√§ndig enth√§lt. </li></ul><br>  Wenn die Begrenzungsrechtecke klein und ungef√§hr gleich gro√ü sind, ist die erste Strategie bei der Suche nach Schnittpunkten effektiver.  Wenn jedoch gro√üe Rechtecke vorhanden sind, k√∂nnen entartete F√§lle auftreten, in denen die Leistung sehr schlecht ist.  Wenn wir beispielsweise einen Wert einf√ºgen, dessen Rechteck sich im globalen Begrenzungsrahmen befindet, wird er allen Bl√§ttern hinzugef√ºgt.  Wenn wir einen <code>Threshold</code> f√ºr solche Werte einf√ºgen, werden alle Knoten geteilt, bis <code>MaxDepth</code> erreicht ist und die Werte nicht in allen Bl√§ttern enthalten sind.  Daher wird quadtree enthalten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="37.45ex" height="2.539ex" viewBox="0 -987.6 16124.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="611" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-78" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="1650" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="2012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="2373" y="0"></use><g transform="translate(2735,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-54" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-68" x="704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-72" x="1281" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="1732" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-73" x="2199" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-68" x="2668" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-6F" x="3245" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-6C" x="3730" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-64" x="4029" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="7537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-69" x="7899" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-6D" x="8244" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="9123" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-73" x="9589" y="0"></use><g transform="translate(10059,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMAIN-34" x="0" y="0"></use><g transform="translate(500,404)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="715" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-78" x="1181" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="1754" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="2115" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="2477" y="0"></use><g transform="translate(2007,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-4D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-61" x="1051" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-78" x="1581" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-44" x="2153" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="2982" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-70" x="3448" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="3952" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-68" x="4313" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&nbsp;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ texttt {Threshold} \ times 4 ^ {\ texttt {MaxDepth}} </script>  Werte, und das ist ... viel. <br><br>  Dar√ºber hinaus ist das Einf√ºgen und L√∂schen bei der ersten Strategie etwas langsamer, da alle Knoten, die den Wert schneiden, eingef√ºgt (oder gel√∂scht) werden m√ºssen. <br><br>  Daher werde ich die zweite Strategie anwenden, bei der es keine entarteten F√§lle gibt.  Da ich Quadtree in verschiedenen Kontexten verwenden m√∂chte, ist dies bequemer.  Dar√ºber hinaus eignet sich diese Strategie besser f√ºr dynamische Kontexte, in denen viele Einf√ºgungen und L√∂schungen durchgef√ºhrt werden, um Werte zu aktualisieren, z. B. in einer physischen Engine, in der Entit√§ten verschoben werden. <br><br>  Um herauszufinden, in welchen Knoten wir einen Wert einf√ºgen oder l√∂schen, verwenden wir zwei Hilfsfunktionen. <br><br>  Die erste, <code>computeBox</code> , berechnet das Rechteck des <code>computeBox</code> Knotens anhand des Rechtecks ‚Äã‚Äãdes √ºbergeordneten Knotens und des Index seines Quadranten. <br><br><pre> <code class="cpp hljs">Box&lt;Float&gt; computeBox(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> origin = box.getTopLeft(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childSize = box.getSize() / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Float&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-comment"><span class="hljs-comment">// North West case 0: return Box&lt;Float&gt;(origin, childSize); // Norst East case 1: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x + childSize.x, origin.y), childSize); // South West case 2: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x, origin.y + childSize.y), childSize); // South East case 3: return Box&lt;Float&gt;(origin + childSize, childSize); default: assert(false &amp;&amp; "Invalid child index"); return Box&lt;Float&gt;(); } }</span></span></code> </pre> <br>  Der zweite, <code>getQuadrant</code> , gibt den Quadranten zur√ºck, in dem sich der Wert befindet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getQuadrant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; nodeBox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; valueBox)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> center = nodeBox.getCenter(); <span class="hljs-comment"><span class="hljs-comment">// West if (valueBox.getRight() &lt; center.x) { // North West if (valueBox.getBottom() &lt; center.y) return 0; // South West else if (valueBox.top &gt;= center.y) return 2; // Not contained in any quadrant else return -1; } // East else if (valueBox.left &gt;= center.x) { // North East if (valueBox.getBottom() &lt; center.y) return 1; // South East else if (valueBox.top &gt;= center.y) return 3; // Not contained in any quadrant else return -1; } // Not contained in any quadrant else return -1; }</span></span></code> </pre> <br>  Es gibt <code>-1</code> wenn es in keinem der Quadranten enthalten ist. <br><br>  Jetzt sind wir bereit, Methoden zum Einf√ºgen und L√∂schen in Betracht zu ziehen. <br><br><h2>  Einf√ºgen </h2><br>  Die <code>add</code> Methode ruft einfach eine private Hilfsmethode auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ add(mRoot.get(), <span class="hljs-number"><span class="hljs-number">0</span></span>, mBox, value); }</code> </pre> <br>  Hier ist der Code der Hilfsmethode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Insert the value in this node if possible if (depth &gt;= MaxDepth || node-&gt;values.size() &lt; Threshold) node-&gt;values.push_back(value); // Otherwise, we split and we try again else { split(node, box); add(node, depth, box, value); } } else { auto i = getQuadrant(box, mGetBox(value)); // Add the value in a child if the value is entirely contained in it if (i != -1) add(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), depth + 1, computeBox(box, i), value); // Otherwise, we add the value in the current node else node-&gt;values.push_back(value); } }</span></span></code> </pre> <br>  Zu Beginn gibt es einige Annahmen, die best√§tigen, dass wir nichts Unlogisches tun. Beispielsweise f√ºgen wir keinen Wert in einen Knoten ein, der keinen Begrenzungsrahmen enth√§lt. <br><br>  Wenn dann der Knoten ein Blatt ist und wir einen neuen Wert in ihn einf√ºgen k√∂nnen, d.h.  Wir haben <code>MaxDepth</code> oder <code>Threshold</code> nicht erreicht. <code>MaxDepth</code> das Einf√ºgen durch.  Andernfalls teilen wir diesen Knoten und versuchen es erneut. <br><br>  Wenn der Knoten intern ist, berechnen wir den Quadranten, der den Begrenzungsrahmen des Werts enth√§lt.  Wenn es vollst√§ndig im untergeordneten Knoten enthalten ist, f√ºhren wir einen rekursiven Aufruf durch.  Andernfalls f√ºgen Sie in diesen Knoten ein. <br><br>  Hier ist das Trennverfahren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only leaves can be split"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Create children for (auto&amp; child : node-&gt;children) child = std::make_unique&lt;Node&gt;(); // Assign values to children auto newValues = std::vector&lt;T&gt;(); // New values for this node for (const auto&amp; value : node-&gt;values) { auto i = getQuadrant(box, mGetBox(value)); if (i != -1) node-&gt;children[static_cast&lt;std::size_t&gt;(i)]-&gt;values.push_back(value); else newValues.push_back(value); } node-&gt;values = std::move(newValues); }</span></span></code> </pre> <br>  Wir erstellen vier untergeordnete Knoten und entscheiden dann f√ºr jeden Wert des √ºbergeordneten Knotens, in welchem ‚Äã‚ÄãKnoten (untergeordnet oder √ºbergeordnet) der Wert gespeichert werden soll. <br><br><h2>  L√∂schen </h2><br>  Die Methode <code>remove</code> ruft auch einfach eine Hilfsmethode auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ remove(mRoot.get(), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, mBox, value); }</code> </pre> <br>  Hier ist der Code der Hilfsmethode, der dem Einf√ºgecode sehr √§hnlich ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, Node* parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Remove the value from node removeValue(node, value); // Try to merge the parent if (parent != nullptr) tryMerge(parent); } else { // Remove the value in a child if the value is entirely contained in it auto i = getQuadrant(box, mGetBox(value)); if (i != -1) remove(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), node, computeBox(box, i), value); // Otherwise, we remove the value from the current node else removeValue(node, value); } }</span></span></code> </pre> <br>  Wenn der aktuelle Knoten ein Blatt ist, entfernen wir den Wert aus der Werteliste des aktuellen Knotens <br>  und versuchen Sie, diesen Knoten mit den Schwesterknoten und seinem √ºbergeordneten Knoten zusammenzuf√ºhren.  Andernfalls bestimmen wir, in welchem ‚Äã‚ÄãQuadranten sich der Begrenzungsrahmen des Werts befindet.  Wenn es vollst√§ndig im untergeordneten Knoten enthalten ist, f√ºhren wir einen rekursiven Aufruf durch.  Andernfalls l√∂schen Sie aus den Werten des aktuellen Knotens. <br><br>  Da uns die Reihenfolge der im Knoten gespeicherten Werte beim L√∂schen egal ist, verwende ich eine kleine Optimierung: Ich √§ndere einfach den gel√∂schten Wert mit dem letzten und l√∂sche ihn: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the value in node-&gt;values auto it = std::find_if(std::begin(node-&gt;values), std::end(node-&gt;values), [this, &amp;value](const auto&amp; rhs){ return mEqual(value, rhs); }); assert(it != std::end(node-&gt;values) &amp;&amp; "Trying to remove a value that is not present in the node"); // Swap with the last element and pop back *it = std::move(node-&gt;values.back()); node-&gt;values.pop_back(); }</span></span></code> </pre> <br>  Wir m√ºssen uns auch <code>tryMerge</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryMerge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(!isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only interior nodes can be merged"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> nbValues = node-&gt;values.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; child : node-&gt;children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(child.get())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; nbValues += child-&gt;values.size(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbValues &lt;= Threshold) { node-&gt;values.reserve(nbValues); <span class="hljs-comment"><span class="hljs-comment">// Merge the values of all the children for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : child-&gt;values) node-&gt;values.push_back(value); } // Remove the children for (auto&amp; child : node-&gt;children) child.reset(); } }</span></span></code> </pre> <br>  <code>tryMerge</code> √ºberpr√ºft, ob alle <code>tryMerge</code> Knoten Bl√§tter sind und ob die Gesamtzahl seiner Werte und der Werte der <code>tryMerge</code> Knoten unter dem Schwellenwert liegt.  Wenn ja, kopieren wir alle Werte von den untergeordneten Knoten auf den aktuellen Knoten und l√∂schen die untergeordneten Knoten. <br><br><h1>  Schnittpunktsuche </h1><br><h2>  Schnittpunkt mit Rechteck </h2><br>  Schlie√ülich kamen wir zum interessantesten: zur Suche nach Kreuzungen.  Die erste M√∂glichkeit besteht darin, alle Werte zu ermitteln, die ein bestimmtes Rechteck schneiden.  Dies ist beispielsweise erforderlich, um das Abschneiden durchzuf√ºhren. <br><br>  Dies <code>query</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; query(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(); query(mRoot.get(), mBox, box, values); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values; }</code> </pre> <br>  Bei dieser Methode w√§hlen wir einfach <code>std::vector</code> , der die Werte enth√§lt, die den Begrenzungsrahmen schneiden, und rufen die Hilfsmethode auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; queryBox, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(queryBox.intersects(box)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; value : node-&gt;values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(mGetBox(value))) values.push_back(value); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(node)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; node-&gt;children.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childBox = computeBox(box, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(i)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(childBox)) query(node-&gt;children[i].get(), childBox, queryBox, values); } } }</code> </pre> <br>  Zuerst addieren wir alle im aktuellen Knoten gespeicherten Werte, die sich mit dem angeforderten Rechteck schneiden.  Wenn der aktuelle Knoten intern ist, f√ºhren wir einen rekursiven Aufruf f√ºr jeden untergeordneten Knoten durch, dessen Begrenzungsrechteck das angeforderte Rechteck schneidet. <br><br><h2>  Alle paarweisen Schnittpunkte </h2><br>  Der zweite unterst√ºtzte Anwendungsfall besteht darin, nach allen Wertepaaren zu suchen, die im sich √ºberschneidenden Quadrantenbaum gespeichert sind.  Dies ist besonders n√ºtzlich, wenn Sie eine physische Engine erstellen.  Dieses Problem kann mit der <code>query</code> gel√∂st werden.  Tats√§chlich k√∂nnen wir die <code>query</code> f√ºr den Begrenzungsrahmen aller Werte aufrufen.  Dies kann jedoch effizienter durchgef√ºhrt werden, indem nur ein Schnittpunkt f√ºr ein Paar hinzugef√ºgt wird (bei <code>query</code> werden diese zweimal gefunden). <br><br>  Um dies zu realisieren, m√ºssen wir ber√ºcksichtigen, dass der Schnittpunkt nur auftreten kann <br><br><ul><li>  zwischen zwei in einem Knoten gespeicherten Werten </li></ul><br>  oder <br><br><ul><li>  zwischen dem im Knoten gespeicherten Wert und einem anderen Wert, der im Nachkommen dieses Knotens gespeichert ist. </li></ul><br>  Aus diesem Grund m√ºssen wir nur den Schnittpunkt zwischen: <br><br><ul><li>  Wert und die folgenden Werte im selben Knoten gespeichert </li></ul><br>  und <br><br><ul><li>  Wert und im Nachkommen gespeicherte Werte. </li></ul><br>  Daher werden wir definitiv nicht zweimal dieselbe Kreuzung melden. <br><br>  Hier ist der <code>findAllIntersections</code> Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt; findAllIntersections() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> intersections = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt;(); findAllIntersections(mRoot.get(), intersections); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersections; }</code> </pre> <br>  Auch hier weisen wir einfach <code>std::vector</code> zu, um die Schnittpunkte zu speichern und die Hilfsfunktion aufzurufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllIntersections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find intersections between values stored in this node // Make sure to not report the same intersection twice for (auto i = std::size_t(0); i &lt; node-&gt;values.size(); ++i) { for (auto j = std::size_t(0); j &lt; i; ++j) { if (mGetBox(node-&gt;values[i]).intersects(mGetBox(node-&gt;values[j]))) intersections.emplace_back(node-&gt;values[i], node-&gt;values[j]); } } if (!isLeaf(node)) { // Values in this node can intersect values in descendants for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : node-&gt;values) findIntersectionsInDescendants(child.get(), value, intersections); } // Find intersections in children for (const auto&amp; child : node-&gt;children) findAllIntersections(child.get(), intersections); } }</span></span></code> </pre> <br>  In der ersten Phase werden Schnittpunkte zwischen den im aktuellen Knoten gespeicherten Werten √ºberpr√ºft.  Wenn der aktuelle Knoten intern ist, <code>findIntersectionInDescendants</code> nach Schnittpunkten zwischen den in diesem Knoten gespeicherten Werten und den in seinen Nachkommen gespeicherten Werten.  Schlie√ülich machen wir rekursive Aufrufe. <br><br>  <code>findIntersectionsInDescendants</code> findet rekursiv Schnittpunkte zwischen dem angegebenen Wert und allen im Teilbaum gespeicherten Werten: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIntersectionsInDescendants</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Test against the values stored in this node for (const auto&amp; other : node-&gt;values) { if (mGetBox(value).intersects(mGetBox(other))) intersections.emplace_back(value, other); } // Test against values stored into descendants of this node if (!isLeaf(node)) { for (const auto&amp; child : node-&gt;children) findIntersectionsInDescendants(child.get(), value, intersections); } }</span></span></code> </pre> <br>  Das ist alles!  Ich wiederhole, der gesamte Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub ver√∂ffentlicht</a> . <br><br><h1>  N√ºtzliche Ressourcen </h1><br>  Wenn Sie mehr √ºber die Kollisionserkennung und Partitionierung von Datenstrukturen erfahren m√∂chten, empfehlen wir Ihnen, das Buch von Christer Erickson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Real-Time Collision Detection zu</a> lesen.  Viele Themen sind darin tief verwurzelt und gleichzeitig ist das Buch in einer sehr verst√§ndlichen Sprache verfasst.  Dar√ºber hinaus k√∂nnen Kapitel separat gelesen werden.  Dies ist eine gro√üartige Referenzquelle. <br><br><h1>  Fazit </h1><br>  Damit ist die Arbeit mit der Kollisionserkennung abgeschlossen.  Es ist jedoch nur die H√§lfte des physischen Motors.  Die zweite H√§lfte ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufl√∂sung von Kollisionen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473066/">https://habr.com/ru/post/de473066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473054/index.html">WorldSkills final, Entwicklung von IT-L√∂sungen f√ºr Unternehmen - was es ist, wie es war und warum 1C-Programmierer dort gewonnen haben</a></li>
<li><a href="../de473056/index.html">Wie Alice L√§nder anhand von Fotografien erkennt. Yandex-Forschung</a></li>
<li><a href="../de473058/index.html">Sergey Sinitsyn: ‚ÄûOSM ist mehr als nur das Zeichnen von H√§usern oder Spuren. Das sind mehr Geschichten! ‚Äú</a></li>
<li><a href="../de473062/index.html">Subjektive user.js f√ºr Mozilla Firefox und nicht nur</a></li>
<li><a href="../de473064/index.html">Batavianische Tr√§nen, Autos und Gorilla-Glas: √ºber einige Arten von verst√§rktem Glas</a></li>
<li><a href="../de473070/index.html">Redux - Nicht ben√∂tigt! Ersetzen durch useContext und useReducer in React?</a></li>
<li><a href="../de473072/index.html">Wie Gazpromneft einen digitalen Weg f√ºr einen Firmenkunden schafft</a></li>
<li><a href="../de473074/index.html">Was ist APS und warum wird ein Produktionsplan nicht so erstellt, wie wir es wollen ...</a></li>
<li><a href="../de473078/index.html">Verwalten Sie einfach Mikroservice-Konfigurationen mit microconfig.io</a></li>
<li><a href="../de473082/index.html">Wie wir Microservices schreiben und warum wir das nicht schnell machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>