<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏩ 👩🏾‍🤝‍👨🏻 👩🏻‍🍳 Quadrantenbäume und Kollisionserkennung 👩‍🎓 🈳 🧘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Woche war kurz, am Montag und Dienstag arbeitete ich weiter an einem 2D-Beleuchtungssystem . Den Rest der Zeit habe ich mit der Implementierung ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quadrantenbäume und Kollisionserkennung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473066/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/237/20a/59e23720a19b3109d80e62c6d2d539a0.gif" alt="Bild"></div><br>  Diese Woche war kurz, am Montag und Dienstag arbeitete ich weiter an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem 2D-Beleuchtungssystem</a> .  Den Rest der Zeit habe ich mit der Implementierung von Quadtree-Bäumen verbracht. <br><br>  In diesem Artikel werde ich meine Implementierung und Gedanken teilen, die während des Entwurfs entstanden sind. <br><br>  Zunächst muss ich sagen, warum ich mich entschieden habe, einen Quadrantenbaum zu implementieren. <br><br>  Quadtree ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Space-Partition-Datenstruktur</a> .  Der Hauptvorteil gegenüber anderen Datenstrukturen ist die Anpassungsfähigkeit.  Es bietet eine gute Leistung beim Einfügen, Löschen und Suchen.  Das heißt, wir können diesen Baum in einem dynamischen Kontext verwenden, in dem sich Daten häufig ändern.  Darüber hinaus ist diese Struktur recht einfach zu verstehen und zu implementieren. <br><br>  Wenn die Speicherpartitionierung ein neues Thema für Sie ist, empfehle ich, diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von</a> Robert Nistrom zu lesen.  Wenn Sie mehr über Quadrantenbäume erfahren möchten, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> Artikel. <br><a name="habracut"></a><br>  Es gibt Bereiche in meinem Spiel, in denen sich die Verwendung von Quadtree sofort auszahlt: <br><br><ul><li>  Bei der Erkennung von Kollisionen ist der Quadrantenbaum viel effizienter als die Brute-Force-Methode (Testen aller Paare).  Dies ist jedoch nicht der effektivste Ansatz. In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> kann ein Überblick über verschiedene Techniken und Benchmarks gegeben werden.  Für die erste Version meiner Physik-Engine verwende ich sie jedoch.  Vielleicht werde ich später, falls nötig, einen spezielleren Algorithmus wählen. </li><li>  Im Szenendiagramm kann ich beim Ausschneiden mit quadtree nach allen sichtbaren Knoten suchen. </li><li>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Beleuchtungssystem können</a> Sie mit quadtree Wände finden, die das Polygon der Sichtbarkeit der Lichtquelle schneiden. </li><li>  Im KI-System können Sie mit quadtree nach allen Objekten oder Feinden suchen, die der Essenz nahe stehen. </li><li>  Usw... </li></ul><br>  Wie Sie sehen können, sind Quadrantenbäume ziemlich vielseitig.  Sie sind eine gute Ergänzung in Ihrem Toolkit. <br><br>  Der gesamte im Artikel gezeigte Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> zu finden. <br><br><h1>  Vorbereitende Vorbereitung </h1><br>  Bevor wir den Quadtree-Code detaillieren, benötigen wir kleine Klassen für geometrische <code>Vector2</code> : die <code>Vector2</code> Klasse zum Definieren von Punkten und die <code>Box</code> Klasse zum Definieren von Rechtecken.  Beide werden Boilerplate sein. <br><br><h2>  Vektor2 </h2><br>  Die <a href=""><code>Vector2</code></a> Klasse <a href=""><code>Vector2</code></a> minimalistisch.  Es enthält nur Konstruktoren sowie <code>+</code> und <code>/</code> Operatoren.  Das ist alles was wir brauchen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T x; T y; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;(TX = <span class="hljs-number"><span class="hljs-number">0</span></span>, TY = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : x(X), y(Y) { } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x += other.x; y += other.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/=(T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { x /= t; y /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vector2&lt;T&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector2&lt;T&gt;&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { lhs += rhs; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Vector2&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/(Vector2&lt;T&gt; vec, T t) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { vec /= t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec; }</code> </pre> <br><h2>  Box </h2><br>  Die <a href=""><code>Box</code></a> Klasse ist nicht viel komplizierter: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T left; T top; T width; <span class="hljs-comment"><span class="hljs-comment">// Must be positive T height; // Must be positive constexpr Box(T Left = 0, T Top = 0, T Width = 0, T Height = 0) noexcept : left(Left), top(Top), width(Width), height(Height) { } constexpr Box(const Vector2&lt;T&gt;&amp; position, const Vector2&lt;T&gt;&amp; size) noexcept : left(position.x), top(position.y), width(size.x), height(size.y) { } constexpr T getRight() const noexcept { return left + width; } constexpr T getBottom() const noexcept { return top + height; } constexpr Vector2&lt;T&gt; getTopLeft() const noexcept { return Vector2&lt;T&gt;(left, top); } constexpr Vector2&lt;T&gt; getCenter() const noexcept { return Vector2&lt;T&gt;(left + width / 2, top + height / 2); } constexpr Vector2&lt;T&gt; getSize() const noexcept { return Vector2&lt;T&gt;(width, height); } constexpr bool contains(const Box&lt;T&gt;&amp; box) const noexcept { return left &lt;= box.left &amp;&amp; box.getRight() &lt;= getRight() &amp;&amp; top &lt;= box.top &amp;&amp; box.getBottom() &lt;= getBottom(); } constexpr bool intersects(const Box&lt;T&gt;&amp; box) const noexcept { return !(left &gt;= box.getRight() || getRight() &lt;= box.left || top &gt;= box.getBottom() || getBottom() &lt;= box.top); } };</span></span></code> </pre> <br>  Es enthält einige nützliche Getter. <br><br>  Interessanter ist, dass es die Methode enthält enthält, die prüft, ob sich das Rechteck in einem anderen befindet, und die Methode <code>intersects</code> , die prüft, ob sich das Rechteck mit einem anderen schneidet. <br><br>  Wir werden beim Einfügen und Löschen Includes verwenden und beim Erkennen von Schnittpunkten überschneiden. <br><br><h1>  Quadtree </h1><br>  Hier ist das <a href=""><code>Quadtree</code></a> der <a href=""><code>Quadtree</code></a> Klasse: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GetBox, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Equal = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::equal_to&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Float = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; class Quadtree { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;GetBox, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, Box&lt;Float&gt;&gt;, <span class="hljs-string"><span class="hljs-string">"GetBox must be a callable of signature Box&lt;Float&gt;(const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_convertible_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Equal, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;, <span class="hljs-string"><span class="hljs-string">"Equal must be a callable of signature bool(const T&amp;, const T&amp;)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt;Float&gt;); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Quadtree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GetBox&amp; getBox = GetBox(), <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Equal&amp; equal = Equal()) : mBox(box), mRoot(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Node&gt;()), mGetBox(getBox), mEqual(equal) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Threshold = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> MaxDepth = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt;, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; children; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; values; }; Box&lt;Float&gt; mBox; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Node&gt; mRoot; GetBox mGetBox; Equal mEqual; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLeaf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Node* node)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(node-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } };</code> </pre> <br>  Wie Sie sehen können, ist <code>Quadtree</code> eine Vorlagenklasse.  Auf diese Weise können wir die Klasse für verschiedene Zwecke verwenden, über die ich zu Beginn gesprochen habe. <br><br>  Vorlagenoptionen: <br><br><ul><li>  <code>T</code> : Die Art der Werte, die in quadtree enthalten sein werden.  <code>T</code> sollte eine einfache Klasse sein, da sie in einem Quadtree gespeichert wird.  Idealerweise sollte dies ein Zeiger oder eine kleine einfache Datenstruktur (POD) sein. </li><li>  <code>GetBox</code> : Der Typ des aufgerufenen Objekts, der den Wert an der Eingabe empfängt und ein Rechteck <code>GetBox</code> . </li><li>  <code>Equal</code> : Der Typ des aufgerufenen Objekts, um zu überprüfen, ob zwei Werte gleich sind.  Standardmäßig verwenden wir den Standard-Gleichheitsoperator. </li><li>  <code>Float</code> : Der in Berechnungen verwendete arithmetische Typ.  Standardmäßig verwenden wir <code>float</code> . </li></ul><br>  Zu Beginn der Klassendefinition gibt es drei statische Zusicherungen zum Überprüfen der Gültigkeit der Vorlagenparameter. <br><br>  Werfen wir einen Blick auf die Definition eines Knotens.  Ein Knoten speichert einfach Zeiger auf seine vier untergeordneten Knoten und eine Liste der darin enthaltenen Werte.  Wir speichern darin weder den Begrenzungsrahmen noch die Tiefe, sie werden im laufenden Betrieb berechnet. <br><br>  Ich führte Benchmarks für beide Ansätze durch (Beibehalten eines Rechtecks ​​mit Tiefe und ohne Beibehalten) und stellte bei der Berechnung im laufenden Betrieb keine Leistungseinbußen fest.  Außerdem spart es ein wenig Speicher. <br><br>  Um einen internen Knoten von einem Blatt unterscheiden zu können, <code>isLeaf</code> die Methode <code>isLeaf</code> .  Es wird nur überprüft, ob das erste Kind nicht null ist.  Da null entweder alle untergeordneten Knoten oder keiner von ihnen sind, reicht es aus, nur den ersten zu überprüfen. <br><br>  Jetzt können wir uns die <code>Quadtree</code> Mitgliedsvariablen <code>Quadtree</code> : <br><br><ul><li>  <code>mBox</code> ist ein globaler Begrenzungsrahmen.  Alle in quadtree eingefügten Werte müssen darin enthalten sein. </li><li>  <code>mRoot</code> ist die Wurzel von quadtree. </li><li>  <code>mGetBox</code> ist das aufgerufene Objekt, mit dem wir das Rechteck aus dem Wert <code>mGetBox</code> . </li><li>  <code>mEqual</code> ist das aufgerufene Objekt, mit dem wir die Gleichheit der beiden Werte überprüfen. </li></ul><br>  Der Konstruktor setzt einfach <code>mBox</code> , <code>mGetBox</code> und <code>mEqual</code> und erstellt auch einen Wurzelknoten. <br><br>  Die letzten beiden Parameter, über die wir noch nicht gesprochen haben, sind <code>Threshold</code> und <code>MaxDepth</code> .  <code>Threshold</code> ist die maximale Anzahl von Werten, die ein Knoten enthalten kann, bevor wir ihn teilen.  <code>MaxDepth</code> ist die maximale Tiefe eines Knotens. Wir versuchen nicht mehr, die Knoten in <code>MaxDepth</code> zu <code>MaxDepth</code> . Wenn Sie zu viel teilen, kann dies die Leistung beeinträchtigen.  Ich habe diesen Konstanten vernünftige Werte gegeben, die für die meisten Fälle geeignet sind.  Sie können versuchen, sie für Ihre Konfiguration zu optimieren. <br><br>  Jetzt sind wir bereit, weitere interessante Operationen zu starten. <br><br><h1>  Einfügen und löschen </h1><br>  Bevor ich den Einfügecode zeige, müssen wir diskutieren, welche Knoten die Werte enthalten.  Es gibt zwei Strategien: <br><br><ul><li>  Werte werden nur in Blättern gespeichert.  Da der Begrenzungsrahmen eines Werts mit mehreren Blättern interagieren kann, wird der Wert in allen diesen Blättern gespeichert. </li><li>  Werte können in allen Knoten gespeichert werden.  Wir speichern den Wert im kleinsten Knoten, der seinen Begrenzungsrahmen vollständig enthält. </li></ul><br>  Wenn die Begrenzungsrechtecke klein und ungefähr gleich groß sind, ist die erste Strategie bei der Suche nach Schnittpunkten effektiver.  Wenn jedoch große Rechtecke vorhanden sind, können entartete Fälle auftreten, in denen die Leistung sehr schlecht ist.  Wenn wir beispielsweise einen Wert einfügen, dessen Rechteck sich im globalen Begrenzungsrahmen befindet, wird er allen Blättern hinzugefügt.  Wenn wir einen <code>Threshold</code> für solche Werte einfügen, werden alle Knoten geteilt, bis <code>MaxDepth</code> erreicht ist und die Werte nicht in allen Blättern enthalten sind.  Daher wird quadtree enthalten <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="37.45ex" height="2.539ex" viewBox="0 -987.6 16124.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="611" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-78" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="1650" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="2012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="2373" y="0"></use><g transform="translate(2735,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-54" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-68" x="704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-72" x="1281" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="1732" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-73" x="2199" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-68" x="2668" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-6F" x="3245" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-6C" x="3730" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-64" x="4029" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="7537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-69" x="7899" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-6D" x="8244" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="9123" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-73" x="9589" y="0"></use><g transform="translate(10059,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMAIN-34" x="0" y="0"></use><g transform="translate(500,404)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="715" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-78" x="1181" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="1754" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="2115" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="2477" y="0"></use><g transform="translate(2007,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-4D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-61" x="1051" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-78" x="1581" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-44" x="2153" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-65" x="2982" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-70" x="3448" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-74" x="3952" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/473066/&amp;usg=ALkJrhg6WZOF1fcg-kFMet8gYoZRpGh-kw#MJMATHI-68" x="4313" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi></mrow><mtext>&nbsp;</mtext><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><msup><mn>4</mn><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>t</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ texttt {Threshold} \ times 4 ^ {\ texttt {MaxDepth}} </script>  Werte, und das ist ... viel. <br><br>  Darüber hinaus ist das Einfügen und Löschen bei der ersten Strategie etwas langsamer, da alle Knoten, die den Wert schneiden, eingefügt (oder gelöscht) werden müssen. <br><br>  Daher werde ich die zweite Strategie anwenden, bei der es keine entarteten Fälle gibt.  Da ich Quadtree in verschiedenen Kontexten verwenden möchte, ist dies bequemer.  Darüber hinaus eignet sich diese Strategie besser für dynamische Kontexte, in denen viele Einfügungen und Löschungen durchgeführt werden, um Werte zu aktualisieren, z. B. in einer physischen Engine, in der Entitäten verschoben werden. <br><br>  Um herauszufinden, in welchen Knoten wir einen Wert einfügen oder löschen, verwenden wir zwei Hilfsfunktionen. <br><br>  Die erste, <code>computeBox</code> , berechnet das Rechteck des <code>computeBox</code> Knotens anhand des Rechtecks ​​des übergeordneten Knotens und des Index seines Quadranten. <br><br><pre> <code class="cpp hljs">Box&lt;Float&gt; computeBox(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> origin = box.getTopLeft(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childSize = box.getSize() / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Float&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-comment"><span class="hljs-comment">// North West case 0: return Box&lt;Float&gt;(origin, childSize); // Norst East case 1: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x + childSize.x, origin.y), childSize); // South West case 2: return Box&lt;Float&gt;(Vector2&lt;Float&gt;(origin.x, origin.y + childSize.y), childSize); // South East case 3: return Box&lt;Float&gt;(origin + childSize, childSize); default: assert(false &amp;&amp; "Invalid child index"); return Box&lt;Float&gt;(); } }</span></span></code> </pre> <br>  Der zweite, <code>getQuadrant</code> , gibt den Quadranten zurück, in dem sich der Wert befindet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getQuadrant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; nodeBox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; valueBox)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> center = nodeBox.getCenter(); <span class="hljs-comment"><span class="hljs-comment">// West if (valueBox.getRight() &lt; center.x) { // North West if (valueBox.getBottom() &lt; center.y) return 0; // South West else if (valueBox.top &gt;= center.y) return 2; // Not contained in any quadrant else return -1; } // East else if (valueBox.left &gt;= center.x) { // North East if (valueBox.getBottom() &lt; center.y) return 1; // South East else if (valueBox.top &gt;= center.y) return 3; // Not contained in any quadrant else return -1; } // Not contained in any quadrant else return -1; }</span></span></code> </pre> <br>  Es gibt <code>-1</code> wenn es in keinem der Quadranten enthalten ist. <br><br>  Jetzt sind wir bereit, Methoden zum Einfügen und Löschen in Betracht zu ziehen. <br><br><h2>  Einfügen </h2><br>  Die <code>add</code> Methode ruft einfach eine private Hilfsmethode auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ add(mRoot.get(), <span class="hljs-number"><span class="hljs-number">0</span></span>, mBox, value); }</code> </pre> <br>  Hier ist der Code der Hilfsmethode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Insert the value in this node if possible if (depth &gt;= MaxDepth || node-&gt;values.size() &lt; Threshold) node-&gt;values.push_back(value); // Otherwise, we split and we try again else { split(node, box); add(node, depth, box, value); } } else { auto i = getQuadrant(box, mGetBox(value)); // Add the value in a child if the value is entirely contained in it if (i != -1) add(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), depth + 1, computeBox(box, i), value); // Otherwise, we add the value in the current node else node-&gt;values.push_back(value); } }</span></span></code> </pre> <br>  Zu Beginn gibt es einige Annahmen, die bestätigen, dass wir nichts Unlogisches tun. Beispielsweise fügen wir keinen Wert in einen Knoten ein, der keinen Begrenzungsrahmen enthält. <br><br>  Wenn dann der Knoten ein Blatt ist und wir einen neuen Wert in ihn einfügen können, d.h.  Wir haben <code>MaxDepth</code> oder <code>Threshold</code> nicht erreicht. <code>MaxDepth</code> das Einfügen durch.  Andernfalls teilen wir diesen Knoten und versuchen es erneut. <br><br>  Wenn der Knoten intern ist, berechnen wir den Quadranten, der den Begrenzungsrahmen des Werts enthält.  Wenn es vollständig im untergeordneten Knoten enthalten ist, führen wir einen rekursiven Aufruf durch.  Andernfalls fügen Sie in diesen Knoten ein. <br><br>  Hier ist das Trennverfahren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only leaves can be split"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Create children for (auto&amp; child : node-&gt;children) child = std::make_unique&lt;Node&gt;(); // Assign values to children auto newValues = std::vector&lt;T&gt;(); // New values for this node for (const auto&amp; value : node-&gt;values) { auto i = getQuadrant(box, mGetBox(value)); if (i != -1) node-&gt;children[static_cast&lt;std::size_t&gt;(i)]-&gt;values.push_back(value); else newValues.push_back(value); } node-&gt;values = std::move(newValues); }</span></span></code> </pre> <br>  Wir erstellen vier untergeordnete Knoten und entscheiden dann für jeden Wert des übergeordneten Knotens, in welchem ​​Knoten (untergeordnet oder übergeordnet) der Wert gespeichert werden soll. <br><br><h2>  Löschen </h2><br>  Die Methode <code>remove</code> ruft auch einfach eine Hilfsmethode auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ remove(mRoot.get(), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, mBox, value); }</code> </pre> <br>  Hier ist der Code der Hilfsmethode, der dem Einfügecode sehr ähnlich ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, Node* parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(box.contains(mGetBox(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLeaf(node)) { <span class="hljs-comment"><span class="hljs-comment">// Remove the value from node removeValue(node, value); // Try to merge the parent if (parent != nullptr) tryMerge(parent); } else { // Remove the value in a child if the value is entirely contained in it auto i = getQuadrant(box, mGetBox(value)); if (i != -1) remove(node-&gt;children[static_cast&lt;std::size_t&gt;(i)].get(), node, computeBox(box, i), value); // Otherwise, we remove the value from the current node else removeValue(node, value); } }</span></span></code> </pre> <br>  Wenn der aktuelle Knoten ein Blatt ist, entfernen wir den Wert aus der Werteliste des aktuellen Knotens <br>  und versuchen Sie, diesen Knoten mit den Schwesterknoten und seinem übergeordneten Knoten zusammenzuführen.  Andernfalls bestimmen wir, in welchem ​​Quadranten sich der Begrenzungsrahmen des Werts befindet.  Wenn es vollständig im untergeordneten Knoten enthalten ist, führen wir einen rekursiven Aufruf durch.  Andernfalls löschen Sie aus den Werten des aktuellen Knotens. <br><br>  Da uns die Reihenfolge der im Knoten gespeicherten Werte beim Löschen egal ist, verwende ich eine kleine Optimierung: Ich ändere einfach den gelöschten Wert mit dem letzten und lösche ihn: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the value in node-&gt;values auto it = std::find_if(std::begin(node-&gt;values), std::end(node-&gt;values), [this, &amp;value](const auto&amp; rhs){ return mEqual(value, rhs); }); assert(it != std::end(node-&gt;values) &amp;&amp; "Trying to remove a value that is not present in the node"); // Swap with the last element and pop back *it = std::move(node-&gt;values.back()); node-&gt;values.pop_back(); }</span></span></code> </pre> <br>  Wir müssen uns auch <code>tryMerge</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryMerge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node)</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(!isLeaf(node) &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Only interior nodes can be merged"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> nbValues = node-&gt;values.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; child : node-&gt;children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(child.get())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; nbValues += child-&gt;values.size(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbValues &lt;= Threshold) { node-&gt;values.reserve(nbValues); <span class="hljs-comment"><span class="hljs-comment">// Merge the values of all the children for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : child-&gt;values) node-&gt;values.push_back(value); } // Remove the children for (auto&amp; child : node-&gt;children) child.reset(); } }</span></span></code> </pre> <br>  <code>tryMerge</code> überprüft, ob alle <code>tryMerge</code> Knoten Blätter sind und ob die Gesamtzahl seiner Werte und der Werte der <code>tryMerge</code> Knoten unter dem Schwellenwert liegt.  Wenn ja, kopieren wir alle Werte von den untergeordneten Knoten auf den aktuellen Knoten und löschen die untergeordneten Knoten. <br><br><h1>  Schnittpunktsuche </h1><br><h2>  Schnittpunkt mit Rechteck </h2><br>  Schließlich kamen wir zum interessantesten: zur Suche nach Kreuzungen.  Die erste Möglichkeit besteht darin, alle Werte zu ermitteln, die ein bestimmtes Rechteck schneiden.  Dies ist beispielsweise erforderlich, um das Abschneiden durchzuführen. <br><br>  Dies <code>query</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; query(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Box&lt;Float&gt;&amp; box) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(); query(mRoot.get(), mBox, box, values); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values; }</code> </pre> <br>  Bei dieser Methode wählen wir einfach <code>std::vector</code> , der die Werte enthält, die den Begrenzungsrahmen schneiden, und rufen die Hilfsmethode auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; box, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Box&lt;Float&gt;&amp; queryBox, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(node != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); assert(queryBox.intersects(box)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; value : node-&gt;values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(mGetBox(value))) values.push_back(value); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLeaf(node)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; node-&gt;children.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> childBox = computeBox(box, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(i)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryBox.intersects(childBox)) query(node-&gt;children[i].get(), childBox, queryBox, values); } } }</code> </pre> <br>  Zuerst addieren wir alle im aktuellen Knoten gespeicherten Werte, die sich mit dem angeforderten Rechteck schneiden.  Wenn der aktuelle Knoten intern ist, führen wir einen rekursiven Aufruf für jeden untergeordneten Knoten durch, dessen Begrenzungsrechteck das angeforderte Rechteck schneidet. <br><br><h2>  Alle paarweisen Schnittpunkte </h2><br>  Der zweite unterstützte Anwendungsfall besteht darin, nach allen Wertepaaren zu suchen, die im sich überschneidenden Quadrantenbaum gespeichert sind.  Dies ist besonders nützlich, wenn Sie eine physische Engine erstellen.  Dieses Problem kann mit der <code>query</code> gelöst werden.  Tatsächlich können wir die <code>query</code> für den Begrenzungsrahmen aller Werte aufrufen.  Dies kann jedoch effizienter durchgeführt werden, indem nur ein Schnittpunkt für ein Paar hinzugefügt wird (bei <code>query</code> werden diese zweimal gefunden). <br><br>  Um dies zu realisieren, müssen wir berücksichtigen, dass der Schnittpunkt nur auftreten kann <br><br><ul><li>  zwischen zwei in einem Knoten gespeicherten Werten </li></ul><br>  oder <br><br><ul><li>  zwischen dem im Knoten gespeicherten Wert und einem anderen Wert, der im Nachkommen dieses Knotens gespeichert ist. </li></ul><br>  Aus diesem Grund müssen wir nur den Schnittpunkt zwischen: <br><br><ul><li>  Wert und die folgenden Werte im selben Knoten gespeichert </li></ul><br>  und <br><br><ul><li>  Wert und im Nachkommen gespeicherte Werte. </li></ul><br>  Daher werden wir definitiv nicht zweimal dieselbe Kreuzung melden. <br><br>  Hier ist der <code>findAllIntersections</code> Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt; findAllIntersections() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> intersections = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;T, T&gt;&gt;(); findAllIntersections(mRoot.get(), intersections); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersections; }</code> </pre> <br>  Auch hier weisen wir einfach <code>std::vector</code> zu, um die Schnittpunkte zu speichern und die Hilfsfunktion aufzurufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllIntersections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find intersections between values stored in this node // Make sure to not report the same intersection twice for (auto i = std::size_t(0); i &lt; node-&gt;values.size(); ++i) { for (auto j = std::size_t(0); j &lt; i; ++j) { if (mGetBox(node-&gt;values[i]).intersects(mGetBox(node-&gt;values[j]))) intersections.emplace_back(node-&gt;values[i], node-&gt;values[j]); } } if (!isLeaf(node)) { // Values in this node can intersect values in descendants for (const auto&amp; child : node-&gt;children) { for (const auto&amp; value : node-&gt;values) findIntersectionsInDescendants(child.get(), value, intersections); } // Find intersections in children for (const auto&amp; child : node-&gt;children) findAllIntersections(child.get(), intersections); } }</span></span></code> </pre> <br>  In der ersten Phase werden Schnittpunkte zwischen den im aktuellen Knoten gespeicherten Werten überprüft.  Wenn der aktuelle Knoten intern ist, <code>findIntersectionInDescendants</code> nach Schnittpunkten zwischen den in diesem Knoten gespeicherten Werten und den in seinen Nachkommen gespeicherten Werten.  Schließlich machen wir rekursive Aufrufe. <br><br>  <code>findIntersectionsInDescendants</code> findet rekursiv Schnittpunkte zwischen dem angegebenen Wert und allen im Teilbaum gespeicherten Werten: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIntersectionsInDescendants</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node* node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;T, T&gt;&gt;&amp; intersections)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Test against the values stored in this node for (const auto&amp; other : node-&gt;values) { if (mGetBox(value).intersects(mGetBox(other))) intersections.emplace_back(value, other); } // Test against values stored into descendants of this node if (!isLeaf(node)) { for (const auto&amp; child : node-&gt;children) findIntersectionsInDescendants(child.get(), value, intersections); } }</span></span></code> </pre> <br>  Das ist alles!  Ich wiederhole, der gesamte Code ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub veröffentlicht</a> . <br><br><h1>  Nützliche Ressourcen </h1><br>  Wenn Sie mehr über die Kollisionserkennung und Partitionierung von Datenstrukturen erfahren möchten, empfehlen wir Ihnen, das Buch von Christer Erickson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Real-Time Collision Detection zu</a> lesen.  Viele Themen sind darin tief verwurzelt und gleichzeitig ist das Buch in einer sehr verständlichen Sprache verfasst.  Darüber hinaus können Kapitel separat gelesen werden.  Dies ist eine großartige Referenzquelle. <br><br><h1>  Fazit </h1><br>  Damit ist die Arbeit mit der Kollisionserkennung abgeschlossen.  Es ist jedoch nur die Hälfte des physischen Motors.  Die zweite Hälfte ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auflösung von Kollisionen</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473066/">https://habr.com/ru/post/de473066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473054/index.html">WorldSkills final, Entwicklung von IT-Lösungen für Unternehmen - was es ist, wie es war und warum 1C-Programmierer dort gewonnen haben</a></li>
<li><a href="../de473056/index.html">Wie Alice Länder anhand von Fotografien erkennt. Yandex-Forschung</a></li>
<li><a href="../de473058/index.html">Sergey Sinitsyn: „OSM ist mehr als nur das Zeichnen von Häusern oder Spuren. Das sind mehr Geschichten! “</a></li>
<li><a href="../de473062/index.html">Subjektive user.js für Mozilla Firefox und nicht nur</a></li>
<li><a href="../de473064/index.html">Batavianische Tränen, Autos und Gorilla-Glas: über einige Arten von verstärktem Glas</a></li>
<li><a href="../de473070/index.html">Redux - Nicht benötigt! Ersetzen durch useContext und useReducer in React?</a></li>
<li><a href="../de473072/index.html">Wie Gazpromneft einen digitalen Weg für einen Firmenkunden schafft</a></li>
<li><a href="../de473074/index.html">Was ist APS und warum wird ein Produktionsplan nicht so erstellt, wie wir es wollen ...</a></li>
<li><a href="../de473078/index.html">Verwalten Sie einfach Mikroservice-Konfigurationen mit microconfig.io</a></li>
<li><a href="../de473082/index.html">Wie wir Microservices schreiben und warum wir das nicht schnell machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>