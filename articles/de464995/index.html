<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú°Ô∏è üéÇ üèáüèª Wrap-Sequenzen in Swift üë®üèª‚Äçüé§ üéâ üè¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Heute m√∂chten wir die √úbersetzung teilen, die am Vorabend des Starts des Kurses ‚ÄûiOS Developer. Fortgeschrittenenkurs . ‚Äú Lass uns gehe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wrap-Sequenzen in Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/464995/"><p>  <em>Hallo an alle.</em>  <em>Heute m√∂chten wir die √úbersetzung teilen, die am Vorabend des Starts des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûiOS Developer.</a></em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortgeschrittenenkurs</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äú</a></em>  <em>Lass uns gehen!</em> </p><br><p><img src="https://habrastorage.org/webt/sk/fh/uc/skfhuco7bg9_mhjmpvov6ie9qao.png"></p><br><p>  Einer der Hauptvorteile des protokollbasierten Designs von Swift besteht darin, dass wir generischen Code schreiben k√∂nnen, der mit einer Vielzahl von Typen kompatibel ist, anstatt speziell f√ºr alle implementiert zu werden.  Insbesondere, wenn ein solcher allgemeiner Code f√ºr eines der Protokolle vorgesehen ist, die in der Standardbibliothek enthalten sind, sodass er sowohl mit integrierten als auch mit benutzerdefinierten Typen verwendet werden kann. </p><a name="habracut"></a><br><p>  Ein Beispiel f√ºr ein solches Protokoll ist Sequence, das von allen Arten von Standardbibliotheken akzeptiert wird, die iteriert werden k√∂nnen, z. B. Array, Dictionary, Set und viele andere.  Schauen wir uns diese Woche an, wie wir Sequence in universelle Container verpacken k√∂nnen, um verschiedene Algorithmen im Kern benutzerfreundlicher APIs zu kapseln. </p><br><h3 id="iskusstvo-byt-lenivym">  Die Kunst, faul zu sein </h3><br><p>  Es ist ziemlich leicht zu verwirren, wenn man denkt, dass alle Sequenzen dem Array √§hnlich sind, da alle Elemente beim Erstellen der Sequenz sofort in den Speicher geladen werden.  Da die einzige Anforderung des Sequenzprotokolls darin besteht, dass Empf√§nger iterieren k√∂nnen m√ºssen, k√∂nnen wir keine Annahmen dar√ºber treffen, wie Elemente einer unbekannten Sequenz geladen oder gespeichert werden. <br>  Wie wir beispielsweise in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swift Sequences: The Art of Being Lazy beschrieben haben</a> , k√∂nnen Sequenzen ihre Elemente manchmal tr√§ge laden - entweder aus Leistungsgr√ºnden oder weil nicht garantiert ist, dass die gesamte Sequenz in den Speicher passt.  Hier sind einige Beispiele f√ºr solche Sequenzen: </p><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,          ,           . let records = database.records(matching: searchQuery) //     ,       ,      . let folders = folder.subfolders //   ,     ,            . let nodes = node.children</span></span></code> </pre> <br><p>  Da alle oben genannten Sequenzen aus irgendeinem Grund faul sind, m√∂chten wir sie nicht in ein Array zwingen, indem wir beispielsweise Array (folder.subfolders) aufrufen.  M√∂glicherweise m√∂chten wir sie jedoch noch auf unterschiedliche Weise √§ndern und damit arbeiten. Schauen wir uns also an, wie wir dies tun k√∂nnen, indem wir eine Art Sequenz-Wrapper erstellen. </p><br><h3 id="sozdanie-osnovy">  Gr√ºndung der Stiftung </h3><br><p>  Beginnen wir mit der Erstellung eines Basistyps, mit dem wir alle Arten von praktischen APIs √ºber einer beliebigen Sequenz erstellen k√∂nnen.  Wir werden es WrappedSequence nennen, und es wird ein universeller Typ sein, der sowohl den Typ der Sequenz enth√§lt, die wir umschlie√üen, als auch den Typ des Elements, das unsere neue Sequenz erstellen soll. <br>  Das Hauptmerkmal unseres Wrappers wird seine IteratorFunction sein, mit der wir die Kontrolle √ºber die Suche nach der Basissequenz √ºbernehmen und den f√ºr jede Iteration verwendeten Iterator √§ndern k√∂nnen: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrappedSequence</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapped</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator: <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(wrapping wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>, iterator: @escaping <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrapped = wrapped <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator = iterator } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedIterator = wrapped.makeIterator() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator(&amp;wrappedIterator) } } }</code> </pre> <br><p>  <em>Wie Sie oben sehen k√∂nnen, verwendet Sequence ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Factory-Muster,</a> sodass f√ºr jede Sequenz eine neue Iteratorinstanz f√ºr jede Iteration erstellt wird - mithilfe der Methode makeIterator ().</em> </p><br><p>  Oben verwenden wir den AnyIterator-Typ der Standardbibliothek, einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterator vom Typ L√∂schen</a> , der jede grundlegende IteratorProtocol-Implementierung verwenden kann, um Elementwerte abzurufen.  In unserem Fall erstellen wir ein Element, indem wir unsere IteratorFunction aufrufen und als Argument unseren eigenen Iterator der umschlossenen Sequenz √ºbergeben. Da dieses Argument als inout markiert ist, k√∂nnen wir den Basisiterator innerhalb unserer Funktion √§ndern. </p><br><p>  Da WrappedSequence auch eine Sequenz ist, k√∂nnen wir alle damit verbundenen Funktionen der Standardbibliothek nutzen, z. B. iterieren oder ihre Werte mithilfe von map transformieren: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> folderNames = <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: folders) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator.next()?.name } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> folderNames { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uppercasedNames = folderNames.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.uppercased() }</code> </pre> <br><p>  Beginnen wir jetzt mit unserer neuen WrappedSequence! </p><br><h3 id="prefiksy-i-suffiksy">  Pr√§fixe und Suffixe </h3><br><p>  Wenn wir sehr oft mit Sequenzen arbeiten, besteht der Wunsch, ein Pr√§fix oder Suffix in die Sequenz einzuf√ºgen, mit der wir arbeiten - aber w√§re es nicht gro√üartig, wenn wir dies tun k√∂nnten, ohne die Hauptsequenz zu √§ndern?  Dies kann zu einer besseren Leistung f√ºhren und erm√∂glicht es uns, jeder Sequenz Pr√§fixe und Suffixe hinzuzuf√ºgen, und nicht nur allgemeinen Typen wie Array. </p><br><p>  Mit WrappedSequence k√∂nnen wir dies ganz einfach tun.  Alles, was wir tun m√ºssen, ist, Sequence mit einer Methode zu erweitern, die eine umschlossene Sequenz aus einem Array von Elementen erstellt, die als Pr√§fix eingef√ºgt werden sollen.  Wenn wir dann iterieren, beginnen wir, alle Pr√§fixelemente zu iterieren, bevor wir mit der Basissequenz fortfahren - wie folgt: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with prefixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prefixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,   ,   ,   : guard prefixIndex &gt;= prefixElements.count else { let element = prefixElements[prefixIndex] prefixIndex += 1 return element } //           : return iterator.next() } } }</span></span></code> </pre> <br><p>  <em>Oben verwenden wir einen Parameter mit einer variablen Anzahl von Argumenten (Hinzuf√ºgen ... zu seinem Typ), um die √úbertragung eines oder mehrerer Elemente an dieselbe Methode zu erm√∂glichen.</em> <br>  Auf die gleiche Weise k√∂nnen wir eine Methode erstellen, die am Ende der Sequenz einen bestimmten Satz von Suffixen hinzuf√ºgt - indem wir zuerst unsere eigene Iteration der Basissequenz durchf√ºhren und dann √ºber die Suffixelemente iterieren: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suffixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with suffixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> suffixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     nil      : guard suffixIndex &lt; suffixElements.count else { return nil } let element = suffixElements[suffixIndex] suffixIndex += 1 return element } return next } } }</span></span></code> </pre> <br><p>  Mit den beiden oben genannten Methoden k√∂nnen wir jetzt jeder gew√ºnschten Sequenz Pr√§fixe und Suffixe hinzuf√ºgen.  Hier einige Beispiele, wie unsere neuen APIs verwendet werden k√∂nnen: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//      : let allFolders = rootFolder.subfolders.prefixed(with: rootFolder) //       : let messages = inbox.messages.suffixed(with: composer.message) //       ,      : let characters = code.prefixed(with: "{").suffixed(with: "}")</span></span></code> </pre> <br><p>  Obwohl alle oben genannten Beispiele mit bestimmten Typen (wie Array und String) implementiert werden k√∂nnen, besteht der Vorteil der Verwendung unseres WrappedSequence-Typs darin, dass alles tr√§ge ausgef√ºhrt werden kann - wir f√ºhren keine Mutationen durch oder bewerten keine Sequenzen, um unsere hinzuzuf√ºgen Pr√§fixe oder Suffixe - die in leistungskritischen Situationen oder bei der Arbeit mit gro√üen Datenmengen sehr n√ºtzlich sein k√∂nnen. </p><br><h3 id="cegmentaciya">  Segmentierung </h3><br><p>  Als n√§chstes schauen wir uns an, wie wir Sequenzen umbrechen k√∂nnen, um segmentierte Versionen davon zu erstellen.  In bestimmten Iterationen reicht es nicht aus, das aktuelle Element zu kennen. M√∂glicherweise ben√∂tigen wir auch Informationen zu den n√§chsten und vorherigen Elementen. <br>  Wenn wir mit indizierten Sequenzen arbeiten, k√∂nnen wir dies h√§ufig mithilfe der enumerated () -API erreichen, die auch einen Sequenz-Wrapper verwendet, um Zugriff auf das aktuelle Element und seinen Index zu erhalten: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index, current) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list.items.enumerated() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previous = (index &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? list.items[index - <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = (index &lt; list.items.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ? list.items[index + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ... }</code> </pre> <br><p>  Die obige Technik ist jedoch nicht nur in Bezug auf den Aufruf ziemlich ausf√ºhrlich, sondern beruht auch auf der erneuten Verwendung von Arrays - oder zumindest einer Form von Sequenz, die uns zuf√§lligen Zugriff auf ihre Elemente erm√∂glicht -, dass viele Sequenzen, insbesondere faule, nicht willkommen. <br>  Verwenden wir stattdessen erneut unsere WrappedSequence, um einen Sequenz-Wrapper zu erstellen, der tr√§ge segmentierte Ansichten in seiner Basissequenz bereitstellt, fr√ºhere und aktuelle Elemente verfolgt und diese aktualisiert, w√§hrend sie weiter durchlaufen: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Segment</span></span> = ( previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span>, current: <span class="hljs-type"><span class="hljs-type">Element</span></span>, next: <span class="hljs-type"><span class="hljs-type">Element?</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segmented: <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Segment</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endReached = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,      ,   ,        ,     . guard !endReached, let element = current ?? iterator.next() else { return nil } let next = iterator.next() let segment = (previous, element, next) //     ,    ,      : previous = element current = next endReached = (next == nil) return segment } } }</span></span></code> </pre> <br><p>  Jetzt k√∂nnen wir die obige API verwenden, um eine segmentierte Version einer beliebigen Sequenz zu erstellen, wenn wir bei einer Iteration entweder vorw√§rts oder r√ºckw√§rts schauen m√ºssen.  Hier ist zum Beispiel, wie wir die Segmentierung verwenden k√∂nnen, damit wir leicht feststellen k√∂nnen, wann wir das Ende der Liste erreicht haben: </p><br><pre> <code class="plaintext hljs">for segment in list.items.segmented { addTopBorder() addView(for: segment.current) if segment.next == nil { //   ,     addBottomBorder() } } ```swift        ,   .    ,               : ```swift for segment in path.nodes.segmented { let directions = ( enter: segment.previous?.direction(to: segment.current), exit: segment.next.map(segment.current.direction) ) let nodeView = NodeView(directions: directions) nodeView.center = segment.current.position.cgPoint view.addSubview(nodeView) }</code> </pre> <br><p>  Jetzt beginnen wir, die wahre Kraft des Wickelns von Sequenzen zu erkennen - indem sie es uns erm√∂glichen, immer komplexere Algorithmen in einer wirklich einfachen API zu verbergen.  Alles, was der Aufrufer zum Segmentieren der Sequenz ben√∂tigt, ist der Zugriff auf die segmentierte Eigenschaft in einer beliebigen Sequenz, und unsere grundlegende Implementierung k√ºmmert sich um den Rest. </p><br><h3 id="rekursiya">  Rekursion </h3><br><p>  Schauen wir uns abschlie√üend an, wie selbst rekursive Iterationen mithilfe von Sequenz-Wrappern modelliert werden k√∂nnen.  Angenommen, wir m√∂chten eine einfache M√∂glichkeit bieten, eine Wertehierarchie rekursiv zu durchlaufen, in der jedes Element in der Hierarchie eine Folge von untergeordneten Elementen enth√§lt.  Es kann ziemlich schwierig sein, es richtig zu machen, daher w√§re es gro√üartig, wenn wir eine Implementierung verwenden k√∂nnten, um alle derartigen Iterationen in unserer Codebasis durchzuf√ºhren. <br>  Mit WrappedSequence k√∂nnen wir dies erreichen, indem wir Sequence um eine Methode erweitern, die dieselbe generische Typbeschr√§nkung verwendet, um sicherzustellen, dass jedes Element eine verschachtelte Sequenz mit demselben Iteratortyp wie unser Original bereitstellen kann.  Um dynamisch auf jede verschachtelte Sequenz zugreifen zu k√∂nnen, werden wir den Aufrufer au√üerdem bitten, KeyPath f√ºr die Eigenschaft anzugeben, die f√ºr die Rekursion verwendet werden soll. Dadurch erhalten wir eine Implementierung, die folgenderma√üen aussieht: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive</span></span></span><span class="hljs-function">&lt;S: Sequence&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> keyPath: KeyPath&lt;Element, S&gt; )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span> == <span class="hljs-type"><span class="hljs-type">Iterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentIterators = [<span class="hljs-type"><span class="hljs-type">Iterator</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; (iterator: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>, element: <span class="hljs-type"><span class="hljs-type">Element</span></span>)? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> !parentIterators.isEmpty <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iterator = parentIterators.removeLast() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//          ,    ,      : return moveUp() } return (iterator, element) } return WrappedSequence(wrapping: self) { iterator in //       ,      ,      : let element = iterator.next() ?? { return moveUp().map { iterator = $0 return $1 } }() //       ,  ,         ,         . if let nested = element?[keyPath: keyPath].makeIterator() { let parent = iterator parentIterators.append(parent) iterator = nested } return element } } }</span></span></code> </pre> <br><p>  Mit dem oben Gesagten k√∂nnen wir jetzt jede Sequenz rekursiv durchlaufen, unabh√§ngig davon, wie sie im Inneren aufgebaut ist, und ohne die gesamte Hierarchie im Voraus laden zu m√ºssen.  Hier ist beispielsweise, wie wir diese neue API verwenden k√∂nnen, um eine Ordnerhierarchie rekursiv zu durchlaufen: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allFolders = folder.subfolders.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subfolders) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> folder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allFolders { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> loadContent(from: folder) }</code> </pre> <br><p>  Wir k√∂nnen es auch verwenden, um √ºber alle Knoten des Baums zu iterieren oder eine Reihe von Datenbankdatens√§tzen rekursiv zu durchlaufen - um beispielsweise alle Benutzergruppen in einer Organisation aufzulisten: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allNodes = tree.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.children) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allGroups = database.groups.recusive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subgroups)</code> </pre> <br><p>  Eine Sache, bei der wir bei rekursiven Iterationen vorsichtig sein m√ºssen, ist die Vermeidung von Zirkelverweisen - wenn ein bestimmter Pfad uns zu einem Element zur√ºckf√ºhrt, auf das wir bereits gesto√üen sind -, was uns zu einer Endlosschleife f√ºhrt. <br>  Eine M√∂glichkeit, dies zu beheben, besteht darin, alle auftretenden Elemente im Auge zu behalten (dies kann jedoch aus Speichersicht problematisch sein), sicherzustellen, dass unser Datensatz keine Zirkelverweise enth√§lt, oder solche F√§lle jedes Mal von der Anrufseite aus zu behandeln (mithilfe von break, continue oder return, um alle zu vervollst√§ndigen) zyklische Iterationen). </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Sequence ist eines der einfachsten Protokolle in der Standardbibliothek - es erfordert nur eine Methode -, aber es ist immer noch eines der leistungsst√§rksten, insbesondere wenn es darum geht, wie viele Funktionen wir basierend darauf erstellen k√∂nnen.  So wie die Standardbibliothek Wrapper-Sequenzen f√ºr Aufz√§hlungen enth√§lt, k√∂nnen wir auch eigene Wrapper erstellen, mit denen wir erweiterte Funktionen mit wirklich einfachen APIs verbergen k√∂nnen. </p><br><p>  Obwohl Abstraktionen immer ihren Preis haben, ist es wichtig zu √ºberlegen, wann es sich lohnt (und vielleicht noch wichtiger, wenn es sich nicht lohnt), sie einzuf√ºhren, wenn wir unsere Abstraktionen direkt auf dem aufbauen k√∂nnen, was die Standardbibliothek bietet - unter Verwendung derselben Konventionen -, dann diese Abstraktionen halten sich normalerweise eher im Laufe der Zeit. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464995/">https://habr.com/ru/post/de464995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464985/index.html">Das Internet der Dinge (IoT) wird die Welt ver√§ndern. Zukunft des IoT</a></li>
<li><a href="../de464987/index.html">Repositories in Kubernetes: OpenEBS gegen Rook (Ceph) gegen Rancher Longhorn gegen StorageOS gegen Robin gegen Portworx gegen Linstor</a></li>
<li><a href="../de464989/index.html">Extravaganter Kontext</a></li>
<li><a href="../de464991/index.html">Projekte, die nicht gestartet sind</a></li>
<li><a href="../de464993/index.html">Erstellen eines RPM-Pakets f√ºr Rosa Linux in der Praxis</a></li>
<li><a href="../de464997/index.html">√úber die Entwicklung von VR-Technologien: Wo sie eingesetzt werden, warum VR-Gesch√§ft und welche Ger√§te</a></li>
<li><a href="../de464999/index.html">Wie sich die Besonderheiten der Arbeit mit Anwendungsservern am OpenLiberty-Beispiel √§ndern</a></li>
<li><a href="../de465001/index.html">Amazon Prime Day 2019 - Unterst√ºtzt von AWS</a></li>
<li><a href="../de465003/index.html">Interessen f√ºr das ARPG-Genre</a></li>
<li><a href="../de465007/index.html">Typechecking Django und DRF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>