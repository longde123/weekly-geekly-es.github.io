<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✡️ 🎂 🏇🏻 Wrap-Sequenzen in Swift 👨🏻‍🎤 🎉 🏴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Heute möchten wir die Übersetzung teilen, die am Vorabend des Starts des Kurses „iOS Developer. Fortgeschrittenenkurs . “ Lass uns gehe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wrap-Sequenzen in Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/464995/"><p>  <em>Hallo an alle.</em>  <em>Heute möchten wir die Übersetzung teilen, die am Vorabend des Starts des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„iOS Developer.</a></em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortgeschrittenenkurs</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">“</a></em>  <em>Lass uns gehen!</em> </p><br><p><img src="https://habrastorage.org/webt/sk/fh/uc/skfhuco7bg9_mhjmpvov6ie9qao.png"></p><br><p>  Einer der Hauptvorteile des protokollbasierten Designs von Swift besteht darin, dass wir generischen Code schreiben können, der mit einer Vielzahl von Typen kompatibel ist, anstatt speziell für alle implementiert zu werden.  Insbesondere, wenn ein solcher allgemeiner Code für eines der Protokolle vorgesehen ist, die in der Standardbibliothek enthalten sind, sodass er sowohl mit integrierten als auch mit benutzerdefinierten Typen verwendet werden kann. </p><a name="habracut"></a><br><p>  Ein Beispiel für ein solches Protokoll ist Sequence, das von allen Arten von Standardbibliotheken akzeptiert wird, die iteriert werden können, z. B. Array, Dictionary, Set und viele andere.  Schauen wir uns diese Woche an, wie wir Sequence in universelle Container verpacken können, um verschiedene Algorithmen im Kern benutzerfreundlicher APIs zu kapseln. </p><br><h3 id="iskusstvo-byt-lenivym">  Die Kunst, faul zu sein </h3><br><p>  Es ist ziemlich leicht zu verwirren, wenn man denkt, dass alle Sequenzen dem Array ähnlich sind, da alle Elemente beim Erstellen der Sequenz sofort in den Speicher geladen werden.  Da die einzige Anforderung des Sequenzprotokolls darin besteht, dass Empfänger iterieren können müssen, können wir keine Annahmen darüber treffen, wie Elemente einer unbekannten Sequenz geladen oder gespeichert werden. <br>  Wie wir beispielsweise in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swift Sequences: The Art of Being Lazy beschrieben haben</a> , können Sequenzen ihre Elemente manchmal träge laden - entweder aus Leistungsgründen oder weil nicht garantiert ist, dass die gesamte Sequenz in den Speicher passt.  Hier sind einige Beispiele für solche Sequenzen: </p><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,          ,           . let records = database.records(matching: searchQuery) //     ,       ,      . let folders = folder.subfolders //   ,     ,            . let nodes = node.children</span></span></code> </pre> <br><p>  Da alle oben genannten Sequenzen aus irgendeinem Grund faul sind, möchten wir sie nicht in ein Array zwingen, indem wir beispielsweise Array (folder.subfolders) aufrufen.  Möglicherweise möchten wir sie jedoch noch auf unterschiedliche Weise ändern und damit arbeiten. Schauen wir uns also an, wie wir dies tun können, indem wir eine Art Sequenz-Wrapper erstellen. </p><br><h3 id="sozdanie-osnovy">  Gründung der Stiftung </h3><br><p>  Beginnen wir mit der Erstellung eines Basistyps, mit dem wir alle Arten von praktischen APIs über einer beliebigen Sequenz erstellen können.  Wir werden es WrappedSequence nennen, und es wird ein universeller Typ sein, der sowohl den Typ der Sequenz enthält, die wir umschließen, als auch den Typ des Elements, das unsere neue Sequenz erstellen soll. <br>  Das Hauptmerkmal unseres Wrappers wird seine IteratorFunction sein, mit der wir die Kontrolle über die Suche nach der Basissequenz übernehmen und den für jede Iteration verwendeten Iterator ändern können: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrappedSequence</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapped</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator: <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(wrapping wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>, iterator: @escaping <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrapped = wrapped <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator = iterator } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedIterator = wrapped.makeIterator() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator(&amp;wrappedIterator) } } }</code> </pre> <br><p>  <em>Wie Sie oben sehen können, verwendet Sequence ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Factory-Muster,</a> sodass für jede Sequenz eine neue Iteratorinstanz für jede Iteration erstellt wird - mithilfe der Methode makeIterator ().</em> </p><br><p>  Oben verwenden wir den AnyIterator-Typ der Standardbibliothek, einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterator vom Typ Löschen</a> , der jede grundlegende IteratorProtocol-Implementierung verwenden kann, um Elementwerte abzurufen.  In unserem Fall erstellen wir ein Element, indem wir unsere IteratorFunction aufrufen und als Argument unseren eigenen Iterator der umschlossenen Sequenz übergeben. Da dieses Argument als inout markiert ist, können wir den Basisiterator innerhalb unserer Funktion ändern. </p><br><p>  Da WrappedSequence auch eine Sequenz ist, können wir alle damit verbundenen Funktionen der Standardbibliothek nutzen, z. B. iterieren oder ihre Werte mithilfe von map transformieren: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> folderNames = <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: folders) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator.next()?.name } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> folderNames { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uppercasedNames = folderNames.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.uppercased() }</code> </pre> <br><p>  Beginnen wir jetzt mit unserer neuen WrappedSequence! </p><br><h3 id="prefiksy-i-suffiksy">  Präfixe und Suffixe </h3><br><p>  Wenn wir sehr oft mit Sequenzen arbeiten, besteht der Wunsch, ein Präfix oder Suffix in die Sequenz einzufügen, mit der wir arbeiten - aber wäre es nicht großartig, wenn wir dies tun könnten, ohne die Hauptsequenz zu ändern?  Dies kann zu einer besseren Leistung führen und ermöglicht es uns, jeder Sequenz Präfixe und Suffixe hinzuzufügen, und nicht nur allgemeinen Typen wie Array. </p><br><p>  Mit WrappedSequence können wir dies ganz einfach tun.  Alles, was wir tun müssen, ist, Sequence mit einer Methode zu erweitern, die eine umschlossene Sequenz aus einem Array von Elementen erstellt, die als Präfix eingefügt werden sollen.  Wenn wir dann iterieren, beginnen wir, alle Präfixelemente zu iterieren, bevor wir mit der Basissequenz fortfahren - wie folgt: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with prefixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prefixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,   ,   ,   : guard prefixIndex &gt;= prefixElements.count else { let element = prefixElements[prefixIndex] prefixIndex += 1 return element } //           : return iterator.next() } } }</span></span></code> </pre> <br><p>  <em>Oben verwenden wir einen Parameter mit einer variablen Anzahl von Argumenten (Hinzufügen ... zu seinem Typ), um die Übertragung eines oder mehrerer Elemente an dieselbe Methode zu ermöglichen.</em> <br>  Auf die gleiche Weise können wir eine Methode erstellen, die am Ende der Sequenz einen bestimmten Satz von Suffixen hinzufügt - indem wir zuerst unsere eigene Iteration der Basissequenz durchführen und dann über die Suffixelemente iterieren: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suffixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with suffixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> suffixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     nil      : guard suffixIndex &lt; suffixElements.count else { return nil } let element = suffixElements[suffixIndex] suffixIndex += 1 return element } return next } } }</span></span></code> </pre> <br><p>  Mit den beiden oben genannten Methoden können wir jetzt jeder gewünschten Sequenz Präfixe und Suffixe hinzufügen.  Hier einige Beispiele, wie unsere neuen APIs verwendet werden können: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//      : let allFolders = rootFolder.subfolders.prefixed(with: rootFolder) //       : let messages = inbox.messages.suffixed(with: composer.message) //       ,      : let characters = code.prefixed(with: "{").suffixed(with: "}")</span></span></code> </pre> <br><p>  Obwohl alle oben genannten Beispiele mit bestimmten Typen (wie Array und String) implementiert werden können, besteht der Vorteil der Verwendung unseres WrappedSequence-Typs darin, dass alles träge ausgeführt werden kann - wir führen keine Mutationen durch oder bewerten keine Sequenzen, um unsere hinzuzufügen Präfixe oder Suffixe - die in leistungskritischen Situationen oder bei der Arbeit mit großen Datenmengen sehr nützlich sein können. </p><br><h3 id="cegmentaciya">  Segmentierung </h3><br><p>  Als nächstes schauen wir uns an, wie wir Sequenzen umbrechen können, um segmentierte Versionen davon zu erstellen.  In bestimmten Iterationen reicht es nicht aus, das aktuelle Element zu kennen. Möglicherweise benötigen wir auch Informationen zu den nächsten und vorherigen Elementen. <br>  Wenn wir mit indizierten Sequenzen arbeiten, können wir dies häufig mithilfe der enumerated () -API erreichen, die auch einen Sequenz-Wrapper verwendet, um Zugriff auf das aktuelle Element und seinen Index zu erhalten: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index, current) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list.items.enumerated() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previous = (index &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? list.items[index - <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = (index &lt; list.items.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ? list.items[index + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ... }</code> </pre> <br><p>  Die obige Technik ist jedoch nicht nur in Bezug auf den Aufruf ziemlich ausführlich, sondern beruht auch auf der erneuten Verwendung von Arrays - oder zumindest einer Form von Sequenz, die uns zufälligen Zugriff auf ihre Elemente ermöglicht -, dass viele Sequenzen, insbesondere faule, nicht willkommen. <br>  Verwenden wir stattdessen erneut unsere WrappedSequence, um einen Sequenz-Wrapper zu erstellen, der träge segmentierte Ansichten in seiner Basissequenz bereitstellt, frühere und aktuelle Elemente verfolgt und diese aktualisiert, während sie weiter durchlaufen: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Segment</span></span> = ( previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span>, current: <span class="hljs-type"><span class="hljs-type">Element</span></span>, next: <span class="hljs-type"><span class="hljs-type">Element?</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segmented: <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Segment</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endReached = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,      ,   ,        ,     . guard !endReached, let element = current ?? iterator.next() else { return nil } let next = iterator.next() let segment = (previous, element, next) //     ,    ,      : previous = element current = next endReached = (next == nil) return segment } } }</span></span></code> </pre> <br><p>  Jetzt können wir die obige API verwenden, um eine segmentierte Version einer beliebigen Sequenz zu erstellen, wenn wir bei einer Iteration entweder vorwärts oder rückwärts schauen müssen.  Hier ist zum Beispiel, wie wir die Segmentierung verwenden können, damit wir leicht feststellen können, wann wir das Ende der Liste erreicht haben: </p><br><pre> <code class="plaintext hljs">for segment in list.items.segmented { addTopBorder() addView(for: segment.current) if segment.next == nil { //   ,     addBottomBorder() } } ```swift        ,   .    ,               : ```swift for segment in path.nodes.segmented { let directions = ( enter: segment.previous?.direction(to: segment.current), exit: segment.next.map(segment.current.direction) ) let nodeView = NodeView(directions: directions) nodeView.center = segment.current.position.cgPoint view.addSubview(nodeView) }</code> </pre> <br><p>  Jetzt beginnen wir, die wahre Kraft des Wickelns von Sequenzen zu erkennen - indem sie es uns ermöglichen, immer komplexere Algorithmen in einer wirklich einfachen API zu verbergen.  Alles, was der Aufrufer zum Segmentieren der Sequenz benötigt, ist der Zugriff auf die segmentierte Eigenschaft in einer beliebigen Sequenz, und unsere grundlegende Implementierung kümmert sich um den Rest. </p><br><h3 id="rekursiya">  Rekursion </h3><br><p>  Schauen wir uns abschließend an, wie selbst rekursive Iterationen mithilfe von Sequenz-Wrappern modelliert werden können.  Angenommen, wir möchten eine einfache Möglichkeit bieten, eine Wertehierarchie rekursiv zu durchlaufen, in der jedes Element in der Hierarchie eine Folge von untergeordneten Elementen enthält.  Es kann ziemlich schwierig sein, es richtig zu machen, daher wäre es großartig, wenn wir eine Implementierung verwenden könnten, um alle derartigen Iterationen in unserer Codebasis durchzuführen. <br>  Mit WrappedSequence können wir dies erreichen, indem wir Sequence um eine Methode erweitern, die dieselbe generische Typbeschränkung verwendet, um sicherzustellen, dass jedes Element eine verschachtelte Sequenz mit demselben Iteratortyp wie unser Original bereitstellen kann.  Um dynamisch auf jede verschachtelte Sequenz zugreifen zu können, werden wir den Aufrufer außerdem bitten, KeyPath für die Eigenschaft anzugeben, die für die Rekursion verwendet werden soll. Dadurch erhalten wir eine Implementierung, die folgendermaßen aussieht: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive</span></span></span><span class="hljs-function">&lt;S: Sequence&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> keyPath: KeyPath&lt;Element, S&gt; )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span> == <span class="hljs-type"><span class="hljs-type">Iterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentIterators = [<span class="hljs-type"><span class="hljs-type">Iterator</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; (iterator: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>, element: <span class="hljs-type"><span class="hljs-type">Element</span></span>)? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> !parentIterators.isEmpty <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iterator = parentIterators.removeLast() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//          ,    ,      : return moveUp() } return (iterator, element) } return WrappedSequence(wrapping: self) { iterator in //       ,      ,      : let element = iterator.next() ?? { return moveUp().map { iterator = $0 return $1 } }() //       ,  ,         ,         . if let nested = element?[keyPath: keyPath].makeIterator() { let parent = iterator parentIterators.append(parent) iterator = nested } return element } } }</span></span></code> </pre> <br><p>  Mit dem oben Gesagten können wir jetzt jede Sequenz rekursiv durchlaufen, unabhängig davon, wie sie im Inneren aufgebaut ist, und ohne die gesamte Hierarchie im Voraus laden zu müssen.  Hier ist beispielsweise, wie wir diese neue API verwenden können, um eine Ordnerhierarchie rekursiv zu durchlaufen: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allFolders = folder.subfolders.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subfolders) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> folder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allFolders { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> loadContent(from: folder) }</code> </pre> <br><p>  Wir können es auch verwenden, um über alle Knoten des Baums zu iterieren oder eine Reihe von Datenbankdatensätzen rekursiv zu durchlaufen - um beispielsweise alle Benutzergruppen in einer Organisation aufzulisten: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allNodes = tree.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.children) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allGroups = database.groups.recusive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subgroups)</code> </pre> <br><p>  Eine Sache, bei der wir bei rekursiven Iterationen vorsichtig sein müssen, ist die Vermeidung von Zirkelverweisen - wenn ein bestimmter Pfad uns zu einem Element zurückführt, auf das wir bereits gestoßen sind -, was uns zu einer Endlosschleife führt. <br>  Eine Möglichkeit, dies zu beheben, besteht darin, alle auftretenden Elemente im Auge zu behalten (dies kann jedoch aus Speichersicht problematisch sein), sicherzustellen, dass unser Datensatz keine Zirkelverweise enthält, oder solche Fälle jedes Mal von der Anrufseite aus zu behandeln (mithilfe von break, continue oder return, um alle zu vervollständigen) zyklische Iterationen). </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Sequence ist eines der einfachsten Protokolle in der Standardbibliothek - es erfordert nur eine Methode -, aber es ist immer noch eines der leistungsstärksten, insbesondere wenn es darum geht, wie viele Funktionen wir basierend darauf erstellen können.  So wie die Standardbibliothek Wrapper-Sequenzen für Aufzählungen enthält, können wir auch eigene Wrapper erstellen, mit denen wir erweiterte Funktionen mit wirklich einfachen APIs verbergen können. </p><br><p>  Obwohl Abstraktionen immer ihren Preis haben, ist es wichtig zu überlegen, wann es sich lohnt (und vielleicht noch wichtiger, wenn es sich nicht lohnt), sie einzuführen, wenn wir unsere Abstraktionen direkt auf dem aufbauen können, was die Standardbibliothek bietet - unter Verwendung derselben Konventionen -, dann diese Abstraktionen halten sich normalerweise eher im Laufe der Zeit. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464995/">https://habr.com/ru/post/de464995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464985/index.html">Das Internet der Dinge (IoT) wird die Welt verändern. Zukunft des IoT</a></li>
<li><a href="../de464987/index.html">Repositories in Kubernetes: OpenEBS gegen Rook (Ceph) gegen Rancher Longhorn gegen StorageOS gegen Robin gegen Portworx gegen Linstor</a></li>
<li><a href="../de464989/index.html">Extravaganter Kontext</a></li>
<li><a href="../de464991/index.html">Projekte, die nicht gestartet sind</a></li>
<li><a href="../de464993/index.html">Erstellen eines RPM-Pakets für Rosa Linux in der Praxis</a></li>
<li><a href="../de464997/index.html">Über die Entwicklung von VR-Technologien: Wo sie eingesetzt werden, warum VR-Geschäft und welche Geräte</a></li>
<li><a href="../de464999/index.html">Wie sich die Besonderheiten der Arbeit mit Anwendungsservern am OpenLiberty-Beispiel ändern</a></li>
<li><a href="../de465001/index.html">Amazon Prime Day 2019 - Unterstützt von AWS</a></li>
<li><a href="../de465003/index.html">Interessen für das ARPG-Genre</a></li>
<li><a href="../de465007/index.html">Typechecking Django und DRF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>