<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüéì üôÖüèæ üìÑ Profundice en los espacios de nombres de Linux ‚ôíÔ∏è üò≠ üëÉüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En esta serie de publicaciones, consideraremos cuidadosamente uno de los ingredientes principales del contenedor : los espacios de nombres. En el proc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Profundice en los espacios de nombres de Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458462/"><p> En esta serie de publicaciones, consideraremos cuidadosamente uno de los ingredientes principales del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedor</a> : los espacios de nombres.  En el proceso, crearemos un clon m√°s simple del <code>docker run</code> : nuestro propio programa que tomar√° el comando (junto con sus argumentos, si los hay) en la entrada y expandir√° el contenedor para su ejecuci√≥n, aislado del resto del sistema, de forma similar a c√≥mo ejecutar√≠a <code>docker run</code> para correr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde una imagen</a> . <a name="habracut"></a></p><br><h2 id="chto-takoe-namespace">  ¬øQu√© es el espacio de nombres? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El espacio de nombres de Linux</a> es una abstracci√≥n de recursos en el sistema operativo.  Podemos pensar en el espacio de nombres como un cuadro.  Este cuadro contiene recursos del sistema que dependen del tipo de cuadro (espacio de nombres).  Actualmente hay siete tipos de espacios de nombres: Cgroups, IPC, Network, Mount, PID, User, UTS. </p><br><p>  Por ejemplo, el espacio de nombres de red incluye recursos del sistema relacionados con la red, tales como interfaces de red (por ejemplo, <code>wlan0</code> , <code>eth0</code> ), tablas de enrutamiento, etc., el espacio de nombres Mount incluye archivos y directorios en el sistema, PID contiene ID de proceso, etc. .  Por lo tanto, dos instancias del espacio de nombres de red <strong>A</strong> y <strong>B</strong> (correspondientes a dos cuadros del mismo tipo en nuestra analog√≠a) pueden contener diferentes recursos: quiz√°s <strong>A</strong> contiene <code>wlan0</code> , mientras que <strong>B</strong> contiene <code>eth0</code> y una copia separada de la tabla de enrutamiento. </p><br><p>  Los espacios de nombres no son una caracter√≠stica o biblioteca adicional que necesite instalar, por ejemplo, usando el administrador de paquetes apt.  Los proporciona el n√∫cleo de Linux y ya son una necesidad para ejecutar cualquier proceso en el sistema.  En cualquier momento dado, cualquier proceso <strong>P</strong> pertenece exactamente a una instancia de espacio de nombres de cada tipo.  Por lo tanto, cuando necesita decir "actualizar la tabla de enrutamiento en el sistema", Linux le muestra una copia de la tabla de enrutamiento del espacio de nombres a la que pertenece en ese momento. </p><br><h2 id="dlya-chego-eto-nuzhno">  ¬øPara qu√© es esto? </h2><br><p>  Absolutamente por nada ... por supuesto, solo estaba bromeando.  Una de las grandes propiedades de los cuadros es que puede agregar y quitar elementos del cuadro y esto no afectar√° el contenido de otros cuadros.  Esta es la misma idea con espacios de nombres: el proceso <strong>P</strong> puede "volverse loco" y ejecutar <code>sudo rm ‚Äìrf /</code> , pero otro proceso <strong>Q</strong> que pertenezca a otro espacio de nombres Mount no se ver√° afectado, ya que usan copias separadas de estos archivos. </p><br><p>  Tenga en cuenta que el recurso contenido en el espacio de nombres no es necesariamente una copia √∫nica.  En algunos casos que ocurrieron intencionalmente o debido a una violaci√≥n de seguridad, dos o m√°s espacios de nombres contendr√°n la misma copia, por ejemplo, el mismo archivo.  Por lo tanto, los cambios realizados en este archivo en un espacio de nombres de Mount ser√°n visibles en todos los dem√°s espacios de nombres de Mount, que tambi√©n se refieren a √©l.  Por lo tanto, abandonaremos nuestra analog√≠a del caj√≥n, ya que el art√≠culo no puede estar en dos cajas diferentes al mismo tiempo. </p><br><h2 id="ogranichenie---eto-zabota">  La restricci√≥n es una preocupaci√≥n </h2><br><p>  ¬°Podemos ver los espacios de nombres a los que pertenece el proceso!  Por lo general, para Linux, aparecen como archivos en el <code>/proc/$pid/ns</code> de este proceso con el id del proceso <code>$pid</code> : </p><br><pre> <code class="bash hljs">$ ls -l /proc/$$/ns total 0 lrwxrwxrwx 1 iffy iffy 0 May 18 12:53 cgroup -&gt; cgroup:[4026531835] lrwxrwxrwx 1 iffy iffy 0 May 18 12:53 ipc -&gt; ipc:[4026531839] lrwxrwxrwx 1 iffy iffy 0 May 18 12:53 mnt -&gt; mnt:[4026531840] lrwxrwxrwx 1 iffy iffy 0 May 18 12:53 net -&gt; net:[4026531957] lrwxrwxrwx 1 iffy iffy 0 May 18 12:53 pid -&gt; pid:[4026531836] lrwxrwxrwx 1 iffy iffy 0 May 18 12:53 user -&gt; user:[4026531837] lrwxrwxrwx 1 iffy iffy 0 May 18 12:53 uts -&gt; uts:[4026531838]</code> </pre> <br><p>  Puedes abrir otra terminal, ejecutar el mismo comando y esto deber√≠a darte el mismo resultado.  Esto se debe a que, como mencionamos anteriormente, el proceso debe pertenecer a un determinado espacio de nombres (espacio de nombres) y hasta que especifiquemos expl√≠citamente cu√°l, Linux lo agrega a los espacios de nombres de forma predeterminada. </p><br><p>  Vamos a involucrarnos un poco en esto.  En la segunda terminal, podemos hacer algo como esto: </p><br><pre> <code class="bash hljs">$ hostname iffy $ sudo unshare -u bash $ ls -l /proc/$$/ns lrwxrwxrwx 1 root root 0 May 18 13:04 cgroup -&gt; cgroup:[4026531835] lrwxrwxrwx 1 root root 0 May 18 13:04 ipc -&gt; ipc:[4026531839] lrwxrwxrwx 1 root root 0 May 18 13:04 mnt -&gt; mnt:[4026531840] lrwxrwxrwx 1 root root 0 May 18 13:04 net -&gt; net:[4026531957] lrwxrwxrwx 1 root root 0 May 18 13:04 pid -&gt; pid:[4026531836] lrwxrwxrwx 1 root root 0 May 18 13:04 user -&gt; user:[4026531837] lrwxrwxrwx 1 root root 0 May 18 13:04 uts -&gt; uts:[4026532474] $ hostname iffy $ hostname coke $ hostname coke</code> </pre> <br><p>  El comando <code>unshare</code> inicia el programa (opcional) en el nuevo espacio de nombres.  La bandera <code>-u</code> le dice que ejecute <code>bash</code> en el nuevo espacio de nombres UTS.  Tenga en cuenta que nuestro nuevo proceso <code>bash</code> apunta a otro archivo <code>uts</code> , mientras que todos los dem√°s siguen siendo los mismos. </p><br><blockquote>  <em>Crear nuevos espacios de nombres generalmente requiere acceso de superusuario.</em>  <code>unshare</code> <em>,</em> <em>asumiremos que tanto</em> <code>unshare</code> <em>como nuestra implementaci√≥n se realizan utilizando</em> <code>sudo</code> . </blockquote><p>  Una de las consecuencias de lo que acabamos de hacer es que ahora podemos cambiar el nombre de host del sistema de nuestro nuevo proceso bash y esto no afectar√° a ning√∫n otro proceso en el sistema.  Puede verificar esto ejecutando <code>hostname</code> en la primera terminal y viendo que el nombre de host no ha cambiado all√≠. </p><br><h2 id="no-chto-naprimer-takoe-konteyner">  Pero, ¬øqu√© es, por ejemplo, un contenedor? </h2><br><p>  Esperemos que ahora tenga alguna idea de lo que puede hacer el espacio de nombres.  Puede suponer que los contenedores son procesos esencialmente ordinarios con espacios de nombres que son diferentes de otros procesos, y tendr√° raz√≥n.  De hecho, esta es una cuota.  No se requiere que un contenedor sin cuotas pertenezca a un espacio de nombres √∫nico de cada tipo; puede compartir algunos de ellos. </p><br><p>  Por ejemplo, cuando escribe <code>docker run --net=host redis</code> , todo lo que debe hacer es decirle al docker que no cree un nuevo espacio de nombres de red para el proceso de redis.  Y, como hemos visto, Linux agregar√° este proceso como participante en el espacio de nombres de red predeterminado, como cualquier otro proceso regular.  Por lo tanto, desde el punto de vista de la red, el proceso de redis es exactamente el mismo que el de todos los dem√°s.  Esta no es solo una opci√≥n de configuraci√≥n de red, la <code>docker run</code> permite realizar dichos cambios para la mayor√≠a de los espacios de nombres existentes.  Esto plantea la pregunta, ¬øqu√© es un contenedor?  ¬øHay un contenedor que usa un proceso que usa todos menos uno del espacio de nombres com√∫n?  ¬Ø \ _ („ÉÑ) _ / ¬Ø Normalmente, los contenedores vienen con el concepto de <strong>aislamiento</strong> logrado a trav√©s de espacios de nombres: cuanto menor sea el n√∫mero de espacios de nombres y recursos que el proceso comparte con otros, m√°s est√° aislado y eso es todo lo que realmente importa. </p><br><h2 id="izolirovanie">  Aislamiento </h2><br><p>  En el resto de esta publicaci√≥n, sentaremos las bases para nuestro programa, que llamaremos <code>isolate</code> .  <code>isolate</code> toma el comando como argumentos y lo inicia en un nuevo proceso, aislado del resto del sistema y limitado por sus propios espacios de nombres.  En las siguientes publicaciones, veremos c√≥mo agregar soporte para espacios de nombres individuales para el comando de proceso que inicia los <code>isolate</code> . </p><br><p>  Dependiendo de la aplicaci√≥n, nos centraremos en los espacios de nombres de usuario, montaje, PID y red.  El resto ser√° relativamente trivial para implementar despu√©s de que terminemos (de hecho, agregaremos soporte UTS aqu√≠ en la implementaci√≥n inicial del programa).  Y la consideraci√≥n, por ejemplo, de Cgroups, est√° m√°s all√° del alcance de esta serie (el estudio de cgroups, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otro componente de los contenedores</a> utilizados para controlar la cantidad de recursos que puede utilizar un proceso). </p><br><p>  Los espacios de nombres pueden resultar muy r√°pidos y hay muchas formas diferentes que puede usar al explorar cada espacio de nombres, pero no podemos seleccionarlos todos a la vez.  Discutiremos solo aquellas formas que son relevantes para el programa que estamos desarrollando.  Cada publicaci√≥n comenzar√° con algunos experimentos en la consola en el espacio de nombres en cuesti√≥n para comprender los pasos necesarios para configurar este espacio de nombres.  Como resultado, ya tendremos una idea de lo que queremos lograr, y luego seguir√° la implementaci√≥n correspondiente <code>isolate</code> . </p><br><blockquote>  Para evitar la sobrecarga de c√≥digo de las publicaciones, no incluiremos elementos tales como funciones auxiliares que no son necesarias para comprender la implementaci√≥n.  Puede encontrar el c√≥digo fuente completo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ en Github</a> . </blockquote><br><h2 id="realizaciya">  Implementaci√≥n </h2><br><p>  El c√≥digo fuente de esta publicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se puede encontrar aqu√≠</a> .  Nuestra implementaci√≥n <code>isolate</code> ser√° un programa simple que lee una l√≠nea con un comando de stdin y clona un nuevo proceso que lo ejecuta con los argumentos especificados.  El proceso clonado con el comando se ejecutar√° en su propio espacio de nombres UTS de la misma manera que lo hicimos con <code>unshare</code> .  En las pr√≥ximas publicaciones veremos que los espacios de nombres no necesariamente funcionan (o al menos proporcionan aislamiento) del cuadro y necesitaremos realizar alguna configuraci√≥n despu√©s de crearlos (pero antes de ejecutar el comando), de modo que el comando realmente se ejecute de forma aislada. </p><br><p>  Esta combinaci√≥n de creaci√≥n de espacio de nombres requerir√° cierta interacci√≥n entre el proceso de <code>isolate</code> principal y el proceso secundario del comando a ejecutar.  Como resultado, parte del trabajo principal aqu√≠ ser√° configurar el canal de conexi√≥n entre ambos procesos; en nuestro caso, utilizaremos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tuber√≠a de Linux</a> debido a su simplicidad. </p><br><p>  Necesitamos hacer tres cosas: </p><br><ol><li>  Cree un proceso de <code>isolate</code> b√°sico que lea datos de stdin. </li><li>  Clone un nuevo proceso que ejecutar√° el comando en el nuevo espacio de nombres UTS. </li><li>  Configure la tuber√≠a para que el proceso de ejecuci√≥n del comando comience su lanzamiento solo despu√©s de recibir una se√±al del proceso principal de que la configuraci√≥n del espacio de nombres se ha completado. </li></ol><br><p>  Aqu√≠ est√° el proceso b√°sico: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;params, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct params)); parse_args(argc, argv, &amp;params); <span class="hljs-comment"><span class="hljs-comment">//         . if (pipe(params.fd) &lt; 0) die("Failed to create pipe: %m"); //   . int clone_flags = SIGCHLD | CLONE_NEWUTS ; int cmd_pid = clone(cmd_exec, cmd_stack + STACKSIZE, clone_flags, &amp;params); if (cmd_pid &lt; 0) die("Failed to clone: %m\n"); //      . int pipe = params.fd[1]; //      namespace ... //   ,     . if (write(pipe, "OK", 2) != 2) die("Failed to write to pipe: %m"); if (close(pipe)) die("Failed to close pipe: %m"); if (waitpid(cmd_pid, NULL, 0) == -1) die("Failed to wait pid %d: %m\n", cmd_pid); return 0; }</span></span></code> </pre> <br><p>  Tenga en cuenta los <code>clone_flags</code> que pasamos a nuestra llamada de <code>clone</code> .  ¬øVes lo f√°cil que es crear un proceso en su propio espacio de nombres?  Todo lo que necesitamos hacer es establecer un indicador para el tipo de espacio de nombres (el indicador <code>CLONE_NEWUTS</code> corresponde al espacio de nombres UTS), y Linux se encargar√° del resto. </p><br><p>  A continuaci√≥n, el proceso de comando espera una se√±al antes de comenzar: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmd_exec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   cmd   isolate . if (prctl(PR_SET_PDEATHSIG, SIGKILL)) die("cannot PR_SET_PDEATHSIG for child process: %m\n"); struct params *params = (struct params*) arg; //   ' '   . await_setup(params-&gt;fd[0]); char **argv = params-&gt;argv; char *cmd = argv[0]; printf("===========%s============\n", cmd); if (execvp(cmd, argv) == -1) die("Failed to exec %s: %m\n", cmd); die("¬Ø\\_(„ÉÑ)_/¬Ø"); return 1; }</span></span></code> </pre> <br><p>  Finalmente, podemos intentar ejecutar esto: </p><br><pre> <code class="bash hljs">$ ./isolate sh ===========sh============ $ ls isolate isolate.c isolate.o Makefile $ hostname iffy $ hostname coke $ hostname coke <span class="hljs-comment"><span class="hljs-comment">#     ,     </span></span></code> </pre> <br><p>  Ahora <code>isolate</code> es un poco m√°s que un programa que simplemente abandona al equipo (tenemos un UTS que funciona para nosotros).  En la pr√≥xima publicaci√≥n, daremos un paso m√°s al examinar los espacios de nombres de Usuario y hacer que <code>isolate</code> ejecute el comando en su propio espacio de nombres de Usuario.  All√≠ veremos que realmente necesitamos hacer algo de trabajo para tener un espacio de nombres utilizable en el que se pueda ejecutar el comando. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458462/">https://habr.com/ru/post/458462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458444/index.html">Internet para el residente de verano. Parte 4. Una tarjeta SIM es suficiente</a></li>
<li><a href="../458450/index.html">Caracter√≠sticas de las computadoras cu√°nticas.</a></li>
<li><a href="../458452/index.html">C√≥mo hacer una cocina de oficina a trav√©s de un enfoque de supermercado</a></li>
<li><a href="../458454/index.html">Alexey Savvateev: Modelos de Internet y redes sociales.</a></li>
<li><a href="../458458/index.html">C√°maras de profundidad: revoluci√≥n silenciosa (cuando los robots lo ver√°n) Parte 2</a></li>
<li><a href="../458464/index.html">Enlace gigabit de 3 km en m√≥dems l√°ser</a></li>
<li><a href="../458468/index.html">¬øC√≥mo ejecutar una impresionante reuni√≥n de Kanban StandUp?</a></li>
<li><a href="../458470/index.html">Texturizado, o lo que necesitas saber para convertirte en un Artista de Surface. Parte 2. M√°scaras y texturas.</a></li>
<li><a href="../458472/index.html">Compilaci√≥n de una clasificaci√≥n de territorios por el m√©todo de potenciales t√©rmicos utilizando datos abiertos</a></li>
<li><a href="../458474/index.html">Los mejores informes con HighLoad ++ 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>