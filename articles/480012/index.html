<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèæ üè† üàµ El formato Clang ralentiza el programa ‚ñ´Ô∏è üõ†Ô∏è üîÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy mediremos el rendimiento de diferentes implementaciones de la funci√≥n toupper, porque esto es lo que hacen los martes. 

 En realidad, no me impor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El formato Clang ralentiza el programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480012/">  Hoy mediremos el rendimiento de diferentes implementaciones de la funci√≥n toupper, porque esto es lo que hacen los martes. <br><br>  En realidad, no me importa la funci√≥n <a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>toupper</i></a> , acabo de escribir otra publicaci√≥n recientemente y necesitaba alg√∫n tipo de n√∫cleo de trama com√∫n, y <i>toupper</i> parece ser un candidato bastante interesante e inofensivo para los puntos de referencia.  Trat√© de elegir algo lo m√°s simple posible que no me llevara a un lado, pero sucedi√≥ que en esta prueba me encontr√© con un problema extra√±o. <br><a name="habracut"></a><br>  Esta publicaci√≥n ser√° peque√±a: pronto se espera un art√≠culo m√°s completo sobre el tema original, quiz√°s m√°s interesante.  Si quieres reproducir los resultados conmigo, puedes <a href="https://github.com/travisdowns/toupper-bench">tomar el</a> c√≥digo fuente <a href="https://github.com/travisdowns/toupper-bench">en github</a> . <br><br>  Por lo tanto, consideraremos tres implementaciones de la funci√≥n <i>toupper</i> , que convierte los caracteres de una matriz que consta de elementos de tipo <i>char</i> a may√∫sculas, es decir, toma una matriz como argumento y cambia directamente sus elementos para que todas las letras min√∫sculas est√©n en may√∫scula. <br><br>  En la primera implementaci√≥n, simplemente llamamos a <a href="https://linux.die.net/man/3/toupper">la funci√≥n toupper</a> [1] <a href="https://linux.die.net/man/3/toupper">de la</a> biblioteca est√°ndar C y ejecutamos un bucle de estilo C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_rawloop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(buf[i]); } }</code> </pre> <br>  En la segunda implementaci√≥n, utilizamos un enfoque <a href="https://www.youtube.com/watch%3Fv%3D2olsGf6JIkU">m√°s moderno</a> con la sustituci√≥n del ciclo sin procesar con <i>std :: transform</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(buf, buf + size, buf, ::<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>); }</code> </pre> <br>  Finalmente, en la tercera implementaci√≥n, usamos un algoritmo especial que funciona con caracteres ASCII.  Comprueba si el car√°cter est√° en el rango <i>a - z</i> , y si tiene √©xito, sustituye la misma letra en may√∫scula, restando el n√∫mero 32 del c√≥digo de car√°cter [2]: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = buf[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) { buf[i] = c - <span class="hljs-number"><span class="hljs-number">32</span></span>; } } }</code> </pre> <br>  Parece f√°cil, ¬øverdad? <br><br>  Ahora mediremos la velocidad de estas implementaciones en mi computadora port√°til con el procesador Skylake i7-6700HQ en el compilador gcc 5.5 con la configuraci√≥n predeterminada.  Los resultados se dan en forma de un gr√°fico de dispersi√≥n [3]: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/ps/uf/ecpsuf8lfb6dcp2empyh6vqbkco.png"></div><br>  Inmediatamente trataremos tres preguntas que son irrelevantes para nuestra tarea. <br><br>  Primero, mire la gr√°fica del algoritmo de ramificaci√≥n (que se muestra en verde).  Var√≠a significativamente seg√∫n el tama√±o de los datos de entrada: los otros dos gr√°ficos permanecen casi planos.  Esto es en realidad solo un artefacto de prueba.  Los caracteres ASCII de entrada se seleccionan aleatoriamente [4], por lo que el factor decisivo en el caso de la tercera implementaci√≥n es la operaci√≥n del algoritmo de predicci√≥n de rama.  Con una peque√±a cantidad de datos, memoriza completamente la secuencia de elementos a medida que se realiza la iteraci√≥n, por lo que el n√∫mero de errores es peque√±o y la velocidad es alta, <a href="https://lemire.me/blog/2019/10/16/benchmarking-is-hard-processors-learn-to-predict-branches/">como se muestra en esta nota</a> .  A medida que aumenta el tama√±o de la secuencia de datos, el algoritmo de predicci√≥n recuerda cada vez menos hasta que finalmente comienza a fallar con cada letra may√∫scula (0.27 errores por car√°cter), y luego el gr√°fico se nivela. <br><br>  En segundo lugar, preste atenci√≥n al grupo de puntos verdes en la <i>esquina</i> superior izquierda, que corresponde a velocidades mucho m√°s bajas de la variante con ramificaci√≥n <i>toupper_branch</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/b6/kj/by/b6kjbygj9inzadobigp0txj3vxu.png"></div><br>  Este no es un artefacto aislado: tales manchas aparecieron durante varios lanzamientos.  Al mismo tiempo, no se pueden reproducir si prueba el algoritmo solo espec√≠ficamente en estos tama√±os de datos; aparecen solo cuando la prueba se ejecuta en todos los tama√±os.  Pero en este caso, no siempre aparecen.  No profundic√© en ello, pero puedo suponer que esto se debe a algunos conflictos de nombres o alias en el algoritmo de predicci√≥n de rama o al mapear p√°ginas f√≠sicas de memoria de 4 kB a virtual (aunque la aleatorizaci√≥n del espacio de direcciones virtuales estaba desactivada). <br><br>  En tercer lugar, la implementaci√≥n de <i>toupper_rawloop</i> (que se muestra en azul) en el gr√°fico parece dos l√≠neas separadas: una ligeramente por encima de la marca de 2 medidas por car√°cter y la otra al nivel de 1,5 medidas por car√°cter.  Estas dos l√≠neas aparecieron en todos los probadores.  La opci√≥n m√°s r√°pida, con una velocidad de 1.57 caracteres por ciclo, en realidad se ralentiza en los puertos de descarga: la lectura de datos en los puertos 2 y 3 ocurre a una velocidad de 1.54 microoperaciones por ciclo, por lo que estar√°n ocupados al 98%.  No pude establecer la raz√≥n del "r√©gimen" m√°s lento. <br><br>  Mientras estaba lidiando con este problema, el "r√©gimen" r√°pido desapareci√≥ repentinamente y solo permaneci√≥ el lento.  Quiz√°s el procesador se dio cuenta de lo que estaba tratando de hacer y descarg√≥ secretamente la actualizaci√≥n del microc√≥digo para eliminar la contradicci√≥n, pero (todav√≠a) tengo pruebas: una imagen vectorial con gr√°ficos. <br><br>  ¬øQu√© nos interesa entonces en este ejemplo? <br><br>  Pero lo que nos interesa es que la versi√≥n con un ciclo "en bruto" es 3-4 veces m√°s r√°pida que la versi√≥n con <i>std :: transform</i> : 1.5-2 ciclos por car√°cter versus 7 con unos pocos ciclos por car√°cter. <br><br>  ¬øCu√°l es el problema aqu√≠?  ¬øMe han fallado los algoritmos est√°ndar?  ¬ø <i>Std :: transform</i> tiene alg√∫n defecto? <br><br>  En realidad no  M√°s precisamente, en absoluto. <br><br>  Resulta que tales resultados aparecen cuando las funciones se compilan en <a href="">diferentes archivos</a> .  Si los coloca en el mismo archivo, su rendimiento se vuelve igualmente bajo. <br><br>  Y no, la alineaci√≥n no tiene nada que ver con eso. <br><br>  Pero eso no es todo: la versi√≥n r√°pida con un ciclo "en bruto", cuando se compila en un archivo separado, se ralentiza si simplemente le adjunta el archivo de encabezado <i>&lt;algorithm&gt;</i> .  S√≠, es cierto: solo conecte este archivo, que nunca se usa y no genera ning√∫n c√≥digo en el archivo de objeto final, y la velocidad del ciclo "en bruto" caer√° 3-4 veces.  Por el contrario, la versi√≥n con <i>std :: transform se</i> acelera al l√≠mite si copia y pega la implementaci√≥n de <i>std :: transform</i> desde el archivo <i>&lt;algorithm&gt;</i> , pero no incluye este archivo. <br><br>  Las rarezas no terminan all√≠ (no habr√° m√°s, lo prometo): incluir el archivo <i>&lt;algorithm&gt;</i> no siempre conduce al efecto descrito.  Se produce una ca√≠da de velocidad si <i>&lt;algorithm&gt; est√°</i> conectado antes que <i>&lt;ctype.h&gt;</i> , pero si los intercambia, entonces no: <br><br>  <b>C√≥digo lento</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;ctype.h&gt;</span></span></span></span></code> </pre> <br>  <b>C√≥digo r√°pido:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctype.h&gt; #include &lt;algorithm&gt;</span></span></span></span></code> </pre> <br>  En realidad, esta anomal√≠a apareci√≥ en m√≠ (en otro proyecto) cuando el formato clang clasific√≥ autom√°ticamente los archivos de encabezado incluidos y coloc√≥ el <i>&lt;algoritmo&gt;</i> al comienzo de la lista, donde pertenece (de ah√≠ el encabezado clickbait del art√≠culo). <br><br>  Naturalmente, tuvimos que sumergirnos en la lista de ensambladores tarde o temprano.  No demoraremos este desagradable momento. <br><br>  Las versiones <a href="https://godbolt.org/z/DwZBJM">r√°pida y lenta</a> de las funciones [5] se muestran a continuaci√≥n, los bucles peque√±os cuentan con anotaciones: <br><br>  <b>&lt;algorithm&gt; conecta primero:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): push rbp push rbx lea rbp, [rdi+rsi] sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> test rsi, rsi je .L1 mov rbx, rdi .L5: movsx edi, BYTE PTR [rbx] ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  *buf add rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> ; buf++ call <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ;  <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(c) mov BYTE PTR [rbx<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;    buf[<span class="hljs-number"><span class="hljs-number">-1</span></span>] cmp rbp, rbx ;  buf == buf_end jne .L5 ; .L1: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp ret</code> </pre> <br>  <b>&lt;algorithm&gt; est√° conectado en segundo lugar:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): test rsi, rsi je .L7 push rbp push rbx mov rbp, rsi mov rbx, rdi sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> call __ctype_toupper_loc lea rsi, [rbx+rbp] mov rdi, rbx .L4: ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  buf movsx rcx, BYTE PTR [rdi] ;      <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ; (   __ctype_toupper_loc) mov rdx, QWORD PTR [rax] ; buf++ add rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>  , ;       mov edx, DWORD PTR [rdx+rcx*<span class="hljs-number"><span class="hljs-number">4</span></span>] mov BYTE PTR [rdi<span class="hljs-number"><span class="hljs-number">-1</span></span>], dl ;   cmp rsi, rdi ;  buf == end_buf jne .L4 ; add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp .L7: rep ret</code> </pre> <br>  La principal diferencia es que en la versi√≥n lenta la funci√≥n toupper simplemente se llama en un bucle, mientras que en la versi√≥n r√°pida las llamadas a funciones est√°n completamente ausentes, y solo hay una b√∫squeda en la tabla de correspondencia [6], es decir  el cuerpo de la funci√≥n <i>std :: toupper se</i> sustituye en el lugar de la llamada. <br><br>  Si observa el <a href="https://sourceware.org/git/%3Fp%3Dglibc.git%3Ba%3Dblob%3Bf%3Dctype/ctype.h%3Bh%3Dd17f727cf0dc2a0f6c62fa50aff799b175dcb426%3Bhb%3D2a764c6ee848dfe92cb2921ed3b14085f15d9e79">c√≥digo fuente de</a> la biblioteca glibc, encontramos la implementaci√≥n de la funci√≥n <i>toupper</i> all√≠: <br><br><pre> <code class="cpp hljs">__extern_inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// __NTH ‚Äì  , ,      __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; }</span></span></code> </pre> <br>  Como podemos ver, <i>toupper se</i> define como una funci√≥n en <i>l√≠nea externa</i> que primero verifica que el tama√±o del car√°cter char se ajuste a un byte [7], y luego busca el car√°cter en la tabla de correspondencia devuelta por la funci√≥n <i>__ctype_toupper_loc ()</i> .  Esta funci√≥n devuelve un puntero de flujo local (de tipo <i>const int **</i> ), que, a su vez, apunta a una tabla de correspondencia, desde la cual, en respuesta a una solicitud de nuestro s√≠mbolo, se devuelve su versi√≥n en may√∫scula [8]. <br><br>  Ahora est√° claro lo que est√° sucediendo en la lista.  En la versi√≥n r√°pida del algoritmo, el compilador sustituye el cuerpo de la funci√≥n <i>toupper</i> , pero no puede sustituir la llamada a la funci√≥n <i>__ctype_toupper_loc ()</i> [9].  Sin embargo, esta llamada se declara como <i>__attribute __ ((const))</i> , lo que significa que el valor de retorno depende solo de los argumentos (que no est√°n aqu√≠).  El compilador sabe que esta funci√≥n devuelve el mismo valor cada vez y, por lo tanto, lleva su llamada fuera del bucle, y en el bucle solo hay unas pocas operaciones de lectura asociadas con el acceso a la tabla de correspondencia, la escritura de un nuevo valor en el b√∫fer y el control del bucle. <br><br>  En la versi√≥n lenta, la llamada a <i>toupper ()</i> permanece en el cuerpo del bucle.  El ciclo en s√≠ mismo es m√°s corto por un comando, pero, por supuesto, ahora todav√≠a tiene que ejecutar todo el c√≥digo dentro de la funci√≥n <i>toupper</i> .  En mi sistema, se ve as√≠: <br><br><pre> <code class="cpp hljs"> lea edx,[rdi+<span class="hljs-number"><span class="hljs-number">0x80</span></span>] ; edx = rdi + <span class="hljs-number"><span class="hljs-number">0x80</span></span> movsxd rax,edi ;    c cmp edx,<span class="hljs-number"><span class="hljs-number">0x17f</span></span> ; ,  c     <span class="hljs-number"><span class="hljs-number">-128</span></span>  <span class="hljs-number"><span class="hljs-number">255</span></span> ja <span class="hljs-number"><span class="hljs-number">2</span></span>a ;  ,   mov rdx,QWORD PTR [rip+<span class="hljs-number"><span class="hljs-number">0x395f30</span></span>] ;    ;   mov rdx,QWORD PTR fs:[rdx] ;     ;     mov rdx,QWORD PTR [rdx] ;    ;    mov rdx,QWORD PTR [rdx+<span class="hljs-number"><span class="hljs-number">0x48</span></span>] ;     <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> mov eax,DWORD PTR [rdx+rax*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0x200</span></span>] ;  c   <span class="hljs-number"><span class="hljs-number">2</span></span>a: ret</code> </pre> <br>  Como se trata de una llamada no integrada, el programa realiza m√°s trabajo.  Hay al menos cinco operaciones consecutivas de acceso a la memoria (la llamada b√∫squeda de punteros, persecuci√≥n de punteros).  En la versi√≥n r√°pida, solo quedan dos, ya que todos los dem√°s se eliminan del bucle.  El retraso entre llamar a una funci√≥n y salir de ella deber√≠a ser de aproximadamente 25 ciclos, y tenemos aproximadamente 7 ciclos saliendo, esto significa que el procesador pudo paralelizar la llamada, lo cual es bastante bueno, dadas las circunstancias. <br><br>  ¬øPor qu√© es esto as√≠? <br><br>  En una larga cadena de archivos de inclusi√≥n, los archivos de encabezado C ++, como <i>&lt;algorithm&gt;</i> , incluyen, a su vez, el archivo <i>&lt;bits / os_defines.h&gt;</i> , que contiene la siguiente l√≠nea: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      isanum  .  //   . #define __NO_CTYPE 1</span></span></code> </pre> <br>  Cuando el archivo <i>&lt;ctype.h&gt;</i> finalmente se conecta, debido a esta directiva, el c√≥digo en el que <i>toupper se</i> define como <i>externo en l√≠nea</i> no se puede incluir: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined __NO_CTYPE # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __isctype_f __isctype_f (alnum) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ..  .. __isctype_f (xdigit) # elif defined __isctype # define isalnum(c) __isctype((c), _ISalnum) # define isalpha(c) __isctype((c), _ISalpha) //  ..  .. # endif //      # ifdef __USE_EXTERN_INLINES __extern_inline int __NTH (tolower (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_tolower_loc ())[__c] : __c; } __extern_inline int __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; } # endif //   tolower     # if __GNUC__ &gt;= 2 &amp;&amp; defined __OPTIMIZE__ &amp;&amp; !defined __cplusplus # define tolower(c) __tobody (c, tolower, *__ctype_tolower_loc (), (c)) # define toupper(c) __tobody (c, toupper, *__ctype_toupper_loc (), (c)) # endif /* Optimizing gcc */ #endif /* Not __NO_CTYPE. */</span></span></span></span></code> </pre> <br>  Tenga en cuenta que cuando se conecta <i>&lt;ctype.h&gt;, la</i> versi√≥n C ++ de <i>toupper</i> nunca se define como una macro, como m√°ximo en <i>l√≠nea</i> <i>externa</i> , ya que las definiciones de las macros est√°n protegidas por la <i>comprobaci√≥n! Defined __cplusplus</i> y, por lo tanto, nunca surtir√°n efecto. <br><br>  En general, no s√© con certeza si <i>__NO_CTYPE</i> en este caso deber√≠a excluir los cuerpos de las funciones <i>tolower</i> y <i>toupper</i> declaradas como en <i>l√≠nea externa</i> , pero esto es exactamente lo que sucede, y por lo tanto, una ca√≠da significativa en la velocidad de nuestro ciclo.  En conclusi√≥n, puedo decir que si incluye <i>&lt;cctype&gt; en</i> lugar de <i>&lt;ctype.h&gt;</i> (es decir, C ++ es la versi√≥n del archivo de encabezado C que pone funciones en el <i>espacio de nombres std ::)</i> , entonces en este caso el c√≥digo funcionar√° lentamente porque <i>&lt;cctype&gt;</i> finalmente incluye <i>&lt;bits / os_defines.h&gt;</i> . <br><br>  ¬øEs tan importante?  No no <br><br>  La funci√≥n <i>toupper</i> no es adecuada para trabajos serios con caracteres de diferentes idiomas, por lo que si necesita procesar solo caracteres ASCII, puede escribir su propia implementaci√≥n m√°s r√°pida.  Si necesita un trabajo serio con el texto, lo m√°s probable es que use UTF-8 y tenga que usar alg√∫n tipo de UCI para admitir configuraciones regionales, o esperar hasta que aparezca el soporte Unicode en C ++ (puede tomar mucho tiempo esperar) .  Por lo tanto, la declaraci√≥n "el formato clang puede causar una ca√≠da del rendimiento 4x" solo es adecuada como encabezado de clickbait. <br><br>  ¬øSe observa este efecto en todas las versiones de libc?  S√≠, en general, pero incluso aqu√≠ no es tan simple. <br><br>  Los resultados mostrados anteriormente son verdaderos para gcc 5.5 y glibc 2.23, porque us√© estas versiones, pero algo nuevo est√° sucediendo en las nuevas versiones (comenzando desde aproximadamente glibc 2.27).  All√≠, encender <i>&lt;algorithm&gt;</i> antes de <i>&lt;ctype.h&gt;</i> todav√≠a da el mismo efecto, pero ahora <i>&lt;stdlib.h&gt;</i> [10] tambi√©n crea problemas: si lo enciende antes de <i>&lt;ctype.h&gt;</i> , el rendimiento tambi√©n disminuir√°, lo que no es observado en versiones anteriores.  Obviamente, en versiones m√°s recientes, el archivo <i>&lt;stdlib.h&gt;</i> tambi√©n contiene la definici√≥n <i>__NO_CTYPE</i> .  Al menos, ahora no ser√° posible culpar al formato clang por la clasificaci√≥n, aqu√≠ solo puede ayudar a resolver el problema (si no hay otros archivos problem√°ticos en la lista de archivos conectados). <br><br>  Publiqu√© <a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D25214">un informe de error en libc</a> , por lo que es probable que este error se solucione, pero no hay duda de que los errores relacionados con el orden en que se conectan los archivos de encabezado nos molestar√°n a√∫n m√°s. <br><br><h2>  Comentarios </h2><br>  No tengo un sistema de comentarios en mi sitio, pero estoy trabajando en ello (es decir, quej√°ndose peri√≥dicamente, lo cual es dif√≠cil de hacer comentarios en un sitio est√°tico). <br><br>  Mientras tanto, puede discutir este art√≠culo en el sitio web de <a href="https://news.ycombinator.com/item%3Fid%3D21579333">Hacker News</a> o <a href="https://lobste.rs/s/tjxzck/clang_format_tanks_performance">lobste.rs</a> . <br><br><h2>  Agradecimientos </h2><br>  Gracias al usuario de ovnis con Hacker News, quien <a href="https://news.ycombinator.com/item%3Fid%3D21579483">se√±al√≥</a> que no es necesario usar la funci√≥n lambda para adaptar <i>std :: toupper</i> para usar en <i>std :: transform</i> , y tambi√©n a Jonathan Muller, quien <a href="https://twitter.com/foonathan/status/1197051249822195712">explic√≥</a> que la funci√≥n lambda todav√≠a es necesaria. <br><br><ol><li>  S√≠, la funci√≥n <i>toupper (3)</i> del archivo de encabezado <i>&lt;ctype.h&gt;</i> no es adecuada para trabajar con la mayor√≠a de los caracteres no ASCII, como  no puede manejar caracteres de m√°s de un byte, pero es adecuado para nuestra tarea, ya que solo le pasaremos cadenas de caracteres ASCII. </li><li>  En la tabla ASCII, los caracteres en may√∫sculas y min√∫sculas est√°n convenientemente ubicados, a una distancia de 32 posiciones entre s√≠, lo que significa que puede transferir caracteres de un caso a otro simplemente restando o sumando 32. En general, si supi√©ramos con certeza que todas las entradas los datos son letras ASCII, podr√≠amos restablecer el quinto bit sin ninguna verificaci√≥n (por ejemplo, <i>c &amp; 0b11011111</i> ) para convertir cualquier letra may√∫scula en min√∫scula, mientras que esto no se reflejar√≠a en letras min√∫sculas.  Pero probablemente no lo sepamos, por lo que debemos verificar si el car√°cter es una letra, para no romper accidentalmente caracteres que no sean letras como <i>char</i> . </li><li>  Deber√≠a llamarse un diagrama de dispersi√≥n con la adici√≥n de "ruido" a la ubicaci√≥n de los puntos.  De hecho, este es un diagrama de dispersi√≥n ordinario en el que el par√°metro de inter√©s para nosotros (el tama√±o de los datos de entrada) se traza en el eje x, y la velocidad de trabajo est√° en el eje y (medidas por s√≠mbolo: cuanto <i>menor es el valor, mayor es la velocidad</i> ).  La caracter√≠stica principal de este diagrama es que para cada valor de par√°metro en el eje x, el muestreo se realiza varias veces: en este caso, la prueba se repite 10 veces para cada tama√±o de matriz. </li><li>  Es decir, los caracteres se seleccionan aleatoria y uniformemente del rango [32, 127], por lo que la condici√≥n en la funci√≥n ser√° verdadera en aproximadamente el 27% de los casos. </li><li>  Ambos listados se refieren a una implementaci√≥n de ciclo sin procesar y difieren solo en el orden en que <i>se incluyen los archivos</i> <i>&lt;algorithm&gt;</i> y <i>&lt;ctype.h&gt;</i> .  El c√≥digo fuente generado es el mismo para todas las implementaciones, tanto en versiones r√°pidas como lentas.  Por ejemplo, una implementaci√≥n con <i>std :: transform</i> producir√° el mismo c√≥digo de ensamblador lento si incluye el archivo <i>&lt;algorithm&gt;</i> , y el mismo c√≥digo r√°pido si copia solo la definici√≥n de funci√≥n y no incluye el archivo. </li><li>  Sin embargo, este ciclo r√°pido es m√°s lento de lo que podr√≠a debido a que el puntero a la tabla de correspondencia se lee demasiadas veces ( <i>mov rdx, QWORD PTR [rax]</i> ) dentro del ciclo.  Este puntero puede ser diferente seg√∫n la configuraci√≥n regional, pero no se actualiza durante la ejecuci√≥n del ciclo y, por lo tanto, podr√≠a moverse fuera del ciclo.  Debe ser que el compilador cree que no hay suficientes razones para esto, ya que estamos escribiendo en una serie de elementos de tipo <i>char</i> , y en principio pueden usarse como alias para <i>[rax]</i> es decir  puntero a la mesa.  De todos modos, incluso <i>__restrict__</i> no ayudar√° aqu√≠.  Pero en otra versi√≥n del ciclo, donde los valores de <i>referencia</i> simplemente se agregan y no se escribe nada en la matriz, <a href="https://godbolt.org/z/Kb6pc8">se aplica esta optimizaci√≥n</a> : el puntero se lee fuera del ciclo. </li><li>  Esta comprobaci√≥n no se refleja en el c√≥digo del ensamblador sustituible, ya que el compilador ya sabe que los valores de caracteres siempre est√°n en el rango <i>[-128, 255]</i> .  La verificaci√≥n es necesaria solo porque la API de la funci√≥n <i>toupper ¬©</i> acepta un valor de tipo <i>int en</i> lugar de <i>char</i> , para que el usuario pueda pasar cualquier n√∫mero familiar de tipo <i>int</i> , mientras que las tablas de correspondencia est√°n dise√±adas solo para valores de tipo <i>char</i> , por lo que la comprobaci√≥n ayuda a evitar leer fuera del b√∫fer . </li><li>  Por cierto, esto explica por qu√© los procedimientos <i>std :: toupper</i> son independientes del tama√±o de los datos de entrada: no usan ramas (excepto para las comprobaciones de rango, que se predicen notablemente), sino que usan una tabla de correspondencia independiente de la rama.  <a href="https://habr.com/ru/company/pvs-studio/blog/480012/">‚Üµ</a> </li><li>  La sustituci√≥n de esta llamada no funcionar√° incluso con un deseo muy fuerte: el cuerpo de la funci√≥n no est√° disponible en el archivo de encabezado. </li><li>  De ninguna manera encuentro fallas en <i>stdlib.h</i> (o <i>&lt;algorithm&gt;</i> , para el caso): es muy posible que muchos otros archivos de encabezado C y todos los archivos de encabezado C ++ tambi√©n causen este comportamiento, simplemente no los prob√©.  <i>Conect√© stdlib.h</i> solo para determinar <i>size_t</i> . </li></ol><br>  <b>Nota</b>  Este art√≠culo se public√≥ por primera vez en el sitio web de <a href="https://travisdowns.github.io/blog/2019/11/19/toupper.html">Performance Matters</a> .  Los art√≠culos de traducci√≥n se publican aqu√≠ con permiso del autor. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480012/">https://habr.com/ru/post/480012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480000/index.html">Indicador de calidad del canal del servidor WebRTC sobre TCP</a></li>
<li><a href="../480002/index.html">Revise DevOpsDays Mosc√∫: ideas de 6 informes</a></li>
<li><a href="../480006/index.html">Indicador de calidad del canal para el servidor WebRTC sobre TCP</a></li>
<li><a href="../480008/index.html">Yuri Rogachev: "Vine a hacer el M-1, sin conocer la tecnolog√≠a inform√°tica"</a></li>
<li><a href="../480010/index.html">Los 3 principales elementos HTML que olvidamos</a></li>
<li><a href="../480016/index.html">El 39% de las pymes rusas se enfrentan a ciberataques selectivos</a></li>
<li><a href="../480018/index.html">Desarrollo de aplicaciones m√≥viles en Python. Biblioteca KivyMD</a></li>
<li><a href="../480022/index.html">Instanciaci√≥n de Python</a></li>
<li><a href="../480024/index.html">B√≠garo: procesador de una sola instrucci√≥n</a></li>
<li><a href="../480026/index.html">Anuncio de la vista previa de Azure Spot Virtual Machines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>