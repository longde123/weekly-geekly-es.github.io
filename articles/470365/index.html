<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè• üë¶üèª üêá Trabajando con USB HID personalizado en Android üßîüèæ ü•ï ‚ñ™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En las aplicaciones modernas de Android para interactuar con otros dispositivos, los protocolos de transferencia de datos inal√°mbricos, como Bluetooth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabajando con USB HID personalizado en Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470365/"><img src="https://habrastorage.org/webt/m_/bo/iw/m_boiwdburcpzcsf_ln5nhtqgju.png" alt="Dise√±ado por Freepik" align="left" width="50%"><br>  En las aplicaciones modernas de Android para interactuar con otros dispositivos, los protocolos de transferencia de datos inal√°mbricos, como Bluetooth, se usan con mayor frecuencia.  En los a√±os en que algunos dispositivos tienen carga inal√°mbrica, es dif√≠cil imaginar un mont√≥n de dispositivos y perif√©ricos Android, que requieren el uso de interfaces cableadas.  Sin embargo, cuando surge tal necesidad, USB viene inmediatamente a la mente. <br><br>  Tomemos un caso hipot√©tico con usted.  Imagine que un cliente acude a usted y le dice: ‚ÄúNecesito una aplicaci√≥n de Android para controlar un dispositivo de recopilaci√≥n de datos y mostrar estos datos en la pantalla.  Hay una PERO: la aplicaci√≥n debe estar escrita en una computadora de una sola placa con el sistema operativo Android, y el dispositivo perif√©rico est√° conectado a trav√©s de USB " <br><br>  Suena fant√°stico, pero a veces sucede.  Y aqu√≠ es muy √∫til tener un conocimiento profundo de la pila USB y sus protocolos, pero este art√≠culo no trata sobre eso.  En este art√≠culo, veremos c√≥mo controlar un dispositivo perif√©rico utilizando el protocolo USB HID personalizado desde un dispositivo Android.  Para simplificar, escribiremos una aplicaci√≥n de Android (HOST) que controlar√° el LED en el dispositivo perif√©rico (DISPOSITIVO) y recibir√° el estado del bot√≥n (presionar).  No voy a dar el c√≥digo de la placa perif√©rica, que est√°n interesados, escriba en los comentarios. <br><a name="habracut"></a><br>  Entonces comencemos. <br><br><h3>  Teor√≠a  Lo m√°s corto posible </h3><br>  Primero, una peque√±a teor√≠a, lo m√°s breve posible.  Este es un m√≠nimo simplificado, suficiente para comprender el c√≥digo, pero para una mejor comprensi√≥n, le aconsejo que se familiarice <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con este recurso</a> . <br><br>  Para comunicarse a trav√©s de USB en un dispositivo perif√©rico, debe implementar una interfaz de interacci√≥n.  Varias funciones (por ejemplo, USB HID, USB Mass Strorage o USB CDC) implementar√°n sus interfaces, y algunas tendr√°n varias interfaces.  Cada interfaz contiene puntos finales: canales de comunicaci√≥n especiales, una especie de portapapeles. <br><br>  Mi perif√©rico tiene un HID personalizado con una interfaz y dos puntos finales, uno para recibir y otro para transmitir.  Por lo general, la informaci√≥n con las interfaces y los puntos finales existentes en el dispositivo se escribe en la especificaci√≥n del dispositivo; de lo contrario, se puede determinar a trav√©s de programas especiales, por ejemplo, USBlyzer. <br><br>  Los dispositivos en USB HID se comunican a trav√©s de informes.  ¬øQu√© son los informes?  Dado que los datos se transmiten a trav√©s de los puntos finales, necesitamos identificarlos y analizarlos de alguna manera de acuerdo con el protocolo.  Los dispositivos no solo lanzan bytes de datos entre s√≠, sino que intercambian paquetes que tienen una estructura claramente definida, que se describe en el dispositivo en un descriptor de informe especial.  Por lo tanto, de acuerdo con el descriptor del informe, podemos determinar con precisi√≥n qu√© identificador, estructura, tama√±o y frecuencia de transmisi√≥n tienen ciertos datos.  El paquete se identifica por el primer byte, que es el ID del informe.  Por ejemplo, el estado del bot√≥n va al informe con ID = 1, y controlamos el LED a trav√©s del informe con ID = 2. <br><br><h3>  Lejos del hierro, m√°s cerca de Android </h3><br>  En Android, el soporte para dispositivos USB apareci√≥ a partir de la versi√≥n 12 de la API (Android 3.1). Para trabajar con un dispositivo perif√©rico, necesitamos implementar el modo host USB.  Trabajar con USB est√° bastante bien descrito en la documentaci√≥n. <br><br>  Primero debe identificar su dispositivo conectado, entre toda la variedad de dispositivos USB.  Los dispositivos USB se identifican mediante una combinaci√≥n de vid (identificaci√≥n del proveedor) y pid (identificaci√≥n del producto).  En la carpeta xml, cree el archivo device_filter.xml con el siguiente contenido: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">resources</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usb-device</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">vendor-id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1155"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">product-id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"22352"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">resources</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ahora debe realizar los permisos y la acci√≥n apropiados (si los necesita) en el manifiesto de la aplicaci√≥n: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uses-permission</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.USB_PERMISSION"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uses-feature</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.hardware.usb.host"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".MainActivity"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-ilter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.MAIN"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.LAUNCHER"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.hardware.usb.action.USB_DEVICE_ATTACHED"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/device_filter"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  En android: resource especificamos un archivo con los filtros necesarios para dispositivos.  Adem√°s, como dije anteriormente, puede asignar filtros de intenci√≥n para iniciar la aplicaci√≥n, por ejemplo, como resultado de conectar su dispositivo. <br><br>  Primero debe obtener el UsbManager, encontrar el dispositivo, la interfaz y los puntos finales del dispositivo.  Esto debe hacerse cada vez que se conecta el dispositivo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> usbManager = context.getSystemService(Context.USB_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UsbManager <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usbConnection: UsbDeviceConnection? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usbInterface: UsbInterface? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usbRequest: UsbRequest? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usbInEndpoint: UsbEndpoint? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usbOutEndpoint: UsbEndpoint? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deviceList = usbManager.deviceList <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (device <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> deviceList.values) { <span class="hljs-comment"><span class="hljs-comment">/*      VID  PID */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((device.vendorId == VENDOR_ID) and (device.productId == PRODUCT_ID)) { <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> usbInterface = device.getInterface(CUSTOM_HID_INTERFACE) <span class="hljs-comment"><span class="hljs-comment">/*            */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> until usbInterface!!.endpointCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usbInterface?.getEndpoint(idx)?.direction == USB_DIR_IN) usbInEndpoint = usbInterface?.getEndpoint(idx) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> usbOutEndpoint = usbInterface?.getEndpoint(idx) } usbConnection = usbManager.openDevice(device) usbConnection?.claimInterface(usbInterface, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) usbRequest = UsbRequest() usbRequest?.initialize(usbConnection, usbInEndpoint) } } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> usbConnection != <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre><br>  Aqu√≠ vemos las mismas interfaces y puntos finales que se discutieron en la √∫ltima secci√≥n.  Conociendo el n√∫mero de interfaz, encontramos ambos puntos finales, para recibir y transmitir, e iniciar una conexi√≥n usb.  Eso es todo, ahora puedes leer los datos. <br><br>  Como dije anteriormente, los dispositivos se comunican a trav√©s de informes. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ByteArray</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { usbConnection?.bulkTransfer(usbOutEndpoint, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.size, <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> buffer = ByteBuffer.allocate(REPORT_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> report = ByteArray(buffer.remaining()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usbRequest.queue(buffer, REPORT_SIZE)) { usbConnection?.requestWait() buffer.rewind() buffer.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(report, <span class="hljs-number"><span class="hljs-number">0</span></span>, report.size) buffer.clear() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> report }</code> </pre><br>  Enviamos una matriz de bytes al m√©todo sendReport, en el que el byte cero es el ID del informe, tomamos la conexi√≥n USB actual al dispositivo y realizamos la transferencia.  Como par√°metros, transferimos el n√∫mero de punto final, los datos, su tama√±o y el tiempo de espera de transmisi√≥n al m√©todo BulkTransfer.  Vale la pena se√±alar que la clase UsbDeviceConnection tiene m√©todos para implementar el intercambio de datos con un dispositivo USB: m√©todos bulkTransfer y controlTransfer.  Su uso depende del tipo de transmisi√≥n que admita un punto final.  En este caso, usamos bulkTransfer, aunque el uso de puntos finales con el tipo de control es m√°s t√≠pico para los HID.  Pero tenemos HID personalizado, por lo que hacemos lo que queremos.  Le aconsejo que lea sobre el tipo de transmisi√≥n por separado, ya que el volumen y la frecuencia de los datos transmitidos dependen de ello. <br><br>  Para recibir datos, debe conocer el tama√±o de los datos que se pueden obtener, c√≥mo saber de antemano y c√≥mo llegar desde el punto final. <br><br>  El m√©todo de recepci√≥n de datos a trav√©s de USB HID es sincr√≥nico y de bloqueo y debe realizarse en un hilo diferente, adem√°s, los informes del dispositivo pueden recibirse constantemente o en cualquier momento, por lo tanto, es necesario implementar una encuesta constante del informe para no perder los datos.  Hag√°moslo con RxJava: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Observable.fromCallable&lt;ByteArray&gt; { getReport() } .subscribeOn(Schedulers.io()) .observeOn(Schedulers.computation()) .repeat() .subscribe({ <span class="hljs-comment"><span class="hljs-comment">/* check it[0] (this is report id) and handle data */</span></span> },{ <span class="hljs-comment"><span class="hljs-comment">/* handle exeption */</span></span> }) }</code> </pre><br>  Habiendo recibido una matriz de bytes, debemos verificar el byte cero, ya que es un ID de informe y, de acuerdo con √©l, analizar los datos recibidos. <br><br>  Una vez completadas todas las acciones con USB, debe cerrar la conexi√≥n.  Puede hacer esto en la actividad onDestroy o en onCleared en ViewModel. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { usbRequest?.close() usbConnection?.releaseInterface(usbInterface) usbConnection?.close() }</code> </pre><br><h3>  Conclusi√≥n </h3><br>  El art√≠culo analiza un c√≥digo muy peque√±o y primitivo, extremadamente demostrativo con implementaci√≥n para un dispositivo espec√≠fico.  Por supuesto, hay muchas clases de USB, no solo HID, y para ellos, por supuesto, la implementaci√≥n ser√° diferente.  Sin embargo, todos los m√©todos est√°n bastante bien documentados y, al tener una buena comprensi√≥n de la pila USB, puede descubrir f√°cilmente c√≥mo usarlos. <br><br><h3>  X. Materiales √∫tiles. </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente del proyecto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">USB en una c√°scara de nuez</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n general del host USB</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470365/">https://habr.com/ru/post/470365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470353/index.html">Holivar Historia de Runet. Parte 4. Mail.ru: juegos, redes sociales, Durov</a></li>
<li><a href="../470355/index.html">Din√°mico en C #: recetas de uso</a></li>
<li><a href="../470357/index.html">Eventos digitales en Mosc√∫ del 7 al 13 de octubre.</a></li>
<li><a href="../470359/index.html">Noticias del mundo de OpenStreetMap No. 479 (17/09/2019 - 23/09/2019)</a></li>
<li><a href="../470361/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 383 (1 al 6 de octubre de 2019)</a></li>
<li><a href="../470367/index.html">Food Design Digest, septiembre de 2019</a></li>
<li><a href="../470373/index.html">PHP Digest No. 165 (23 de septiembre - 7 de octubre de 2019)</a></li>
<li><a href="../470375/index.html">Cuando se necesitan pruebas y pruebas autom√°ticas, una mirada desde el superesistema</a></li>
<li><a href="../470379/index.html">El problema de las tres monta√±as, la esquiva teor√≠a de la mente y el problema de periodizaci√≥n del desarrollo infantil.</a></li>
<li><a href="../470381/index.html">Estaci√≥n meteorol√≥gica aut√≥noma en el controlador ATMEGA328P y alimentada por bater√≠a con un sensor remoto inal√°mbrico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>