<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî° üç£ üè≠ Graph Node Dungeon Generator üõí ‚òÉÔ∏è üëåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Beitrag werde ich den Algorithmus zur prozeduralen Erzeugung von Ebenen eines zweidimensionalen Dungeons mit einer vorgegebenen Struktur bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Graph Node Dungeon Generator</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436198/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pt/uh/r0/ptuhr0jo9giaq3dkb15uiqlfp30.png" alt="Bild"></div><br>  In diesem Beitrag werde ich den Algorithmus zur prozeduralen Erzeugung von Ebenen eines zweidimensionalen Dungeons mit einer vorgegebenen Struktur beschreiben.  Im ersten Teil wird eine allgemeine Beschreibung und im zweiten Teil die Implementierung des Algorithmus vorgestellt. <br><br><h2>  Einf√ºhrung </h2><br>  Der Algorithmus wurde im Rahmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer Bachelorarbeit geschrieben</a> und basiert auf einem Artikel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ma et al. (2014)</a> .  Ziel der Arbeit war es, den Algorithmus zu beschleunigen und durch neue Funktionen zu erg√§nzen.  Ich bin sehr zufrieden mit dem Ergebnis, da wir den Algorithmus schnell genug gemacht haben, um ihn w√§hrend der Ausf√ºhrung des Spiels zu verwenden.  Nachdem wir die Bachelorarbeit abgeschlossen hatten, beschlossen wir, sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> umzuwandeln und an die Game-ON 2018-Konferenz zu senden. <br><br><h2>  Algorithmus </h2><br>  Um ein Spiellevel zu erstellen, erh√§lt der Algorithmus als Eingabe einen Satz polygonaler Bausteine ‚Äã‚Äãund ein Diagramm der Level-Konnektivit√§t (Level-Topologie).  Die Knoten des Diagramms geben die R√§ume an, und die Kanten bestimmen die Verbindungen zwischen ihnen.  Der Zweck des Algorithmus besteht darin, jedem Knoten des Diagramms die Form und Position des Raums zuzuweisen, so dass sich keine zwei Raumformen schneiden und jedes Paar benachbarter R√§ume durch T√ºren verbunden werden kann. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41f/ed9/68f/41fed968fc3150ffb6285e660ff2ec5c.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96a/68a/302/96a68a302c5af7bc046644a659f0cc81.png"></div><br>  (b) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc1/79e/c88/fc179ec88afc1fa1889937a2df25c029.png"></div><br>  (c) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9f/898/224/d9f8982240071dcb3d9205207912a46f.png"></div><br>  (d) <br><br>  Die Abbildungen (c) und (d) zeigen die Diagramme, die aus dem Eingabegraphen (a) und den Bausteinen (b) erzeugt wurden. <br><br>  Mithilfe des Konnektivit√§tsdiagramms kann ein Spieledesigner den Spielfluss einfach steuern.  Ben√∂tigen Sie einen gemeinsamen Weg zum Chefraum mit mehreren optionalen Seitenwegen?  Beginnen Sie einfach mit dem Pfaddiagramm und geben Sie dann einige Knoten an, in denen der Spieler w√§hlen kann: Gehen Sie entweder den Hauptpfad entlang oder erkunden Sie den Nebenpfad, wobei m√∂gliche Sch√§tze und / oder Monster darauf warten.  M√ºssen Sie den Weg abschneiden?  W√§hlen Sie einfach die beiden Knoten im Diagramm aus und f√ºgen Sie eine kurze Stra√üe hinzu, die sie verbindet.  Die M√∂glichkeiten dieses Schemas sind endlos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/044/41a/61904441a82fd281642664a0e784513d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/b4e/65e/9feb4e65e116328e42b3e9638911fae5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83c/fd9/d63/83cfd9d6388c784f88c818e7bc6c9513.png"></div><br>  <i>Beispiele f√ºr Eingabediagramme.</i>  <i>Der Hauptpfad ist rot dargestellt, die Hilfspfade sind blau, der kurze Pfad ist orange.</i> <br><br>  Der Algorithmus erm√∂glicht es Spieldesignern nicht nur, die Struktur der generierten Karten auf hoher Ebene zu verwalten, sondern bietet auch die M√∂glichkeit, das Erscheinungsbild einzelner R√§ume zu steuern und sie miteinander zu verbinden. <br><br><h3>  Unterschiedliche Formen f√ºr unterschiedliche R√§ume </h3><br>  Ich erw√§hnte den Chefraum am Ende des Levels.  Wir wollen nicht, dass der Chefraum wie ein anderer gew√∂hnlicher Raum aussieht, oder?  Mit dem Algorithmus k√∂nnen Sie Formulare f√ºr jeden Raum festlegen.  Zum Beispiel k√∂nnen wir einen Raum am Anfang des Levels und einen Chefraum erstellen, der ihre eigenen S√§tze von Raumformen haben sollte, und einen gemeinsamen Satz f√ºr alle anderen R√§ume. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/988/e05/e1f988e05bf84eea4209c128ac0b9e60.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f97/b39/b15/f97b39b15661d51ad7cf3a30a4e9b80a.png"></div><br>  Zwei aus dem Eingangsgraphen erzeugte Schaltkreise, in denen der Raumnummer 8 eine spezielle Form von R√§umen zugeordnet ist. <br><br><h3>  Explizit angegebene T√ºrpositionen </h3><br>  Stellen Sie sich vor, Sie haben ein hochwertiges Boss-Meeting-Skript und der Spieler muss den Raum des Chefs von einem bestimmten Pl√§ttchen aus betreten.  Oder wir haben eine Raumvorlage, in der einige Fliesen f√ºr W√§nde und andere Hindernisse reserviert sind.  Mit dem Algorithmus k√∂nnen Designer m√∂gliche T√ºrpositionen f√ºr einzelne Raumformen explizit festlegen. <br><br>  Aber manchmal kann das Ziel das Gegenteil sein.  Wir k√∂nnen Raumvorlagen so erstellen, dass die T√ºren zu ihnen fast √ºberall sein k√∂nnen.  Aus diesem Grund legen wir dem Algorithmus weniger Einschr√§nkungen auf, daher l√§uft er h√§ufig schneller und die erzeugten Schaltkreise wirken m√∂glicherweise weniger eint√∂nig und organischer.  In solchen Situationen kann einfach die L√§nge der T√ºren angegeben werden und wie weit sie von den Ecken entfernt sein sollten.  Der Abstand von den Ecken ist eine Art Kompromiss zwischen der manuellen Anordnung aller T√ºren und dem Vorhandensein von T√ºren √ºberall. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/cf8/05f/13dcf805f54ce10ad637ce1c6e298b28.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/e9f/51e/7bee9f51e10cda43d07163e27f7ff1dd.png"></div><br>  (b) <br><br>  Abbildung (a) zeigt die verschiedenen Arten der T√ºrplatzierung: Ein quadratischer Raum hat 8 klar definierte T√ºrpositionen, und ein rechteckiger Raum verwendet L√§nge und Abstand von den Ecken.  Abbildung (b) zeigt ein einfaches generiertes Diagramm mit den Formen der R√§ume in Abbildung (a). <br><br><h3>  Korridore zwischen den Zimmern </h3><br>  Wenn wir √ºber Dungeonebenen sprechen, stellen wir uns oft R√§ume vor, die durch enge Korridore verbunden sind.  Ich w√ºrde gerne annehmen, dass die Verbindungen im Eingabediagramm die Korridore anzeigen, aber sie sind es nicht.  Sie garantieren einfach, dass alle benachbarten Knoten direkt durch T√ºren verbunden werden.  Wenn wir m√∂chten, dass die R√§ume durch Korridore verbunden sind, m√ºssen wir einen neuen Knoten zwischen allen benachbarten Raumpaaren einf√ºgen und so tun, als w√§ren dies Korridorr√§ume (mit bestimmten Raumformen und bestimmten T√ºrpositionen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/56a/2b3/b5956a2b30f27882272fa44fe540f0bb.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbc/91d/b4e/fbc91db4e3beec215ad06cc7799cc56a.png"></div><br>  (b) <br><br>  Eine Illustration, wie wir das Eingabediagramm √§ndern k√∂nnen, um Korridore zwischen R√§umen hinzuzuf√ºgen.  Abbildung (a) zeigt das Eingabediagramm vor dem Hinzuf√ºgen der Korridorr√§ume.  Abbildung (b) zeigt das aus (a) erstellte Eingabediagramm, indem neue R√§ume zwischen allen benachbarten R√§umen des urspr√ºnglichen Diagramms hinzugef√ºgt werden. <br><br>  Leider erschwert dies die Aufgabe des Algorithmus erheblich, da sich die Anzahl der Knoten h√§ufig verdoppelt.  Aus diesem Grund habe ich eine Version des Algorithmus implementiert, die Korridore ber√ºcksichtigt und es erm√∂glicht, den Leistungsabfall beim Anordnen von Korridorr√§umen zu verringern.  Im Moment unterst√ºtzt der Algorithmus entweder Korridore zwischen allen R√§umen oder das v√∂llige Fehlen von Korridoren, aber in Zukunft plane ich, ihn flexibler zu gestalten. <br><br><h2>  Beispiele </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/c4c/b17/b01c4cb173e0b315ce81c842a617e32c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2b/5a0/5aa/a2b5a05aa014d12b0fc70d23a540997d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/5b7/de6/3055b7de654c62dc96c1e83ad510e199.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80e/d9e/b26/80ed9eb26994f6b395e9fa2af34b6dce.png"></div><br>  <i>Mehrere Schemata, die aus verschiedenen Bausteins√§tzen und mit aktivierten Korridoren generiert wurden.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/738/8a4/a44/7388a4a4466fe32fc9b9975e71473936.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1e/1ed/95b/c1e1ed95b4a9236c02fc11ed1bb33ed9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/628/f19/025/628f19025acf78eed8aa199347804f9e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa7/7e5/03d/aa77e503dbb791e78189777bc875e2cd.png"></div><br>  <i>Mehrere Schemata, die aus verschiedenen Bausteins√§tzen mit ein- und ausgeschalteten Korridoren generiert wurden.</i> <br><br>  Im zweiten Teil des Beitrags werde ich √ºber die interne Funktionsweise des Algorithmus sprechen. <br><br>  Ich arbeite auch an einem Unity-Plugin f√ºr die prozedurale Dungeon-Generierung, das diesen Algorithmus enthalten wird.  Ich mache das, weil trotz der M√∂glichkeit, diesen Algorithmus direkt in Unity zu verwenden (er ist in C # geschrieben), die Bequemlichkeit, damit zu arbeiten, alles andere als ideal ist.  Das Erstellen von Raumvorlagen ohne GUI nimmt viel Zeit in Anspruch, und es wird viel Code ben√∂tigt, um die Ausgabe des Algorithmus in die im Spiel verwendete Darstellung zu konvertieren. <br><br>  Da ich selbst kein Spieleentwickler bin, ist es mein Ziel, das Plugin so gut zu machen, dass andere es verwenden k√∂nnen.  Wenn alles gut geht, werde ich versuchen, Updates zu ver√∂ffentlichen, wenn ich etwas Interessantes zu sagen habe.  Ich habe bereits einige Ideen zum Generator selbst und zum Testen seiner F√§higkeiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d12/43f/2c0/d1243f2c05e18826eb3d97a30b6f743c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ed/34f/05c/7ed34f05ca19aa127aae0938e26d63ec.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/d48/39f/ad4d4839f9ca1c333c2fbb3e0333989e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0e/805/121/c0e805121b2cda153980875d780d5f9b.png"></div><br>  <i>Screenshots des Unity-Plugins (das Projekt befindet sich in der Entwicklung)</i> <br><br><h2>  Teil 2. Implementierung des Algorithmus </h2><br>  In diesem Teil werde ich √ºber die Grundideen sprechen, die in der Grundlage des im ersten Teil des Beitrags beschriebenen Algorithmus festgelegt wurden.  Zun√§chst wollte ich die grundlegenden Konzepte sowie die wichtigsten Verbesserungen beschreiben, die erforderlich sind, damit der Algorithmus schnell genug ist.  Wie sich jedoch herausstellte, sind selbst die Grundkonzepte f√ºr diesen Beitrag mehr als ausreichend.  Aus diesem Grund habe ich beschlossen, Leistungsverbesserungen in einem zuk√ºnftigen Artikel aufzuzeigen. <br><br><h2>  Motivation </h2><br>  Bevor ich zur Implementierung √ºbergehe, m√∂chte ich das Ergebnis dessen zeigen, was wir tun werden.  Das folgende Video zeigt 30 verschiedene Schaltkreise, die aus einem Eingangsgraphen und einem Satz von Bausteinen generiert wurden.  Der Algorithmus stoppt nach dem Erzeugen der Schaltung immer f√ºr 500 ms und versucht dann, die n√§chste zu erzeugen. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterst√ºtzt kein HTML5-Video. <source src="https://ondra.nepozitek.cz/blog/wp-content/uploads/2019/01/GeneratorWindow-12_01_2019-23_48_40.mp4" type="video/mp4"></video></div></div></div><br><h2>  Wie funktioniert es? </h2><br>  Der Zweck des Algorithmus besteht darin, jedem Knoten im Diagramm die Form und Position des Raums zuzuweisen, sodass sich keine zwei R√§ume schneiden und benachbarte R√§ume durch T√ºren verbunden sind. <br><br>  Eine M√∂glichkeit, dies zu erreichen, besteht darin, alle m√∂glichen Kombinationen von Raumformen und deren Positionen auszuprobieren.  Wie Sie vielleicht erraten haben, wird dies jedoch sehr ineffizient sein, und wir werden wahrscheinlich keine Schaltungen erzeugen k√∂nnen, selbst wenn sehr einfache Eingabegraphen verwendet werden. <br><br>  Anstatt nach allen m√∂glichen Kombinationen zu suchen, berechnet der Algorithmus, wie alle einzelnen R√§ume (die sogenannten Konfigurationsr√§ume) korrekt verbunden werden, und verwendet diese Informationen, um die Suche zu steuern.  Leider ist es trotz dieser Informationen immer noch schwierig, das richtige Schema zu finden.  F√ºr eine effektive Untersuchung des Suchraums verwenden wir daher eine probabilistische Optimierungstechnik (in diesem Fall eine Tempersimulation).  Zur weiteren Beschleunigung der Optimierung teilen wir die Eingabeaufgabe in kleinere und einfacher zu l√∂sende Unteraufgaben auf.  Dies erfolgt durch Aufteilen des Diagramms in kleinere Teile (als Ketten bezeichnet) mit anschlie√üender Erstellung von Schemata f√ºr jeden von ihnen in der angegebenen Reihenfolge. <br><br><h2>  Konfigurationsbereiche </h2><br>  F√ºr ein Paar von Polygonen, in denen eines an Ort und Stelle fixiert ist und das andere sich frei bewegen kann, ist der Konfigurationsraum die Menge der Positionen eines freien Polygons, an denen sich zwei Polygone nicht schneiden und durch T√ºren verbunden werden k√∂nnen.  Bei der Arbeit mit Polygonen kann jeder Konfigurationsraum als m√∂glicherweise leerer Satz von Linien dargestellt und mit einfachen geometrischen Werkzeugen berechnet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/823/45e/13482345ed98c982677a10e53ddaec2d.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8c/1eb/62c/b8c1eb62c2f6d8f166670781dfe35336.png"></div><br>  (b) <br><br>  Raumkonfigurationen.  Abbildung (a) zeigt den Konfigurationsraum (rote Linien) eines freien Rechtecks ‚Äã‚Äãrelativ zu einem festen L-f√∂rmigen Polygon.  Es bestimmt alle Positionen der Mitte des Quadrats, an denen sich die beiden Bl√∂cke nicht schneiden und ber√ºhren.  Abbildung (b) zeigt den Schnittpunkt (gelbe Punkte) der Konfigurationsr√§ume eines sich bewegenden Quadrats in Bezug auf zwei feste Rechtecke. <br><br>  Der folgende Algorithmus wird verwendet, um den Konfigurationsraum eines festen und eines freien Blocks zu berechnen.  Wir w√§hlen einen Referenzpunkt auf dem beweglichen Block aus und ber√ºcksichtigen alle Positionen in <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi><mi>b</mi><msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>R</mi></mrow><mn>2</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.843ex" height="2.539ex" viewBox="0 -987.6 4668.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6D" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="1128" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-74" x="1658" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-68" x="2019" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-62" x="2596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-62" x="3025" y="0"></use><g transform="translate(3455,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-52" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMAIN-32" x="1074" y="581"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi><mi>b</mi><msup><mrow class="MJX-TeXAtom-ORD"><mi>R</mi></mrow><mn>2</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ mathbb {R} ^ 2 </script>  , so dass sich beim Verschieben des Polygons so, dass sich sein Referenzpunkt an dieser Stelle befindet, sowohl der bewegliche als auch der feste Block ber√ºhren, sich jedoch nicht schneiden.  Die Menge all dieser Punkte bildet den Konfigurationsraum von zwei Bl√∂cken (Abbildung (a) oben).  Um den Konfigurationsraum des sich bewegenden Blocks relativ zu zwei oder mehr festen Bl√∂cken zu erhalten, wird der Schnittpunkt der einzelnen Konfigurationsr√§ume berechnet (Abbildung (b) oben). <br><br>  Der Algorithmus verwendet Konfigurationsr√§ume auf zwei Arten.  Anstatt die zuf√§lligen Positionen einzelner R√§ume auszuprobieren, verwenden wir zun√§chst Konfigurationsr√§ume, um nach Positionen zu suchen, die zu einer m√∂glichst gro√üen Anzahl benachbarter R√§ume f√ºhren, die durch die T√ºren verbunden sind.  Dazu m√ºssen wir den maximalen nicht leeren Schnittpunkt der Konfigurationsr√§ume der Nachbarn erhalten.  Zweitens verwenden wir Konfigurationsr√§ume, um zu pr√ºfen, ob alle Paare benachbarter R√§ume mit T√ºren verbunden werden k√∂nnen.  Dies erfolgt durch √úberpr√ºfen, ob sich die Position des Raums innerhalb des Konfigurationsraums aller seiner Nachbarn befindet. <br><br>  Da sich die Formen der R√§ume w√§hrend der Ausf√ºhrung des Spiels nicht √§ndern, k√∂nnen wir die Konfigurationsr√§ume aller Paare von Raumformen vor dem Start des Algorithmus vorberechnen.  Dadurch wird der gesamte Algorithmus erheblich beschleunigt. <br><br><h2>  Inkrementelles Schema </h2><br>  Bei der L√∂sung eines komplexen Problems besteht einer der m√∂glichen Ans√§tze darin, es in kleinere und einfachere Teilaufgaben zu unterteilen und diese bereits zu l√∂sen.  Genau das tun wir mit der Aufgabe, einzelne R√§ume zu platzieren.  Anstatt alle R√§ume gleichzeitig anzuordnen, teilen wir das Eingabediagramm in kleinere Untergraphen auf und versuchen, daraus nacheinander Diagramme zu erstellen.  Die Autoren des urspr√ºnglichen Algorithmus nennen diese Untergraphen aufgrund des Prinzips dieser Graphen, in denen jeder Knoten nicht mehr als zwei Nachbarn hat, "Ketten", und daher ist es recht einfach, ihr Schema zu erstellen. <br><br>  Die endg√ºltige Ausgangsschaltung ist immer eine verbundene Komponente, daher ist es nicht sinnvoll, die einzelnen Komponenten in die Schaltung einzubinden und dann zu versuchen, sie zu kombinieren, da der Kombinationsprozess sehr kompliziert sein kann.  Daher ist nach dem Platzieren der Kette die n√§chste verbundene Kette immer diejenige, die mit den Scheitelpunkten verbunden ist, die bereits in der Schaltung aufgereiht sind. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Layout </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateLayout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputGraph</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> emptyLayout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Layout(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;Layout&gt;(); stack.Push(emptyLayout); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!stack.Empty()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> layout = stack.Pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextChain = GetNextChain(layout, inputGraph); Layout[] partialLayouts = AddChain(layout, nextChain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!partialLayouts.Empty()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsFullLayout(partialLayouts[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> partialLayouts[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { stack.Push(partialLayouts); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  <i>Pseudocode, der einen inkrementellen Ansatz zum Finden des richtigen Schemas zeigt.</i> <br><br>  Der oben gezeigte Pseudocode demonstriert die Implementierung eines inkrementellen Schemas.  Bei jeder Iteration des Algorithmus (Zeilen 6 - 18) nehmen wir zuerst die letzte Schaltung aus dem Stapel (Zeile 7) und berechnen, welche Kette als n√§chstes hinzugef√ºgt werden soll (Zeile 8).  Dies kann durch einfaches Speichern der Nummer der letzten Schaltung erfolgen, die zu jeder Teilschaltung hinzugef√ºgt wurde.  Im n√§chsten Schritt f√ºgen wir der Schaltung (Zeile 9) die folgende Kette hinzu, erzeugen mehrere detaillierte Schaltungen und speichern sie.  Wenn die Erweiterungsphase fehlschl√§gt, dem Stapel jedoch keine neuen Teilschemata hinzugef√ºgt werden und der Algorithmus mit dem zuletzt gespeicherten Teilschema fortfahren muss.  Wir nennen diese Situation eine R√ºckgabesuche, da der Algorithmus das aktuelle Teilschema nicht erweitern kann und zur√ºckgehen und mit einem anderen gespeicherten Schema fortfahren muss.  Dies ist normalerweise erforderlich, wenn nicht gen√ºgend Platz vorhanden ist, um zus√§tzliche Schaltungen mit den bereits in der Schaltung zusammengesetzten Scheitelpunkten zu verbinden.  Eine R√ºckgabesuche ist auch der Grund, warum wir immer versuchen, mehrere erweiterte Schemata zu generieren (Zeile 9).  Andernfalls h√§tten wir nichts, worauf wir zur√ºckkommen k√∂nnten.  Der Prozess endet, wenn wir eine vollst√§ndige Schaltung erzeugen oder der Stapel leer ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90e/909/ca4/90e909ca4640401cf869e4ad2e558d32.png"></div><br>  (a) Eingabediagramm <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/736/f69/8ca736f69ce1ba31910d12c49f0546a4.png"></div><br>  (b) Teildiagramm <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0e/74f/284/d0e74f2846ea5cdd8351bd1a20561704.png"></div><br>  (c) Teildiagramm <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/708/d35/2c4708d351e2b4a13a98cffa9a090a58.png"></div><br>  (d) Vollst√§ndiger √úberblick <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/13b/796/b3b13b796d79dd8587d23d82cee6da52.png"></div><br>  (e) Vollst√§ndige Gliederung <br><br>  Inkrementelles Schema.  Die Abbildungen (b) und (c) zeigen zwei Teildiagramme nach der Planung der ersten Schaltung.  Fig. (D) zeigt die vollst√§ndige Schaltung nach der Erweiterung (b) um eine zweite Schaltung.  Fig. (E) zeigt die vollst√§ndige Schaltung nach der Erweiterung (c) um eine zweite Schaltung. <br><br>  Um das Diagramm in Teile zu unterteilen, m√ºssen Sie eine flache Einbettung des Eingabediagramms finden, dh eine Zeichnung in der Ebene, in der sich die Kanten nur an den Endpunkten schneiden.  Dieser Anhang wird dann verwendet, um alle Fl√§chen des Diagramms abzurufen.  Die Hauptidee der Zerlegung besteht darin, dass es schwieriger ist, eine Schaltung aus Zyklen zu erstellen, da ihre Knoten mehr Einschr√§nkungen aufweisen.  Daher versuchen wir, die Zyklen zu Beginn der Zerlegung so anzuordnen, dass sie so fr√ºh wie m√∂glich verarbeitet werden und die Wahrscheinlichkeit verringert wird, dass in nachfolgenden Phasen zur√ºckgegangen werden muss.  Die erste Zerlegungskette wird durch die kleinste Fl√§che des Anhangs gebildet, und nachfolgende Fl√§chen werden dann in der Reihenfolge der Breitensuche hinzugef√ºgt.  Wenn andere Fl√§chen ausgew√§hlt werden k√∂nnen, wird die kleinste verwendet.  Wenn keine Fl√§chen mehr vorhanden sind, werden die verbleibenden nichtzyklischen Komponenten hinzugef√ºgt.  Fig. 4 zeigt ein Beispiel der Zersetzung in einer Kette, die gem√§√ü diesen Schritten erhalten wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/c57/c57/e0fc57c571633c5f70b818c412e8d80c.png"></div><br>  (a) <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bb/02c/950/4bb02c950ef9309be5df082e0c630ec3.png"></div><br>  (b) <br><br>  Zersetzung in Ketten.  Abbildung (b) zeigt ein Beispiel f√ºr die Anordnung von Abbildung (a) auf einer Schaltung.  Jede Farbe repr√§sentiert eine separate Kette.  Zahlen geben die Reihenfolge an, in der die Ketten erstellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0c/ad3/554/f0cad3554aa63d7cc46e5d9dae334209.png"></div><br>  (c) Gutes Teildesign <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/839/114/d0083911404026fa33a26f529d1db1a0.png"></div>  (d) Vollst√§ndiger √úberblick <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b27/f99/ed2/b27f99ed239d73e25a14e3f785ba5bd2.png"></div><br>  (a) Eingabediagramm <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/60c/13b/85c60c13b6479b643855f71f5138f738.png"></div><br>  (b) Schlechter Teilgraph <br><br>  Suche mit R√ºckgabe.  Abbildung (b) zeigt ein Beispiel f√ºr eine schlechte Teilschaltung, da nicht gen√ºgend Platz vorhanden ist, um die Knoten 0 und 9 zu verbinden. Um die vollst√§ndige Schaltung (d) zu erzeugen, ist eine R√ºckkehr zu einer anderen Teilschaltung (c) erforderlich. <br><br><h2>  Simuliertes Gl√ºhen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Tempersimulationsalgorithmus</a> ist eine probabilistische Optimierungstechnik, deren Zweck darin besteht, den Raum m√∂glicher Schaltungen zu untersuchen.  Es wurde von den Autoren des Originalartikels ausgew√§hlt, weil es sich in der Vergangenheit in √§hnlichen Situationen als n√ºtzlich erwiesen hat.  Bei der Implementierung des Algorithmus habe ich mich f√ºr dieselbe Methode entschieden, weil ich mit dem beginnen wollte, was sich bereits als wirksam bei der L√∂sung dieses Problems erwiesen hat.  Ich denke jedoch, dass es durch eine andere Methode ersetzt werden kann und meine Bibliothek so geschrieben ist, dass das Ersetzen der Methode recht einfach ist. <br><br>  Der Tempersimulationsalgorithmus wertet iterativ kleine √Ñnderungen in der aktuellen Konfiguration oder Schaltung aus.  Dies bedeutet, dass wir eine neue Konfiguration erstellen, indem wir zuf√§llig einen Knoten ausw√§hlen und seine Position oder Form √§ndern.  Wenn die neue Konfiguration die Energiefunktion verbessert, wird sie immer akzeptiert.  Andernfalls besteht ohnehin nur eine geringe Chance, die Konfiguration zu akzeptieren.  Die Wahrscheinlichkeit, schlechtere Entscheidungen zu treffen, nimmt mit der Zeit ab.  Die Energiefunktion ist so ausgelegt, dass sich kreuzende Knoten und benachbarte Knoten, die sich nicht ber√ºhren, mit hohen Bu√ügeldern belegt werden. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>E</mi><mo>=</mo><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>A</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>D</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="32.209ex" height="2.66ex" viewBox="0 -987.6 13867.5 1145.2" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-45" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMAIN-3D" x="1042" y="0"></use><g transform="translate(2098,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-41" x="2318" y="0"></use><g transform="translate(2170,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6F" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6D" x="839" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="1717" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-67" x="2184" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="2664" y="0"></use></g></g></g><g transform="translate(7093,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-44" x="2318" y="0"></use><g transform="translate(2225,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6F" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6D" x="839" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="1717" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-67" x="2184" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="2664" y="0"></use></g></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMAIN-2212" x="12366" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMAIN-31" x="13367" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>E</mi><mo>=</mo><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>A</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>D</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><mo>‚àí</mo><mn>1</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> E = e ^ {\ frac {A} {\ omega}} e ^ {\ frac {D} {\ omega}} - 1 </script></p><br>  A ist die gesamte Schnittfl√§che zwischen allen Blockpaaren im Diagramm.  D ist die Summe der Quadrate der Abst√§nde zwischen den Mittelpunkten der Blockpaare im Eingabediagramm, die Nachbarn sind, sich aber nicht ber√ºhren.  Wert <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.178ex" height="1.817ex" viewBox="0 -520.7 3090.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6F" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6D" x="735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="1614" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-67" x="2080" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="2561" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ omega </script>  beeinflusst die Wahrscheinlichkeit, dass simuliertes Tempern in die schlechteste Konfiguration gelangen darf;  Dieser Parameter wird aus der durchschnittlichen Fl√§che der Bausteine ‚Äã‚Äãberechnet. <br><br>  Nachdem Sie einen zu √§ndernden Knoten ausgew√§hlt haben, √§ndern wir entweder seine Form oder Position.  Wie w√§hlen wir eine neue Position?  Sie k√∂nnen es zuf√§llig ausw√§hlen, aber dies verschlechtert h√§ufig die Energiefunktion und der Algorithmus konvergiert sehr langsam.  K√∂nnen wir eine Position w√§hlen, die die Energiefunktion eher erh√∂ht?  Sehen Sie, wohin ich f√ºhre?  Wir verwenden Konfigurationsr√§ume, um eine Position auszuw√§hlen, die die Grenzen der gr√∂√üten Anzahl benachbarter R√§ume erf√ºllt. <br><br>  Um die Form zu √§ndern, w√§hlen Sie einfach eine der verf√ºgbaren Raumformen aus.  Der Algorithmus versucht zwar nicht zu entscheiden, welche Form uns am wahrscheinlichsten zum richtigen Schema f√ºhrt.  Es w√§re jedoch interessant, diese Funktion auszuprobieren und zu pr√ºfen, ob sie den Algorithmus beschleunigt. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Layout&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddChain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chain, layout</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentLayout = GetInitialLayout(layout, chain); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generatedLayouts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Layout&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n, i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*       */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= m, j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newLayout = PerturbLayout(currentLayout, chain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsValid(newLayout)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DifferentEnough(newLayout, generatedLayouts)) { generatedLayouts.Add(newLayout); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* newLayout ,  currentLayout */</span></span>) { currentLayout = newLayout; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* ,   ,    newLayout */</span></span>) { currentLayout = newLayout; } } <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> generatedLayouts; }</code> </pre> <br>  Dies ist der Pseudocode des Verfahrens, das f√ºr die Erzeugung einer separaten Schaltungsschaltung durch Simulation des Temperns verantwortlich ist. <br><br>  Um den gesamten Prozess zu beschleunigen, werden wir versuchen, die anf√§ngliche Niedrigenergiekonfiguration zu finden.  Zu diesem Zweck ordnen wir die Knoten in der aktuellen Kette f√ºr eine Breitensuche an, beginnend mit denen, die an die bereits im Schema enthaltenen Knoten angrenzen.  Dann werden die geordneten Knoten einzeln platziert und f√ºr sie wird die Position mit der niedrigsten Energie aus dem Konfigurationsraum ausgew√§hlt.  Hier machen wir kein Backtracking - dies ist ein einfacher gieriger Prozess. <br><br><h2>  Bonus Video </h2><br>  Das folgende Video zeigt die Diagramme, die aus demselben Eingabediagramm wie im ersten Video erstellt wurden.  Diesmal wird jedoch ein inkrementeller Ansatz gezeigt.  M√∂glicherweise stellen Sie fest, dass der Algorithmus nacheinander Knotenketten hinzuf√ºgt.  Es ist auch ersichtlich, dass es manchmal zwei aufeinanderfolgende Teilschaltungen mit der gleichen Anzahl von Knoten gibt.  Dies geschieht, wenn der Algorithmus zur√ºckkehrt.  Wenn die ersten Versuche, der ersten Teilschaltung eine weitere Schaltung hinzuzuf√ºgen, fehlschlagen, versucht der Algorithmus eine andere Teilschaltung. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterst√ºtzt kein HTML5-Video. <source src="https://ondra.nepozitek.cz/blog/wp-content/uploads/2019/01/GeneratorWindow-13_01_2019-23_23_30.mp4" type="video/mp4"></video></div></div></div><br><h2>  Herunterladbare Materialien </h2><br>  Die Implementierung des Algorithmus in .NET finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem Github</a> .  Das Repository enth√§lt die .NET-DLL und die WinForms-GUI-Anwendung, die von YAML-Konfigurationsdateien gesteuert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436198/">https://habr.com/ru/post/de436198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436186/index.html">Was ist w√§hrend des NALSD-Interviews zu denken?</a></li>
<li><a href="../de436188/index.html">Mit dem DJI Smart Controller haben Sie die Freiheit, immer zur Hand zu sein</a></li>
<li><a href="../de436192/index.html">Physik-Browser-Simulation</a></li>
<li><a href="../de436194/index.html">Funktionsweise des Ivideon-Video√ºberwachungssystems: √úberblick √ºber die mobile Anwendung</a></li>
<li><a href="../de436196/index.html">Tester-Voyeurismus: Wie man Menschen richtig ausspioniert und warum es notwendig ist</a></li>
<li><a href="../de436200/index.html">Entscheidung des US-Gerichts: Die Beh√∂rden haben kein Recht, eine Person zu zwingen, das Telefon mit einem Finger oder Gesicht zu entsperren</a></li>
<li><a href="../de436202/index.html">Ich habe das Vertrauen in die Entwicklung verloren, bin ausgebrannt, aber der Werkzeugkult hat mich gerettet</a></li>
<li><a href="../de436206/index.html">Wie man Kunst schmerzlos mit Java, JavaScript und Grafiken vereint oder die Geschichte hinter dem Erstellen eines interaktiven Theaterprodukts</a></li>
<li><a href="../de436208/index.html">Neue Str√∂me erscheinen nicht mehr in The Pirate Bay</a></li>
<li><a href="../de436210/index.html">Biquaternionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>