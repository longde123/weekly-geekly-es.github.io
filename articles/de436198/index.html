<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔡 🍣 🏭 Graph Node Dungeon Generator 🛒 ☃️ 👌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Beitrag werde ich den Algorithmus zur prozeduralen Erzeugung von Ebenen eines zweidimensionalen Dungeons mit einer vorgegebenen Struktur bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Graph Node Dungeon Generator</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436198/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pt/uh/r0/ptuhr0jo9giaq3dkb15uiqlfp30.png" alt="Bild"></div><br>  In diesem Beitrag werde ich den Algorithmus zur prozeduralen Erzeugung von Ebenen eines zweidimensionalen Dungeons mit einer vorgegebenen Struktur beschreiben.  Im ersten Teil wird eine allgemeine Beschreibung und im zweiten Teil die Implementierung des Algorithmus vorgestellt. <br><br><h2>  Einführung </h2><br>  Der Algorithmus wurde im Rahmen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer Bachelorarbeit geschrieben</a> und basiert auf einem Artikel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ma et al. (2014)</a> .  Ziel der Arbeit war es, den Algorithmus zu beschleunigen und durch neue Funktionen zu ergänzen.  Ich bin sehr zufrieden mit dem Ergebnis, da wir den Algorithmus schnell genug gemacht haben, um ihn während der Ausführung des Spiels zu verwenden.  Nachdem wir die Bachelorarbeit abgeschlossen hatten, beschlossen wir, sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> umzuwandeln und an die Game-ON 2018-Konferenz zu senden. <br><br><h2>  Algorithmus </h2><br>  Um ein Spiellevel zu erstellen, erhält der Algorithmus als Eingabe einen Satz polygonaler Bausteine ​​und ein Diagramm der Level-Konnektivität (Level-Topologie).  Die Knoten des Diagramms geben die Räume an, und die Kanten bestimmen die Verbindungen zwischen ihnen.  Der Zweck des Algorithmus besteht darin, jedem Knoten des Diagramms die Form und Position des Raums zuzuweisen, so dass sich keine zwei Raumformen schneiden und jedes Paar benachbarter Räume durch Türen verbunden werden kann. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41f/ed9/68f/41fed968fc3150ffb6285e660ff2ec5c.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96a/68a/302/96a68a302c5af7bc046644a659f0cc81.png"></div><br>  (b) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc1/79e/c88/fc179ec88afc1fa1889937a2df25c029.png"></div><br>  (c) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9f/898/224/d9f8982240071dcb3d9205207912a46f.png"></div><br>  (d) <br><br>  Die Abbildungen (c) und (d) zeigen die Diagramme, die aus dem Eingabegraphen (a) und den Bausteinen (b) erzeugt wurden. <br><br>  Mithilfe des Konnektivitätsdiagramms kann ein Spieledesigner den Spielfluss einfach steuern.  Benötigen Sie einen gemeinsamen Weg zum Chefraum mit mehreren optionalen Seitenwegen?  Beginnen Sie einfach mit dem Pfaddiagramm und geben Sie dann einige Knoten an, in denen der Spieler wählen kann: Gehen Sie entweder den Hauptpfad entlang oder erkunden Sie den Nebenpfad, wobei mögliche Schätze und / oder Monster darauf warten.  Müssen Sie den Weg abschneiden?  Wählen Sie einfach die beiden Knoten im Diagramm aus und fügen Sie eine kurze Straße hinzu, die sie verbindet.  Die Möglichkeiten dieses Schemas sind endlos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/044/41a/61904441a82fd281642664a0e784513d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/b4e/65e/9feb4e65e116328e42b3e9638911fae5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83c/fd9/d63/83cfd9d6388c784f88c818e7bc6c9513.png"></div><br>  <i>Beispiele für Eingabediagramme.</i>  <i>Der Hauptpfad ist rot dargestellt, die Hilfspfade sind blau, der kurze Pfad ist orange.</i> <br><br>  Der Algorithmus ermöglicht es Spieldesignern nicht nur, die Struktur der generierten Karten auf hoher Ebene zu verwalten, sondern bietet auch die Möglichkeit, das Erscheinungsbild einzelner Räume zu steuern und sie miteinander zu verbinden. <br><br><h3>  Unterschiedliche Formen für unterschiedliche Räume </h3><br>  Ich erwähnte den Chefraum am Ende des Levels.  Wir wollen nicht, dass der Chefraum wie ein anderer gewöhnlicher Raum aussieht, oder?  Mit dem Algorithmus können Sie Formulare für jeden Raum festlegen.  Zum Beispiel können wir einen Raum am Anfang des Levels und einen Chefraum erstellen, der ihre eigenen Sätze von Raumformen haben sollte, und einen gemeinsamen Satz für alle anderen Räume. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/988/e05/e1f988e05bf84eea4209c128ac0b9e60.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f97/b39/b15/f97b39b15661d51ad7cf3a30a4e9b80a.png"></div><br>  Zwei aus dem Eingangsgraphen erzeugte Schaltkreise, in denen der Raumnummer 8 eine spezielle Form von Räumen zugeordnet ist. <br><br><h3>  Explizit angegebene Türpositionen </h3><br>  Stellen Sie sich vor, Sie haben ein hochwertiges Boss-Meeting-Skript und der Spieler muss den Raum des Chefs von einem bestimmten Plättchen aus betreten.  Oder wir haben eine Raumvorlage, in der einige Fliesen für Wände und andere Hindernisse reserviert sind.  Mit dem Algorithmus können Designer mögliche Türpositionen für einzelne Raumformen explizit festlegen. <br><br>  Aber manchmal kann das Ziel das Gegenteil sein.  Wir können Raumvorlagen so erstellen, dass die Türen zu ihnen fast überall sein können.  Aus diesem Grund legen wir dem Algorithmus weniger Einschränkungen auf, daher läuft er häufig schneller und die erzeugten Schaltkreise wirken möglicherweise weniger eintönig und organischer.  In solchen Situationen kann einfach die Länge der Türen angegeben werden und wie weit sie von den Ecken entfernt sein sollten.  Der Abstand von den Ecken ist eine Art Kompromiss zwischen der manuellen Anordnung aller Türen und dem Vorhandensein von Türen überall. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/cf8/05f/13dcf805f54ce10ad637ce1c6e298b28.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/e9f/51e/7bee9f51e10cda43d07163e27f7ff1dd.png"></div><br>  (b) <br><br>  Abbildung (a) zeigt die verschiedenen Arten der Türplatzierung: Ein quadratischer Raum hat 8 klar definierte Türpositionen, und ein rechteckiger Raum verwendet Länge und Abstand von den Ecken.  Abbildung (b) zeigt ein einfaches generiertes Diagramm mit den Formen der Räume in Abbildung (a). <br><br><h3>  Korridore zwischen den Zimmern </h3><br>  Wenn wir über Dungeonebenen sprechen, stellen wir uns oft Räume vor, die durch enge Korridore verbunden sind.  Ich würde gerne annehmen, dass die Verbindungen im Eingabediagramm die Korridore anzeigen, aber sie sind es nicht.  Sie garantieren einfach, dass alle benachbarten Knoten direkt durch Türen verbunden werden.  Wenn wir möchten, dass die Räume durch Korridore verbunden sind, müssen wir einen neuen Knoten zwischen allen benachbarten Raumpaaren einfügen und so tun, als wären dies Korridorräume (mit bestimmten Raumformen und bestimmten Türpositionen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/56a/2b3/b5956a2b30f27882272fa44fe540f0bb.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbc/91d/b4e/fbc91db4e3beec215ad06cc7799cc56a.png"></div><br>  (b) <br><br>  Eine Illustration, wie wir das Eingabediagramm ändern können, um Korridore zwischen Räumen hinzuzufügen.  Abbildung (a) zeigt das Eingabediagramm vor dem Hinzufügen der Korridorräume.  Abbildung (b) zeigt das aus (a) erstellte Eingabediagramm, indem neue Räume zwischen allen benachbarten Räumen des ursprünglichen Diagramms hinzugefügt werden. <br><br>  Leider erschwert dies die Aufgabe des Algorithmus erheblich, da sich die Anzahl der Knoten häufig verdoppelt.  Aus diesem Grund habe ich eine Version des Algorithmus implementiert, die Korridore berücksichtigt und es ermöglicht, den Leistungsabfall beim Anordnen von Korridorräumen zu verringern.  Im Moment unterstützt der Algorithmus entweder Korridore zwischen allen Räumen oder das völlige Fehlen von Korridoren, aber in Zukunft plane ich, ihn flexibler zu gestalten. <br><br><h2>  Beispiele </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/c4c/b17/b01c4cb173e0b315ce81c842a617e32c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2b/5a0/5aa/a2b5a05aa014d12b0fc70d23a540997d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/5b7/de6/3055b7de654c62dc96c1e83ad510e199.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80e/d9e/b26/80ed9eb26994f6b395e9fa2af34b6dce.png"></div><br>  <i>Mehrere Schemata, die aus verschiedenen Bausteinsätzen und mit aktivierten Korridoren generiert wurden.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/738/8a4/a44/7388a4a4466fe32fc9b9975e71473936.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1e/1ed/95b/c1e1ed95b4a9236c02fc11ed1bb33ed9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/628/f19/025/628f19025acf78eed8aa199347804f9e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa7/7e5/03d/aa77e503dbb791e78189777bc875e2cd.png"></div><br>  <i>Mehrere Schemata, die aus verschiedenen Bausteinsätzen mit ein- und ausgeschalteten Korridoren generiert wurden.</i> <br><br>  Im zweiten Teil des Beitrags werde ich über die interne Funktionsweise des Algorithmus sprechen. <br><br>  Ich arbeite auch an einem Unity-Plugin für die prozedurale Dungeon-Generierung, das diesen Algorithmus enthalten wird.  Ich mache das, weil trotz der Möglichkeit, diesen Algorithmus direkt in Unity zu verwenden (er ist in C # geschrieben), die Bequemlichkeit, damit zu arbeiten, alles andere als ideal ist.  Das Erstellen von Raumvorlagen ohne GUI nimmt viel Zeit in Anspruch, und es wird viel Code benötigt, um die Ausgabe des Algorithmus in die im Spiel verwendete Darstellung zu konvertieren. <br><br>  Da ich selbst kein Spieleentwickler bin, ist es mein Ziel, das Plugin so gut zu machen, dass andere es verwenden können.  Wenn alles gut geht, werde ich versuchen, Updates zu veröffentlichen, wenn ich etwas Interessantes zu sagen habe.  Ich habe bereits einige Ideen zum Generator selbst und zum Testen seiner Fähigkeiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d12/43f/2c0/d1243f2c05e18826eb3d97a30b6f743c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ed/34f/05c/7ed34f05ca19aa127aae0938e26d63ec.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/d48/39f/ad4d4839f9ca1c333c2fbb3e0333989e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0e/805/121/c0e805121b2cda153980875d780d5f9b.png"></div><br>  <i>Screenshots des Unity-Plugins (das Projekt befindet sich in der Entwicklung)</i> <br><br><h2>  Teil 2. Implementierung des Algorithmus </h2><br>  In diesem Teil werde ich über die Grundideen sprechen, die in der Grundlage des im ersten Teil des Beitrags beschriebenen Algorithmus festgelegt wurden.  Zunächst wollte ich die grundlegenden Konzepte sowie die wichtigsten Verbesserungen beschreiben, die erforderlich sind, damit der Algorithmus schnell genug ist.  Wie sich jedoch herausstellte, sind selbst die Grundkonzepte für diesen Beitrag mehr als ausreichend.  Aus diesem Grund habe ich beschlossen, Leistungsverbesserungen in einem zukünftigen Artikel aufzuzeigen. <br><br><h2>  Motivation </h2><br>  Bevor ich zur Implementierung übergehe, möchte ich das Ergebnis dessen zeigen, was wir tun werden.  Das folgende Video zeigt 30 verschiedene Schaltkreise, die aus einem Eingangsgraphen und einem Satz von Bausteinen generiert wurden.  Der Algorithmus stoppt nach dem Erzeugen der Schaltung immer für 500 ms und versucht dann, die nächste zu erzeugen. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterstützt kein HTML5-Video. <source src="https://ondra.nepozitek.cz/blog/wp-content/uploads/2019/01/GeneratorWindow-12_01_2019-23_48_40.mp4" type="video/mp4"></video></div></div></div><br><h2>  Wie funktioniert es? </h2><br>  Der Zweck des Algorithmus besteht darin, jedem Knoten im Diagramm die Form und Position des Raums zuzuweisen, sodass sich keine zwei Räume schneiden und benachbarte Räume durch Türen verbunden sind. <br><br>  Eine Möglichkeit, dies zu erreichen, besteht darin, alle möglichen Kombinationen von Raumformen und deren Positionen auszuprobieren.  Wie Sie vielleicht erraten haben, wird dies jedoch sehr ineffizient sein, und wir werden wahrscheinlich keine Schaltungen erzeugen können, selbst wenn sehr einfache Eingabegraphen verwendet werden. <br><br>  Anstatt nach allen möglichen Kombinationen zu suchen, berechnet der Algorithmus, wie alle einzelnen Räume (die sogenannten Konfigurationsräume) korrekt verbunden werden, und verwendet diese Informationen, um die Suche zu steuern.  Leider ist es trotz dieser Informationen immer noch schwierig, das richtige Schema zu finden.  Für eine effektive Untersuchung des Suchraums verwenden wir daher eine probabilistische Optimierungstechnik (in diesem Fall eine Tempersimulation).  Zur weiteren Beschleunigung der Optimierung teilen wir die Eingabeaufgabe in kleinere und einfacher zu lösende Unteraufgaben auf.  Dies erfolgt durch Aufteilen des Diagramms in kleinere Teile (als Ketten bezeichnet) mit anschließender Erstellung von Schemata für jeden von ihnen in der angegebenen Reihenfolge. <br><br><h2>  Konfigurationsbereiche </h2><br>  Für ein Paar von Polygonen, in denen eines an Ort und Stelle fixiert ist und das andere sich frei bewegen kann, ist der Konfigurationsraum die Menge der Positionen eines freien Polygons, an denen sich zwei Polygone nicht schneiden und durch Türen verbunden werden können.  Bei der Arbeit mit Polygonen kann jeder Konfigurationsraum als möglicherweise leerer Satz von Linien dargestellt und mit einfachen geometrischen Werkzeugen berechnet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/823/45e/13482345ed98c982677a10e53ddaec2d.png"></div><br>  (a) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8c/1eb/62c/b8c1eb62c2f6d8f166670781dfe35336.png"></div><br>  (b) <br><br>  Raumkonfigurationen.  Abbildung (a) zeigt den Konfigurationsraum (rote Linien) eines freien Rechtecks ​​relativ zu einem festen L-förmigen Polygon.  Es bestimmt alle Positionen der Mitte des Quadrats, an denen sich die beiden Blöcke nicht schneiden und berühren.  Abbildung (b) zeigt den Schnittpunkt (gelbe Punkte) der Konfigurationsräume eines sich bewegenden Quadrats in Bezug auf zwei feste Rechtecke. <br><br>  Der folgende Algorithmus wird verwendet, um den Konfigurationsraum eines festen und eines freien Blocks zu berechnen.  Wir wählen einen Referenzpunkt auf dem beweglichen Block aus und berücksichtigen alle Positionen in <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi><mi>b</mi><msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>R</mi></mrow><mn>2</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.843ex" height="2.539ex" viewBox="0 -987.6 4668.4 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6D" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="1128" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-74" x="1658" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-68" x="2019" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-62" x="2596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-62" x="3025" y="0"></use><g transform="translate(3455,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-52" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMAIN-32" x="1074" y="581"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>b</mi><mi>b</mi><msup><mrow class="MJX-TeXAtom-ORD"><mi>R</mi></mrow><mn>2</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ mathbb {R} ^ 2 </script>  , so dass sich beim Verschieben des Polygons so, dass sich sein Referenzpunkt an dieser Stelle befindet, sowohl der bewegliche als auch der feste Block berühren, sich jedoch nicht schneiden.  Die Menge all dieser Punkte bildet den Konfigurationsraum von zwei Blöcken (Abbildung (a) oben).  Um den Konfigurationsraum des sich bewegenden Blocks relativ zu zwei oder mehr festen Blöcken zu erhalten, wird der Schnittpunkt der einzelnen Konfigurationsräume berechnet (Abbildung (b) oben). <br><br>  Der Algorithmus verwendet Konfigurationsräume auf zwei Arten.  Anstatt die zufälligen Positionen einzelner Räume auszuprobieren, verwenden wir zunächst Konfigurationsräume, um nach Positionen zu suchen, die zu einer möglichst großen Anzahl benachbarter Räume führen, die durch die Türen verbunden sind.  Dazu müssen wir den maximalen nicht leeren Schnittpunkt der Konfigurationsräume der Nachbarn erhalten.  Zweitens verwenden wir Konfigurationsräume, um zu prüfen, ob alle Paare benachbarter Räume mit Türen verbunden werden können.  Dies erfolgt durch Überprüfen, ob sich die Position des Raums innerhalb des Konfigurationsraums aller seiner Nachbarn befindet. <br><br>  Da sich die Formen der Räume während der Ausführung des Spiels nicht ändern, können wir die Konfigurationsräume aller Paare von Raumformen vor dem Start des Algorithmus vorberechnen.  Dadurch wird der gesamte Algorithmus erheblich beschleunigt. <br><br><h2>  Inkrementelles Schema </h2><br>  Bei der Lösung eines komplexen Problems besteht einer der möglichen Ansätze darin, es in kleinere und einfachere Teilaufgaben zu unterteilen und diese bereits zu lösen.  Genau das tun wir mit der Aufgabe, einzelne Räume zu platzieren.  Anstatt alle Räume gleichzeitig anzuordnen, teilen wir das Eingabediagramm in kleinere Untergraphen auf und versuchen, daraus nacheinander Diagramme zu erstellen.  Die Autoren des ursprünglichen Algorithmus nennen diese Untergraphen aufgrund des Prinzips dieser Graphen, in denen jeder Knoten nicht mehr als zwei Nachbarn hat, "Ketten", und daher ist es recht einfach, ihr Schema zu erstellen. <br><br>  Die endgültige Ausgangsschaltung ist immer eine verbundene Komponente, daher ist es nicht sinnvoll, die einzelnen Komponenten in die Schaltung einzubinden und dann zu versuchen, sie zu kombinieren, da der Kombinationsprozess sehr kompliziert sein kann.  Daher ist nach dem Platzieren der Kette die nächste verbundene Kette immer diejenige, die mit den Scheitelpunkten verbunden ist, die bereits in der Schaltung aufgereiht sind. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Layout </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateLayout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inputGraph</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> emptyLayout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Layout(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;Layout&gt;(); stack.Push(emptyLayout); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!stack.Empty()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> layout = stack.Pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextChain = GetNextChain(layout, inputGraph); Layout[] partialLayouts = AddChain(layout, nextChain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!partialLayouts.Empty()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsFullLayout(partialLayouts[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> partialLayouts[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { stack.Push(partialLayouts); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  <i>Pseudocode, der einen inkrementellen Ansatz zum Finden des richtigen Schemas zeigt.</i> <br><br>  Der oben gezeigte Pseudocode demonstriert die Implementierung eines inkrementellen Schemas.  Bei jeder Iteration des Algorithmus (Zeilen 6 - 18) nehmen wir zuerst die letzte Schaltung aus dem Stapel (Zeile 7) und berechnen, welche Kette als nächstes hinzugefügt werden soll (Zeile 8).  Dies kann durch einfaches Speichern der Nummer der letzten Schaltung erfolgen, die zu jeder Teilschaltung hinzugefügt wurde.  Im nächsten Schritt fügen wir der Schaltung (Zeile 9) die folgende Kette hinzu, erzeugen mehrere detaillierte Schaltungen und speichern sie.  Wenn die Erweiterungsphase fehlschlägt, dem Stapel jedoch keine neuen Teilschemata hinzugefügt werden und der Algorithmus mit dem zuletzt gespeicherten Teilschema fortfahren muss.  Wir nennen diese Situation eine Rückgabesuche, da der Algorithmus das aktuelle Teilschema nicht erweitern kann und zurückgehen und mit einem anderen gespeicherten Schema fortfahren muss.  Dies ist normalerweise erforderlich, wenn nicht genügend Platz vorhanden ist, um zusätzliche Schaltungen mit den bereits in der Schaltung zusammengesetzten Scheitelpunkten zu verbinden.  Eine Rückgabesuche ist auch der Grund, warum wir immer versuchen, mehrere erweiterte Schemata zu generieren (Zeile 9).  Andernfalls hätten wir nichts, worauf wir zurückkommen könnten.  Der Prozess endet, wenn wir eine vollständige Schaltung erzeugen oder der Stapel leer ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90e/909/ca4/90e909ca4640401cf869e4ad2e558d32.png"></div><br>  (a) Eingabediagramm <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/736/f69/8ca736f69ce1ba31910d12c49f0546a4.png"></div><br>  (b) Teildiagramm <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0e/74f/284/d0e74f2846ea5cdd8351bd1a20561704.png"></div><br>  (c) Teildiagramm <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/708/d35/2c4708d351e2b4a13a98cffa9a090a58.png"></div><br>  (d) Vollständiger Überblick <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/13b/796/b3b13b796d79dd8587d23d82cee6da52.png"></div><br>  (e) Vollständige Gliederung <br><br>  Inkrementelles Schema.  Die Abbildungen (b) und (c) zeigen zwei Teildiagramme nach der Planung der ersten Schaltung.  Fig. (D) zeigt die vollständige Schaltung nach der Erweiterung (b) um eine zweite Schaltung.  Fig. (E) zeigt die vollständige Schaltung nach der Erweiterung (c) um eine zweite Schaltung. <br><br>  Um das Diagramm in Teile zu unterteilen, müssen Sie eine flache Einbettung des Eingabediagramms finden, dh eine Zeichnung in der Ebene, in der sich die Kanten nur an den Endpunkten schneiden.  Dieser Anhang wird dann verwendet, um alle Flächen des Diagramms abzurufen.  Die Hauptidee der Zerlegung besteht darin, dass es schwieriger ist, eine Schaltung aus Zyklen zu erstellen, da ihre Knoten mehr Einschränkungen aufweisen.  Daher versuchen wir, die Zyklen zu Beginn der Zerlegung so anzuordnen, dass sie so früh wie möglich verarbeitet werden und die Wahrscheinlichkeit verringert wird, dass in nachfolgenden Phasen zurückgegangen werden muss.  Die erste Zerlegungskette wird durch die kleinste Fläche des Anhangs gebildet, und nachfolgende Flächen werden dann in der Reihenfolge der Breitensuche hinzugefügt.  Wenn andere Flächen ausgewählt werden können, wird die kleinste verwendet.  Wenn keine Flächen mehr vorhanden sind, werden die verbleibenden nichtzyklischen Komponenten hinzugefügt.  Fig. 4 zeigt ein Beispiel der Zersetzung in einer Kette, die gemäß diesen Schritten erhalten wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/c57/c57/e0fc57c571633c5f70b818c412e8d80c.png"></div><br>  (a) <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bb/02c/950/4bb02c950ef9309be5df082e0c630ec3.png"></div><br>  (b) <br><br>  Zersetzung in Ketten.  Abbildung (b) zeigt ein Beispiel für die Anordnung von Abbildung (a) auf einer Schaltung.  Jede Farbe repräsentiert eine separate Kette.  Zahlen geben die Reihenfolge an, in der die Ketten erstellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0c/ad3/554/f0cad3554aa63d7cc46e5d9dae334209.png"></div><br>  (c) Gutes Teildesign <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/839/114/d0083911404026fa33a26f529d1db1a0.png"></div>  (d) Vollständiger Überblick <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b27/f99/ed2/b27f99ed239d73e25a14e3f785ba5bd2.png"></div><br>  (a) Eingabediagramm <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/60c/13b/85c60c13b6479b643855f71f5138f738.png"></div><br>  (b) Schlechter Teilgraph <br><br>  Suche mit Rückgabe.  Abbildung (b) zeigt ein Beispiel für eine schlechte Teilschaltung, da nicht genügend Platz vorhanden ist, um die Knoten 0 und 9 zu verbinden. Um die vollständige Schaltung (d) zu erzeugen, ist eine Rückkehr zu einer anderen Teilschaltung (c) erforderlich. <br><br><h2>  Simuliertes Glühen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Tempersimulationsalgorithmus</a> ist eine probabilistische Optimierungstechnik, deren Zweck darin besteht, den Raum möglicher Schaltungen zu untersuchen.  Es wurde von den Autoren des Originalartikels ausgewählt, weil es sich in der Vergangenheit in ähnlichen Situationen als nützlich erwiesen hat.  Bei der Implementierung des Algorithmus habe ich mich für dieselbe Methode entschieden, weil ich mit dem beginnen wollte, was sich bereits als wirksam bei der Lösung dieses Problems erwiesen hat.  Ich denke jedoch, dass es durch eine andere Methode ersetzt werden kann und meine Bibliothek so geschrieben ist, dass das Ersetzen der Methode recht einfach ist. <br><br>  Der Tempersimulationsalgorithmus wertet iterativ kleine Änderungen in der aktuellen Konfiguration oder Schaltung aus.  Dies bedeutet, dass wir eine neue Konfiguration erstellen, indem wir zufällig einen Knoten auswählen und seine Position oder Form ändern.  Wenn die neue Konfiguration die Energiefunktion verbessert, wird sie immer akzeptiert.  Andernfalls besteht ohnehin nur eine geringe Chance, die Konfiguration zu akzeptieren.  Die Wahrscheinlichkeit, schlechtere Entscheidungen zu treffen, nimmt mit der Zeit ab.  Die Energiefunktion ist so ausgelegt, dass sich kreuzende Knoten und benachbarte Knoten, die sich nicht berühren, mit hohen Bußgeldern belegt werden. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>E</mi><mo>=</mo><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>A</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>D</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="32.209ex" height="2.66ex" viewBox="0 -987.6 13867.5 1145.2" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-45" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMAIN-3D" x="1042" y="0"></use><g transform="translate(2098,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-41" x="2318" y="0"></use><g transform="translate(2170,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6F" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6D" x="839" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="1717" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-67" x="2184" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="2664" y="0"></use></g></g></g><g transform="translate(7093,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,412)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-66" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-72" x="904" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="1355" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-63" x="1885" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-44" x="2318" y="0"></use><g transform="translate(2225,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6F" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6D" x="839" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="1717" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-67" x="2184" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="2664" y="0"></use></g></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMAIN-2212" x="12366" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMAIN-31" x="13367" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>E</mi><mo>=</mo><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>A</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>D</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></mrow></mrow></msup><mo>−</mo><mn>1</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> E = e ^ {\ frac {A} {\ omega}} e ^ {\ frac {D} {\ omega}} - 1 </script></p><br>  A ist die gesamte Schnittfläche zwischen allen Blockpaaren im Diagramm.  D ist die Summe der Quadrate der Abstände zwischen den Mittelpunkten der Blockpaare im Eingabediagramm, die Nachbarn sind, sich aber nicht berühren.  Wert <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.178ex" height="1.817ex" viewBox="0 -520.7 3090.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6F" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-6D" x="735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-65" x="1614" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-67" x="2080" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/436198/&amp;usg=ALkJrhhBXkElze82HZVpf1APIq_Xp3_Smw#MJMATHI-61" x="2561" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>o</mi><mi>m</mi><mi>e</mi><mi>g</mi><mi>a</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ omega </script>  beeinflusst die Wahrscheinlichkeit, dass simuliertes Tempern in die schlechteste Konfiguration gelangen darf;  Dieser Parameter wird aus der durchschnittlichen Fläche der Bausteine ​​berechnet. <br><br>  Nachdem Sie einen zu ändernden Knoten ausgewählt haben, ändern wir entweder seine Form oder Position.  Wie wählen wir eine neue Position?  Sie können es zufällig auswählen, aber dies verschlechtert häufig die Energiefunktion und der Algorithmus konvergiert sehr langsam.  Können wir eine Position wählen, die die Energiefunktion eher erhöht?  Sehen Sie, wohin ich führe?  Wir verwenden Konfigurationsräume, um eine Position auszuwählen, die die Grenzen der größten Anzahl benachbarter Räume erfüllt. <br><br>  Um die Form zu ändern, wählen Sie einfach eine der verfügbaren Raumformen aus.  Der Algorithmus versucht zwar nicht zu entscheiden, welche Form uns am wahrscheinlichsten zum richtigen Schema führt.  Es wäre jedoch interessant, diese Funktion auszuprobieren und zu prüfen, ob sie den Algorithmus beschleunigt. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Layout&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddChain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chain, layout</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentLayout = GetInitialLayout(layout, chain); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generatedLayouts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Layout&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n, i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*       */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= m, j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newLayout = PerturbLayout(currentLayout, chain); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsValid(newLayout)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DifferentEnough(newLayout, generatedLayouts)) { generatedLayouts.Add(newLayout); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* newLayout ,  currentLayout */</span></span>) { currentLayout = newLayout; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/* ,   ,    newLayout */</span></span>) { currentLayout = newLayout; } } <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> generatedLayouts; }</code> </pre> <br>  Dies ist der Pseudocode des Verfahrens, das für die Erzeugung einer separaten Schaltungsschaltung durch Simulation des Temperns verantwortlich ist. <br><br>  Um den gesamten Prozess zu beschleunigen, werden wir versuchen, die anfängliche Niedrigenergiekonfiguration zu finden.  Zu diesem Zweck ordnen wir die Knoten in der aktuellen Kette für eine Breitensuche an, beginnend mit denen, die an die bereits im Schema enthaltenen Knoten angrenzen.  Dann werden die geordneten Knoten einzeln platziert und für sie wird die Position mit der niedrigsten Energie aus dem Konfigurationsraum ausgewählt.  Hier machen wir kein Backtracking - dies ist ein einfacher gieriger Prozess. <br><br><h2>  Bonus Video </h2><br>  Das folgende Video zeigt die Diagramme, die aus demselben Eingabediagramm wie im ersten Video erstellt wurden.  Diesmal wird jedoch ein inkrementeller Ansatz gezeigt.  Möglicherweise stellen Sie fest, dass der Algorithmus nacheinander Knotenketten hinzufügt.  Es ist auch ersichtlich, dass es manchmal zwei aufeinanderfolgende Teilschaltungen mit der gleichen Anzahl von Knoten gibt.  Dies geschieht, wenn der Algorithmus zurückkehrt.  Wenn die ersten Versuche, der ersten Teilschaltung eine weitere Schaltung hinzuzufügen, fehlschlagen, versucht der Algorithmus eine andere Teilschaltung. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Ihr Browser unterstützt kein HTML5-Video. <source src="https://ondra.nepozitek.cz/blog/wp-content/uploads/2019/01/GeneratorWindow-13_01_2019-23_23_30.mp4" type="video/mp4"></video></div></div></div><br><h2>  Herunterladbare Materialien </h2><br>  Die Implementierung des Algorithmus in .NET finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem Github</a> .  Das Repository enthält die .NET-DLL und die WinForms-GUI-Anwendung, die von YAML-Konfigurationsdateien gesteuert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436198/">https://habr.com/ru/post/de436198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436186/index.html">Was ist während des NALSD-Interviews zu denken?</a></li>
<li><a href="../de436188/index.html">Mit dem DJI Smart Controller haben Sie die Freiheit, immer zur Hand zu sein</a></li>
<li><a href="../de436192/index.html">Physik-Browser-Simulation</a></li>
<li><a href="../de436194/index.html">Funktionsweise des Ivideon-Videoüberwachungssystems: Überblick über die mobile Anwendung</a></li>
<li><a href="../de436196/index.html">Tester-Voyeurismus: Wie man Menschen richtig ausspioniert und warum es notwendig ist</a></li>
<li><a href="../de436200/index.html">Entscheidung des US-Gerichts: Die Behörden haben kein Recht, eine Person zu zwingen, das Telefon mit einem Finger oder Gesicht zu entsperren</a></li>
<li><a href="../de436202/index.html">Ich habe das Vertrauen in die Entwicklung verloren, bin ausgebrannt, aber der Werkzeugkult hat mich gerettet</a></li>
<li><a href="../de436206/index.html">Wie man Kunst schmerzlos mit Java, JavaScript und Grafiken vereint oder die Geschichte hinter dem Erstellen eines interaktiven Theaterprodukts</a></li>
<li><a href="../de436208/index.html">Neue Ströme erscheinen nicht mehr in The Pirate Bay</a></li>
<li><a href="../de436210/index.html">Biquaternionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>