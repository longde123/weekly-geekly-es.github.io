<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💹 👋🏻 🚸 DynamicData: Koleksi Dinamis, Arsitektur MVVM, dan Ekstensi Reaktif 🧀 🙍🏿 🧙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Februari 2019 menandai pelepasan ReactiveUI 9 - kerangka kerja lintas-platform untuk membangun aplikasi GUI pada platform Microsoft .NET. ReactiveUI a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DynamicData: Koleksi Dinamis, Arsitektur MVVM, dan Ekstensi Reaktif</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454074/"><p>  Februari 2019 menandai pelepasan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactiveUI 9</a> - kerangka kerja lintas-platform untuk membangun aplikasi GUI pada platform Microsoft .NET.  ReactiveUI adalah alat untuk integrasi ketat ekstensi reaktif dengan pola desain MVVM.  Anda dapat membiasakan diri dengan kerangka kerja melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian video</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman pembuka dokumentasi</a> .  Pembaruan ReactiveUI 9 mencakup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak perbaikan dan peningkatan</a> , tetapi mungkin yang paling penting dan menarik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integrasi dengan kerangka kerja DynamicData</a> , memungkinkan Anda untuk bekerja dengan koleksi dinamis dalam mode Reaktif.  Mari cari tahu apa yang bisa kita gunakan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> dan bagaimana kerangka kerja reaktif yang kuat ini bekerja di bawah tenda! </p><a name="habracut"></a><br><h1 id="introduction">  Pendahuluan </h1><br><p> Pertama-tama mari kita tentukan kasus penggunaan untuk DynamicData dan mencari tahu apa yang tidak kita sukai tentang alat default untuk bekerja dengan dataset dinamis dari <code>System.Collections.ObjectModel</code> namespace. </p><br><p>  Template MVVM, seperti yang kita ketahui, mengasumsikan pembagian tanggung jawab antara lapisan model, lapisan presentasi dan model presentasi aplikasi, juga dikenal sebagai model tampilan.  Lapisan model diwakili oleh entitas domain dan layanan dan tidak tahu apa-apa tentang lapisan model tampilan.  Model merangkum seluruh logika kompleks aplikasi, sementara model tampilan mendelegasikan operasi ke model, menyediakan akses ke informasi tentang keadaan aplikasi saat ini melalui properti yang dapat diamati, perintah, dan koleksi, ke tampilan.  Alat default untuk bekerja dengan properti dinamis adalah antarmuka <code>INotifyPropertyChanged</code> , untuk bekerja dengan tindakan pengguna - <code>ICommand</code> , dan untuk bekerja dengan koleksi - antarmuka <code>INotifyCollectionChanged</code> , serta implementasi seperti, sebagai <code>ObservableCollection&lt;T&gt;</code> dan <code>ReadOnlyObservableCollection&lt;T&gt;</code> . </p><br><img width="500" src="https://habrastorage.org/getpro/habr/post_images/504/c83/ab0/504c83ab04fe2e2d1eed037317b8aa2c.jpg"><br><p><br>  Implementasi dari <code>INotifyPropertyChanged</code> dan antarmuka <code>ICommand</code> biasanya <code>ICommand</code> pada pengembang dan kerangka kerja MVVM yang digunakan, tetapi menggunakan standar <code>ObservableCollection&lt;T&gt;</code> membebankan sejumlah batasan!  Sebagai contoh, kami tidak dapat mengubah koleksi dari utas latar belakang tanpa <code>Dispatcher.Invoke</code> Panggilan atau panggilan serupa, dan itu akan sangat berguna untuk menyinkronkan array data dengan server melalui operasi latar belakang.  Perlu dicatat, bahwa ketika menggunakan arsitektur MVVM yang bersih, lapisan model tidak boleh tahu apa-apa tentang kerangka kerja GUI yang digunakan, dan harus kompatibel dengan lapisan model dalam terminologi MVC atau MVP.  Itu sebabnya banyak panggilan <code>Dispatcher.Invoke</code> Panggilan dalam layanan domain melanggar prinsip segregasi tanggung jawab. </p><br><p>  Tentu saja, kami dapat mendeklarasikan suatu peristiwa dalam layanan domain, dan mengirimkan potongan dengan item yang diubah sebagai argumen peristiwa, kemudian berlangganan acara tersebut, merangkum <code>Dispatcher.Invoke</code> Menelepon memanggil balik antarmuka, sehingga aplikasi kami tidak akan bergantung pada GUI kerangka kerja, sebut antarmuka itu dari model tampilan dan modifikasi <code>ObservableCollection&lt;T&gt;</code> sesuai, tetapi ada banyak cara yang lebih elegan untuk menangani masalah seperti itu tanpa perlu menemukan kembali roda.  Apa yang kita tunggu? </p><br><h1 id="reactive-extensions-managing-observable-data-streams">  Ekstensi reaktif.  Mengelola Streaming Data yang Dapat Diamati </h1><br><p>  Untuk sepenuhnya memahami abstraksi yang diperkenalkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> , dan cara bekerja dengan mengubah set data reaktif, mari kita ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa itu pemrograman reaktif dan bagaimana menggunakannya dalam konteks platform Microsoft .NET dan pola desain MVVM</a> .  Cara mengatur interaksi antar komponen program dapat bersifat interaktif atau reaktif.  Dengan pendekatan interaktif, konsumen menerima data dari produsen secara serempak (berbasis pull, T, IEnumerable), dan dengan pendekatan reaktif, produsen mendorong data ke konsumen secara tidak sinkron (berbasis push, Tugas, IObservable). </p><br><img width="500" src="https://habrastorage.org/webt/mb/ts/mj/mbtsmjfyhjqeeb4tv8ynotvkdms.png"><br><p><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman reaktif</a> adalah pemrograman dengan aliran data asinkron, dan ekstensi reaktif adalah implementasi pemrograman reaktif, berdasarkan pada antarmuka <code>IObserver</code> dan <code>IObserver</code> dari namespace System, yang mendefinisikan serangkaian operasi mirip LINQ pada antarmuka <code>IObservable</code> , yang dikenal sebagai LINQ over Observable.  Ekstensi reaktif mendukung .NET Standard dan berjalan di mana pun Microsoft .NET menjalankan. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ue/qe/80/ueqe80neq0ufivj-bq5hipdrldo.gif"></a> <br><br>  ReactiveUI menawarkan pengembang aplikasi untuk mengambil keuntungan dari menggunakan implementasi reaktif untuk antarmuka <code>ICommand</code> dan <code>INotifyPropertyChanged</code> , dengan menyediakan alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ReactiveCommand&lt;TIn, TOut&gt;</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>WhenAnyValue</code></a> .  <code>WhenAnyValue</code> memungkinkan Anda untuk mengonversi properti kelas yang mengimplementasikan antarmuka <code>INotifyPropertyChanged</code> ke aliran peristiwa tipe <code>IObservable&lt;T&gt;</code> , ini menyederhanakan penerapan properti dependen. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ReactiveObject</span></span> { [Reactive] <span class="hljs-comment"><span class="hljs-comment">// Attribute from the ReactiveUI.Fody package, // takes care of aspect-oriented INPC implementation // for this particular property. public string Name { get; set; } public ExampleViewModel() { // Here we subscribe to OnPropertyChanged("Name") events. this.WhenAnyValue(x =&gt; x.Name) // IObservable&lt;string&gt; .Subscribe(Console.WriteLine); } }</span></span></code> </pre> <br><p>  <code>ReactiveCommand&lt;TIn, TOut&gt;</code> memungkinkan Anda untuk bekerja dengan perintah seperti halnya dengan <code>IObservable&lt;TOut&gt;</code> , yang diterbitkan kapan pun perintah menyelesaikan eksekusi.  Juga, perintah apa pun memiliki properti <code>IObservable&lt;Exception&gt;</code> tipe <code>IObservable&lt;Exception&gt;</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// ReactiveCommand&lt;Unit, int&gt; var command = ReactiveCommand.Create(() =&gt; 42); command // IObservable&lt;int&gt; .Subscribe(Console.WriteLine); command .ThrownExceptions // IObservable&lt;Exception&gt; .Select(exception =&gt; exception.Message) // IObservable&lt;string&gt; .Subscribe(Console.WriteLine); command.Execute().Subscribe(); // Outputs: 42</span></span></code> </pre> <br><p>  Hingga saat ini, kami telah bekerja dengan <code>IObservable&lt;T&gt;</code> , seperti peristiwa yang menerbitkan nilai baru tipe <code>T</code> setiap kali keadaan objek yang diamati berubah.  Sederhananya, <code>IObservable&lt;T&gt;</code> adalah aliran peristiwa, kumpulan tipe <code>T</code> terbentang dalam waktu. </p><br><p>  Tentu saja, kami dapat bekerja dengan koleksi dengan mudah dan alami - setiap kali koleksi berubah, kami dapat menerbitkan koleksi baru dengan elemen yang diubah.  Dalam hal ini, nilai yang dipublikasikan akan bertipe <code>IEnumerable&lt;T&gt;</code> atau lebih terspesialisasi, dan stream yang dapat diamati itu sendiri bertipe <code>IObservable&lt;IEnumerable&lt;T&gt;&gt;</code> .  Tetapi, seperti dicatat oleh pembaca yang berpikiran kritis, ini penuh dengan masalah kinerja kritis, terutama jika tidak ada selusin elemen dalam koleksi kami, tetapi seratus, atau bahkan beberapa ribu! </p><br><h1 id="introduction-to-dynamicdata">  Pengantar DynamicData </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> adalah perpustakaan yang memungkinkan Anda menggunakan kekuatan ekstensi reaktif saat bekerja dengan koleksi.  Rx sangat kuat, tetapi di luar kotak tidak menyediakan apa pun untuk membantu mengelola koleksi, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> memperbaikinya.  Di sebagian besar aplikasi, ada kebutuhan untuk memperbarui koleksi secara dinamis - biasanya, koleksi diisi dengan item saat aplikasi dimulai, dan kemudian koleksi diperbarui secara tidak sinkron, menyinkronkan informasi dengan server atau database.  Aplikasi modern cukup kompleks, dan seringkali perlu untuk membuat proyeksi koleksi - filter, transformasi, atau mengurutkan elemen.  DynamicData dirancang untuk menghilangkan kode yang sangat rumit yang kita perlukan untuk mengelola set data yang berubah secara dinamis.  Alat ini secara aktif mengembangkan dan memperbaiki, dan sekarang lebih dari 60 operator didukung untuk bekerja dengan koleksi. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/hn/7j/v3/hn7jv3fv1qgfxlhqrd9g6dokkao.gif"></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> bukan merupakan implementasi alternatif dari <code>ObservableCollection&lt;T&gt;</code> .  Arsitektur DynamicData didasarkan terutama pada konsep pemrograman berbasis domain.  Ideologi penggunaan didasarkan pada fakta bahwa Anda mengontrol sumber data tertentu, kumpulan kode yang bertanggung jawab untuk menyinkronkan dan bermutasi data memiliki akses.  Selanjutnya, Anda menerapkan serangkaian operator ke sumber data, dengan bantuan operator tersebut Anda dapat mengubah data secara deklaratif tanpa perlu secara manual membuat dan memodifikasi koleksi lainnya.  Bahkan, dengan DynamicData Anda memisahkan operasi baca dan tulis, dan Anda hanya bisa membaca dengan cara reaktif - oleh karena itu, koleksi yang diwarisi akan selalu tetap disinkronkan dengan sumbernya. </p><br><p>  Alih-alih <code>IObservable&lt;T&gt;</code> klasik <code>IObservable&lt;T&gt;</code> , DynamicData mendefinisikan operasi pada <code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code> dan <code>IObservable&lt;IChangeSet&lt;TValue, TKey&gt;&gt;</code> , di mana <code>IChangeSet</code> adalah bongkahan berisi informasi tentang perubahan koleksi, termasuk jenis perubahan dan elemen yang terpengaruh.  Pendekatan ini dapat secara signifikan meningkatkan kinerja kode untuk bekerja dengan koleksi, ditulis secara reaktif.  Anda selalu dapat mengubah <code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code> menjadi <code>IObservable&lt;IEnumerable&lt;T&gt;&gt;</code> , jika perlu mengakses semua elemen koleksi sekaligus.  Jika ini terdengar sulit - jangan khawatir, contoh kode di bawah ini akan membuat semuanya jelas! </p><br><h1 id="dynamicdata-in-action">  Data dinamis dalam aksi </h1><br><p>  Mari kita lihat beberapa contoh untuk lebih memahami bagaimana DynamicData bekerja, bagaimana ia berbeda dari System.Reactive dan tugas-tugas apa yang biasa diselesaikan oleh pengembang perangkat lunak GUI.  Mari kita mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh komprehensif yang dipublikasikan di GitHub</a> .  Dalam contoh ini, sumber data adalah <code>SourceCache&lt;Trade, long&gt;</code> berisi kumpulan transaksi.  Tujuannya adalah hanya menampilkan transaksi aktif, mengubah model menjadi objek proxy, mengurutkan koleksi. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// The default collection from the System.Collections.ObjectModel // namespace, to which we bind XAML UI controls. ReadOnlyObservableCollection&lt;TradeProxy&gt; list; // The mutable data source, containing the list of transactions. // We can use Add, Remove, Insert and similar methods on it. var source = new SourceCache&lt;Trade, long&gt;(trade =&gt; trade.Id); var cancellation = source // Here we transform the data source to an observable change set. .Connect() // Now we have IObservable&lt;IChangeSet&lt;Trade, long&gt;&gt; here. // Filter only active transactions. .Filter(trade =&gt; trade.Status == TradeStatus.Live) // Transform the models into proxy objects. .Transform(trade =&gt; new TradeProxy(trade)) // No we have IObservable&lt;IChangeSet&lt;TrandeProxy, long&gt;&gt; // Order the trade proxies by timestamp. .Sort(SortExpressionComparer&lt;TradeProxy&gt; .Descending(trade =&gt; trade.Timestamp)) // Use the dispatcher scheduler to update the GUI. .ObserveOnDispatcher() // Bind the sorted objects to the collection from the // System.Collections.ObjectModel namespace. .Bind(out list) // Ensure that when deleting elements from the // collections, the resources will get disposed. .DisposeMany() .Subscribe();</span></span></code> </pre> <br><p>  Dalam contoh di atas, ketika mengubah <code>SourceCache</code> yang merupakan sumber data, <code>ReadOnlyObservableCollection</code> juga berubah.  Pada saat yang sama, ketika menghapus item dari koleksi, metode <code>Dispose</code> akan dipanggil, koleksi akan selalu diperbarui hanya dari utas GUI dan akan tetap disortir dan disaring.  Keren, sekarang kami tidak punya <code>Dispatcher.Invoke</code> Panggilan telepon dan kode sederhana dan mudah dibaca! </p><br><h1 id="data-sources-sourcelist-and-sourcecache">  Sumber Data.  SourceList dan SourceCache </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DynamicData</a> menyediakan dua koleksi khusus yang dapat digunakan sebagai sumber data yang bisa berubah.  Koleksi-koleksi ini adalah <code>SourceList&lt;TObject&gt;</code> dan <code>SourceCache&lt;TObject, TKey&gt;</code> .  Disarankan untuk menggunakan <code>SourceCache</code> setiap kali <code>TObject</code> memiliki kunci unik, jika tidak gunakan <code>SourceList</code> .  Objek-objek ini menyediakan familiar untuk .NET developer API untuk manajemen koleksi - metode-metode seperti, <code>Add</code> , <code>Remove</code> , <code>Insert</code> .  Untuk mengonversi sumber data ke <code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code> atau ke <code>IObservable&lt;IChangeSet&lt;T, TKey&gt;&gt;</code> , gunakan operator <code>.Connect()</code> .  Misalnya, jika Anda memiliki layanan yang secara berkala memperbarui koleksi item di latar belakang, Anda dapat dengan mudah menyinkronkan daftar item-item ini dengan GUI, tanpa <code>Dispatcher.Invoke</code> dan kode boilerplate serupa: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BackgroundService</span></span> : <span class="hljs-title"><span class="hljs-title">IBackgroundService</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Declare the mutable data source containing trades. private readonly SourceList&lt;Trade&gt; _trades; // Expose the observable change set to the outside world. // If we have more than one subscriber, it is recommended // to use the Publish() operator from reactive extensions. public IObservable&lt;IChangeSet&lt;Trade&gt;&gt; Connect() =&gt; _trades.Connect(); public BackgroundService() { _trades = new SourceList&lt;Trade&gt;(); _trades.Add(new Trade()); // Mutate the source list! // Even from the background thread. } }</span></span></code> </pre> <br><p>  Dengan bantuan operator DynamicData yang kuat, kita dapat mengubah <code>IObservable&lt;IChangeSet&lt;Trade&gt;&gt;</code> menjadi <code>ReadOnlyObservableCollection</code> dideklarasikan dalam model tampilan kami. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TradesViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ReactiveObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReadOnlyObservableCollection&lt;TradeVm&gt; _trades; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadOnlyObservableCollection&lt;TradeVm&gt; Trades =&gt; _trades; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TradesViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBackgroundService background</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Connect to the data source, transform elements, bind // them to the read-only observable collection. background.Connect() .Transform(x =&gt; new TradeVm(x)) .ObserveOn(RxApp.MainThreadScheduler) .Bind(out _trades) .DisposeMany() .Subscribe(); } }</span></span></code> </pre> <br><p>  Selain operator <code>Transform</code> , <code>Filter</code> dan <code>Sort</code> , DynamicData mendukung pengelompokan, operasi logis, perataan koleksi, penggunaan fungsi agregat, penghapusan elemen identik, penghitungan elemen, dan bahkan virtualisasi pada level model tampilan.  Anda dapat membaca lebih lanjut tentang semua operator di <a href="">README proyek di GitHub</a> . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/jy/6-/4a/jy6-4azw__6rou9alucffpjhkrq.gif"></a> <br><br>  Selain dari <code>SourceList</code> dan <code>SourceCache</code> , pustaka DynamicData menyertakan implementasi koleksi yang dapat berulir tunggal - <code>ObservableCollectionExtended</code> .  Untuk menyinkronkan dua koleksi dalam model tampilan Anda, nyatakan salah satunya sebagai <code>ObservableCollectionExtended</code> , dan yang lainnya sebagai <code>ReadOnlyObservableCollection</code> , dan kemudian gunakan operator <code>ToObservableChangeSet</code> , yang melakukan hal yang hampir sama dengan Connect, tetapi dimaksudkan untuk bekerja dengan <code>ObservableCollection</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Declare the derived collection. ReadOnlyObservableCollection&lt;TradeVm&gt; _derived; // Declare and initialize the source collection. var source = new ObservableCollectionExtended&lt;Trade&gt;(); source.ToObservableChangeSet(trade =&gt; trade.Key) .Transform(trade =&gt; new TradeProxy(trade)) .Filter(proxy =&gt; proxy.IsChecked) .Bind(out _derived) .Subscribe();</span></span></code> </pre> <br><p>  DynamicData juga mendukung pelacakan perubahan di kelas yang mengimplementasikan antarmuka <code>INotifyPropertyChanged</code> .  Misalnya, jika Anda ingin menerima pemberitahuan setiap kali properti berubah, gunakan operator <code>AutoRefresh</code> dan berikan pemilih properti yang diperlukan.  <code>AutoRefresh</code> dan operator DynamicData lainnya memungkinkan Anda untuk dengan mudah memvalidasi sejumlah besar formulir dan formulir bersarang yang ditampilkan di layar! </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// IObservable&lt;bool&gt; var isValid = databases .ToObservableChangeSet() // Subscribe only to IsValid property changes. .AutoRefresh(database =&gt; database.IsValid) // Materialize the collection. .ToCollection() // Determine if all forms are valid. .Select(x =&gt; x.All(y =&gt; y.IsValid)); // If ReactiveUI is used, you can transform the // IObservable&lt;bool&gt; variable to a property declared // as ObservableAsPropertyHelper&lt;bool&gt;, eg IsValid. _isValid = isValid .ObserveOn(RxApp.MainThreadScheduler) .ToProperty(this, x =&gt; x.IsValid);</span></span></code> </pre> <br><p>  Anda dapat membuat UI kompleks menggunakan fungsionalitas DynamicData, dan ini sangat relevan untuk sistem yang menampilkan sejumlah besar data secara real time, seperti aplikasi pesan instan dan sistem pemantauan. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/98/nh/ws/98nhws7gl4yzk8kgcovbpvvozoi.gif"></a> <br><br></p><br><h1 id="conclusion">  Kesimpulan </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactiveX</a> adalah alat yang ampuh yang memungkinkan Anda untuk bekerja dengan aliran acara dan dengan UI, menulis kode portabel dan dapat dipelihara dan menyelesaikan tugas-tugas kompleks dengan cara yang sederhana dan elegan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactiveUI</a> memungkinkan para pengembang .NET untuk mengintegrasikan ekstensi reaktif ke dalam proyek mereka menggunakan arsitektur MVVM dengan implementasi reaktif dari <code>INotifyPropertyChanged</code> dan <code>ICommand</code> , sementara DynamicData menangani manajemen pengumpulan dengan menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>INotifyCollectionChanged</code></a> , memperluas kemampuan ekstensi reaktif dengan fokus pada kinerja. </p><br><p>  Pustaka ReactiveUI dan DynamicData sepenuhnya kompatibel dengan semua kerangka kerja GUI pada platform .NET, termasuk Windows Presentation Foundation, Universal Windows Platform, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Avalonia</a> , Xamarin. Android, Formulir Xamarin, dan Xamarin iOS.  Anda bisa mulai mempelajari DynamicData pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman yang sesuai dari dokumentasi ReactiveUI</a> .  Juga berhati-hatilah untuk membiasakan diri Anda dengan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cuplikan DynamicData</a> , yang berisi sampel kode untuk hampir semua yang Anda butuhkan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454074/">https://habr.com/ru/post/id454074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454062/index.html">Telepon perusahaan - seperti pisau Swiss: untuk inventaris, obrolan, panggilan dukungan, dan pertanyaan</a></li>
<li><a href="../id454064/index.html">Kisah AI yang tak terhitung</a></li>
<li><a href="../id454066/index.html">Cara berhenti melupakan indeks dan mulai memeriksa rencana eksekusi dalam pengujian</a></li>
<li><a href="../id454070/index.html">Memilih monowheel untuk bepergian</a></li>
<li><a href="../id454072/index.html">Lima contoh kebohongan terbesar tentang 5G</a></li>
<li><a href="../id454076/index.html">DotNext 2019 Piter: laporan kecil</a></li>
<li><a href="../id454078/index.html">"Konten seluler" gratis, tanpa SMS dan pendaftaran. Detail penipuan megafon</a></li>
<li><a href="../id454082/index.html">Gelombang plastik: bencana ekologis lautan</a></li>
<li><a href="../id454084/index.html">Pedoman langsung - MDX dan kerangka kerja lainnya</a></li>
<li><a href="../id454086/index.html">Apa yang diingat RIT ++ 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>