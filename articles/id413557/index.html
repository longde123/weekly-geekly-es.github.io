<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’¼ ğŸ§™ğŸ» ğŸŒŒ NewSQL: SQL tidak ke mana-mana ğŸ§—ğŸ½ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ½ ğŸ‘©ğŸ¾â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tren NoSQL sudah hampir 10 tahun, dan Anda dapat dengan aman menarik kesimpulan dan generalisasi. Kami akan melakukan ini dan berbicara tentang pengem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NewSQL: SQL tidak ke mana-mana</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/413557/"> Tren NoSQL sudah hampir 10 tahun, dan Anda dapat dengan aman menarik kesimpulan dan generalisasi.  Kami akan melakukan ini dan berbicara tentang pengembangan NoSQL. <br><br>  Ingat bagaimana NoSQL lahir.  Mari kita lihat apa yang baik dan apa yang buruk di dalamnya, dan apa yang telah bertahan dalam ujian waktu.  Mari kita menganalisis fitur-fitur yang sudah ada dalam SQL, dan yang sekarang muncul di NoSQL DBMS.  Kami menyoroti nilai-nilai unik NoSQL, dan melihat sedikit ke depan pada apa yang akan terjadi di pasar besok. <br><br>  Dan Konstantin Osipov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@kostja</a> ), pengembang dan arsitek Tarantool DBMS, yang berbicara tentang tren NewSQL dalam laporannya di RIT ++ 2017, akan membantu kami dalam hal ini, karena arsitek seharusnya memahami apa yang terjadi di dunia basis data sehingga setidaknya menemukan kembali roda. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_8OZcgOKUyk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Tentang pembicara</b> : Sekarang Konstantin Osipov bekerja di Tarantool, tetapi sebelumnya berpartisipasi dalam pengembangan MySQL, dan ketika Konstantin mulai bekerja pada database baru, ia sangat bingung mengapa ini harus dilakukan sama sekali, mengapa database berikutnya diperlukan.  Secara khusus, sikap terhadap NoSQL sangat skeptis, seperti "under-SQL". <br><br>  Namun, pengembangan terus berlanjut, beberapa prinsip asli mati, dan, pada saat yang sama, database NoSQL mengambil alih kemampuan dari SQL klasik.  Berdasarkan hasil transformasi cepat selama beberapa tahun ini, sangat mungkin untuk menggambar hasil antara dan membiarkan diri Anda membuat beberapa prediksi untuk masa depan. <br><a name="habracut"></a><br><h2>  Rencanakan <br></h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Latar belakang</a>  Ingat bagaimana NoSQL lahir, apa yang baik dan apa yang buruk di dalamnya. <br></li><li>  Mari kita lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagaimana NoSQL telah teruji oleh waktu</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NoSQL SQL</a> : N1QL dan CQL.  Mari kita menganalisis fitur-fitur yang sudah ada dalam SQL, dan yang sekarang muncul di NoSQL DBMS. <br></li><li>  NoSQL sudah mati, dan NewSQL belum lahir: betapa hangatnya, tabung SQL berbeda dari SQL di NoSQL. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nilai unik dari NoSQL</a> .  Kita akan melihat apa yang baik terjadi dalam 10 tahun upaya dan apa yang akan terjadi selanjutnya. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Database Multi-Model dan NewSQL</a> .  Mari kita melihat sedikit ke depan pada apa yang akan ada di pasar besok. <br></li></ul><br><h2><a name="NoSQL_tenets"></a>  Prinsip NoSQL <br></h2><br>  Banyak orang berusaha untuk tetap menggunakan istilah NoSQL sekarang, tetapi secara luas diadopsi pada tahun 2009 ketika <strong>tagar #nosql</strong> muncul.  Pengembang dari Last.FM menemukan tag ini untuk mitap database terdistribusi. <br><br>  Setelah itu, tag mulai mendapatkan popularitas di Twitter, dan NoSQL menjadi saluran pembuangan atau corong untuk frustrasi, seperti saya menyebutnya - frustrasi yang telah terakumulasi selama bertahun-tahun bekerja dengan database tradisional. <br><br><blockquote>  NoSQL adalah jalan keluar untuk frustrasi, sebuah tag yang setiap orang yang belum memiliki cukup fitur SQL telah disesuaikan untuk dirinya sendiri. <br></blockquote><br>  Rasa frustrasi ini perlu disusun dan ditentukan dengan cara tertentu yang paling sering orang tidak sukai dalam DBMS tradisional.  Kita dapat membedakan 3 blok besar tugas untuk solusi yang NoSQL dibuat: <br><br><ul><li>  <strong>penskalaan horizontal;</strong> <br></li><li>  <strong>model data baru;</strong> <br></li><li>  <strong>model baru konsistensi.</strong> <br></li></ul><br>  Mari kita lihat apa blok-blok ini.  Ambil, misalnya, basis data nilai-kunci.  Gagasan utama dari model data Key-value adalah bahwa databasenya sederhana, tetapi dapat diskalakan.  Sejumlah besar masalah jatuh di pundak pengembang, tetapi ia memiliki jaminan ketat bahwa basis datanya akan <strong>terukur tak terhingga</strong> .  Tapi skalabilitas tanpa batas bukanlah sihir.  Jaminan skalabilitas dicapai karena <strong>semantik yang sangat sederhana dari</strong> operasi yang didukung: dalam database nilai kunci, operasi apa pun memengaruhi secara ketat satu simpul gugus. <br><br>  Awalnya, sangat sulit bagi masyarakat untuk memisahkan model data dari model skala.  Jika Anda melihat Cassandra yang sama, pada versi awal model datanya disebut Wide Column Store - basis data kolom yang luas.  Jika ada satu indeks dalam nilai kunci DBMS, dengan kunci, maka di toko kolom luas dua indeks selalu dibuat secara otomatis: dengan kunci dan oleh Keluarga Kolom. <br><br>  Selain itu, indeks menurut kunci dapat shardable, dan indeks oleh Keluarga Kolom adalah lokal untuk simpul data tertentu.  Karena ini, kami mencapai penskalaan horizontal, tetapi pada saat yang sama mendapat kesempatan untuk melakukan kueri lokal pada keluarga kolom.  Old-timer ingat bahwa fitur serupa diimplementasikan di Oracle, sambil mempertahankan model relasional, dan disebut tabel gabungan.  Fitur ini memungkinkan untuk menentukan lokasi fisik dari dua tabel dalam formulir bergabung.  Toko kolom luas di Cassandra - mengimplementasikan tabel gabungan dengan distribusi otomatis di seluruh cluster. <br><br><blockquote>  Penggabungan model data dan model skala persis masalah yang diselesaikan dengan menggunakan model relasional.  Selamat datang di tahun 70an. </blockquote><br>  Selain model data baru, NoSQL telah menerapkan model konsistensi baru.  Ya, ya, lagi <strong>teorema CAP yang</strong> terkenal ini.  Berbicara tentang teorema CAP menghibur saya sepanjang waktu - siapa yang membutuhkannya?  Karena tidak ada penguatan dari kesegaran kedua, maka tidak ada jawaban lain untuk pertanyaan tentang konsistensi data kecuali satu: <strong>database harus menjamin konsistensi ini</strong> .  Karena itu, model konsistensi baru juga, menurut pendapat saya, merupakan tren yang sedang sekarat. <br><br><h2><a name="NoSQL_today"></a>  NoSQL hari ini <br></h2><br>  Tesis yang ingin saya ungkapkan pertama-tama adalah bahwa seluruh gerakan NoSQL selamat: <br><br><ul><li>  penskalaan horizontal; </li><li>  <s>model data baru model</s> dokumen data dan grafik; </li><li>  <s>model baru konsistensi.</s> </li></ul><br>  Dari tesis tentang model data baru, hampir satu setengah selamat dan tesis tentang model konsistensi benar-benar mati. <br><br><h2>  Topi kematian <br></h2><br>  Mengapa beberapa model konsistensi tidak bertahan? <br><br>  â— <strong>Konsistensi akhirnya: inflasi jangka</strong> <br>  Siapa yang menggunakan database yang memiliki jam vektor yang berfungsi dan logika bisnis dari aplikasi diarahkan ini?  - tidak seorangpun.  Siapa yang menggunakan basis data yang memiliki CRDT (tipe data yang direplikasi bebas konflik)?  Siapa yang menggunakan Riak?  - tidak seorangpun.  Apa yang digunakan orang?  Lebih sering PostgreSQL, lebih jarang basis lainnya, misalnya, MongoDB. <br><br>  â— <strong>MongoDB: atom diganti dengan terisolasi, transaksi ditambahkan dalam 3.xx</strong> <br>  Basis data ini memiliki replikasi asinkron.  Ini adalah hal yang sangat mudah dimengerti, meskipun, pada kenyataannya, <strong>ada 4 jenis replikasi asinkron</strong> .  Replikasi data transaksi dapat terjadi setelah transaksi dilakukan secara lokal;  sebelum transaksi dilakukan secara lokal. <br><br>  Artinya, komit ke database utama dapat dikorelasikan dengan komit ke replika dengan berbagai cara juga. <br><br>  Entri ke log lokal sudah dibuat, tetapi belum diterbangkan ke replika.  Misalkan Anda ingin menunggunya untuk setidaknya terbang ke replika.  Terbang - tidak berarti terbang.  Tiba - ini tidak berarti bahwa itu ditulis ke jurnal lokal di replika. <br><br>  Awalnya, MongoDB memiliki mode: permintaan tiba di server, database menjawab OK - itu bahkan belum sampai ke disk, atau ke buku log - tidak pergi ke mana-mana.  Karena ini, semuanya bekerja sangat cepat, tetapi kemudian mereka mulai mengkritik MongoDB untuk ini, dan secara default di rilis kemudian 3+, setelah semua, pertama-tama mulai menulis transaksi ke log, dan hanya setelah itu mengirim konfirmasi kepada klien. <br><br>  Artinya, bahkan replikasi asinkron adalah jurang model semantik.  Oleh karena itu, <strong>model konsistensi terlalu rumit untuk dipahami oleh kalangan pengembang yang luas, dan transaksi serta replikasi sinkron menggantikan bermacam-macam model eksotis</strong> . <br><br>  Terhadap latar belakang kematian model konsistensi, masih ada tren yang menarik dalam pengembangan konsistensi yang sebenarnya lebih ketat.  Ada transaksi di Redis, meskipun saya tidak akan menyebutnya transaksi, tetapi dengan mengorbankan apa transaksi nyata, ada kontroversi tanpanya. <br><br>  Mari kita lihat sejarah transaksi di NoSQL.  Awalnya, MongoDB menerapkan atomisitas tingkat dokumen.  Kemudian mode eksekusi terisolasi ditambahkan untuk memungkinkan pengembang, jika mereka benar-benar ingin, memperbarui beberapa dokumen secara atom. <br><br>  â— <strong>Redis transaksi</strong> <br>  Pada awal NoSQL, pengembang ditawari untuk menempatkan seluruh kasus bisnis dalam satu keranjang dokumen.  Keseluruhan aliran muncul yang disebut desain berbasis domain, yang meningkatkan penyimpangan ini ke peringkat pola desain.  Memang, jika semuanya disimpan dalam satu dokumen, atomicity dicapai hanya: Anda melakukan satu transaksi, satu proses bisnis dan Anda memiliki satu perubahan atom dalam satu dokumen. <br><br>  Tapi ternyata ini tidak berhasil.  Data perlu dinormalisasi untuk menghindari redudansi penyimpanan.  Mereka perlu dinormalisasi untuk pertanyaan analitis.  Pada akhirnya, model data berkembang - dan dokumen yang kemarin dapat menyimpan semua informasi yang diperlukan untuk skenario bisnis saat ini perlu diperluas dan ditambah. <br><br>  Apakah masalah atomisitas menunjukkan?  seberapa dekat model data terkait dengan model konsistensi - munculnya transaksi dan replikasi sinkron membuat sebagian besar model di NoSQL tidak perlu. <br><br><h2>  Model data <br></h2><br>  Sekarang mari kita bicara tentang kisah selanjutnya - kisah dengan model data. <br><br>  Kelompok model data ditemukan setelah SQL: <br><br><ul><li>  Nilai Kunci <br></li><li>  Dokumenter <br></li><li>  Toko Kolom Lebar; <br></li><li>  Server struktur data (untuk Redis); <br></li><li>  Database grafik. <br></li></ul><br>  Keren!  Kami memiliki begitu banyak model data!  Dan seberapa baik skala mereka? <br><br>  Ini adalah tesis, terutama terkait dengan apa yang disebut hiper-konvergensi, ketika semua proyek modern menggunakan server server tunggal murah dan bisnis berhenti membeli mesin yang skalabilitasnya vertikal. <br><br>  Hyperconvergence telah datang ke dalam kehidupan kita secara menyeluruh sehingga hari ini bahkan di dalam mesin skala vertikal, jika ada, sudah ada perangkat lunak yang dapat diskalakan secara horizontal - lihat bagaimana PureStorage bekerja atau, jika Anda ingat, pada malam hari, Nutanix.  Tentu saja, mereka menjual lemari kepada orang-orang, tetapi lemari ini diatur di dalam seperti rak biasa di penyedia hosting. <br><br>  Artinya, penskalaan horizontal adalah tren yang memberi tekanan pada semua orang, termasuk para penemu model data baru.  Jadi model data mana yang bagus untuk penskalaan horizontal, dan mana yang buruk? <br><br>  Apakah baik atau buruk untuk penskalaan horizontal?  Jawabannya, sebenarnya, cukup kontroversial, kami akan kembali lagi nanti. <br><br><h3>  Redis <br></h3><br>  Ketika Redis menambahkan cluster Redis, ternyata tidak semua skala operasi model data normal secara horizontal. <br><br><img src="https://habrastorage.org/webt/e9/j_/lu/e9j_lugugsuorakmg8o8qonvqmi.jpeg"><br><br>  Ini adalah kutipan dari dokumentasi di mana mereka menulis bahwa sesuatu bekerja untuk mereka di beling tertentu, dan sesuatu yang benar-benar berfungsi seperti di cluster nyata. <br><br>  Masalah mendasar dari pendekatan ini adalah sama seperti di MySQL, yang kami ambil dan berjabat tangan.  Artinya, pengembang memiliki dua model data: <br><br><ol><li>  Dalam satu, ia berpikir dalam kerangka aljabar relasional. <br></li><li>  Kemudian, ketika dia berpikir tentang sharding independen, dia berpikir dalam model data aljabar shard-relational. <br></li></ol><br>  <strong>Model data yang baik harus bersifat universal</strong> .  Apa yang indah tentang aljabar relasional - hasil proyeksi adalah relasi, hasil dari operator mana pun adalah relasi.  Dan segera setelah kita secara manual mulai sharding MySQL ke cluster, kita kehilangan itu. <br><br>  Namun, Redis menambahkan cluster Redis karena <strong>semua orang ingin skala secara horizontal</strong> . <br><br><h3>  Database grafik <br></h3><br>  Database grafik adalah contoh yang baik yang membantu <strong>memisahkan konsep skala horisontal komputasi dan penyimpanan</strong> .  Informasi selalu dapat dibagi dengan sejumlah node.  Tetapi jika database pada dasarnya dirancang untuk memproses data yang disimpannya, dan perhitungan ini tidak diskalakan secara horizontal, maka masalah muncul dari penyimpanan horisontal yang efektif yang memungkinkan perhitungan bekerja. <br><br>  Mari kita lihat masalah penskalaan grafik DBMSs - SQL DBMSs menghadapi hambatan skala yang sangat mirip. <br><br><img src="https://habrastorage.org/webt/pc/yp/mm/pcypmmbjtpdrzvgb4yqhwqd5f4g.jpeg"><br><br>  Ambil basis data lokal tempat grafik disimpan.  Cepat atau lambat, satu node terisi, dan kita mulai menggunakan node lain.  Segera setelah kami menggunakan lebih dari satu simpul, simpul pusat menjadi kelebihan beban, karena lokalitas permintaan hilang.  Beberapa pertanyaan pada grafik dipaksa untuk mengikuti beberapa node fisik, yaitu penundaan jaringan muncul. <br><br>  Misalkan kita melakukan sesuatu yang berbeda - mereka mengambil dan menghancurkan segalanya dengan fungsi sharding yang baik.  Kami menghitung hash tertentu, menyebarkan semua data di cluster kami secara acak - dan kami mendapatkan masalah lain. <br><br><img src="https://habrastorage.org/webt/g_/sh/z5/g_shz5c2avjc9vhwhtyfqmrwgbi.jpeg"><br><br>  Jika dalam skema sebelumnya setidaknya beberapa kueri berfungsi dengan baik, maka <strong>100% kueri itu bodoh di sini</strong> , karena sebagian besar kueri basis data terhubung dengan grafik <strong>traversal</strong> .  Setiap jalan memutar dari node harus pergi ke suatu tempat, dan paling sering, untuk menghitung permintaan, Anda harus pergi ke node lain. <br><br><img src="https://habrastorage.org/webt/hm/sg/hp/hmsghpnyj_w7yzi80oyuc6ecf3s.jpeg"><br><br>  Gagasan muncul sekitar beling, seperti yang ditunjukkan pada diagram di atas: temukan cluster dan letakkan di node Anda: himpunan bagian yang terhubung erat ditempatkan bersama-sama, himpunan bagian yang terhubung lemah diberi jarak. <br><br>  Ini adalah beberapa opsi ideal, tetapi <strong>opsi ideal hanya ada dalam teori</strong> .  Data langsung tidak cocok dengan partisi statis.  Untuk menerapkan pendekatan ini, kita harus secara otomatis mendeteksi cluster pada set yang berubah secara dinamis, terus-menerus memindahkan node tergantung pada ikatan yang muncul dan menghilang. <br><br>  Oleh karena itu, pada umumnya Neo4j diskalakan seperti database SQL klasik.  Mereka telah bekerja pada sharding selama beberapa waktu, mencoba menyelesaikan masalah yang dijelaskan. <br><br>  Tesis yang saya kemukakan adalah bahwa <strong>penskalaan horizontal</strong> memberikan <strong>tekanan pada semua orang</strong> , dan semua model data cepat atau lambat akan dipaksa untuk mengimplementasikannya.  Tetapi beberapa model akan tetap bersama kami, sementara beberapa tidak. <br><br>  Jadi, misalnya, jika kita mempertimbangkan database Key-Value dan Dokumen dalam bentuk murni, maka pernyataan saya adalah bahwa mereka tidak akan.  Jika Anda melihat basis data grafik, mereka sudah menempati segmen yang signifikan, tetapi berada di bawah tekanan penskalaan horizontal. <br><br>  Apakah basis data grafik akan hilang?  Kemungkinan besar <strong>kolom, seperti dokumen, akan dimasukkan dalam semua produk</strong> .  Tren ini disebut database multi-model, dan nanti dalam laporan ini saya akan memberikan contoh bagaimana ini bisa bekerja dalam praktiknya.  Tetapi untuk sekarang, sebagai ilustrasi lain dari tren database multi-model, mari kita lihat JSON. <br><br><h3>  Json <br></h3><br>  Di bawah ini adalah contoh bagaimana tren yang menjadi semua mencakup bekerja. <br><br><blockquote>  Saya berpendapat bahwa setiap basis data yang bahkan mampu mendukung JSON dengan cara apa pun akan mendukung JSON. </blockquote><br>  Mungkin beberapa database untuk komputasi matriks tidak akan mendukung JSON.  Tapi kemungkinan besar itu akan berguna.  Dan yang lainnya pasti. <br><br><table border="1"><tbody><tr><td width="141"></td><td width="94">  MySQL <br></td><td width="95">  PostgreSQL <br></td><td width="66">  Redis <br></td><td width="85">  Couchbase <br></td><td width="85">  Cassandra <br></td><td width="56">  Neo4j <br></td></tr><tr><td width="141">  Penyimpanan JSON <br></td><td width="94">  Ya <br></td><td width="95">  Ya <br></td><td width="66">  Ya <br></td><td width="85">  Ya <br></td><td width="85">  Ya <br></td><td width="56">  Ya! <br></td></tr><tr><td width="141">  Ops bidang JSON <br></td><td width="94">  Ya <br></td><td width="95">  Ya <br></td><td width="66">  Ya <br></td><td width="85">  Ya <br></td><td width="85">  Tidak <br></td><td width="56">  Tidak <br></td></tr><tr><td width="141">  Permintaan json <br></td><td width="94">  Ya <br></td><td width="95">  Ya <br></td><td width="66">  Tidak <br></td><td width="85">  Ya <br></td><td width="85">  Ya <br></td><td width="56">  Tidak <br></td></tr><tr><td width="141">  Indeks sekunder JSON <br></td><td width="94">  Ya <br></td><td width="95">  Ya <br></td><td width="66">  Tidak <br></td><td width="85">  Ya <br></td><td width="85">  Tidak <br></td><td width="56">  Tidak <br></td></tr></tbody></table><br>  Tabel ini memungkinkan Anda untuk melihat secara visual apa yang terjadi dengan model data.  Database relasional dalam dukungan mereka untuk JSON bahkan di depan yang non-relasional dari Cassandra yang sama.  Itu tidak memiliki kunci sekunder untuk bidang JSON.  Dan bahkan basis data grafik juga mulai memasukkan JSON, karena <strong>semua orang membutuhkan JSON</strong> . <br><br>  Dengan demikian, database multi-model, dan khususnya JSON sebagai tipe data yang ditemukan di hampir semua produk, adalah apa yang akan tetap dari NoSQL dengan serius dan untuk waktu yang lama. <br><br>  <strong>Tetapi jika semua database mendukung JSON, mengapa Anda membutuhkan database NoSQL sama sekali?</strong> <br><br>  Hanya ada satu cerita yang tersisa - penskalaan horisontal.  Kami ingin skala secara horizontal, dan itulah mengapa kami menggunakan sesuatu selain MySQL atau PostgreSQL. <br><br><img src="https://habrastorage.org/webt/qp/rj/up/qprjupel17nogdvuzw2eal03hw4.jpeg"><br><br>  Ini adalah keynote dari Thomas Ulin, VP MySQL Engineering di Oracle, yang berbicara tentang masa depan MySQL.  Hal yang sama terjadi di komunitas Postgres dan produk relasional lainnya.  Tekanan penskalaan horizontal memengaruhi 100% produk karena transisi ke hiper-konvergensi dan komputasi awan. <br><br>  Thomas mengatakan visi mereka adalah satu produk dengan ketersediaan tinggi dan skalabilitas di luar kotak.  Kita berbicara tentang ketersediaan tinggi terutama InnoDB Cluster, ini replikasi grup + InnoDB.  Database seperti itu tidak pernah mati, bahkan jika dipukul dengan palu. <br><br>  Kemudian Thomas menulis " <strong>fitur penskalaan yang dipanggang di</strong> " - "kami memanggang semua fitur ini."  Intinya adalah bahwa melalui rilis x (saya pikir x = 2, 3) mereka akan menerima MySQL Cluster dalam bentuk murni, yang akan mendukung SQL pada cluster, penyimpanan JSON dalam cluster. <br><br>  Sudah hari ini <strong>MySQL memiliki protokol X yang sangat mirip dengan MongoDB</strong> dan dirancang untuk bekerja dengan JSON. <br><br><h2><a name="SQL_NoSQL"></a>  SQL dalam NoSQL <br></h2><br>  Sekarang mari kita lihat pergerakan dari sisi lain.  Untuk menyatakan kematian, Anda perlu melihat tidak hanya pada bagaimana SQL mengadopsi prinsip-prinsip NoSQL, tetapi juga sebaliknya. <br><br><table border="1"><tbody><tr><td width="125"></td><td width="125">  Mongodb <br></td><td width="125">  Couchbase <br></td><td width="125">  Cassandra <br></td><td width="125">  Redis <br></td></tr><tr><td width="125">  Skema data <br></td><td width="125">  Ya * <br></td><td width="125">  Tidak <br></td><td width="125">  Ya <br></td><td width="125">  Tidak <br></td></tr><tr><td width="125">  Nilai NULLs / Absen <br></td><td width="125">  Ya * <br></td><td width="125">  Ya <br></td><td width="125">  Ya <br></td><td width="125">  Tidak <br></td></tr><tr><td width="125">  Bergabung <br></td><td width="125">  Ya <br></td><td width="125">  Ya <br></td><td width="125">  Tidak <br></td><td width="125">  Tidak <br></td></tr><tr><td width="125">  Kunci sekunder <br></td><td width="125">  Ya * <br></td><td width="125">  Ya <br></td><td width="125">  Ya, tapi ... <br></td><td width="125">  Tidak <br></td></tr><tr><td width="125">  KELOMPOK OLEH <br></td><td width="125">  Ya * <br></td><td width="125">  Ya <br></td><td width="125">  Tidak <br></td><td width="125">  Tidak <br></td></tr><tr><td width="125">  JDBC / ODBC <br></td><td width="125">  Tidak <br></td><td width="125">  Ya <br></td><td width="125">  Tidak <br></td><td width="125">  Tidak <br></td></tr></tbody></table><br>  Di sini, sebenarnya, ada juga wawasan yang menarik.  Menurut pendapat saya, saya mengambil para pemimpin.  Saya setuju bahwa tidak semuanya ada di sini, misalnya, Elastic juga merupakan pemimpin NoSQL.  Tapi Elastic masih merupakan solusi utama untuk pencarian teks lengkap, jadi saya tidak memasukkannya dalam tabel. <br><br>  Times Series Databases sebagai tren yang tidak saya sentuh.  Ada tesis di antara serangkaian gerakan yang mengatakan bahwa ini adalah ceruk yang terpisah, mirip dengan basis data grafik, tetapi jika Anda menggali lebih dalam, Postgres duduk di bawah tenda. <br><br><h3>  Couchbase <br></h3><br>  Menurut pendapat saya, Couchbase memiliki berbagai kemungkinan dari dunia SQL.  Semua orang tahu bahwa <strong>Couchbase adalah Memcached</strong> .  Dormando ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alan Kasindorf</a> ), salah satu pengembang Memcached memiliki visi produk yang sama sekali berbeda, yang tidak melibatkan penskalaan horizontal.  Oleh karena itu, Memcache bercabang untuk skala secara horizontal.  Itu berjalan dengan baik dan mulai melakukan bisnis di sekitarnya, kemudian bergabung dengan CouchDB dan seterusnya dan seterusnya. <br><br>  Couchbase awalnya mengatakan pada dirinya sendiri bahwa mereka adalah <strong>database schemaless</strong> .  Memcache pada awalnya merupakan nilai kunci yang sangat sederhana.  Sekarang mari kita lihat bagaimana identifikasi diri ini berubah seiring waktu. <br><br>  Sebagai contoh, Couchbase memiliki kunci sekunder, dan <strong>kunci sekunder sebenarnya adalah awal dari skema</strong> .  Jika Anda mengatakan bahwa Anda memiliki beberapa bidang yang digunakan untuk membuat indeks, maka Anda sudah berbicara tentang skema dokumen data yang Anda simpan. <br><br>  Selain itu, karena Couchbase secara bertahap memotong seluruh cerita tentang masa lalu Memcache dari dokumentasi hari ini, mereka juga akan memotong cerita tentang konsistensi akhirnya besok, meskipun hari ini masih ada banyak cerita tentang kurangnya konsistensi baca - kunci sekunder akhirnya konsisten. <br><br>  Tetapi yang menarik adalah bahwa Couchbase memiliki JDBC / ODBC.  ,       Tableau  ClickView â€” ,    CQL    SQL.   <strong>     â€”    SQL.</strong> <br><br>  ,    . <br><br><img src="https://habrastorage.org/webt/ru/4o/wy/ru4owybeykx975o_owylkunnxrw.jpeg"><br><br>     ,   - ,      ,   ,    -   â€”     ,     SQL. <br><br> ,    IS MISSING â€”   ,     IS NULL? <br><br>   JDBC, ODBC       SQL    ?   30-40  ,  SQL-      SQL  ,  ,       :     look-in,  ,           .. <br><br>  ,   . <strong> ,  ,    .</strong> <br><br>  ,  Couchbase  JDBC/ODBC â€”    .      ,   â€”   . <br><br><h3> Secondary keys <br></h3><br>  ,    NoSQL â€”   ,  â€”   ,    .     OrientDB, ,   ,   . <br><br> SQL-     ,     (  ,    ),  NoSQL,   . <br><br>   NoSQL-   secondary keys.    secondary keys? <br><br> <strong>        </strong> (  â€”    ): <br><br><ol><li>    ,     ,  <strong>  </strong> .               ,    range-,  SQL      .    range-             map/reduce   . <br></li><li>  <strong>    </strong> .     index notes,    .           range-  ..,     . <br></li></ol><br>           ,    , ,   ,     ,  .    ,      . <br><br> <strong>    </strong> .   , NoSQL-      SQL,   ,     ,     . <br><br>      :       CockroachDB?   : <strong>      ,       </strong> . ,  MySQL         â€”       legacy.    ,  ,     .. <br><br>    ,  NoSQL-      legacy  10   . ,   ,     .     SQL-   ,   PostgreSQL,  ,  MySQL   Couchbase  ,    True NewSQL. <br><br>     ,  secondary keys.  MongoDB   SQL,     . ,       JOINs,   ,    . <br><br>  Redis  No,       .  Redis    ,      â€”   .   ,      ,    ,    . <br><br>   ,  Redis    â€” ,    - .    ,    Redis-,  SQL.    ,     Redis SQLite,     â€” storage   â€”  Redis',  in memory. <br><br>  NoSQL   ,         ,     ? <br><br><h3>   <br></h3><br>    ,  NoSQL     .   ,   ,    ,   SQL     .       SQL  . <br><br>  schemaless  ,    ,   ,     waterfall    :    agile,        -     .    ,        ,    CREATE TABLE,    . <br><br>   ,   online alter table.   Oracle    ,          . <br><br>     SQL      ,   . <strong>       MongoDB â€”  ,     </strong> . <br><br>  MongoDB   ,  schemaless.        .   ,     ,      strict.  validation level  validation action. Validation level   ,           . <br><br>     ,       ,     - .          ,   ,   .  validation action     reject,  warn:   warning,     validation action. <br><br>   <strong>        </strong> .  ,  MongoDB (      Tarantool),     . <br>  Cassandra        JSON,      .      â€”    ,    .  ,   ,   NoSQL,    . <br><br><h3>  <br></h3><br>   -,  NoSQL     SQL     . <br><br><img src="https://habrastorage.org/webt/je/z2/fj/jez2fj0_acxhcfrhuqh4zis3-es.jpeg"><br><br>  eventually consistent  ,    ,        ,    <strong> </strong> .    ,      â€”    .   . <br><br>       ? <br><br>     ,    ,    .   BigQuery      , , Vertica,     . <br><br>  NoSQL     .  ,     SELECT    LTP,    LTP -   Key-value. <br><br><blockquote>    ,    NoSQL-          . </blockquote><br>   SELECT  JOIN    ,    ,    ,  <strong>    </strong> â€”    .. <br><br><h2><a name="NoSQL_val"></a> NoSQL:   <br></h2><br> ,    <strong></strong> ,     ,       .     <strong>domain-specific languages</strong> . <br><br> NoSQL     DSL.     â€”  <strong>RethinkDB ReQL</strong> .    ,    â€”         domen specific language.     Python,  JavaScript  .. â€”      .      SQL  ,           . <br><br>       ReQL,  . ReQL ,     ,     â€”      .    RethinkDB, ,   ,     ,      ,   . <br><br>      : <br><br><ul><li> Elasticsearch Query Language: <ul><li> MIN/MAX/AVG; </li><li> derivative/percentiles/histogram/cumulative sum/serial diff; </li></ul></li><li> JSONIQ; <br></li><li> GraphQL; <br></li><li> SparQL; <br></li><li> Pregel. <br></li></ul><br>   , ,       SQL,   . <strong> -  SQL!</strong> <br><br>     SQL â€”    OLTP ,  GROUP BY, Window Functions,       (recursive). SQL    ,      .     !        ,   ,    . <br><br><blockquote> ,   ,   . ,     ,    , ,       . <br></blockquote><br> , , Pregel â€”     .     :   ,               /   .  -    ,  .   ,      ,     . <br><br>  -    SQL,    ,      ,       . <br><br>   ,  ,     <strong> ,  ,       </strong> .   . <br><br><h2><a name="MMDB"></a> -   <br></h2><br>  ,     ,   .      . <br><br><img src="https://habrastorage.org/webt/ul/ov/dv/ulovdv_tas-ndbzdymkwujc-cdm.jpeg"><br><br>    ArangoDB,      -      :   ,    ,   ( ),      ,    . <br><br><img src="https://habrastorage.org/webt/pp/k4/tb/ppk4tbnrjvmxesm52ac3somgiz4.jpeg"><br><br>   , ,          .               .    :  ,     . <br><br><img src="https://habrastorage.org/webt/zg/ml/gy/zgmlgy0df4it9m10lfxzyqnk4lo.jpeg"><br><br>    ,     ,    . ,  ,      ,    ,     .     . <br><br> <strong>           </strong> .           ,   ,   relations.  ,   relation    ,    ,       relations  .. <br><br><h2> UPSERT:   <br></h2><br>  Ini bukan sepenuhnya tentang NoSQL, tetapi ini adalah tren yang tampaknya sangat penting bagi saya - ini adalah <strong>penyimpanan tulis yang dioptimalkan</strong> - yang, menurut pendapat saya, akan tetap bersama kami dengan serius dan untuk waktu yang lama. <br><br>  SQL atau NoSQL tidak memiliki pernyataan yang hanya menulis secara alami.  Bahkan absen, yang ada di MongoDB, dalam sejumlah kasus juga membaca data.  Sisipan juga merupakan operasi baca, karena jika ID sudah ditentukan dalam dokumen, maka Anda perlu memeriksa bahwa tidak ada ID tersebut. <br><br>  Anda katakan - jika ada indeks, maka kita harus membaca.  Tetapi <strong>bahkan jika ada indeks, maka membaca tidak selalu diperlukan</strong> .  Idenya adalah ini - Anda tidak ingin membaca dalam hal apapun, Anda tidak perlu melakukan ini, Anda tidak peduli dengan hasil membaca.  Anda ingin menambahkan data ke basis data jika belum ada di sana.  Jika ada, misalkan Anda mengganti versi lama dengan yang baru atau menjalankan semacam perintah penggabungan.  Artinya, Anda harus menciptakan <strong>semantik baru</strong> agar tidak membaca. <br><br>  Menurut pendapat saya, tidak ada satu pun database yang menyediakan ini sekarang, tetapi daya tarik dari algoritma yang dioptimalkan sangat besar sehingga saya benar-benar menginginkan kemungkinan ini.  Karena berkat menulis penyimpanan yang dioptimalkan, pohon-pohon LSM (RocksDB, LevelDB dan lain-lain) <strong>menulis kinerja tanpa membaca adalah 2 urutan lebih tinggi daripada kinerja menulis dengan membaca</strong> .  Alih-alih 10 ribu permintaan per detik, mungkin ada satu juta pada satu simpul. <br>  Itulah sebabnya Database Time Series sekarang menang karena mereka tidak memiliki celah semantik ini.  Aliran data yang tiba di dalamnya secara jelas didefinisikan sebagai rangkaian waktu dan ditulis dengan sangat cepat dan kompak ke dalam basis data, khususnya.  karena Anda tidak perlu memverifikasi keunikan.  Ini adalah urutan besarnya lebih cepat hanya karena dalam database tradisional tidak ada operasi semantik yang hanya akan menulis. <br><br>  Saya pikir itu akan muncul. <br><br><img src="https://habrastorage.org/webt/v0/-w/tl/v0-wtldczsojccjohz5nzbrcnrs.jpeg"><br><br>  Ke mana semua ini selanjutnya?  Jika Anda melihat sangat jauh, inovasi tidak berhenti di NoSQL dan NewSQL.  Pemahaman kita tentang informasi terus berkembang. <br><br><blockquote>  Salah satu tren paling penting di masa depan, menurut saya, adalah kita akan semakin sedikit menghapus informasi. <br></blockquote><br>  Untuk ini, serangkaian produk lahir, yang disebut basis data temporal. <br><br><h2>  Setelah NewSQL: basis data temporal <br></h2><br>  Di bawah ini adalah tangkapan layar dari Microsoft SQL Server.  Ini adalah basis data yang memungkinkan Anda mengajukan pertanyaan ke titik waktu: ada SELECT untuk kondisi saat ini, tetapi masih memungkinkan untuk membuat SELECT untuk beberapa tanggal di masa lalu. <br><br><img src="https://habrastorage.org/webt/1z/pz/c5/1zpzc5-px5chjpkth1v12pa71bs.jpeg"><br><br>  Ini memunculkan sejumlah aplikasi basis data baru.  Pertama, Anda dapat melacak sejarah suatu objek.  Kedua, Anda dapat secara otomatis menghitung grup, laporan berdasarkan titik.  Anda tidak perlu membuat tabel terpisah untuk ini - Anda memiliki representasi alami dalam satu tabel: satu entitas - satu tabel. <br><br><img src="https://habrastorage.org/webt/_w/ls/kk/_wlskk1vblw3g3_fxcsgdgjqdm0.jpeg"><br><br>  Dari sudut pandang struktur internal, ini sebenarnya adalah tabel utama dan tabel dengan sejarah.  Setiap baris dikaitkan dengan dua kali diketahui sistem.  Ini bukan hanya dua kolom yang Anda tambahkan, tetapi data yang didukung sistem secara otomatis: <br><br><ol><li>  <strong>waktu catatan ditambahkan ke database,</strong> <br></li><li>  <strong>waktu acara.</strong> <br></li></ol><br>  Ini adalah waktu yang berbeda, tidak peduli seberapa lucu. <br><br>  Misalkan Ivan Ivanovich meninggal pada 17 November, dan catatan ini dimasukkan ke dalam basis data pada 20 November - kedua kali ini disimpan dalam database seperti itu. <br><br>  Menurut saya, ini juga salah satu tren mendasar.  Mengapa saya berpikir demikian?  Jika kita kembali ke kunci sekunder dan konsistensi akhirnya, maka menyimpan semuanya benar-benar hanya memungkinkan Anda untuk menyelesaikan masalah ini dengan elegan. <br><br><blockquote>  Jika kita tidak perlu menghapus apapun dari database sama sekali, maka database kita selalu konsisten - cerita yang sangat menarik! <br></blockquote><br><h2>  Tautan yang bermanfaat <br></h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.couchbase.com/documentation/server/current/developer-guide/query-consistency.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://martinfowler.com/books/nosql.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://jimwebber.org/2011/02/on-sharding-graph-databases/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.mongodb.com/manual/core/document-validation/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.oreilly.com/pub/e/3847</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.oreilly.com/ideas/data-modeling-with-multi-model-databases</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://redislabs.com/blog/redis-as-a-json-store/</a> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Faq</b> <div class="spoiler_text"><blockquote>  <em>- Apakah ada perkembangan dalam pembuatan database baru yang tidak akan berlaku untuk MySQL, PostgreSQL, MongoDB, dll?</em> </blockquote><br>  Dalam cara yang baik, pertanyaannya adalah: apakah akan ada database baru, startup?  Saya pikir mereka akan semakin jarang terlihat.  Badai telah mereda, dan sekarang kita akan lebih cepat melihat keberangkatan daripada kedatangan, CockroachDB adalah salah satu yang terakhir tiba. <br><br>  Mari kita langsung ke intinya.  Profesor saya di universitas mengatakan bahwa DBMS adalah area hijau abadi.  Karena itu, kita akan selalu melihat semacam gerakan.  Tapi saya pikir dalam waktu dekat produk yang berbeda secara fundamental tidak akan muncul, akan ada konvergensi, bukan booming. <br><br><blockquote>  <em>- Bukan pertanyaan, melainkan tambahan: SQL sering mencoba untuk membuat indeks yang meliputi sehingga hasil query SQL tidak menyangkut tingkat penyimpanan, tetapi langsung diperoleh dari indeks.</em>  <em>Indeks itu sendiri sebenarnya adalah kasus khusus dari grafik.</em>  <em>Jadi, mungkin tren seluruh database secara bertahap mengalir ke indeks grafik curam?</em> <br></blockquote><br>  Ini adalah kisah yang luar biasa yang disukai oleh semua perwakilan database grafik untuk memberi tahu pelanggan mereka - itu tidak berhasil!  Karena ada banyak cara untuk memperbarui indeks, dan ada banyak opsi pengindeksan, tetapi tidak semua orang memiliki grafik!  Mari kita tenang - sama seperti tidak semuanya relasional, jadi tidak semua orang adalah grafik. <br><br><blockquote>  <em>- Menurut Anda, kemana elastis dan sejenisnya akan pergi?</em>  <em>Saya berbicara tentang fakta bahwa dia mulai memecahkan masalah yang sangat aneh - dia mencoba untuk berpura-pura time series dan basis analitik untuk bekerja dengan log.</em>  <em>Tampaknya tidak ada yang menggunakannya untuk pencarian teks.</em> <br></blockquote><br>  Elastis tidak harus bergerak ke mana pun karena elastis terasa hebat.  Ini memecahkan masalah bisnis tertentu - ini adalah pencarian yang efektif dan segala sesuatu yang berkaitan dengan ekosistem ini. <br><br>  Saya pikir semuanya terutama berasal dari fakta bahwa Elastic mencoba menjadi segalanya.  Tapi di sini pertanyaannya adalah dari tugas, tugas Elastis sangat mirip dengan tugas deret waktu, oleh karena itu dibenarkan.  Elastis bagus untuk mencari melalui array besar dari log yang sama, dll. <br><br>  Ada kasus yang lebih sempit - ini hanya pencarian teks lengkap, tetapi Anda tidak akan menghasilkan banyak dari itu.  Lebih banyak yang perlu dilakukan untuk membedakan dari pesaing di tempat pertama.  Karena itu, ini semua terjadi. <br><br>  Tetapi saya tidak berpikir bahwa Elastis akan melakukan transaksi perbankan besok.  Semuanya berjalan ke titik di mana Couchbase, misalnya, akan - jika bukan transaksi perbankan, tetapi sesuatu yang sangat cepat. <br></div></div><br><blockquote><h3>  Berita </h3><br>  Segera, <strong>pada tanggal 21 Juni,</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konferensi Tarantool</a> <strong>akan berlangsung di Moskow</strong> - atau secara singkat <strong>T + Conf</strong> - sebuah konferensi tidak hanya tentang Tarantool itu sendiri, tetapi juga tentang penggunaan <strong>komputasi dalam memori secara</strong> umum <strong>.</strong> <br><br><ul><li>  Konstantin Osipov berencana untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> di mana ia akan memeriksa arsitektur Vinyl, kemampuannya dan, yang paling penting, mekanisme tuning dan pemantauan kinerja khusus untuk mesin ini secara konsisten dan sedetail mungkin. </li><li>  Vladimir Perepelitsa dalam format tutorial, ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan</a> bahwa Tarantool adalah basis data yang memiliki potensi besar untuk digunakan sebagai server aplikasi. </li><li>  Vladislav Zaitsev dari pergi untuk mendekati topik ini dari sisinya - dari sisi Internet hal dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> , khususnya, mengapa sistem kontrol IoT. </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413557/">https://habr.com/ru/post/id413557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413547/index.html">Alami 2 juta sesi tanpa kepala</a></li>
<li><a href="../id413549/index.html">Kursus Kuliah Pengembangan Web</a></li>
<li><a href="../id413551/index.html">Scrolling dan perhatian (studi 2018)</a></li>
<li><a href="../id413553/index.html">Registrar REG.RU menghilangkan mitra akses ke 70 ribu domain dan mengambil layanan mereka sendiri</a></li>
<li><a href="../id413555/index.html">Interoperabilitas yang Aman dalam Sistem Terdistribusi</a></li>
<li><a href="../id413559/index.html">Degradasi web atau cara membuat web manusia dapat dibaca</a></li>
<li><a href="../id413561/index.html">Kecepatan Linq Expression Tree dikompilasi</a></li>
<li><a href="../id413563/index.html">4 cara untuk mengimpor paket ke Go</a></li>
<li><a href="../id413565/index.html">Analisis hack Kubernetes - backdoor via kubelet</a></li>
<li><a href="../id413567/index.html">Memulai dengan layanan microser di Spring Boot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>