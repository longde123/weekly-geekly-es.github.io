<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≠ üÖæÔ∏è üõÄüèø Akzeptieren und dekodieren Sie analoges Fernsehen mit SDR und Python üëßüèø üéº üõ∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 

 Heute setzen wir das Thema SDR-Empfang und Signalverarbeitung fort. Ich habe mich nach einer Frage von einem der Leser ganz zuf√§llig f√º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Akzeptieren und dekodieren Sie analoges Fernsehen mit SDR und Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482014/">  Hallo Habr. <br><br>  Heute setzen wir das Thema SDR-Empfang und Signalverarbeitung fort.  Ich habe mich nach einer Frage von einem der Leser ganz zuf√§llig f√ºr den Empfang von analogem Fernsehen interessiert.  Dies stellte sich jedoch aufgrund des banalen Mangels an Signalabtastungen als nicht so einfach heraus - vielerorts wurde das analoge Fernsehen bereits ausgeschaltet.  Der Reader hat sogar eine Aufnahme mit RTL-SDR gesendet, die Breite der Aufnahme bei RTL betr√§gt jedoch ungef√§hr 2 MHz, w√§hrend die TV-Signalbandbreite ungef√§hr 8 MHz betr√§gt und bei der Aufnahme nichts klar war.  Infolgedessen wurde das Thema f√ºr eine lange Zeit aufgegeben, und schlie√ülich nahm ich gerade bei der n√§chsten Reise zu meinen Verwandten SDRPlay mit und stellte die Frequenzen der Fernsehkan√§le ein. Ich sah das gew√ºnschte Signal auf dem Bildschirm. <br><br>  Ein kleines Python-Programm, und alles funktioniert: <br><br><img src="https://habrastorage.org/webt/o4/t9/y4/o4t9y4lcex9vssgmpgc2vssujvu.jpeg"><br><br>  F√ºr alle, die sich f√ºr Details interessieren, weiter unter dem Schnitt. <a name="habracut"></a><br><br><h2>  Theorie </h2><br>  In den alten Nachkriegsjahren, als digitale Geheimsignale nur in Geheimlabors bekannt waren, die Leute aber schon fernsehen wollten, gab es drei konkurrierende analoge Standards.  Das erste war das seit den 40er Jahren entwickelte amerikanische <a href="https://en.wikipedia.org/wiki/NTSC">NTSC</a> (National Television System System Committee), das f√ºr die amerikanische Netzfrequenz von 60 Hz ‚Äûgesch√§rft‚Äú wurde und eine vertikale Aufl√∂sung von nur 486 Zeilen aufwies.  Wenig sp√§ter wurde in Deutschland der <a href="https://en.wikipedia.org/wiki/PAL">PAL-</a> Standard (Phase Alternating Line) entwickelt, der etwas besser war als der amerikanische (Aufl√∂sung der ‚Äûganzen‚Äú 576 Leitungen und Konzentration auf die europ√§ische Netzfrequenz von 50 Hz), und etwas sp√§ter erschien der franz√∂sische <a href="https://en.wikipedia.org/wiki/SECAM">SECAM-</a> Standard (S√©quentiel couleur √† m√©moire).  Es wurden einige der M√§ngel des PAL im Zusammenhang mit der Farbwiedergabe beseitigt, und es gibt eine Version, in der die Annahme von zwei Standards auch eine politische Entscheidung war, sodass Einwohner einiger L√§nder keine Programme aus anderen L√§ndern sehen konnten (etwa 50 Jahre vor der Vereinten Europ√§ischen Union und Schengen). .  So oder so, aber die ganze Welt war so geteilt: <br><br><img src="https://habrastorage.org/webt/i3/w7/qy/i3w7qyt3opicaz0prpryn9-9ha4.png"><br><br>  Weil  Habr ist immer noch eine russischsprachige Site, dann werden wir in Zukunft SECAM in Betracht ziehen, obwohl es auch interessant w√§re, wenn jemand ein Beispielsignal PAL sendet. <br><br>  Das SECAM-Spektrum ist <s>nach alten Schriftrollen</s> wie folgt: <br><br><img src="https://habrastorage.org/webt/m-/t1/l9/m-t1l9ntpksl9ul6zoi4evslxac.png"><br><br>  Auf der linken Seite befindet sich bei der Frequenz F0 das amplitudenmodulierte Luminanzsignal (L).  Dies ist eigentlich ein Schwarz-Wei√ü-Bild, das immer noch auf einem alten Schwarz-Wei√ü-Fernseher mit <s>Warmwei√ü-Lampe</s> angezeigt werden kann.  Das Problem von Legacy und dem Vorhandensein von alten Ger√§ten bei den Benutzern bestand bereits damals, so dass der Farbkanal separat hinzugef√ºgt wurde, ohne die Kompatibilit√§t mit alten Fernsehger√§ten zu verlieren.  Zwei Farbkan√§le wurden abwechselnd in Frequenzmodulation mit Frequenzen von 4,25 und 4,406 MHz √ºbertragen.  Und schlie√ülich wurde der Ton, der eine noch h√∂here Frequenz aufwies, separat √ºbertragen, auch bei der Frequenzmodulation. <br><br>  √úbrigens, mit dem Empfang des Fernsehens in St. Petersburg gibt es einen lustigen Moment.  Wie die russischen Medien berichteten, wurde das analoge Fernsehen im Oktober abgeschaltet: <br><br><img src="https://habrastorage.org/webt/e_/ql/pm/e_qlpmgp7ukmcw5ag9ial0gozic.png"><br><br>  Dies gilt jedoch nur f√ºr <i>staatliche Kan√§le</i> , niemand zwingt kommerzielle <i>Kan√§le,</i> ihre Sendungen auszuschalten.  Zumindest zum Zeitpunkt des Schreibens (Dezember 2019) sind noch ca. 5-6 Kan√§le im ‚ÄûAnalog‚Äú mitten in St. Petersburg verf√ºgbar.  Aber wie lange es dauern wird, ist unbekannt. Wer also "for history" -Signal-Samples aufnehmen m√∂chte, sollte es trotzdem eilig haben. <br><br>  Schlie√ülich ist es Zeit, den SDR einzuschalten und zu sehen, was wir im wirklichen Leben haben: <br><br><img src="https://habrastorage.org/webt/gl/pc/6m/glpc6midlpecggjb4nknxhcvdkc.png"><br><br>  Der Audiokanal ist nicht schwierig, Sie k√∂nnen einfach mit der ‚ÄûMaus‚Äú in HDSDR dar√ºber fahren, FM mit einer Bandbreite von ca. 50 kHz ausw√§hlen und h√∂ren.  Wir werden mit dem Dekodieren des Helligkeitskanals beginnen, um ein fertiges ‚ÄûBild‚Äú zu erhalten. <br><br><h2>  Dekodierung </h2><br>  Wie oben beschrieben, werden Luminanzsignale zu AM √ºbertragen.  Um selbst keinen Decoder zu schreiben, verwenden wir GNU Radio - wir √ºbertragen das Spektrum auf die Frequenz Null, starten den AM-Decoder und speichern das Ergebnis in einer Datei. <br><br><img src="https://habrastorage.org/webt/xp/n2/wf/xpn2wfbovg--y915lex2kesd1we.png"><br><br>  Jetzt k√∂nnen wir die gespeicherte Datei in Python √∂ffnen: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt lum_data = np.fromfile(<span class="hljs-string"><span class="hljs-string">"pal_lum.raw"</span></span>, dtype=<span class="hljs-string"><span class="hljs-string">'int32'</span></span>) lum_data = -lum_data - <span class="hljs-number"><span class="hljs-number">4700</span></span> fs = <span class="hljs-number"><span class="hljs-number">9000000</span></span>//<span class="hljs-number"><span class="hljs-number">2</span></span> x_time = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(lum_data)/fs, num=len(lum_data)) plt.plot(x_time, lum_data)</code> </pre> <br>  Wir sehen eine Sequenz von 4 Bildern auf dem Bildschirm. <br><br><img src="https://habrastorage.org/webt/f5/yq/4a/f5yq4aeks144gso4-_73qcmn0t8.png"><br><br>  Die L√§nge eines Frames von 0,02 s - dies ist nur 1/50 - ist ein Vielfaches der 50-Hz-Netzwerkfrequenz, deren Signale als "Taktgenerator" dienen (vergessen Sie nicht, dass das Signal analog ist).  F√ºr jeden Frame werden 320 Zeilen √ºbertragen - wir haben Interlaced-Scanning, die endg√ºltige Frame-Rate betr√§gt also 25 Hz. <br><br>  Schauen wir uns die einzelnen Zeilen genauer an: <br><br><img src="https://habrastorage.org/webt/j6/ly/7g/j6ly7gfmqmev6rlumkfudjgc8k4.png"><br><br>  Wie Sie sehen, entspricht der Anfang jeder Zeile einer ‚ÄûUhr‚Äú, dann entspricht der Signalhub den aktuellen Helligkeitswerten in dieser Zeile.  Alles ist ganz einfach, und wahrscheinlich wurde praktisch unver√§ndert ein solches Signal an die Kathodenstrahlr√∂hre des Fernsehers angelegt. <br><br>  Der Rest ist eine Frage der Technologie.  Wir erstellen ein Bild im Speicher und kopieren zwei Frames hinein, weil  wir haben interlaced.  Die Signalspanne √ºberschreitet nicht +200, wodurch wir diese Werte direkt als RGB-Farben schreiben k√∂nnen. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Output image frame_size = fs*1//50 img_x, img_y = 320, 650 img_size = (img_y, img_x, 3) img_data = np.zeros(img_size, dtype=np.uint8) img_data.fill(255) frame_num = 0 # Frame #1 pos_x, pos_y = 0, 0 for px in range(frame_num*frame_size, (frame_num+1)*frame_size): val = lum_data[px] if val &lt; 0: val = 0 if val &gt; 255: val = 255 img_data[pos_y][pos_x] = (0, val, 0) pos_x += 1 if lum_data[px] &lt;= 0 and lum_data[px+1] &gt; 0: pos_x = 0 pos_y += 2 print("Scan lines 1:", pos_y) # Frame #2 pos_x, pos_y = 0, 0 for px in range((frame_num+1)*frame_size, (frame_num+2)*frame_size): val = lum_data[px] if val &lt; 0: val = 0 if val &gt; 255: val = 255 img_data[pos_y+1][pos_x] = (0, val, 0) pos_x += 1 if lum_data[px] &lt;= 0 and lum_data[px+1] &gt; 0: pos_x = 0 pos_y += 2 img_resized = cv2.resize(img_data, dsize=(3*img_x, img_y), interpolation=cv2.INTER_CUBIC) plt.imshow(img_resized, interpolation='nearest')</span></span></code> </pre><br>  Wie Sie sehen, verwende ich den Nulldurchgang, um den Beginn einer neuen Linie zu erkennen.  Es stellte sich heraus, dass das Bild vertikal komprimiert ist. In diesem Fall h√§ngt es von der Abtastfrequenz des SDR ab. Am Ende habe ich nur die Gr√∂√üe ge√§ndert. <br><br>  Das Endergebnis f√ºr die Animation von 10 Bildern (akzeptiert das Habr-Dateiarchiv nicht mehr): <br><br><img src="https://habrastorage.org/webt/k0/ah/ri/k0ahrixczcntxnwflutgq-aihpy.gif"><br><br><h2>  Fazit </h2><br>  Es ist interessant, solche Standards zu analysieren, weil  Erstens sind sie recht einfach zu implementieren, und zweitens ist ihre Untersuchung auch teilweise von historischem Interesse.  Nat√ºrlich hatte ich nicht das Ziel, einen vollwertigen Software-TV-Tuner zu entwickeln, daher wird der Code in einer minimal bedienbaren Form angezeigt. <br><br>  Wenn die Bewertungen des Artikels positiv sind, k√∂nnen Sie im zweiten Teil die Arbeit mit Farbe in Betracht ziehen und ein vollwertiges Farbbild anzeigen. <br><br>  F√ºr diejenigen, die alleine experimentieren m√∂chten, kann die IQ-Datei hier heruntergeladen <a href="https://cloud.mail.ru/public/2gSx/5LfQSJwDZ">werden</a> . <br><br>  Alle erfolgreichen Experimente. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482014/">https://habr.com/ru/post/de482014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482002/index.html">Erstellen eines Microservice-Blogs - Teil 3 ‚ÄûBenutzer‚Äú</a></li>
<li><a href="../de482004/index.html">Wir testen 1C auf dem VPS Server</a></li>
<li><a href="../de482008/index.html">LEGO Konstruktor und absolute Null</a></li>
<li><a href="../de482010/index.html">"Neue Epen". F√ºr Entwickler, Ops und Neugierige</a></li>
<li><a href="../de482012/index.html">Raspberry Pi und iperf - Bandbreitentester f√ºr Smart Home- und IoT-Ger√§te</a></li>
<li><a href="../de482020/index.html">R, Monte Carlo und Unternehmensaufgaben</a></li>
<li><a href="../de482022/index.html">Schau einfach! 20 Filme √ºber Wissenschaft und Wissenschaftler</a></li>
<li><a href="../de482028/index.html">Zwei rote Kn√∂pfe, L√∂tkolben und React: Wie wir uns f√ºr eine IT-Konferenz entschieden haben</a></li>
<li><a href="../de482030/index.html">Vue.js: Lifecycle-Hooks f√ºr Ihre und Komponenten von Drittanbietern</a></li>
<li><a href="../de482034/index.html">Yandex: Es gibt alles ... √ºber Benutzer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>