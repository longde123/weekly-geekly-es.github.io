<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏼 😱 👨🏻‍🍳 Combatendo a complexidade no desenvolvimento de software 📥 ⏮️ 🚣🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que é isso? 


 Depois de trabalhar em diferentes projetos, notei que cada um deles apresentava alguns problemas comuns, independentemente do domíni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Combatendo a complexidade no desenvolvimento de software</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458730/"><h2 id="whats-this-about">  O que é isso? </h2><br><p> Depois de trabalhar em diferentes projetos, notei que cada um deles apresentava alguns problemas comuns, independentemente do domínio, arquitetura, convenção de código e assim por diante.  Esses problemas não eram desafiadores, apenas uma rotina tediosa: garantir que você não perdesse nada estúpido e óbvio.  Em vez de fazer essa rotina diariamente, fiquei obcecado em procurar uma solução: alguma abordagem de desenvolvimento ou convenção de código ou qualquer outra coisa que me ajude a criar um projeto de forma a impedir que esses problemas aconteçam, para que eu possa me concentrar em coisas interessantes .  Esse é o objetivo deste artigo: descrever esses problemas e mostrar a você a mistura de ferramentas e abordagens que encontrei para resolvê-los. </p><a name="habracut"></a><br><h2 id="problems-we-face">  Problemas que enfrentamos </h2><br><p>  Ao desenvolver software, enfrentamos muitas dificuldades ao longo do caminho: requisitos pouco claros, falta de comunicação, processo de desenvolvimento ruim e assim por diante. </p><br><p>  Também enfrentamos algumas dificuldades técnicas: o código legado nos atrasa, a escalabilidade é complicada, algumas decisões ruins do passado nos chocam hoje. </p><br><p>  Todos eles podem ser, se não eliminados, e reduzidos significativamente, mas há um problema fundamental sobre o qual você não pode fazer nada: a complexidade do seu sistema. </p><br><p>  A idéia de um sistema que você está desenvolvendo é sempre complexa, entenda ou não. <br>  Mesmo quando você está fazendo <em>outro aplicativo CRUD</em> , sempre existem alguns casos extremos, algumas coisas complicadas e, de tempos em tempos, alguém pergunta: "Ei, o que vai acontecer se eu fizer isso e isso nessas circunstâncias?"  e você diz "Hum, essa é uma pergunta muito boa". </p><br><p>  Esses casos complicados, lógica obscura, validação e gerenciamento de acesso - tudo isso contribui para a sua grande ideia. <br>  Muitas vezes, essa ideia é tão grande que não cabe em uma só cabeça, e esse fato por si só traz problemas como falta de comunicação. </p><br><p>  Mas sejamos generosos e suponhamos que essa equipe de especialistas em domínio e analistas de negócios se comunique claramente e produza requisitos consistentes. </p><br><p>  Agora temos que implementá-los, para expressar essa ideia complexa em nosso código.  Agora esse código é outro sistema, muito mais complicado do que a ideia original que tínhamos em mente. </p><br><p>  Como assim?  Enfrenta a realidade: as limitações técnicas obrigam você a lidar com alta carga, consistência e disponibilidade de dados, além de implementar a lógica de negócios real. </p><br><p>  Como você pode ver, a tarefa é bastante desafiadora e agora precisamos de ferramentas adequadas para lidar com ela. <br>  Uma linguagem de programação é apenas mais uma ferramenta e, como todas as outras ferramentas, não se trata apenas da qualidade dela, provavelmente é ainda mais sobre a ferramenta adequada ao trabalho.  Você pode ter a melhor chave de fenda que existe, mas se você precisar colocar alguns pregos na madeira, um martelo de baixa qualidade seria melhor, certo? </p><br><h2 id="technical-aspects">  Aspectos técnicos </h2><br><p>  Hoje, a maioria das línguas populares é orientada a objetos.  Quando alguém faz uma introdução ao POO, geralmente usa exemplos: <br>  Considere um carro, que é um objeto do mundo real.  Possui várias propriedades como marca, peso, cor, velocidade máxima, velocidade atual e assim por diante. </p><br><p>  Para refletir esse objeto em nosso programa, reunimos essas propriedades em uma classe.  As propriedades podem ser permanentes ou mutáveis, que juntas formam o estado atual desse objeto e alguns limites nos quais ele pode variar.  No entanto, combinar essas propriedades não é suficiente, pois temos que verificar se o estado atual faz sentido, por exemplo, a velocidade atual não excede a velocidade máxima.  Para garantir que anexemos alguma lógica a essa classe, marque as propriedades como privadas para impedir que alguém crie estado ilegal. <br>  Como você pode ver, os objetos são sobre seu estado interno e ciclo de vida. </p><br><p>  Portanto, esses três pilares da OOP fazem todo sentido neste contexto: usamos herança para reutilizar certas manipulações de estado, encapsulamento para proteção de estado e polimorfismo para tratar objetos semelhantes da mesma maneira.  A mutabilidade como padrão também faz sentido, pois nesse contexto o objeto imutável não pode ter um ciclo de vida e sempre possui um estado, o que não é o caso mais comum. </p><br><p> O problema é que, quando você olha para um aplicativo típico da Web atualmente, ele não lida com objetos.  Quase tudo em nosso código tem uma vida eterna ou nenhuma vida adequada.  Dois tipos mais comuns de "objetos" são algum tipo de serviço, como <code>UserService</code> , <code>EmployeeRepository</code> ou alguns modelos / entidades / DTOs ou o que você chamar.  Os serviços não têm um estado lógico dentro deles, eles morrem e nascem de novo exatamente da mesma forma, apenas recriamos o gráfico de dependência com uma nova conexão com o banco de dados. </p><br><p>  Entidades e modelos não têm nenhum comportamento associado a eles, são apenas pacotes de dados, sua mutabilidade não ajuda, mas muito pelo contrário. </p><br><p>  Portanto, os principais recursos do OOP não são realmente úteis para o desenvolvimento desse tipo de aplicativo. </p><br><p>  O que acontece em um aplicativo Web típico é o fluxo de dados: validação, transformação, avaliação e assim por diante.  E há um paradigma que se encaixa perfeitamente para esse tipo de trabalho: programação funcional.  E há uma prova disso: todos os recursos modernos das linguagens populares de hoje vêm de lá: <code>async/await</code> , lambdas e delegados, programação reativa, uniões discriminadas (enums em rápido ou enferrujado, para não serem confundidas com enums em java ou .net ), tuplas - tudo o que é do FP. </p><br><p>  No entanto, essas são apenas migalhas, é muito bom tê-las, mas há mais, muito mais. </p><br><p>  Antes de me aprofundar, há um ponto a ser feito.  Mudar para um novo idioma, especialmente um novo paradigma, é um investimento para desenvolvedores e, portanto, para os negócios.  Fazer investimentos tolos não lhe dará nada além de problemas, mas investimentos razoáveis ​​podem ser exatamente o que o manterá à tona. </p><br><h2 id="tools-we-have-and-what-they-give-us">  Ferramentas que temos e o que elas nos dão </h2><br><p>  Muitos de nós preferimos idiomas com digitação estática.  A razão disso é simples: o compilador cuida de verificações tediosas, como passar parâmetros apropriados para funções, construir nossas entidades corretamente e assim por diante.  Essas verificações são gratuitas.  Agora, quanto às coisas que o compilador não pode verificar, temos uma escolha: esperar o melhor ou fazer alguns testes.  Escrever testes significa dinheiro, e você não paga apenas uma vez por teste; você deve mantê-los.  Além disso, as pessoas ficam desleixadas e, de vez em quando, obtemos resultados falso-positivos e falso-negativos.  Quanto mais testes você tiver que escrever, menor será a qualidade média desses testes.  Há outro problema: para testar algo, você precisa saber e lembrar que esse item deve ser testado, mas quanto maior o seu sistema, mais fácil é perder algo. </p><br><p>  No entanto, o compilador é tão bom quanto o sistema de tipos da linguagem.  Se não permitir que você expresse algo de maneira estática, é necessário fazer isso em tempo de execução.  O que significa testes, sim.  Porém, não se trata apenas de sistema de tipos, os recursos de sintaxe e pequenos açúcares também são muito importantes, porque no final do dia queremos escrever o mínimo de código possível, por isso, se alguma abordagem exigir que você escreva dez vezes mais linhas, ninguém vai usá-lo.  É por isso que é importante que o idioma escolhido tenha o conjunto adequado de recursos e truques - bem, foco correto em geral.  Caso contrário, em vez de usar seus recursos para enfrentar desafios originais, como a complexidade do seu sistema e requisitos variáveis, você também estará lutando contra o idioma.  E tudo se resume a dinheiro, já que você paga aos desenvolvedores pelo tempo gasto.  Quanto mais problemas eles tiverem que resolver, mais tempo eles precisarão e mais desenvolvedores serão necessários. </p><br><p>  Finalmente, estamos prestes a ver algum código para provar tudo isso.  Sou um desenvolvedor .NET, então os exemplos de código serão em C # e F #, mas a imagem geral pareceria mais ou menos a mesma em outras linguagens populares de OOP e FP. </p><br><h2 id="let-the-coding-begin">  Que comece a codificação </h2><br><p>  Vamos criar um aplicativo da web para gerenciar cartões de crédito. </p><br><p>  Requisitos básicos: </p><br><ul><li>  Criar / ler usuários </li><li>  Criar / ler cartões de crédito </li><li>  Ativar / desativar cartões de crédito </li><li>  Definir limite diário para cartões </li><li>  Saldo de recarga </li><li>  Processar pagamentos (considerando saldo, data de validade do cartão, estado ativo / desativado e limite diário) </li></ul><br><p>  Por uma questão de simplicidade, usaremos um cartão por conta e pularemos a autorização.  Mas, de resto, vamos criar aplicativos capazes de validação, manipulação de erros, banco de dados e API da web.  Então, vamos à nossa primeira tarefa: criar cartões de crédito. </p><br><p>  Primeiro, vamos ver como seria em C # </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Card</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CardNumber {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExpirationMonth {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExpirationYear {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AccountInfo AccountInfo {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AccountInfo</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> Balance {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CardNumber {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> DailyLimit {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre> <br><p>  Mas isso não basta, precisamos adicionar a validação e, geralmente, isso está sendo feito em algum <code>Validator</code> , como o do <code>FluentValidation</code> . </p><br><p>  As regras são simples: </p><br><ul><li>  O número do cartão é obrigatório e deve ser uma sequência de 16 dígitos. </li><li>  O nome é obrigatório e deve conter apenas letras e pode conter espaços no meio. </li><li>  Mês e ano precisam satisfazer os limites. </li><li>  As informações da conta devem estar presentes quando o cartão está ativo e ausentes quando o cartão está desativado.  Se você está se perguntando por que, é simples: quando o cartão é desativado, não deve ser possível alterar o saldo ou o limite diário. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CardValidator</span></span> : <span class="hljs-title"><span class="hljs-title">IValidator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CardNumberRegex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(<span class="hljs-string"><span class="hljs-string">"^[0-9]{16}$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> NameRegex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(<span class="hljs-string"><span class="hljs-string">"^[\w]+[\w ]+[\w]+$"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CardValidator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RuleFor(x =&gt; x.CardNumber) .Must(c =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(c) &amp;&amp; CardNumberRegex.IsMatch(c)) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh my"</span></span>); RuleFor(x =&gt; x.Name) .Must(c =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(c) &amp;&amp; NameRegex.IsMatch(c)) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh no"</span></span>); RuleFor(x =&gt; x.ExpirationMonth) .Must(x =&gt; x &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">12</span></span>) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh boy"</span></span>); RuleFor(x =&gt; x.ExpirationYear) .Must(x =&gt; x &gt;= <span class="hljs-number"><span class="hljs-number">2019</span></span> &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">2023</span></span>) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh boy"</span></span>); RuleFor(x =&gt; x.AccountInfo) .Null() .When(x =&gt; !x.IsActive) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh boy"</span></span>); RuleFor(x =&gt; x.AccountInfo) .NotNull() .When(x =&gt; x.IsActive) .WithMessage(<span class="hljs-string"><span class="hljs-string">"oh boy"</span></span>); } }</code> </pre> <br><p>  Agora, existem vários problemas com essa abordagem: </p><br><ul><li>  A validação é separada da declaração de tipo, o que significa que, para ver a imagem completa do <em>cartão</em> , precisamos navegar pelo código e recriar essa imagem em nossa cabeça.  Não é um grande problema quando isso acontece apenas uma vez, mas quando precisamos fazer isso para todas as entidades de um grande projeto, bem, isso consome muito tempo. </li><li>  Essa validação não é forçada, temos que ter em mente para usá-la em qualquer lugar.  Podemos garantir isso com testes, mas, novamente, você deve se lembrar disso ao escrever testes. </li><li>  Quando queremos validar o número do cartão em outros lugares, precisamos fazer a mesma coisa novamente.  Claro, podemos manter o regex em um local comum, mas ainda assim precisamos chamá-lo em todos os validadores. </li></ul><br><p>  No F #, podemos fazer isso de uma maneira diferente: </p><br><pre> <code class="haskell hljs">(*<span class="hljs-comment"><span class="hljs-comment">{- First we define a type for CardNumber with private constructor and public factory which receives string and returns `Result&lt;CardNumber, string&gt;`. Normally we would use `ValidationError` instead, but string is good enough for example -}</span></span>*) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> = private </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> of string with member this.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Value</span></span></span><span class="hljs-class"> = match this with </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> s -&gt; s static member create str = match str with | (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">|"") -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error</span></span></span><span class="hljs-class"> "card number can't be empty" | str -&gt; if cardNumberRegex.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsMatch</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">str</span></span></span><span class="hljs-class">) then </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> str |&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class"> else </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Error</span></span></span><span class="hljs-class"> "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> number must be a 16 digits string" (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- Then in here we express this logic "when card is deactivated, balance and daily limit manipulations aren't available". Note that this is way easier to grasp that reading `RuleFor()` in validators. -}</span></span></span><span class="hljs-class">*) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardAccountInfo</span></span></span><span class="hljs-class"> = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Active</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Deactivated</span></span></span><span class="hljs-class"> (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- And then that's it. The whole set of rules is here, and it's described in a static way. We don't need tests for that, the compiler is our test. And we can't accidentally miss this validation. -}</span></span></span><span class="hljs-class">*) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LetterString</span></span></span><span class="hljs-class"> //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- LetterString is another type with built-in validation HolderId: UserId Expiration: (Month * Year) AccountDetails: CardAccountInfo }</span></span></span></span></code> </pre> <br><p>  É claro que algumas coisas daqui podemos fazer em C #.  Podemos criar a classe <code>CardNumber</code> que também lançará <code>ValidationException</code> .  Mas esse truque com <code>CardAccountInfo</code> não pode ser feito em C # de maneira fácil. <br>  Outra coisa - o C # depende muito de exceções.  Existem vários problemas com isso: </p><br><ul><li>  As exceções têm semântica "ir para".  Um momento em que você está aqui neste método, outro - você acabou em algum manipulador global. </li><li>  Eles não aparecem na assinatura do método.  Exceções como <code>ValidationException</code> ou <code>InvalidUserOperationException</code> fazem parte do contrato, mas você não sabe disso até ler a <em>implementação</em> .  E esse é um grande problema, porque muitas vezes você precisa usar o código escrito por outra pessoa e, em vez de ler apenas a assinatura, precisa navegar até o final da pilha de chamadas, o que leva muito tempo. </li></ul><br><p>  E é isso que me incomoda: sempre que eu implemento algum novo recurso, o processo de implementação em si não leva muito tempo, a maioria vai para duas coisas: </p><br><ul><li>  Lendo o código de outras pessoas e descobrindo regras de lógica de negócios. </li><li>  Certificando-se de que nada está quebrado. </li></ul><br><p>  Pode parecer um sintoma de um mau design de código, mas o mesmo acontece em projetos escritos decentemente. <br>  Ok, mas podemos tentar usar a mesma coisa <code>Result</code> em C #.  A implementação mais óbvia seria assim: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TOk</span></span>, <span class="hljs-title"><span class="hljs-title">TError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TOk Ok {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TError Error {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre> <br><p>  e é um lixo puro, não nos impede de definir <code>Ok</code> e <code>Error</code> e permite que o erro seja completamente ignorado.  A versão adequada seria algo como isto: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TOk</span></span>, <span class="hljs-title"><span class="hljs-title">TError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsOk { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OkResult</span></span> : <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TOk</span></span>, <span class="hljs-title"><span class="hljs-title">TError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TOk _ok; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OkResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TOk ok</span></span></span><span class="hljs-function">)</span></span> { _ok = ok; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsOk =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ErrorResult</span></span> : <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TOk</span></span>, <span class="hljs-title"><span class="hljs-title">TError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TError _error; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErrorResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TError error</span></span></span><span class="hljs-function">)</span></span> { _error = error; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsOk =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Result&lt;TOk, TError&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ok</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TOk ok</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OkResult(ok); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Result&lt;TOk, TError&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TError error</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ErrorResult(error); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Result&lt;T, TError&gt; Map&lt;T&gt;(Func&lt;TOk, T&gt; map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsOk) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ((OkResult)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)._ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result&lt;T, TError&gt;.Ok(map(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ((ErrorResult)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)._error; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result&lt;T, TError&gt;.Error(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Result&lt;TOk, T&gt; MapError&lt;T&gt;(Func&lt;TError, T&gt; mapError) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsOk) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ((OkResult)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)._ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result&lt;TOk, T&gt;.Ok(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ((ErrorResult)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)._error; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result&lt;TOk, T&gt;.Error(mapError(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } } }</code> </pre> <br><p>  Muito pesado, certo?  E nem implementei as versões <code>void</code> do <code>Map</code> e <code>MapError</code> .  O uso ficaria assim: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> squareResult = result.Map(x =&gt; x * x); }</code> </pre> <br><p>  Não é tão ruim assim?  Bem, agora imagine que você tem três resultados e deseja fazer algo com eles quando todos estiverem <code>Ok</code> .  Desagradável.  Então isso dificilmente é uma opção. <br>  Versão F #: </p><br><pre> <code class="haskell hljs">//<span class="hljs-comment"><span class="hljs-comment">-- this type is in standard library, but declaration looks like this: type Result&lt;'ok, 'error&gt; = | Ok of 'ok | Error of 'error //-- and usage: let test res1 res2 res3 = match res1, res2, res3 with | Ok ok1, Ok ok2, Ok ok3 -&gt; printfn "1: %A 2: %A 3: %A" ok1 ok2 ok3 | _ -&gt; printfn "fail"</span></span></code> </pre> <br><p>  Basicamente, você deve escolher se escreve uma quantidade razoável de código, mas o código é obscuro, depende de exceções, reflexões, expressões e outras "mágicas" ou escreve muito mais código, difícil de ler, mas é mais durável e direto.  Quando esse projeto cresce, você simplesmente não pode combatê-lo, não em idiomas com sistemas do tipo C #.  Vamos considerar um cenário simples: você tem alguma entidade em sua base de código por um tempo.  Hoje você deseja adicionar um novo campo obrigatório.  Naturalmente, você precisa inicializar esse campo em qualquer lugar em que essa entidade for criada, mas o compilador não ajuda em nada, pois a classe é mutável e <code>null</code> é um valor válido.  E bibliotecas como o <code>AutoMapper</code> tornam ainda mais difícil.  Essa mutabilidade nos permite inicializar parcialmente os objetos em um lugar, depois empurrá-lo para outro lugar e continuar a inicialização lá.  Essa é outra fonte de erros. </p><br><p>  Enquanto isso, a comparação de recursos de idiomas é boa, mas não é sobre o que este artigo trata.  Se você estiver interessado, eu cobri esse tópico no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> .  Mas os próprios recursos da linguagem não devem ser um motivo para mudar a tecnologia. </p><br><p>  Então, isso nos leva a estas perguntas: </p><br><ol><li>  Por que realmente precisamos mudar do OOP moderno? </li><li>  Por que devemos mudar para o FP? </li></ol><br><p>  A resposta à primeira pergunta é que o uso de linguagens comuns de POO para aplicativos modernos oferece muitos problemas, porque eles foram projetados para finalidades diferentes.  Isso resulta em tempo e dinheiro gasto para combater o design deles, além da complexidade do aplicativo. </p><br><p>  E a segunda resposta é que as linguagens FP fornecem uma maneira fácil de projetar seus recursos para que funcionem como um relógio, e se um novo recurso quebra a lógica existente, ele quebra o código, portanto você sabe disso imediatamente. </p><br><hr><br><p>  No entanto, essas respostas não são suficientes.  Como meu amigo apontou durante uma de nossas discussões, mudar para FP seria inútil quando você não conhece as melhores práticas.  Nossa grande indústria produziu toneladas de artigos, livros e tutoriais sobre o design de aplicativos OOP, e temos experiência em produção com OOP, portanto sabemos o que esperar de diferentes abordagens.  Infelizmente, não é o caso da programação funcional, portanto, mesmo se você mudar para o FP, suas primeiras tentativas provavelmente serão estranhas e certamente não trarão o resultado desejado: desenvolvimento rápido e indolor de sistemas complexos. </p><br><p>  Bem, é exatamente disso que trata este artigo.  Como eu disse, vamos criar aplicativos de produção para ver a diferença. </p><br><h2 id="how-do-we-design-application">  Como projetamos aplicativos? </h2><br><p>  Muitas dessas idéias que usei no processo de design foram emprestadas do grande livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Domain Modeling Made Functional</a> , por isso recomendo fortemente que você a leia. </p><br><p>  O código fonte completo com comentários está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Naturalmente, eu não vou colocar tudo isso aqui, então vou abordar os principais pontos. </p><br><p>  Teremos quatro projetos principais: camada de negócios, camada de acesso a dados, infraestrutura e, é claro, comuns.  Toda solução tem, certo? </p><br><p>  Começamos com a modelagem do nosso domínio.  Neste ponto, não sabemos e não ligamos para o banco de dados.  É feito de propósito, porque, tendo em mente um banco de dados específico, tendemos a projetar nosso domínio de acordo com ele, trazemos essa relação de entidade-tabela na camada de negócios, o que mais tarde traz problemas.  Você só precisa implementar o <code>domain -&gt; DAL</code> mapeamento <code>domain -&gt; DAL</code> uma vez, enquanto o design errado nos incomoda constantemente até o ponto em que o corrigimos.  Então, eis o que fazemos: criamos um projeto chamado <code>CardManagement</code> (muito criativo, eu sei) e imediatamente <code>&lt;TreatWarningsAsErrors&gt;true&lt;/TreatWarningsAsErrors&gt;</code> a configuração <code>&lt;TreatWarningsAsErrors&gt;true&lt;/TreatWarningsAsErrors&gt;</code> no arquivo do projeto.  Por que precisamos disso?  Bem, usaremos fortemente uniões discriminadas e, quando você faz a correspondência de padrões, o compilador nos dá um aviso, se não cobrirmos todos os casos possíveis: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> fail result = match result with | <span class="hljs-type"><span class="hljs-type">Ok</span></span> v -&gt; printfn <span class="hljs-string"><span class="hljs-string">"%A"</span></span> v //<span class="hljs-comment"><span class="hljs-comment">-- warning: Incomplete pattern matches on this expression. //-- For example, the value 'Error' may indicate a case not covered by the pattern(s).</span></span></code> </pre> <br><p>  Com essa configuração ativada, esse código não será compilado, exatamente o que precisamos, quando estendemos a funcionalidade existente e queremos que ela seja ajustada em qualquer lugar.  A próxima coisa que fazemos é criar o módulo (compila em uma classe estática) <code>CardDomain</code> .  Neste arquivo, descrevemos tipos de domínio e nada mais.  Lembre-se de que no F #, a ordem dos códigos e arquivos é importante: por padrão, você pode usar apenas o que declarou anteriormente. </p><br><h3 id="domain-types">  Tipos de domínio </h3><br><p>  Começamos a definir nossos tipos com o <code>CardNumber</code> que mostrei antes, embora precisemos de um <code>Error</code> mais prático do que apenas uma string, portanto usaremos <code>ValidationError</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidationError</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FieldPath</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Message</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> } let validationError field message = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FieldPath</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Message</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class"> } (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- Actually we should use here Luhn's algorithm, but I leave it to you as an exercise, so you can see for yourself how easy is updating code to new requirements. -}</span></span></span><span class="hljs-class">*) let private cardNumberRegex = new </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Regex</span></span></span><span class="hljs-class">("^[0-9]{16}$", </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegexOptions</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Compiled</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> = private </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> of string with member this.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Value</span></span></span><span class="hljs-class"> = match this with </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> s -&gt; s static member create fieldName str = match str with | (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">|"") -&gt; validationError fieldName "card number can't be empty" | str -&gt; if cardNumberRegex.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsMatch</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">str</span></span></span><span class="hljs-class">) then </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> str |&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class"> else validationError fieldName "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> number must be a 16 digits string"</span></span></code> </pre> <br><p>  Então, é claro, definimos <code>Card</code> que é o coração do nosso domínio.  Sabemos que o cartão possui alguns atributos permanentes, como número, data de validade e nome no cartão, além de algumas informações alteráveis, como saldo e limite diário. Portanto, encapsulamos essas informações alteráveis ​​em outro tipo: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HolderId</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Balance</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Money</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DailyLimit</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DailyLimit</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LetterString</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HolderId</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expiration</span></span></span><span class="hljs-class">: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Month</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Year</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountDetails</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardAccountInfo</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Agora, existem vários tipos aqui, que ainda não declaramos: </p><br><ol><li><p>  <strong>Dinheiro</strong> </p><br><p>  Poderíamos usar <code>decimal</code> (e usaremos, mas não diretamente), mas <code>decimal</code> é menos descritivo.  Além disso, pode ser usado para representar outras coisas além de dinheiro, e não queremos que isso seja confundido.  Portanto, usamos o tipo de <code>type [&lt;Struct&gt;] Money = Money of decimal</code> personalizado <code>type [&lt;Struct&gt;] Money = Money of decimal</code> . </p><br></li><li><p>  <strong>Dailylimit</strong> </p><br><p>  O limite diário pode ser definido para uma quantidade específica ou estar ausente.  Se estiver presente, deve ser positivo.  Em vez de usar <code>decimal</code> ou <code>Money</code> , definimos este tipo: </p><br><pre> <code class="haskell hljs">[&lt;<span class="hljs-type"><span class="hljs-type">Struct</span></span>&gt;] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DailyLimit</span></span></span><span class="hljs-class"> = private //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- private constructor so it can't be created directly outside of module | Limit of Money | Unlimited with static member ofDecimal dec = if dec &gt; 0m then Money dec |&gt; Limit else Unlimited member this.ToDecimalOption() = match this with | Unlimited -&gt; None | Limit limit -&gt; Some limit.Value</span></span></span></span></code> </pre> <br><p>  É mais descritivo do que apenas sugerir que <code>0M</code> significa que não há limite, pois também pode significar que você não pode gastar dinheiro com este cartão.  O único problema é que, como ocultamos o construtor, não podemos fazer a correspondência de padrões.  Mas não se preocupe, podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Padrões Ativos</a> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (|<span class="hljs-type"><span class="hljs-type">Limit</span></span>|<span class="hljs-type"><span class="hljs-type">Unlimited</span></span>|) limit = match limit with | <span class="hljs-type"><span class="hljs-type">Limit</span></span> dec -&gt; <span class="hljs-type"><span class="hljs-type">Limit</span></span> dec | <span class="hljs-type"><span class="hljs-type">Unlimited</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Unlimited</span></span></code> </pre> <br><p>  Agora podemos padronizar a correspondência do <code>DailyLimit</code> todos os lugares como um DU regular. </p><br></li><li><p>  <strong>Letterstring</strong> </p><br><p>  Essa é simples.  Usamos a mesma técnica que no <code>CardNumber</code> .  Porém, uma coisinha: <code>LetterString</code> dificilmente se trata de cartões de crédito, é uma coisa bastante, e devemos movê-lo no projeto <code>Common</code> no módulo <code>CommonTypes</code> .  Chegou a hora de movermos o <code>ValidationError</code> para outro local também. </p><br></li><li><p>  <strong>ID do usuário</strong> </p><br><p>  Esse é apenas um <code>type UserId = System.Guid</code> alias <code>type UserId = System.Guid</code> .  Nós o usamos apenas para descrição. </p><br></li><li><p>  <strong>Mês e Ano</strong> </p><br><p>  Aqueles também têm que ir ao <code>Common</code> .  <code>Month</code> será uma união discriminada com métodos para convertê-lo de e para <code>unsigned int16</code> ; <code>Year</code> será como <code>CardNumber</code> mas para <code>uint16</code> vez de string. </p><br></li></ol><br><p>  Agora vamos terminar nossa declaração de tipos de domínio.  Precisamos de <code>User</code> com algumas informações do usuário e coleta de cartões, precisamos de operações de saldo para recargas e pagamentos. </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserInfo</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LetterString</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Address</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Address</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserInfo</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cards</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> } [&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Struct</span></span></span><span class="hljs-class">&gt;] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BalanceChange</span></span></span><span class="hljs-class"> = //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- another common type with validation for positive amount | Increase of increase: MoneyTransaction | Decrease of decrease: MoneyTransaction with member this.ToDecimal() = match this with | Increase i -&gt; i.Value | Decrease d -&gt; -d.Value [&lt;Struct&gt;] type BalanceOperation = { CardNumber: CardNumber Timestamp: DateTimeOffset BalanceChange: BalanceChange NewBalance: Money }</span></span></span></span></code> </pre> <br><p>  Bom, projetamos nossos tipos de forma que o estado inválido não seja representável.  Agora, sempre que lidamos com instâncias de qualquer um desses tipos, temos certeza de que os dados são válidos e não precisamos validá-los novamente.  Agora podemos avançar para a lógica de negócios! </p><br><h3 id="business-logic">  Lógica de negócios </h3><br><p>  Teremos uma regra inquebrável aqui: toda a lógica de negócios será codificada em <strong>funções puras</strong> .  Uma função pura é uma função que satisfaz os seguintes critérios: </p><br><ul><li>  A única coisa que faz é calcular o valor de saída.  Não tem efeitos colaterais. </li><li>  Sempre produz a mesma saída para a mesma entrada. </li></ul><br><p>  Portanto, funções puras não lançam exceções, não produzem valores aleatórios, não interagem com o mundo exterior de qualquer forma, seja banco de dados ou um simples <code>DateTime.Now</code> .  É claro que interagir com a função impura automaticamente torna a função de chamada impura.  Então, o que devemos implementar? </p><br><p>  Aqui está uma lista de requisitos que temos: </p><br><ul><li><p>  <strong>Ativar / desativar cartão</strong> </p><br></li><li><p>  <strong>Processar pagamentos</strong> </p><br><p>  Podemos processar o pagamento se: </p><br><ol><li>  O cartão não expirou </li><li>  O cartão está ativo </li><li>  Há dinheiro suficiente para o pagamento </li><li>  Os gastos de hoje não excederam o limite diário. </li></ol><br></li><li><p>  <strong>Saldo de recarga</strong> </p><br><p>  Podemos completar o saldo do cartão ativo e não expirado. </p><br></li><li><p>  <strong>Definir limite diário</strong> </p><br><p>  O usuário pode definir o limite diário se o cartão não tiver expirado e estiver ativo. </p><br></li></ul><br><p>  Quando a operação não pode ser concluída, temos que retornar um erro; portanto, precisamos definir <code>OperationNotAllowedError</code> : </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OperationNotAllowedError</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operation</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reason</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> } //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- and a helper function to wrap it in `Error` which is a case for `Result&lt;'ok,'error&gt; type let operationNotAllowed operation reason = { Operation = operation; Reason = reason } |&gt; Error</span></span></span></span></code> </pre> <br><p>  Neste módulo com lógica de negócios, esse seria <em>o único</em> tipo de erro que retornamos.  Não fazemos validação aqui, não interagimos com o banco de dados - basta executar operações se pudermos retornar o <code>OperationNotAllowedError</code> . </p><br><p>  O módulo completo pode ser encontrado <a href="">aqui</a> .  Vou listar aqui o caso mais complicado aqui: <code>processPayment</code> .  Temos que verificar a validade, status ativo / desativado, dinheiro gasto hoje e saldo atual.  Como não podemos interagir com o mundo exterior, temos que passar todas as informações necessárias como parâmetros.  Dessa forma, essa <em>lógica</em> seria muito fácil de testar e permitirá que você faça <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">testes baseados em propriedades</a> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> processPayment (currentDate: <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span>) (spentToday: <span class="hljs-type"><span class="hljs-type">Money</span></span>) card (paymentAmount: <span class="hljs-type"><span class="hljs-type">MoneyTransaction</span></span>) = //<span class="hljs-comment"><span class="hljs-comment">-- first check for expiration if isCardExpired currentDate card then cardExpiredMessage card.CardNumber |&gt; processPaymentNotAllowed else //-- then active/deactivated match card.AccountDetails with | Deactivated -&gt; cardDeactivatedMessage card.CardNumber |&gt; processPaymentNotAllowed | Active accInfo -&gt; //-- if active then check balance if paymentAmount.Value &gt; accInfo.Balance.Value then sprintf "Insufficent funds on card %s" card.CardNumber.Value |&gt; processPaymentNotAllowed else //-- if balance is ok check limit and money spent today match accInfo.DailyLimit with | Limit limit when limit &lt; spentToday + paymentAmount -&gt; sprintf "Daily limit is exceeded for card %s with daily limit %M. Today was spent %M" card.CardNumber.Value limit.Value spentToday.Value |&gt; processPaymentNotAllowed (*{- We could use here the ultimate wild card case like this: | _ -&gt; but it's dangerous because if a new case appears in `DailyLimit` type, we won't get a compile error here, which would remind us to process this new case in here. So this is a safe way to do the same thing. -}*) | Limit _ | Unlimited -&gt; let newBalance = accInfo.Balance - paymentAmount let updatedCard = { card with AccountDetails = Active { accInfo with Balance = newBalance } } //-- note that we have to return balance operation, //-- so it can be stored to DB later. let balanceOperation = { Timestamp = currentDate CardNumber = card.CardNumber NewBalance = newBalance BalanceChange = Decrease paymentAmount } Ok (updatedCard, balanceOperation)</span></span></code> </pre> <br><p>  <code>spentToday</code> - teremos que calculá-lo a partir da coleção <code>BalanceOperation</code> que manteremos no banco de dados.  Então, precisaremos de um módulo para isso, que basicamente terá 1 função pública: </p><br><pre> <code class="haskell hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> private isDecrease change = match change with | <span class="hljs-type"><span class="hljs-type">Increase</span></span> _ -&gt; false | <span class="hljs-type"><span class="hljs-type">Decrease</span></span> _ -&gt; true <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spentAtDate (date: <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span>) cardNumber operations = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> date = date.<span class="hljs-type"><span class="hljs-type">Date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> operationFilter { <span class="hljs-type"><span class="hljs-type">CardNumber</span></span> = number; <span class="hljs-type"><span class="hljs-type">BalanceChange</span></span> = change; <span class="hljs-type"><span class="hljs-type">Timestamp</span></span> = timestamp } = isDecrease change &amp;&amp; number = cardNumber &amp;&amp; timestamp.<span class="hljs-type"><span class="hljs-type">Date</span></span> = date <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spendings = <span class="hljs-type"><span class="hljs-type">List</span></span>.filter operationFilter operations <span class="hljs-type"><span class="hljs-type">List</span></span>.sumBy (fun s -&gt; -s.<span class="hljs-type"><span class="hljs-type">BalanceChange</span></span>.<span class="hljs-type"><span class="hljs-type">ToDecimal</span></span>()) spendings |&gt; <span class="hljs-type"><span class="hljs-type">Money</span></span></code> </pre> <br><p>  Bom  Agora que terminamos toda a implementação da lógica de negócios, chegou a hora de pensar no mapeamento.  Muitos de nossos tipos usam uniões discriminadas, alguns não têm construtor público, portanto não podemos expô-los como estão para o mundo exterior.  Precisamos lidar com a (des) serialização.  Além disso, no momento, temos apenas um contexto limitado em nosso aplicativo, mas, mais tarde, na vida real, você deseja construir um sistema maior com múltiplos contextos limitados, e eles precisam interagir entre si por meio de contratos públicos, o que deve ser compreensível. para todos, incluindo outras linguagens de programação. </p><br><p>  Temos que fazer o mapeamento bidirecional: dos modelos públicos ao domínio e vice-versa.  Embora o mapeamento do domínio para os modelos seja bastante direto, a outra direção tem um pouco de dificuldade: os modelos podem ter dados inválidos, afinal usamos tipos simples que podem ser serializados para json.  Não se preocupe, teremos que construir nossa validação nesse mapeamento.  O fato de usarmos tipos diferentes para dados e dados possivelmente inválidos, <strong>sempre</strong> válidos, significa que o compilador não nos deixa esquecer de executar a validação. </p><br><p>  Aqui está o que parece: </p><br><pre> <code class="haskell hljs">(*<span class="hljs-comment"><span class="hljs-comment">{- You can use type aliases to annotate your functions. This is just an example, but sometimes it makes code more readable -}</span></span>*) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidateCreateCardCommand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCardCommandModel</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidationResult</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">&gt; let validateCreateCardCommand : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidateCreateCardCommand</span></span></span><span class="hljs-class"> = fun cmd -&gt; (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- that's a computation expression for `Result&lt;&gt;` type. Thanks to this we don't have to chose between short code and strait forward one, like we have to do in C# -}</span></span></span><span class="hljs-class">*) result { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LetterString</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cardNumber</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">month</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Month</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expirationMonth</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExpirationMonth</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">year</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Year</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expirationYear</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExpirationYear</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HolderId</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expiration</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">month</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">year</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountDetails</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Default</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> |&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Active</span></span></span><span class="hljs-class"> } }</span></span></code> </pre> <br><p>  O módulo completo para mapeamentos e validações está <a href="">aqui</a> e o módulo para mapeamento para modelos está <a href="">aqui</a> . </p><br><p>  Neste ponto, temos implementação para toda a lógica de negócios, mapeamentos, validação e assim por diante, e até agora tudo isso está completamente isolado do mundo real: está escrito inteiramente em funções puras.  Agora você deve estar se perguntando, como exatamente vamos fazer uso disso?  Porque nós temos que interagir com o mundo exterior.  Mais do que isso, durante a execução do fluxo de trabalho, precisamos tomar algumas decisões com base no resultado dessas interações no mundo real.  Então a questão é como montamos tudo isso?  No OOP, eles usam contêineres IoC para cuidar disso, mas aqui não podemos fazer isso, já que nem temos objetos, temos funções estáticas. </p><br><p>  Nós vamos usar o <code>Interpreter pattern</code> para isso!  É um pouco complicado, principalmente porque não é familiar, mas farei o possível para explicar esse padrão.  Primeiro, vamos falar sobre a composição da função.  Por exemplo, temos uma função <code>int -&gt; string</code> .  Isso significa que a função espera <code>int</code> como parâmetro e retorna string.  Agora vamos dizer que temos outra função <code>string -&gt; char</code> .  Nesse ponto, podemos encadeá-los, ou seja, executar o primeiro, pegar sua saída e alimentá-la para a segunda função, e há até um operador para isso: <code>&gt;&gt;</code> .  Veja como funciona: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> intToString (i: int) = i.<span class="hljs-type"><span class="hljs-type">ToString</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstCharOrSpace (s: string) = match s with | (null| <span class="hljs-string"><span class="hljs-string">""</span></span>) -&gt; ' ' | s -&gt; s.[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstDigitAsChar = intToString &gt;&gt; firstCharOrSpace //<span class="hljs-comment"><span class="hljs-comment">-- And you can chain as many functions as you like let alwaysTrue = intToString &gt;&gt; firstCharOrSpace &gt;&gt; Char.IsDigit</span></span></code> </pre> <br><p>  No entanto, não podemos usar encadeamento simples em alguns cenários, por exemplo, ativar o cartão.  Aqui está uma sequência de ações: </p><br><ul><li>  valide o número do cartão de entrada.  Se é válido, então </li><li>  tente obter um cartão com esse número.  Se houver um </li><li>  ativá-lo. </li><li>  salvar resultados.  Se estiver tudo bem, então </li><li>  mapear para modelar e retornar. </li></ul><br><p>  Os dois primeiros passos têm que, se <code>If it's ok then...</code>  Essa é a razão pela qual o encadeamento direto não está funcionando. </p><br><p>  Poderíamos simplesmente injetar como parâmetros essas funções, assim: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> activateCard getCardAsync saveCardAsync cardNumber = ...</code> </pre> <br><p>  Mas há certos problemas com isso.  Primeiro, o número de dependências pode aumentar e a assinatura da função ficará feia.  Segundo, estamos vinculados a efeitos específicos aqui: temos que escolher se é uma <code>Task</code> ou <code>Async</code> ou apenas chamadas de sincronização simples.  Terceiro, é fácil atrapalhar as coisas quando você tem tantas funções para passar: por exemplo, <code>createUserAsync</code> e <code>replaceUserAsync</code> têm a mesma assinatura, mas com efeitos diferentes; portanto, quando você precisa passá-las centenas de vezes, pode cometer um erro com sintomas realmente estranhos.  Por esses motivos, procuramos intérpretes. </p><br><p>  A idéia é que dividimos nosso código de composição em 2 partes: árvore de execução e intérprete para essa árvore.  Cada nó nesta árvore é um local para uma função com efeito que queremos injetar, como <code>getUserFromDatabase</code> .  Esses nós são definidos pelo nome, por exemplo, <code>getCard</code> , tipo de parâmetro de entrada, por exemplo, <code>CardNumber</code> e tipo de retorno, por exemplo, <code>Card option</code> .  Não especificamos aqui <code>Task</code> ou <code>Async</code> , isso não faz parte da árvore, <em>faz parte do intérprete</em> .  Cada borda desta árvore é uma série de transformações puras, como validação ou execução de função da lógica de negócios.  As bordas também têm alguma entrada, por exemplo, número do cartão de sequência não processada, e há validação, que pode nos dar um erro ou um número de cartão válido.  Se houver um erro, interromperemos essa borda; caso contrário, ela nos levará ao próximo nó: <code>getCard</code> .  Se esse nó retornar <code>Some card</code> , podemos continuar até a próxima borda, que seria a ativação e assim por diante. </p><br><p>  Para todos os cenários como <code>activateCard</code> <code>topUp</code> ou o <code>topUp</code> , construiremos uma árvore separada.  Quando essas árvores são construídas, seus nós ficam meio vazios, eles não têm funções reais, <em>eles têm um lugar</em> para essas funções.  O objetivo do intérprete é preencher esses nós, simples assim.  O intérprete conhece os efeitos que usamos, por exemplo, <code>Task</code> , e sabe qual função real colocar em um determinado nó.  Quando visita um nó, ele executa a função real correspondente, aguarda-o no caso de <code>Task</code> ou <code>Async</code> e passa o resultado para a próxima borda.  Essa borda pode levar a outro nó e, em seguida, é um trabalho para intérprete novamente, até que esse intérprete atinja o nó de parada, a parte inferior de nossa recursão, onde apenas retornamos o resultado de toda a execução de nossa árvore. </p><br><p>  A árvore inteira seria representada com união discriminada e um nó ficaria assim: </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'a&gt; = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- &lt;- THE NODE | ... //-- ANOTHER NODE</span></span></span></span></code> </pre> <br><p>  Sempre será uma tupla, onde o primeiro elemento é uma entrada para sua dependência e o último elemento é uma <em>função</em> , que recebe o resultado dessa dependência.  Esse "espaço" entre esses elementos da tupla é onde sua dependência se encaixa, como nos exemplos de composição, onde você tem a função <code>'a -&gt; 'b</code> , <code>'c -&gt; 'd</code> e precisa colocar outro <code>'b -&gt; 'c</code> entre eles para conectá-los. </p><br><p>  Como estamos dentro do nosso contexto limitado, não devemos ter muitas dependências e, se tivermos - provavelmente é hora de dividir nosso contexto em outras menores. </p><br><p>  Aqui está o que parece, a fonte completa está <a href="">aqui</a> : </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'a&gt; = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> * ((</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class">) option -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'a&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> of (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class">) * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserInfo</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> of (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DateTimeOffset</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DateTimeOffset</span></span></span><span class="hljs-class">) * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BalanceOperation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BalanceOperation</span></span></span><span class="hljs-class"> * (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unit</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class"> of 'a (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- This bind function allows you to pass a continuation for current node of your expression tree the code is basically a boiler plate, as you can see. -}</span></span></span><span class="hljs-class">*) let rec bind f instruction = match instruction with | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">,(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">,(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">,(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">,(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class"> x -&gt; fx (*</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">{- This is a set of basic functions. Use them in your expression tree builder to represent dependency call -}</span></span></span><span class="hljs-class">*) let stop x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class"> x let getCardByNumber number = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let getCardWithAccountInfo number = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let createNewCard (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">), stop) let replaceCard card = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let getUserById id = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let createNewUser user = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">) let getBalanceOperations (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fromDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toDate</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fromDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toDate</span></span></span><span class="hljs-class">), stop) let saveBalanceOperation op = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> With a help of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">computation expressions</a> , we now have a very easy way to build our workflows without having to care about implementation of real-world interactions. We do that in <a href="">CardWorkflow module</a> : </p><br><pre> <code class="haskell hljs">(*<span class="hljs-comment"><span class="hljs-comment">{- `program` is the name of our computation expression. In every `let!` binding we unwrap the result of operation, which can be either `Program&lt;'a&gt;` or `Program&lt;Result&lt;'a, Error&gt;&gt;`. What we unwrap would be of type 'a. If, however, an operation returns `Error`, we stop the execution at this very step and return it. The only thing we have to take care of is making sure that type of error is the same in every operation we call -}</span></span>*) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> processPayment (currentDate: <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span>, payment) = program { (*<span class="hljs-comment"><span class="hljs-comment">{- You can see these `expectValidationError` and `expectDataRelatedErrors` functions here. What they do is map different errors into `Error` type, since every execution branch must return the same type, in this case `Result&lt;'a, Error&gt;`. They also help you quickly understand what's going on in every line of code: validation, logic or calling external storage. -}</span></span>*) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! cmd = validateProcessPaymentCommand payment |&gt; expectValidationError <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! card = tryGetCard cmd.<span class="hljs-type"><span class="hljs-type">CardNumber</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> today = currentDate.<span class="hljs-type"><span class="hljs-type">Date</span></span> |&gt; <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tomorrow = currentDate.<span class="hljs-type"><span class="hljs-type">Date</span></span>.<span class="hljs-type"><span class="hljs-type">AddDays</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span> |&gt; <span class="hljs-type"><span class="hljs-type">DateTimeOffset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! operations = getBalanceOperations (cmd.<span class="hljs-type"><span class="hljs-type">CardNumber</span></span>, today, tomorrow) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spentToday = <span class="hljs-type"><span class="hljs-type">BalanceOperation</span></span>.spentAtDate currentDate cmd.<span class="hljs-type"><span class="hljs-type">CardNumber</span></span> operations <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! (card, op) = <span class="hljs-type"><span class="hljs-type">CardActions</span></span>.processPayment currentDate spentToday card cmd.<span class="hljs-type"><span class="hljs-type">PaymentAmount</span></span> |&gt; expectOperationNotAllowedError <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>! saveBalanceOperation op |&gt; expectDataRelatedErrorProgram <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>! replaceCard card |&gt; expectDataRelatedErrorProgram return card |&gt; toCardInfoModel |&gt; <span class="hljs-type"><span class="hljs-type">Ok</span></span> }</code> </pre> <br><p> This module is the last thing we need to implement in business layer. Also, I've done some refactoring: I moved errors and common types to <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Common project</a> . About time we moved on to implementing data access layer. </p><br><h3 id="data-access-layer"> Data access layer </h3><br><p> The design of entities in this layer may depend on our database or framework we use to interact with it. Therefore domain layer doesn't know anything about these entities, which means we have to take care of mapping to and from domain models in here. Which is quite convenient for consumers of our DAL API. For this application I've chosen MongoDB, not because it's a best choice for this kind of task, but because there're many examples of using SQL DBs already and I wanted to add something different. We are gonna use C# driver. </p><br><p> For the most part it's gonna be pretty strait forward, the only tricky moment is with <code>Card</code> . When it's active it has an <code>AccountInfo</code> inside, when it's not it doesn't. So we have to split it in two documents: <code>CardEntity</code> and <code>CardAccountInfoEntity</code> , so that deactivating card doesn't erase information about balance and daily limit. </p><br><p> Other than that we just gonna use primitive types instead of discriminated unions and types with built-in validation. </p><br><p> There're also few things we need to take care of, since we are using C# library: </p><br><ul><li> Convert <code>null</code> s to <code>Option&lt;'a&gt;</code> </li><li> Catch expected exceptions and convert them to our errors and wrap it in <code>Result&lt;_,_&gt;</code> </li></ul><br><p> We start with <a href="">CardDomainEntities module</a> , where we define our entities: </p><br><pre> <code class="haskell hljs"> [&lt;<span class="hljs-type"><span class="hljs-type">CLIMutable</span></span>&gt;] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardEntity</span></span></span><span class="hljs-class"> = { [&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BsonId</span></span></span><span class="hljs-class">&gt;] </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CardNumber</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsActive</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExpirationMonth</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uint16</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExpirationYear</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uint16</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UserId</span></span></span><span class="hljs-class"> } with //</span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- we're gonna need this in every entity for error messages member this.EntityId = this.CardNumber.ToString() (*{- we use this Id comparer quotation (F# alternative to C# Expression) for updating entity by id, since for different entities identifier has different name and type -}*) member this.IdComparer = &lt;@ System.Func&lt;_,_&gt; (fun c -&gt; c.CardNumber = this.CardNumber) @&gt;</span></span></span></span></code> </pre> <br><p> Those fields <code>EntityId</code> and <code>IdComparer</code> we are gonna use with a help of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SRTP</a> . We'll define functions that will retrieve them from any type that has those fields define, without forcing every entity to implement some interface: </p><br><pre> <code class="haskell hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inline (|<span class="hljs-type"><span class="hljs-type">HasEntityId</span></span>|) x = fun () -&gt; (^a : (member <span class="hljs-type"><span class="hljs-type">EntityId</span></span>: string) x) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inline entityId (<span class="hljs-type"><span class="hljs-type">HasEntityId</span></span> f) = f() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inline (|<span class="hljs-type"><span class="hljs-type">HasIdComparer</span></span>|) x = fun () -&gt; (^a : (member <span class="hljs-type"><span class="hljs-type">IdComparer</span></span>: <span class="hljs-type"><span class="hljs-type">Quotations</span></span>.<span class="hljs-type"><span class="hljs-type">Expr</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Func</span></span>&lt; ^a, bool&gt;&gt;) x) //<span class="hljs-comment"><span class="hljs-comment">-- We need to convert F# quotations to C# expressions //-- which C# mongo db driver understands. let inline idComparer (HasIdComparer id) = id() |&gt; LeafExpressionConverter.QuotationToExpression |&gt; unbox&lt;Expression&lt;Func&lt;_,_&gt;&gt;&gt;</span></span></code> </pre> <br><p> As for <code>null</code> and <code>Option</code> thing, since we use record types, F# compiler doesn't allow using <code>null</code> value, neither for assigning nor for comparison. At the same time record types are just another CLR types, so technically we can and will get a <code>null</code> value, thanks to C# and design of this library. We can solve this in 2 ways: use <code>AllowNullLiteral</code> attribute, or use <code>Unchecked.defaultof&lt;'a&gt;</code> . I went for the second choice since this <code>null</code> situation should be localized as much as possible: </p><br><pre> <code class="haskell hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isNullUnsafe (arg: 'a when 'a: not struct) = arg = <span class="hljs-type"><span class="hljs-type">Unchecked</span></span>.defaultof&lt;'a&gt; //<span class="hljs-comment"><span class="hljs-comment">-- then we have this function to convert nulls to option, //-- therefore we limited this toxic null thing in here. let unsafeNullToOption a = if isNullUnsafe a then None else Some a</span></span></code> </pre> <br><p> In order to deal with expected exception for duplicate key, we use Active Patterns again: </p><br><pre> <code class="haskell hljs"> //<span class="hljs-comment"><span class="hljs-comment">-- First we define a function which checks, whether exception is about duplicate key let private isDuplicateKeyException (ex: Exception) = ex :? MongoWriteException &amp;&amp; (ex :?&gt; MongoWriteException).WriteError.Category = ServerErrorCategory.DuplicateKey //-- Then we have to check wrapping exceptions for this let rec private (|DuplicateKey|_|) (ex: Exception) = match ex with | :? MongoWriteException as ex when isDuplicateKeyException ex -&gt; Some ex | :? MongoBulkWriteException as bex when bex.InnerException |&gt; isDuplicateKeyException -&gt; Some (bex.InnerException :?&gt; MongoWriteException) | :? AggregateException as aex when aex.InnerException |&gt; isDuplicateKeyException -&gt; Some (aex.InnerException :?&gt; MongoWriteException) | _ -&gt; None //-- And here's the usage: let inline private executeInsertAsync (func: 'a -&gt; Async&lt;unit&gt;) arg = async { try do! func(arg) return Ok () with | DuplicateKey ex -&gt; return EntityAlreadyExists (arg.GetType().Name, (entityId arg)) |&gt; Error }</span></span></code> </pre> <br><p> After mapping is implemented we have everything we need to assemble <a href="">API for our data access layer</a> , which looks like this: </p><br><pre> <code class="haskell hljs"> //<span class="hljs-comment"><span class="hljs-comment">-- `MongoDb` is a type alias for `IMongoDatabase` let replaceUserAsync (mongoDb: MongoDb) : ReplaceUserAsync = fun user -&gt; user |&gt; DomainToEntityMapping.mapUserToEntity |&gt; CommandRepository.replaceUserAsync mongoDb let getUserInfoAsync (mongoDb: MongoDb) : GetUserInfoAsync = fun userId -&gt; async { let! userInfo = QueryRepository.getUserInfoAsync mongoDb userId return userInfo |&gt; Option.map EntityToDomainMapping.mapUserInfoEntity }</span></span></code> </pre> <br><p> The last moment I mention is when we do mapping <code>Entity -&gt; Domain</code> , we have to instantiate types with built-in validation, so there can be validation errors. In this case we won't use <code>Result&lt;_,_&gt;</code> because if we've got invalid data in DB, it's a bug, not something we expect. So we just throw an exception. Other than that nothing really interesting is happening in here. The full source code of data access layer you'll find <a href="">here</a> . </p><br><h3 id="composition-logging-and-all-the-rest"> Composition, logging and all the rest </h3><br><p> As you remember, we're not gonna use DI framework, we went for interpreter pattern. If you want to know why, here's some reasons: </p><br><ul><li> IoC container operates in runtime. So until you run your program you can't know that all the dependencies are satisfied. </li><li> It's a powerful tool which is very easy to abuse: you can do property injection, use lazy dependencies, and sometimes even some business logic can find it's way in dependency registering/resolving (yeah, I've witnessed it). All of that makes code maintaining extremely hard. </li></ul><br><p> That means we need a place for that functionality. We could place it on a top level in our Web Api, but in my opinion it's not a best choice: right now we are dealing with only 1 bounded context, but if there's more, this global place with all the interpreters for each context will become cumbersome. Besides, there's single responsibility rule, and web api project should be responsible for web, right? So we create <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CardManagement.Infrastructure project</a> . </p><br><p> Here we will do several things: </p><br><ul><li> Composing our functionality </li><li> App configuration </li><li> Logging </li></ul><br><p> If we had more than 1 context, app configuration and log configuration should be moved to global infrastructure project, and the only thing happening in this project would be assembling API for our bounded context, but in our case this separation is not necessary. </p><br><p> Let's get down to composition. We've built execution trees in our domain layer, now we have to interpret them. Every node in that tree represents some dependency call, in our case a call to database. If we had a need to interact with 3rd party api, that would be in here also. So our interpreter has to know how to handle every node in that tree, which is verified in compile time, thanks to <code>&lt;TreatWarningsAsErrors&gt;</code> setting. Here's what it looks like: </p><br><pre> <code class="haskell hljs">(*<span class="hljs-comment"><span class="hljs-comment">{- Those `bindAsync (next &gt;&gt; interpretCardProgram mongoDb)` work pretty simple: we execute async function to the left of this expression, await that operation and pass the result to the next node, after which we interpret that node as well, until we reach the bottom of this recursion: `Stop a` node. -}</span></span>*) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rec</span></span> private interpretCardProgram mongoDb prog = match prog with | <span class="hljs-type"><span class="hljs-type">GetCard</span></span> (cardNumber, next) -&gt; cardNumber |&gt; getCardAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">GetCardWithAccountInfo</span></span> (number, next) -&gt; number |&gt; getCardWithAccInfoAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">CreateCard</span></span> ((card,acc), next) -&gt; (card, acc) |&gt; createCardAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">ReplaceCard</span></span> (card, next) -&gt; card |&gt; replaceCardAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">GetUser</span></span> (id, next) -&gt; getUserAsync mongoDb id |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">CreateUser</span></span> (user, next) -&gt; user |&gt; createUserAsync mongoDb |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">GetBalanceOperations</span></span> (request, next) -&gt; getBalanceOperationsAsync mongoDb request |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">SaveBalanceOperation</span></span> (op, next) -&gt; saveBalanceOperationAsync mongoDb op |&gt; bindAsync (next &gt;&gt; interpretCardProgram mongoDb) | <span class="hljs-type"><span class="hljs-type">Stop</span></span> a -&gt; async.<span class="hljs-type"><span class="hljs-type">Return</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interpret prog = try <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interpret = interpretCardProgram (getMongoDb()) interpret prog with | failure -&gt; <span class="hljs-type"><span class="hljs-type">Bug</span></span> failure |&gt; <span class="hljs-type"><span class="hljs-type">Error</span></span> |&gt; async.<span class="hljs-type"><span class="hljs-type">Return</span></span></code> </pre> <br><p> Note that this interpreter is the place where we have this <code>async</code> thing. We can do another interpreter with <code>Task</code> or just a plain sync version of it. Now you're probably wondering, how we can cover this with unit-test, since familiar mock libraries ain't gonna help us. Well, it's easy: you have to make another interpreter. Here's what it can look like: </p><br><pre> <code class="haskell hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class">&lt;unit, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataRelatedError</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TestInterpreterConfig</span></span></span><span class="hljs-class"> = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class">: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AccountInfo</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BalanceOperation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveResult</span></span></span><span class="hljs-class"> } let defaultConfig = { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accountInfo</span></span></span><span class="hljs-class">) |&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Some</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class">() </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">balanceOperations</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class">() </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class">() </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ok</span></span></span><span class="hljs-class">() } let testInject a = fun _ -&gt; a let rec interpretCardProgram config (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prog</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class">&lt;'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">&gt;) = match prog with | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cardNumber</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; cardNumber |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCard</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; number |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCardWithAccountInfo</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">), next) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acc</span></span></span><span class="hljs-class">) |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateCard</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">card</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; card |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReplaceCard</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; id |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetUser</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; user |&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateUser</span></span></span><span class="hljs-class"> |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetBalanceOperations</span></span></span><span class="hljs-class"> request |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; testInject config.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SaveBalanceOperation</span></span></span><span class="hljs-class"> op |&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> &gt;&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interpretCardProgram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class"> a -&gt; a</span></span></code> </pre> <br><p> We've created <code>TestInterpreterConfig</code> which holds desired results of every operation we want to inject. You can easily change that config for every given test and then just run interpreter. This interpreter is sync, since there's no reason to bother with <code>Task</code> or <code>Async</code> . </p><br><p> There's nothing really tricky about the logging, but you can find it in <a href="">this module</a> . The approach is that we wrap the function in logging: we log function name, parameters and log result. If result is ok, it's info, if error it's a warning and if it's a <code>Bug</code> then it's an error. That's pretty much it. </p><br><p> One last thing is to make a facade, since we don't want to expose raw interpreter calls. Here's the whole thing: </p><br><pre> <code class="haskell hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> createUser arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.createUser &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.createUser"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> createCard arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.createCard &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.createCard"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activateCard arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.activateCard &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.activateCard"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> deactivateCard arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.deactivateCard &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.deactivateCard"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> processPayment arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.processPayment &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.processPayment"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topUp arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.topUp &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.topUp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> setDailyLimit arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.setDailyLimit &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.setDailyLimit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> getCard arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.getCard &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpret |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.getCard"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> getUser arg = arg |&gt; (<span class="hljs-type"><span class="hljs-type">CardWorkflow</span></span>.getUser &gt;&gt; <span class="hljs-type"><span class="hljs-type">CardProgramInterpreter</span></span>.interpretSimple |&gt; logifyResultAsync <span class="hljs-string"><span class="hljs-string">"CardApi.getUser"</span></span>)</code> </pre> <br><p> All the dependencies here are injected, logging is taken care of, no exceptions is thrown — that's it. For web api I used <a href="">Giraffe</a> framework. Web project is <a href="">here</a> . </p><br><h2 id="conclusion">  Conclusão </h2><br><p> We have built an application with validation, error handling, logging, business logic — all those things you usually have in your application. The difference is this code is way more durable and easy to refactor. Note that we haven't used reflection or code generation, no exceptions, but still our code isn't verbose. It's easy to read, easy to understand and hard to break. As soon as you add another field in your model, or another case in one of our union types, the code won't compile until you update every usage. Sure it doesn't mean you're totally safe or that you don't need any kind of testing at all, it just means that you're gonna have fewer problems when you develope new features or do some refactoring. The development process will be both cheaper and more interesting, because this tool allows you to focus on your domain and business tasks, instead of drugging focus on keeping an eye out that nothing is broken. </p><br><p> Another thing: I don't claim that OOP is completely useless and we don't need it, that's not true. I'm saying that we don't need it for solving <em>every single task</em> we have, and that a big portion of our tasks can be better solved with FP. And truth is, as always, in balance: we can't solve everything efficiently with only one tool, so a good programming language should have a decent support of both FP and OOP. And, unfortunately, a lot of most popular languages today have only lambdas and async programming from functional world. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458730/">https://habr.com/ru/post/pt458730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458718/index.html">Grande entrevista com Cliff Click, o pai da compilação JIT em Java</a></li>
<li><a href="../pt458720/index.html">A escola de programadores hh.ru, pela décima vez, abre um conjunto de especialistas em TI</a></li>
<li><a href="../pt458724/index.html">Redes neurais e aprendizado profundo, capítulo 3, parte 1: melhorando a maneira como as redes neurais são treinadas</a></li>
<li><a href="../pt458726/index.html">Habr Special // Podcast com autor de Invasion. Uma Breve História dos Hackers Russos</a></li>
<li><a href="../pt458728/index.html">O que são bicicletas elétricas (revisão em grupo de cinco modelos de dois fabricantes), parte 2</a></li>
<li><a href="../pt458732/index.html">SIG? ou não GIS? Essa é a questão</a></li>
<li><a href="../pt458734/index.html">Dias úteis do data center: insignificantes por 7 anos de operação. E a continuação sobre o rato</a></li>
<li><a href="../pt458738/index.html">Matéria e antimatéria: o que é, qual é a diferença e o que o neutrino tem a ver com isso</a></li>
<li><a href="../pt458740/index.html">E o Senhor ordenou: "Entreviste e aceite as ofertas"</a></li>
<li><a href="../pt458742/index.html">Kirill Tolkachev e Maxim Gorelikov sobre Spring Boot em jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>