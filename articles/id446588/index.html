<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÑ üé© üëêüèº Memeriksa Kode Sumber Roslyn üÜò üìà üéµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekali-sekali kita kembali ke proyek yang sebelumnya telah kita periksa menggunakan PVS-Studio, yang menghasilkan deskripsi mereka di berbagai artikel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memeriksa Kode Sumber Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio vs Roslyn"></div><br>  Sekali-sekali kita kembali ke proyek yang sebelumnya telah kita periksa menggunakan PVS-Studio, yang menghasilkan deskripsi mereka di berbagai artikel.  Dua alasan membuat comeback ini menarik bagi kami.  Pertama, kesempatan untuk menilai kemajuan alat analisis kami.  Kedua, memantau umpan balik dari penulis proyek untuk artikel kami dan laporan kesalahan, yang biasanya kami berikan kepada mereka.  Tentu saja, kesalahan dapat diperbaiki tanpa partisipasi kami.  Namun, selalu menyenangkan ketika upaya kami membantu membuat proyek lebih baik.  Roslyn tidak terkecuali.  Artikel sebelumnya tentang pemeriksaan proyek ini tanggal kembali ke 23 Desember 2015. Ini cukup lama, mengingat kemajuan yang telah dibuat oleh analis kami sejak saat itu.  Karena inti C # dari analisa PVS-Studio didasarkan pada Roslyn, itu memberi kami minat tambahan dalam proyek ini.  Sebagai hasilnya, kami sama tertarik dengan mustard tentang kualitas kode proyek ini.  Sekarang mari kita coba sekali lagi dan cari tahu beberapa masalah baru dan menarik (tapi mari kita berharap tidak ada yang signifikan) yang dapat ditemukan oleh PVS-Studio. <br><a name="habracut"></a><br>  Banyak pembaca kami mungkin sangat menyadari Roslyn (atau .NET Compiler Platform).  Singkatnya, ini adalah kumpulan kompiler open source dan API untuk analisis kode bahasa C # dan Visual Basic .NET dari Microsoft.  Kode sumber proyek tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  Saya tidak akan memberikan penjelasan rinci tentang platform ini dan saya akan merekomendasikan memeriksa artikel oleh rekan saya Sergey Vasiliev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Roslyn dan penggunaannya dalam pengembangan program</a> " untuk semua pembaca yang tertarik.  Dari artikel ini, Anda dapat mengetahui tidak hanya tentang fitur arsitektur Roslyn, tetapi bagaimana tepatnya kami menggunakan platform ini. <br><br>  Seperti yang saya sebutkan sebelumnya, sudah lebih dari 3 tahun sejak kolega saya Andrey Karpov menulis artikel terakhir tentang cek Roslyn " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">New Year PVS-Studio 6.00 Release: Scanning Roslyn</a> ".  Sejak itu, penganalisa C # PVS-Studio telah mendapatkan banyak fitur baru.  Sebenarnya, artikel Andrey adalah uji kasus, karena pada saat itu penganalisa C # baru saja ditambahkan di PVS-Studio.  Meskipun demikian, kami berhasil mendeteksi kesalahan dalam proyek Roslyn, yang tentu saja berkualitas tinggi.  Jadi apa yang telah berubah dalam alat analisis untuk kode C # pada saat ini yang memungkinkan kami melakukan analisis yang lebih mendalam? <br><br>  Sejak itu, inti dan infrastruktur telah berkembang.  Kami menambahkan dukungan untuk Visual Studio 2017 dan Roslyn 2.0, dan integrasi mendalam dengan MSBuild.  Artikel oleh rekan saya Paul Eremeev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan Visual Studio 2017 dan Roslyn 2.0 di PVS-Studio: kadang-kadang itu tidak mudah untuk menggunakan solusi yang sudah jadi seperti yang tampak</a> " menggambarkan pendekatan kami untuk integrasi dengan MSBuild dan alasan untuk keputusan ini. <br><br>  Saat ini kami secara aktif bekerja untuk pindah ke Roslyn 3.0 dengan cara yang sama seperti kami awalnya mendukung Visual Studio 2017. Ini membutuhkan penggunaan toolset kami sendiri, termasuk dalam distribusi PVS-Studio sebagai "rintisan", yang merupakan MSBuild kosong File .exe.  Terlepas dari kenyataan bahwa itu terlihat seperti "penopang" (MSBuild API tidak terlalu ramah untuk digunakan kembali dalam proyek-proyek pihak ketiga karena portabilitas perpustakaan rendah), pendekatan semacam itu telah membantu kami untuk secara relatif mulus mengatasi beberapa pembaruan Roslyn dalam hal Visual Studio 2017. Sampai sekarang ini membantu (bahkan dengan beberapa tantangan) untuk melewati pembaruan Visual Studio 2019 dan mempertahankan kompatibilitas mundur penuh dan kinerja untuk sistem dengan versi MSBuild yang lebih lama. <br><br>  Inti penganalisa juga telah mengalami sejumlah perbaikan.  Salah satu fitur utama adalah analisis interprocedural lengkap dengan pertimbangan nilai-nilai metode input dan output, mengevaluasi (tergantung pada parameter ini) jangkauan cabang eksekusi dan titik pengembalian. <br><br>  Kami sedang dalam perjalanan untuk menyelesaikan tugas pemantauan parameter di dalam metode (misalnya, dereferensi yang berpotensi berbahaya) bersama dengan menyimpan anotasi otomatis mereka.  Untuk diagnostik yang menggunakan mekanisme aliran data, ini akan memungkinkan mempertimbangkan situasi berbahaya, terjadi ketika melewati parameter dalam suatu metode.  Sebelum ini, ketika menganalisis tempat berbahaya seperti itu, peringatan tidak dibuat, karena kami tidak bisa tahu tentang semua nilai input yang mungkin dalam metode seperti itu.  Sekarang kita dapat mendeteksi bahaya, karena di semua tempat memanggil metode ini, parameter input ini akan diperhitungkan. <br><br>  Catatan: Anda dapat membaca tentang mekanisme analisa dasar, seperti aliran data dan lainnya dalam artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teknologi yang digunakan dalam penganalisa kode PVS-Studio untuk menemukan bug dan potensi kerentanan</a> ". <br><br>  Analisis antar-prosedur dalam PVS-Studio C # tidak dibatasi oleh parameter input, maupun kedalaman.  Satu-satunya batasan adalah metode virtual di kelas, terbuka untuk warisan, serta masuk ke rekursi (analisis berhenti ketika tersandung panggilan berulang metode yang sudah dievaluasi).  Dengan demikian, metode rekursif itu sendiri pada akhirnya akan dievaluasi dengan asumsi bahwa nilai pengembalian rekursi tidak diketahui. <br><br>  Fitur baru yang hebat lainnya dalam penganalisis C # telah mempertimbangkan kemungkinan dereferensi penunjuk yang berpotensi nol.  Sebelum itu, penganalisa mengeluh tentang kemungkinan pengecualian referensi nol, dipastikan bahwa di semua cabang eksekusi nilai variabel akan menjadi nol.  Tentu saja, itu salah dalam beberapa kasus, itu sebabnya diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> sebelumnya disebut referensi nol potensial. <br><br>  Sekarang penganalisa menyadari fakta bahwa variabel bisa nol di salah satu cabang eksekusi (misalnya, di bawah kondisi <i>if</i> tertentu).  Jika ia melihat akses ke variabel seperti itu tanpa centang, itu akan mengeluarkan peringatan V3080, tetapi pada tingkat kepastian yang lebih rendah, daripada jika ia melihat nol di semua cabang.  Seiring dengan peningkatan analisis antarproedural, mekanisme semacam itu memungkinkan menemukan kesalahan yang sangat sulit dideteksi.  Berikut ini sebuah contoh - bayangkan rantai panjang pemanggilan metode, yang terakhir tidak Anda kenal.  Dalam keadaan tertentu, ia mengembalikan nol di blok <i>tangkap</i> , tetapi Anda belum terlindungi dari ini, karena Anda belum tahu.  Dalam hal ini, penganalisa hanya mengeluh, ketika ia benar-benar melihat penugasan nol.  Dalam pandangan kami, ini secara kualitatif membedakan pendekatan kami dari fitur C # 8.0 sebagai referensi jenis yang dapat dibatalkan, yang, pada kenyataannya, terbatas pada pengaturan pemeriksaan untuk null untuk setiap metode.  Namun, kami menyarankan alternatif - untuk melakukan pemeriksaan hanya di tempat-tempat di mana null benar-benar dapat terjadi, dan penganalisa kami sekarang dapat mencari kasus-kasus tersebut. <br><br>  Jadi, jangan menunda poin utama terlalu lama dan menyalahkan orang lain - menganalisis hasil pemeriksaan Roslyn.  Pertama, mari kita pertimbangkan kesalahan yang ditemukan karena fitur-fitur yang dijelaskan di atas.  Singkatnya, ada cukup banyak peringatan untuk kode Roslyn kali ini.  Saya pikir ini terkait dengan fakta bahwa platform sangat aktif berkembang (pada titik ini basis kode sekitar 2.770.000 baris tidak termasuk kosong), dan kami belum menganalisis proyek ini lama.  Namun demikian, tidak ada begitu banyak kesalahan kritis, sedangkan mereka yang paling menarik untuk artikel ini.  Seperti biasa, saya mengecualikan tes dari cek, ada cukup banyak di Roslyn. <br><br>  Saya akan mulai dengan kesalahan V3080 tingkat menengah kepastian, di mana penganalisa telah mendeteksi kemungkinan akses dengan referensi nol, tetapi tidak dalam semua kasus yang mungkin (kode cabang). <br><br>  <b>Kemungkinan null dereference - Medium</b> <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'saat ini'.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Mari kita pertimbangkan metode <i>GetNode</i> .  Alat analisis menyarankan akses dengan referensi nol dimungkinkan dalam kondisi blok <i>sementara</i> <i>.</i>  Variabel diberikan nilai dalam tubuh blok <i>sementara</i> , yang merupakan hasil dari metode <i>AsNode</i> .  Dalam beberapa kasus, nilai ini akan menjadi <i>nol</i> .  Contoh yang baik dari analisis antar prosedur dalam aksi. <br><br>  Sekarang mari kita pertimbangkan kasus serupa, di mana analisis antar-prosedur dilakukan melalui dua pemanggilan metode. <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'direktori'.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  Variabel <i>direktori</i> dalam tubuh metode <i>ExpandFileNamePattern</i> mendapatkan nilai dari metode <i>GetDirectoryName (string)</i> .  Itu, pada gilirannya, mengembalikan hasil metode <i>GetDirectoryName</i> kelebihan <i>(string, bool)</i> yang nilainya bisa <i>nol</i> .  Karena <i>direktori</i> variabel digunakan tanpa pemeriksaan pendahuluan untuk null dalam tubuh metode <i>ExpandFileNamePattern</i> - kita dapat menyatakan penganalisa dengan benar tentang mengeluarkan peringatan.  Ini adalah konstruksi yang berpotensi tidak aman. <br><br>  Fragmen kode lain dengan kesalahan V3080, lebih tepatnya, dengan dua kesalahan, dikeluarkan untuk satu baris kode.  Analisis antar-prosedur tidak diperlukan di sini. <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Variabel <i>spanStartLocation</i> dan <i>spanEndLocationExclusive</i> adalah dari tipe <i>int nullable</i> dan diinisialisasi dengan <i>nol</i> .  Lebih lanjut di sepanjang kode mereka dapat diberi nilai, tetapi hanya dalam kondisi tertentu.  Dalam beberapa kasus, nilainya tetap <i>nol</i> .  Setelah itu, variabel-variabel ini diakses dengan referensi tanpa pemeriksaan awal untuk null, yang menunjukkan penganalisa. <br><br>  Kode Roslyn mengandung cukup banyak kesalahan seperti itu, lebih dari 100. Seringkali pola kesalahan ini sama.  Ada beberapa jenis metode umum, yang berpotensi mengembalikan <i>nol</i> .  Hasil dari metode ini digunakan di banyak tempat, kadang-kadang melalui puluhan panggilan metode menengah atau pemeriksaan tambahan.  Penting untuk dipahami bahwa kesalahan ini tidak fatal, tetapi mereka berpotensi menyebabkan akses dengan referensi nol.  Meskipun mendeteksi kesalahan seperti itu cukup menantang.  Itu sebabnya dalam beberapa kasus seseorang harus mempertimbangkan kode refactoring, dalam hal ini jika <i>null</i> kembali, metode ini akan mengeluarkan pengecualian.  Jika tidak, Anda dapat mengamankan kode Anda hanya dengan pemeriksaan umum yang cukup melelahkan dan terkadang tidak dapat diandalkan.  Bagaimanapun, jelas bahwa setiap kasus spesifik memerlukan solusi berdasarkan spesifikasi proyek. <br><br>  Catatan  Kebetulan, bahwa pada titik tertentu tidak ada kasus seperti itu (input data), ketika metode mengembalikan <i>nol</i> dan tidak ada kesalahan aktual.  Namun, kode semacam itu masih tidak dapat diandalkan, karena semuanya dapat berubah ketika memperkenalkan beberapa perubahan kode. <br><br>  Untuk menjatuhkan subjek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> , mari kita lihat kesalahan yang jelas dari tingkat kepastian tinggi, ketika akses dengan referensi nol adalah yang paling mungkin atau bahkan tak terhindarkan. <br><br>  <b>Kemungkinan null dereference - Tinggi</b> <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Karena kesalahan ketik dalam kondisi ( <i>&amp;&amp;</i> digunakan sebagai ganti operator <i>||</i> ), kode bekerja secara berbeda dari yang dimaksudkan dan akses ke variabel <i>collectionType.Type</i> akan dieksekusi ketika itu <i>nol</i> .  Kondisi tersebut harus diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Ngomong-ngomong, hal-hal dapat terungkap dengan cara lain: di bagian pertama kondisi operator <i>==</i> dan <i>! =</i> Kacau <i>.</i>  Maka kode yang benar akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Versi kode ini kurang logis, tetapi juga memperbaiki kesalahan.  Solusi akhir ada pada penulis proyek untuk memutuskan. <br><br>  Kesalahan serupa lainnya. <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'tindakan'.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Kesalahan dibuat saat membuat pesan untuk pengecualian.  Ini diikuti oleh upaya untuk mengakses properti <i>action.DisplayText</i> melalui variabel <i>tindakan</i> , yang dikenal sebagai <i>nol</i> . <br><br>  Di sinilah kesalahan V3080 terakhir dari tingkat Tinggi. <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'tipe'.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  Metodenya cukup kecil, jadi saya kutip sepenuhnya.  Kondisi di blok <i>kembali</i> salah.  Dalam beberapa kasus, ketika mengakses <i>type.FullName</i> , pengecualian dapat terjadi.  Saya akan menggunakan tanda kurung untuk memperjelas (mereka tidak akan mengubah perilaku): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Menurut operasi yang diutamakan, kode akan bekerja persis seperti ini.  Jika variabel <i>tipe</i> adalah <i>nol</i> , kita akan jatuh ke cek lain, di mana kita akan menggunakan referensi <i>tipe</i> nol, setelah memeriksa variabel <i>targetTypeName</i> untuk <i>null</i> .  Kode mungkin diperbaiki, misalnya, sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Saya pikir, itu sudah cukup untuk meninjau kesalahan V3080.  Sekarang saatnya untuk melihat hal-hal menarik lainnya yang berhasil ditemukan oleh alat analisa PVS-Studio. <br><br>  <b>Salah ketik</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3005 Variabel</a> 'SourceCodeKind' ditugaskan untuk dirinya sendiri.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Karena kegagalan penamaan variabel, kesalahan ketik dibuat di konstruktor kelas <i>DynamicFileInfo</i> .  Bidang <i>SourceCodeKind</i> diberi nilainya sendiri alih-alih menggunakan parameter <i>sourceCodeKind</i> .  Untuk meminimalkan kemungkinan kesalahan tersebut, kami sarankan Anda menggunakan awalan garis bawah ke nama parameter dalam kasus tersebut.  Berikut adalah contoh versi kode yang diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Ketidaksengajaan</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3006</a> Objek telah dibuat tetapi tidak sedang digunakan.  Kata kunci 'melempar' bisa hilang: lempar InvalidOperationException (FOO) baru.  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Di bawah kondisi tertentu, destructor harus melempar eksepsi, tetapi itu tidak terjadi ketika objek eksepsi hanya dibuat.  Kata kunci <i>lemparan</i> tidak terjawab.  Ini adalah versi kode yang diperbaiki: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Masalah dengan destruktor di C # dan melemparkan pengecualian dari mereka adalah topik untuk diskusi lain, yang berada di luar cakupan artikel ini. <br><br>  <b>Ketika hasilnya tidak penting</b> <br><br>  Metode, yang menerima nilai yang sama dalam semua kasus, memicu sejumlah peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009</a> .  Dalam beberapa kasus bisa jadi tidak kritis atau nilai kembaliannya tidak dicentang dalam kode panggilan.  Saya melewatkan peringatan seperti itu.  Tetapi beberapa cuplikan kode tampak mencurigakan.  Ini salah satunya: <br><br>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Metode <i>TryExecuteCommand</i> mengembalikan apa pun kecuali <i>benar</i> .  Dalam melakukannya, dalam kode panggilan nilai yang dikembalikan terlibat dalam beberapa pemeriksaan. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Sulit untuk mengatakan dengan tepat sejauh mana perilaku seperti itu berbahaya.  Tetapi jika hasilnya tidak diperlukan, mungkin jenis nilai kembali harus diubah menjadi batal dan orang harus mengedit kecil dalam metode panggilan.  Ini akan membuat kode lebih mudah dibaca dan aman. <br><br>  Peringatan penganalisa serupa: <br><br><ul><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  JsonRpcClient.cs 138 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama 'salah'.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  ObjectList.cs 173 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  ObjectList.cs 249 </li></ul><br>  <b>Memeriksa hal yang salah</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3019</a> Mungkin variabel yang salah dibandingkan dengan nol setelah konversi jenis menggunakan kata kunci 'sebagai'.  Periksa variabel 'nilai', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  Variabel <i>nilai</i> dilemparkan ke tipe <i>NamingStylePreferences</i> .  Masalahnya ada di cek yang mengikuti ini.  Bahkan jika variabel <i>nilai</i> bukan nol, itu tidak menjamin bahwa casting tipe berhasil dan <i>valueToSerialize</i> tidak mengandung <i>nol</i> .  Kemungkinan melempar pengecualian <i>NullReferenceException</i> .  Kode perlu diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Bug serupa lainnya: <br><br>  V3019 Mungkin variabel yang salah dibandingkan dengan nol setelah konversi jenis menggunakan kata kunci 'sebagai'.  Periksa variabel 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  Variabel <i>columnState</i> dilemparkan ke jenis <i>ColumnState2</i> .  Namun, hasil operasi, yang merupakan variabel <i>columnState2,</i> tidak diperiksa untuk <i>nol</i> lebih lanjut.  Sebagai gantinya, variabel <i>columnState</i> diperiksa menggunakan operator <i>null</i> bersyarat.  Mengapa kode ini berbahaya?  Sama seperti pada contoh sebelumnya, casting dengan operator <i>as</i> mungkin gagal dan variabel akan menjadi <i>nol</i> yang akan menghasilkan pengecualian.  Ngomong-ngomong, kesalahan ketik bisa disalahkan di sini.  Lihatlah kondisi di blok <i>if</i> . <br><br>  Mungkin, bukannya <i>columnState? .Nama</i> penulis ingin menulis <i>columnState2? .Name</i> .  Sangat mungkin, mengingat nama variabel yang agak salah, <i>columnState</i> dan <i>columnState2.</i> <br><br>  <b>Cek berlebihan</b> <br><br>  Cukup banyak peringatan (lebih dari 100) dikeluarkan pada konstruksi yang tidak kritis, tetapi berpotensi tidak aman terkait dengan cek yang berlebihan.  Misalnya, ini salah satunya. <br><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3022</a> 'navInfo == null' selalu salah.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Mungkin tidak ada bug yang sebenarnya di sini.  Itu hanya alasan yang bagus untuk menunjukkan "analisis antar-proses + analisis aliran data" yang bekerja dengan baik.  Alat analisis menyarankan cek kedua <i>navInfo == null</i> berlebihan.  Memang, sebelum itu nilai yang ditetapkan untuk <i>navInfo</i> akan diperoleh dari metode <i>libraryService.NavInfoFactory.CreateForProject</i> , yang akan membangun dan mengembalikan objek baru dari kelas <i>NavInfo</i> .  Tidak mungkin itu akan mengembalikan <i>nol</i> .  Di sini muncul pertanyaan, mengapa analis tidak mengeluarkan peringatan untuk cek pertama <i>navInfo == null</i> ?  Ada beberapa alasan.  Pertama, jika variabel <i>simbol</i> <i>nol</i> , nilai <i>navInfo</i> akan tetap menjadi referensi nol juga.  Kedua, bahkan jika <i>navInfo</i> mendapatkan nilai dari metode <i>ibraryService.NavInfoFactory.CreateForSymbol</i> , nilai ini juga bisa menjadi <i>nol</i> .  Jadi, pemeriksaan pertama <i>navInfo == null</i> benar-benar diperlukan. <br><br>  <b>Cek tidak mencukupi</b> <br><br>  Sekarang situasi sebaliknya dari yang dibahas di atas.  Beberapa peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3042</a> dipicu untuk kode, di mana akses dengan referensi nol dimungkinkan.  Bahkan satu atau dua cek kecil bisa memperbaiki semuanya. <br><br>  Mari kita pertimbangkan fragmen kode lain yang menarik, yang memiliki dua kesalahan seperti itu. <br><br>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'penerima' Binder_Expressions.cs 7770 <br><br>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'penerima' Binder_Expressions.cs 7776 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  Variabel <i>penerima</i> mungkin nol.  Penulis kode mengetahui hal ini, karena ia menggunakan operator <i>null</i> bersyarat dalam kondisi blok <i>if</i> untuk mengakses <i>receiver ?</i> . <i>Sintaks</i> .  Selanjutnya variabel <i>penerima</i> digunakan tanpa pemeriksaan untuk mengakses <i>receiver. Jenis</i> , <i>penerima</i> . <i>Sintaks</i> dan <i>penerima</i> . <i>Memiliki Kesalahan</i> .  Kesalahan ini harus diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Kita juga harus memastikan bahwa konstruktor mendukung mendapatkan nilai <i>nol</i> untuk parameternya atau kita perlu melakukan refactoring tambahan. <br><br>  Kesalahan serupa lainnya: <br><br><ul><li>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'mengandungType' SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'ekspresi' ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'ekspresi' ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Kesalahan dalam kondisi</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3057</a> Fungsi 'Substring' dapat menerima nilai '-1' sementara nilai non-negatif diharapkan.  Periksa argumen kedua.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Dalam hal jika variabel <i>usus besar</i> adalah 0, yang baik-baik saja sesuai dengan kondisi dalam kode, metode <i>Substring</i> akan melempar pengecualian.  Ini harus diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Kemungkinan salah ketik</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3065</a> Parameter 't2' tidak digunakan di dalam tubuh metode.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Ekspresi lambda menerima dua parameter: t1 dan t2.  Namun, hanya t1 yang digunakan.  Itu terlihat mencurigakan, dengan mempertimbangkan fakta betapa mudahnya melakukan kesalahan ketika menggunakan variabel dengan nama-nama tersebut. <br><br>  <b>Ketidaksengajaan</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3083</a> Doa yang tidak aman dari acara 'TagsChanged', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Acara <i>TagsChanged</i> dipanggil dengan cara yang tidak aman.  Antara memeriksa <i>nol</i> dan menjalankan acara, seseorang dapat berhenti berlangganan darinya, maka pengecualian akan dilemparkan.  Selanjutnya, operasi lain dilakukan di tubuh blok <i>if</i> tepat sebelum memanggil acara.  Saya menyebut kesalahan ini "Kelalaian", karena acara ini ditangani lebih hati-hati di tempat lain, sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  Penggunaan variabel <i>penangan</i> tambahan mencegah masalah.  Dalam metode <i>OnTextBufferChanged,</i> kita harus mengedit agar dapat menangani acara dengan aman. <br><br>  <b>Rentang berpotongan</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3092</a> Range intersection dimungkinkan dalam ekspresi bersyarat.  Contoh: if (A&gt; 0 &amp;&amp; A &lt;5) {...} lain jika (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Untuk pemahaman yang lebih baik, izinkan saya menulis ulang kode ini, mengubah nama konstanta dengan nilai aktualnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Mungkin, tidak ada kesalahan nyata, tetapi kondisinya terlihat aneh.  Bagian kedua ( <i>selain itu</i> ) akan dieksekusi hanya untuk rentang dari 2147483648 +1 untuk 4294967295. <br><br>  Beberapa peringatan serupa lainnya: <br><br><ul><li>  V3092 Range intersection dimungkinkan dalam ekspresi bersyarat.  Contoh: if (A&gt; 0 &amp;&amp; A &lt;5) {...} lain jika (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Range intersection dimungkinkan dalam ekspresi bersyarat.  Contoh: if (A&gt; 0 &amp;&amp; A &lt;5) {...} lain jika (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>Lebih lanjut tentang cek nol (atau kurang dari itu)</b> <br><br>  Beberapa kesalahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3095</a> pada pemeriksaan variabel untuk null tepat setelah penggunaannya.  Yang pertama ambigu, mari kita pertimbangkan kodenya. <br><br>  V3095 Objek 'displayName' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Diasumsikan bahwa <i>displayName</i> referensi bisa nol.  Untuk ini, cek <i>Debug.Assert</i> dilakukan.  Tidak jelas mengapa ia pergi setelah menggunakan string.  Ini juga harus diperhitungkan bahwa untuk konfigurasi yang berbeda dari Debug, kompiler akan menghapus <i>Debug</i> <i>.</i> <i>Masukkan</i> sama sekali <i>.</i>  Apakah itu berarti mendapatkan referensi nol hanya mungkin untuk Debug?  Jika tidak demikian, mengapa penulis melakukan pemeriksaan <i>string. IsNullOrEmpty (string)</i> , misalnya.  Ini adalah pertanyaan untuk pembuat kode. <br><br>  Kesalahan berikut lebih jelas. <br><br>  V3095 Objek 'scriptArgsOpt' digunakan sebelum diverifikasi terhadap null.  Periksa baris: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Saya pikir kode ini tidak memerlukan penjelasan apa pun.  Biarkan saya memberi Anda versi tetap: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Dalam kode Roslyn, ada 15 kesalahan serupa lainnya: <br><br><ul><li>  V3095 Objek 'LocalFunctions' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 Objek 'resolution.OverloadResolutionResult' digunakan sebelum diverifikasi terhadap null.  Periksa baris: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 Objek 'resolution.MethodGroup' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 Objek 'touchFilesLogger' digunakan sebelum diverifikasi terhadap null.  Periksa baris: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 Objek 'newExceptionRegionsOpt' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 736, 743. AbstrakEditAndLanjutkanAnalyzer.cs 736 </li><li>  V3095 Objek 'simbol' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 Objek '_state.BaseTypeOrInterfaceOpt' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 Objek 'elemen' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 Objek 'bahasa' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 Objek 'memberType' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 Objek 'validTypeDeclarations' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 223, 228. SyntaxTreeExtensions.cs 223 </li><li>  V3095 Objek 'teks' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 376, 385. MSBuildWorkspace.cs 376 </li><li>  V3095 Objek 'nameOrMemberAccessExpression' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 206, 223. CSharpGenerateTypeService.cs 206 </li><li>  V3095 Objek 'simpleName' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 83, 85. CSharpGenerateMethodService.cs 83 </li><li>  V3095 Objek 'opsi' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 23, 28. OptionKey.cs 23 </li></ul><br>  Mari kita pertimbangkan kesalahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3105</a> .  Di sini operator <i>nol</i> bersyarat digunakan ketika menginisialisasi variabel, tetapi selanjutnya variabel digunakan tanpa memeriksa <i>nol</i> . <br><br>  Dua peringatan menunjukkan kesalahan berikut: <br><br>  V3105 Variabel 'documentId' digunakan setelah ditugaskan melalui operator kondisional nol.  NullReferenceException dimungkinkan.  CodeLensReferencesService.cs 138 <br><br>  V3105 Variabel 'documentId' digunakan setelah ditugaskan melalui operator kondisional nol.  NullReferenceException dimungkinkan.  CodeLensReferencesService.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br>  Variabel <i>documentId</i> dapat diinisialisasi dengan <i>nol</i> .  Akibatnya, membuat objek <i>ReferenceLocationDescriptor</i> akan menghasilkan melempar pengecualian.  Kode harus diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br>  Pengembang juga harus mencakup kemungkinan variabel, diteruskan ke konstruktor, menjadi <i>nol.</i> <br><br>  Kesalahan serupa lainnya dalam kode: <br><br><ul><li>  V3105 Variabel 'simbol' digunakan setelah ditugaskan melalui operator kondisional nol.  NullReferenceException dimungkinkan.  SymbolFinder_Hierarchy.cs 44 </li><li>  V3105 Variabel 'simbol' digunakan setelah ditugaskan melalui operator kondisional nol.  NullReferenceException dimungkinkan.  SymbolFinder_Hierarchy.cs 51 </li></ul><br>  <b>Prioritas dan tanda kurung</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3123</a> Mungkin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator</a> '?:' Bekerja dengan cara yang berbeda dari yang diharapkan.  Prioritasnya lebih rendah daripada prioritas operator lain dalam kondisinya.  Edit.cs 70 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br>  Kondisi di blok kembali dievaluasi bukan seperti yang dimaksudkan pengembang.  Diasumsikan bahwa kondisi pertama adalah <i>_kind == other._kin</i> d, (ini sebabnya setelah kondisi ini ada jeda baris), dan setelah itu blok kondisi dengan operator " <i>?</i> " Akan dievaluasi secara berurutan.  Faktanya, kondisi pertama adalah <i>_kind == other._kind &amp;&amp; (_oldNode == null)</i> .  Ini disebabkan oleh fakta bahwa operator <i>&amp;&amp;</i> memiliki prioritas lebih tinggi daripada operator " <i>?</i> ".  Untuk memperbaikinya, pengembang harus mengambil semua ekspresi operator " <i>?</i> " Dalam tanda kurung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br>  Itu menyimpulkan deskripsi saya tentang kesalahan yang ditemukan. <br><br>  <b>Kesimpulan</b> <br><br>  Terlepas dari sejumlah besar kesalahan, yang saya berhasil temukan, dalam hal ukuran kode proyek Roslyn (2.770.000 baris), itu tidak terlalu banyak.  Seperti yang ditulis Andrey dalam artikel sebelumnya, saya juga siap untuk mengakui kualitas tinggi dari proyek ini. <br><br>  Saya ingin mencatat bahwa pemeriksaan kode sesekali tidak ada hubungannya dengan metodologi analisis statis dan hampir tidak membantu.  Analisis statis harus diterapkan secara teratur, dan tidak berdasarkan kasus per kasus.  Dengan cara ini, banyak kesalahan akan diperbaiki pada tahap paling awal, dan karenanya biaya untuk memperbaikinya akan sepuluh kali lebih sedikit.  Gagasan ini dituangkan secara lebih rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan</a> kecil ini, silakan, periksa. <br><br>  Anda dapat memeriksa sendiri beberapa kesalahan di proyek ini dan di yang lain.  Untuk melakukan ini, Anda hanya perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh</a> dan mencoba penganalisa kami. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446588/">https://habr.com/ru/post/id446588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446572/index.html">Editor.js adalah editor yang sangat baik yang menyimpan kode sumber dalam format JSON</a></li>
<li><a href="../id446576/index.html">Mengganti impor, atau bagaimana Helikopter Rusia melakukan kesalahan</a></li>
<li><a href="../id446578/index.html">Bahasa pemrograman berbasis kartu pos</a></li>
<li><a href="../id446582/index.html">Refleksi tentang Hosting Surya untuk Lebah</a></li>
<li><a href="../id446586/index.html">Pengaturan Jaringan dari FreeRadius via DHCP</a></li>
<li><a href="../id446590/index.html">39 fitur baru akan tersedia di Java 12</a></li>
<li><a href="../id446592/index.html">Memeriksa kode sumber Roslyn</a></li>
<li><a href="../id446598/index.html">Menciptakan Font CRT</a></li>
<li><a href="../id446602/index.html">Maksimum Arus DC Melalui Transistor Efek Bidang</a></li>
<li><a href="../id446604/index.html">ESET: Skema Pengiriman Backdoor OceanLotus Cybergroup Baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>