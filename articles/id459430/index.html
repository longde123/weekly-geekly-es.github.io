<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 🔴 👨🏼 Aplikasi seluler dengan pembuatan formulir otomatis: kasus kami 🙌🏾 💆🏾 👎🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi seluler tidak selalu sederhana dan ringkas, karena kami pengembang menyukainya. Aplikasi lain dibuat untuk memecahkan masalah pengguna yang k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi seluler dengan pembuatan formulir otomatis: kasus kami</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/459430/">  Aplikasi seluler tidak selalu sederhana dan ringkas, karena kami pengembang menyukainya.  Aplikasi lain dibuat untuk memecahkan masalah pengguna yang kompleks dan mengandung banyak layar dan skrip.  Misalnya, aplikasi untuk melakukan tes, kuesioner, dan survei - di mana pun Anda perlu mengisi banyak formulir dalam proses.  Aplikasi ini akan dibahas dalam artikel ini. <br><br><img src="https://habrastorage.org/webt/qb/xy/ue/qbxyueqa7hvl4dy8wvzubhb5fxs.png"><br><br>  Kami mulai mengembangkan aplikasi mobile untuk agen yang terlibat dalam pendaftaran polis asuransi di tempat.  Mereka mengisi formulir besar dalam aplikasi dengan data pelanggan: informasi tentang mobil, pemilik, pengemudi, dll.  Meskipun setiap formulir memiliki bagian, sel, dan strukturnya sendiri, dan setiap item kuesioner membutuhkan tipe data unik (string, tanggal, dokumen terlampir), bentuk layarnya cukup mirip.  Tapi yang utama adalah jumlah mereka ... Tidak ada yang ingin terlibat dalam pengulangan visualisasi dan pemrosesan elemen yang sama berkali-kali. <br><br>  Untuk menghindari berjam-jam pekerjaan manual membuat formulir, Anda perlu menerapkan sedikit kecerdikan dan banyak konstruksi UI yang dinamis.  Dalam artikel ini, kami ingin membagikan bagaimana kami memecahkan masalah ini. <br><a name="habracut"></a><br>  Untuk solusi elegan untuk masalah ini, kami menggunakan mekanisme untuk menghasilkan objek - ViewModels, yang digunakan untuk membangun formulir kustom menggunakan tabel. <br><br><img src="https://habrastorage.org/webt/v3/s7/st/v3s7st-jaihcsxnxmybcn2n7gjw.png"><br><br>  Dalam pekerjaan normal, untuk setiap tabel individual yang ingin dilihat pengembang di layar, kelas ViewModel yang terpisah harus dibuat.  Ini mendefinisikan komponen visual dari tabel.  Kami memutuskan untuk naik satu tingkat lebih tinggi dan menghasilkan ViewModels dan Model sendiri secara dinamis, menggunakan deskripsi sederhana dari struktur melalui bidang Enum. <br><br><h3>  Bagaimana cara kerjanya </h3><br>  Semuanya dimulai dengan enum.  Untuk setiap profil kami membuat enum unik - ini adalah bagian dari profil kami.  Salah satu metodenya adalah mengembalikan array sel di bagian ini. <br><br>  Sel-sel dalam tabel juga akan enum dengan fungsi tambahan yang akan menjelaskan sifat-sifat sel.  Dalam fungsi seperti itu, kami menetapkan nama sel, nilai awal.  Kemudian ditambahkan parameter seperti <br><br><ul><li>  periksa tampilan: beberapa sel harus disembunyikan, </li><li>  daftar sel "induk": sel yang bergantung pada nilai, validasi, atau tampilan sel ini, </li><li>  tipe sel: sel-sel sederhana dengan nilai-nilai, sel-sel dalam saklar, sel-sel dengan fungsi menambahkan elemen, dll. </li></ul><br>  Kami berlangganan semua bagian ke protokol QuestionnaireSectionCellType umum untuk mengecualikan pengikatan ke bagian tertentu, kami akan melakukan hal yang sama dengan semua sel tabel (QuestionnaireCellType). <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuestionnaireSectionCellType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sectionCellTypes: [<span class="hljs-type"><span class="hljs-type">QuestionnaireCellType</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuestionnaireCellType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialValue: <span class="hljs-type"><span class="hljs-type">Any?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isHidden: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentFields: [<span class="hljs-type"><span class="hljs-type">QuestionnaireCellType</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } … }</code> </pre> <br>  Model seperti itu akan sangat mudah diisi.  Kami cukup menjalankan semua bagian, di setiap bagian kami menjalankan melalui array sel dan menambahkannya ke model array. <br><br>  Pada contoh layar pemegang polis (enum with section - InsurantSectionType): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InsurantModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuestionnaireCellType</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() initParameters() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initParameters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">InsurantSectionType</span></span>.allCases.forEach { type <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> type.sectionCellTypes.forEach { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> valueModel = <span class="hljs-type"><span class="hljs-type">ValueModel</span></span>(type: $<span class="hljs-number"><span class="hljs-number">0</span></span>, parentFields: $<span class="hljs-number"><span class="hljs-number">0</span></span>.parentFields, value: $<span class="hljs-number"><span class="hljs-number">0</span></span>.initialValue) { valueModels.append(valueModel) } } } } }</code> </pre> <br>  Selesai!  Sekarang kita memiliki tabel dengan nilai awal.  Tambahkan metode untuk membaca nilai dengan kunci QuestionnaireCellType dan menyimpannya ke elemen array yang diinginkan. <br><br>  Beberapa model mungkin memiliki bidang opsional, jadi kami menambahkan array dengan tombol opsional.  Selama validasi model, kunci-kunci ini mungkin tidak mengandung nilai, tetapi model itu akan dianggap diisi. <br><br>  Lebih lanjut, untuk kenyamanan, semua nilai dalam ValueModel kami berlangganan protokol StringRepresentable protokol umum untuk membatasi daftar nilai yang mungkin dan menambahkan metode untuk menampilkan nilai dalam sel. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRepresentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringValue: <span class="hljs-type"><span class="hljs-type">String?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br>  Fungsionalitas tumbuh, dan banyak properti dan metode lain muncul dalam model: membersihkan model (nilai awal harus ditetapkan dalam beberapa model), dukungan untuk array nilai dinamis (nilai: Array), dll. <br><br>  Pendekatan ini ternyata sangat nyaman untuk menyimpan dalam database menggunakan Realm.  Untuk mengisi kuesioner, dimungkinkan untuk memilih model yang sudah disimpan sebelumnya.  Untuk memperpanjang kebijakan CTP, agen tidak perlu lagi mengisi dokumen pengguna, driver yang dilampirkan olehnya, dan data TCP untuk yang baru.  Sebagai gantinya, Anda dapat menggunakannya kembali untuk mengisi yang sudah ada. <br><br>  Untuk mengubah atau menambah tabel, Anda hanya perlu menemukan ViewModel yang terkait dengan layar tertentu, menemukan enum yang diperlukan yang bertanggung jawab untuk menampilkan blok yang diinginkan dan menambahkan atau memperbaiki beberapa kasus.  Semuanya, tabel akan mengambil bentuk yang diperlukan! <br><br>  Mengisi formulir dengan nilai tes juga sangat mudah dan cepat.  Dengan cara ini Anda dapat dengan cepat menghasilkan data uji apa pun.  Dan jika Anda menambahkan file terpisah dengan data awal, dari mana program akan mengambil nilai ke setiap bidang spesifik dari kuesioner, maka bahkan seorang pemula dapat menghasilkan kuesioner yang sudah jadi tanpa pergi ke dan membongkar sisa kode, kecuali untuk file tertentu. <br><br><h3>  Ketergantungan </h3><br>  Tugas terpisah yang kami selesaikan selama proses pengembangan adalah penanganan ketergantungan.  Beberapa elemen kuesioner saling berhubungan.  Jadi, nomor dokumen tidak dapat diisi tanpa memilih jenis dokumen ini sendiri, nomor rumah tidak dapat ditunjukkan tanpa menunjukkan kota dan jalan, dll. <br><br><img src="https://habrastorage.org/webt/oc/vi/hb/ocvihbnjpzq20kwxwgmoarphdy4.png"><br><br>  Kami membuat pembaruan nilai-nilai kuesioner dengan membersihkan semua bidang dependen (misalnya, menghapus atau mengubah jenis dokumen, kami menghapus bidang "nomor dokumen"): <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateValueModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: StringRepresentable?, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type: QuestionnaireCellType)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> model = valueModels.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span>.type.<span class="hljs-built_in"><span class="hljs-built_in">equal</span></span>(to: type) }) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } model.value = value clearRelativeValues(type: type) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearRelativeValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: QuestionnaireCellType)</span></span></span></span> { <span class="hljs-number"><span class="hljs-number">_</span></span> = valueModels.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.parentFields.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">equal</span></span>(to: type) }) } .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.type } .compactMap { updateValueModel(value: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre><br><h3>  Perangkap yang harus kami pecahkan selama pengembangan, dan bagaimana kami mengelola </h3><br>  Jelas bahwa metode ini nyaman untuk layar dengan fungsi yang sama (mengisi kolom), tetapi tidak begitu nyaman jika elemen atau fungsi unik muncul di satu layar terpisah yang tidak ada di layar lain.  Dalam aplikasi kami, ini adalah: <br><br><ul><li>  Layar dengan tenaga mesin, yang harus dihasilkan secara terpisah, itulah sebabnya mengapa fungsinya berbeda.  Pada layar ini, permintaan akan hilang dan nilai dari server secara otomatis diganti.  Saya harus secara terpisah membuat kelas untuk itu yang akan bertanggung jawab untuk menampilkan, memuat, memvalidasi, memuat dari server dan mengganti nilai dalam bidang kosong, tanpa mengganggu pengguna jika yang terakhir memutuskan untuk memasukkan nilainya sendiri. </li><li>  Layar nomor registrasi, di mana satu-satunya adalah sakelar, yang memengaruhi tampilan atau menyembunyikan bidang teks.  Untuk kasus ini, kondisi tambahan harus dibuat, yang secara terprogram akan menentukan kasus dengan posisi sakelar aktif sebagai nilai kosong. </li><li>  Daftar dinamis, seperti daftar driver yang harus disimpan dan diikat ke formulir, yang juga keluar dari konsep. </li><li>  Jenis validasi data yang unik.  Bisa jadi banyak topeng yang dicampur dengan regex'ami.  Dan validasi tanggal untuk berbagai bidang, di mana validasi berbeda secara dramatis (pembatasan nilai minimum / maksimum), dll. </li><li>  Layar entri data dibuat sebagai sel collectionView.  (Itu diperlukan oleh desain!) Karena itu, menampilkan modal windows memerlukan kontrol yang tepat atas indeks yang dipilih.  Saya harus memeriksa bidang yang tersedia untuk diisi, dan mengecualikan dari daftar yang tidak boleh dilihat pengguna. </li><li>  Untuk menampilkan data dalam tabel dengan benar, perlu dilakukan perubahan pada metode model beberapa layar.  Sel-sel seperti nama dan alamat ditampilkan dalam tabel sebagai elemen tunggal, tetapi membutuhkan beberapa layar pop-up untuk diisi penuh. </li></ul><br><h3>  Kesimpulan </h3><br>  Pengalaman ini memungkinkan kami di True Engineering dengan cepat mengimplementasikan aplikasi seluler yang mudah dirawat.  Keserbagunaan memungkinkan Anda untuk secara cepat menghasilkan tabel dengan berbagai jenis data input: kami membuat 20 jendela hanya dalam seminggu.  Pendekatan ini juga mempercepat proses pengujian aplikasi.  Dalam waktu dekat, kami akan menggunakan kembali pabrik yang sudah jadi untuk dengan cepat menghasilkan tabel baru dan fungsionalitas baru. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459430/">https://habr.com/ru/post/id459430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459416/index.html">Menulis API untuk Komponen Bereaksi, Bagian 5: Cukup Gunakan Komposisi</a></li>
<li><a href="../id459420/index.html">Penggaruk paling umum saat menggunakan printf dalam program untuk mikrokontroler</a></li>
<li><a href="../id459422/index.html">Kami menulis API untuk komponen Bereaksi, bagian 6: kami membuat komunikasi antar komponen</a></li>
<li><a href="../id459426/index.html">Bagaimana desain Yandex.Avto dibuat</a></li>
<li><a href="../id459428/index.html">Intel Quartus Prime - semua yang Anda butuhkan untuk bekerja dengan Intel FPGA</a></li>
<li><a href="../id459432/index.html">RD-180: bisakah AS membuat mesin roket?</a></li>
<li><a href="../id459434/index.html">React Hook Router Alternatif Modern React Router</a></li>
<li><a href="../id459438/index.html">Data masih lebih penting</a></li>
<li><a href="../id459442/index.html">5 sistem manajemen acara keamanan sumber terbuka</a></li>
<li><a href="../id459444/index.html">Perubahan terbaru dalam Linux IO stack dari sudut pandang DBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>