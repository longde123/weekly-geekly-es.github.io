<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§§ üéÖüèΩ üë∂üèø Pil√£o de dentro para fora. Como ele faz isso üïØÔ∏è üê§ üî©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="V√°rios ajudantes na escrita de c√≥digos legais nos cercam, linter, typekchera, utilit√°rio para encontrar vulnerabilidades, todos conosco. Estamos acost...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pil√£o de dentro para fora. Como ele faz isso</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433474/">  V√°rios ajudantes na escrita de c√≥digos legais nos cercam, linter, typekchera, utilit√°rio para encontrar vulnerabilidades, todos conosco.  Estamos acostumados a us√°-lo sem entrar em detalhes como uma "caixa preta".  Por exemplo, poucas pessoas entendem os princ√≠pios do Pylint, uma dessas ferramentas indispens√°veis ‚Äã‚Äãpara otimizar e melhorar o c√≥digo Python. <br><br>  Mas <strong>Maxim Mazaev</strong> sabe o quanto √© importante entender suas ferramentas e ele nos disse no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Moscow Python Conf ++</a> .  Usando exemplos da vida real, ele mostrou como o conhecimento do dispositivo interno da Pylint e de seus plug-ins ajudou a reduzir o tempo de revis√£o do c√≥digo, melhorar a qualidade do c√≥digo e, geralmente, melhorar a efici√™ncia do desenvolvimento.  Abaixo est√° uma instru√ß√£o de descriptografia. <br><br><img src="https://habrastorage.org/webt/4d/mv/i7/4dmvi7slkt32taha4ec14e8kdfg.jpeg"><br><a name="habracut"></a><br><h2>  Por que precisamos do Pylint? <br></h2><br>  Se voc√™ j√° o usa, pode surgir a pergunta: "Por que saber o que h√° dentro do Pylint, como esse conhecimento pode ajudar?" <br><br>  Normalmente, os desenvolvedores escrevem c√≥digo, iniciam o linter, recebem mensagens sobre o que melhorar, como tornar o c√≥digo mais bonito e fazer as altera√ß√µes propostas.  Agora o c√≥digo √© mais f√°cil de ler e n√£o tem vergonha de mostrar aos colegas. <br><br>  Por um longo tempo, eles trabalharam exatamente da mesma maneira com Pylint no Cyan Institute, com pequenas adi√ß√µes: eles mudaram configura√ß√µes, removeram regras desnecess√°rias e aumentaram o comprimento m√°ximo da string. <br><br>  Mas em algum momento eles se depararam com um problema, pelo qual eu tive que me aprofundar no Pylint e descobrir como ele funciona.  Qual √© esse problema e como resolv√™-lo, continue lendo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZKoBZkdYLiM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre o palestrante:</strong> Maxim Mazaev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">barra invertida</a> ), 5 anos em desenvolvimento, trabalha no CIAN.  Aprende profundamente Python, assincronia e programa√ß√£o funcional. <br><br><h2>  Sobre cyan <br></h2><br>  Muitos acreditam que o CIAN √© uma ag√™ncia imobili√°ria com corretores de im√≥veis e ficam muito surpresos ao descobrir que, em vez de corretores, temos programadores. <br><br>  Somos uma empresa t√©cnica na qual n√£o existem corretores de im√≥veis, mas existem muitos programadores. <br><br><ul><li>  1 milh√£o de usu√°rios √∫nicos por dia. </li><li>  O maior quadro de avisos para a venda e aluguel de im√≥veis em Moscou e S√£o Petersburgo.  Em 2018, eles entraram no n√≠vel federal e trabalham em toda a R√∫ssia. </li><li>  Quase 100 pessoas na equipe de desenvolvimento, das quais 30 escrevem c√≥digo Python diariamente. </li></ul><br>  Todos os dias, centenas e milhares de linhas de novo c√≥digo entram em produ√ß√£o.  Os requisitos para o c√≥digo s√£o bem simples: <br><br><ul><li>  C√≥digo de qualidade decente. </li><li>  Homogeneidade estil√≠stica.  Todos os desenvolvedores devem escrever c√≥digo aproximadamente semelhante, sem "vinagrete" nos reposit√≥rios. </li></ul><br>  Para conseguir isso, √© claro, voc√™ precisa de uma revis√£o de c√≥digo. <br><br><h2>  Revis√£o de c√≥digo <br></h2><br>  A revis√£o de c√≥digo no CIAN ocorre em dois est√°gios: <br><br><ol><li>  O primeiro est√°gio √© <strong>automatizado</strong> .  O rob√¥ Jenkins executa testes, executa Pylint e verifica a consist√™ncia da API entre microsservi√ßos, uma vez que usamos microsservi√ßos.  Se, nesse est√°gio, os testes falharem ou o linter mostrar algo estranho, ser√° uma ocasi√£o para rejeitar a solicita√ß√£o de recebimento e enviar o c√≥digo para revis√£o. <br></li><li>  Se o primeiro est√°gio foi bem-sucedido, o segundo vem - a aprova√ß√£o de <strong>dois</strong> <strong>desenvolvedores</strong> .  Eles podem avaliar a qualidade do c√≥digo em termos de l√≥gica de neg√≥cios, aprovar uma solicita√ß√£o pull ou retornar o c√≥digo para revis√£o. <br></li></ol><br><h3><br>  Problemas de revis√£o de c√≥digo <br></h3><br>  A solicita√ß√£o de recebimento pode n√£o passar na revis√£o do c√≥digo devido a: <br><br><ul><li>  erros na l√≥gica de neg√≥cios quando um desenvolvedor resolveu um problema de maneira ineficaz ou incorreta; </li><li>  problemas de estilo de c√≥digo. </li></ul><br>  Quais poderiam ser os problemas de estilo se o linter verifica o c√≥digo? <br><br>  Todo mundo que escreve em Python sabe que existe um guia para escrever c√≥digo <strong>PEP-8</strong> .  Como qualquer padr√£o, o PEP-8 √© bastante geral e, para n√≥s, como desenvolvedores, isso n√£o √© suficiente.  Quero especificar o padr√£o em alguns lugares e expandir em outros. <br><br>  Portanto, criamos nossos arranjos internos sobre a apar√™ncia e o funcionamento do c√≥digo e os chamamos de <strong>"Recusar propostas Cian"</strong> . <br><br><img src="https://habrastorage.org/webt/u8/rk/tw/u8rktwmht5bmkqktwuoof_kbohs.png"><br><br>  ‚ÄúRecusar propostas Cian‚Äù - um conjunto de regras, agora existem cerca de 15. Cada uma dessas regras √© a base para que a solicita√ß√£o de recebimento seja rejeitada e enviada para revis√£o. <br><br><h3>  O que dificulta uma revis√£o produtiva do c√≥digo? <br></h3><br><blockquote>  H√° um problema com nossas regras internas - o linter n√£o sabe sobre elas, e seria estranho se ele soubesse - elas s√£o internas. <br></blockquote>  O desenvolvedor que executa a tarefa deve sempre lembrar e manter as regras em mente.  Se ele esquecer uma das regras, no processo de revis√£o de c√≥digo os revisores apontar√£o o problema, a tarefa passar√° por revis√£o e o tempo de libera√ß√£o da tarefa aumentar√°.  Ap√≥s a conclus√£o e a corre√ß√£o dos erros, os testadores precisam lembrar o que estava na tarefa, para mudar o contexto. <br><br>  Isso cria um problema para o desenvolvedor e os revisores.  Como resultado, a velocidade da revis√£o de c√≥digo √© reduzida drasticamente.  Em vez de analisar a l√≥gica do c√≥digo, os testadores come√ßam a analisar o estilo visual, ou seja, realizam o trabalho do linter: digitalizam o c√≥digo linha por linha e procuram inconsist√™ncias na indenta√ß√£o no formato de importa√ß√£o. <br><br>  Gostar√≠amos de nos livrar desse problema. <br><br><h2>  Mas n√£o nos escreva seu linter? <br></h2><br>  Parece que o problema ser√° resolvido por uma ferramenta que conhecer√° todos os acordos internos e poder√° verificar o c√≥digo para sua implementa√ß√£o.  Ent√£o, precisamos do nosso pr√≥prio linter? <br><br>  Na verdade n√£o.  A ideia √© est√∫pida, porque j√° usamos o Pylint.  Este √© um interface conveniente, apreciado pelos desenvolvedores e incorporado em todos os processos: √© executado no Jenkins, gera relat√≥rios bonitos que s√£o completamente satisfeitos e v√™m na forma de coment√°rios na solicita√ß√£o pull.  Est√° tudo bem, <strong>n√£o √© necess√°rio</strong> um <strong>segundo ponteiro</strong> . <br><br>  Ent√£o, como resolver o problema se n√£o queremos escrever nosso pr√≥prio linter? <br><br><h2>  Escreva um plug-in Pylint <br></h2><br>  Voc√™ pode escrever plugins para o Pylint, eles s√£o chamados de damas.  Sob cada regra interna, voc√™ pode escrever seu pr√≥prio verificador, que ser√° verificado. <br><br>  Considere dois exemplos de tais damas. <br><br><h3>  Exemplo No. 1 <br></h3><br>  Em algum momento, verificou-se que o c√≥digo cont√©m muitos coment√°rios no formato ‚ÄúTODO‚Äù - promete refatorar, excluir c√≥digo desnecess√°rio ou reescrev√™-lo lindamente, mas n√£o agora, mas mais tarde.  H√° um problema com esses coment√°rios - eles absolutamente n√£o o obrigam a nada. <br><br><h4>  O problema <br></h4><br>  O desenvolvedor escreveu uma promessa, exalou e ficou tranq√ºilo para executar a pr√≥xima tarefa. <br><img src="https://habrastorage.org/webt/ji/fk/js/jifkjskaly04vj5ljo74qrb0ys8.png"><br><br>  Em resumo: <br><br><ul><li>  coment√°rios com promessas s√£o suspensos ao longo dos anos e n√£o s√£o seguidos; </li><li>  c√≥digo est√° cheio; </li><li>  a d√≠vida t√©cnica vem se acumulando h√° anos. </li></ul><br>  Por exemplo, um desenvolvedor h√° 3 anos prometeu remover algo ap√≥s um lan√ßamento bem-sucedido, mas o lan√ßamento aconteceu em 3 anos?  Talvez sim.  Devo excluir o c√≥digo neste caso?  Esta √© uma grande quest√£o, mas provavelmente n√£o. <br><br><h4>  Solu√ß√£o: escreva seu verificador para a Pylint <br></h4><br>  Voc√™ n√£o pode proibir os desenvolvedores de escrever esses coment√°rios, mas pode faz√™-los fazer um trabalho extra: crie uma tarefa no rastreador para finalizar a promessa.  Ent√£o definitivamente n√£o vamos esquec√™-la. <br><br>  Precisamos encontrar todos os coment√°rios do formul√°rio TODO e garantir que cada um deles tenha um link para uma tarefa no Jira.  Vamos escrever <br><br>  O que √© um verificador em termos de Pylint?  Esta √© uma classe que herda da classe base do verificador e implementa uma certa interface. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoIssueChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> _ _implements_ _ = IRawChecker</code> </pre> <br>  No nosso caso, este √© o <strong>IRawChecker</strong> - o chamado verificador "bruto". <br><br>  Um verificador bruto itera sobre as linhas de um arquivo e pode executar uma determinada a√ß√£o em uma linha.  No nosso caso, em cada linha, o verificador procurar√° algo semelhante a um coment√°rio e um link para uma tarefa. <br><br>  Para o verificador, voc√™ precisa determinar a lista de mensagens que ele emitir√°: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9999'</span></span>: (<span class="hljs-string"><span class="hljs-string">'  TODO    '</span></span>, issue-code-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-todo<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  A mensagem tem: <br><br><ul><li>  a descri√ß√£o √© curta e longa; </li><li>  c√≥digo do verificador e um nome mnem√¥nico curto que determina que tipo de mensagem √©. </li></ul><br>  O c√≥digo da mensagem tem o formato "C1234", no qual: <br><br><ul><li>  A primeira letra √© claramente padronizada para diferentes tipos de mensagens: <strong>[C]</strong> onvention;  <strong>[W]</strong> arning;  <strong>[E]</strong> yog;  <strong>[F]</strong> atal;  <strong>[R]</strong> efactoring.  Gra√ßas √† carta, o relat√≥rio mostra imediatamente o que est√° acontecendo: um lembrete dos acordos ou problemas fatais que precisam ser abordados com urg√™ncia. </li><li>  4 n√∫meros aleat√≥rios exclusivos do Pylint. </li></ul><br>  O c√≥digo √© necess√°rio para desativar a verifica√ß√£o se for desnecess√°ria.  Voc√™ pode escrever Pylint: disable e um c√≥digo alfanum√©rico curto ou nome mnem√¥nico: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Pylint: disable=C9999 # Pylint: disable=issue-code-in-todo</span></span></code> </pre><br>  Os autores do Pylint recomendam abandonar o c√≥digo alfanum√©rico e usar o mnem√¥nico, √© mais visual. <br><br>  O pr√≥ximo passo √© definir um m√©todo chamado <strong>process_module</strong> . <br><br><img src="https://habrastorage.org/webt/25/cg/lc/25cglcdvsxu5qwgwv6fwhmhuvyu.jpeg"><br><br>  O nome √© muito importante.  O m√©todo deve ser chamado dessa maneira, porque o Pylint o chamar√°. <br><br>  O par√¢metro do <strong>n√≥</strong> √© passado para o m√≥dulo.  Nesse caso, n√£o importa o que √© ou o tipo, √© importante lembrar que o n√≥ possui um m√©todo de <strong>fluxo</strong> que retorna um arquivo linha por linha. <br><br>  Voc√™ pode percorrer o arquivo e, para cada linha, verificar coment√°rios e links para a tarefa.  Se houver um coment√°rio, mas nenhum link, <strong>emita</strong> um aviso no formul√°rio <strong>'emitir c√≥digo-em-todo'</strong> com o c√≥digo do verificador e o n√∫mero da linha.  O algoritmo √© bastante simples. <br><br>  Registre o verificador para que o Pylint saiba sobre ele.  Isso √© feito pela fun√ß√£o de <strong>registro</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter. register_checker ( TodoIssueChecker(linter) )</code> </pre><br><ul><li>  Uma inst√¢ncia do Pylint entra na fun√ß√£o. </li><li>  Ele chama o m√©todo register_checker. </li><li>  Passamos o verificador para o m√©todo </li></ul><br>  <strong>Um ponto importante: o</strong> m√≥dulo verificador deve estar no PYTHONPATH para que o Pylint possa import√°-lo mais tarde. <br><br>  Um verificador registrado √© verificado por um arquivo de teste com coment√°rios sem links para tarefas. <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work. --load-plugins todo_checker ‚Ä¶</span></span></code> </pre><br>  Para o teste, execute o Pylint, passe o m√≥dulo para ele, use o par√¢metro <strong>load-plugins</strong> para passar no verificador e, dentro do linter, execute duas fases. <br><br><h4>  Fase 1. Inicializa√ß√£o do Plugin <br></h4><br><ul><li>  Todos os m√≥dulos com plugins s√£o importados.  O Pylint possui verificadores internos e externos.  Todos eles se re√∫nem e s√£o importados. </li><li>  N√≥s registramos - <strong>module.register (self)</strong> .  Para cada verificador, a fun√ß√£o de registro √© chamada, onde a inst√¢ncia do Pylint √© passada. </li><li>  As verifica√ß√µes s√£o realizadas: para a validade dos par√¢metros, para a presen√ßa de mensagens, op√ß√µes e relat√≥rios no formato correto. </li></ul><br><h4>  Fase 2. Analisar o conjunto de damas <br></h4><br>  Ap√≥s a fase 1, permanece uma lista completa de diferentes tipos de damas: <br><br><ul><li>  Verificador AST; </li><li>  Verificador bruto; </li><li>  Verificador de token. </li></ul><br><img src="https://habrastorage.org/webt/iy/o-/e9/iyo-e93tezy3y4iczp5d8regoog.jpeg"><br><br>  Na lista, selecionamos aqueles relacionados √† interface bruta do verificador: verificamos quais verificadores implementam a interface IRawChecker e os tomamos por conta pr√≥pria. <br><br>  Para cada verificador selecionado, chame o <strong>m√©todo checker.process_module (module)</strong> e execute a verifica√ß√£o. <br><br><h4>  Resultado <br></h4><br>  Execute o verificador no arquivo de teste novamente: <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work,  --load-plugins todo_checker : 0,0:   T0D0     (issue-code-in-todo)</span></span></code> </pre><br>  Aparecer√° uma mensagem informando que h√° um coment√°rio com TODO e nenhum link para a tarefa. <br><br>  O problema foi resolvido e, agora, no processo de revis√£o do c√≥digo, os desenvolvedores n√£o precisam escanear o c√≥digo com os olhos, encontrar coment√°rios, escrever um lembrete ao autor do c√≥digo de que existe um acordo e √© recomend√°vel deixar um link.  Tudo acontece automaticamente e a revis√£o do c√≥digo √© um pouco mais r√°pida. <br><br><h3>  Exemplo No. 2. argumentos-chave <br></h3><br>  Existem fun√ß√µes que aceitam argumentos posicionais.  Se houver muitos argumentos, quando eles chamam a fun√ß√£o, n√£o est√° muito claro onde est√° o argumento e por que ele √© necess√°rio. <br><br><h4>  O problema <br></h4><br>  Por exemplo, temos uma fun√ß√£o: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, rue, <span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  O c√≥digo tem <strong>venda</strong> e <strong>True,</strong> e n√£o est√° claro o que eles significam.  √â muito mais conveniente quando fun√ß√µes nas quais existem muitos argumentos seriam chamadas apenas com argumentos nomeados: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, truncate=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, cian_id=<span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  Este √© um bom c√≥digo, no qual fica imediatamente claro onde est√° o par√¢metro e n√£o confundiremos sua sequ√™ncia.  Vamos tentar escrever um verificador que verifique esses casos. <br><br>  O verificador "bruto" usado no exemplo anterior √© muito dif√≠cil de escrever para esse caso.  Voc√™ pode adicionar express√µes regulares super complexas, mas esse c√≥digo √© dif√≠cil de ler.  √â bom que o Pylint permita escrever outro tipo de verificador com base na √°rvore de sintaxe abstrata do <strong>AST</strong> , e n√≥s o usaremos. <br><br><h4>  Letras sobre AST <br></h4><br>  Uma √°rvore de sintaxe AST ou abstrata √© uma representa√ß√£o em √°rvore do c√≥digo, onde o v√©rtice s√£o os operandos e as folhas s√£o operadores. <br><br>  Por exemplo, uma chamada de fun√ß√£o, onde h√° um argumento posicional e dois argumentos nomeados, √© transformada em uma √°rvore abstrata: <br><img src="https://habrastorage.org/webt/k3/zi/hu/k3zihuknbk9txzbwffdwcwr5gf4.jpeg"><br><br>  Existe um v√©rtice com o tipo <strong>Call</strong> e ele possui: <br><br><ul><li>  atributos de fun√ß√£o chamados func; </li><li>  uma lista de argumentos posicionais args, onde h√° um n√≥ com o tipo Const e um valor de 112; </li><li>  lista de argumentos nomeados Palavras-chave. </li></ul><br>  A tarefa neste caso: <br><br><ul><li>  Encontre no m√≥dulo todos os n√≥s com o tipo Chamada (chamada de fun√ß√£o). </li><li>  Calcule o n√∫mero total de argumentos que a fun√ß√£o leva. </li><li>  Se houver mais de 2 argumentos, verifique se n√£o h√° argumentos posicionais no n√≥. </li><li>  Se houver argumentos posicionais, mostre um aviso. </li></ul><br><br><pre> <code class="python hljs">ll( func=Name(name=<span class="hljs-string"><span class="hljs-string">'get_offer'</span></span>), args=[Const(value=<span class="hljs-number"><span class="hljs-number">1298880</span></span>)], keywords=[ ‚Ä¶ ]))]</code> </pre><br>  Do ponto de vista do Pylint, um verificador baseado em AST √© uma classe que herda da classe verificador base e implementa a interface <strong>IAstroidChecker</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonKeywordArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> -_ _implements_ _ = IAstroidChecker</code> </pre><br>  Como no primeiro exemplo, a descri√ß√£o do verificador, o c√≥digo da mensagem e o nome mnem√¥nico curto s√£o indicados na lista de mensagens: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9191'</span></span>: (<span class="hljs-string"><span class="hljs-string">' '</span></span>, keyword-only-args<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  A pr√≥xima etapa √© definir o m√©todo <strong>visit_call</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node: Call)</span></span></span><span class="hljs-function"> ‚Ä¶</span></span></code> </pre><br>  O m√©todo n√£o precisa ser chamado assim.  O mais importante √© o prefixo visit_, e depois vem o nome do v√©rtice que nos interessa, com uma pequena letra. <br><br><ul><li>  O analisador AST percorre a √°rvore e, para cada v√©rtice, verifica se a interface checkr visit_ &lt;Name&gt; est√° definida. </li><li>  Se sim, ent√£o chame. </li><li>  Recursivamente passa por todos os seus filhos. </li><li>  Ao sair de um n√≥, ele chama o m√©todo leave_ &lt;Name&gt;. </li></ul><br>  Neste exemplo, o m√©todo visit_call receber√° um n√≥ do tipo Call como uma entrada e ver√° se ele possui mais de dois argumentos e se argumentos posicionais est√£o presentes para emitir um aviso e passar o c√≥digo para o pr√≥prio n√≥. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.args <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.args + node.keywords) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: self.add_message( <span class="hljs-string"><span class="hljs-string">'keyword-only-args'</span></span>, node=node )</code> </pre><br>  Registramos o verificador, como no exemplo anterior: transferimos a inst√¢ncia do Pylint, chamamos register_checker, passando o pr√≥prio verificador e iniciando-o. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter.register_checker( TodoIssueChecker(linter) )</code> </pre><br>  Este √© um exemplo de uma chamada de fun√ß√£o de teste em que existem 3 argumentos e apenas um deles √© nomeado: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker ‚Ä¶</code> </pre><br>  Essa √© uma fun√ß√£o potencialmente chamada incorretamente do nosso ponto de vista.  Inicie o Pylint. <br><br>  A fase de inicializa√ß√£o do plug-in 1 √© completamente repetida, como no exemplo anterior. <br><br><h4>  Fase 2. M√≥dulo analisando na AST <br></h4><br>  O c√≥digo √© analisado em uma √°rvore AST.  A an√°lise √© realizada pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca Astroid</a> . <br><br><h4>  Por que Astroid, n√£o AST (stdlib) <br></h4><br>  O Astroid usa internamente n√£o o m√≥dulo AST padr√£o do Python, mas o <strong>analisador AST</strong> do tipo <strong>typed_ast</strong> , caracterizado por suportar as <strong>dicas do tipo</strong> PEP 484. <strong>Typed_ast</strong> √© um ramo do AST, um fork que se desenvolve em paralelo.  Curiosamente, existem os mesmos erros que est√£o no AST e s√£o reparados em paralelo. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Entity <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (Entity) -&gt; None return</span></span></code> </pre><br>  Anteriormente, o Astroid usava o m√≥dulo AST padr√£o, no qual era poss√≠vel encontrar o problema de usar as dicas definidas nos coment√°rios usados ‚Äã‚Äãno segundo Python.  Se voc√™ verificar esse c√≥digo atrav√©s do Pylint, at√© um certo ponto, ele juraria na importa√ß√£o n√£o utilizada, porque a classe Entity importada est√° presente apenas no coment√°rio. <br><br><blockquote>  Em algum momento, Guido Van Rossum chegou ao Astroid no GitHub e disse: ‚ÄúPessoal, voc√™ tem o Pylint, que jura nesses casos, e temos um analisador AST digitado que suporta tudo isso.  Vamos ser amigos! <br></blockquote><br>  O trabalho come√ßou a ferver!  Dois anos se passaram, nesta primavera, a Pylint mudou para um analisador AST digitado e parou de xingar essas coisas.  As importa√ß√µes de taiphints n√£o s√£o mais marcadas como n√£o utilizadas. <br><br>  O Astroid usa um analisador AST para analisar o c√≥digo em uma √°rvore e, em seguida, faz algumas coisas interessantes ao constru√≠-lo.  Por exemplo, se voc√™ usar <strong>import *</strong> , ele importa tudo com um asterisco e adiciona aos locais para evitar erros com importa√ß√µes n√£o utilizadas. <br><br>  <strong>Os plug-ins de transforma√ß√£o</strong> s√£o usados ‚Äã‚Äãnos casos em que existem alguns modelos complexos baseados em meta classes, quando todos os atributos s√£o gerados dinamicamente.  Nesse caso, o Astroid √© muito dif√≠cil de entender o que se entende.  Ao verificar, o Pylint jurar√° que os modelos n√£o t√™m esse atributo quando for acessado e, usando os plugins Transform, voc√™ pode resolver o problema: <br><br><ul><li>  Ajude o Astroid a modificar a √°rvore abstrata e entender a natureza din√¢mica do Python. </li><li>  Complemente o AST com informa√ß√µes √∫teis. </li></ul><br>  Um exemplo t√≠pico √© o <strong>pylint-django</strong> .  Ao trabalhar com modelos complexos de django, o linter geralmente jura por atributos desconhecidos.  O Pylint-django apenas resolve esse problema. <br><br><h4>  Fase 3. Analise o conjunto de damas <br></h4><br>  Voltamos ao verificador.  Novamente, temos uma lista de verificadores, a partir dos quais encontramos aqueles que implementam a interface do verificador AST. <br><br><h4>  Fase 4. Analisar verificadores por tipos de n√≥s <br></h4><br>  Em seguida, encontramos m√©todos para cada verificador, eles podem ser de dois tipos: <br><br><ul><li>  visit_ &lt;Nome do n√≥&gt; </li><li>  le√©v_ &lt;Nome do n√≥&gt;. </li></ul><br>  Seria bom saber quais n√≥s voc√™ precisa chamar para um n√≥ enquanto caminhava em uma √°rvore.  Portanto, eles entendem o dicion√°rio, onde a chave √© o nome do n√≥, o valor √© uma lista dos verificadores que est√£o interessados ‚Äã‚Äãno fato de acessar esse n√≥. <br><br><pre> <code class="python hljs">_visit_methods = dict( &lt; &gt; : [checker1, checker2 ... checkerN] )</code> </pre><br>  O mesmo com os m√©todos leave: uma chave na forma de um nome de n√≥, uma lista de verificadores que est√£o interessados ‚Äã‚Äãno fato de sair desse n√≥. <br><br><pre> <code class="python hljs">_leave_methods = dict( &lt; &gt;: [checker1, checker2 ... checkerN] )</code> </pre><br>  Inicie o Pylint.  Ele mostra um aviso de que temos uma fun√ß√£o em que h√° mais de dois argumentos e h√° um argumento posicional: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker C: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:  c &gt;<span class="hljs-number"><span class="hljs-number">2</span></span>      (keyword-only-args)</code> </pre><br>  O problema est√° resolvido.  Agora, os programadores de revis√£o de c√≥digo n√£o precisam ler os argumentos da fun√ß√£o; o linter far√° isso por eles.  <strong>Economizamos nosso tempo</strong> , tempo para revis√£o de c√≥digo e as tarefas s√£o mais r√°pidas na produ√ß√£o. <br><br><h2>  E para escrever testes? <br></h2><br>  O Pylint permite realizar testes de unidade de damas e √© muito simples.  Do ponto de vista do linter, o verificador de teste se parece com uma classe que herda do abstrato <strong>CheckerTestCase</strong> .  √â necess√°rio indicar o verificador que est√° sendo verificado nele. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonKwArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CheckerTestCase)</span></span></span><span class="hljs-class">:</span></span> CHECKER_CLASS = NonKeywordArgsChecker</code> </pre><br>  Etapa 1. Criamos um n√≥ AST de teste a partir da parte do c√≥digo que estamos verificando. <br><br><pre> <code class="python hljs">node = astroid.extract_node( <span class="hljs-string"><span class="hljs-string">"get_offers(3, 'magic', 'args')"</span></span> )</code> </pre><br>  Etapa 2. Verifique se o verificador, entrando no n√≥, lan√ßa ou n√£o lan√ßa a mensagem correspondente: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.assertAddsMessages(message): self.checker.visit_call(node)</code> </pre><br><h2>  Tokenchecker <br></h2><br>  H√° outro tipo de verificador chamado <strong>TokenChecker</strong> .  Ele trabalha com o princ√≠pio de um analisador lexical.  O Python possui um m√≥dulo de <strong>tokenize</strong> que faz o trabalho de um scanner lexical e divide o c√≥digo em uma lista de tokens.  Pode ser algo como isto: <br><img src="https://habrastorage.org/webt/ul/vj/bl/ulvjblhatvsted81sc1drmjn2io.png"><br><br>  Nomes de vari√°veis, nomes de fun√ß√µes e palavras-chave se tornam tokens do tipo NAME e delimitadores, colchetes e dois pontos se tornam tokens do tipo OP.  Al√©m disso, existem tokens separados para recuo, avan√ßo de linha e convers√£o reversa. <br><br>  Como o Pylint funciona com o TokenChecker: <br><br><ul><li>  O m√≥dulo em teste √© tokenizado. </li><li>  Uma lista enorme de tokens √© passada para todos os verificadores que implementam ITokenChecker e o m√©todo <strong>process_tokens</strong> (tokens) √© <strong>chamado</strong> . </li></ul><br>  N√£o encontramos o uso do TokenChecker, mas existem alguns exemplos que o Pylint usa: <br><br><ul><li>  <strong>Verifica√ß√£o ortogr√°fica</strong> .  Por exemplo, voc√™ pode pegar todos os tokens com o texto do tipo e examinar a alfabetiza√ß√£o lexical, verificar palavras nas listas de palavras de parada, etc. </li><li>  <strong>Verifique recuos</strong> , espa√ßos. </li><li>  <strong>Trabalhe com strings</strong> .  Por exemplo, voc√™ pode verificar se o Python 3 n√£o usa literais Unicode ou se apenas caracteres ASCI est√£o presentes na cadeia de bytes. </li></ul><br><h2>  Conclus√µes <br></h2><br>  Ocorreu um problema com a revis√£o de c√≥digo.  Os desenvolvedores executaram o trabalho do linter, gastaram seu tempo em varreduras in√∫teis de c√≥digo e informaram o autor sobre erros.  Com a Pylint, n√≥s: <br><br><ul><li>  Transferiu verifica√ß√µes de rotina para o linter, implementou acordos internos nele. </li><li>  Maior velocidade e revis√£o do c√≥digo de qualidade. </li><li>  Reduzido o n√∫mero de solicita√ß√µes de recebimento rejeitadas, e o tempo para passar tarefas na produ√ß√£o tornou-se menor. </li></ul><br>  Um simples verificador √© escrito em meia hora e outro complexo em poucas horas.  O verificador economiza muito mais tempo do que leva para escrever e luta por v√°rias solicita√ß√µes de recebimento n√£o rejeitadas. <br><br>  Voc√™ pode aprender mais sobre o Pylint e como escrever damas na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o oficial</a> , mas em termos de escrever damas √© bastante ruim.  Por exemplo, sobre o TokenChecker, h√° apenas uma men√ß√£o, mas n√£o sobre como escrever o pr√≥prio verificador.  Mais informa√ß√µes est√£o dispon√≠veis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nas fontes Pylint no GitHub</a> .  Voc√™ pode ver o que as damas est√£o no pacote padr√£o e se inspirar para escrever suas pr√≥prias. <br><br>  <em>O conhecimento do design interno da Pylint economiza horas de trabalho, simplifica</em> <em><br></em>  <em>desempenho e melhora o c√≥digo.</em>  <em>Economize seu tempo, escreva um bom c√≥digo e</em> <em><br></em>  <em>use linter.</em> <br><blockquote>  A pr√≥xima confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Moscow Python Conf ++</a> ser√° realizada <b>em 5 de abril de 2019</b> e voc√™ j√° pode reservar um ingresso antecipado de birf agora.  √â ainda melhor coletar suas opini√µes e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solicitar</a> um relat√≥rio, pois a visita ser√° gratuita e os p√£es agrad√°veis ‚Äã‚Äãser√£o um b√¥nus, incluindo treinamento na prepara√ß√£o do relat√≥rio. <br><br>  Nossa confer√™ncia √© uma plataforma para encontrar pessoas que pensam da mesma forma, mecanismos do setor, para comunicar e discutir o que os desenvolvedores de Python adoram: back-end e Web, coleta e processamento de dados, AI / ML, testes, IoT.  Como foi no outono, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">veja a reportagem</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deo</a> em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canal Python</a> e assine o canal - em breve publicaremos os melhores relat√≥rios da confer√™ncia para acesso gratuito. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433474/">https://habr.com/ru/post/pt433474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433450/index.html">Cres√ßa e ensine. Como fizemos amizade com o PEGA</a></li>
<li><a href="../pt433456/index.html">Como convencer um cliente ou empresa a usar o Flutter</a></li>
<li><a href="../pt433458/index.html">Alguns benef√≠cios n√£o √≥bvios do Serverless for DevOps</a></li>
<li><a href="../pt433462/index.html">Verifica√ß√µes de sa√∫de e degrada√ß√£o gradual de sistemas distribu√≠dos</a></li>
<li><a href="../pt433472/index.html">Lan√ßamento do Unity 2018.3</a></li>
<li><a href="../pt433476/index.html">50 tons de aipo</a></li>
<li><a href="../pt433478/index.html">Por que o Django √© escolhido na Revista Tinkoff</a></li>
<li><a href="../pt433480/index.html">Hist√≥ria de Holivarny sobre linter</a></li>
<li><a href="../pt433482/index.html">Django sob microsc√≥pio</a></li>
<li><a href="../pt433486/index.html">O que de novo? A recupera√ß√£o de cart√µes de d√©bito n√£o banc√°rios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>