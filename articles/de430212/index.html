<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§© üíº üëÇüèΩ OpenSceneGraph: Grundlagen der Szenengeometrie üë¶üèæ üôÑ üë®üèæ‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 OpenGL, das Backend f√ºr OpenSceneGraph, verwendet geometrische Grundelemente (wie Punkte, Linien, Dreiecke und polygonale Fl√§chen), um al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Grundlagen der Szenengeometrie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430212/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><br><h1>  Einf√ºhrung </h1><br>  OpenGL, das Backend f√ºr OpenSceneGraph, verwendet geometrische Grundelemente (wie Punkte, Linien, Dreiecke und polygonale Fl√§chen), um alle Objekte in der dreidimensionalen Welt zu konstruieren. <br><br>  Diese Grundelemente werden durch Daten √ºber ihre Scheitelpunkte definiert, einschlie√ülich der Koordinaten der Scheitelpunkte, Normalkomponenten, Farbdaten und Texturkoordinaten.  Diese Daten werden in speziellen Arrays gespeichert.  Grundelemente k√∂nnen beispielsweise gebildet werden, indem f√ºr die Objekte, die sie beschreiben, eine Liste von Scheitelpunktindizes angegeben wird.  Diese Methode wird als Vertex-Array-Methode bezeichnet. Sie eliminiert die Speicherung redundanter Vertices im Speicher und weist eine gute Leistung auf. <br><br>  Dar√ºber hinaus kann OpenGL den Mechanismus sogenannter <i>Anzeigelisten verwenden</i> , wenn im Videospeicher vorbereitete Grundelemente wiederverwendet werden k√∂nnen, was die Anzeige statischer Objekte erheblich beschleunigt. <br><br>  Standardm√§√üig verwendet OSG die Vertex-Array-Methode und die Anzeigelistenmethode, um die Geometrie zu rendern.  Die Rendering-Strategie kann jedoch abh√§ngig von der Darstellung der Geometriedaten ge√§ndert werden.  In diesem Artikel werden die grundlegenden Techniken f√ºr die Arbeit mit Geometrie in OSG behandelt. <br><a name="habracut"></a><br><h1>  1. Klassen Geode und Drawable </h1><br>  Die osg :: Geode-Klasse ist ein Terminal, der sogenannte "Blatt" -Knoten des Szenenbaums.  Es kann keine untergeordneten Knoten haben, enth√§lt jedoch alle erforderlichen Informationen zum Rendern der Geometrie.  Der Name Geode steht f√ºr Geometrieknoten. <br><br>  Die von der Engine zu verarbeitenden geometrischen Daten werden in der Gruppe von Objekten der Klasse osg :: Drawable gespeichert, die von der Klasse osg :: Geode verwaltet wird.  Die osg :: Drawable-Klasse ist eine rein virtuelle Klasse.  Eine Reihe von Unterklassen werden davon geerbt, n√§mlich dreidimensionale Modelle, Bilder und Text, die von der OpenGL-Pipeline verarbeitet werden.  OSG bezeichnet Drawable als alle Elemente, die von der Engine gezeichnet werden k√∂nnen. <br><br>  Die Klasse osg :: Geode bietet eine Reihe von Methoden zum Anh√§ngen und Trennen von Drawables: <br><br><ul><li>  √ñffentliche Methode addDrawable () - √úbergibt einen Zeiger auf ein zeichnbares Element in einer Instanz der Klasse osg :: Geode.  Alle diese Elemente werden von intelligenten Zeigern von osg :: ref_ptr &lt;&gt; gesteuert. <br></li><li>  Die √∂ffentlichen Methoden removeDrawable () und removeDrawables () entfernen das Objekt aus osg :: Geode und verringern die Referenzanzahl daf√ºr.  Die Methode removeDrawable () verwendet als einzelnen Parameter einen Zeiger auf das interessierende Element, und die Methode removeDrawables () verwendet zwei Parameter: den Anfangsindex und die Anzahl der Elemente, die aus dem Objektarray osg :: Geode entfernt werden sollen. <br></li><li>  Die Methode getDrawable () gibt einen Zeiger auf ein Element am Index zur√ºck, der als Parameter √ºbergeben wird. <br></li><li>  Die Methode getNumDrawables () gibt die Gesamtzahl der an osg :: Geode angeh√§ngten Elemente zur√ºck.  Um beispielsweise alle Elemente aus osg :: Geode zu entfernen, k√∂nnen Sie solchen Code verwenden <br></li></ul><br><pre><code class="cpp hljs">geode-&gt;removeDrawables(<span class="hljs-number"><span class="hljs-number">0</span></span>, geode-&gt;getNumDrawables());</code> </pre> <br><h1>  2. Einfache Formen zeichnen </h1><br>  OSG stellt die Klasse osg :: ShapeDrawable bereit, die der Nachkomme der Klasse osg :: Drawable ist und zum Erstellen einfacher dreidimensionaler Grundelemente entwickelt wurde.  Diese Klasse enth√§lt ein osg :: Shape-Objekt, in dem Informationen zu bestimmten Geometrien und anderen Parametern gespeichert sind.  Grundelemente werden beispielsweise mit der Methode setShape () generiert <br><br><pre> <code class="cpp hljs">shapeDrawable-&gt;setShape(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Box(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>));</code> </pre><br>  Erstellt eine rechteckige Box mit einem geometrischen Mittelpunkt am Punkt (1.0, 0.0, 0.0) mit einer Breite und H√∂he von 10 und einer Tiefe von 5 Einheiten.  Die Klasse osg :: Vec3 definiert einen Vektor im dreidimensionalen Raum (zus√§tzlich werden auch die Klassen osg :: Vec2 und osg :: Vec4 dargestellt, die Vektoren der entsprechenden Dimension beschreiben). <br><br>  Die beliebtesten Grundelemente werden in OSG durch die Klassen osg :: Box, osg :: Capsule, osg :: Cone, osg :: Cylinder und osg :: Sphere dargestellt. <br><br>  Betrachten Sie ein Beispiel f√ºr die Anwendung dieses Mechanismus. <br><br>  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ShapeDrawable&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ShapeDrawable&gt; shape1 = new osg::ShapeDrawable; shape1-&gt;setShape(new osg::Box(osg::Vec3(-3.0f, 0.0f, 0.0f), 2.0f, 2.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape2 = new osg::ShapeDrawable; shape2-&gt;setShape(new osg::Cone(osg::Vec3(0.0f, 0.0f, 0.0f), 1.0f, 1.0f)); shape2-&gt;setColor(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape3 = new osg::ShapeDrawable; shape3-&gt;setShape(new osg::Sphere(osg::Vec3(3.0f, 0.0f, 0.0f), 1.0f)); shape3-&gt;setColor(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(shape1.get()); root-&gt;addDrawable(shape2.get()); root-&gt;addDrawable(shape3.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Dieses Beispiel ben√∂tigt insbesondere keine Kommentare: Im Programm werden drei einfache Formen erstellt, nach dem Kompilieren und Starten sehen wir ein solches Ergebnis <br><br><img src="https://habrastorage.org/webt/mu/kl/cq/muklcqrapar1quikfyshzkang-4.png"><br><br>  Der im Beispiel gezeigte Mechanismus ist einfach und unkompliziert, aber nicht die effektivste Methode zum Erstellen von Geometrie und kann ausschlie√ülich f√ºr Tests verwendet werden.  Die osg :: Geometry-Klasse wird zum Erstellen von Geometrie in leistungsstarken OSG-basierten Anwendungen verwendet. <br><br><h1>  3. Speicherung von Geometriedaten: Klassen osg :: Array und osg :: Geometry </h1><br>  Die osg :: Array-Klasse ist eine grundlegende abstrakte Klasse, von der mehrere Nachkommen geerbt werden, um Daten zu speichern, die an OpenGL-Funktionen √ºbergeben werden.  Die Arbeit mit dieser Klasse √§hnelt der Arbeit mit std :: vector aus der C ++ - Standardbibliothek.  Der folgende Code veranschaulicht das Hinzuf√ºgen eines Vektors zu einem Scheitelpunktarray mithilfe der push_back () -Methode <br><br><pre> <code class="cpp hljs">vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  OSG-Arrays werden auf dem Heap zugewiesen und von intelligenten Zeigern verwaltet.  Dies gilt jedoch nicht f√ºr Array-Elemente wie osg :: Vec3 oder osg :: Vec2, die auch auf dem Stapel erstellt werden k√∂nnen. <br><br>  Die osg :: Geometry-Klasse ist ein Wrapper √ºber OpenGL-Funktionen, die mit Vertex-Arrays arbeiten.  Es ist von der Klasse osg :: Drawable abgeleitet und kann problemlos zur Objektliste osg :: Geode hinzugef√ºgt werden.  Diese Klasse verwendet die oben beschriebenen Arrays als Eingabe und verwendet sie zum Generieren von Geometrie mit OpenGL. <br><br><h1>  4. Eckpunkte und ihre Attribute </h1><br>  Ein Scheitelpunkt ist eine atomare Einheit von Geometrieprimitiven.  Es hat eine Reihe von Attributen, die einen Punkt im zwei- oder dreidimensionalen Raum beschreiben.  Zu den Attributen geh√∂ren: Position, Farbe, Normalvektor, Texturkoordinaten, Nebelkoordinaten usw.  Die Oberseite muss immer eine Position im Raum haben, da andere Attribute optional vorhanden sein k√∂nnen.  OpenGL unterst√ºtzt 16 grundlegende Scheitelpunktattribute und kann verschiedene Arrays zum Speichern verwenden.  Alle Attribut-Arrays werden von der Klasse osg :: Geometry unterst√ºtzt und k√∂nnen mit Methoden des Formularsatzes * Array () festgelegt werden. <br><br>  <b>Scheitelpunktattribute in OpenSceneGraph</b> <br><table><tbody><tr><th>  Attribut </th><th>  Datentyp </th><th>  Osg :: Geometry-Methode </th><th>  √Ñquivalenter OpenGL-Aufruf </th></tr><tr><td>  Position </td><td>  3-Vektor </td><td>  setVertexArray () </td><td>  glVertexPointer () </td></tr><tr><td>  Normal </td><td>  3-Vektor </td><td>  setNormalArray () </td><td>  glNormalPointer () </td></tr><tr><td>  Farbe </td><td>  4-Vektor </td><td>  setColorArray () </td><td>  glColorPointer () </td></tr><tr><td>  Sekund√§rfarbe </td><td>  4-Vektor </td><td>  setSecondaryColorArray () </td><td>  glSecondaryColorPointerEXT () </td></tr><tr><td>  Nebelkoordinaten </td><td>  float </td><td>  setFogCoordArray () </td><td>  glFogCoordPointerEXT () </td></tr><tr><td>  Texturkoordinaten </td><td>  2- oder 3-Vektor </td><td>  setTexCoordArray () </td><td>  glTexCoordPointer () </td></tr><tr><td>  Andere Attribute </td><td>  Benutzerdefiniert </td><td>  setVertexArribArray () </td><td>  glVertexAttribPointerARB () </td></tr></tbody></table><br>  Grunds√§tzlich ist es erforderlich, f√ºr jeden Scheitelpunkt eigene Attribute festzulegen, was zur Bildung mehrerer Arrays von Attributen gleicher Gr√∂√üe f√ºhrt. Andernfalls kann eine Nicht√ºbereinstimmung der Gr√∂√üe der Arrays zu einem undefinierten Verhalten der Engine f√ºhren.  OSG unterst√ºtzt beispielsweise verschiedene Methoden zum Verkn√ºpfen von Scheitelpunktattributen <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  bedeutet, dass jeder Scheitelpunkt und jede Farbe des Scheitelpunkts eins zu eins miteinander korreliert ist.  Wenn Sie sich jedoch einen solchen Code ansehen <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  dann wendet er eine Farbe auf die gesamte Geometrie an.  In √§hnlicher Weise k√∂nnen Beziehungen zwischen anderen Attributen durch Aufrufen der Methoden setNormalBinding (), setSecondaryColorBinding (), setFogCoordBinding () und setVertexAttribBinding () konfiguriert werden. <br><br><h1>  5. S√§tze von Geometrieprimitiven </h1><br>  Der n√§chste Schritt nach dem Definieren der Vertex-Attribut-Arrays besteht darin, zu beschreiben, wie die Vertex-Daten gerendert werden.  Die virtuelle osg :: PrimitiveSet-Klasse wird verwendet, um die vom Renderer generierten geometrischen Grundelemente aus einer Reihe von Scheitelpunkten zu steuern.  Die Klasse osg :: Geometry bietet verschiedene Methoden zum Arbeiten mit S√§tzen von Geometrieprimitiven: <br><br><ul><li>  addPrimitiveSet () - √úbergibt einen Zeiger auf eine Reihe von Grundelementen in einem osg :: Geometry-Objekt. <br></li><li>  removePrimitiveSet () - entfernt eine Reihe von Grundelementen.  Als Parameter werden der Anfangsindex der S√§tze und die Anzahl der zu l√∂schenden S√§tze verwendet. <br></li><li>  getPrimitiveSet () - gibt eine Reihe von Grundelementen an dem als Parameter √ºbergebenen Index zur√ºck. <br></li><li>  getNumPrimitiveSets () - Gibt die Gesamtzahl der S√§tze von Grundelementen zur√ºck, die dieser Geometrie zugeordnet sind. <br></li></ul><br>  Die osg :: PrimitiveSet-Klasse ist abstrakt und kann nicht instanziiert werden, aber mehrere abgeleitete Klassen, die S√§tze von Grundelementen enthalten, mit denen OpenGL arbeitet, wie z. B. osg :: DrawArrays und osg :: DrawElementsUInt, erben davon. <br><br>  Die Klasse osg :: DrawArrays verwendet mehrere aufeinanderfolgende Elemente eines Scheitelpunktarrays, um ein geometrisches Grundelement zu erstellen.  Es kann durch Aufrufen einer Methode erstellt und an die Geometrie angeh√§ngt werden. <br><br><pre> <code class="cpp hljs">geom-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(mode, first, count));</code> </pre><br>  Der erste Parametermodus setzt den Primitivtyp auf die entsprechenden OpenGL-Primitivtypen: GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADY und GL_. <br><br>  Der erste und der zweite Parameter geben den ersten Index im Scheitelpunktarray und die Anzahl der Scheitelpunkte an, aus denen die Geometrie generiert werden soll.  <strong>Dar√ºber hinaus pr√ºft OSG nicht, ob die angegebene Anzahl von Scheitelpunkten ausreicht, um die im Modus angegebene Geometrie zu erstellen, was zum Absturz der Anwendung f√ºhren kann!</strong> <br><br><h1>  6. Beispiel - Zeichnen Sie ein gemaltes Quadrat </h1><br>  Wir implementieren all das als einfaches Beispiel <br><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndiger Quellcode f√ºr Quad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 1.0f)); vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Nach der Kompilierung und Ausf√ºhrung erhalten wir ein √§hnliches Ergebnis <br><br><img src="https://habrastorage.org/webt/pz/1p/e4/pz1pe4inopylxd1vikvi4kzm8m0.png"><br><br>  Dieses Beispiel muss gekl√§rt werden.  Zun√§chst erstellen wir ein Array von Eckpunkten des Quadrats, in denen ihre Koordinaten gespeichert sind <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Als n√§chstes setzen wir das Array von Normalen.  In unserem einfachen Fall m√ºssen wir nicht f√ºr jeden Scheitelpunkt eine Normale erstellen - beschreiben Sie einfach einen Einheitsvektor, der senkrecht zur Ebene des Quadrats gerichtet ist <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Legen Sie f√ºr jeden Scheitelpunkt eine Farbe fest <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Erstellen Sie nun ein Geometrieobjekt, in dem die Beschreibung unseres Quadrats gespeichert wird, das vom Render verarbeitet wird.  Wir √ºbergeben dieser Geometrie eine Reihe von Eckpunkten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get());</code> </pre><br>  Wenn wir ein Array von Normalen √ºbergeben, informieren wir die Engine, dass eine einzige Normalen f√ºr alle Scheitelpunkte verwendet werden, indem wir die Bindungsmethode ("Bindung") der Normalen BIND_OVAERALL angeben <br><br><pre> <code class="cpp hljs">quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  Wenn wir dagegen die Farben der Scheitelpunkte √ºbergeben, geben wir an, dass jeder Scheitelpunkt seine eigene Farbe hat <br><br><pre> <code class="cpp hljs">quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  Erstellen Sie nun eine Reihe von Grundelementen f√ºr die Geometrie.  Wir geben an, dass quadratische (GL_QUADS) Fl√§chen aus dem Scheitelpunktarray generiert werden sollten, wobei der Scheitelpunkt mit dem Index 0 als erstem Scheitelpunkt verwendet wird und die Gesamtzahl der Scheitelpunkte 4 betr√§gt <br><br><pre> <code class="cpp hljs">quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  Ich denke, es lohnt sich nicht, die √úbertragung der Geometrie und den Start des Renderings zu erkl√§ren <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Der obige Code entspricht dem folgenden Design in reinem OpenGL <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLfloat vertices[][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { ‚Ä¶ }; glEnableClientState( GL_VERTEX_ARRAY ); glVertexPointer( <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices ); glDrawArrays( GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> );</code> </pre><br><h1>  7. Indizieren von Eckpunkten in Grundelementen </h1><br>  Die osg :: DrawArrays-Klasse funktioniert gut, wenn Scheitelpunktdaten ohne L√ºcken direkt aus Arrays gelesen werden.  Dies ist jedoch nicht so effektiv, wenn derselbe Scheitelpunkt zu mehreren Fl√§chen eines Objekts geh√∂ren kann.  Schauen wir uns ein Beispiel an. <br><br><img src="https://habrastorage.org/webt/yp/is/wm/ypiswmcxzm2uokv9xdreonovmf4.png"><br><br>  Der W√ºrfel hat acht Eckpunkte.  Wie aus der Abbildung ersichtlich ist (wir betrachten die Entfaltung des W√ºrfels in der Ebene), geh√∂ren einige Scheitelpunkte zu mehr als einer Fl√§che.  Wenn Sie einen W√ºrfel mit 12 dreieckigen Fl√§chen erstellen, werden diese Scheitelpunkte wiederholt, und anstelle eines Arrays mit 8 Scheitelpunkten erhalten wir ein Array mit 36 ‚Äã‚ÄãScheitelpunkten, von denen die meisten tats√§chlich der gleiche Scheitelpunkt sind! <br><br>  Die OSG-Klassen osg :: DrawElementsUInt, osg :: DrawElementsUByte und osg :: DrawElementsUShort, die Vertex-Index-Arrays als Daten verwenden, sollen das beschriebene Problem l√∂sen.  Arrays von Indizes speichern Indizes von Eckpunkten von Grundelementen, die Fl√§chen und andere Elemente der Geometrie beschreiben.  Wenn Sie diese Klassen f√ºr einen Cube anwenden, ist es ausreichend, ein Array von acht Scheitelpunkten zu speichern, die Fl√§chen durch Arrays von Indizes zugeordnet sind. <br><br>  Klassen vom Typ osg :: DrawElements * werden auf die gleiche Weise wie die Standardklasse std :: vector erstellt.  Mit diesem Code k√∂nnen Indizes hinzugef√ºgt werden. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Dieser Code definiert die Vorderseite des in der Abbildung gezeigten W√ºrfels. <br><br>  Betrachten wir ein weiteres anschauliches Beispiel - ein Oktaeder <br><br><img src="https://habrastorage.org/webt/is/cg/3r/iscg3rdq59wftnoy7h1iulgoczk.png"><br><br>  Es ist interessant, weil es nur sechs Eckpunkte enth√§lt, aber jeder Eckpunkt bis zu vier dreieckige Fl√§chen eingibt!  Mit osg :: DrawArrays k√∂nnen wir ein Array mit 24 Scheitelpunkten erstellen, um alle acht Fl√§chen anzuzeigen.  Wir werden jedoch etwas anderes tun - wir werden die Eckpunkte in einem Array von sechs Elementen speichern und Gesichter mit der Klasse osg :: DrawElementsUInt generieren. <br><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndige Quelle f√ºr das Oktaeder-Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/SmoothingVisitor&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array(6); (*vertices)[0].set( 0.0f, 0.0f, 1.0f); (*vertices)[1].set(-0.5f, -0.5f, 0.0f); (*vertices)[2].set( 0.5f, -0.5f, 0.0f); (*vertices)[3].set( 0.5f, 0.5f, 0.0f); (*vertices)[4].set(-0.5f, 0.5f, 0.0f); (*vertices)[5].set( 0.0f, 0.0f, -1.0f); osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = new osg::DrawElementsUInt(GL_TRIANGLES, 24); (*indices)[ 0] = 0; (*indices)[ 1] = 1; (*indices)[ 2] = 2; (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;addPrimitiveSet(indices.get()); osgUtil::SmoothingVisitor::smooth(*geom); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Lassen Sie uns diesen Code genauer analysieren.  Als erstes erstellen wir nat√ºrlich ein Array mit sechs Eckpunkten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array(<span class="hljs-number"><span class="hljs-number">6</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">3</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">5</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>);</code> </pre><br>  Wir initialisieren jeden Scheitelpunkt direkt, indem wir mit der Dereferenzierungsoperation des Zeiger- und Operatoroperators [] auf den Vektor seiner Koordinaten zugreifen (wir erinnern uns, dass osg :: Array in seinem Ger√§t std :: vector √§hnlich ist). <br><br>  Erstellen Sie nun Fl√§chen als Liste von Scheitelpunktindizes <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">24</span></span>); (*indices)[ <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; //  1 (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; //  2 (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; //  3 (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; //  4 (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; //  5 (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; //  6 (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; //  7</span></span></code> </pre><br>  Die Fl√§chen sind dreieckig, es gibt 8, was bedeutet, dass die Liste der Indizes 24 Elemente enthalten sollte.  Die Indizes von Fl√§chen verlaufen in diesem Array nacheinander: Zum Beispiel wird die Fl√§che 0 durch die Eckpunkte 0, 1 und 2 gebildet;  Fl√§che 1 - Eckpunkte 0, 4 und 1;  Gesicht 2 - Eckpunkte 4, 5 und 1 und so weiter.  Die Eckpunkte werden gegen den Uhrzeigersinn aufgelistet, wenn Sie das Gesicht des Gesichts betrachten (siehe Abbildung oben). <br><br>  Weitere Schritte zum Erstellen der Geometrie haben wir in den vorherigen Beispielen ausgef√ºhrt.  Das einzige, was wir nicht getan haben, war die automatische Erzeugung gegl√§tteter (gemittelter) Normalen, die wir in diesem Beispiel durch Aufrufen ausf√ºhren <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br>  In der Tat ist es einfach, die Normalen zu berechnen, wenn die Eckpunkte eines Gesichts angegeben sind.  An den Eckpunkten, an denen mehrere Fl√§chen zusammenlaufen, wird eine bestimmte durchschnittliche Normalen berechnet - die Normalen der konvergierenden Fl√§chen werden addiert und die resultierende Summe erneut normalisiert.  Diese Operationen (und vieles mehr!) K√∂nnen von der Engine selbst mithilfe von Klassen aus der osgUtil-Bibliothek ausgef√ºhrt werden.  Daher f√ºgen wir in unserem Beispiel dem Linker eine Anweisung hinzu, um unser Programm mit dieser Bibliothek in der * .pro-Datei zu erstellen <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">octahedron.pro</a></strong> <br><br><pre> <code class="cmake hljs">CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,_d) . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil }</code> </pre><br>  Als Ergebnis erhalten wir das folgende Ergebnis <br><br><img src="https://habrastorage.org/webt/sf/ia/yg/sfiayg-o7wqijwskwuw6276xx0y.png"><br><br>  Betrachten Sie die OpenGL-Pipeline, um zu verstehen, wie dies funktioniert <br><br><img src="https://habrastorage.org/webt/7w/f0/mq/7wf0mqmabsa1ltwbzsgt189jsmy.png"><br><br>  Der Vertex-Array-Mechanismus reduziert die Anzahl der OpenGL-Aufrufe.  Es speichert Vertexdaten im Anwendungsspeicher, der auf der Clientseite verwendet wird.  Die OpenGL-Pipeline auf der Serverseite erh√§lt Zugriff auf verschiedene Vertex-Arrays.  Wie im Diagramm gezeigt, empf√§ngt OpenGL Daten vom Scheitelpunktpuffer auf der Clientseite und f√ºhrt in geordneter Weise die Zusammenstellung von Grundelementen durch.  Auf diese Weise werden Daten mit den set * Array () -Methoden der Klasse osg :: Geometry verarbeitet.  Die Klasse osg :: DrawArrays durchl√§uft diese Arrays direkt und zeigt sie an. <br><br>  Bei Verwendung von osg :: DrawElements * wird die Dimension von Scheitelpunktarrays verringert und die Anzahl der in die Pipeline √ºbertragenen Scheitelpunkte verringert.  Mit einem Array von Indizes k√∂nnen Sie einen Server-Cache mit Scheitelpunkten erstellen.  OpenGL liest Scheitelpunktdaten aus dem Cache, anstatt aus dem Scheitelpunktpuffer auf der Clientseite zu lesen.  Dies erh√∂ht die allgemeine Renderleistung erheblich. <br><br><h1>  8. Polygonnetz-Verarbeitungstechniken </h1><br>  OpenSceneGraph unterst√ºtzt verschiedene Techniken zur Verarbeitung des Polygonnetzes von Szenengeometrieobjekten.  Diese Vorverarbeitungsmethoden wie Polygonreduktion und Tessellation werden h√§ufig verwendet, um polygonale Modelle zu erstellen und zu optimieren.  Sie haben eine einfache Oberfl√§che, f√ºhren dabei jedoch viele komplexe Berechnungen durch und eignen sich nicht sehr gut f√ºr die sofortige Ausf√ºhrung. <br><br>  Die beschriebenen Techniken umfassen: <br><br><ol><li>  osgUtil :: Simplifier - Reduziert die Anzahl der Dreiecke in der Geometrie.  Die √∂ffentliche Methode simplify () wird verwendet, um die Modellgeometrie zu vereinfachen. <br></li><li>  osgUtil :: SmootingVisitor - Berechnung von Normalen.  Die Methode glatt () kann verwendet werden, um gegl√§ttete Normalen f√ºr das Modell zu generieren, anstatt sie unabh√§ngig zu berechnen und explizit durch ein Array von Normalen zu setzen. <br></li><li>  osgUtil :: TangentSpaceGenerator - Generierung von Tangentenbasisvektoren f√ºr Modellscheitelpunkte.  Es wird durch Aufrufen der generate () -Methode gestartet und speichert das von den Methoden getTangentArray (), getNormalArray () und getBinormalArray () zur√ºckgegebene Ergebnis.  Diese Ergebnisse k√∂nnen f√ºr verschiedene Scheitelpunktattribute beim Schreiben von Shadern in GLSL verwendet werden. <br></li><li>  osgUtil :: Tesselator - f√ºhrt die Tessellierung eines Polygonnetzes durch - teilt komplexe Grundelemente in eine Folge einfacher Grundelemente auf (retesselatePolygons () -Methode) <br></li><li>  osgUtil :: TriStripVisitor - konvertiert eine geometrische Oberfl√§che in einen Satz Streifen dreieckiger Fl√§chen, wodurch das Rendern mit effizientem Speicherverbrauch erm√∂glicht wird.  Die Methode stripify () konvertiert eine Reihe von Modellprimitiven basierend auf der Menge GL_TRIANGLE_STRIP in Geometrie. <br></li></ol><br>  Alle Methoden akzeptieren die Geometrie des Objekts als Parameter, der beispielsweise von osg :: Geometry &amp; link √ºbergeben wird <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; tsv.stripify(*geom);</code> </pre><br>  Dabei bezieht sich Geom auf eine Geometrieinstanz, die durch einen intelligenten Zeiger beschrieben wird. <br><br>  Die Klassen osg :: Simplifier, osg :: SmoothingVisitor und osg :: TriStripVisitor k√∂nnen beispielsweise direkt mit Knoten im Szenendiagramm arbeiten <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; node-&gt;accept(tsv);</code> </pre><br>  Die Methode accept () verarbeitet alle untergeordneten Knoten, bis die angegebene Operation auf alle Endknoten dieses Teils des Szenenbaums angewendet wird, der in Knoten vom Typ osg :: Geode gespeichert ist. <br><br>  Lassen Sie uns die Tessellationstechnik in der Praxis ausprobieren. <br><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndiger Tesselator-Beispielcode</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/Tessellator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ----- | _| | |_ | | ----- */</span></span></span><span class="hljs-meta"> osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); // 0 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); // 1 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); // 2 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); // 3 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 2.0f) ); // 4 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 2.0f) ); // 5 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 3.0f) ); // 6 vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 3.0f) ); // 7 osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_POLYGON, 0, 8)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Anhand der r√§umlichen Position der Scheitelpunkte in diesem Beispiel wird deutlich, dass wir versuchen, ein nicht konvexes Polygon aus acht Scheitelpunkten zu erstellen, indem eine Fl√§che vom Typ GL_POLYGON generiert wird.  Die Zusammenstellung und Ausf√ºhrung dieses Beispiels zeigt, dass das erwartete Ergebnis nicht funktioniert - das Beispiel wird falsch angezeigt <br><br><img src="https://habrastorage.org/webt/yb/d3/0f/ybd30fn9fa9duvxedfyb6igt3ui.png"><br><br>  Um dieses Problem zu beheben, muss die konstruierte Geometrie tesselliert werden, bevor sie an den Viewer √ºbergeben wird <br><br><pre> <code class="cpp hljs">osgUtil::Tessellator ts; ts.retessellatePolygons(*geom);</code> </pre><br>  Danach erhalten wir das richtige Ergebnis <br><br><img src="https://habrastorage.org/webt/p7/wj/fa/p7wjfanogrvkbdxksemk5li_vdi.png"><br><br>  Wie funktioniert es  Ein nicht konvexes Polygon ohne die Verwendung einer korrekten Tessellation wird nicht wie erwartet angezeigt, da OpenGL, um die Leistung zu optimieren, es als einfaches, konvexes Polygon betrachtet oder es einfach ignoriert, was zu v√∂llig unerwarteten Ergebnissen f√ºhren kann. <br><br>  Die Klasse osgUtil :: Tessellator verwendet Algorithmen, um ein konvexes Polygon in eine Reihe nicht konvexer zu transformieren. In unserem Fall transformiert sie die Geometrie in GL_TRIANGLE_STRIP. <br><br><img src="https://habrastorage.org/webt/05/ho/do/05hodotfc4iltbsnlyevejuhvfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Klasse kann Lochpolygone und sich selbst schneidende Polygone verarbeiten. Mit der √∂ffentlichen Methode setWindingType () k√∂nnen Sie verschiedene Verarbeitungsregeln definieren, z. B. GLU_TESS_WINDING_ODD oder GLU_TESS_WINDING_NONZERO, die den inneren und √§u√üeren Bereich eines komplexen Polygons angeben.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel haben wir ein grundlegendes Verst√§ndnis daf√ºr erhalten, wie die Geometrie dreidimensionaler Objekte in der OSG-Engine gespeichert und verarbeitet wird. </font><font style="vertical-align: inherit;">Denken Sie nicht, dass diese einfachen und nicht zu eindrucksvollen Beispiele, die in diesem Artikel behandelt werden, die Grenzen der Motorleistung darstellen. </font><font style="vertical-align: inherit;">Nur diese Beispiele k√∂nnen dem Entwickler helfen, die Mechanik von OpenSceneGraph zu verstehen, und ohne dieses Verst√§ndnis ist es schwierig, sich die Arbeit komplexerer Dinge vorzustellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Artikel basiert auf der √úbersetzung und Verarbeitung des Textes der entsprechenden Kapitel des Buches </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSceneGraph 3.0. </font><font style="vertical-align: inherit;">Anf√§ngerleitfaden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alle Beispiele werden von mir pers√∂nlich gepr√ºft und ihr Quellcode ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier verf√ºgbar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung folgt...</font></font></a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430212/">https://habr.com/ru/post/de430212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430202/index.html">Schreiben eines Systems paarweise interagierender Partikel in C ++ mit DirectX 11</a></li>
<li><a href="../de430204/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: ‚ÄûPrivates Surfen im Internet‚Äú, Teil 1</a></li>
<li><a href="../de430206/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: Privates Surfen im Internet, Teil 2</a></li>
<li><a href="../de430208/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: ‚ÄûPrivates Surfen im Internet‚Äú, Teil 3</a></li>
<li><a href="../de430210/index.html">Testen Sie meine Geduld mit der Check Point Security Academy</a></li>
<li><a href="../de430216/index.html">So wie ich es verstehe, esse ich viele S√º√üigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung</a></li>
<li><a href="../de430218/index.html">Energieoptimierung STM32: Ein praktischer Leitfaden</a></li>
<li><a href="../de430220/index.html">Wie man einen "hundertj√§hrigen" USB-Hub in einen intelligent verwalteten verwandelt und 300 US-Dollar spart</a></li>
<li><a href="../de430222/index.html">Senior Engineer auf der Suche nach Arbeit. Wie ich 20 Interviews mit HR durchlaufen habe und was ich dar√ºber denke</a></li>
<li><a href="../de430224/index.html">Schizotypische St√∂rung: Ein Einblick</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>