<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤩 💼 👂🏽 OpenSceneGraph: Grundlagen der Szenengeometrie 👦🏾 🙄 👨🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 OpenGL, das Backend für OpenSceneGraph, verwendet geometrische Grundelemente (wie Punkte, Linien, Dreiecke und polygonale Flächen), um al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Grundlagen der Szenengeometrie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430212/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><br><h1>  Einführung </h1><br>  OpenGL, das Backend für OpenSceneGraph, verwendet geometrische Grundelemente (wie Punkte, Linien, Dreiecke und polygonale Flächen), um alle Objekte in der dreidimensionalen Welt zu konstruieren. <br><br>  Diese Grundelemente werden durch Daten über ihre Scheitelpunkte definiert, einschließlich der Koordinaten der Scheitelpunkte, Normalkomponenten, Farbdaten und Texturkoordinaten.  Diese Daten werden in speziellen Arrays gespeichert.  Grundelemente können beispielsweise gebildet werden, indem für die Objekte, die sie beschreiben, eine Liste von Scheitelpunktindizes angegeben wird.  Diese Methode wird als Vertex-Array-Methode bezeichnet. Sie eliminiert die Speicherung redundanter Vertices im Speicher und weist eine gute Leistung auf. <br><br>  Darüber hinaus kann OpenGL den Mechanismus sogenannter <i>Anzeigelisten verwenden</i> , wenn im Videospeicher vorbereitete Grundelemente wiederverwendet werden können, was die Anzeige statischer Objekte erheblich beschleunigt. <br><br>  Standardmäßig verwendet OSG die Vertex-Array-Methode und die Anzeigelistenmethode, um die Geometrie zu rendern.  Die Rendering-Strategie kann jedoch abhängig von der Darstellung der Geometriedaten geändert werden.  In diesem Artikel werden die grundlegenden Techniken für die Arbeit mit Geometrie in OSG behandelt. <br><a name="habracut"></a><br><h1>  1. Klassen Geode und Drawable </h1><br>  Die osg :: Geode-Klasse ist ein Terminal, der sogenannte "Blatt" -Knoten des Szenenbaums.  Es kann keine untergeordneten Knoten haben, enthält jedoch alle erforderlichen Informationen zum Rendern der Geometrie.  Der Name Geode steht für Geometrieknoten. <br><br>  Die von der Engine zu verarbeitenden geometrischen Daten werden in der Gruppe von Objekten der Klasse osg :: Drawable gespeichert, die von der Klasse osg :: Geode verwaltet wird.  Die osg :: Drawable-Klasse ist eine rein virtuelle Klasse.  Eine Reihe von Unterklassen werden davon geerbt, nämlich dreidimensionale Modelle, Bilder und Text, die von der OpenGL-Pipeline verarbeitet werden.  OSG bezeichnet Drawable als alle Elemente, die von der Engine gezeichnet werden können. <br><br>  Die Klasse osg :: Geode bietet eine Reihe von Methoden zum Anhängen und Trennen von Drawables: <br><br><ul><li>  Öffentliche Methode addDrawable () - Übergibt einen Zeiger auf ein zeichnbares Element in einer Instanz der Klasse osg :: Geode.  Alle diese Elemente werden von intelligenten Zeigern von osg :: ref_ptr &lt;&gt; gesteuert. <br></li><li>  Die öffentlichen Methoden removeDrawable () und removeDrawables () entfernen das Objekt aus osg :: Geode und verringern die Referenzanzahl dafür.  Die Methode removeDrawable () verwendet als einzelnen Parameter einen Zeiger auf das interessierende Element, und die Methode removeDrawables () verwendet zwei Parameter: den Anfangsindex und die Anzahl der Elemente, die aus dem Objektarray osg :: Geode entfernt werden sollen. <br></li><li>  Die Methode getDrawable () gibt einen Zeiger auf ein Element am Index zurück, der als Parameter übergeben wird. <br></li><li>  Die Methode getNumDrawables () gibt die Gesamtzahl der an osg :: Geode angehängten Elemente zurück.  Um beispielsweise alle Elemente aus osg :: Geode zu entfernen, können Sie solchen Code verwenden <br></li></ul><br><pre><code class="cpp hljs">geode-&gt;removeDrawables(<span class="hljs-number"><span class="hljs-number">0</span></span>, geode-&gt;getNumDrawables());</code> </pre> <br><h1>  2. Einfache Formen zeichnen </h1><br>  OSG stellt die Klasse osg :: ShapeDrawable bereit, die der Nachkomme der Klasse osg :: Drawable ist und zum Erstellen einfacher dreidimensionaler Grundelemente entwickelt wurde.  Diese Klasse enthält ein osg :: Shape-Objekt, in dem Informationen zu bestimmten Geometrien und anderen Parametern gespeichert sind.  Grundelemente werden beispielsweise mit der Methode setShape () generiert <br><br><pre> <code class="cpp hljs">shapeDrawable-&gt;setShape(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Box(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">5.0f</span></span>));</code> </pre><br>  Erstellt eine rechteckige Box mit einem geometrischen Mittelpunkt am Punkt (1.0, 0.0, 0.0) mit einer Breite und Höhe von 10 und einer Tiefe von 5 Einheiten.  Die Klasse osg :: Vec3 definiert einen Vektor im dreidimensionalen Raum (zusätzlich werden auch die Klassen osg :: Vec2 und osg :: Vec4 dargestellt, die Vektoren der entsprechenden Dimension beschreiben). <br><br>  Die beliebtesten Grundelemente werden in OSG durch die Klassen osg :: Box, osg :: Capsule, osg :: Cone, osg :: Cylinder und osg :: Sphere dargestellt. <br><br>  Betrachten Sie ein Beispiel für die Anwendung dieses Mechanismus. <br><br>  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ShapeDrawable&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::ShapeDrawable&gt; shape1 = new osg::ShapeDrawable; shape1-&gt;setShape(new osg::Box(osg::Vec3(-3.0f, 0.0f, 0.0f), 2.0f, 2.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape2 = new osg::ShapeDrawable; shape2-&gt;setShape(new osg::Cone(osg::Vec3(0.0f, 0.0f, 0.0f), 1.0f, 1.0f)); shape2-&gt;setColor(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::ShapeDrawable&gt; shape3 = new osg::ShapeDrawable; shape3-&gt;setShape(new osg::Sphere(osg::Vec3(3.0f, 0.0f, 0.0f), 1.0f)); shape3-&gt;setColor(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(shape1.get()); root-&gt;addDrawable(shape2.get()); root-&gt;addDrawable(shape3.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br>  Dieses Beispiel benötigt insbesondere keine Kommentare: Im Programm werden drei einfache Formen erstellt, nach dem Kompilieren und Starten sehen wir ein solches Ergebnis <br><br><img src="https://habrastorage.org/webt/mu/kl/cq/muklcqrapar1quikfyshzkang-4.png"><br><br>  Der im Beispiel gezeigte Mechanismus ist einfach und unkompliziert, aber nicht die effektivste Methode zum Erstellen von Geometrie und kann ausschließlich für Tests verwendet werden.  Die osg :: Geometry-Klasse wird zum Erstellen von Geometrie in leistungsstarken OSG-basierten Anwendungen verwendet. <br><br><h1>  3. Speicherung von Geometriedaten: Klassen osg :: Array und osg :: Geometry </h1><br>  Die osg :: Array-Klasse ist eine grundlegende abstrakte Klasse, von der mehrere Nachkommen geerbt werden, um Daten zu speichern, die an OpenGL-Funktionen übergeben werden.  Die Arbeit mit dieser Klasse ähnelt der Arbeit mit std :: vector aus der C ++ - Standardbibliothek.  Der folgende Code veranschaulicht das Hinzufügen eines Vektors zu einem Scheitelpunktarray mithilfe der push_back () -Methode <br><br><pre> <code class="cpp hljs">vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  OSG-Arrays werden auf dem Heap zugewiesen und von intelligenten Zeigern verwaltet.  Dies gilt jedoch nicht für Array-Elemente wie osg :: Vec3 oder osg :: Vec2, die auch auf dem Stapel erstellt werden können. <br><br>  Die osg :: Geometry-Klasse ist ein Wrapper über OpenGL-Funktionen, die mit Vertex-Arrays arbeiten.  Es ist von der Klasse osg :: Drawable abgeleitet und kann problemlos zur Objektliste osg :: Geode hinzugefügt werden.  Diese Klasse verwendet die oben beschriebenen Arrays als Eingabe und verwendet sie zum Generieren von Geometrie mit OpenGL. <br><br><h1>  4. Eckpunkte und ihre Attribute </h1><br>  Ein Scheitelpunkt ist eine atomare Einheit von Geometrieprimitiven.  Es hat eine Reihe von Attributen, die einen Punkt im zwei- oder dreidimensionalen Raum beschreiben.  Zu den Attributen gehören: Position, Farbe, Normalvektor, Texturkoordinaten, Nebelkoordinaten usw.  Die Oberseite muss immer eine Position im Raum haben, da andere Attribute optional vorhanden sein können.  OpenGL unterstützt 16 grundlegende Scheitelpunktattribute und kann verschiedene Arrays zum Speichern verwenden.  Alle Attribut-Arrays werden von der Klasse osg :: Geometry unterstützt und können mit Methoden des Formularsatzes * Array () festgelegt werden. <br><br>  <b>Scheitelpunktattribute in OpenSceneGraph</b> <br><table><tbody><tr><th>  Attribut </th><th>  Datentyp </th><th>  Osg :: Geometry-Methode </th><th>  Äquivalenter OpenGL-Aufruf </th></tr><tr><td>  Position </td><td>  3-Vektor </td><td>  setVertexArray () </td><td>  glVertexPointer () </td></tr><tr><td>  Normal </td><td>  3-Vektor </td><td>  setNormalArray () </td><td>  glNormalPointer () </td></tr><tr><td>  Farbe </td><td>  4-Vektor </td><td>  setColorArray () </td><td>  glColorPointer () </td></tr><tr><td>  Sekundärfarbe </td><td>  4-Vektor </td><td>  setSecondaryColorArray () </td><td>  glSecondaryColorPointerEXT () </td></tr><tr><td>  Nebelkoordinaten </td><td>  float </td><td>  setFogCoordArray () </td><td>  glFogCoordPointerEXT () </td></tr><tr><td>  Texturkoordinaten </td><td>  2- oder 3-Vektor </td><td>  setTexCoordArray () </td><td>  glTexCoordPointer () </td></tr><tr><td>  Andere Attribute </td><td>  Benutzerdefiniert </td><td>  setVertexArribArray () </td><td>  glVertexAttribPointerARB () </td></tr></tbody></table><br>  Grundsätzlich ist es erforderlich, für jeden Scheitelpunkt eigene Attribute festzulegen, was zur Bildung mehrerer Arrays von Attributen gleicher Größe führt. Andernfalls kann eine Nichtübereinstimmung der Größe der Arrays zu einem undefinierten Verhalten der Engine führen.  OSG unterstützt beispielsweise verschiedene Methoden zum Verknüpfen von Scheitelpunktattributen <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  bedeutet, dass jeder Scheitelpunkt und jede Farbe des Scheitelpunkts eins zu eins miteinander korreliert ist.  Wenn Sie sich jedoch einen solchen Code ansehen <br><br><pre> <code class="cpp hljs">geom-&gt;setColorBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  dann wendet er eine Farbe auf die gesamte Geometrie an.  In ähnlicher Weise können Beziehungen zwischen anderen Attributen durch Aufrufen der Methoden setNormalBinding (), setSecondaryColorBinding (), setFogCoordBinding () und setVertexAttribBinding () konfiguriert werden. <br><br><h1>  5. Sätze von Geometrieprimitiven </h1><br>  Der nächste Schritt nach dem Definieren der Vertex-Attribut-Arrays besteht darin, zu beschreiben, wie die Vertex-Daten gerendert werden.  Die virtuelle osg :: PrimitiveSet-Klasse wird verwendet, um die vom Renderer generierten geometrischen Grundelemente aus einer Reihe von Scheitelpunkten zu steuern.  Die Klasse osg :: Geometry bietet verschiedene Methoden zum Arbeiten mit Sätzen von Geometrieprimitiven: <br><br><ul><li>  addPrimitiveSet () - Übergibt einen Zeiger auf eine Reihe von Grundelementen in einem osg :: Geometry-Objekt. <br></li><li>  removePrimitiveSet () - entfernt eine Reihe von Grundelementen.  Als Parameter werden der Anfangsindex der Sätze und die Anzahl der zu löschenden Sätze verwendet. <br></li><li>  getPrimitiveSet () - gibt eine Reihe von Grundelementen an dem als Parameter übergebenen Index zurück. <br></li><li>  getNumPrimitiveSets () - Gibt die Gesamtzahl der Sätze von Grundelementen zurück, die dieser Geometrie zugeordnet sind. <br></li></ul><br>  Die osg :: PrimitiveSet-Klasse ist abstrakt und kann nicht instanziiert werden, aber mehrere abgeleitete Klassen, die Sätze von Grundelementen enthalten, mit denen OpenGL arbeitet, wie z. B. osg :: DrawArrays und osg :: DrawElementsUInt, erben davon. <br><br>  Die Klasse osg :: DrawArrays verwendet mehrere aufeinanderfolgende Elemente eines Scheitelpunktarrays, um ein geometrisches Grundelement zu erstellen.  Es kann durch Aufrufen einer Methode erstellt und an die Geometrie angehängt werden. <br><br><pre> <code class="cpp hljs">geom-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(mode, first, count));</code> </pre><br>  Der erste Parametermodus setzt den Primitivtyp auf die entsprechenden OpenGL-Primitivtypen: GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADY und GL_. <br><br>  Der erste und der zweite Parameter geben den ersten Index im Scheitelpunktarray und die Anzahl der Scheitelpunkte an, aus denen die Geometrie generiert werden soll.  <strong>Darüber hinaus prüft OSG nicht, ob die angegebene Anzahl von Scheitelpunkten ausreicht, um die im Modus angegebene Geometrie zu erstellen, was zum Absturz der Anwendung führen kann!</strong> <br><br><h1>  6. Beispiel - Zeichnen Sie ein gemaltes Quadrat </h1><br>  Wir implementieren all das als einfaches Beispiel <br><br><div class="spoiler">  <b class="spoiler_title">Vollständiger Quellcode für Quad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 0.0f)); vertices-&gt;push_back(osg::Vec3(1.0f, 0.0f, 1.0f)); vertices-&gt;push_back(osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back(osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f)); colors-&gt;push_back(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Nach der Kompilierung und Ausführung erhalten wir ein ähnliches Ergebnis <br><br><img src="https://habrastorage.org/webt/pz/1p/e4/pz1pe4inopylxd1vikvi4kzm8m0.png"><br><br>  Dieses Beispiel muss geklärt werden.  Zunächst erstellen wir ein Array von Eckpunkten des Quadrats, in denen ihre Koordinaten gespeichert sind <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); vertices-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Als nächstes setzen wir das Array von Normalen.  In unserem einfachen Fall müssen wir nicht für jeden Scheitelpunkt eine Normale erstellen - beschreiben Sie einfach einen Einheitsvektor, der senkrecht zur Ebene des Quadrats gerichtet ist <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre><br>  Legen Sie für jeden Scheitelpunkt eine Farbe fest <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); colors-&gt;push_back(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Erstellen Sie nun ein Geometrieobjekt, in dem die Beschreibung unseres Quadrats gespeichert wird, das vom Render verarbeitet wird.  Wir übergeben dieser Geometrie eine Reihe von Eckpunkten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get());</code> </pre><br>  Wenn wir ein Array von Normalen übergeben, informieren wir die Engine, dass eine einzige Normalen für alle Scheitelpunkte verwendet werden, indem wir die Bindungsmethode ("Bindung") der Normalen BIND_OVAERALL angeben <br><br><pre> <code class="cpp hljs">quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL);</code> </pre><br>  Wenn wir dagegen die Farben der Scheitelpunkte übergeben, geben wir an, dass jeder Scheitelpunkt seine eigene Farbe hat <br><br><pre> <code class="cpp hljs">quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX);</code> </pre><br>  Erstellen Sie nun eine Reihe von Grundelementen für die Geometrie.  Wir geben an, dass quadratische (GL_QUADS) Flächen aus dem Scheitelpunktarray generiert werden sollten, wobei der Scheitelpunkt mit dem Index 0 als erstem Scheitelpunkt verwendet wird und die Gesamtzahl der Scheitelpunkte 4 beträgt <br><br><pre> <code class="cpp hljs">quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>));</code> </pre><br>  Ich denke, es lohnt sich nicht, die Übertragung der Geometrie und den Start des Renderings zu erklären <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Der obige Code entspricht dem folgenden Design in reinem OpenGL <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLfloat vertices[][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { … }; glEnableClientState( GL_VERTEX_ARRAY ); glVertexPointer( <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, <span class="hljs-number"><span class="hljs-number">0</span></span>, vertices ); glDrawArrays( GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> );</code> </pre><br><h1>  7. Indizieren von Eckpunkten in Grundelementen </h1><br>  Die osg :: DrawArrays-Klasse funktioniert gut, wenn Scheitelpunktdaten ohne Lücken direkt aus Arrays gelesen werden.  Dies ist jedoch nicht so effektiv, wenn derselbe Scheitelpunkt zu mehreren Flächen eines Objekts gehören kann.  Schauen wir uns ein Beispiel an. <br><br><img src="https://habrastorage.org/webt/yp/is/wm/ypiswmcxzm2uokv9xdreonovmf4.png"><br><br>  Der Würfel hat acht Eckpunkte.  Wie aus der Abbildung ersichtlich ist (wir betrachten die Entfaltung des Würfels in der Ebene), gehören einige Scheitelpunkte zu mehr als einer Fläche.  Wenn Sie einen Würfel mit 12 dreieckigen Flächen erstellen, werden diese Scheitelpunkte wiederholt, und anstelle eines Arrays mit 8 Scheitelpunkten erhalten wir ein Array mit 36 ​​Scheitelpunkten, von denen die meisten tatsächlich der gleiche Scheitelpunkt sind! <br><br>  Die OSG-Klassen osg :: DrawElementsUInt, osg :: DrawElementsUByte und osg :: DrawElementsUShort, die Vertex-Index-Arrays als Daten verwenden, sollen das beschriebene Problem lösen.  Arrays von Indizes speichern Indizes von Eckpunkten von Grundelementen, die Flächen und andere Elemente der Geometrie beschreiben.  Wenn Sie diese Klassen für einen Cube anwenden, ist es ausreichend, ein Array von acht Scheitelpunkten zu speichern, die Flächen durch Arrays von Indizes zugeordnet sind. <br><br>  Klassen vom Typ osg :: DrawElements * werden auf die gleiche Weise wie die Standardklasse std :: vector erstellt.  Mit diesem Code können Indizes hinzugefügt werden. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">3</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); de-&gt;push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Dieser Code definiert die Vorderseite des in der Abbildung gezeigten Würfels. <br><br>  Betrachten wir ein weiteres anschauliches Beispiel - ein Oktaeder <br><br><img src="https://habrastorage.org/webt/is/cg/3r/iscg3rdq59wftnoy7h1iulgoczk.png"><br><br>  Es ist interessant, weil es nur sechs Eckpunkte enthält, aber jeder Eckpunkt bis zu vier dreieckige Flächen eingibt!  Mit osg :: DrawArrays können wir ein Array mit 24 Scheitelpunkten erstellen, um alle acht Flächen anzuzeigen.  Wir werden jedoch etwas anderes tun - wir werden die Eckpunkte in einem Array von sechs Elementen speichern und Gesichter mit der Klasse osg :: DrawElementsUInt generieren. <br><br><div class="spoiler">  <b class="spoiler_title">Vollständige Quelle für das Oktaeder-Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/SmoothingVisitor&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array(6); (*vertices)[0].set( 0.0f, 0.0f, 1.0f); (*vertices)[1].set(-0.5f, -0.5f, 0.0f); (*vertices)[2].set( 0.5f, -0.5f, 0.0f); (*vertices)[3].set( 0.5f, 0.5f, 0.0f); (*vertices)[4].set(-0.5f, 0.5f, 0.0f); (*vertices)[5].set( 0.0f, 0.0f, -1.0f); osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = new osg::DrawElementsUInt(GL_TRIANGLES, 24); (*indices)[ 0] = 0; (*indices)[ 1] = 1; (*indices)[ 2] = 2; (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;addPrimitiveSet(indices.get()); osgUtil::SmoothingVisitor::smooth(*geom); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Lassen Sie uns diesen Code genauer analysieren.  Als erstes erstellen wir natürlich ein Array mit sechs Eckpunkten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array(<span class="hljs-number"><span class="hljs-number">6</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">0</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">2</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">3</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">4</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); (*vertices)[<span class="hljs-number"><span class="hljs-number">5</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>);</code> </pre><br>  Wir initialisieren jeden Scheitelpunkt direkt, indem wir mit der Dereferenzierungsoperation des Zeiger- und Operatoroperators [] auf den Vektor seiner Koordinaten zugreifen (wir erinnern uns, dass osg :: Array in seinem Gerät std :: vector ähnlich ist). <br><br>  Erstellen Sie nun Flächen als Liste von Scheitelpunktindizes <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::DrawElementsUInt&gt; indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawElementsUInt(GL_TRIANGLES, <span class="hljs-number"><span class="hljs-number">24</span></span>); (*indices)[ <span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; (*indices)[ <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 (*indices)[ 3] = 0; (*indices)[ 4] = 4; (*indices)[ 5] = 1; //  1 (*indices)[ 6] = 4; (*indices)[ 7] = 5; (*indices)[ 8] = 1; //  2 (*indices)[ 9] = 4; (*indices)[10] = 3; (*indices)[11] = 5; //  3 (*indices)[12] = 3; (*indices)[13] = 2; (*indices)[14] = 5; //  4 (*indices)[15] = 1; (*indices)[16] = 5; (*indices)[17] = 2; //  5 (*indices)[18] = 3; (*indices)[19] = 0; (*indices)[20] = 2; //  6 (*indices)[21] = 0; (*indices)[22] = 3; (*indices)[23] = 4; //  7</span></span></code> </pre><br>  Die Flächen sind dreieckig, es gibt 8, was bedeutet, dass die Liste der Indizes 24 Elemente enthalten sollte.  Die Indizes von Flächen verlaufen in diesem Array nacheinander: Zum Beispiel wird die Fläche 0 durch die Eckpunkte 0, 1 und 2 gebildet;  Fläche 1 - Eckpunkte 0, 4 und 1;  Gesicht 2 - Eckpunkte 4, 5 und 1 und so weiter.  Die Eckpunkte werden gegen den Uhrzeigersinn aufgelistet, wenn Sie das Gesicht des Gesichts betrachten (siehe Abbildung oben). <br><br>  Weitere Schritte zum Erstellen der Geometrie haben wir in den vorherigen Beispielen ausgeführt.  Das einzige, was wir nicht getan haben, war die automatische Erzeugung geglätteter (gemittelter) Normalen, die wir in diesem Beispiel durch Aufrufen ausführen <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br>  In der Tat ist es einfach, die Normalen zu berechnen, wenn die Eckpunkte eines Gesichts angegeben sind.  An den Eckpunkten, an denen mehrere Flächen zusammenlaufen, wird eine bestimmte durchschnittliche Normalen berechnet - die Normalen der konvergierenden Flächen werden addiert und die resultierende Summe erneut normalisiert.  Diese Operationen (und vieles mehr!) Können von der Engine selbst mithilfe von Klassen aus der osgUtil-Bibliothek ausgeführt werden.  Daher fügen wir in unserem Beispiel dem Linker eine Anweisung hinzu, um unser Programm mit dieser Bibliothek in der * .pro-Datei zu erstellen <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">octahedron.pro</a></strong> <br><br><pre> <code class="cmake hljs">CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,_d) . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { . . . LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil }</code> </pre><br>  Als Ergebnis erhalten wir das folgende Ergebnis <br><br><img src="https://habrastorage.org/webt/sf/ia/yg/sfiayg-o7wqijwskwuw6276xx0y.png"><br><br>  Betrachten Sie die OpenGL-Pipeline, um zu verstehen, wie dies funktioniert <br><br><img src="https://habrastorage.org/webt/7w/f0/mq/7wf0mqmabsa1ltwbzsgt189jsmy.png"><br><br>  Der Vertex-Array-Mechanismus reduziert die Anzahl der OpenGL-Aufrufe.  Es speichert Vertexdaten im Anwendungsspeicher, der auf der Clientseite verwendet wird.  Die OpenGL-Pipeline auf der Serverseite erhält Zugriff auf verschiedene Vertex-Arrays.  Wie im Diagramm gezeigt, empfängt OpenGL Daten vom Scheitelpunktpuffer auf der Clientseite und führt in geordneter Weise die Zusammenstellung von Grundelementen durch.  Auf diese Weise werden Daten mit den set * Array () -Methoden der Klasse osg :: Geometry verarbeitet.  Die Klasse osg :: DrawArrays durchläuft diese Arrays direkt und zeigt sie an. <br><br>  Bei Verwendung von osg :: DrawElements * wird die Dimension von Scheitelpunktarrays verringert und die Anzahl der in die Pipeline übertragenen Scheitelpunkte verringert.  Mit einem Array von Indizes können Sie einen Server-Cache mit Scheitelpunkten erstellen.  OpenGL liest Scheitelpunktdaten aus dem Cache, anstatt aus dem Scheitelpunktpuffer auf der Clientseite zu lesen.  Dies erhöht die allgemeine Renderleistung erheblich. <br><br><h1>  8. Polygonnetz-Verarbeitungstechniken </h1><br>  OpenSceneGraph unterstützt verschiedene Techniken zur Verarbeitung des Polygonnetzes von Szenengeometrieobjekten.  Diese Vorverarbeitungsmethoden wie Polygonreduktion und Tessellation werden häufig verwendet, um polygonale Modelle zu erstellen und zu optimieren.  Sie haben eine einfache Oberfläche, führen dabei jedoch viele komplexe Berechnungen durch und eignen sich nicht sehr gut für die sofortige Ausführung. <br><br>  Die beschriebenen Techniken umfassen: <br><br><ol><li>  osgUtil :: Simplifier - Reduziert die Anzahl der Dreiecke in der Geometrie.  Die öffentliche Methode simplify () wird verwendet, um die Modellgeometrie zu vereinfachen. <br></li><li>  osgUtil :: SmootingVisitor - Berechnung von Normalen.  Die Methode glatt () kann verwendet werden, um geglättete Normalen für das Modell zu generieren, anstatt sie unabhängig zu berechnen und explizit durch ein Array von Normalen zu setzen. <br></li><li>  osgUtil :: TangentSpaceGenerator - Generierung von Tangentenbasisvektoren für Modellscheitelpunkte.  Es wird durch Aufrufen der generate () -Methode gestartet und speichert das von den Methoden getTangentArray (), getNormalArray () und getBinormalArray () zurückgegebene Ergebnis.  Diese Ergebnisse können für verschiedene Scheitelpunktattribute beim Schreiben von Shadern in GLSL verwendet werden. <br></li><li>  osgUtil :: Tesselator - führt die Tessellierung eines Polygonnetzes durch - teilt komplexe Grundelemente in eine Folge einfacher Grundelemente auf (retesselatePolygons () -Methode) <br></li><li>  osgUtil :: TriStripVisitor - konvertiert eine geometrische Oberfläche in einen Satz Streifen dreieckiger Flächen, wodurch das Rendern mit effizientem Speicherverbrauch ermöglicht wird.  Die Methode stripify () konvertiert eine Reihe von Modellprimitiven basierend auf der Menge GL_TRIANGLE_STRIP in Geometrie. <br></li></ol><br>  Alle Methoden akzeptieren die Geometrie des Objekts als Parameter, der beispielsweise von osg :: Geometry &amp; link übergeben wird <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; tsv.stripify(*geom);</code> </pre><br>  Dabei bezieht sich Geom auf eine Geometrieinstanz, die durch einen intelligenten Zeiger beschrieben wird. <br><br>  Die Klassen osg :: Simplifier, osg :: SmoothingVisitor und osg :: TriStripVisitor können beispielsweise direkt mit Knoten im Szenendiagramm arbeiten <br><br><pre> <code class="cpp hljs">osgUtil::TriStripVisitor tsv; node-&gt;accept(tsv);</code> </pre><br>  Die Methode accept () verarbeitet alle untergeordneten Knoten, bis die angegebene Operation auf alle Endknoten dieses Teils des Szenenbaums angewendet wird, der in Knoten vom Typ osg :: Geode gespeichert ist. <br><br>  Lassen Sie uns die Tessellationstechnik in der Praxis ausprobieren. <br><br><div class="spoiler">  <b class="spoiler_title">Vollständiger Tesselator-Beispielcode</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgUtil/Tessellator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ----- | _| | |_ | | ----- */</span></span></span><span class="hljs-meta"> osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); // 0 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); // 1 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); // 2 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); // 3 vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 2.0f) ); // 4 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 2.0f) ); // 5 vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 3.0f) ); // 6 vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 3.0f) ); // 7 osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_POLYGON, 0, 8)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Anhand der räumlichen Position der Scheitelpunkte in diesem Beispiel wird deutlich, dass wir versuchen, ein nicht konvexes Polygon aus acht Scheitelpunkten zu erstellen, indem eine Fläche vom Typ GL_POLYGON generiert wird.  Die Zusammenstellung und Ausführung dieses Beispiels zeigt, dass das erwartete Ergebnis nicht funktioniert - das Beispiel wird falsch angezeigt <br><br><img src="https://habrastorage.org/webt/yb/d3/0f/ybd30fn9fa9duvxedfyb6igt3ui.png"><br><br>  Um dieses Problem zu beheben, muss die konstruierte Geometrie tesselliert werden, bevor sie an den Viewer übergeben wird <br><br><pre> <code class="cpp hljs">osgUtil::Tessellator ts; ts.retessellatePolygons(*geom);</code> </pre><br>  Danach erhalten wir das richtige Ergebnis <br><br><img src="https://habrastorage.org/webt/p7/wj/fa/p7wjfanogrvkbdxksemk5li_vdi.png"><br><br>  Wie funktioniert es  Ein nicht konvexes Polygon ohne die Verwendung einer korrekten Tessellation wird nicht wie erwartet angezeigt, da OpenGL, um die Leistung zu optimieren, es als einfaches, konvexes Polygon betrachtet oder es einfach ignoriert, was zu völlig unerwarteten Ergebnissen führen kann. <br><br>  Die Klasse osgUtil :: Tessellator verwendet Algorithmen, um ein konvexes Polygon in eine Reihe nicht konvexer zu transformieren. In unserem Fall transformiert sie die Geometrie in GL_TRIANGLE_STRIP. <br><br><img src="https://habrastorage.org/webt/05/ho/do/05hodotfc4iltbsnlyevejuhvfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Klasse kann Lochpolygone und sich selbst schneidende Polygone verarbeiten. Mit der öffentlichen Methode setWindingType () können Sie verschiedene Verarbeitungsregeln definieren, z. B. GLU_TESS_WINDING_ODD oder GLU_TESS_WINDING_NONZERO, die den inneren und äußeren Bereich eines komplexen Polygons angeben.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel haben wir ein grundlegendes Verständnis dafür erhalten, wie die Geometrie dreidimensionaler Objekte in der OSG-Engine gespeichert und verarbeitet wird. </font><font style="vertical-align: inherit;">Denken Sie nicht, dass diese einfachen und nicht zu eindrucksvollen Beispiele, die in diesem Artikel behandelt werden, die Grenzen der Motorleistung darstellen. </font><font style="vertical-align: inherit;">Nur diese Beispiele können dem Entwickler helfen, die Mechanik von OpenSceneGraph zu verstehen, und ohne dieses Verständnis ist es schwierig, sich die Arbeit komplexerer Dinge vorzustellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Artikel basiert auf der Übersetzung und Verarbeitung des Textes der entsprechenden Kapitel des Buches </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenSceneGraph 3.0. </font><font style="vertical-align: inherit;">Anfängerleitfaden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alle Beispiele werden von mir persönlich geprüft und ihr Quellcode ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier verfügbar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung folgt...</font></font></a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430212/">https://habr.com/ru/post/de430212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430202/index.html">Schreiben eines Systems paarweise interagierender Partikel in C ++ mit DirectX 11</a></li>
<li><a href="../de430204/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: „Privates Surfen im Internet“, Teil 1</a></li>
<li><a href="../de430206/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: Privates Surfen im Internet, Teil 2</a></li>
<li><a href="../de430208/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: „Privates Surfen im Internet“, Teil 3</a></li>
<li><a href="../de430210/index.html">Testen Sie meine Geduld mit der Check Point Security Academy</a></li>
<li><a href="../de430216/index.html">So wie ich es verstehe, esse ich viele Süßigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung</a></li>
<li><a href="../de430218/index.html">Energieoptimierung STM32: Ein praktischer Leitfaden</a></li>
<li><a href="../de430220/index.html">Wie man einen "hundertjährigen" USB-Hub in einen intelligent verwalteten verwandelt und 300 US-Dollar spart</a></li>
<li><a href="../de430222/index.html">Senior Engineer auf der Suche nach Arbeit. Wie ich 20 Interviews mit HR durchlaufen habe und was ich darüber denke</a></li>
<li><a href="../de430224/index.html">Schizotypische Störung: Ein Einblick</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>