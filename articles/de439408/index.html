<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò§ ‚≠ïÔ∏è üîï Pseudo Lens Flare üë©üèª‚Äçüåæ ü§ûüèª ü§•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels ‚ÄûPseudo Lens Flare‚Äú von John Chapman. 



 Lens Flare (Lens Flare) ist ein fotografisch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pseudo Lens Flare</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439408/">  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûPseudo Lens Flare‚Äú</a> von John Chapman. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/905/ced/087/905ced087e506e2a67793bb663eb43f9.png" alt="Bild"><br><br>  <b>Lens Flare</b> (Lens Flare) ist ein fotografisches Artefakt, das durch Streuung und Brechung von Licht in einem Linsensystem entsteht.  Obwohl es sich um ein Artefakt handelt, gibt es viele Gr√ºnde, <b>Linseneffekte</b> in Computergrafiken zu verwenden: <br><br><ul><li>  Es erh√∂ht die wahrgenommene Helligkeit und den sichtbaren Dynamikbereich des Bildes. </li><li>  <b>Linseneffekte sind</b> h√§ufig auf Fotografien zu finden, so dass ihre Abwesenheit auff√§llig sein kann </li><li>  Es kann eine wichtige Rolle im Stil oder im Drama spielen oder Teil des Gameplays in Spielen sein (stellen Sie sich vor, Blendung macht einen Spieler blind). </li></ul><br>  Traditionell wurde <b>Lens Flare</b> in Echtzeit mithilfe von Sprite-basierten Technologien implementiert.  Obwohl Sprites leicht zu kontrollierende und sehr realistische Ergebnisse liefern, m√ºssen sie explizit platziert werden und erfordern Okklusionsdaten, um korrekt angezeigt zu werden.  Hier werde ich einen einfachen und relativ billigen Bildschirmraumeffekt beschreiben, der aus dem Eingabefarbpuffer ein Pseudo- <b>Linseneffekt</b> erzeugt.  Es basiert nicht auf Physik, daher unterscheidet sich das Ergebnis geringf√ºgig vom fotorealistischen, es kann jedoch in Kombination mit (oder als Ersatz) herk√∂mmlichen Sprite-basierten Effekten verwendet werden. <br><a name="habracut"></a><br><h2>  Algorithmus </h2><br>  Besteht aus 4 Stufen: <br><br><ol><li>  Downsample / Schwelle. </li><li>  Erzeugung von <b>Linseneffektelementen</b> . </li><li>  Unsch√§rfe </li><li>  Gehoben / mit dem Originalbild verschmelzen. </li></ol><br><h3>  1. Downsample / Threshold </h3><br>  <b>Downsampling</b> - Optimierung zur Reduzierung der Kosten nachfolgender Schritte.  Au√üerdem m√∂chten wir eine Teilmenge der hellsten Pixel im Originalbild ausw√§hlen.  Die Verwendung von <b>Scale / Bias</b> (Scale / Bias) bietet eine flexible M√∂glichkeit, dies zu erreichen: <br><br><pre><code class="cpp hljs">uniform sampler2D uInputTex; uniform vec4 uScale; uniform vec4 uBias; noperspective in vec2 vTexcoord; out vec4 fResult; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fResult = max(vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), texture(uInputTex, vTexcoord) + uBias) * uScale; }</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/35d/775/c6d/35d775c6d8258a1485f52cb92b6430e5.jpg" alt="Bild"><br><br>  <b>Die</b> Einstellung von <b>Skalierung / Bias</b> ist die Hauptmethode zum Anpassen des Effekts.  Die besten Einstellungen h√§ngen vom Dynamikbereich des Farbpuffers sowie davon ab, wie d√ºnn das Ergebnis angezeigt werden soll.  Aufgrund der Tatsache, dass die Technik eine Ann√§herung ist, sieht die Subtilit√§t eher besser aus. <br><br><h3>  2. Erzeugung von Linseneffektelementen </h3><br>  <b>Linseneffektelemente</b> neigen dazu, sich um die Bildmitte zu drehen.  Indem wir diesen Effekt simulieren, k√∂nnen wir das Ergebnis der vorherigen Stufe horizontal / vertikal erweitern.  Dies ist in der Phase der Elementgenerierung einfach zu tun, indem die Texturkoordinaten erweitert werden: <br><br><pre> <code class="cpp hljs">vec2 texcoord = -vTexcoords + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre><br>  Dies ist nicht notwendig;  Die Elementgenerierung funktioniert gut mit und ohne.  Das Ergebnis der √Ñnderung der Texturkoordinaten hilft jedoch dabei, den Linseneffekt visuell vom Originalbild zu trennen. <br><br><h4>  Geister </h4><br>  ‚Äû <b>Geister</b> ‚Äú (Geister) wiederholen Glanzlichter, die die hellen Bereiche im Farbpuffer reflektieren und sich relativ zur Bildmitte entfalten.  Der Ansatz, den ich generiert habe, besteht darin, einen Vektor vom aktuellen Pixel in die Mitte des Bildschirms zu bringen und dann mehrere Auswahlen entlang dieses Vektors zu treffen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/305/a06/097/305a06097b4e8ea7917a3635eb28f308.jpg" alt="Bild"><br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; uniform <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uGhosts; <span class="hljs-comment"><span class="hljs-comment">// number of ghost samples uniform float uGhostDispersal; // dispersion factor noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec2 texcoord = -vTexcoord + vec2(1.0); vec2 texelSize = 1.0 / vec2(textureSize(uInputTex, 0)); // ghost vector to image centre: vec2 ghostVec = (vec2(0.5) - texcoord) * uGhostDispersal; // sample ghosts: vec4 result = vec4(0.0); for (int i = 0; i &lt; uGhosts; ++i) { vec2 offset = fract(texcoord + ghostVec * float(i)); result += texture(uInputTex, offset); } fResult = result; }</span></span></code> </pre><br>  Beachten Sie, dass ich <i>Fract () verwende,</i> um sicherzustellen, dass die Texturkoordinaten <i>umlaufen</i> .  Entsprechend k√∂nnen Sie den Wrap-Modus <i>GL_REPEAT</i> f√ºr die Textur verwenden. <br><br>  Hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/204/502/804/204502804fdf82167d0748821d8bac72.jpg" alt="Bild"><br><br>  Sie k√∂nnen das Ergebnis verbessern, indem Sie nur helle Bereiche n√§her an der Bildmitte zulassen, um Geisterbilder zu erzeugen.  Wir k√∂nnen dies erreichen, indem wir Gewichte hinzuf√ºgen, die von der Mitte f√ºr Proben abnehmen: <br><br><pre> <code class="cpp hljs">vec4 result = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; uGhosts; ++i) { vec2 offset = fract(texcoord + ghostVec * <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(i)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) - offset) / length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)); weight = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - weight, <span class="hljs-number"><span class="hljs-number">10.0</span></span>); result += texture(uInputTex, offset) * weight; }</code> </pre><br>  Die Gewichtsfunktion ist so einfach wie m√∂glich - linear.  Der Grund, warum wir das Gewicht innerhalb der Schleife berechnen, ist, dass die hellen Bereiche in der Mitte des Eingabebilds Geister in die R√§nder ‚Äûwerfen‚Äú k√∂nnen, die hellen Bereiche an den R√§ndern jedoch keine Geister in die Mitte werfen k√∂nnen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/c83/d61/0bdc83d61fc9195c6578bd37145d3aed.jpg" alt="Bild"><br><br>  Die letzte Verbesserung ist die radiale Farb√§nderung des Geistes gem√§√ü der 1D-Textur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/591/5c9/199/5915c9199899554fd2b545a9e882c5cc.jpg" alt="Bild"><br><br>  Es wird nach dem Zyklus angewendet, um die endg√ºltige Farbe des Geistes zu beeinflussen: <br><br><pre> <code class="cpp hljs">result *= texture(uLensColor, length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) - texcoord) / length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)));</code> </pre><br><h4>  Halos (Lichth√∂fe) </h4><br>  Wenn wir den Vektor wie bei der <b>Geisterberechnung</b> in die Bildmitte bringen, aber die L√§nge des Vektors festlegen, erhalten wir einen weiteren Effekt: Das Originalbild wird radial deformiert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/280/b54/c7d280b54391cc3507c3f3c5cd713078.jpg" alt="Bild"><br>  Wir k√∂nnen dies verwenden, um einen ‚ÄûLichthof‚Äú zu erzeugen, indem wir das Gewicht mit einer Probe multiplizieren und dadurch den Beitrag des deformierten Bildes zu einem Ring begrenzen, dessen Radius von <b>uHaloWidth</b> gesteuert wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// sample halo: vec2 haloVec = normalize(ghostVec) * uHaloWidth; float weight = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5)); weight = pow(1.0 - weight, 5.0); result += texture(uInputTex, texcoord + haloVec) * weight;</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/bad/cdb/40a/badcdb40a06b62ba0732b8fa54fe2f88.jpg" alt="Bild"><br><br><h4>  CHROMATISCHE VERZERRUNG (Farbverzerrung) </h4><br>  Einige Linseneffekte weisen Farbverzerrungen auf, die durch Variationen der Lichtbrechung bei verschiedenen Wellenl√§ngen verursacht werden.  Wir k√∂nnen dies simulieren, indem wir eine Funktion erstellen, die die roten, gr√ºnen und blauen Kan√§le separat mit leicht unterschiedlichen Offsets entlang des Stichprobenvektors ausw√§hlt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textureDistorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( in sampler2D tex, in vec2 texcoord, in vec2 direction, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// direction of distortion in vec3 distortion // per-channel distortion factor ) { return vec3( texture(tex, texcoord + direction * distortion.r).r, texture(tex, texcoord + direction * distortion.g).g, texture(tex, texcoord + direction * distortion.b).b ); }</span></span></span></span></span></span></code> </pre><br>  Es kann als direkter Ersatz f√ºr den Aufruf von <b>textur ()</b> in der vorherigen Liste verwendet werden.  Ich berechne <b>Richtung</b> und <b>Verzerrung</b> wie folgt: <br><br><pre> <code class="cpp hljs">vec2 texelSize = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / vec2(textureSize(uInputTex, <span class="hljs-number"><span class="hljs-number">0</span></span>)); vec3 distortion = vec3(-texelSize.x * uDistortion, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, texelSize.x * uDistortion); vec3 direction = normalize(ghostVec);</code> </pre><br>  Obwohl die Abruffunktion einfach ist, kostet sie x3 Samples aus der Textur, obwohl sie alle <b>cachefreundlich sein</b> sollten, es sei denn, Sie setzen <b>uDistortion</b> auf einen gigantischen Wert. <br><br>  Mit der Erzeugung von Elementen alles.  Hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a8/fea/9e7/2a8fea9e783d8b254d2c738fc3362a45.jpg" alt="Bild"><br><br><h3>  3. Verwischen </h3><br>  Ohne Unsch√§rfe neigen <b>Linseneffektelemente</b> (insbesondere Geister) dazu, das Erscheinungsbild des Bildes beizubehalten.  Durch Hinzuf√ºgen von Unsch√§rfe zu den Linseneffektelementen werden die hohen Frequenzen geschw√§cht und dadurch der Kontrast zum Eingabebild verringert, wodurch wir den Effekt verkaufen k√∂nnen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93f/bad/099/93fbad09987037e5d1fd5aa29441bc5c.jpg" alt="Bild"><br><br>  Ich werde nicht sagen, wie man eine Unsch√§rfe macht;  Sie k√∂nnen dar√ºber in verschiedenen Internetquellen lesen (Gau√üsche Unsch√§rfe). <br><br><h3>  4. Erh√∂hen / mischen Sie mit dem Originalbild </h3><br>  Wir haben also unsere <b>Linseneffektelemente</b> gut verschwommen.  Wie k√∂nnen wir sie mit dem urspr√ºnglichen Quellbild kombinieren?  Es gibt mehrere wichtige √úberlegungen zur gesamten Render-Pipeline: <br><br><ul><li>  Nachfolgende <b>Bewegungsunsch√§rfe</b> oder <b>Sch√§rfentiefe</b> m√ºssen vor dem Kombinieren mit Linseneffekt angewendet werden, damit Linseneffektelemente nicht an diesen Effekten beteiligt sind. </li><li>  Vor jeder <b>Tonabbildung</b> sollte ein <b>Linseneffekt angewendet werden</b> .  Dies ist physikalisch sinnvoll, da <b>Tonemapping</b> die Film- / CMOS-Reaktion auf einfallendes Licht nachahmt, wobei <b>Linseneffekt</b> ein wesentlicher Bestandteil ist. </li></ul><br>  Vor diesem Hintergrund k√∂nnen wir in dieser Phase einige Ma√ünahmen ergreifen, um das Ergebnis zu verbessern: <br><br><h4>  LENS DIRT </h4><br>  Zuerst m√ºssen Sie die <b>Linseneffektelemente</b> mit einer schmutzigen Textur in voller Aufl√∂sung modifizieren (was in Battlefield 3 weit verbreitet ist): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c1/f6a/f9e/6c1f6af9e3c34aeff34a174870c31f74.jpg" alt="Bild"><br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; <span class="hljs-comment"><span class="hljs-comment">// source image uniform sampler2D uLensFlareTex; // input from the blur stage uniform sampler2D uLensDirtTex; // full resolution dirt texture noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec4 lensMod = texture(uLensDirtTex, vTexcoord); vec4 lensFlare = texture(uLensFlareTex, vTexcoord) * lensMod; fResult = texture(uInputTex, vTexcoord) + lensflare; }</span></span></code> </pre><br>  Der Schl√ºssel dazu ist die sehr schmutzige Textur auf den Linsen.  Wenn der Kontrast gering ist, dominieren Linseneffektformen tendenziell das Ergebnis.  Mit zunehmendem Kontrast werden die <b>Linseneffektelemente</b> ged√§mpft, was ein anderes √§sthetisches Erscheinungsbild ergibt und auch einige M√§ngel verbirgt. <br><br><h4>  DIFFRAKTION STARBURST </h4><br>  Als zus√§tzliche Verbesserung k√∂nnen wir die <b>Starburst-</b> Textur verwenden, indem wir sie dem <b>Linsenschmutz</b> hinzuf√ºgen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23b/81b/27e/23b81b27e47a3f5983b649ea0d368edb.jpg" alt="Bild"><br>  Als Textur sieht <b>Starburst</b> nicht sehr gut aus.  Trotzdem k√∂nnen wir die Transformationsmatrix an den Shader √ºbergeben, wodurch wir den <b>Starburst in</b> jedem Frame drehen / deformieren und den gew√ºnschten dynamischen Effekt erzielen k√∂nnen: <br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; <span class="hljs-comment"><span class="hljs-comment">// source image uniform sampler2D uLensFlareTex; // input from the blur stage uniform sampler2D uLensDirtTex; // full resolution dirt texture uniform sampler2D uLensStarTex; // diffraction starburst texture uniform mat3 uLensStarMatrix; // transforms texcoords noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec4 lensMod = texture(uLensDirtTex, vTexcoord); vec2 lensStarTexcoord = (uLensStarMatrix * vec3(vTexcoord, 1.0)).xy; lensMod += texture(uLensStarTex, lensStarTexcoord); vec4 lensFlare = texture(uLensFlareTex, vTexcoord) * lensMod; fResult = texture(uInputTex, vTexcoord) + lensflare; }</span></span></code> </pre><br>  Die <b>uLensStarMatrix-</b> Transformationsmatrix basiert auf dem Wert, der aus der Kameraausrichtung wie folgt erhalten wird: <br><br><pre> <code class="cpp hljs">vec3 camx = cam.getViewMatrix().col(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// camera x (left) vector vec3 camz = cam.getViewMatrix().col(1); // camera z (forward) vector float camrot = dot(camx, vec3(0,0,1)) + dot(camz, vec3(0,1,0));</span></span></code> </pre><br>  Es gibt andere M√∂glichkeiten, den Camrot-Wert zu ermitteln.  Am wichtigsten ist, dass es sich kontinuierlich √§ndert, wenn die Kamera gedreht wird.  Die Matrix selbst ist wie folgt aufgebaut: <br><br><pre> <code class="cpp hljs">mat3 scaleBias1 = ( <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, ); mat3 rotation = ( <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(camrot), -<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(camrot), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(camrot), <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(camrot), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> ); mat3 scaleBias2 = ( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, ); mat3 uLensStarMatrix = scaleBias2 * rotation * scaleBias1;</code> </pre><br>  <b>Skalierungs-</b> und <b>Bias-</b> Matrizen ben√∂tigen Texturursprungsvers√§tze, damit wir den <b>Starburst</b> relativ zur Bildmitte drehen k√∂nnen. <br><br><h2>  Fazit </h2><br>  Also jetzt alles!  Diese Methode zeigt, wie ein relativ vereinfachter Nachbearbeitungsprozess zu einem anst√§ndig aussehenden <b>Linseneffekt f√ºhrt</b> .  Es ist nicht vollst√§ndig fotorealistisch, kann aber bei richtiger Anwendung hervorragende Ergebnisse erzielen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a8/168/c34/8a8168c3447b9f9b97c7c240557e2f32.jpg" alt="Bild"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AjSr0zLBnx8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">UPD</b> <div class="spoiler_text">  Der Autor ver√∂ffentlichte auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> mit geringf√ºgigen Optimierungen. <br>  Der Quellcode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zu sehen. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439408/">https://habr.com/ru/post/de439408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439392/index.html">Die Meisterschaftssaison 2019 ist er√∂ffnet! Das SNA Hackathon Ala ML Boot Camp 8 startet</a></li>
<li><a href="../de439394/index.html">Als Programmierer haben Rechenzentrumskerne geschrieben</a></li>
<li><a href="../de439396/index.html">Setzen Sie das UniFi Controller-Passwort zur√ºck</a></li>
<li><a href="../de439402/index.html">JavaScript: Das gro√üe Ganze gut warum</a></li>
<li><a href="../de439404/index.html">Eine kurze Geschichte des elektronischen √∂ffentlichen Beschaffungswesens in Russland</a></li>
<li><a href="../de439410/index.html">Jeff Hawkins ist endlich bereit, seine Gehirnforschung zu erkl√§ren</a></li>
<li><a href="../de439414/index.html">Client f√ºr "Push Message Server"</a></li>
<li><a href="../de439416/index.html">A-Frame Review Artikel</a></li>
<li><a href="../de439418/index.html">Pentaho Data Integration (PDI), Python und Deep Learning</a></li>
<li><a href="../de439420/index.html">Erstellen eines Transportpakets ohne Installation von MODX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>