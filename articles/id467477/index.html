<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖋️ ✋🏽 🕒 Kubernetes 1.16: Ikhtisar Sorotan 💄 🤜🏼 ⏰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, pada hari Rabu, rilis Kubernetes berikutnya akan diadakan - 1.16. Menurut tradisi yang telah dikembangkan untuk blog kita, untuk kesepuluh k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.16: Ikhtisar Sorotan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/467477/"><img src="https://habrastorage.org/webt/6b/oi/xq/6boixq7wqypazw43aysbw8y9xty.png"><br><br>  Hari ini, pada hari Rabu, rilis Kubernetes berikutnya <a href="">akan diadakan</a> - 1.16.  Menurut tradisi yang telah dikembangkan untuk blog kita, untuk kesepuluh kalinya, kita berbicara tentang perubahan paling signifikan dalam versi baru. <br><br>  Informasi yang digunakan untuk mempersiapkan bahan ini diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel pelacakan perangkat tambahan Kubernet</a> , <a href="">CHANGELOG-1.16</a> dan masalah terkait, permintaan tarik, serta Kubernetes Enhancement Proposals (KEP).  Jadi ayo pergi! .. <a name="habracut"></a><br><br><h2>  Simpul </h2><br>  Sejumlah besar inovasi penting (dalam status versi alfa) disajikan di sisi node-cluster K8s (Kubelet). <br><br>  Pertama, apa yang disebut <b>" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wadah ephemeral</a> " <i>(Ephemeral Containers)</i></b> disajikan <b>, dirancang untuk menyederhanakan proses debugging di pod</b> .  Mekanisme baru memungkinkan Anda untuk menjalankan wadah khusus yang dimulai di namespace pod yang ada dan hidup untuk waktu yang singkat.  Tujuannya adalah untuk berinteraksi dengan pod dan wadah lain untuk menyelesaikan masalah dan debugging.  Untuk fitur ini, perintah <code>kubectl debug</code> baru <code>kubectl debug</code> , intinya mirip dengan <code>kubectl exec</code> : hanya alih-alih memulai proses dalam wadah (seperti dalam kasus <code>exec</code> ) itu mulai kontainer di pod.  Misalnya, perintah seperti itu akan menghubungkan wadah baru ke pod: <br><br><pre> <code class="bash hljs">kubectl debug -c debug-shell --image=debian target-pod -- bash</code> </pre> <br>  Rincian tentang wadah sementara (dan contoh penggunaannya) dapat ditemukan di <a href="">KEP terkait</a> .  Implementasi saat ini (dalam K8 1.16) adalah versi alpha, dan di antara kriteria untuk transfernya ke versi beta adalah "menguji API Wadah Ephemeral untuk setidaknya 2 rilis [Kubernetes]". <br><br>  <i><b>NB</b> : Intinya dan bahkan nama fitur menyerupai plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubectl-debug yang</a> sudah ada, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tulis</a> .</i>  <i>Diasumsikan bahwa dengan munculnya wadah sementara, pengembangan plug-in eksternal yang terpisah akan berhenti.</i> <br><br>  Inovasi lain, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PodOverhead</code></a> dirancang untuk menyediakan <b>mekanisme untuk menghitung biaya overhead pod</b> , yang dapat sangat bervariasi tergantung pada runtime yang digunakan.  Sebagai contoh, penulis <a href="">KEP ini</a> mengutip Kata Containers, yang mengharuskan peluncuran kernel tamu, agen kata, sistem init, dll.  Ketika biaya overhead menjadi begitu besar, itu tidak dapat diabaikan, yang berarti bahwa cara diperlukan untuk memperhitungkan kuota, perencanaan, dll.  Untuk mengimplementasikannya, bidang <code>Overhead *ResourceList</code> telah ditambahkan ke <code>PodSpec</code> (dibandingkan dengan data di <code>RuntimeClass</code> , jika digunakan). <br><br>  Inovasi penting lainnya adalah <i>Node Topology Manager</i> , yang dirancang untuk menyatukan pendekatan untuk menyempurnakan alokasi sumber daya perangkat keras untuk berbagai komponen di Kubernetes.  Inisiatif ini disebabkan oleh meningkatnya permintaan berbagai sistem modern (dari bidang telekomunikasi, pembelajaran mesin, layanan keuangan, dll.) Untuk komputasi paralel berkinerja tinggi dan meminimalkan penundaan dalam menjalankan operasi, di mana mereka menggunakan kemampuan canggih CPU dan akselerasi perangkat keras.  Optimalisasi di Kubernetes sejauh ini telah dicapai berkat komponen yang berbeda (manajer CPU, Manajer perangkat, CNI), dan sekarang mereka akan menambahkan antarmuka internal tunggal yang menyatukan pendekatan dan menyederhanakan koneksi komponen baru yang serupa - yang disebut topologi-sadar - di sisi Kubelet.  Detail ada di <a href="">KEP terkait</a> . <br><br><img src="https://habrastorage.org/webt/tq/bs/vr/tqbsvryzr9tnxv_9uldn-ofx1es.png"><br>  <i>Diagram Komponen Manajer Topologi</i> <br><br>  Fitur selanjutnya adalah <b>memeriksa wadah selama startup <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyelidikan startup</a> )</i></b> .  Seperti yang Anda ketahui, untuk wadah yang beroperasi untuk waktu yang lama, sulit untuk mendapatkan status saat ini: mereka "terbunuh" sebelum dimulainya operasi, atau berakhir di jalan buntu untuk waktu yang lama.  Pemeriksaan baru (diaktifkan melalui gerbang fitur yang disebut <code>StartupProbeEnabled</code> ) membatalkan - atau lebih tepatnya, <code>StartupProbeEnabled</code> - tindakan pemeriksaan lainnya hingga saat pod selesai peluncurannya.  Untuk alasan ini, fitur ini awalnya disebut <a href="">pod-startup liveness-probe holdoff</a> .  Untuk pod yang membutuhkan waktu lama untuk memulai, Anda dapat memilih status dalam interval waktu yang relatif singkat. <br><br>  Selain itu, segera dalam status beta peningkatan untuk RuntimeClass ditambahkan, menambahkan dukungan untuk "cluster heterogen".  Dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwalan RuntimeClass,</a> sekarang tidak perlu untuk setiap node memiliki dukungan untuk setiap RuntimeClass: untuk pod, Anda dapat memilih RuntimeClass tanpa memikirkan topologi cluster.  Sebelumnya, untuk mencapai ini - agar pod muncul di node dengan dukungan untuk semua yang mereka butuhkan - mereka harus menetapkan aturan yang sesuai untuk NodeSelector dan toleransi.  <a href="">KEP</a> berbicara tentang contoh penggunaan dan, tentu saja, detail implementasi. <br><br><h2>  Jaringan </h2><br>  Dua fitur jaringan signifikan yang pertama kali muncul (dalam versi alpha) di Kubernetes 1.16 adalah: <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan untuk</a> tumpukan jaringan ganda - IPv4 / IPv6</b> - dan "pemahaman" terkait di tingkat pod, node, layanan.  Ini termasuk interaksi IPv4-ke-IPv4 dan IPv6-ke-IPv6 antara pod, dari pod ke layanan eksternal, implementasi referensi (dalam kerangka Bridge CNI, PTP CNI dan plug-in IPAM Host-Lokal), serta sebaliknya Kompatibel dengan kluster Kubernet yang hanya berfungsi pada IPv4 atau IPv6.  Detail implementasi ada di <a href="">KEP</a> . <br><br>  Contoh output dari dua jenis alamat IP (IPv4 dan IPv6) dalam daftar pod: <br><br><pre> <code class="bash hljs">kube-master<span class="hljs-comment"><span class="hljs-comment"># kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE nginx-controller 1/1 Running 0 20m fd00:db8:1::2,192.168.1.3 kube-minion-1 kube-master#</span></span></code> </pre> <br></li><li>  <b>API baru untuk Endpoint</b> adalah <a href="">API EndpointSlice</a> .  Ini memecahkan masalah API Endpoint yang ada dengan kinerja / skalabilitas yang memengaruhi berbagai komponen dalam bidang kontrol (apiserver, etcd, endpoint-controller, kube-proxy).  API baru akan ditambahkan ke grup Discovery API dan akan dapat melayani puluhan ribu titik akhir backend pada setiap layanan dalam sebuah cluster yang terdiri dari seribu node.  Untuk melakukan ini, setiap Layanan dipetakan ke objek N <code>EndpointSlice</code> , yang masing-masing secara default memiliki tidak lebih dari 100 titik akhir (nilainya dapat dikonfigurasi).  API EndpointSlice juga akan memberikan peluang untuk pengembangannya di masa depan: dukungan untuk beberapa alamat IP untuk setiap pod, status baru untuk titik akhir (tidak hanya <code>Ready</code> dan <code>NotReady</code> ), subset dinamis untuk titik akhir. </li></ul><br>  <a href="">Finalizer yang</a> disajikan dalam rilis terakhir disebut <code>service.kubernetes.io/load-balancer-cleanup</code> dan dilampirkan ke setiap layanan dengan tipe <code>LoadBalancer</code> maju ke versi beta.  Pada saat penghapusan layanan seperti itu, ia mencegah penghapusan sumber daya yang sebenarnya sampai "pembersihan" semua sumber daya yang sesuai dari penyeimbang selesai. <br><br><h2>  Mesin API </h2><br>  "Tonggak stabilisasi" yang sebenarnya telah diperbaiki di area server API Kubernetes dan berinteraksi dengannya.  Dalam banyak hal, ini terjadi karena <b>transfer ke status stabil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CustomResourceDefinitions</a> (CRD)</b> yang <b>tidak memerlukan presentasi khusus</b> , yang berstatus beta sejak Kubernetes 1.7 yang jauh (dan ini adalah Juni 2017!).  Stabilisasi yang sama datang ke fitur yang berkaitan dengan mereka: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Subresources"</a> dengan <code>/status</code> dan <code>/scale</code> untuk CustomResources; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konversi</a> versi untuk CRD, berdasarkan pada webhook eksternal; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baru-baru ini diperkenalkan</a> (dalam K8s 1.15) nilai-nilai default <i>(default)</i> dan penghapusan bidang otomatis <i>(pemangkasan)</i> untuk CustomResources; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemungkinan</a> menggunakan skema OpenAPI v3 untuk membuat dan menerbitkan dokumentasi OpenAPI yang digunakan untuk memvalidasi sumber daya CRD di sisi server. </li></ul><br>  Mekanisme lain yang telah lama dikenal oleh administrator Kubernetes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>webhook masuk</b></a> - juga telah dalam status beta untuk waktu yang lama (sejak K8 1.9) dan sekarang telah dinyatakan stabil. <br><br>  Dua fitur lainnya mencapai beta: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sisi server berlaku</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat bookmark</a> . <br><br>  Dan satu-satunya inovasi signifikan dalam versi alpha adalah <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penolakan</a> <code>SelfLink</code></b> - URI khusus yang mewakili objek yang ditentukan dan merupakan bagian dari <code>ObjectMeta</code> dan <code>ListMeta</code> (mis., Bagian dari objek apa pun di Kubernetes).  Kenapa menolaknya?  Motivasi "sederhana" <a href="">terdengar</a> seperti tidak adanya alasan yang nyata (tidak dapat diatasi) untuk bidang ini terus ada.  Alasan yang lebih formal adalah untuk mengoptimalkan kinerja (menghapus bidang yang tidak perlu) dan menyederhanakan pekerjaan apiserver generik, yang dipaksa untuk memproses bidang tersebut dengan cara khusus (ini adalah satu-satunya bidang yang ditetapkan tepat sebelum objek tersebut serial).  "Usang" nyata (dalam versi beta) dari <code>SelfLink</code> akan terjadi pada Kubernetes versi 1.20, dan yang terakhir - 1.21. <br><br><h2>  Penyimpanan data </h2><br>  Pekerjaan utama di bidang penyimpanan, seperti dalam rilis sebelumnya, diamati di bidang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan untuk CSI</a> .  Perubahan utama di sini adalah: <br><br><ul><li>  untuk pertama kalinya (dalam versi alpha) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> <b>dukungan untuk plug-in CSI untuk node kerja Windows telah muncul</b> : cara saat ini untuk bekerja dengan repositori akan menggantikan plug-in di pohon di inti Kubernetes dan plug-in FlexVolume berbasis Powershell dari Microsoft; <br><br><img src="https://habrastorage.org/webt/4_/6o/h2/4_6oh2zuutje1tcvwqwzhi385m0.png"><br>  <i>Skema Implementasi Plugin Kubernetes Windows CSI</i> <br></li><li>  kemampuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk mengubah ukuran volume CSI</a> , diperkenalkan dalam K8 1.12, telah berkembang ke versi beta; </li><li>  kemungkinan menggunakan CSI untuk membuat volume ephemeral lokal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan Volume Inline CSI</a> ) telah mencapai "peningkatan" yang serupa (dari alpha ke beta). </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi untuk volume kloning yang</a> muncul di versi Kubernetes sebelumnya (menggunakan PVC yang ada sebagai <code>DataSource</code> untuk membuat PVC baru) juga sekarang telah menerima status beta. <br><br><h2>  Perencana </h2><br>  Dua perubahan penting dalam perencanaan (keduanya dalam versi alpha): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>EvenPodsSpreading</code></a> adalah kemampuan untuk <b>menggunakan</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>EvenPodsSpreading</code></a> <b>untuk "mendistribusikan secara adil" banyak unit alih-alih unit logis aplikasi</b> (seperti Deployment dan ReplicaSet) dan menyesuaikan distribusi ini (sebagai persyaratan ketat atau sebagai kondisi ringan, mis. Prioritas).  Fitur ini akan memperluas kapabilitas distribusi yang ada dari pod yang direncanakan, sekarang dibatasi oleh opsi <code>PodAffinity</code> dan <code>PodAntiAffinity</code> , memberikan administrator kontrol yang lebih baik dalam hal ini, yang berarti aksesibilitas yang lebih baik dan konsumsi sumber daya yang dioptimalkan.  Detailnya ada di <a href="">KEP</a> . </li><li>  Menggunakan <i>Kebijakan BestFit</i> dalam <i>Fungsi Prioritas RequestedToCapacityRatio</i> selama penjadwalan pod, yang memungkinkan <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengemasan bin</a></b> ("pengemasan dalam wadah") untuk digunakan baik untuk sumber daya inti (prosesor, memori) dan diperluas (seperti GPU).  Lihat <a href="">KEP untuk</a> lebih jelasnya. <br><br><img src="https://habrastorage.org/webt/4z/gx/zm/4zgxzmdtmhyg-mmjnw-cccyw8wq.gif"><br>  <i>Penjadwalan pod: sebelum menggunakan kebijakan yang paling sesuai (langsung melalui penjadwal default) dan menggunakannya (melalui penjadwal penjadwal)</i> </li></ul><br>  Selain itu, kesempatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disajikan</a> untuk membuat plugin Anda sendiri untuk penjadwal di luar pohon pengembangan Kubernetes utama (out-of-tree). <br><br><h2>  Perubahan lainnya </h2><br>  Juga dalam rilis Kubernetes 1.16, Anda dapat mencatat <b>inisiatif untuk <a href="">membawa</a> metrik yang ada dalam urutan penuh</b> , atau lebih tepatnya, sesuai dengan <a href="">persyaratan resmi</a> untuk instrumentasi K8.  Mereka pada dasarnya mengandalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi Prometheus yang</a> relevan.  Ketidakkonsistenan terbentuk karena berbagai alasan (misalnya, beberapa metrik dibuat sebelum instruksi saat ini muncul), dan para pengembang memutuskan bahwa sudah waktunya untuk membawa semuanya ke standar tunggal, "sejalan dengan seluruh ekosistem Prometheus."  Implementasi inisiatif ini saat ini memiliki status versi alpha, yang secara bertahap akan meningkat di versi masa depan Kubernetes menjadi beta (1,17) dan stabil (1,18). <br><br>  Selain itu, perubahan berikut dapat dicatat: <br><br><ul><li>  <b>Pengembangan dukungan Windows</b> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">munculnya</a> utilitas Kubeadm untuk OS ini (versi alpha), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemungkinan</a> <code>RunAsUserName</code> untuk wadah Windows (versi alpha), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peningkatan</a> dukungan untuk Akun Layanan Grup yang Dikelola (gMSA) ke versi beta, pasang / pasang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan</a> untuk volume vSphere. </li><li>  <b>Mekanisme kompresi data yang</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dirancang ulang</a> <b>dalam respons API</b> .  Sebelumnya, filter HTTP digunakan untuk tujuan ini, yang memberlakukan sejumlah pembatasan yang mencegah penyertaannya secara default.  Sekarang "kompresi permintaan transparan" berfungsi: klien yang mengirim <code>Accept-Encoding: gzip</code> di header menerima respons terkompresi di GZIP jika ukurannya melebihi 128 Kb.  Klien on Go secara otomatis mendukung kompresi (mengirim tajuk yang diinginkan), sehingga mereka segera melihat penurunan traffic.  (Untuk bahasa lain, modifikasi minor mungkin diperlukan.) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menjadi mungkin untuk</a> <b>menskala HPA dari / ke nol polong berdasarkan metrik eksternal</b> .  Jika penskalaan didasarkan pada objek / metrik eksternal, maka ketika beban kerja idle, Anda dapat secara otomatis skala ke 0 replika untuk menghemat sumber daya.  Fitur ini harus sangat berguna untuk kasus-kasus ketika pekerja meminta sumber daya GPU, dan jumlah berbagai jenis pekerja menganggur melebihi jumlah GPU yang tersedia. </li><li>  Klien baru - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>k8s.io/client-go/metadata.Client</code></a> - untuk akses "umum" ke objek.  Ia dirancang untuk dengan mudah memperoleh metadata (mis., Subbagian <code>metadata</code> ) dari sumber daya cluster dan melakukan operasi bersamanya dari kategori pengumpulan sampah dan kuota. </li><li>  Kubernet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekarang dapat dibangun</a> tanpa penyedia cloud yang ketinggalan jaman ("built-in") (versi alpha). </li><li>  Kemampuan eksperimental (versi alpha) untuk menerapkan tambalan khusus selama <code>init</code> , <code>join</code> dan <code>upgrade</code> operasi telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditambahkan ke</a> utilitas kubeadm.  Untuk detail tentang cara menggunakan <code>--experimental-kustomize</code> , lihat <a href="">KEP</a> . </li><li>  Titik akhir baru untuk apiserver adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>readyz</code></a> , yang memungkinkan Anda untuk mengekspor informasi kesiapan.  Server API juga memiliki flag <code>--maximum-startup-sequence-duration</code> , yang memungkinkan Anda untuk menyesuaikan restart. </li><li>  Dua <b>fitur untuk Azure</b> dinyatakan stabil: Dukungan untuk Zona Ketersediaan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup lintas sumber daya</a> (RG).  Selain itu, Azure menambahkan: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan otentikasi</a> AAD dan ADFS </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">service annotation.beta.kubernetes.io/azure-pip-name</a> untuk menentukan IP publik dari load balancer; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kemampuan untuk</a> mengonfigurasi <code>LoadBalancerName</code> dan <code>LoadBalancerResourceGroup</code> . </li></ul></li><li>  AWS memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan</a> untuk EBS di Windows dan panggilan EC2 API yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dioptimalkan</a> <code>DescribeInstances</code> . </li><li>  Kubeadm sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memigrasikan</a> konfigurasi CoreDNS-nya sendiri ketika meningkatkan ke CoreDNS. </li><li>  Binari, <b>dll,</b> dalam gambar Docker yang sesuai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjadikannya</a> dapat dieksekusi-dunia, yang memungkinkan Anda untuk menjalankan gambar ini tanpa memerlukan hak akses root.  Selain itu, gambar migrasi etcd telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjatuhkan</a> dukungan untuk versi etcd2. </li><li>  <a href="">Cluster Autoscaler 1.16.0</a> beralih menggunakan distroless sebagai gambar dasar, meningkatkan kinerja, dan menambahkan penyedia cloud baru (DigitalOcean, Magnum, Packet). </li><li>  Pembaruan dalam perangkat lunak yang digunakan / tergantung: Go 1.12.9, etcd 3.3.15, CoreDNS 1.6.2. </li></ul><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes 1.15: Tinjauan Umum atas Inovasi Kunci</a> ”; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes 1.14: Tinjauan Umum tentang Inovasi Kunci</a> ”; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes 1.13: Tinjauan Umum tentang Inovasi Kunci</a> ”; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes 1.12: Gambaran Umum Inovasi-inovasi Utama</a> .” </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467477/">https://habr.com/ru/post/id467477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467463/index.html">Hanya divisi, atau cara membuat teori matematika dan dapatkan $ 400K di atasnya. Seri Tiga, Final</a></li>
<li><a href="../id467465/index.html">Apakah cloud akan menyimpan smartphone ultra-anggaran</a></li>
<li><a href="../id467471/index.html">Jiwa Mikrotik terhadap ILV berjiwa dan penyedia yang sama</a></li>
<li><a href="../id467473/index.html">Dan lebih banyak tentang macam-macam</a></li>
<li><a href="../id467475/index.html">Kembalikan Thread.Abort () ke .NET Core. Pengiriman aplikasi dengan versi CoreCLR dan CoreFX</a></li>
<li><a href="../id467479/index.html">Kir Shatrov: Shopify dimulai dengan Rails dan di sini mereka dengan tulus menyukai kerangka ini.</a></li>
<li><a href="../id467485/index.html">Pemecahan masalah dengan kalkulator pwnable.kr 23 - md5. Kami berurusan dengan Stack Canary. Menghubungkan C library dengan python</a></li>
<li><a href="../id467487/index.html">Tentang masa depan pembayaran blockchain dan cryptocurrency</a></li>
<li><a href="../id467489/index.html">Mereka adalah variabel statis aneh di PHP</a></li>
<li><a href="../id467493/index.html">Bagaimana menjadi kurang dapat diakses oleh penyerang potensial di Internet. Pengalaman dan pengamatan pribadi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>