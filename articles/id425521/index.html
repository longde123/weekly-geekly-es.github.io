<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßõ üêæ üë©üèø‚Äçü§ù‚Äçüë®üèª Metode yang Dilindungi dalam JavaScript ES5 üë±üèø üöà üî∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak artikel bagus telah ditulis tentang model objek dalam JavaScript. Dan tentang berbagai cara untuk membuat anggota kelas privat di Internet penu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode yang Dilindungi dalam JavaScript ES5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425521/">  Banyak artikel bagus telah ditulis tentang model objek dalam JavaScript.  Dan tentang berbagai cara untuk membuat anggota kelas privat di Internet penuh dengan deskripsi yang layak.  Tetapi tentang metode yang dilindungi - hanya ada sedikit data.  Saya ingin mengisi celah ini dan memberi tahu bagaimana Anda dapat membuat metode yang dilindungi tanpa pustaka di JavaScript ECMAScript 5 murni. <br><br>  Dalam artikel ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa anggota kelas yang dilindungi diperlukan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang Anda butuhkan untuk memahami metode yang disajikan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helper Class ProtectedError</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi anggota yang dilindungi (metode dan properti) untuk kelas yang dinyatakan sebagai fungsi (ECMAScript 5)</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke repositori git-hub dengan kode sumber dan tes.</a> <a name="habracut"></a><br><br><h2>  Mengapa anggota kelas yang dilindungi diperlukan </h2><br>  Singkatnya, kalau begitu <br><br><ul><li>  lebih mudah untuk memahami operasi kelas dan menemukan kesalahan di dalamnya.  (Anda dapat segera melihat dalam kasus mana anggota kelas digunakan. Jika pribadi, maka Anda hanya perlu menganalisis kelas ini, baik, dan jika dilindungi, maka hanya kelas ini dan yang diturunkan.) </li><li>  lebih mudah mengelola perubahan.  (Misalnya, Anda dapat menghapus anggota pribadi tanpa takut akan terjadi sesuatu di luar kelas yang dapat diedit.) </li><li> jumlah aplikasi dalam pelacak bug berkurang, karena  pengguna perpustakaan atau kontrol dapat "menjahit" anggota "pribadi" kami, yang kami putuskan untuk hapus dalam versi baru kelas, atau mengubah logika pekerjaan mereka. </li><li>  Dan secara umum, anggota kelas yang dilindungi adalah alat desain.  Sangat baik untuk membuatnya berguna dan teruji dengan baik. </li></ul><br>  Biarkan saya mengingatkan Anda bahwa ide utama anggota yang dilindungi adalah untuk menyembunyikan metode dan properti dari pengguna instance kelas, tetapi pada saat yang sama memungkinkan kelas turunan memiliki akses ke mereka. <br><br>  Menggunakan TypeScript tidak akan memungkinkan pemanggilan metode yang dilindungi, setelah kompilasi dalam JavaScript, semua anggota pribadi dan yang dilindungi menjadi publik.  Misalnya, kami mengembangkan kontrol atau pustaka yang akan dipasang pengguna di situs atau aplikasi mereka.  Para pengguna ini akan dapat melakukan apa pun yang mereka inginkan dengan anggota yang dilindungi, melanggar integritas kelas.  Akibatnya, pelacak bug kami penuh dengan keluhan bahwa perpustakaan atau kontrol kami tidak berfungsi dengan baik.  Kami menghabiskan waktu dan upaya untuk mengatasinya - <i>"Apakah ini objeknya dalam keadaan klien, yang menyebabkan kesalahan?!"</i>  .  Oleh karena itu, untuk membuat hidup lebih mudah bagi semua orang, perlindungan semacam itu diperlukan yang tidak akan memungkinkan untuk mengubah makna anggota kelas yang privat dan terlindungi. <br><br><h2>  Apa yang dibutuhkan untuk memahami metode yang dimaksud </h2><br>  Untuk memahami metode mendeklarasikan anggota kelas yang dilindungi, Anda membutuhkan pengetahuan yang kuat: <br><br><ul><li>  kelas dan objek perangkat dalam JavaScript. </li><li>  cara membuat anggota kelas privat (setidaknya melalui penutupan). </li><li>  metode Object.defineProperty dan Object.getOwnPropertyDescriptor </li></ul><br>  Tentang model perangkat dalam JavaScript, saya dapat merekomendasikan, misalnya, artikel yang sangat baik oleh Andrey Akinshin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">DreamWalker</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Memahami OOP di JS [Bagian No. 1]"</a> . <br>  Tentang properti pribadi ada yang bagus dan, menurut saya, deskripsi yang cukup lengkap tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebanyak 4 cara berbeda untuk membuat anggota kelas privat</a> di situs web MDN. <br><br>  Adapun metode Object.defineProperty, itu akan memungkinkan kita untuk menyembunyikan properti dan metode dari for-in loop, dan, sebagai akibatnya, dari algoritma serialisasi: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(MyClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedNumber'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.publicNumber = <span class="hljs-number"><span class="hljs-number">25</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prop <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj1){ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'property:'</span></span> prop); <span class="hljs-comment"><span class="hljs-comment">//prop     'protectedNumber' } console.log(JSON.stringify(obj1)); //  { 'publicNumber': 25 }</span></span></code> </pre> <br>  Penyembunyian seperti itu harus dilakukan, tetapi ini, tentu saja, tidak cukup karena  Masih ada kemungkinan untuk memanggil metode / properti secara langsung: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1.protectedNumber); <span class="hljs-comment"><span class="hljs-comment">//  12.</span></span></code> </pre><br><h2>  Helper Class ProtectedError </h2><br>  Pertama, kita membutuhkan kelas ProtectedError, yang mewarisi dari Kesalahan, dan yang akan dilempar jika tidak ada akses ke metode atau properti yang dilindungi. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProtectedError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = <span class="hljs-string"><span class="hljs-string">"Encapsulation error, the object member you are trying to address is protected."</span></span>; } ProtectedError.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); ProtectedError.prototype.constructor = ProtectedError;</code> </pre><br><h2>  Menerapkan anggota kelas yang dilindungi di ES5 </h2><br>  Sekarang kita memiliki kelas ProtectedError dan kita mengerti apa yang Object.defineProperty lakukan dengan nilai yang dapat dihitung: false, mari kita menganalisis penciptaan kelas dasar yang ingin berbagi metode protectedMethod dengan semua kelas turunannya, tetapi sembunyikan dari orang lain: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,        /** @summary       */ function checkAccess() { if (!(this instanceof BaseClass)) throw new ProtectedError(); if (this.constructor === BaseClass) throw new ProtectedError() } Object.defineProperty(_self, 'protectedMethod', { enumerable: false, //    for-in  configurable:false, //     value: function(){ //   , ,          Base,     checkAccess.call(this); //  . protectedMethod(); } }); function protectedMethod(){ //       , //       this,   _self return 'example value'; } this.method = function (){ protectedMethod(); //          BaseClass //this.protectedMethod(); //   , ..      ProtectedError } }</span></span></code> </pre><br><h3>  Deskripsi konstruktor kelas BaseClass </h3><br>  Mungkin Anda akan bingung dengan cek: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass();</code> </pre>  Tes ini adalah "amatir".  Anda dapat menghapusnya, itu tidak ada hubungannya dengan metode yang dilindungi.  Namun, saya pribadi membiarkannya di kode saya, karena  itu diperlukan untuk kasus-kasus ketika instance kelas tidak dibuat dengan benar, yaitu  tanpa kata kunci baru.  Misalnya, seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = BaseClass(); <span class="hljs-comment"><span class="hljs-comment">//  : var obj2 = BaseClass.call({});</span></span></code> </pre><br>  Dalam kasus seperti itu, lakukan yang Anda inginkan.  Anda dapat, misalnya, menghasilkan kesalahan: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong instance creation. Maybe operator "new" was forgotten'</span></span>);</code> </pre><br>  Atau Anda cukup instantiate dengan benar, seperti yang dilakukan pada BaseClass. <br><br>  Selanjutnya, kita menyimpan instance baru dalam variabel _self (mengapa saya perlu menjelaskan ini nanti). <br><br><h3>  Deskripsi properti publik bernama protectedMethod </h3><br>  Memasuki metode ini, kami memanggil pemeriksaan konteks tempat kami dipanggil.  Lebih baik untuk memeriksa dalam metode terpisah, misalnya, checkAccess, karena  pemeriksaan yang sama akan diperlukan dalam semua metode dan properti kelas yang dilindungi.  Jadi, pertama-tama, periksa jenis panggilan untuk konteks ini.  Jika ini memiliki tipe selain BaseClass, maka jenisnya bukan BaseClass itu sendiri maupun turunannya.  Kami melarang panggilan semacam itu. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  Bagaimana ini bisa terjadi?  Misalnya, seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someObject = {}; b.protectedMethod.call(someObject); <span class="hljs-comment"><span class="hljs-comment">//   ,  protectedMethod this   someObject    , .. someObject instanceof BaseClass  </span></span></code> </pre><br>  Dalam kasus kelas turunan, ekspresi instanceClassClass ini akan benar.  Tetapi untuk instance BaseClass, ekspresi BaseClass instance ini akan benar.  Oleh karena itu, untuk membedakan instance dari kelas BaseClass dari instance kelas turunan, kami memeriksa konstruktor.  Jika konstruktor cocok dengan BaseClass, maka protectedMethod kami dipanggil pada instance BaseClass, seperti metode publik biasa: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); b.protectedMethod();</code> </pre><br>  Kami melarang panggilan semacam itu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === BaseClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  Selanjutnya adalah panggilan metode tertutup protectedMethod, yang, pada kenyataannya, adalah metode yang kami lindungi.  Di dalam metode, jika Anda perlu merujuk ke anggota kelas BaseClass, Anda dapat melakukan ini menggunakan instance _self yang tersimpan.  Inilah yang _self diciptakan untuk memiliki akses ke anggota kelas dari semua metode pribadi / pribadi.  Oleh karena itu, jika Anda tidak perlu mengakses anggota kelas dalam metode atau properti yang dilindungi, maka Anda tidak dapat membuat variabel _self. <br><br><h3>  Memanggil metode yang dilindungi di dalam kelas BaseClass </h3><br>  Di dalam kelas BaseClass, protectedMethod harus diakses hanya dengan nama, bukan melalui ini.  Kalau tidak, di dalam protectedMethod kita tidak bisa membedakan apakah kita dipanggil sebagai metode publik atau dari dalam suatu kelas.  Dalam hal ini, penutupan menghemat kita - protectedMethod berperilaku seperti metode pribadi biasa, ditutup di dalam kelas dan hanya terlihat dalam lingkup fungsi BaseClass. <br><br><h3>  DerivedClass Derived Class Description </h3><br>  Sekarang mari kita lihat kelas turunan dan bagaimana membuatnya dapat diakses oleh metode yang dilindungi dari kelas dasar. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.protectedMethod.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">/** @summary       */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError(); } <span class="hljs-comment"><span class="hljs-comment">//     Object.defineProperty(this, 'protectedMethod', { enumerable: false, // ..       this configurable: false,//         for-in  //      value: function(){ checkAccess.call(_self); return _base.protectedMethod(); } }); //        this.someMethod = function(){ console.log(_base.protectedMethod()); } } DerivedClass.prototype = new BaseClass(); Object.defineProperty(DerivedClass.prototype, 'constructor', { value : DerivedClass, configurable: false });</span></span></code> </pre><br><h3>  Deskripsi konstruktor kelas turunan </h3><br>  Di kelas turunan, kita membuat objek _base di mana kita menempatkan referensi ke metode protectedMethod dari kelas dasar, ditutup ke konteks kelas turunan melalui metode bind standar.  Ini berarti memanggil _base.protectedMethod ();  di dalam protectedMethod ini bukan objek _base, tetapi turunan dari kelas DerivedClass. <br><br><h3>  Deskripsi Metode ProtectedMethod Di dalam DerivedClass </h3><br>  Di kelas DerivedClass, perlu untuk mendeklarasikan metode publik protectedMethod dengan cara yang sama seperti yang kami lakukan di kelas dasar melalui Object.defineProperty dan memeriksa akses di dalamnya dengan memanggil metode checkAccess atau dengan memeriksa langsung dalam metode: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedMethod'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _base.protectedMethod(); } });</code> </pre><br>  Kami memeriksa - <i>"tetapi apakah kita telah dipanggil sebagai metode publik yang sederhana?"</i>  Untuk contoh kelas DerivedClass, konstruktor akan sama dengan DerivedClass.  Jika demikian, maka hasilkan kesalahan.  Kalau tidak, kami mengirimnya ke kelas dasar dan itu sudah akan melakukan semua pemeriksaan lainnya. <br><br>  Jadi, di kelas turunan, kami memiliki dua fungsi.  Satu dideklarasikan melalui Object.defineProperty dan diperlukan untuk kelas turunan DerivedClass.  Ini publik dan karenanya memiliki cek yang melarang panggilan publik.  Metode kedua terletak di objek _base, yang ditutup di dalam kelas DerivedClass dan karenanya tidak terlihat oleh siapa pun dari luar dan digunakan untuk mengakses metode yang dilindungi dari semua metode DerivedClass. <br><br><h3>  Perlindungan Properti </h3><br>  Dengan properti, pekerjaan terjadi sedikit berbeda.  Properti di BaseClass didefinisikan seperti biasa melalui Object.defineProperty, hanya di getter dan setter Anda pertama-tama perlu menambahkan cek kami, mis.  panggil checkAccess: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _protectedProperty; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _protectedProperty = value; }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); }</code> </pre><br>  Di dalam kelas BaseClass, properti yang dilindungi diakses bukan melalui ini, tetapi ke variabel tertutup _protectedProperty.  Jika penting bagi kita bahwa pengambil dan penyetel bekerja saat menggunakan properti di dalam kelas BaseClass, maka kita perlu membuat metode pribadi getProtectedPropety dan setProtectedProperty, di dalamnya tidak akan ada pemeriksaan, dan mereka seharusnya sudah dipanggil. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getProtectedProperty(); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); setProtectedProperty(value); }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProtectedProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    return _protectedProperty; } function setProtectedProperty(value){ //    _protectedProperty = value; } }</span></span></code> </pre><br>  Di kelas turunan, bekerja dengan properti sedikit lebih rumit, karena  properti tidak dapat diganti oleh konteks.  Oleh karena itu, kita akan menggunakan metode Object.getOwnPropertyDescriptor standar untuk mendapatkan pengambil dan penyetel dari properti kelas dasar sebagai fungsi yang sudah dapat mengubah konteks panggilan: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: _self.protectedMethod.bind(_self), }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _baseProtectedPropertyDescriptor = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(_self, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      _base //    DerivedClass     Object.defineProperty(_base, 'protectedProperty', { get: function() { return _baseProtectedPropertyDescriptor.get.call(_self); }, set: function(value){ _baseProtectedPropertyDescriptor.set.call(_self, value); } }) //      ,      DerivedClass      . Object.defineProperty(_self, 'protectedProperty', { get: function () { checkAccess.call(_self); return base.protectedProperty; }, set: function (value) { checkAccess.call(_self); _base.protectedProperty = value; }, enumerable: false, configurable: false }); }</span></span></code> </pre><br><h3>  Deskripsi warisan </h3><br>  Dan hal terakhir yang ingin saya komentari adalah warisan DerivedClass dari BaseClass.  Seperti yang Anda ketahui, DerivedClass.prototype = BaseClass baru ();  tidak hanya membuat prototipe, tetapi juga menulis ulang properti konstruktornya.  Karena itu, untuk setiap instance DerivedClass, properti konstruktor menjadi sama dengan BaseClass.  Untuk memperbaikinya, biasanya setelah membuat prototipe, tulis ulang properti konstruktor: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); DerivedClass.prototype.constructor = DerivedClass;</code> </pre><br>  Namun, agar tidak ada yang menulis ulang properti ini setelah kami, kami menggunakan Object.defineProperty yang sama.  Properti yang dapat dikonfigurasi: salah mencegah properti ditimpa kembali: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'constructor'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span> : DerivedClass, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425521/">https://habr.com/ru/post/id425521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425505/index.html">Analisis proses boot kernel Linux</a></li>
<li><a href="../id425507/index.html">Parsim Wikipedia untuk tugas NLP dalam 4 tim</a></li>
<li><a href="../id425511/index.html">Fitur-fitur aplikasi Rotativa yang tidak jelas untuk menghasilkan PDF dalam aplikasi ASP.NET MVC</a></li>
<li><a href="../id425515/index.html">Apple memblokir perbaikan independen model MacBook baru</a></li>
<li><a href="../id425517/index.html">Bagaimana Yandex membuat perkiraan curah hujan global menggunakan radar dan satelit</a></li>
<li><a href="../id425525/index.html">Tim Berners-Lee melanjutkan perang: "Satu langkah kecil untuk web ..."</a></li>
<li><a href="../id425527/index.html">Daftar di Kotlin. Pendekatan Haskell</a></li>
<li><a href="../id425529/index.html">Sans Forgetica: font yang memungkinkan Anda sedikit lebih baik menghafal apa yang Anda baca</a></li>
<li><a href="../id425531/index.html">Pendinginan rem cair. Opsi Pengembangan Sistem</a></li>
<li><a href="../id425533/index.html">Cara bekerja di cloud: dari memeriksa keandalan pusat data hingga mengelola infrastruktur virtual</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>