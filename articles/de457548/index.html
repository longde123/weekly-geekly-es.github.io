<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÄ üíÜüèø üêº Mehrphasige PWM-Signalerzeugung auf TMS320F28027 üíô üî§ üë©üèø‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war einmal  in einer fernen fernen Galaxie  Ich habe einen kurzen Artikel √ºber den speziellen Piccolo-Controller von Texas Instruments geschrieben,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mehrphasige PWM-Signalerzeugung auf TMS320F28027</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457548/"><p>  Es war einmal <del>  in einer fernen fernen Galaxie </del>  Ich habe einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kurzen Artikel</a> √ºber den speziellen Piccolo-Controller von Texas Instruments geschrieben, der zur Steuerung von Stromrichtern und elektrischen Antrieben entwickelt wurde.  Diese Controller sind sehr leistungsf√§hige Entwicklungswerkzeuge f√ºr viele Aufgaben, und ich wollte etwas anderes dar√ºber schreiben ... einfach und n√ºtzlich. </p><br><p>  Vor kurzem war ich verwirrt, eine Steuerung f√ºr die Motorsteuerung zu entwickeln, und dementsprechend wurde ein Thema f√ºr den Artikel formuliert. Heute werde ich √ºber den Prozess der Bildung einer dreiphasigen PWM f√ºr die Motorsteuerung sprechen und die vorteilhaften Unterschiede zwischen TMS320F28 und anderen Steuerungen wie STM32F334, STM32G484, XMC4200 und anderen erl√§utern. </p><br><p>  Als Stand werde ich den Controller in der Entwicklung verwenden, leider kann ich nicht im Detail √ºber das Eisenteil sprechen.  Wenn ich jedoch sage, dass der Controller auf dem TMS320F28027 + DRV8353RSRGZT-Bundle basiert, k√∂nnen Sie sich die Treiberdaten ansehen und das allgemeine Schaltungskonzept sehen + es gibt ein Debugging auf diesem Stein und das Referenzdesign ist darauf offen. </p><br><p><img src="https://habrastorage.org/webt/bu/ps/ur/bupsur6y9nfobnpa53zqjrfodmo.jpeg" alt="BLDC-Treiber"></p><br><p>  Im Prinzip ist es bei der gleichen Art von Schaltung m√∂glich, BLDC-Motoren zu steuern, die Spannungspegel "verbrauchen", und gew√∂hnliche Dreiphasenmotoren, die bereits einen sinusf√∂rmigen Ausgang w√ºnschen.  Ich werde beide Optionen als zeigen  Der Weg zum Sinus liegt in der Bildung von Spannungspegeln. </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Oszillogramm Nummer 1"></p><a name="habracut"></a><br><h1 id="nemnogo-o-zheleze">  Ein bisschen √ºber Eisen </h1><br><p>  Der Leistungsteil des Treibers besteht ideologisch aus 3 Halbbr√ºckenwandlern, wahrscheinlich sind alle Chastotniks und Steuerungen zur Steuerung von BLDC-Motoren in allen Koptern auf √§hnliche Weise hergestellt: </p><br><p><img src="https://habrastorage.org/webt/fm/kd/3t/fmkd3tequjgg3gapytg5bvupwfw.png" alt="Dreiphasenbr√ºcke"></p><br><p>  Ein Unterschied - ich habe keinen Eingangsgleichrichter, weil  Die Steuerung wird anf√§nglich von einer konstanten Spannung gespeist.  Die Stromquelle in meinem Fall ist eine Anordnung von Li-Ionen-Batterien in Form von 18650-Zellen. Der verwendete DRV8353RSRGZT-Treiber kann nur 3 Leistungshalbbr√ºcken steuern. Auch in der verwendeten Version des Steins sind eingebaute Operationsverst√§rker f√ºr die Arbeit mit Shunts als Stromsensoren eingebaut Gleichstrom / Gleichstrom, der bis zu 70 ... 80 V verarbeiten kann, und all dies ist sehr flexibel √ºber SPI konfiguriert.  Zum Beispiel ist es sehr praktisch, den maximalen Impulsstrom der Transistorsteuerung einstellen zu k√∂nnen. </p><br><p>  Auch in dieser Serie gibt es Treiber mit einem anderen Funktionsumfang, zum Beispiel mit analoger Steuerung, nicht SPI oder ohne eingebauten DC / DC und ohne Operationsverst√§rker.  F√ºr den Preis sind sie nicht sehr unterschiedlich und ich habe das "k√ºhnste" genommen, wie Sie wahrscheinlich schon verstanden haben.  Das Ganze sieht sehr sch√∂n aus, aber ich habe mich ziemlich leichtfertig dem Design der Treiberbindung gen√§hert und 2 bedeutende Probleme gel√∂st.  In der Tat gibt es nur ein Problem - dies ist eine starke √úberhitzung: </p><br><p><img src="https://habrastorage.org/webt/hh/ud/hh/hhudhh5jk3tpwowsivbvjjar66e.jpeg" alt="W√§rmebildkamera"></p><br><p>  Dieses Problem wurde jedoch aus zwei Gr√ºnden verursacht.  Tats√§chlich besteht die Essenz des Problems in der √úberhitzung des Fahrers.  Auf dem Thermogramm ist der Fahrer mit einem Strom von 5 A belastet (f√ºr ihn ist es fast im Leerlauf) und nichts als der Fahrer und der MK selbst werden ein wenig erw√§rmt.  Transistoren sind nicht einmal sichtbar, sie haben eine PCB-Temperatur, bei 5A gibt es sp√§rliche W√§rmeverluste. </p><br><ul><li>  <strong>Fehler Nr. 1</strong> <br>  Ich wurde von einem Freund dazu aufgefordert, ehrlich gesagt, ich h√§tte dies als letzten Ausweg angesehen - DC / DC ist in den Treiber eingebaut, der 15 ... 50 V Eingang empf√§ngt und 3,3 V f√ºr die Stromversorgung von MK, Logik, Komparatoren und Operationsverst√§rkern liefert.  Es scheint, dass meine Projekte LM5008- und LM5017-Mikrochips in Form separater Mikrochips haben und ich 60 V ruhig auf 3,3 V reduziert habe, ohne dass eine Erw√§rmung bei einem Strom von 100-150 mA sp√ºrbar war, aber alles stellte sich als schwieriger heraus - der Gesamtwirkungsgrad des Wandlers stellte sich bei einem Strom als etwa 65-70% heraus 300 mA!  Tatsache ist, dass der Wandler selbst 3,3 V liefern kann, der Wirkungsgrad jedoch gering ist. Es ist optimal, die Ausgangsspannung auf 10-12-15 V einzustellen.  Als der Ausgang 12 V 100 mA betrug, h√∂rte mein Fahrer praktisch auf, sich aufzuw√§rmen, und der Wirkungsgrad erreichte angenehme 88%.  <strong>Die L√∂sung des Problems</strong> besteht darin, den Eingang mit dem eingebauten Gleichstrom / Gleichstrom um 15 ... 50 V auf 12 V und dann mit einem bereits billigen externen Gleichstrom / Gleichstrom von 12 V auf 3,3 V zu senken. </li></ul><br><br><ul><li>  <strong>Fehler Nr. 2</strong> <br>  Der zweite Fehler ist offensichtlicher und das erste, worauf ich s√ºndigte, so gut ich konnte.  Tatsache ist, dass bei Chips im QFN-Paket die Hauptw√§rme durch den "Bauch" abgef√ºhrt wird, normalerweise auf dem GND sitzt und durch mehrere Durchkontaktierungen (Via) am Boden haftet und die gesamte W√§rme ruhig dorthin flie√üt.  Anfangs habe ich die magere Effizienz des eingebauten Gleichstroms / Gleichstroms mit einer gro√üen Spannungsdifferenz nicht ber√ºcksichtigt, so dass es mich nicht st√∂rte, dass der thermische Abfall ("Bauch") an einem festen GND-Polygon auf der inneren Schicht haftete, auf der √§u√üeren Schicht hatte ich kein Kupfer unter dem Bauch als Polygon GND  Als Ergebnis stellte sich heraus, dass ~ 0,5 W W√§rme auf dem Chip freigesetzt werden und sich in der inneren Schicht der Platine ableiten, dh der Wirkungsgrad ist sehr schlecht.  <strong>Die L√∂sung des Problems</strong> besteht darin, dass Sie auf der √§u√üeren Schicht (untere Schicht) einen Erdtestboden erstellen m√ºssen und dies nicht tun: </li></ul><br><p><img src="https://habrastorage.org/webt/xj/hr/0g/xjhr0galowhdsrtub50fwouwj_s.png" alt="Leiterplatte"></p><br><p>  Infolgedessen wurden bei der zweiten Revision von Eisen diese Fehler korrigiert: Ein externer DC / DC-Wandler 12-3,3 V wurde hinzugef√ºgt und das GND-Polygon wurde zus√§tzlich auf die untere Schicht gef√ºllt und das Chip-Pad wurde darauf gepflanzt + das interne feste Grundpolygon wurde erhalten.  Nach solchen Verbesserungen sank die Temperatur im Dauerbetrieb von +82 auf +43 ¬∞ C: </p><br><p><img src="https://habrastorage.org/webt/_p/t9/qf/_pt9qfhtiicqqdj-kuo_ssg2zsm.png" alt="Thermogramm"></p><br><p>  Wie Sie sehen k√∂nnen, ist die Temperatur aufgrund der Verringerung der Verluste unter den gleichen Bedingungen erheblich gesunken, und die W√§rme wird jetzt gleichm√§√üiger √ºber den Platinenbereich verteilt und √ºberhitzt den Treiber oder den Mikrocontroller nicht lokal.  Im Prinzip war alles Eisen, nichts Interessanteres passierte und funktionierte stabil.  Daher empfehlen sie m√∂glicherweise die Verwendung des <strong>DRV8353-</strong> Treibers. </p><br><h1 id="realizaciya-apparatnogo-sdviga-faz-na-120suposup">  Implementierung einer Hardware-Phasenverschiebung von 120 <sup>o</sup> </h1><br><p>  Ein Merkmal des dreiphasigen Netzwerks ist, dass der Strom in den Phasen nicht synchron ist, sondern um 120 <sup>¬∞</sup> gegen√ºber dem benachbarten verschoben ist.  Was ist diese 120 <sup>o</sup> Phasenverschiebung im Allgemeinen?  In einfachen Worten ist dies eine Verschiebung des Startpunkts der Erzeugung um 1/3 der Periode.  Aus mathematischer Sicht betr√§gt die Signalperiode <em>2œÄ</em> , was bedeutet, dass das zweite Signal um 2œÄ / 3 und das dritte um 4œÄ / 3 verschoben werden muss.  Aus elektronischer Sicht wird die Periode durch die Countdown-Periode unseres Timers festgelegt.  Wenn wir beispielsweise mit 60 MHz takten, m√∂chten wir eine PWM mit einer Frequenz von 50 kHz erhalten, was bedeutet, dass die Countdown-Zeit des Timers zwischen 0 und 1200 liegt (60 000 000 Hz / 50 000 Hz = 1200).  Um nun 3 Phasen mit einer Verschiebung von 120 ¬∞ zu erhalten <sup>, m√ºssen</sup> wir die 1. Phase nicht ber√ºhren, +400 zum aktuellen Wert f√ºr die 2. Phase hinzuf√ºgen und +800 zur aktuellen Phase hinzuf√ºgen. </p><br><p>  Wenn wir Mikrocontroller auf dem Kortexkern verwenden, k√∂nnen wir die Verschiebung entweder durch Schreiben einer mathematischen Formel oder durch Verwenden der Ereignissynchronisation implementieren.  Es war immer wieder erstaunlich f√ºr mich, warum ST, NXP und andere nicht nur registrierten, wo der Verschiebungswert geschrieben werden w√ºrde.  Gl√ºcklicherweise hat TI dies in seinem TMS320F28xxx getan, um die Verschiebung einzustellen, schreiben Sie einfach ein Register!  Ich werde Ihnen nicht sagen, warum die Softwarel√∂sung nicht optimal ist. Ich m√∂chte nur sagen, dass MK-Formeln nicht sehr schnell ber√ºcksichtigt werden.  Der Profi mit Synchronisation von Ereignissen ist bereits ad√§quater und auf stm w√ºrde ich genau das tun, aber diese Option erlaubt es nicht, den Phasenwert im laufenden Betrieb zu √§ndern, dh f√ºr einige phasenverschobene Br√ºcken bleibt nur die Softwareversion √ºbrig.  Ist der Vorteil der F√§higkeit, die Phasenhardware zu steuern?  Es liegt an Ihnen zu entscheiden, meine Aufgabe ist es Ihnen zu sagen, dass es m√∂glich ist.  F√ºr mich ist dies ein offensichtliches Plus, wenn wir √ºber die Steuerung eines elektrischen Antriebs oder von Spannungswechselrichtern mit einem dreiphasigen Ausgang sprechen. </p><br><p>  Konfigurieren wir nun die Erzeugung von PWM-Signalen in Form von 3 komplement√§ren Paaren mit Totzeit und Phasenverschiebung.  Bisher ohne Sinus.  Ich werde die folgenden Paare verwenden: EPWM1A + EPWM1B, EPWM2A + EPWM2B und EPWM4A + EPWM4B.  Dies sind die Signale, die vom Mikrocontroller zum Treiber gelangen. </p><br><ul><li>  <strong>Schritt 1</strong> <br>  Es ist erforderlich, den GPIO-Multiplexer mithilfe des <em>GPAMUX-</em> Registers f√ºr die Arbeit mit PWM zu konfigurieren und die <em>Pull-Ups des</em> Ausgangs zur Stromversorgung auszuschalten, damit beim Einschalten alle Beine kein Protokoll haben und die Schl√ºssel nicht ge√∂ffnet werden.  Der aktuelle Schutz wird sicherlich sparen, aber es ist besser, dies nicht zu tun.  Beachten Sie auch, dass Sie f√ºr den Zugriff auf die Setup-Register diese mit dem Befehl <em>EALLOW abrufen</em> und dann den √úberschreibschutz mit dem Befehl <em>EDIS wieder aktivieren m√ºssen</em> . </li></ul><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitGPIOforPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPAPUD.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Disable pull-up on GPIO0 (EPWM1A) GpioCtrlRegs.GPAPUD.bit.GPIO1 = 1; // Disable pull-up on GPIO1 (EPWM1B) GpioCtrlRegs.GPAMUX1.bit.GPIO0 = 1; // Configure GPIO0 as EPWM1A GpioCtrlRegs.GPAMUX1.bit.GPIO1 = 1; // Configure GPIO1 as EPWM1B GpioCtrlRegs.GPAPUD.bit.GPIO2 = 1; // Disable pull-up on GPIO2 (EPWM2A) GpioCtrlRegs.GPAPUD.bit.GPIO3 = 1; // Disable pull-up on GPIO3 (EPWM2B) GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1; // Configure GPIO2 as EPWM2A GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1; // Configure GPIO3 as EPWM2B GpioCtrlRegs.GPAPUD.bit.GPIO6 = 1; // Disable pull-up on GPIO6 (EPWM4A) GpioCtrlRegs.GPAPUD.bit.GPIO7 = 1; // Disable pull-up on GPIO7 (EPWM4B) GpioCtrlRegs.GPAMUX1.bit.GPIO6 = 1; // Configure GPIO6 as EPWM4A GpioCtrlRegs.GPAMUX1.bit.GPIO7 = 1; // Configure GPIO7 as EPWM4B EDIS; }</span></span></code> </pre> <br><ul><li>  <strong>Schritt 2</strong> <br>  Richten Sie die PWM-Signalerzeugung ein.  Es ist notwendig, eine Frequenz von 50 kHz und eine Phasenverschiebung von 120 <sup>o zu erhalten</sup> .  In diesem Fall verwende ich das √ºbliche PWM, da in diesem Controller auch HRPWM vorhanden ist. Dies ist wichtig zu beachten.  Das PWM-Modul wird mit der Kernfrequenz getaktet, dh 60 MHz. Ich habe im ersten Artikel auf TMS320 gezeigt, wie die PLL-Frequenz angepasst wird. Ich werde es nicht wiederholen, aber am Ende des Artikels wird es ein Archiv mit dem Code geben und es wird m√∂glich sein, dort nachzuschauen. </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitPWM</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// EPWM Module 1 config EPwm1Regs.TBPRD = 600; // Set priod EPwm1Regs.TBPHS.half.TBPHS = 0; // Set phase EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Symmetrical mode EPwm1Regs.TBCTL.bit.PHSEN = TB_DISABLE; // Master enable EPwm1Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm1Regs.TBCTL.bit.SYNCOSEL = TB_CTR_ZERO; // Sync down-stream module EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm1Regs.AQCTLA.bit.CAU = AQ_SET; EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm1Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; // enable dead-time module EPwm1Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; // Active Hi complementary EPwm1Regs.DBFED = 20; // dead-time on 20 tick EPwm1Regs.DBRED = 20; // dead-time off 20 tick // EPWM Module 2 config EPwm2Regs.TBPRD = 600; EPwm2Regs.TBPHS.half.TBPHS = 400; // Set phase = 400/1200 * 360 = 120 deg EPwm2Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm2Regs.TBCTL.bit.PHSEN = TB_ENABLE; // Slave enable EPwm2Regs.TBCTL.bit.PHSDIR = TB_DOWN; // Count DOWN on sync (=120 deg) EPwm2Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm2Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; // sync flow-through EPwm2Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm2Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm2Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm2Regs.AQCTLA.bit.CAU = AQ_SET; EPwm2Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm2Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm2Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm2Regs.DBFED = 20; EPwm2Regs.DBRED = 20; // EPWM Module 4 config EPwm4Regs.TBPRD = 600; EPwm4Regs.TBPHS.half.TBPHS = 400; EPwm4Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; EPwm4Regs.TBCTL.bit.PHSEN = TB_ENABLE; EPwm4Regs.TBCTL.bit.PHSDIR = TB_UP; EPwm4Regs.TBCTL.bit.PRDLD = TB_SHADOW; EPwm4Regs.TBCTL.bit.SYNCOSEL = TB_SYNC_IN; EPwm4Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW; EPwm4Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO; EPwm4Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO; EPwm4Regs.AQCTLA.bit.CAU = AQ_SET; EPwm4Regs.AQCTLA.bit.CAD = AQ_CLEAR; EPwm4Regs.DBCTL.bit.OUT_MODE = DB_FULL_ENABLE; EPwm4Regs.DBCTL.bit.POLSEL = DB_ACTV_HIC; EPwm4Regs.DBFED = 20; EPwm4Regs.DBRED = 20; }</span></span></code> </pre> <br><p>  Nun ein bisschen mehr Details ... schreiben Sie in das <em>TBPRD-</em> Register den Punkt oder besser "Punkt / 2", weil  Wenn der Zeitgeber in beide Richtungen gez√§hlt wird, stellt sich heraus, dass die Periode 600 der Frequenz des Ausgangs-PWM-Signals von 50 kHz im Komplement√§rpaarmodus entspricht.  In das <em>TBPHS-</em> Register schreiben <em>wir</em> den Phasenwert, um den wir uns verschieben m√ºssen, in diesem Fall 400 von 600, was 2œÄ / 3 entspricht.  Es ist erw√§hnenswert, dass wir die 1. Phase nicht verschieben, daher ist die Verschiebung 0, f√ºr die 2. Phase ist die Verschiebung 400, aber f√ºr die 3. Phase erscheint es logisch, 800, aber irgendwie 800 von 600 zu schreiben nicht wirklich ... deshalb schreiben sie die Verschiebung nicht relativ zur 1. Phase, sondern relativ zur vorherigen, dh zur 2 ..  Als Ergebnis erhalten wir, dass wir in der 3. Phase 400 schreiben und dies 2œÄ / 3 zwischen Phase 2 und 3 entspricht. Da die 2. Phase bereits verschoben ist, ergibt sich zwischen Phase 1 und 3 "2œÄ / 3 + 2œÄ / 3 = 4œÄ" / 3 "und aus elektronischer Sicht sieht alles logisch aus. </p><br><p>  Damit die Phasen verstehen, wer sich relativ zu wem bewegt, wird ein Boss ben√∂tigt. Daher wird EPWM1 ‚Äã‚Äãmithilfe des <em>PHSEN-</em> Bits in den Master-Modus und EPWM2 bzw. EPWM4 als Slaves gesetzt.  Mit den <em>SYNCOSEL-</em> Bits wird auch der <em>Synchronisationspunkt</em> gesetzt, <em>dh</em> wo die Verschiebung abgelesen werden soll.  EPWM1 ‚Äã‚Äãist mit dem Start des Timers synchronisiert, dh mit der Nullperiode, und EPWM2 und EPWM4 sind bereits relativ zur Signalflanke des vorherigen Kanals synchronisiert: Der vorherige Kanal f√ºr EPWM2 ist EPWM1 ‚Äã‚Äãund f√ºr EPWM4 ist es EPWM2. </p><br><p>  Jetzt m√ºssen noch komplement√§re Paare eingeschaltet und die Totzeitdauer eingestellt werden.  Mit den <em>POLSEL-</em> Bits setzen <em>wir</em> eine nicht inverse PWM, <em>dh</em> bei Erreichen des eingestellten Wertes des Komparators (Referenz) wird am Ausgang ein Protokoll generiert.  1. In <em>OUT_MODE setzen wir</em> die Totzeiterzeugung sowohl am Rand als auch beim Abfall des Signals.  Dementsprechend schreiben <em>DBFED</em> und <em>DBRED</em> in die Register die Dauer der Totzeit in Ticks. </p><br><ul><li>  <strong>Schritt 3</strong> <br>  Jetzt bleibt es, den Tastverh√§ltniswert in das <em>CMPA-</em> Register zu schreiben, das jedem Kanal entspricht, und Sie k√∂nnen das Ergebnis beobachten. </li></ul><br><pre> <code class="cpp hljs"> EPwm1Regs.CMPA.half.CMPA = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-comment"><span class="hljs-comment">// duty for output EPWM1A EPwm2Regs.CMPA.half.CMPA = 300; // duty for output EPWM2A EPwm4Regs.CMPA.half.CMPA = 300; // duty for output EPWM4A</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/sl/wy/6b/slwy6b5zoivfrdpbzlf9vpbsmms.png" alt="Dreiphasen-PWM"></p><br><p>  Voila!  Die Oszilloskopsonden sind mit dem Treiberausgang verbunden.  Der gelbe Kanal ist unser EPWM1, also der Master.  Der blaue Kanal ist EPWM2 und er ist um 2œÄ / 3 (oder 400 Abtastwerte) relativ zum gelben Kanal verschoben, und der gr√ºne Kanal ist um weitere 400 Abtastwerte verschoben.  Somit erhalten wir 3 Phasen, wobei jede Phase um 120 <sup>¬∞</sup> verschoben ist. </p><br><p>  Lassen Sie uns nun die Oszilloskopsonden vom Ausgang der Leistungsbr√ºcke auf die Steuersignale √ºbertragen, die aus dem Mikrocontroller kommen, und die Totzeit innerhalb des komplement√§ren Paares √ºberpr√ºfen: </p><br><p><img src="https://habrastorage.org/webt/cd/aj/k7/cdajk7vfo9vs5d1yzvbuvtggy00.png" alt="Oszillogramm Nummer 2"></p><br><p>  Wie Sie sehen k√∂nnen, entspricht die eingestellte Totzeit der tats√§chlichen.  Die Dauer einer Probe betr√§gt <em>1 / 60.000.000 Hz = 16,6 ns</em> und wir erhalten 20 Proben, was der Totzeit von 20,6 <em>16</em> ns = 332 ns entspricht *, was ungef√§hr dem entspricht, was im Oszillogramm beobachtet wird. </p><br><p>  Eigentlich, wo dies n√ºtzlich sein kann, in der Form, wie es jetzt ist.  Die naheliegendste Option sind mehrphasige DC / DC-Wandler f√ºr diejenigen, die den <strong>verschachtelten DC / DC-Wandler</strong> googeln <strong>m√∂chten</strong> .  Dies ist eine √§u√üerst interessante technische L√∂sung, die die Gr√∂√üe der Leistungsinduktivit√§ten erheblich reduzieren, die Ausgangskapazit√§t von Kondensatoren verringern und auch den Wirkungsgrad erh√∂hen kann.  Auf einem einfachen TMS320F28027 k√∂nnen Sie einen 4-Phasen-Wandler implementieren, und all dies wird sehr einfach im Code und nur in Hardware implementiert. </p><br><h1 id="generiruem-trehfaznoe-peremennoe-napryazhenie">  Wir erzeugen eine dreiphasige Wechselspannung </h1><br><p>  Bei vielen Problemen reicht es nicht aus, am Ausgang diskrete Werte von 0 oder VCC zu erhalten, es wird eine Sinuswelle ben√∂tigt.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> , der √ºber die Bildung einer einphasigen Wechselspannung spricht, und dort wird die "tabellarische" Methode verwendet, dh die Werte f√ºr die Sinuswelle wurden urspr√ºnglich berechnet.  Grunds√§tzlich kann dies auch dreiphasig erfolgen, ich m√∂chte jedoch eine alternative Option aufzeigen, n√§mlich die Berechnung des Zollwerts in Echtzeit oder im laufenden Betrieb. </p><br><p>  Es gibt eine Funktion.  Die PWM-Frequenz betr√§gt in diesem Fall ebenfalls 50 kHz und die Phasenverschiebung wird zwischen den Perioden dieses Signals eingestellt.  Wenn wir also eine Sinuskurve mit einer Frequenz von 50 Hz modulieren, geht die Hardware-Phasenverschiebung "verloren", sie bleibt zwischen den PWMs bestehen, jedoch nicht innerhalb der Sinuskurve, sodass Software durchgef√ºhrt werden muss.  Trigonometrie ist eine schwere Sache f√ºr TMS320F28027, aber sie ist nicht sehr besch√§ftigt mit mir. Lassen Sie es also z√§hlen.  Wenn Sie eine Aufgabe haben, die viele Berechnungen erfordert, ben√∂tigen Sie einen Controller mit TMU und FPU, z. B. TMS320F280049, der die Mathematik viel schneller umdrehen kann. </p><br><p>  Um die Tastwerte in die PWM zu laden, ben√∂tigen wir einen Timer, dessen Periode die Abtastfrequenz einstellt.  Ich ben√∂tige eine Periode von 20 ms (1/50 Hz = 20 ms) und nehme die Anzahl der Schritte in einer Sinuskurve, sagen wir 20, als Ergebnis sollte ein Interrupt mit einer Frequenz von 0,02 s / 20 = 0,001 ms = 1 kHz erzeugt werden. In diesem Interrupt schreibe ich den Wert in die PWM .  Der Einfachheit halber nehme ich einen normalen <em>CPU0-</em> Timer und konfiguriere ihn: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitTimer0ForGenerator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; PieVectTable.TINT0 = &amp;cpu_timer0_isr; EDIS; InitCpuTimers(); ConfigCpuTimer(&amp;CpuTimer0, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); CpuTimer0Regs.TCR.bit.TIE = <span class="hljs-number"><span class="hljs-number">1</span></span>; CpuTimer0Regs.TCR.bit.TSS = <span class="hljs-number"><span class="hljs-number">0</span></span>; IER |= M_INT1; PieCtrlRegs.PIEIER1.bit.INTx7 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Enable TINT0 in the PIE: Group 1 interrupt 7 EINT; // Enable Global interrupt INTM ERTM; // Enable Global real-time interrupt DBGM } __interrupt void cpu_timer0_isr (void) { CpuTimer0.InterruptCount++; /* *   -  . ... */ PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre> <br><p>  Die <em>Funktionen</em> <em>InitCpuTimers</em> und <em>ConfigCpuTimer sind</em> Standard, alle Einstellungen sind in ihnen enthalten. Wir m√ºssen nur die <em>Kernfrequenz</em> (60 MHz) und die Z√§hlperiode in Mikrosekunden (1000 Œºs = 1 ms) √ºbertragen, was 1 kHz entspricht, und wir brauchten sie.  Wo also in der Konfigurationsfunktion Interrupts aktiviert werden und die Adresse des Handlers unseres Interrupts √ºbergeben wird, wo alles passieren wird. </p><br><p>  Jetzt ist es notwendig, die Sinusformel erneut zu ‚Äûerfinden‚Äú. Dazu ben√∂tigen Sie Kenntnisse der Schultrigonometrie und das ist alles.  Und so ... haben wir eine Funktion <strong><em>y = sin (x)</em></strong> zeichnen wir diese Funktion: </p><br><p><img src="https://habrastorage.org/webt/hi/bx/ey/hibxeyajv_h7l7t-mqkbkfrq6-s.png" alt="y = sin (x)"></p><br><p>  Wie Sie in der Grafik sehen k√∂nnen, variiert die Amplitude von y von -1 bis 1, aber wir wollen von 0 bis 1, weil  Mit einer minimalen Amplitude haben wir 0 V und mit einem Maximum (entspricht 1) haben wir + VCC.  Um -1 ... + 1 zu "zeichnen", brauchen wir eine bipolare Ern√§hrung, aber das ist es nicht.  Sie m√ºssen das Diagramm in eine positive Richtung verschieben.  Wenn wir es nur anheben, wird es von 0 auf +2 und wir k√∂nnen nur auf +1.  Sie m√ºssen also durch 2 und nur etwas teilen!  Beginnen wir mit dem Teilen und Zeichnen f√ºr <strong><em>y = (sin (x) / 2):</em></strong> </p><br><p><img src="https://habrastorage.org/webt/t_/n0/iw/t_n0iw1fym8aboggaxk1my7r4um.png" alt="y = (sin (x) / 2)"></p><br><p>  Ja!  Jetzt hat der Graph einen Bereich von -0,5 bis +0,5, das hei√üt, die Amplitude ist 1. Es ist bereits besser, aber wir haben die negativen Werte noch nicht beseitigt. Verschieben wir den Graph also einfach um 0,5 nach oben. Dazu m√ºssen wir nur diesen Wert zum Ergebnis hinzuf√ºgen und die Formel erhalten <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> und zeichnen Sie den Graphen f√ºr diese Funktion: </p><br><p><img src="https://habrastorage.org/webt/df/vu/ez/dfvuez1lks2uhg0cp3tkhie9cdq.png" alt="y = 0,5 + (sin (x) / 2)"></p><br><p>  Jetzt ist alles absolut perfekt geworden: Die Sinuskurve hat eine Amplitude von 0 bis 1, negative Werte fehlen.  Die Formel <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> beschreibt die 1. Phase. Nun ist es notwendig, eine Phasenverschiebung hinzuzuf√ºgen, um die Phasen 2 und 3 zu erhalten. Dazu subtrahieren Sie 2œÄ / 3 bzw. 4œÄ / 3 von <em>x</em> und erhalten die Formeln f√ºr die verbleibenden Phasen <strong><em>y = 0,5 + (sin (x-2œÄ / 3) / 2)</em></strong> und <strong><em>y = 0,5 + (sin (x-4œÄ / 3) / 2).</em></strong>  Wir erstellen 3 Diagramme und sehen, ob es wie die Wahrheit aussieht: </p><br><p><img src="https://habrastorage.org/webt/hj/kp/n9/hjkpn93-37r_rclbrevchhdzf_m.png" alt="3 Phasen"></p><br><p>  Nicht schlecht!  Das Bild √§hnelt dem, was normalerweise in Lehrb√ºchern der Elektrotechnik gemalt wird, wenn es sich um ein Dreiphasennetz oder Asynchronmotoren handelt.  √úbrigens ist 2.0943 2œÄ / 3 und 4.1866 4œÄ / 3, ich habe sie sofort gez√§hlt und sie erscheinen in meinem Code.  Insgesamt haben wir 3 Gleichungen: </p><br><ul><li>  Phase A - <strong><em>y = 0,5 + (sin (x) / 2)</em></strong> </li><li>  Phase B - <strong><em>y = 0,5 + (sin (x-2œÄ / 3) / 2)</em></strong> </li><li>  Phase C - <strong><em>y = 0,5 + (sin (x-4œÄ / 3) / 2)</em></strong> </li></ul><br><p>  Seitens der Mathematik scheint alles einfach und klar zu sein, aber jetzt muss es an die Realit√§t der Mikrocontroller angepasst werden.  Unsere Sinuswelle ist nicht analog, sondern hat "Schritte", das hei√üt, sie ist diskret, da wir in meinem Fall nur Spannung oder 0 V oder + 15 V (VCC) einstellen k√∂nnen.  Fr√ºher habe ich geschrieben, dass ich 20 Schritte haben werde, also werde ich f√ºr 1 Periode 20 Berechnungen haben. </p><br><p>  Lassen Sie uns zun√§chst entscheiden, was <em>x ersetzt werden soll</em> .  Die Periode unserer Sinuskurve betr√§gt <em>2œÄ</em> , was bedeutet, dass der Abtastschritt <em>2œÄ / 20</em> betr√§gt.  Dementsprechend besteht die Sinuskurve aus 20 Punkten, als ob wir ein Diagramm auf den Punkten erstellen und zwischen ihnen ann√§hern.  Infolgedessen ist der Wert im ersten Schritt <strong><em>sin (2œÄ * (1/20),</em></strong> im zweiten Schritt <strong><em>sin (2œÄ * (2/20)),</em></strong> im dritten Schritt * <strong>sin (2œÄ <em>(3/20))</em></strong> und so weiter, wenn wir Wenn es <em>20/20</em> erreicht, bedeutet dies das Ende des Zeitraums und es muss erneut mit dem Z√§hlen begonnen werden. Korrigieren wir anhand der empfangenen Daten die Formeln: </p><br><ul><li>  Phase A - <strong><em>y = 0,5 + (sin (2œÄ * (n / N)) / 2)</em></strong> </li><li>  Phase B - <strong><em>y = 0,5 + (sin (2œÄ * (n / N) -2œÄ / 3) / 2)</em></strong> </li><li>  Phase C - <strong><em>y = 0,5 + (sin (2œÄ * (n / N) -4œÄ / 3) / 2)</em></strong> </li></ul><br><p>  Nun betrachten wir den Sinuswert an jedem bestimmten Punkt in der Grafik.  Dementsprechend ist <strong>n</strong> der aktuelle Schritt, <strong>N</strong> ist der Gesamtschritt (20).  Nach diesen Formeln erhalten wir einen Wert von 0 bis 1, aber in Wirklichkeit arbeiten wir nicht mit einer abstrakten Amplitude.  Die Amplitude h√§ngt in unserem Fall vom Arbeitszyklus ab, weil  Die Einschaltdauer √§ndert sich von 0 auf 600 (aus den PWM-Einstellungen), dann ist 0 0 und 1 entspricht 600. Auf dieser Grundlage berechnen wir sie neu in eine reelle Formel, um den Wert zu erhalten, der in das CMPA- <em>PWM-Register</em> geladen wird: </p><br><ul><li>  Phase A - <strong><em>Pflicht1 = A <em>(0,5 + (sin (2œÄ</em> (n / N)) / 2))</em></strong> </li><li>  Phase B - <strong><em>Pflicht2 = A <em>(0,5 + (sin (2œÄ</em> (n / N) -2œÄ / 3) / 2))</em></strong> </li><li>  Phase C - <strong><em>Duty4 = A <em>(0,5 + (sin (2œÄ</em> (n / N) -4œÄ / 3) / 2))</em></strong> </li></ul><br><p>  Dementsprechend ist <strong>A</strong> der Maximalwert der Amplitude, d. H. 600, <strong>n</strong> ist der aktuelle Schritt, <strong>N</strong> ist die Gesamtzahl der Schritte (20).  Die Werte von <strong><em>Duty1, Duty2, Duty4</em></strong> sind die umgerechneten realen Werte des Duty Factors, der in den <em>CMPA</em> geladen <em>wird.</em>  Schreiben wir nun den Code f√ºr den aktualisierten Interrupt-Handler und deklarieren alle erforderlichen Variablen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> activeStep = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> amplitude = <span class="hljs-number"><span class="hljs-number">600.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> allStep = <span class="hljs-number"><span class="hljs-number">20.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pi = <span class="hljs-number"><span class="hljs-number">3.1415</span></span>; <span class="hljs-comment"><span class="hljs-comment">// œÄ const float piTwo = 6.2831; // 2œÄ const float phaseShifted120deg = 2.0943; // 2œÄ/3 const float phaseShifted240deg = 4.1866; // 4œÄ/3 __interrupt void cpu_timer0_isr (void) { if (activeStep &gt;= allStep) {activeStep = 0;} activeStep++; EPwm1Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep)) / 2)))); EPwm2Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted120deg) / 2)))); EPwm4Regs.CMPA.half.CMPA = ((uint16_t)(amplitude * (0.5 + (sinf(piTwo * (activeStep / allStep) - phaseShifted240deg) / 2)))); PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; // Acknowledge this interrupt to receive more interrupts from group 1 }</span></span></code> </pre><br><p>  Der Code ist, wie Sie sehen, der einfachste, wenn Sie verstehen, was zu tun war, und einfache Mathematik f√ºr das zu l√∂sende Problem.  Jedes Mal, wenn der Interrupt aufgerufen wird, <em>erh√∂hen</em> wir die Variable <em>activeStep</em> , die die <em>Schrittnummer</em> enth√§lt. Sie √§ndert sich von 0 auf 20 und wird dann zur√ºckgesetzt.  Es stellt sich heraus, dass wir in einer Periode 20 Schritte und 20 Berechnungen f√ºr jede Phase durchf√ºhren.  Um nicht st√§ndig <em>2œÄ / 3</em> und <em>4œÄ / 3</em> in der Formel zu z√§hlen, habe ich sie sofort gez√§hlt, um sie als Konstanten zu verwenden. </p><br><p>  Berechnungen haben sich als Minimum herausgestellt, f√ºr diesen MK ist es absolut nichts.  Auf Wunsch kann die Anzahl der Punkte deutlich erh√∂ht werden, beispielsweise auf bis zu 200. Alles h√§ngt von der Aufgabe ab.  Das √Ñndern der PWM-Frequenz erfolgt durch √Ñndern der Interrupt-Anruffrequenz und der Anzahl der Schritte.  Sie k√∂nnen auch die variable <em>Amplitude</em> und die Spannung am Ausgang des Stromrichters √§ndern. </p><br><p>  Nach dem Herunterladen des Codes auf den Mikrocontroller erhalten Sie das entsprechende Bild: </p><br><p><img src="https://habrastorage.org/webt/qf/rd/ck/qfrdck6y4rcvirbws9o6zbzrfea.png" alt="Oszillogramm Nummer 1"></p><br><p>  Wenn Sie den Graphen entlang <em>Y</em> strecken, ist es besser, die Fehler des Signals zu sehen.  Dies ist eine Folge der geringen Anzahl von Abtastschritten, es gilt eine bedingte Regel: <strong>Je mehr Punkte, desto sch√∂ner das Signal.</strong> </p><br><p><img src="https://habrastorage.org/webt/wh/4d/du/wh4dduwnbyshscey7rlmzs6s1mw.png" alt="Oszillogramm Nummer 3"></p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Heute habe ich √ºber den Prozess der Phasenverschiebungsbildung in Mehrphasensystemen gesprochen, im Prinzip gibt es nichts Kompliziertes, insbesondere bei Verwendung von TMS320F28.  Der Rest h√§ngt von den Algorithmen ab. Im Prinzip gibt es auf den riesigen Fl√§chen von Runet viele Artikel, in denen Steuerungs- und b√ºrstenlose Motoren, asynchrone und alle m√∂glichen anderen Dinge gekaut werden. Sie m√ºssen nur die Logik √§ndern. </p><br><p>  Ich hoffe, dass dieses Material n√ºtzlich und nicht besonders langweilig zu lesen ist.  Wie immer ist die Quelle beigef√ºgt: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Archivieren Sie mit dem Projekt f√ºr Code Composer Studio</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457548/">https://habr.com/ru/post/de457548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457534/index.html">Zertifizierte Versionen - der Rechen, den wir w√§hlen</a></li>
<li><a href="../de457538/index.html">Wie kann ich unterbrochene virtuelle Yandex.Cloud-Maschinen verwenden und bei der L√∂sung gro√üer Probleme sparen?</a></li>
<li><a href="../de457540/index.html">Intel Optane DC Persistent Memory, ein Jahr sp√§ter</a></li>
<li><a href="../de457542/index.html">Das Hacken und Sch√ºtzen von Verschl√ºsselungslaufwerken LUKS</a></li>
<li><a href="../de457546/index.html">Demo-Tag: Warum ist das alles und wie geht das? UPD + Broadcast</a></li>
<li><a href="../de457550/index.html">Wovor die digitale Industrie gesch√ºtzt werden muss</a></li>
<li><a href="../de457552/index.html">Kletterer in Zafasadia. Wie die Promalps auf dem Lakhta Center Tower funktionieren</a></li>
<li><a href="../de457558/index.html">EvilParcel-Sicherheitsanf√§lligkeitsanalyse</a></li>
<li><a href="../de457560/index.html">Tokenized Shares: So werden Sie vor dem B√∂rsengang ein Gett-Investor</a></li>
<li><a href="../de457562/index.html">Ivideon Counter 3D: Wen, wie und warum werden Besucher gez√§hlt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>