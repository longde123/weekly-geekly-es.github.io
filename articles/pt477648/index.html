<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò£Ô∏è üö¥üèæ üë≤üèΩ MVCC no PostgreSQL-3. Vers√µes de linha üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ ü§∂ üß†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bem, j√° discutimos o isolamento e fizemos uma digress√£o em rela√ß√£o √† estrutura de dados de baixo n√≠vel . E finalmente chegamos √† coisa mais fascinante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC no PostgreSQL-3. Vers√µes de linha</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/477648/">  Bem, j√° discutimos o <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolamento</a> e fizemos uma digress√£o em rela√ß√£o <a href="https://habr.com/ru/company/postgrespro/blog/469087/">√† estrutura de dados de baixo n√≠vel</a> .  E finalmente chegamos √† coisa mais fascinante, ou seja, vers√µes de linha (tuplas). <br><br><h1>  Cabe√ßalho da tupla </h1><br>  Como j√° mencionado, v√°rias vers√µes de cada linha podem estar dispon√≠veis simultaneamente no banco de dados.  E precisamos de alguma forma distinguir uma vers√£o da outra.  Para esse fim, cada vers√£o √© rotulada com seu ‚Äútempo‚Äù efetivo ( <code>xmin</code> ) e ‚Äútempo‚Äù de expira√ß√£o ( <code>xmax</code> ).  As aspas indicam que um contador de incremento especial √© usado em vez do pr√≥prio tempo.  E esse contador √© <em>o identificador da transa√ß√£o</em> . <br><br>  (Como sempre, na realidade isso √© mais complicado: o ID da transa√ß√£o nem sempre pode aumentar devido a uma profundidade de bits limitada do contador. Mas exploraremos mais detalhes disso quando nossa discuss√£o chegar ao congelamento.) <br><a name="habracut"></a><br>  Quando uma linha √© criada, o valor de <code>xmin</code> √© definido igual ao ID da transa√ß√£o que executou o comando INSERT, enquanto <code>xmax</code> n√£o √© preenchido. <br><br>  Quando uma linha √© exclu√≠da, o valor <code>xmax</code> da vers√£o atual √© rotulado com o ID da transa√ß√£o que executou DELETE. <br><br>  Um comando UPDATE realmente executa duas opera√ß√µes subseq√ºentes: DELETE e INSERT.  Na vers√£o atual da linha, <code>xmax</code> √© definido igual ao ID da transa√ß√£o que executou UPDATE.  Em seguida, uma nova vers√£o da mesma linha √© criada, na qual o valor de <code>xmin</code> √© o mesmo que <code>xmax</code> da vers√£o anterior. <br><br>  <code>xmin</code> campos <code>xmin</code> e <code>xmax</code> s√£o inclu√≠dos no cabe√ßalho de uma vers√£o de linha.  Al√©m desses campos, o cabe√ßalho da tupla cont√©m outros, como: <br><br><ul><li>  <code>infomask</code> - v√°rios bits que determinam as propriedades de uma determinada tupla.  Existem alguns deles, e discutiremos cada um ao longo do tempo. </li><li>  <code>ctid</code> - uma refer√™ncia para a pr√≥xima vers√£o mais recente da mesma linha.  <code>ctid</code> da <code>ctid</code> de linha mais recente e atualizada faz refer√™ncia a essa mesma vers√£o.  O n√∫mero est√° no formato <code>(x,y)</code> , onde <code>x</code> √© o n√∫mero da p√°gina e <code>y</code> √© o n√∫mero do pedido do ponteiro na matriz. </li><li>  O bitmap NULLs, que marca as colunas de uma determinada vers√£o que cont√™m um NULL.  NULL n√£o √© um valor regular dos tipos de dados e, portanto, precisamos armazenar essa caracter√≠stica separadamente. </li></ul><br>  Como resultado, o cabe√ßalho parece bem grande: 23 bytes por cada tupla, no m√≠nimo, mas geralmente maiores por causa do bitmap NULLs.  Se uma tabela √© "estreita" (ou seja, cont√©m poucas colunas), os bytes gerais podem ocupar mais espa√ßo do que as informa√ß√µes √∫teis. <br><br><h1>  Inserir </h1><br>  Vamos examinar mais detalhadamente como as opera√ß√µes nas linhas s√£o executadas em um n√≠vel baixo e come√ßamos com uma inser√ß√£o. <br><br>  Para experimentar, criaremos uma nova tabela com duas colunas e um √≠ndice em uma delas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre><br>  Iniciamos uma transa√ß√£o para inserir uma linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Este √© o ID da nossa transa√ß√£o atual: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Vamos examinar o conte√∫do da p√°gina.  A fun√ß√£o heap_page_items da extens√£o "pageinspect" permite obter informa√ß√µes sobre os ponteiros e vers√µes de linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Observe que a palavra "heap" no PostgreSQL indica tabelas.  Este √© mais um uso estranho de um termo: um heap √© uma <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">estrutura de dados</a> conhecida, que n√£o tem nada a ver com uma tabela.  Essa palavra √© usada aqui no sentido de que "tudo est√° amontoado", diferente dos √≠ndices ordenados. <br><br>  Esta fun√ß√£o mostra os dados "como est√£o", em um formato dif√≠cil de compreender.  Para esclarecer as coisas, deixamos apenas parte das informa√ß√µes e as interpretamos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Fizemos o seguinte: <br><br><ul><li>  Adicionado zero ao n√∫mero do ponteiro para torn√°-lo parecido com um <code>t_ctid</code> : (n√∫mero da p√°gina, n√∫mero do ponteiro). </li><li>  Interpretou o status do ponteiro <code>lp_flags</code> .  Aqui √© "normal", o que significa que o ponteiro realmente faz refer√™ncia a uma vers√£o de linha.  Discutiremos outros valores posteriormente. </li><li>  De todos os bits de informa√ß√£o, selecionamos apenas dois pares at√© agora.  <code>xmin_committed</code> bits <code>xmin_committed</code> e <code>xmin_aborted</code> mostram se a transa√ß√£o com o ID <code>xmin</code> est√° confirmada (revertida).  Um par de bits semelhantes est√° relacionado √† transa√ß√£o com o ID <code>xmax</code> . </li></ul><br>  O que observamos?  Quando uma linha √© inserida, na p√°gina da tabela, um ponteiro aparece com o n√∫mero 1 e faz refer√™ncia √† primeira e √† √∫nica vers√£o da linha. <br><br>  O campo <code>xmin</code> na tupla √© preenchido com o ID da transa√ß√£o atual.  Como a transa√ß√£o ainda est√° ativa, os bits <code>xmin_aborted</code> e <code>xmin_aborted</code> n√£o est√£o configurados. <br><br>  O campo <code>ctid</code> da vers√£o da linha faz refer√™ncia √† mesma linha.  Isso significa que nenhuma vers√£o mais recente est√° dispon√≠vel. <br><br>  O campo <code>xmax</code> √© preenchido com o n√∫mero convencional 0, pois a tupla n√£o √© exclu√≠da, ou seja, atualizada.  As transa√ß√µes ignoram esse n√∫mero devido ao conjunto de bits <code>xmax_aborted</code> . <br><br>  Vamos dar mais um passo para melhorar a legibilidade acrescentando bits de informa√ß√£o aos IDs de transa√ß√£o.  E vamos criar a fun√ß√£o, pois precisaremos da consulta mais de uma vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  O que est√° acontecendo no cabe√ßalho da vers√£o da linha √© muito mais claro neste formato: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Podemos obter informa√ß√µes semelhantes, mas muito menos detalhadas, da pr√≥pria tabela usando as pseudo-colunas <code>xmin</code> e <code>xmax</code> : <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Confirmar </h1><br>  Quando uma transa√ß√£o √© bem-sucedida, seu status deve ser lembrado, ou seja, a transa√ß√£o deve ser marcada como confirmada.  Para esse fim, a estrutura XACT √© usada.  (Antes da vers√£o 10, era chamado CLOG (commit log), e √© prov√°vel que voc√™ encontre esse nome.) <br><br>  XACT n√£o √© uma tabela do cat√°logo do sistema, mas arquivos no diret√≥rio PGDATA / pg_xact.  Dois bits s√£o alocados nesses arquivos para cada transa√ß√£o - "confirmada" e "abortada" - exatamente da mesma maneira que no cabe√ßalho da tupla.  Essas informa√ß√µes est√£o espalhadas por v√°rios arquivos apenas por conveni√™ncia;  voltaremos a isso quando discutirmos o congelamento.  O PostgreSQL trabalha com esses arquivos p√°gina por p√°gina, como em todos os outros. <br><br>  Portanto, quando uma transa√ß√£o √© confirmada, o bit "confirmado" √© definido para essa transa√ß√£o no XACT.  E isso √© tudo o que acontece quando a transa√ß√£o √© confirmada (embora ainda n√£o mencionemos o log de grava√ß√£o antecipada). <br><br>  Quando alguma outra transa√ß√£o acessar a p√°gina da tabela que est√°vamos vendo, a primeira ter√° que responder a algumas perguntas. <br><br><ol><li>  A transa√ß√£o <code>xmin</code> conclu√≠da?  Caso contr√°rio, a tupla criada n√£o deve estar vis√≠vel. <br>  Isso √© verificado olhando atrav√©s de outra estrutura, localizada na mem√≥ria compartilhada da inst√¢ncia e chamada ProcArray.  Essa estrutura mant√©m uma lista de todos os processos ativos, juntamente com o ID da transa√ß√£o atual (ativa) de cada um. </li><li>  Se a transa√ß√£o foi conclu√≠da, ela foi confirmada ou revertida?  Se foi revertida, a tupla tamb√©m n√£o deve estar vis√≠vel. <br>  √â exatamente para isso que o XACT √© necess√°rio.  Mas √© caro verificar o XACT a cada vez, embora as √∫ltimas p√°ginas do XACT sejam armazenadas em buffers na mem√≥ria compartilhada.  Portanto, uma vez descoberto, o status da transa√ß√£o √© gravado nos bits <code>xmin_aborted</code> e <code>xmin_aborted</code> da tupla.  Se qualquer um desses bits estiver definido, o status da transa√ß√£o ser√° tratado como conhecido e a pr√≥xima transa√ß√£o n√£o precisar√° verificar XACT. </li></ol><br>  Por que a transa√ß√£o que executa a inser√ß√£o define esses bits?  Quando uma inser√ß√£o est√° sendo executada, a transa√ß√£o ainda n√£o sabe se ser√° conclu√≠da com √™xito.  E no momento da confirma√ß√£o j√° n√£o est√° claro quais linhas e quais p√°ginas foram alteradas.  Pode haver muitas dessas p√°ginas e √© impratic√°vel acompanh√°-las.  Al√©m disso, algumas das p√°ginas podem ser despejadas em disco do cache do buffer;  l√™-los novamente para alterar os bits significaria uma desacelera√ß√£o significativa do commit. <br><br>  O lado oposto da economia de custos √© que, ap√≥s as atualiza√ß√µes, qualquer transa√ß√£o (mesmo a que executa o SELECT) pode come√ßar a alterar as p√°ginas de dados no cache do buffer. <br><br>  Ent√£o, comprometemos a mudan√ßa. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Nada mudou na p√°gina (mas sabemos que o status das transa√ß√µes j√° est√° gravado no XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Agora, uma transa√ß√£o que acessa primeiro a p√°gina precisar√° determinar o status da transa√ß√£o <code>xmin</code> e grav√°-la nos bits de informa√ß√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Excluir </h1><br>  Quando uma linha √© exclu√≠da, o ID da transa√ß√£o de exclus√£o atual √© gravado no campo <code>xmax</code> da vers√£o atualizada e o bit <code>xmax_aborted</code> √© redefinido. <br><br>  Observe que o valor de <code>xmax</code> correspondente √† transa√ß√£o ativa funciona como um bloqueio de linha.  Se outra transa√ß√£o for atualizar ou excluir esta linha, ela ter√° que esperar at√© que a transa√ß√£o <code>xmax</code> conclu√≠da.  Falaremos sobre bloqueios com mais detalhes posteriormente.  Nesse ponto, observe apenas que o n√∫mero de bloqueios de linha n√£o √© limitado.  Eles n√£o ocupam mem√≥ria e o desempenho do sistema n√£o √© afetado por esse n√∫mero.  No entanto, transa√ß√µes de longa dura√ß√£o t√™m outras desvantagens, que tamb√©m ser√£o discutidas mais adiante. <br><br>  Vamos excluir uma linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Vemos que o ID da transa√ß√£o √© gravado no campo <code>xmax</code> , mas os bits de informa√ß√£o n√£o est√£o definidos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Abortar </h1><br>  O cancelamento de uma transa√ß√£o funciona da mesma forma que o commit, exceto que o bit "cancelado" est√° definido no XACT.  Um cancelamento √© feito t√£o r√°pido quanto um commit.  Embora o comando seja chamado ROLLBACK, as altera√ß√µes n√£o s√£o revertidas: tudo o que a transa√ß√£o j√° mudou, permanece intocado. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Ao acessar a p√°gina, o status ser√° verificado e o bit de dica <code>xmax_aborted</code> ser√° definido.  Embora o pr√≥prio n√∫mero <code>xmax</code> ainda esteja na p√°gina, ele n√£o ser√° visto. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Update </h1><br>  Uma atualiza√ß√£o funciona como se a vers√£o atual fosse exclu√≠da primeiro e depois uma nova fosse inserida. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  A consulta retorna uma linha (a nova vers√£o): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Mas podemos ver as duas vers√µes na p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  A vers√£o exclu√≠da √© rotulada com o ID da transa√ß√£o atual no campo <code>xmax</code> .  Al√©m disso, esse valor substituiu o antigo desde que a transa√ß√£o anterior foi revertida.  E o bit <code>xmax_aborted</code> √© redefinido, pois o status da transa√ß√£o atual ainda √© desconhecido. <br><br>  A primeira vers√£o da linha agora est√° fazendo refer√™ncia √† segunda, como uma mais nova. <br><br>  A p√°gina de √≠ndice agora cont√©m o segundo ponteiro e a segunda linha, que referencia a segunda vers√£o na p√°gina da tabela. <br><br>  Da mesma maneira que para uma exclus√£o, o valor de <code>xmax</code> na primeira vers√£o indica que a linha est√° bloqueada. <br><br>  Por fim, confirmamos a transa√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  √çndices </h1><br>  Est√°vamos conversando apenas sobre as p√°ginas da tabela at√© agora.  Mas o que acontece dentro dos √≠ndices? <br><br>  As informa√ß√µes nas p√°ginas de √≠ndice dependem muito do tipo de √≠ndice espec√≠fico.  Al√©m disso, mesmo um tipo de √≠ndices pode ter diferentes tipos de p√°ginas.  Por exemplo: uma √°rvore B possui a p√°gina de metadados e as p√°ginas "normais". <br><br>  No entanto, uma p√°gina de √≠ndice geralmente possui uma matriz de ponteiros para as linhas e linhas (como as p√°ginas da tabela).  Al√©m disso, algum espa√ßo no final de uma p√°gina √© alocado para dados especiais. <br><br>  Linhas em √≠ndices tamb√©m podem ter estruturas diferentes, dependendo do tipo de √≠ndice.  Por exemplo: em uma √°rvore B, as linhas pertinentes √†s p√°ginas folha cont√™m o valor da chave de indexa√ß√£o e uma refer√™ncia ( <code>ctid</code> ) √† linha da tabela apropriada.  Em geral, um √≠ndice pode ser estruturado de uma maneira bem diferente. <br><br>  O ponto principal √© que, em √≠ndices de qualquer tipo, n√£o h√° <em>vers√µes de</em> linha.  Ou podemos considerar que cada linha seja representada por apenas uma vers√£o.  Em outras palavras, o cabe√ßalho da linha de √≠ndice n√£o cont√©m os campos <code>xmin</code> e <code>xmax</code> .  Por enquanto, podemos assumir que as refer√™ncias do √≠ndice apontam para todas as vers√µes das linhas da tabela.  Portanto, para descobrir quais vers√µes de linha s√£o vis√≠veis para uma transa√ß√£o, o PostgreSQL precisa examinar a tabela.  (Como sempre, essa n√£o √© a hist√≥ria toda. √Äs vezes, o mapa de visibilidade permite otimizar o processo, mas discutiremos isso mais tarde.) <br><br>  Aqui, na p√°gina de √≠ndice, encontramos indicadores para ambas as vers√µes: a atualizada e a anterior: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transa√ß√µes virtuais </h1><br>  Na pr√°tica, o PostgreSQL tira proveito de uma otimiza√ß√£o que permite gastar "moderadamente" os IDs de transa√ß√£o. <br><br>  Se uma transa√ß√£o apenas l√™ dados, ela n√£o afeta a visibilidade da tupla.  Portanto, primeiro o processo de back-end atribui um ID virtual (xid virtual) √† transa√ß√£o.  Esse ID consiste no identificador do processo e em um n√∫mero seq√ºencial. <br><br>  A atribui√ß√£o desse ID virtual n√£o requer sincroniza√ß√£o entre todos os processos e, portanto, √© realizada muito rapidamente.  Aprenderemos outro motivo do uso de IDs virtuais quando discutirmos o congelamento. <br><br>  Os instant√¢neos de dados n√£o levam em considera√ß√£o o ID virtual. <br><br>  Em diferentes momentos, o sistema pode ter transa√ß√µes virtuais com IDs que j√° foram usados, e isso √© bom.  Mas esse ID n√£o pode ser gravado nas p√°ginas de dados, pois quando a p√°gina √© acessada na pr√≥xima vez, o ID pode se tornar sem sentido. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Por√©m, se uma transa√ß√£o come√ßar a alterar dados, ela receber√° um ID de transa√ß√£o verdadeiro e exclusivo. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Subtransa√ß√µes </h1><br><h2>  Savepoints </h2><br>  No SQL, s√£o definidos pontos de <em>salvamento</em> , que permitem reverter algumas opera√ß√µes da transa√ß√£o sem o aborto completo.  Mas isso √© incompat√≠vel com o modelo acima, pois o status da transa√ß√£o √© um para todas as altera√ß√µes e nenhum dado √© fisicamente revertido. <br><br>  Para implementar essa funcionalidade, uma transa√ß√£o com um ponto de salvamento √© dividida em v√°rias <em>subtransa√ß√µes</em> separadas cujos status podem ser gerenciados separadamente. <br><br>  As subtrabsa√ß√µes t√™m seus pr√≥prios IDs (maiores que o ID da transa√ß√£o principal).  Os status das subtransa√ß√µes s√£o gravados no XACT da maneira usual, mas o status final depende do status da transa√ß√£o principal: se for revertida, todas as subtransa√ß√µes tamb√©m ser√£o revertidas. <br><br>  As informa√ß√µes sobre o aninhamento de subtransa√ß√µes s√£o armazenadas nos arquivos do diret√≥rio PGDATA / pg_subtrans.  Esses arquivos s√£o acessados ‚Äã‚Äãpor meio de buffers na mem√≥ria compartilhada da inst√¢ncia, estruturados da mesma maneira que os buffers XACT. <br><br>  N√£o confunda subtransa√ß√µes com transa√ß√µes aut√¥nomas.  As transa√ß√µes aut√¥nomas n√£o dependem uma da outra, enquanto as subtransa√ß√µes dependem.  N√£o h√° transa√ß√µes aut√¥nomas no PostgreSQL comum, o que √©, talvez, para melhor: elas s√£o realmente necess√°rias muito raramente, e sua disponibilidade em outros DBMS convida a abusos, que todos sofrem. <br><br>  Vamos limpar a tabela, iniciar uma transa√ß√£o e inserir uma linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Agora, estabelecemos um ponto de salvamento e inserimos outra linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Observe que a fun√ß√£o <code>txid_current</code> retorna o ID da transa√ß√£o principal em vez da subtransa√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Vamos reverter para o ponto de salvamento e inserir a terceira linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Na p√°gina, continuamos a ver a linha que foi adicionada pela subtransa√ß√£o revertida. <br><br>  Confirmando as altera√ß√µes. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  √â claramente visto agora que cada subtransa√ß√£o tem seu pr√≥prio status. <br><br>  Observe que o SQL n√£o permite o uso expl√≠cito de subtransa√ß√µes, ou seja, voc√™ n√£o pode iniciar uma nova transa√ß√£o antes de concluir a atual.  Essa t√©cnica se envolve implicitamente quando pontos de salvamento s√£o usados ‚Äã‚Äãe tamb√©m ao lidar com exce√ß√µes do PL / pgSQL, bem como em outras situa√ß√µes mais ex√≥ticas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Erros e atomicidade da opera√ß√£o </h2><br>  O que acontece se ocorrer um erro enquanto a opera√ß√£o estiver sendo executada?  Por exemplo, assim: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Ocorreu um erro.  Agora a transa√ß√£o √© tratada como abortada e nenhuma opera√ß√£o √© permitida nela: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  E mesmo se tentarmos confirmar as altera√ß√µes, o PostgreSQL reportar√° a revers√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Por que √© imposs√≠vel continuar a execu√ß√£o da transa√ß√£o ap√≥s uma falha?  O problema √© que o erro poderia ocorrer para que tiv√©ssemos acesso a parte das altera√ß√µes, ou seja, a atomicidade seria interrompida n√£o apenas para a transa√ß√£o, mas tamb√©m para um √∫nico operador.  Por exemplo, em nosso exemplo, o operador poderia ter atualizado uma linha antes do erro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Vale ressaltar que o psql possui um modo que permite continuar a transa√ß√£o ap√≥s a falha, como se os efeitos do operador incorreto fossem revertidos. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  √â f√°cil descobrir que, nesse modo, o psql realmente estabelece um ponto de salvaguarda impl√≠cito antes de cada comando e inicia uma revers√£o para ele em caso de falha.  Esse modo n√£o √© usado por padr√£o, pois o estabelecimento de pontos de salvamento (mesmo sem revers√£o) implica uma sobrecarga significativa. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477648/">https://habr.com/ru/post/pt477648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477634/index.html">Microsservi√ßos e estrutura organizacional. Que tipos de equipes garantir√£o o sucesso?</a></li>
<li><a href="../pt477638/index.html">Comprado! = Seu: John Deere rouba os agricultores do direito de consertar seus pr√≥prios tratores</a></li>
<li><a href="../pt477642/index.html">A vis√£o de m√°quina (r√°dio) v√™ atrav√©s das paredes</a></li>
<li><a href="../pt477644/index.html">Restaurando o UNIX v0 para o PDP-7: detalhes da sala de bastidores</a></li>
<li><a href="../pt477646/index.html">Matem√°ticos cortam formas em busca de partes de equa√ß√µes</a></li>
<li><a href="../pt477650/index.html">Criptografia do tr√°fego TLS de acordo com os algoritmos GOST-2012 com Stunnel</a></li>
<li><a href="../pt477654/index.html">Tentando a inst√¢ncia aprimorada do operador em Java 14</a></li>
<li><a href="../pt477656/index.html">Ainda assim, por que voc√™ precisa fazer?</a></li>
<li><a href="../pt477658/index.html">Restaura√ß√£o ativa: a recupera√ß√£o de desastres pode ser mais r√°pida? Muito mais r√°pido?</a></li>
<li><a href="../pt477662/index.html">Acesso aos pneus Redd nas pontes FTDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>