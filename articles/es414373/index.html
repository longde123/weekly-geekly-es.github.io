<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏽 🧓🏻 ❤️ Diseño asincrónico / en espera de JavaScript: fortalezas, dificultades y patrones de uso 🧜🏿 👋🏻 🤷🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La construcción asíncrona / espera apareció en el estándar ES7. Se puede considerar una mejora notable en el campo de la programación asincrónica en J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Diseño asincrónico / en espera de JavaScript: fortalezas, dificultades y patrones de uso</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414373/">  La construcción asíncrona / espera apareció en el estándar ES7.  Se puede considerar una mejora notable en el campo de la programación asincrónica en JavaScript.  Le permite escribir código que parece síncrono, pero se utiliza para resolver tareas asíncronas y no bloquea el hilo principal.  A pesar de que async / await es una gran característica nueva del lenguaje, usarlo correctamente no es tan simple.  El material, cuya traducción publicamos hoy, está dedicado a un estudio exhaustivo de async / wait y una historia sobre cómo usar este mecanismo de manera correcta y efectiva. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/ea6/61a/e97/ea661ae979bc9999209bca9db6744dc5.png" alt="imagen"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Fortalezas de asíncrono / espera</font> </h2><br>  El beneficio más importante que obtiene un programador que utiliza la construcción async / await es que permite escribir código asincrónico en un estilo específico para el código síncrono.  Compare el código escrito usando async / await con el código basado en promesas. <br><br><pre><code class="hljs pgsql">// async/await async getBooksByAuthorWithAwait(authorId) {  const books = await bookModel.fetchAll();  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId); } //  getBooksByAuthorWithPromise(authorId) {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(books =&gt; books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId)); }</code> </pre> <br>  Es fácil notar que la versión asíncrona / en espera del ejemplo es más comprensible que su versión, en la que se utiliza la promesa.  Si no presta atención a la palabra clave en <code>await</code> , este código se verá como un conjunto regular de instrucciones ejecutadas sincrónicamente, como en JavaScript familiar o en cualquier otro lenguaje sincrónico como Python. <br><br>  El atractivo de async / await no solo se debe a la legibilidad mejorada del código.  Este mecanismo, además, goza de una excelente compatibilidad con el navegador, que no requiere soluciones alternativas.  Por lo tanto, hoy las funciones asincrónicas son totalmente compatibles con todos los principales navegadores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b98/324/a94/b98324a94798cf96620a3ed89c88204d.png"></div><br>  <i><font color="#999999">Todos los principales navegadores admiten funciones asincrónicas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">caniuse.com</a> )</font></i> <br><br>  Este nivel de soporte significa, por ejemplo, que el código que usa async / await no necesita ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transpuesto</a> .  Además, facilita la depuración, que quizás sea aún más importante que la falta de necesidad de transpilación. <br><br>  La siguiente figura muestra el proceso de depuración de una función asincrónica.  Aquí, al establecer un punto de interrupción en la primera instrucción de la función y al ejecutar el comando Paso a paso, cuando el depurador llega a la línea donde se usa la palabra clave de <code>await</code> , puede observar cómo el depurador hace una pausa durante un tiempo, esperando que <code>bookModel.fetchAll()</code> función <code>bookModel.fetchAll()</code> , y luego salta a la línea donde se <code>.filter()</code> comando <code>.filter()</code> !  Tal proceso de depuración parece mucho más simple que las promesas de depuración.  Aquí, al depurar un código similar, debería establecer otro punto de interrupción en la <code>.filter()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23d/bdb/4e0/23dbdb4e062eb7523a1d677e6255e880.gif"><br>  <i><font color="#999999">Depuración de una función asincrónica.</font></i>  <i><font color="#999999">El depurador esperará a que se complete la línea de espera y pasará a la siguiente línea después de que se complete la operación</font></i> <br><br>  Otra fortaleza del mecanismo en consideración, que es menos obvio que lo que ya hemos examinado, es la presencia de la palabra clave <code>async</code> aquí.  En nuestro caso, su uso garantiza que el valor devuelto por <code>getBooksByAuthorWithAwait()</code> sea ​​una promesa.  Como resultado, puede usar de forma segura el <code>getBooksByAuthorWithAwait().then(...)</code> o <code>await getBooksByAuthorWithAwait()</code> construcción <code>await getBooksByAuthorWithAwait()</code> en el código que llama a esta función.  Considere el siguiente ejemplo (tenga en cuenta que esto no se recomienda): <br><br><pre> <code class="hljs javascript">getBooksByAuthorWithPromise(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!authorId) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books</span></span></span><span class="hljs-function"> =&gt;</span></span> books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function"> =&gt;</span></span> b.authorId === authorId)); } }</code> </pre> <br>  Aquí la función <code>getBooksByAuthorWithPromise()</code> puede, si todo está bien, devolver una promesa o, si algo salió mal, <code>null</code> .  Como resultado, si se produce un error, no puede llamar con seguridad <code>.then()</code> .  Al declarar funciones utilizando la <code>async</code> errores de este tipo son imposibles. <br><br><h2>  <font color="#3AC1EF">Sobre la percepción errónea de async / wait</font> </h2><br>  En algunas publicaciones, la construcción asíncrona / en espera se compara con las promesas y se dice que representa la próxima generación de la evolución de la programación asíncrona de JavaScript.  Con esto, con el debido respeto a los autores de tales publicaciones, me permito estar en desacuerdo.  Async / await es una mejora, pero no es más que "azúcar sintáctico", cuya apariencia no conduce a un cambio completo en el estilo de programación. <br><br>  En esencia, las funciones asincrónicas son promesas.  Antes de que un programador pueda usar adecuadamente la construcción asíncrona / espera, debe estudiar bien las promesas.  Además, en la mayoría de los casos, al trabajar con funciones asincrónicas, debe usar promesas. <br><br>  Eche un vistazo a las <code>getBooksByAuthorWithAwait()</code> y <code>getBooksByAuthorWithPromises()</code> del ejemplo anterior.  Tenga en cuenta que son idénticos no solo en términos de funcionalidad.  También tienen exactamente las mismas interfaces. <br><br>  Todo esto significa que si llama directamente a la función <code>getBooksByAuthorWithAwait()</code> , devolverá la promesa. <br><br>  De hecho, la esencia del problema del que estamos hablando aquí es la percepción incorrecta del nuevo diseño, cuando crea una sensación engañosa de que una función síncrona se puede convertir en asíncrona debido al simple uso del <code>async</code> y <code>await</code> palabras clave y no pensar en otra cosa. <br><br><h2>  <font color="#3AC1EF">Las trampas de async / aguardan</font> </h2><br>  Hablemos de los errores más comunes que se pueden cometer usando async / await.  En particular, sobre el uso irracional de llamadas sucesivas de funciones asincrónicas. <br><br>  Aunque la palabra clave <code>await</code> puede hacer que el código parezca síncrono, al usarlo, vale la pena recordar que el código es asíncrono, lo que significa que debe tener mucho cuidado con las llamadas en serie a funciones asíncronas. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Este código, en términos de lógica, parece correcto.  Sin embargo, hay un problema grave.  Así es como funciona. <br><br><ol><li>  Las llamadas del sistema <code>await bookModel.fetchAll()</code> y espera a que se <code>.fetchAll()</code> comando <code>.fetchAll()</code> . </li><li>  Después de recibir el resultado de <code>bookModel.fetchAll()</code> <code>await authorModel.fetch(authorId)</code> . </li></ol><br>  Tenga en cuenta que la llamada a <code>authorModel.fetch(authorId)</code> es independiente de los resultados de la llamada a <code>bookModel.fetchAll()</code> y, de hecho, estos dos comandos se pueden ejecutar en paralelo.  Sin embargo, el uso de los resultados de <code>await</code> en estas dos llamadas se ejecutan secuencialmente.  El tiempo total de ejecución secuencial de estos dos comandos será más largo que el tiempo de su ejecución paralela. <br><br>  Aquí está el enfoque correcto para escribir dicho código: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bookPromise = bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authorPromise = authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> book = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookPromise; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Considere otro ejemplo del mal uso de las funciones asincrónicas.  Esto es aún peor que en el ejemplo anterior.  Como puede ver, para cargar asincrónicamente una lista de ciertos elementos, debemos confiar en las posibilidades de las promesas. <br><br><pre> <code class="hljs ruby">async getAuthors(authorIds) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     /<span class="hljs-regexp"><span class="hljs-regexp">/ const authors = _.map( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   authorIds, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   id =&gt; await authorModel.fetch(id)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   const promises = _.map(authorIds, id =&gt; authorModel.fetch(id)); const authors = await Promise.all(promises); }</span></span></code> </pre> <br>  En pocas palabras, entonces, para usar correctamente las funciones asincrónicas, necesita, como en un momento en que esto no era posible, primero pensar en las operaciones asincrónicas y luego escribir el código usando <code>await</code> .  En casos complejos, probablemente será más fácil usar las promesas directamente. <br><br><h2>  <font color="#3AC1EF">Manejo de errores</font> </h2><br>  Cuando se usan promesas, la ejecución del código asincrónico puede finalizar como se esperaba, luego dicen que la promesa se resolvió con éxito o con un error, y luego dicen que la promesa se rechaza.  Esto nos permite usar <code>.then()</code> y <code>.catch()</code> , respectivamente.  Sin embargo, el manejo de errores utilizando el mecanismo asíncrono / espera puede ser complicado. <br><br><h3>  <font color="#3AC1EF">▍ tratar / atrapar construcción</font> </h3><br>  La forma estándar de manejar errores cuando se usa async / await es con la construcción try / catch.  Recomiendo usar este enfoque.  Al realizar una llamada en espera, el valor devuelto cuando se rechaza la promesa se presenta como una excepción.  Aquí hay un ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span><span class="hljs-class"> </span></span>{ fetchAll() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject({<span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>}) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);   }); } } <span class="hljs-comment"><span class="hljs-comment">// async/await async getBooksByAuthorWithAwait(authorId) { try { const books = await bookModel.fetchAll(); } catch (error) { console.log(error);    // { "error": 400 } }</span></span></code> </pre> <br>  El error detectado en el <code>catch</code> es exactamente el valor obtenido cuando se rechaza la promesa.  Después de detectar una excepción, podemos aplicar varios enfoques para trabajar con ella: <br><br><ul><li>  Puede manejar la excepción y devolver el valor normal.  Si no utiliza la expresión de <code>return</code> en el <code>catch</code> para devolver lo que se espera después de que se ejecute la función asincrónica, esto será equivalente a usar el comando <code>return undefined</code> ; </li><li>  Simplemente puede pasar el error al lugar donde se llamó el código que falló y permitir que se procese allí.  Puede lanzar un error directamente usando un comando como <code>throw error;</code>  , que le permite utilizar la función <code>async getBooksByAuthorWithAwait()</code> en la cadena de promesas.  Es decir, se puede <code>getBooksByAuthorWithAwait().then(...).catch(error =&gt; ...)</code> usando la <code>getBooksByAuthorWithAwait().then(...).catch(error =&gt; ...)</code> .  Además, puede ajustar el error en un objeto <code>Error</code> , que puede parecer <code>throw new Error(error)</code> .  Esto permitirá, por ejemplo, al enviar información de error a la consola, ver la pila completa de llamadas. </li><li>  El error se puede representar como una promesa rechazada, parece que <code>return Promise.reject(error)</code> .  En este caso, esto es equivalente al comando <code>throw error</code> ; no se recomienda hacerlo. </li></ul><br>  Estos son los beneficios de usar la construcción try / catch: <br><br><ul><li>  Tales herramientas de manejo de errores han existido en la programación durante mucho tiempo, son simples y comprensibles.  Supongamos que si tiene experiencia en programación en otros lenguajes, como C ++ o Java, comprenderá fácilmente el dispositivo try / catch en JavaScript. </li><li>  Puede colocar varias llamadas en espera en un bloque try / catch, lo que le permite manejar todos los errores en un solo lugar si no necesita manejar por separado los errores en cada paso de la ejecución del código. </li></ul><br>  Cabe señalar que hay un inconveniente en el mecanismo try / catch.  Dado que try / catch captura cualquier excepción que ocurra en el bloque <code>try</code> , esas excepciones que no están relacionadas con las promesas también entrarán en el controlador <code>catch</code> .  Echa un vistazo a este ejemplo. <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span></span> { fetchAll() {   cb();    //    ,   `cb`  ,       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'/books'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { bookModel.fetchAll(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error) { console.log(error);  //       <span class="hljs-string"><span class="hljs-string">"cb is not defined"</span></span> }</code> </pre> <br>  Si ejecuta este código, verá el error <code>ReferenceError: cb is not defined</code> en la consola.  Este mensaje es emitido por el comando <code>console.log()</code> desde el <code>catch</code> , y no por el propio JavaScript.  En algunos casos, tales errores conducen a graves consecuencias.  Por ejemplo, si llama a <code>bookModel.fetchAll();</code>  oculto en una serie de llamadas a funciones y una de las llamadas "tragará" un error, será muy difícil detectarlo. <br><br><h3>  <font color="#3AC1EF">▍ Función de retorno de dos valores</font> </h3><br>  La inspiración para la siguiente forma de manejar errores en código asincrónico es Go.  Permite que las funciones asincrónicas devuelvan tanto un error como un resultado.  Lea más sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  En pocas palabras, las funciones asincrónicas, con este enfoque, se pueden usar así: <br><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">err</span></span>, <span class="hljs-type"><span class="hljs-type">user</span></span>] = await to(UserModel.findById(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  Personalmente, no me gusta esto, porque este método de manejo de errores introduce el estilo de programación Go en JavaScript, que parece poco natural, aunque, en algunos casos, puede ser muy útil. <br><br><h3>  <font color="#3AC1EF">▍Uso de .catch</font> </h3><br>  La última forma de manejar los errores, de los que hablaremos, es usar <code>.catch()</code> . <br><br>  Piensa en cómo funciona la <code>await</code> .  Es decir, el uso de esta palabra clave hace que el sistema espere hasta que la promesa complete su trabajo.  Además, recuerde que un comando de la forma <code>promise.catch()</code> también devuelve una promesa.  Todo esto sugiere que los errores de función asincrónica se pueden manejar de esta manera: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> books   <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>     let books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); });</code> </pre> <br>  Dos pequeños problemas son característicos de este enfoque: <br><br><ul><li>  Esta es una mezcla de promesas y funciones asincrónicas.  Para usar esto, es necesario, como en otros casos similares, comprender las características del trabajo de las promesas. </li><li>  Este enfoque no es intuitivo, ya que el manejo de errores se realiza en un lugar inusual. </li></ul><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  La construcción async / await, que se introdujo en ES7, es definitivamente una mejora en los mecanismos de programación asincrónica de JavaScript.  Puede facilitar la lectura y la depuración de código.  Sin embargo, para usar async / await correctamente, es necesario un conocimiento profundo de las promesas, ya que async / await es solo "azúcar sintáctico" basado en promesas. <br><br>  Esperamos que este material le haya permitido familiarizarse más con async / wait, y lo que aprendió aquí lo salvará de algunos errores comunes que surgen al usar esta construcción. <br><br>  <b>Estimados lectores!</b>  ¿Utiliza la construcción async / await en JavaScript?  Si es así, díganos cómo maneja los errores en el código asíncrono. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414373/">https://habr.com/ru/post/es414373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414361/index.html">Unity3D: Arquitectura de juego, Objetos de secuencias de comandos, Singletones</a></li>
<li><a href="../es414363/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 319 (11 al 17 de junio de 2018)</a></li>
<li><a href="../es414367/index.html">Galopando en tres años: lo que puede ser interesante volver a leer en el blog HashFlare</a></li>
<li><a href="../es414369/index.html">Servidor de impresión tolerante a fallas de Windows</a></li>
<li><a href="../es414371/index.html">Clase escolar y un pequeño boceto de ingeniería social.</a></li>
<li><a href="../es414375/index.html">Comandos para trabajar con la consola de JavaScript en navegadores y aumentar la productividad del programador</a></li>
<li><a href="../es414377/index.html">Innovaciones de literales de objetos en JavaScript ES6</a></li>
<li><a href="../es414379/index.html">"Los que están dispuestos a intercambiar libertad por seguridad no son dignos de libertad ni de seguridad" (fuente original)</a></li>
<li><a href="../es414381/index.html">Airwheel R8 E-bike: debajo del piloto o re-bike</a></li>
<li><a href="../es414383/index.html">Los cables submarinos de fibra óptica también pueden funcionar como sismógrafos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>