<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèΩ üßìüèª ‚ù§Ô∏è Dise√±o asincr√≥nico / en espera de JavaScript: fortalezas, dificultades y patrones de uso üßúüèø üëãüèª ü§∑üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La construcci√≥n as√≠ncrona / espera apareci√≥ en el est√°ndar ES7. Se puede considerar una mejora notable en el campo de la programaci√≥n asincr√≥nica en J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dise√±o asincr√≥nico / en espera de JavaScript: fortalezas, dificultades y patrones de uso</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414373/">  La construcci√≥n as√≠ncrona / espera apareci√≥ en el est√°ndar ES7.  Se puede considerar una mejora notable en el campo de la programaci√≥n asincr√≥nica en JavaScript.  Le permite escribir c√≥digo que parece s√≠ncrono, pero se utiliza para resolver tareas as√≠ncronas y no bloquea el hilo principal.  A pesar de que async / await es una gran caracter√≠stica nueva del lenguaje, usarlo correctamente no es tan simple.  El material, cuya traducci√≥n publicamos hoy, est√° dedicado a un estudio exhaustivo de async / wait y una historia sobre c√≥mo usar este mecanismo de manera correcta y efectiva. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/ea6/61a/e97/ea661ae979bc9999209bca9db6744dc5.png" alt="imagen"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Fortalezas de as√≠ncrono / espera</font> </h2><br>  El beneficio m√°s importante que obtiene un programador que utiliza la construcci√≥n async / await es que permite escribir c√≥digo asincr√≥nico en un estilo espec√≠fico para el c√≥digo s√≠ncrono.  Compare el c√≥digo escrito usando async / await con el c√≥digo basado en promesas. <br><br><pre><code class="hljs pgsql">// async/await async getBooksByAuthorWithAwait(authorId) {  const books = await bookModel.fetchAll();  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId); } //  getBooksByAuthorWithPromise(authorId) {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(books =&gt; books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId)); }</code> </pre> <br>  Es f√°cil notar que la versi√≥n as√≠ncrona / en espera del ejemplo es m√°s comprensible que su versi√≥n, en la que se utiliza la promesa.  Si no presta atenci√≥n a la palabra clave en <code>await</code> , este c√≥digo se ver√° como un conjunto regular de instrucciones ejecutadas sincr√≥nicamente, como en JavaScript familiar o en cualquier otro lenguaje sincr√≥nico como Python. <br><br>  El atractivo de async / await no solo se debe a la legibilidad mejorada del c√≥digo.  Este mecanismo, adem√°s, goza de una excelente compatibilidad con el navegador, que no requiere soluciones alternativas.  Por lo tanto, hoy las funciones asincr√≥nicas son totalmente compatibles con todos los principales navegadores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b98/324/a94/b98324a94798cf96620a3ed89c88204d.png"></div><br>  <i><font color="#999999">Todos los principales navegadores admiten funciones asincr√≥nicas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">caniuse.com</a> )</font></i> <br><br>  Este nivel de soporte significa, por ejemplo, que el c√≥digo que usa async / await no necesita ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transpuesto</a> .  Adem√°s, facilita la depuraci√≥n, que quiz√°s sea a√∫n m√°s importante que la falta de necesidad de transpilaci√≥n. <br><br>  La siguiente figura muestra el proceso de depuraci√≥n de una funci√≥n asincr√≥nica.  Aqu√≠, al establecer un punto de interrupci√≥n en la primera instrucci√≥n de la funci√≥n y al ejecutar el comando Paso a paso, cuando el depurador llega a la l√≠nea donde se usa la palabra clave de <code>await</code> , puede observar c√≥mo el depurador hace una pausa durante un tiempo, esperando que <code>bookModel.fetchAll()</code> funci√≥n <code>bookModel.fetchAll()</code> , y luego salta a la l√≠nea donde se <code>.filter()</code> comando <code>.filter()</code> !  Tal proceso de depuraci√≥n parece mucho m√°s simple que las promesas de depuraci√≥n.  Aqu√≠, al depurar un c√≥digo similar, deber√≠a establecer otro punto de interrupci√≥n en la <code>.filter()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23d/bdb/4e0/23dbdb4e062eb7523a1d677e6255e880.gif"><br>  <i><font color="#999999">Depuraci√≥n de una funci√≥n asincr√≥nica.</font></i>  <i><font color="#999999">El depurador esperar√° a que se complete la l√≠nea de espera y pasar√° a la siguiente l√≠nea despu√©s de que se complete la operaci√≥n</font></i> <br><br>  Otra fortaleza del mecanismo en consideraci√≥n, que es menos obvio que lo que ya hemos examinado, es la presencia de la palabra clave <code>async</code> aqu√≠.  En nuestro caso, su uso garantiza que el valor devuelto por <code>getBooksByAuthorWithAwait()</code> sea ‚Äã‚Äãuna promesa.  Como resultado, puede usar de forma segura el <code>getBooksByAuthorWithAwait().then(...)</code> o <code>await getBooksByAuthorWithAwait()</code> construcci√≥n <code>await getBooksByAuthorWithAwait()</code> en el c√≥digo que llama a esta funci√≥n.  Considere el siguiente ejemplo (tenga en cuenta que esto no se recomienda): <br><br><pre> <code class="hljs javascript">getBooksByAuthorWithPromise(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!authorId) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books</span></span></span><span class="hljs-function"> =&gt;</span></span> books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function"> =&gt;</span></span> b.authorId === authorId)); } }</code> </pre> <br>  Aqu√≠ la funci√≥n <code>getBooksByAuthorWithPromise()</code> puede, si todo est√° bien, devolver una promesa o, si algo sali√≥ mal, <code>null</code> .  Como resultado, si se produce un error, no puede llamar con seguridad <code>.then()</code> .  Al declarar funciones utilizando la <code>async</code> errores de este tipo son imposibles. <br><br><h2>  <font color="#3AC1EF">Sobre la percepci√≥n err√≥nea de async / wait</font> </h2><br>  En algunas publicaciones, la construcci√≥n as√≠ncrona / en espera se compara con las promesas y se dice que representa la pr√≥xima generaci√≥n de la evoluci√≥n de la programaci√≥n as√≠ncrona de JavaScript.  Con esto, con el debido respeto a los autores de tales publicaciones, me permito estar en desacuerdo.  Async / await es una mejora, pero no es m√°s que "az√∫car sint√°ctico", cuya apariencia no conduce a un cambio completo en el estilo de programaci√≥n. <br><br>  En esencia, las funciones asincr√≥nicas son promesas.  Antes de que un programador pueda usar adecuadamente la construcci√≥n as√≠ncrona / espera, debe estudiar bien las promesas.  Adem√°s, en la mayor√≠a de los casos, al trabajar con funciones asincr√≥nicas, debe usar promesas. <br><br>  Eche un vistazo a las <code>getBooksByAuthorWithAwait()</code> y <code>getBooksByAuthorWithPromises()</code> del ejemplo anterior.  Tenga en cuenta que son id√©nticos no solo en t√©rminos de funcionalidad.  Tambi√©n tienen exactamente las mismas interfaces. <br><br>  Todo esto significa que si llama directamente a la funci√≥n <code>getBooksByAuthorWithAwait()</code> , devolver√° la promesa. <br><br>  De hecho, la esencia del problema del que estamos hablando aqu√≠ es la percepci√≥n incorrecta del nuevo dise√±o, cuando crea una sensaci√≥n enga√±osa de que una funci√≥n s√≠ncrona se puede convertir en as√≠ncrona debido al simple uso del <code>async</code> y <code>await</code> palabras clave y no pensar en otra cosa. <br><br><h2>  <font color="#3AC1EF">Las trampas de async / aguardan</font> </h2><br>  Hablemos de los errores m√°s comunes que se pueden cometer usando async / await.  En particular, sobre el uso irracional de llamadas sucesivas de funciones asincr√≥nicas. <br><br>  Aunque la palabra clave <code>await</code> puede hacer que el c√≥digo parezca s√≠ncrono, al usarlo, vale la pena recordar que el c√≥digo es as√≠ncrono, lo que significa que debe tener mucho cuidado con las llamadas en serie a funciones as√≠ncronas. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Este c√≥digo, en t√©rminos de l√≥gica, parece correcto.  Sin embargo, hay un problema grave.  As√≠ es como funciona. <br><br><ol><li>  Las llamadas del sistema <code>await bookModel.fetchAll()</code> y espera a que se <code>.fetchAll()</code> comando <code>.fetchAll()</code> . </li><li>  Despu√©s de recibir el resultado de <code>bookModel.fetchAll()</code> <code>await authorModel.fetch(authorId)</code> . </li></ol><br>  Tenga en cuenta que la llamada a <code>authorModel.fetch(authorId)</code> es independiente de los resultados de la llamada a <code>bookModel.fetchAll()</code> y, de hecho, estos dos comandos se pueden ejecutar en paralelo.  Sin embargo, el uso de los resultados de <code>await</code> en estas dos llamadas se ejecutan secuencialmente.  El tiempo total de ejecuci√≥n secuencial de estos dos comandos ser√° m√°s largo que el tiempo de su ejecuci√≥n paralela. <br><br>  Aqu√≠ est√° el enfoque correcto para escribir dicho c√≥digo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bookPromise = bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authorPromise = authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> book = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookPromise; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Considere otro ejemplo del mal uso de las funciones asincr√≥nicas.  Esto es a√∫n peor que en el ejemplo anterior.  Como puede ver, para cargar asincr√≥nicamente una lista de ciertos elementos, debemos confiar en las posibilidades de las promesas. <br><br><pre> <code class="hljs ruby">async getAuthors(authorIds) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     /<span class="hljs-regexp"><span class="hljs-regexp">/ const authors = _.map( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   authorIds, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   id =&gt; await authorModel.fetch(id)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   const promises = _.map(authorIds, id =&gt; authorModel.fetch(id)); const authors = await Promise.all(promises); }</span></span></code> </pre> <br>  En pocas palabras, entonces, para usar correctamente las funciones asincr√≥nicas, necesita, como en un momento en que esto no era posible, primero pensar en las operaciones asincr√≥nicas y luego escribir el c√≥digo usando <code>await</code> .  En casos complejos, probablemente ser√° m√°s f√°cil usar las promesas directamente. <br><br><h2>  <font color="#3AC1EF">Manejo de errores</font> </h2><br>  Cuando se usan promesas, la ejecuci√≥n del c√≥digo asincr√≥nico puede finalizar como se esperaba, luego dicen que la promesa se resolvi√≥ con √©xito o con un error, y luego dicen que la promesa se rechaza.  Esto nos permite usar <code>.then()</code> y <code>.catch()</code> , respectivamente.  Sin embargo, el manejo de errores utilizando el mecanismo as√≠ncrono / espera puede ser complicado. <br><br><h3>  <font color="#3AC1EF">‚ñç tratar / atrapar construcci√≥n</font> </h3><br>  La forma est√°ndar de manejar errores cuando se usa async / await es con la construcci√≥n try / catch.  Recomiendo usar este enfoque.  Al realizar una llamada en espera, el valor devuelto cuando se rechaza la promesa se presenta como una excepci√≥n.  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span><span class="hljs-class"> </span></span>{ fetchAll() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject({<span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>}) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);   }); } } <span class="hljs-comment"><span class="hljs-comment">// async/await async getBooksByAuthorWithAwait(authorId) { try { const books = await bookModel.fetchAll(); } catch (error) { console.log(error);    // { "error": 400 } }</span></span></code> </pre> <br>  El error detectado en el <code>catch</code> es exactamente el valor obtenido cuando se rechaza la promesa.  Despu√©s de detectar una excepci√≥n, podemos aplicar varios enfoques para trabajar con ella: <br><br><ul><li>  Puede manejar la excepci√≥n y devolver el valor normal.  Si no utiliza la expresi√≥n de <code>return</code> en el <code>catch</code> para devolver lo que se espera despu√©s de que se ejecute la funci√≥n asincr√≥nica, esto ser√° equivalente a usar el comando <code>return undefined</code> ; </li><li>  Simplemente puede pasar el error al lugar donde se llam√≥ el c√≥digo que fall√≥ y permitir que se procese all√≠.  Puede lanzar un error directamente usando un comando como <code>throw error;</code>  , que le permite utilizar la funci√≥n <code>async getBooksByAuthorWithAwait()</code> en la cadena de promesas.  Es decir, se puede <code>getBooksByAuthorWithAwait().then(...).catch(error =&gt; ...)</code> usando la <code>getBooksByAuthorWithAwait().then(...).catch(error =&gt; ...)</code> .  Adem√°s, puede ajustar el error en un objeto <code>Error</code> , que puede parecer <code>throw new Error(error)</code> .  Esto permitir√°, por ejemplo, al enviar informaci√≥n de error a la consola, ver la pila completa de llamadas. </li><li>  El error se puede representar como una promesa rechazada, parece que <code>return Promise.reject(error)</code> .  En este caso, esto es equivalente al comando <code>throw error</code> ; no se recomienda hacerlo. </li></ul><br>  Estos son los beneficios de usar la construcci√≥n try / catch: <br><br><ul><li>  Tales herramientas de manejo de errores han existido en la programaci√≥n durante mucho tiempo, son simples y comprensibles.  Supongamos que si tiene experiencia en programaci√≥n en otros lenguajes, como C ++ o Java, comprender√° f√°cilmente el dispositivo try / catch en JavaScript. </li><li>  Puede colocar varias llamadas en espera en un bloque try / catch, lo que le permite manejar todos los errores en un solo lugar si no necesita manejar por separado los errores en cada paso de la ejecuci√≥n del c√≥digo. </li></ul><br>  Cabe se√±alar que hay un inconveniente en el mecanismo try / catch.  Dado que try / catch captura cualquier excepci√≥n que ocurra en el bloque <code>try</code> , esas excepciones que no est√°n relacionadas con las promesas tambi√©n entrar√°n en el controlador <code>catch</code> .  Echa un vistazo a este ejemplo. <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span></span> { fetchAll() {   cb();    //    ,   `cb`  ,       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'/books'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { bookModel.fetchAll(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error) { console.log(error);  //       <span class="hljs-string"><span class="hljs-string">"cb is not defined"</span></span> }</code> </pre> <br>  Si ejecuta este c√≥digo, ver√° el error <code>ReferenceError: cb is not defined</code> en la consola.  Este mensaje es emitido por el comando <code>console.log()</code> desde el <code>catch</code> , y no por el propio JavaScript.  En algunos casos, tales errores conducen a graves consecuencias.  Por ejemplo, si llama a <code>bookModel.fetchAll();</code>  oculto en una serie de llamadas a funciones y una de las llamadas "tragar√°" un error, ser√° muy dif√≠cil detectarlo. <br><br><h3>  <font color="#3AC1EF">‚ñç Funci√≥n de retorno de dos valores</font> </h3><br>  La inspiraci√≥n para la siguiente forma de manejar errores en c√≥digo asincr√≥nico es Go.  Permite que las funciones asincr√≥nicas devuelvan tanto un error como un resultado.  Lea m√°s sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  En pocas palabras, las funciones asincr√≥nicas, con este enfoque, se pueden usar as√≠: <br><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">err</span></span>, <span class="hljs-type"><span class="hljs-type">user</span></span>] = await to(UserModel.findById(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  Personalmente, no me gusta esto, porque este m√©todo de manejo de errores introduce el estilo de programaci√≥n Go en JavaScript, que parece poco natural, aunque, en algunos casos, puede ser muy √∫til. <br><br><h3>  <font color="#3AC1EF">‚ñçUso de .catch</font> </h3><br>  La √∫ltima forma de manejar los errores, de los que hablaremos, es usar <code>.catch()</code> . <br><br>  Piensa en c√≥mo funciona la <code>await</code> .  Es decir, el uso de esta palabra clave hace que el sistema espere hasta que la promesa complete su trabajo.  Adem√°s, recuerde que un comando de la forma <code>promise.catch()</code> tambi√©n devuelve una promesa.  Todo esto sugiere que los errores de funci√≥n asincr√≥nica se pueden manejar de esta manera: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> books   <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>     let books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); });</code> </pre> <br>  Dos peque√±os problemas son caracter√≠sticos de este enfoque: <br><br><ul><li>  Esta es una mezcla de promesas y funciones asincr√≥nicas.  Para usar esto, es necesario, como en otros casos similares, comprender las caracter√≠sticas del trabajo de las promesas. </li><li>  Este enfoque no es intuitivo, ya que el manejo de errores se realiza en un lugar inusual. </li></ul><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  La construcci√≥n async / await, que se introdujo en ES7, es definitivamente una mejora en los mecanismos de programaci√≥n asincr√≥nica de JavaScript.  Puede facilitar la lectura y la depuraci√≥n de c√≥digo.  Sin embargo, para usar async / await correctamente, es necesario un conocimiento profundo de las promesas, ya que async / await es solo "az√∫car sint√°ctico" basado en promesas. <br><br>  Esperamos que este material le haya permitido familiarizarse m√°s con async / wait, y lo que aprendi√≥ aqu√≠ lo salvar√° de algunos errores comunes que surgen al usar esta construcci√≥n. <br><br>  <b>Estimados lectores!</b>  ¬øUtiliza la construcci√≥n async / await en JavaScript?  Si es as√≠, d√≠ganos c√≥mo maneja los errores en el c√≥digo as√≠ncrono. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414373/">https://habr.com/ru/post/es414373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414361/index.html">Unity3D: Arquitectura de juego, Objetos de secuencias de comandos, Singletones</a></li>
<li><a href="../es414363/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 319 (11 al 17 de junio de 2018)</a></li>
<li><a href="../es414367/index.html">Galopando en tres a√±os: lo que puede ser interesante volver a leer en el blog HashFlare</a></li>
<li><a href="../es414369/index.html">Servidor de impresi√≥n tolerante a fallas de Windows</a></li>
<li><a href="../es414371/index.html">Clase escolar y un peque√±o boceto de ingenier√≠a social.</a></li>
<li><a href="../es414375/index.html">Comandos para trabajar con la consola de JavaScript en navegadores y aumentar la productividad del programador</a></li>
<li><a href="../es414377/index.html">Innovaciones de literales de objetos en JavaScript ES6</a></li>
<li><a href="../es414379/index.html">"Los que est√°n dispuestos a intercambiar libertad por seguridad no son dignos de libertad ni de seguridad" (fuente original)</a></li>
<li><a href="../es414381/index.html">Airwheel R8 E-bike: debajo del piloto o re-bike</a></li>
<li><a href="../es414383/index.html">Los cables submarinos de fibra √≥ptica tambi√©n pueden funcionar como sism√≥grafos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>