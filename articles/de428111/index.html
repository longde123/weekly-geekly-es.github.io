<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèΩ üç≥ üñ≤Ô∏è Arithmetik beliebiger Genauigkeit in Erlang üöÆ üöí üë∞üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="@rawpixel 


 Sogar Schulkinder sind sich der Existenz verschiedener Zahlensysteme und der Tatsache bewusst, dass nicht jeder endliche Dezimalbruch ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arithmetik beliebiger Genauigkeit in Erlang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428111/"><p><img src="https://habrastorage.org/webt/h6/vn/cg/h6vncgl-xdc_8d5peworwhnrg4a.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@rawpixel</a> </p><br><p>  Sogar Schulkinder sind sich der Existenz verschiedener Zahlensysteme und der Tatsache bewusst, dass nicht jeder endliche Dezimalbruch ein endlicher Bruch in einem bin√§ren Zahlensystem ist.  Nur wenige Leute denken, dass aufgrund dieser Tatsache die Operationen auf Float und Double nicht genau sind. </p><br><p>  Wenn wir √ºber Erlang sprechen, implementiert es wie viele andere Sprachen den IEEE754-Standard f√ºr float, w√§hrend der Standard-Integer-Typ in Erlang mit Arithmetik mit beliebiger Genauigkeit implementiert wird.  Ich m√∂chte jedoch nicht nur Bigint haben, sondern auch die F√§higkeit, mit rationalen, komplexen und Gleitkommazahlen mit der erforderlichen Genauigkeit zu arbeiten. </p><br><p> Der Artikel bietet einen minimalen √úberblick √ºber die Theorie der Codierung von Gleitkommazahlen und die auff√§lligsten Beispiele f√ºr neu auftretende Effekte.  Die L√∂sung, die durch den √úbergang zu einer Festkommadarstellung die erforderliche Genauigkeit der Operationen bietet, ist als EAPA-Bibliothek (Erlang Arbitrary Precision Arithmetic) konzipiert, die den Anforderungen von auf Erlang / Elixir entwickelten Finanzanwendungen gerecht wird. </p><a name="habracut"></a><br><hr><br><h2 id="standarty-standarty-standarty">  Standards, Standards, Standards ... </h2><br><p>  Heute ist der IEEE754 der Hauptstandard f√ºr die bin√§re Gleitkomma-Arithmetik, der in der Technik und Programmierung weit verbreitet ist.  Es definiert vier Pr√§sentationsformate: </p><br><ul><li>  32 Bit mit einfacher Genauigkeit </li><li>  64 Bit mit doppelter Genauigkeit </li><li>  einfach erweiterte Genauigkeit&gt; = 43 Bit (selten verwendet) </li><li>  doppelte erweiterte Genauigkeit&gt; = 79 Bit (normalerweise werden 80 Bit verwendet) <br>  und vier Rundungsmodi: </li><li>  Abrunden, auf das n√§chste Ganze achten. </li><li>  Rundung gegen Null. </li><li>  Rundung mit Tendenz zu + ‚àû </li><li>  Rundung in Richtung -‚àû </li></ul><br><p>  Die meisten modernen Mikroprozessoren werden mit Hardware-Implementierung der Darstellung realer Variablen im IEEE754-Format hergestellt.  Pr√§sentationsformate begrenzen die Gr√∂√üenbeschr√§nkung einer Zahl, und Rundungsmodi wirken sich auf die Genauigkeit aus.  Programmierer k√∂nnen das Verhalten von Hardware h√§ufig nicht √§ndern und Programmiersprachen implementieren.  Beispielsweise speichert die offizielle Erlang-Implementierung einen Float in 3 W√∂rtern auf einem 64-Bit-Computer und in 4 W√∂rtern auf einem 32-Bit-Computer. </p><br><p>  Wie oben erw√§hnt, sind Zahlen im IEEE754-Format eine endliche Menge, auf die eine unendliche Menge von reellen Zahlen abgebildet wird, so dass die urspr√ºngliche Zahl im IEEE754-Format mit einem Fehler dargestellt werden kann. </p><br><p>  Der Gro√üteil der Zahlen, wenn sie auf einer endlichen Menge angezeigt werden, weist einen stabilen und kleinen relativen Fehler auf.  F√ºr Float sind es also 11,920928955078125e-6% und f√ºr Double 2,2204460492503130808472633361816e-14%.  Im Leben von Programmierern erlauben uns die meisten allt√§glichen Aufgaben, die gel√∂st werden k√∂nnen, diesen Fehler zu vernachl√§ssigen, obwohl zu beachten ist, dass Sie selbst bei einfachen Aufgaben auf den Rechen treten k√∂nnen, da die Gr√∂√üe des absoluten Fehlers 10 <sup>31</sup> und 10 <sup>292</sup> f√ºr float bzw. double erreichen kann, was zu Berechnungsschwierigkeiten f√ºhrt. </p><br><h2 id="illyustraciya-effektov">  Effektillustration </h2><br><p>  Von allgemeinen Informationen bis zum Gesch√§ft.  Versuchen wir, die aufkommenden Effekte in Erlang zu reproduzieren. </p><br><p>  Alle folgenden Beispiele sind als CT-Tests konzipiert. </p><br><h3 id="okruglenie-i-poterya-tochnosti">  Rundung und Genauigkeitsverlust </h3><br><p>  Beginnen wir mit den Klassikern - der Addition von zwei Zahlen: 0.1 + 0.2 =?: </p><br><pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t30000000000000004</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> [<span class="hljs-string"><span class="hljs-string">"0.30000000000000004"</span></span>] = io_lib:format(<span class="hljs-string"><span class="hljs-string">"~w"</span></span>, [<span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">0.2</span></span>]).</code> </pre> <br><p>  Das Ergebnis der Zugabe unterscheidet sich geringf√ºgig von dem intuitiv erwarteten, und der Test besteht erfolgreich.  Versuchen wir, das richtige Ergebnis zu erzielen.  Schreiben Sie den Test mit EAPA neu: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t30000000000000004_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">%% prec = 1 symbols after coma X = eapa_int:with_val(1, &lt;&lt;"0.1"&gt;&gt;), Y = eapa_int:with_val(1, &lt;&lt;"0.2"&gt;&gt;), &lt;&lt;"0.3"&gt;&gt; = eapa_int:to_float(1, eapa_int:add(X, Y)).</span></span></code> </pre> <br><p>  Dieser Test ist ebenfalls erfolgreich und zeigt, dass das Problem behoben wurde. <br>  Lassen Sie uns die Experimente fortsetzen und einen sehr kleinen Wert zu 1.0 hinzuf√ºgen: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, Y = <span class="hljs-number"><span class="hljs-number">0.0000000000000000000000001</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> = X + Y.</code> </pre> <br><p>  Wie Sie sehen, blieb unser Anstieg unbemerkt.  Wir versuchen, das Problem zu beheben und gleichzeitig eine der Funktionen der Bibliothek zu veranschaulichen - die automatische Skalierung: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tiny_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X1 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt;), X2 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">25</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"0.0000000000000000000000001"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0000000000000000000000001"</span></span>&gt;&gt; = eapa_int:to_float(eapa_int:add(X1, X2)).</code> </pre> <br><h3 id="perepolnenie-razryadnoy-setki">  Bitgitter√ºberlauf </h3><br><p>  Zus√§tzlich zu den Problemen, die mit kleinen Zahlen verbunden sind, ist ein √úberlauf ein offensichtliches und bedeutendes Problem. </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float_overflow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740991.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740990.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740992.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740991.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740993.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740992.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740994.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740993.0</span></span>.</code> </pre> <br><p>  Wie Sie dem Test entnehmen k√∂nnen, ist der Unterschied irgendwann nicht mehr gleich 1,0, was offensichtlich ein Problem ist.  EAPA l√∂st auch dieses Problem: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float_overflow_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X11 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740992.0"</span></span>&gt;&gt;), X21 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740991.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X11, X21)), X12 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740993.0"</span></span>&gt;&gt;), X22 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740992.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X12, X22)), X13 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740994.0"</span></span>&gt;&gt;), X23 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740993.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X13, X23)).</code> </pre> <br><h3 id="opasnaya-redukciya">  Gef√§hrliche Reduzierung </h3><br><p>  Der folgende Test zeigt das Auftreten einer gef√§hrlichen Reduktion.  Dieser Prozess geht mit einer katastrophalen Abnahme der Genauigkeit von Berechnungen in Operationen einher, bei denen der resultierende Wert viel geringer als die Eingabe ist.  In unserem Fall das Ergebnis der Subtraktion 1. </p><br><p>  Wir zeigen, dass in Erlang dieses Problem vorliegt: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = float(<span class="hljs-number"><span class="hljs-number">87654321098765432</span></span>), Y = float(<span class="hljs-number"><span class="hljs-number">87654321098765431</span></span>), <span class="hljs-number"><span class="hljs-number">16.0</span></span> = XY. <span class="hljs-comment"><span class="hljs-comment">%% has to be 1.0</span></span></code> </pre> <br><p>  Es stellte sich heraus, 16.0 anstelle der erwarteten 1.0.  Versuchen wir, diese Situation zu beheben: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduction_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"87654321098765432"</span></span>&gt;&gt;), Y = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"87654321098765431"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(eapa_int:sub(X, Y)).</code> </pre> <br><h3 id="drugie-osobennosti-arifmetiki-s-plavayuschey-tochkoy-v-erlang">  Weitere Merkmale der Gleitkomma-Arithmetik in Erlang </h3><br><p>  Beginnen wir damit, die negative Null zu ignorieren. </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> = list_to_float(<span class="hljs-string"><span class="hljs-string">"0.0"</span></span>) =:= list_to_float(<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>).</code> </pre> <br><p>  Ich m√∂chte nur sagen, dass EAPA dieses Verhalten beibeh√§lt: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"0.0"</span></span>&gt;&gt;), Y = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>&gt;&gt;), <span class="hljs-literal"><span class="hljs-literal">true</span></span> = eapa_int:eq(X, Y).</code> </pre> <br><p>  da es g√ºltig ist.  Erlang hat keine klare Syntax und Verarbeitung von NaN und Unendlichkeiten, was zu einer Reihe von Merkmalen f√ºhrt, zum Beispiel: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">1&gt; </span></span>math:sqrt(list_to_float(<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>)). <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  Der n√§chste Punkt ist das Merkmal der Verarbeitung gro√üer und kleiner Zahlen.  Versuchen wir, f√ºr die Kleinen zu reproduzieren: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">2&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">322</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"1"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e-323</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">323</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"1"</span></span>). <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  und f√ºr gro√üe Zahlen: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">4&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"1"</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">308</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">".0"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e308</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"1"</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">309</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">".0"</span></span>). ** exception error: bad argument</code> </pre> <br><p>  Hier noch ein paar Beispiele f√ºr kleine Zahlen: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">6&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">322</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"123456789"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e-323</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">300</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"123456789"</span></span>). <span class="hljs-number"><span class="hljs-number">1.23456789e-301</span></span></code> </pre> <br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">8&gt; </span></span><span class="hljs-number"><span class="hljs-number">0.123456789e-100</span></span> * <span class="hljs-number"><span class="hljs-number">0.123456789e-100</span></span>. <span class="hljs-number"><span class="hljs-number">1.524157875019052e-202</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0.123456789e-200</span></span> * <span class="hljs-number"><span class="hljs-number">0.123456789e-200</span></span>. <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  Die obigen Beispiele best√§tigen die Wahrheit f√ºr Erlang-Projekte: Geld kann in IEEE754 nicht gez√§hlt werden. </p><br><h2 id="eapa-erlang-arbitrary-precision-arithmetic">  EAPA (Erlang Arbitrary-Precision Arithmetic) </h2><br><p>  EAPA ist eine in Rust geschriebene NIF-Erweiterung.  Derzeit bietet das EAPA-Repository die einfachste und bequemste eapa_int-Schnittstelle f√ºr die Arbeit mit Festkommazahlen.  Die Funktionen von eapa_int umfassen Folgendes: </p><br><ol><li>  Fehlende Auswirkungen der IEEE754-Codierung </li><li>  Unterst√ºtzung f√ºr gro√üe Zahlen </li><li>  Konfigurierbare Genauigkeit bis zu 126 Dezimalstellen.  (in der aktuellen Implementierung) </li><li>  Autoskalierung </li><li>  Unterst√ºtzung f√ºr alle grundlegenden Operationen an Zahlen </li><li>  Mehr oder weniger vollst√§ndige Tests, einschlie√ülich eigenschaftsbasierter Tests. </li></ol><br><p>  <code>eapa_int</code> Schnittstelle: </p><br><ul><li>  <code>with_val/2</code> - √úbersetzung einer Gleitkommazahl in eine feste Darstellung, die auch sicher in json, xml verwendet werden kann. </li><li>  <code>to_float/2</code> - √úbersetzung einer Festkommazahl in eine Gleitkommazahl mit einer bestimmten Genauigkeit. </li><li>  <code>to_float/1</code> - √ºbersetzt eine Festkommazahl in eine Gleitkommazahl. </li><li>  <code>add/2</code> - die Summe zweier Zahlen </li><li>  <code>sub/2</code> - Unterschied </li><li>  <code>mul/2</code> - Multiplikation </li><li>  <code>divp/2</code> - Division </li><li>  <code>min/2</code> - das Minimum an Zahlen </li><li>  <code>max/2</code> - das Maximum der Zahlen </li><li>  <code>eq/2</code> - Gleichheit der Zahlen pr√ºfen </li><li>  <code>lt/2</code> - √úberpr√ºfen Sie, ob die Anzahl geringer ist </li><li>  <code>lte/2</code> - √úberpr√ºfung weniger als gleich </li><li>  <code>gt/2</code> - √úberpr√ºfen Sie, ob die Anzahl gr√∂√üer ist </li><li>  <code>gte/2</code> - √úberpr√ºfung ist mehr als gleich </li></ul><br><p>  EAPA-Code finden Sie im Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/Vonmo/eapa</a> </p><br><p>  Wann sollten Sie eapa_int verwenden?  Wenn Ihre Anwendung beispielsweise mit Geld arbeitet oder Sie Berechnungsvorg√§nge f√ºr Zahlen wie 92233720368547758079223372036854775807.92233720368547758079223372036854775807 bequem und genau ausf√ºhren m√ºssen, k√∂nnen Sie EAPA sicher verwenden. </p><br><p>  Wie jede L√∂sung ist EAPA ein Kompromiss.  Wir erhalten die erforderliche Genauigkeit, indem wir auf Speicher und Rechengeschwindigkeit verzichten. Leistungstests und Statistiken, die auf realen Systemen gesammelt wurden, zeigen, dass die meisten Operationen im Bereich von 3 bis 30 Œºs ausgef√ºhrt werden.  Dieser Punkt muss auch bei der Auswahl einer EAPA-Festkomma-Schnittstelle ber√ºcksichtigt werden. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Nat√ºrlich ist es bei weitem nicht immer notwendig, solche Probleme mit Erlang oder Elixir zu l√∂sen, aber wenn ein Problem auftritt und kein geeignetes Werkzeug gefunden wird, m√ºssen Sie eine L√∂sung erfinden. <br>  Dieser Artikel ist ein Versuch, das Tool und die Erfahrung mit der Community zu teilen, in der Hoffnung, dass diese Bibliothek f√ºr einige Benutzer n√ºtzlich ist und Zeit spart. <br>  Was denkst du √ºber Geld in Erlang? </p><br><p>  PS Die Arbeit mit rationalen und komplexen Zahlen sowie der native Zugriff auf Integer-, Float-, Complex- und Rational-Typen mit beliebiger Genauigkeit werden in den folgenden Ver√∂ffentlichungen behandelt.  Nicht wechseln! </p><br><hr><br><p>  Verwandte Materialien: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was jeder Informatiker √ºber Gleitkomma-Arithmetik wissen sollte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was Sie √ºber Gleitkomma-Arithmetik wissen m√ºssen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gleitkommazahlen nach IEEE-Standard 754</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IEEE 754 - bin√§rer arithmetischer Standard</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gleitkomma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">0,30000000000000004</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428111/">https://habr.com/ru/post/de428111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428101/index.html">Automatisieren mit Jenkins das Erstellen und Rollen von Artefakten von Metadatenmodellartefakten f√ºr Tabellen im Repository</a></li>
<li><a href="../de428103/index.html">Mitap in St. Petersburg: Data Engineering und mehr</a></li>
<li><a href="../de428105/index.html">Blogger empfiehlt: Einfluss auf das Marketing</a></li>
<li><a href="../de428107/index.html">Containerisierung von Angular 6 SPA-Vorlagen ASP .NET Core 2.1-Anwendungen</a></li>
<li><a href="../de428109/index.html">Unternehmenswand</a></li>
<li><a href="../de428113/index.html">Auf die Frage nach Bezier-Kurven, Arduino-Geschwindigkeit und einem interessanten Ort oder wie ich das Wochenende verbracht habe</a></li>
<li><a href="../de428115/index.html">Webentwicklung f√ºr E-Commerce: 5 Technologietrends f√ºr 2019</a></li>
<li><a href="../de428117/index.html">Kostenlose Tensorprozessoren von Google in der Colaboratory Cloud</a></li>
<li><a href="../de428119/index.html">"Klassenfeld-Vorschlag" oder "Was ist beim tc39-Commit schief gelaufen"</a></li>
<li><a href="../de428121/index.html">Stan Drapkin. Hochrangige Kryptografiefallen in .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>