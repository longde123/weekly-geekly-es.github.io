<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏽 🍳 🖲️ Arithmetik beliebiger Genauigkeit in Erlang 🚮 🚒 👰🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="@rawpixel 


 Sogar Schulkinder sind sich der Existenz verschiedener Zahlensysteme und der Tatsache bewusst, dass nicht jeder endliche Dezimalbruch ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arithmetik beliebiger Genauigkeit in Erlang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428111/"><p><img src="https://habrastorage.org/webt/h6/vn/cg/h6vncgl-xdc_8d5peworwhnrg4a.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@rawpixel</a> </p><br><p>  Sogar Schulkinder sind sich der Existenz verschiedener Zahlensysteme und der Tatsache bewusst, dass nicht jeder endliche Dezimalbruch ein endlicher Bruch in einem binären Zahlensystem ist.  Nur wenige Leute denken, dass aufgrund dieser Tatsache die Operationen auf Float und Double nicht genau sind. </p><br><p>  Wenn wir über Erlang sprechen, implementiert es wie viele andere Sprachen den IEEE754-Standard für float, während der Standard-Integer-Typ in Erlang mit Arithmetik mit beliebiger Genauigkeit implementiert wird.  Ich möchte jedoch nicht nur Bigint haben, sondern auch die Fähigkeit, mit rationalen, komplexen und Gleitkommazahlen mit der erforderlichen Genauigkeit zu arbeiten. </p><br><p> Der Artikel bietet einen minimalen Überblick über die Theorie der Codierung von Gleitkommazahlen und die auffälligsten Beispiele für neu auftretende Effekte.  Die Lösung, die durch den Übergang zu einer Festkommadarstellung die erforderliche Genauigkeit der Operationen bietet, ist als EAPA-Bibliothek (Erlang Arbitrary Precision Arithmetic) konzipiert, die den Anforderungen von auf Erlang / Elixir entwickelten Finanzanwendungen gerecht wird. </p><a name="habracut"></a><br><hr><br><h2 id="standarty-standarty-standarty">  Standards, Standards, Standards ... </h2><br><p>  Heute ist der IEEE754 der Hauptstandard für die binäre Gleitkomma-Arithmetik, der in der Technik und Programmierung weit verbreitet ist.  Es definiert vier Präsentationsformate: </p><br><ul><li>  32 Bit mit einfacher Genauigkeit </li><li>  64 Bit mit doppelter Genauigkeit </li><li>  einfach erweiterte Genauigkeit&gt; = 43 Bit (selten verwendet) </li><li>  doppelte erweiterte Genauigkeit&gt; = 79 Bit (normalerweise werden 80 Bit verwendet) <br>  und vier Rundungsmodi: </li><li>  Abrunden, auf das nächste Ganze achten. </li><li>  Rundung gegen Null. </li><li>  Rundung mit Tendenz zu + ∞ </li><li>  Rundung in Richtung -∞ </li></ul><br><p>  Die meisten modernen Mikroprozessoren werden mit Hardware-Implementierung der Darstellung realer Variablen im IEEE754-Format hergestellt.  Präsentationsformate begrenzen die Größenbeschränkung einer Zahl, und Rundungsmodi wirken sich auf die Genauigkeit aus.  Programmierer können das Verhalten von Hardware häufig nicht ändern und Programmiersprachen implementieren.  Beispielsweise speichert die offizielle Erlang-Implementierung einen Float in 3 Wörtern auf einem 64-Bit-Computer und in 4 Wörtern auf einem 32-Bit-Computer. </p><br><p>  Wie oben erwähnt, sind Zahlen im IEEE754-Format eine endliche Menge, auf die eine unendliche Menge von reellen Zahlen abgebildet wird, so dass die ursprüngliche Zahl im IEEE754-Format mit einem Fehler dargestellt werden kann. </p><br><p>  Der Großteil der Zahlen, wenn sie auf einer endlichen Menge angezeigt werden, weist einen stabilen und kleinen relativen Fehler auf.  Für Float sind es also 11,920928955078125e-6% und für Double 2,2204460492503130808472633361816e-14%.  Im Leben von Programmierern erlauben uns die meisten alltäglichen Aufgaben, die gelöst werden können, diesen Fehler zu vernachlässigen, obwohl zu beachten ist, dass Sie selbst bei einfachen Aufgaben auf den Rechen treten können, da die Größe des absoluten Fehlers 10 <sup>31</sup> und 10 <sup>292</sup> für float bzw. double erreichen kann, was zu Berechnungsschwierigkeiten führt. </p><br><h2 id="illyustraciya-effektov">  Effektillustration </h2><br><p>  Von allgemeinen Informationen bis zum Geschäft.  Versuchen wir, die aufkommenden Effekte in Erlang zu reproduzieren. </p><br><p>  Alle folgenden Beispiele sind als CT-Tests konzipiert. </p><br><h3 id="okruglenie-i-poterya-tochnosti">  Rundung und Genauigkeitsverlust </h3><br><p>  Beginnen wir mit den Klassikern - der Addition von zwei Zahlen: 0.1 + 0.2 =?: </p><br><pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t30000000000000004</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> [<span class="hljs-string"><span class="hljs-string">"0.30000000000000004"</span></span>] = io_lib:format(<span class="hljs-string"><span class="hljs-string">"~w"</span></span>, [<span class="hljs-number"><span class="hljs-number">0.1</span></span> + <span class="hljs-number"><span class="hljs-number">0.2</span></span>]).</code> </pre> <br><p>  Das Ergebnis der Zugabe unterscheidet sich geringfügig von dem intuitiv erwarteten, und der Test besteht erfolgreich.  Versuchen wir, das richtige Ergebnis zu erzielen.  Schreiben Sie den Test mit EAPA neu: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t30000000000000004_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">%% prec = 1 symbols after coma X = eapa_int:with_val(1, &lt;&lt;"0.1"&gt;&gt;), Y = eapa_int:with_val(1, &lt;&lt;"0.2"&gt;&gt;), &lt;&lt;"0.3"&gt;&gt; = eapa_int:to_float(1, eapa_int:add(X, Y)).</span></span></code> </pre> <br><p>  Dieser Test ist ebenfalls erfolgreich und zeigt, dass das Problem behoben wurde. <br>  Lassen Sie uns die Experimente fortsetzen und einen sehr kleinen Wert zu 1.0 hinzufügen: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tiny</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = <span class="hljs-number"><span class="hljs-number">1.0</span></span>, Y = <span class="hljs-number"><span class="hljs-number">0.0000000000000000000000001</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> = X + Y.</code> </pre> <br><p>  Wie Sie sehen, blieb unser Anstieg unbemerkt.  Wir versuchen, das Problem zu beheben und gleichzeitig eine der Funktionen der Bibliothek zu veranschaulichen - die automatische Skalierung: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tiny_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X1 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt;), X2 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">25</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"0.0000000000000000000000001"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0000000000000000000000001"</span></span>&gt;&gt; = eapa_int:to_float(eapa_int:add(X1, X2)).</code> </pre> <br><h3 id="perepolnenie-razryadnoy-setki">  Bitgitterüberlauf </h3><br><p>  Zusätzlich zu den Problemen, die mit kleinen Zahlen verbunden sind, ist ein Überlauf ein offensichtliches und bedeutendes Problem. </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float_overflow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740991.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740990.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740992.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740991.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740993.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740992.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> = <span class="hljs-number"><span class="hljs-number">9007199254740994.0</span></span> - <span class="hljs-number"><span class="hljs-number">9007199254740993.0</span></span>.</code> </pre> <br><p>  Wie Sie dem Test entnehmen können, ist der Unterschied irgendwann nicht mehr gleich 1,0, was offensichtlich ein Problem ist.  EAPA löst auch dieses Problem: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float_overflow_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X11 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740992.0"</span></span>&gt;&gt;), X21 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740991.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X11, X21)), X12 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740993.0"</span></span>&gt;&gt;), X22 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740992.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X12, X22)), X13 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740994.0"</span></span>&gt;&gt;), X23 = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"9007199254740993.0"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(<span class="hljs-number"><span class="hljs-number">1</span></span>, eapa_int:sub(X13, X23)).</code> </pre> <br><h3 id="opasnaya-redukciya">  Gefährliche Reduzierung </h3><br><p>  Der folgende Test zeigt das Auftreten einer gefährlichen Reduktion.  Dieser Prozess geht mit einer katastrophalen Abnahme der Genauigkeit von Berechnungen in Operationen einher, bei denen der resultierende Wert viel geringer als die Eingabe ist.  In unserem Fall das Ergebnis der Subtraktion 1. </p><br><p>  Wir zeigen, dass in Erlang dieses Problem vorliegt: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = float(<span class="hljs-number"><span class="hljs-number">87654321098765432</span></span>), Y = float(<span class="hljs-number"><span class="hljs-number">87654321098765431</span></span>), <span class="hljs-number"><span class="hljs-number">16.0</span></span> = XY. <span class="hljs-comment"><span class="hljs-comment">%% has to be 1.0</span></span></code> </pre> <br><p>  Es stellte sich heraus, 16.0 anstelle der erwarteten 1.0.  Versuchen wir, diese Situation zu beheben: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduction_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"87654321098765432"</span></span>&gt;&gt;), Y = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"87654321098765431"</span></span>&gt;&gt;), &lt;&lt;<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>&gt;&gt; = eapa_int:to_float(eapa_int:sub(X, Y)).</code> </pre> <br><h3 id="drugie-osobennosti-arifmetiki-s-plavayuschey-tochkoy-v-erlang">  Weitere Merkmale der Gleitkomma-Arithmetik in Erlang </h3><br><p>  Beginnen wir damit, die negative Null zu ignorieren. </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> = list_to_float(<span class="hljs-string"><span class="hljs-string">"0.0"</span></span>) =:= list_to_float(<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>).</code> </pre> <br><p>  Ich möchte nur sagen, dass EAPA dieses Verhalten beibehält: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_eapa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span><span class="hljs-function">-&gt;</span></span> X = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"0.0"</span></span>&gt;&gt;), Y = eapa_int:with_val(<span class="hljs-number"><span class="hljs-number">1</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>&gt;&gt;), <span class="hljs-literal"><span class="hljs-literal">true</span></span> = eapa_int:eq(X, Y).</code> </pre> <br><p>  da es gültig ist.  Erlang hat keine klare Syntax und Verarbeitung von NaN und Unendlichkeiten, was zu einer Reihe von Merkmalen führt, zum Beispiel: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">1&gt; </span></span>math:sqrt(list_to_float(<span class="hljs-string"><span class="hljs-string">"-0.0"</span></span>)). <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  Der nächste Punkt ist das Merkmal der Verarbeitung großer und kleiner Zahlen.  Versuchen wir, für die Kleinen zu reproduzieren: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">2&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">322</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"1"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e-323</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">323</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"1"</span></span>). <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  und für große Zahlen: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">4&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"1"</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">308</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">".0"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e308</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"1"</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">309</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">".0"</span></span>). ** exception error: bad argument</code> </pre> <br><p>  Hier noch ein paar Beispiele für kleine Zahlen: </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">6&gt; </span></span>list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">322</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"123456789"</span></span>). <span class="hljs-number"><span class="hljs-number">1.0e-323</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>&gt; list_to_float(<span class="hljs-string"><span class="hljs-string">"0."</span></span>++lists:duplicate(<span class="hljs-number"><span class="hljs-number">300</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span>)++<span class="hljs-string"><span class="hljs-string">"123456789"</span></span>). <span class="hljs-number"><span class="hljs-number">1.23456789e-301</span></span></code> </pre> <br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">8&gt; </span></span><span class="hljs-number"><span class="hljs-number">0.123456789e-100</span></span> * <span class="hljs-number"><span class="hljs-number">0.123456789e-100</span></span>. <span class="hljs-number"><span class="hljs-number">1.524157875019052e-202</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0.123456789e-200</span></span> * <span class="hljs-number"><span class="hljs-number">0.123456789e-200</span></span>. <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p>  Die obigen Beispiele bestätigen die Wahrheit für Erlang-Projekte: Geld kann in IEEE754 nicht gezählt werden. </p><br><h2 id="eapa-erlang-arbitrary-precision-arithmetic">  EAPA (Erlang Arbitrary-Precision Arithmetic) </h2><br><p>  EAPA ist eine in Rust geschriebene NIF-Erweiterung.  Derzeit bietet das EAPA-Repository die einfachste und bequemste eapa_int-Schnittstelle für die Arbeit mit Festkommazahlen.  Die Funktionen von eapa_int umfassen Folgendes: </p><br><ol><li>  Fehlende Auswirkungen der IEEE754-Codierung </li><li>  Unterstützung für große Zahlen </li><li>  Konfigurierbare Genauigkeit bis zu 126 Dezimalstellen.  (in der aktuellen Implementierung) </li><li>  Autoskalierung </li><li>  Unterstützung für alle grundlegenden Operationen an Zahlen </li><li>  Mehr oder weniger vollständige Tests, einschließlich eigenschaftsbasierter Tests. </li></ol><br><p>  <code>eapa_int</code> Schnittstelle: </p><br><ul><li>  <code>with_val/2</code> - Übersetzung einer Gleitkommazahl in eine feste Darstellung, die auch sicher in json, xml verwendet werden kann. </li><li>  <code>to_float/2</code> - Übersetzung einer Festkommazahl in eine Gleitkommazahl mit einer bestimmten Genauigkeit. </li><li>  <code>to_float/1</code> - übersetzt eine Festkommazahl in eine Gleitkommazahl. </li><li>  <code>add/2</code> - die Summe zweier Zahlen </li><li>  <code>sub/2</code> - Unterschied </li><li>  <code>mul/2</code> - Multiplikation </li><li>  <code>divp/2</code> - Division </li><li>  <code>min/2</code> - das Minimum an Zahlen </li><li>  <code>max/2</code> - das Maximum der Zahlen </li><li>  <code>eq/2</code> - Gleichheit der Zahlen prüfen </li><li>  <code>lt/2</code> - Überprüfen Sie, ob die Anzahl geringer ist </li><li>  <code>lte/2</code> - Überprüfung weniger als gleich </li><li>  <code>gt/2</code> - Überprüfen Sie, ob die Anzahl größer ist </li><li>  <code>gte/2</code> - Überprüfung ist mehr als gleich </li></ul><br><p>  EAPA-Code finden Sie im Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/Vonmo/eapa</a> </p><br><p>  Wann sollten Sie eapa_int verwenden?  Wenn Ihre Anwendung beispielsweise mit Geld arbeitet oder Sie Berechnungsvorgänge für Zahlen wie 92233720368547758079223372036854775807.92233720368547758079223372036854775807 bequem und genau ausführen müssen, können Sie EAPA sicher verwenden. </p><br><p>  Wie jede Lösung ist EAPA ein Kompromiss.  Wir erhalten die erforderliche Genauigkeit, indem wir auf Speicher und Rechengeschwindigkeit verzichten. Leistungstests und Statistiken, die auf realen Systemen gesammelt wurden, zeigen, dass die meisten Operationen im Bereich von 3 bis 30 μs ausgeführt werden.  Dieser Punkt muss auch bei der Auswahl einer EAPA-Festkomma-Schnittstelle berücksichtigt werden. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Natürlich ist es bei weitem nicht immer notwendig, solche Probleme mit Erlang oder Elixir zu lösen, aber wenn ein Problem auftritt und kein geeignetes Werkzeug gefunden wird, müssen Sie eine Lösung erfinden. <br>  Dieser Artikel ist ein Versuch, das Tool und die Erfahrung mit der Community zu teilen, in der Hoffnung, dass diese Bibliothek für einige Benutzer nützlich ist und Zeit spart. <br>  Was denkst du über Geld in Erlang? </p><br><p>  PS Die Arbeit mit rationalen und komplexen Zahlen sowie der native Zugriff auf Integer-, Float-, Complex- und Rational-Typen mit beliebiger Genauigkeit werden in den folgenden Veröffentlichungen behandelt.  Nicht wechseln! </p><br><hr><br><p>  Verwandte Materialien: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was jeder Informatiker über Gleitkomma-Arithmetik wissen sollte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was Sie über Gleitkomma-Arithmetik wissen müssen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gleitkommazahlen nach IEEE-Standard 754</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IEEE 754 - binärer arithmetischer Standard</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gleitkomma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">0,30000000000000004</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428111/">https://habr.com/ru/post/de428111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428101/index.html">Automatisieren mit Jenkins das Erstellen und Rollen von Artefakten von Metadatenmodellartefakten für Tabellen im Repository</a></li>
<li><a href="../de428103/index.html">Mitap in St. Petersburg: Data Engineering und mehr</a></li>
<li><a href="../de428105/index.html">Blogger empfiehlt: Einfluss auf das Marketing</a></li>
<li><a href="../de428107/index.html">Containerisierung von Angular 6 SPA-Vorlagen ASP .NET Core 2.1-Anwendungen</a></li>
<li><a href="../de428109/index.html">Unternehmenswand</a></li>
<li><a href="../de428113/index.html">Auf die Frage nach Bezier-Kurven, Arduino-Geschwindigkeit und einem interessanten Ort oder wie ich das Wochenende verbracht habe</a></li>
<li><a href="../de428115/index.html">Webentwicklung für E-Commerce: 5 Technologietrends für 2019</a></li>
<li><a href="../de428117/index.html">Kostenlose Tensorprozessoren von Google in der Colaboratory Cloud</a></li>
<li><a href="../de428119/index.html">"Klassenfeld-Vorschlag" oder "Was ist beim tc39-Commit schief gelaufen"</a></li>
<li><a href="../de428121/index.html">Stan Drapkin. Hochrangige Kryptografiefallen in .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>