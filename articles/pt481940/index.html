<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üâë üë®‚Äçüëß ü§¶üèΩ Trabalho r√°pido e eficaz na linha de comando üòô üì∞ üë©üèΩ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem muitas dicas e truques de linha de comando na internet. A maioria deles descreve os triviais como "aprenda as teclas de atalho" ou " sudo !! e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabalho r√°pido e eficaz na linha de comando</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481940/"><p> Existem muitas dicas e truques de linha de comando na internet.  A maioria deles descreve os triviais como "aprenda as teclas de atalho" ou " <code>sudo !!</code> executar√° o comando anterior com o sudo".  Em vez disso, vou lhe dizer o que fazer quando voc√™ j√° aprendeu as teclas de atalho e conhece o <code>sudo !!</code>  . </p><a name="habracut"></a><br><h3 id="the-terminal-should-start-instantly">  O terminal deve iniciar instantaneamente </h3><br><p>  Quanto tempo voc√™ gasta para lan√ßar um terminal?  E outro?  Por um longo tempo, usei o atalho Ctrl + Alt + T para iniciar um terminal e achei r√°pido.  Quando migrei do Openbox para o i3, comecei a lan√ßar um terminal via Win + Enter, que funcionava de forma imediata.  Voc√™ sabe o que?  Agora n√£o acho que Ctrl + Alt + T seja r√°pido o suficiente. </p><br><p>  Obviamente, a coisa n√£o √© uma acelera√ß√£o de milissegundos, mas voc√™ abre um terminal no n√≠vel dos reflexos, completamente alheio a isso. </p><br><p>  Portanto, se voc√™ costuma usar um terminal, mas pega um mouse para inici√°-lo, tente configurar uma tecla de atalho √∫til.  Tenho certeza que voc√™ vai gostar. </p><br><h3 id="zsh-instead-of-bash">  Zsh em vez de bash </h3><br><p>  Este √© um t√≥pico da guerra santa, eu sei.  Voc√™ deve instalar o Zsh para pelo menos tr√™s recursos: preenchimento autom√°tico avan√ßado, corre√ß√£o de erros de digita√ß√£o e conclus√£o de v√°rios nomes de caminhos: quando uma √∫nica guia converte <code>/u/s/d</code> em <code>/usr/share/doc</code> .  O Arch Linux j√° migrou para o Zsh em seu CD de instala√ß√£o.  Espero que o Zsh se torne um shell padr√£o no Ubuntu.  Esse ser√° um momento hist√≥rico. </p><br><p>  Come√ßar a usar o Zsh n√£o √© nada dif√≠cil.  Basta instal√°-lo via gerenciador de pacotes e encontrar uma configura√ß√£o bonita.  Eu recomendo levar a configura√ß√£o usada no Arch Linux: </p><br><pre> <code class="plaintext hljs">$ wget -O ~/.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc</code> </pre> <br><p>  A √∫nica coisa que resta √© mudar o seu shell padr√£o e entrar novamente. </p><br><pre> <code class="plaintext hljs">$ chsh -s $(which zsh)</code> </pre> <br><p>  √â tudo, continue trabalhando como se nada tivesse acontecido. </p><br><h3 id="how-the-shell-prompt-should-look-like">  Como o prompt do shell deve se parecer </h3><br><p>  O prompt do shell √© um pequeno peda√ßo de texto mostrado no terminal no in√≠cio da sua linha de comando.  Deve ser configurado para o seu tipo de trabalho.  Voc√™ pode perceb√™-lo como o painel de instrumentos de um ve√≠culo.  Por favor, coloque algumas informa√ß√µes √∫teis, deixe-o ajud√°-lo a navegar!  Torne-o √∫til, especialmente se voc√™ o v√™ todos os dias! </p><br><p>  O prompt do shell deve ser colorido.  N√£o concorda?  Tente contar quantos comandos foram executados neste terminal: </p><br><p><img src="https://habrastorage.org/webt/yh/mu/s7/yhmus7x5-abqnlrho5u5djwau8o.png"></p><br><p>  E agora com cores: </p><br><p><img src="https://habrastorage.org/webt/re/1b/ln/re1blnqfemmydwf99758sbirqai.png"></p><br><p>  O prompt do shell deve exibir um diret√≥rio de trabalho atual de um shell.  Se o diret√≥rio de trabalho atual n√£o for exibido, mantenha-o em mente e verifique-o periodicamente com o comando <code>pwd</code> .  Por favor, n√£o fa√ßa isso.  Lembre-se de algumas coisas realmente importantes e n√£o perca tempo com o comando <code>pwd</code> . </p><br><p>  Se voc√™ mudar para a conta raiz, precisar√° de uma indica√ß√£o de "usu√°rio atual".  O nome de usu√°rio espec√≠fico geralmente n√£o √© importante, mas seu status (regular ou raiz) √©.  A solu√ß√£o √© usar o prompt de shell color: red para raiz e verde para usu√°rio comum.  E voc√™ nunca assumir√° o shell raiz como regular. </p><br><p>  Se voc√™ se conectar a servidores usando ssh, precisar√° distinguir seus shells locais e remotos.  Para esse prop√≥sito, o prompt do shell deve conter um nome de host ou, melhor ainda, indicar uma conex√£o ssh. </p><br><p>  O prompt do shell pode mostrar o c√≥digo de sa√≠da do √∫ltimo comando.  Lembre-se de que o c√≥digo de sa√≠da zero significa que um comando foi encerrado com sucesso, diferente de zero - o comando foi encerrado sem √™xito.  Voc√™ pode obter o c√≥digo de sa√≠da do √∫ltimo comando via <code>echo $?</code>  , mas digitar tudo isso √© uma coisa muito longa.  Deixe o shell mostrar uma sa√≠da sem √™xito. </p><br><p>  Se voc√™ trabalha com reposit√≥rios Git, ser√° √∫til ver o status do reposit√≥rio no prompt do shell: branch atual e o estado do diret√≥rio de trabalho.  Voc√™ economizar√° algum tempo com os comandos <code>git status</code> e <code>git branch</code> e n√£o se comprometer√° com uma ramifica√ß√£o errada.  Sim, o c√°lculo do status pode levar um tempo significativo nos reposit√≥rios de gordura, mas para mim os profissionais superam os contras. </p><br><p>  Algumas pessoas adicionam clock ao prompt do shell ou at√© o nome de um terminal virtual (tty), ou alguns rabiscos arbitr√°rios.  Isso √© tudo sup√©rfluo.  √â melhor manter muito espa√ßo para comandos. </p><br><p>  √â assim que meu prompt de shell se parece em diferentes condi√ß√µes: </p><br><p><img src="https://habrastorage.org/webt/ka/q3/gf/kaq3gfz9idb6pkxdglx44qyuxlq.png"></p><br><p>  Voc√™ pode ver na captura de tela que a barra de t√≠tulo do terminal faz o trabalho semelhante.  Tamb√©m √© parte de um painel e tamb√©m deve ser configurado. </p><br><p>  Ent√£o, como tudo isso deve ser implementado no <code>.zshrc</code> ?  A vari√°vel <code>PROMPT</code> define o prompt esquerdo e <code>RPROMPT</code> define o prompt direito.  A vari√°vel <code>EUID</code> define o status de um usu√°rio (regular ou raiz) e a presen√ßa <code>SSH2_CLIENT</code> ou <code>SSH2_CLIENT</code> indica conex√£o ssh.  Para que possamos ter um modelo: </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH_CLIENT</span></span></span><span class="hljs-string">"</span></span> || -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH2_CLIENT</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EUID</span></span> == 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment"># not SSH if [[ $EUID == 0 ]]; then PROMPT=... else PROMPT=... fi fi</span></span></code> </pre> <br><p>  N√£o mostro o c√≥digo pronto para copiar e colar, pois a implementa√ß√£o exata √© uma quest√£o de gosto.  Se voc√™ n√£o quiser se incomodar e a captura de tela acima estiver correta para voc√™, ent√£o pegue meu cofig <a href="" rel="nofollow">no Github</a> . </p><br><p>  Resumo: </p><br><ul><li>  Prompt de shell colorido √© um deve ter. </li><li>  O m√≠nimo necess√°rio √© um diret√≥rio de trabalho atual. </li><li>  A casca da raiz deve estar claramente vis√≠vel. </li><li>  O nome de um usu√°rio n√£o se importa com uma carga √∫til se voc√™ usar apenas uma conta. </li><li>  O nome do host √© √∫til se voc√™ se conectar aos servidores via ssh, n√£o √© obrigat√≥rio se n√£o o fizer. </li><li>  √â √∫til ver o c√≥digo de sa√≠da sem √™xito de um √∫ltimo comando. </li><li>  O status do reposit√≥rio Git economiza tempo nos comandos <code>git status</code> e <code>git branch</code> e traz √† prova de falhas. </li></ul><br><h3 id="heavily-use-the-command-history">  Use fortemente o hist√≥rico de comandos </h3><br><p>  Na maior parte dos comandos da sua vida, voc√™ digita mais de uma vez; portanto, seria legal retir√°-los da hist√≥ria em vez de digitar novamente.  Todos os shells modernos salvam um hist√≥rico de comando e fornecem v√°rias maneiras de pesquisar nesse hist√≥rico. </p><br><p>  Talvez voc√™ j√° consiga cavar o hist√≥rico usando as teclas Ctrl + R.  Infelizmente, tem duas desvantagens: </p><br><ol><li>  A linha de comando deve estar vazia para iniciar a pesquisa, ou seja, no caso "algu√©m come√ßou a digitar um comando - lembrado da pesquisa", voc√™ deve limpar sua digita√ß√£o primeiro e, em seguida, pressionar Ctrl + R e repetir sua entrada.  Isso leva muito tempo. </li><li>  A pesquisa direta n√£o funciona por padr√£o, pois Ctrl + S para o terminal. </li></ol><br><p>  O tipo de pesquisa mais r√°pido e conveniente funciona desta maneira: </p><br><ol><li>  Voc√™ come√ßa a digitar um comando, </li><li>  voc√™ se lembra da pesquisa, </li><li>  voc√™ pressiona uma tecla de atalho e o shell oferece comandos do hist√≥rico que come√ßaram da mesma maneira. </li></ol><br><p>  Por exemplo, voc√™ deseja sincronizar um diret√≥rio local com um remoto usando o Rsync e j√° o fez duas horas antes.  Voc√™ digita <code>rsync</code> , pressiona uma tecla de atalho uma ou duas vezes e o comando desejado est√° pronto para ser iniciado.  Voc√™ n√£o precisa ativar o modo de pesquisa primeiro, o prompt do shell n√£o muda para <code>(reverse-i-search)':</code> e nada salta em qualquer lugar.  Voc√™ est√° apenas percorrendo o hist√≥rico da mesma maneira que pressiona as setas ‚Üë ‚Üì para percorrer os comandos inseridos anteriormente, mas com filtragem adicional.  Isso √© muito legal e economiza muito tempo. </p><br><p>  Esse tipo de pesquisa n√£o funciona por padr√£o no Bash e no Zsh, ent√£o voc√™ deve habilit√°-lo manualmente.  Eu escolhi o PgUp para pesquisar para frente e o PgDown para pesquisar para tr√°s.  √â longe de alcan√ß√°-los, mas eu j√° criei um h√°bito.  Talvez mais tarde eu mude para algo mais pr√≥ximo como Ctrl + P e Ctrl + N. </p><br><p>  Para o Bash, voc√™ precisa adicionar algumas strings em <code>/etc/inputrc</code> de <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[5~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[6~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Se voc√™ <code>.zshrc</code> um <code>.zshrc</code> completo estrangeiro, √© altamente prov√°vel que o PgUp e o PgDown j√° fa√ßam o trabalho.  Caso contr√°rio, adicione a <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[5~"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-beginning-search-backward <span class="hljs-comment"><span class="hljs-comment"># pg up bindkey "^[[6~" history-beginning-search-forward # pg down</span></span></code> </pre> <br><p>  Os reservat√≥rios Fish e Ipython j√° possuem essa pesquisa vinculada √†s setas ‚Üë ‚Üì.  Eu acho que muitos usu√°rios migraram para o Fish apenas pelo comportamento das flechas.  Obviamente, √© poss√≠vel vincular as setas dessa maneira no Bash e no Zsh, se desejar.  Use isso em <code>/etc/inputrc</code> de <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[A"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[B"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  E isso em <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[A"</span></span> up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[B"</span></span> down-line-or-beginning-search</code> </pre> <br><p>  √â curioso que, com o tempo, comecei a escrever comandos tendo em mente que mais tarde os retirarei da hist√≥ria.  Deixe-me mostrar algumas t√©cnicas. </p><br><p>  <strong>Junte-se aos comandos</strong> que sempre se seguem: </p><br><pre> <code class="plaintext hljs"># ip link set eth1 up &amp;&amp; dhclient eth1 # mkdir /tmp/t &amp;&amp; mount /dev/sdb1 /tmp/t</code> </pre> <br><p>  <strong>Caminhos absolutos em vez de relativos</strong> permitem executar um comando a partir de qualquer diret√≥rio: <br>  <code>vim ~/.ssh/config</code> vez de <code>vim .ssh/config</code> , <code>systemd-nspawn /home/chroot/stretch</code> vez de <code>systemd-nspawn stretch</code> e assim por diante. </p><br><p>  <strong>O uso de curinga</strong> torna seus comandos mais universais.  Eu costumo us√°-lo em conjunto com <code>chmod</code> e <code>chown</code> . </p><br><pre> <code class="plaintext hljs"># chown root:root /var/www/*.sq &amp;&amp; chmod 644 /var/www/*.sq</code> </pre> <br><h3 id="keyboard-shortcuts">  Atalhos do teclado </h3><br><p>  Aqui est√° o m√≠nimo necess√°rio. </p><br><p>  Alt +.  - substitui o √∫ltimo argumento do comando anterior.  Tamb√©m pode ser acessado com <code>!$</code> . <br>  Ctrl + A, Ctrl + E - pula para o in√≠cio e o final da linha, respectivamente. <br>  Ctrl + U, Ctrl + Y - recortar e colar.  √â √∫til quando voc√™ digita um comando complexo e percebe que precisa executar outro primeiro.  Hmm, onde salvar a entrada atual?  Bem aqui. <br>  Ctrl + W - mata uma palavra antes do cursor.  Limpa a linha ao pressionar e segurar.  Por padr√£o, a entrada √© salva na √°rea de transfer√™ncia (usada para Ctrl + Y). <br>  Ctrl + K - corta a parte da linha ap√≥s o cursor, adicionando-a √† √°rea de transfer√™ncia.  Ctrl + A Ctrl + K limpa rapidamente a linha. <br>  PgUp, PgDown, Ctrl + R - pesquisa de hist√≥rico. <br>  Ctrl + L limpa o terminal. </p><br><h3 id="keyboard-responsiveness">  Capacidade de resposta do teclado </h3><br><p>  Quero mostrar uma pequena configura√ß√£o que permite rolar, navegar e apagar mais rapidamente.  O que fazemos quando queremos apagar algo grande?  Pressionamos e mantemos Backspace e assistimos a ele voltar a limpar caracteres.  O que est√° acontecendo exatamente?  Depois que o Backspace √© pressionado, um caractere desaparece, passa um pequeno atraso e a repeti√ß√£o autom√°tica √© acionada: O Backspace apaga os caracteres um por um, como se voc√™ o pressionasse repetidamente. </p><br><p>  Eu recomendo que voc√™ ajuste o atraso e a frequ√™ncia de repeti√ß√£o autom√°tica para a velocidade dos seus dedos.  O atraso √© necess√°rio quando voc√™ deseja apagar apenas um caractere - ele oferece tempo para liberar uma tecla.  Atraso muito grande faz com que voc√™ espere uma repeti√ß√£o autom√°tica.  N√£o √© o suficiente para voc√™ se aborrecer, mas o suficiente para retardar a transfer√™ncia de seus pensamentos da cabe√ßa para o computador.  Quanto maior a frequ√™ncia de repeti√ß√£o autom√°tica, mais r√°pido o texto est√° sendo apagado e mais dif√≠cil √© interromper esse processo.  O objetivo √© encontrar um valor √≥timo. </p><br><p>  Ent√£o, o comando m√°gico √©: </p><br><pre> <code class="plaintext hljs">$ xset r rate 190 20</code> </pre> <br><p>  190 - dura√ß√£o do atraso em milissegundos, <br>  20 - frequ√™ncia em repeti√ß√µes por segundo. </p><br><p>  Eu recomendo come√ßar com esses valores e aumentar o atraso pouco a pouco at√© falsos positivos, depois retornar um pouco.  Se o atraso for muito pequeno, voc√™ n√£o poder√° usar o teclado.  Para corrigir isso, um servidor X ou um computador completo deve ser reiniciado.  Ent√£o, por favor, tenha cuidado. </p><br><p>  Para salvar os par√¢metros, voc√™ precisa adicionar este comando em algum lugar do X autostart. </p><br><h3 id="process-exit-indication">  Indica√ß√£o de sa√≠da do processo </h3><br><p>  Muitas vezes, tenho que iniciar alguns processos de longa execu√ß√£o: backup em massa, transfer√™ncia de big data, empacotamento / extra√ß√£o de arquivos, cria√ß√£o de pacotes e assim por diante.  Geralmente inicio esse processo, alterno para outra tarefa e olho ocasionalmente se meu processo de longo prazo terminou.  √Äs vezes eu mergulho muito fundo no trabalho e esque√ßo.  A solu√ß√£o √© adicionar uma notifica√ß√£o de sa√≠da do processo que me tirar√° do transe. </p><br><p>  Existem muitas ferramentas para esse fim: notificar-enviar, dzen2, bip, aplay, wall.  Todos eles s√£o bons de alguma forma, mas n√£o funcionam com a conex√£o ssh.  √â por isso que eu uso o bipe do terminal: </p><br><pre> <code class="plaintext hljs">$ long-running-command; echo $'\a'</code> </pre> <br><p>  A codifica√ß√£o ASCII possui um caractere 0x7, chamado <a href="https://en.wikipedia.org/wiki/Bell_character" rel="nofollow">bell</a> .  √â usado para emitir um bipe no alto-falante do PC.  O alto-falante do PC n√£o √© algo moderno, nem todo computador o possui e n√£o √© ouvido nos fones de ouvido.  √â por isso que alguns terminais usam a chamada campainha visual.  Eu uso o urxvt, e ele executa um sino visual, aumentando a sinaliza√ß√£o de urg√™ncia.  O que √© isso?  √â uma coisa usada quando uma janela quer dizer que √© urgente. </p><br><p>  Voc√™ pode verificar como o seu terminal reage ao car√°ter da campainha agora: </p><br><pre> <code class="plaintext hljs">$ sleep 3; echo $'\a'</code> </pre> <br><p>  S√£o dados tr√™s segundos para voc√™ alternar para outra janela; pode ser necess√°rio. </p><br><p>  Infelizmente, nem todo terminal pode exibir campainha visual, levantando a bandeira de urg√™ncia.  Eu verifiquei o mais popular. </p><br><div class="scrollable-table"><table><thead><tr><th>  Emulador de terminal </th><th>  sino visual como bandeira de urg√™ncia </th></tr></thead><tbody><tr><td>  konsole </td><td>  pode estar ativado nas prefer√™ncias </td></tr><tr><td>  urxvt </td><td>  sim </td></tr><tr><td>  xfce4-terminal </td><td>  pode estar ativado nas prefer√™ncias </td></tr><tr><td>  xterm </td><td>  n√£o </td></tr><tr><td>  termo retro legal </td><td>  n√£o </td></tr><tr><td>  lxterminal </td><td>  n√£o </td></tr><tr><td>  gnome-terminal </td><td>  n√£o </td></tr></tbody></table></div><br><p>  √â muito longo para digitar <code>echo $'\a'</code> , ent√£o criei um alias de <code>wake</code> . </p><br><h3 id="aliases">  Aliases </h3><br><p>  Por comandos padr√£o, <code>cp</code> , <code>scp</code> e <code>rm</code> funcionam de forma n√£o recursiva e isso √© p√©ssimo!  √â um maldito legado!  Bem, pode ser corrigido usando aliases.  Mas primeiro vamos ver quando o comportamento n√£o recursivo pode ser √∫til. </p><br><pre> <code class="plaintext hljs">$ mkdir foodir $ cp * foodir</code> </pre> <br><p>  Somente arquivos ser√£o copiados para o <code>foodir</code> , mas n√£o para os diret√≥rios.  A mesma situa√ß√£o ocorre com <code>rm</code> : </p><br><pre> <code class="plaintext hljs">$ rm *</code> </pre> <br><p>  excluir√° apenas arquivos e links simb√≥licos, mas manter√° os diret√≥rios.  Mas com que frequ√™ncia voc√™ precisa desse recurso?  Eu gosto de pensar que <code>cp</code> e <code>rm</code> sempre funcionam recursivamente. </p><br><p>  Ok, mas e a seguran√ßa?  Talvez o comportamento n√£o recursivo proteja seus arquivos?  H√° um caso em que voc√™ tem um link simb√≥lico para o diret√≥rio e deseja remover esse link simb√≥lico, mas mantenha o diret√≥rio.  Se uma barra for anexada (intencionalmente ou ocasionalmente) ao nome do diret√≥rio e o modo recursivo for ativado via <code>-r</code> , o diret√≥rio ficar√° vazio!  VAZIO! </p><br><pre> <code class="plaintext hljs">$ ln -s foodir dir_link $ rm -r dir_link/</code> </pre> <br><p>  Sem <code>-r</code> arg, ele abusar√° e n√£o remover√° nada.  Portanto, <code>rm</code> recursiva aumenta o risco de perder um pouco os dados. </p><br><p>  Ativei o modo recursivo para <code>cp</code> , <code>scp</code> e <code>rm</code> e tamb√©m adicionei <code>-p</code> para <code>mkdir</code> para criar diret√≥rios aninhados facilmente. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> scp=<span class="hljs-string"><span class="hljs-string">'scp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> rm=<span class="hljs-string"><span class="hljs-string">'rm -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> mkdir=<span class="hljs-string"><span class="hljs-string">'mkdir -p'</span></span></code> </pre> <br><p>  Por dois anos, nunca me arrependi desses pseud√¥nimos e nunca perdi dados.  H√° tamb√©m uma desvantagem: √© poss√≠vel copiar / remover menos dados do que o necess√°rio e n√£o avist√°-los ao trabalhar no sistema sem apelidos.  Ent√£o, por favor tenha cuidado.  Sei o que fa√ßo e sempre corro <code>rm</code> com cautela. </p><br><p>  Os mais populares s√£o os aliases de <code>ls</code> e voc√™ provavelmente j√° os usa: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ls=<span class="hljs-string"><span class="hljs-string">'ls -F --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> la=<span class="hljs-string"><span class="hljs-string">'ls -A'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ll=<span class="hljs-string"><span class="hljs-string">'ls -lh'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> lla=<span class="hljs-string"><span class="hljs-string">'ll -A'</span></span></code> </pre> <br><p>  Al√©m disso, um grep colorido √© muito mais bonito do que incolor: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grep=<span class="hljs-string"><span class="hljs-string">'grep --colour=auto'</span></span></code> </pre> <br><p>  Aliases n√£o funcionam em scripts, n√£o se esque√ßa disso!  Voc√™ precisa especificar explicitamente todos os argumentos. </p><br><h3 id="touch-typing">  Digita√ß√£o por toque </h3><br><p>  √â √≥bvio, mas lembro: a digita√ß√£o por toque ajuda a digitar mais rapidamente.  Vai ser dif√≠cil no come√ßo, mas voc√™ superar√° os limites ao longo do tempo. </p><br><p>  O melhor momento para aprender a digitar com toque √© nas f√©rias, quando ningu√©m a incomoda.  Por favor, n√£o se apresse ao aprender!  Seu objetivo √© <em>memorizar</em> onde cada personagem est√° localizado, n√£o tanto com sua mente, mas com seus dedos.  √â melhor digitar devagar, mas sem erros, em vez de r√°pido com erros.  Lembre-se de que os mestres t√™m bons resultados, n√£o com dedos r√°pidos, mas sem cometer erros. </p><br><p>  N√£o se esque√ßa de fazer uma pausa.  Seu c√©rebro e seus dedos precisam descansar.  Quando os erros come√ßam a aparecer, isso significa que voc√™ precisa fazer uma pausa. </p><br><h3 id="that-is-all-for-today">  Isso √© tudo por hoje </h3><br><p>  Espero que essas dicas realmente o ajudem.  Boa sorte </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481940/">https://habr.com/ru/post/pt481940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481926/index.html">Conhe√ßa a nova solu√ß√£o Veeam Backup for AWS</a></li>
<li><a href="../pt481930/index.html">Cultura de desenvolvimento: como o desempenho e a efici√™ncia s√£o avaliados</a></li>
<li><a href="../pt481932/index.html">Implanta√ß√£o e bancos de dados sem tempo de inatividade</a></li>
<li><a href="../pt481934/index.html">An√°lise: por que as a√ß√µes da Tesla est√£o crescendo em pre√ßo</a></li>
<li><a href="../pt481936/index.html">Pr√≥s e contras dos testes A / B: experi√™ncia de grandes empresas</a></li>
<li><a href="../pt481942/index.html">De volta ao futuro: que jogos modernos foram apresentados em 2010</a></li>
<li><a href="../pt481944/index.html">O que determina a posi√ß√£o do site na p√°gina de pesquisa?</a></li>
<li><a href="../pt481946/index.html">M√©todos de comunica√ß√£o no Microsoft Teams: canais vs bate-papos</a></li>
<li><a href="../pt481948/index.html">Como criar um rob√¥ virtual?</a></li>
<li><a href="../pt481950/index.html">Tutorial: Inicializa√ß√£o reativa por mola</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>