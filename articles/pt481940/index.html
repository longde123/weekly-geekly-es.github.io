<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🉑 👨‍👧 🤦🏽 Trabalho rápido e eficaz na linha de comando 😙 📰 👩🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem muitas dicas e truques de linha de comando na internet. A maioria deles descreve os triviais como "aprenda as teclas de atalho" ou " sudo !! e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabalho rápido e eficaz na linha de comando</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481940/"><p> Existem muitas dicas e truques de linha de comando na internet.  A maioria deles descreve os triviais como "aprenda as teclas de atalho" ou " <code>sudo !!</code> executará o comando anterior com o sudo".  Em vez disso, vou lhe dizer o que fazer quando você já aprendeu as teclas de atalho e conhece o <code>sudo !!</code>  . </p><a name="habracut"></a><br><h3 id="the-terminal-should-start-instantly">  O terminal deve iniciar instantaneamente </h3><br><p>  Quanto tempo você gasta para lançar um terminal?  E outro?  Por um longo tempo, usei o atalho Ctrl + Alt + T para iniciar um terminal e achei rápido.  Quando migrei do Openbox para o i3, comecei a lançar um terminal via Win + Enter, que funcionava de forma imediata.  Você sabe o que?  Agora não acho que Ctrl + Alt + T seja rápido o suficiente. </p><br><p>  Obviamente, a coisa não é uma aceleração de milissegundos, mas você abre um terminal no nível dos reflexos, completamente alheio a isso. </p><br><p>  Portanto, se você costuma usar um terminal, mas pega um mouse para iniciá-lo, tente configurar uma tecla de atalho útil.  Tenho certeza que você vai gostar. </p><br><h3 id="zsh-instead-of-bash">  Zsh em vez de bash </h3><br><p>  Este é um tópico da guerra santa, eu sei.  Você deve instalar o Zsh para pelo menos três recursos: preenchimento automático avançado, correção de erros de digitação e conclusão de vários nomes de caminhos: quando uma única guia converte <code>/u/s/d</code> em <code>/usr/share/doc</code> .  O Arch Linux já migrou para o Zsh em seu CD de instalação.  Espero que o Zsh se torne um shell padrão no Ubuntu.  Esse será um momento histórico. </p><br><p>  Começar a usar o Zsh não é nada difícil.  Basta instalá-lo via gerenciador de pacotes e encontrar uma configuração bonita.  Eu recomendo levar a configuração usada no Arch Linux: </p><br><pre> <code class="plaintext hljs">$ wget -O ~/.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc</code> </pre> <br><p>  A única coisa que resta é mudar o seu shell padrão e entrar novamente. </p><br><pre> <code class="plaintext hljs">$ chsh -s $(which zsh)</code> </pre> <br><p>  É tudo, continue trabalhando como se nada tivesse acontecido. </p><br><h3 id="how-the-shell-prompt-should-look-like">  Como o prompt do shell deve se parecer </h3><br><p>  O prompt do shell é um pequeno pedaço de texto mostrado no terminal no início da sua linha de comando.  Deve ser configurado para o seu tipo de trabalho.  Você pode percebê-lo como o painel de instrumentos de um veículo.  Por favor, coloque algumas informações úteis, deixe-o ajudá-lo a navegar!  Torne-o útil, especialmente se você o vê todos os dias! </p><br><p>  O prompt do shell deve ser colorido.  Não concorda?  Tente contar quantos comandos foram executados neste terminal: </p><br><p><img src="https://habrastorage.org/webt/yh/mu/s7/yhmus7x5-abqnlrho5u5djwau8o.png"></p><br><p>  E agora com cores: </p><br><p><img src="https://habrastorage.org/webt/re/1b/ln/re1blnqfemmydwf99758sbirqai.png"></p><br><p>  O prompt do shell deve exibir um diretório de trabalho atual de um shell.  Se o diretório de trabalho atual não for exibido, mantenha-o em mente e verifique-o periodicamente com o comando <code>pwd</code> .  Por favor, não faça isso.  Lembre-se de algumas coisas realmente importantes e não perca tempo com o comando <code>pwd</code> . </p><br><p>  Se você mudar para a conta raiz, precisará de uma indicação de "usuário atual".  O nome de usuário específico geralmente não é importante, mas seu status (regular ou raiz) é.  A solução é usar o prompt de shell color: red para raiz e verde para usuário comum.  E você nunca assumirá o shell raiz como regular. </p><br><p>  Se você se conectar a servidores usando ssh, precisará distinguir seus shells locais e remotos.  Para esse propósito, o prompt do shell deve conter um nome de host ou, melhor ainda, indicar uma conexão ssh. </p><br><p>  O prompt do shell pode mostrar o código de saída do último comando.  Lembre-se de que o código de saída zero significa que um comando foi encerrado com sucesso, diferente de zero - o comando foi encerrado sem êxito.  Você pode obter o código de saída do último comando via <code>echo $?</code>  , mas digitar tudo isso é uma coisa muito longa.  Deixe o shell mostrar uma saída sem êxito. </p><br><p>  Se você trabalha com repositórios Git, será útil ver o status do repositório no prompt do shell: branch atual e o estado do diretório de trabalho.  Você economizará algum tempo com os comandos <code>git status</code> e <code>git branch</code> e não se comprometerá com uma ramificação errada.  Sim, o cálculo do status pode levar um tempo significativo nos repositórios de gordura, mas para mim os profissionais superam os contras. </p><br><p>  Algumas pessoas adicionam clock ao prompt do shell ou até o nome de um terminal virtual (tty), ou alguns rabiscos arbitrários.  Isso é tudo supérfluo.  É melhor manter muito espaço para comandos. </p><br><p>  É assim que meu prompt de shell se parece em diferentes condições: </p><br><p><img src="https://habrastorage.org/webt/ka/q3/gf/kaq3gfz9idb6pkxdglx44qyuxlq.png"></p><br><p>  Você pode ver na captura de tela que a barra de título do terminal faz o trabalho semelhante.  Também é parte de um painel e também deve ser configurado. </p><br><p>  Então, como tudo isso deve ser implementado no <code>.zshrc</code> ?  A variável <code>PROMPT</code> define o prompt esquerdo e <code>RPROMPT</code> define o prompt direito.  A variável <code>EUID</code> define o status de um usuário (regular ou raiz) e a presença <code>SSH2_CLIENT</code> ou <code>SSH2_CLIENT</code> indica conexão ssh.  Para que possamos ter um modelo: </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH_CLIENT</span></span></span><span class="hljs-string">"</span></span> || -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH2_CLIENT</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EUID</span></span> == 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment"># not SSH if [[ $EUID == 0 ]]; then PROMPT=... else PROMPT=... fi fi</span></span></code> </pre> <br><p>  Não mostro o código pronto para copiar e colar, pois a implementação exata é uma questão de gosto.  Se você não quiser se incomodar e a captura de tela acima estiver correta para você, então pegue meu cofig <a href="" rel="nofollow">no Github</a> . </p><br><p>  Resumo: </p><br><ul><li>  Prompt de shell colorido é um deve ter. </li><li>  O mínimo necessário é um diretório de trabalho atual. </li><li>  A casca da raiz deve estar claramente visível. </li><li>  O nome de um usuário não se importa com uma carga útil se você usar apenas uma conta. </li><li>  O nome do host é útil se você se conectar aos servidores via ssh, não é obrigatório se não o fizer. </li><li>  É útil ver o código de saída sem êxito de um último comando. </li><li>  O status do repositório Git economiza tempo nos comandos <code>git status</code> e <code>git branch</code> e traz à prova de falhas. </li></ul><br><h3 id="heavily-use-the-command-history">  Use fortemente o histórico de comandos </h3><br><p>  Na maior parte dos comandos da sua vida, você digita mais de uma vez; portanto, seria legal retirá-los da história em vez de digitar novamente.  Todos os shells modernos salvam um histórico de comando e fornecem várias maneiras de pesquisar nesse histórico. </p><br><p>  Talvez você já consiga cavar o histórico usando as teclas Ctrl + R.  Infelizmente, tem duas desvantagens: </p><br><ol><li>  A linha de comando deve estar vazia para iniciar a pesquisa, ou seja, no caso "alguém começou a digitar um comando - lembrado da pesquisa", você deve limpar sua digitação primeiro e, em seguida, pressionar Ctrl + R e repetir sua entrada.  Isso leva muito tempo. </li><li>  A pesquisa direta não funciona por padrão, pois Ctrl + S para o terminal. </li></ol><br><p>  O tipo de pesquisa mais rápido e conveniente funciona desta maneira: </p><br><ol><li>  Você começa a digitar um comando, </li><li>  você se lembra da pesquisa, </li><li>  você pressiona uma tecla de atalho e o shell oferece comandos do histórico que começaram da mesma maneira. </li></ol><br><p>  Por exemplo, você deseja sincronizar um diretório local com um remoto usando o Rsync e já o fez duas horas antes.  Você digita <code>rsync</code> , pressiona uma tecla de atalho uma ou duas vezes e o comando desejado está pronto para ser iniciado.  Você não precisa ativar o modo de pesquisa primeiro, o prompt do shell não muda para <code>(reverse-i-search)':</code> e nada salta em qualquer lugar.  Você está apenas percorrendo o histórico da mesma maneira que pressiona as setas ↑ ↓ para percorrer os comandos inseridos anteriormente, mas com filtragem adicional.  Isso é muito legal e economiza muito tempo. </p><br><p>  Esse tipo de pesquisa não funciona por padrão no Bash e no Zsh, então você deve habilitá-lo manualmente.  Eu escolhi o PgUp para pesquisar para frente e o PgDown para pesquisar para trás.  É longe de alcançá-los, mas eu já criei um hábito.  Talvez mais tarde eu mude para algo mais próximo como Ctrl + P e Ctrl + N. </p><br><p>  Para o Bash, você precisa adicionar algumas strings em <code>/etc/inputrc</code> de <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[5~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[6~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Se você <code>.zshrc</code> um <code>.zshrc</code> completo estrangeiro, é altamente provável que o PgUp e o PgDown já façam o trabalho.  Caso contrário, adicione a <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[5~"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-beginning-search-backward <span class="hljs-comment"><span class="hljs-comment"># pg up bindkey "^[[6~" history-beginning-search-forward # pg down</span></span></code> </pre> <br><p>  Os reservatórios Fish e Ipython já possuem essa pesquisa vinculada às setas ↑ ↓.  Eu acho que muitos usuários migraram para o Fish apenas pelo comportamento das flechas.  Obviamente, é possível vincular as setas dessa maneira no Bash e no Zsh, se desejar.  Use isso em <code>/etc/inputrc</code> de <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[A"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[B"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  E isso em <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[A"</span></span> up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[B"</span></span> down-line-or-beginning-search</code> </pre> <br><p>  É curioso que, com o tempo, comecei a escrever comandos tendo em mente que mais tarde os retirarei da história.  Deixe-me mostrar algumas técnicas. </p><br><p>  <strong>Junte-se aos comandos</strong> que sempre se seguem: </p><br><pre> <code class="plaintext hljs"># ip link set eth1 up &amp;&amp; dhclient eth1 # mkdir /tmp/t &amp;&amp; mount /dev/sdb1 /tmp/t</code> </pre> <br><p>  <strong>Caminhos absolutos em vez de relativos</strong> permitem executar um comando a partir de qualquer diretório: <br>  <code>vim ~/.ssh/config</code> vez de <code>vim .ssh/config</code> , <code>systemd-nspawn /home/chroot/stretch</code> vez de <code>systemd-nspawn stretch</code> e assim por diante. </p><br><p>  <strong>O uso de curinga</strong> torna seus comandos mais universais.  Eu costumo usá-lo em conjunto com <code>chmod</code> e <code>chown</code> . </p><br><pre> <code class="plaintext hljs"># chown root:root /var/www/*.sq &amp;&amp; chmod 644 /var/www/*.sq</code> </pre> <br><h3 id="keyboard-shortcuts">  Atalhos do teclado </h3><br><p>  Aqui está o mínimo necessário. </p><br><p>  Alt +.  - substitui o último argumento do comando anterior.  Também pode ser acessado com <code>!$</code> . <br>  Ctrl + A, Ctrl + E - pula para o início e o final da linha, respectivamente. <br>  Ctrl + U, Ctrl + Y - recortar e colar.  É útil quando você digita um comando complexo e percebe que precisa executar outro primeiro.  Hmm, onde salvar a entrada atual?  Bem aqui. <br>  Ctrl + W - mata uma palavra antes do cursor.  Limpa a linha ao pressionar e segurar.  Por padrão, a entrada é salva na área de transferência (usada para Ctrl + Y). <br>  Ctrl + K - corta a parte da linha após o cursor, adicionando-a à área de transferência.  Ctrl + A Ctrl + K limpa rapidamente a linha. <br>  PgUp, PgDown, Ctrl + R - pesquisa de histórico. <br>  Ctrl + L limpa o terminal. </p><br><h3 id="keyboard-responsiveness">  Capacidade de resposta do teclado </h3><br><p>  Quero mostrar uma pequena configuração que permite rolar, navegar e apagar mais rapidamente.  O que fazemos quando queremos apagar algo grande?  Pressionamos e mantemos Backspace e assistimos a ele voltar a limpar caracteres.  O que está acontecendo exatamente?  Depois que o Backspace é pressionado, um caractere desaparece, passa um pequeno atraso e a repetição automática é acionada: O Backspace apaga os caracteres um por um, como se você o pressionasse repetidamente. </p><br><p>  Eu recomendo que você ajuste o atraso e a frequência de repetição automática para a velocidade dos seus dedos.  O atraso é necessário quando você deseja apagar apenas um caractere - ele oferece tempo para liberar uma tecla.  Atraso muito grande faz com que você espere uma repetição automática.  Não é o suficiente para você se aborrecer, mas o suficiente para retardar a transferência de seus pensamentos da cabeça para o computador.  Quanto maior a frequência de repetição automática, mais rápido o texto está sendo apagado e mais difícil é interromper esse processo.  O objetivo é encontrar um valor ótimo. </p><br><p>  Então, o comando mágico é: </p><br><pre> <code class="plaintext hljs">$ xset r rate 190 20</code> </pre> <br><p>  190 - duração do atraso em milissegundos, <br>  20 - frequência em repetições por segundo. </p><br><p>  Eu recomendo começar com esses valores e aumentar o atraso pouco a pouco até falsos positivos, depois retornar um pouco.  Se o atraso for muito pequeno, você não poderá usar o teclado.  Para corrigir isso, um servidor X ou um computador completo deve ser reiniciado.  Então, por favor, tenha cuidado. </p><br><p>  Para salvar os parâmetros, você precisa adicionar este comando em algum lugar do X autostart. </p><br><h3 id="process-exit-indication">  Indicação de saída do processo </h3><br><p>  Muitas vezes, tenho que iniciar alguns processos de longa execução: backup em massa, transferência de big data, empacotamento / extração de arquivos, criação de pacotes e assim por diante.  Geralmente inicio esse processo, alterno para outra tarefa e olho ocasionalmente se meu processo de longo prazo terminou.  Às vezes eu mergulho muito fundo no trabalho e esqueço.  A solução é adicionar uma notificação de saída do processo que me tirará do transe. </p><br><p>  Existem muitas ferramentas para esse fim: notificar-enviar, dzen2, bip, aplay, wall.  Todos eles são bons de alguma forma, mas não funcionam com a conexão ssh.  É por isso que eu uso o bipe do terminal: </p><br><pre> <code class="plaintext hljs">$ long-running-command; echo $'\a'</code> </pre> <br><p>  A codificação ASCII possui um caractere 0x7, chamado <a href="https://en.wikipedia.org/wiki/Bell_character" rel="nofollow">bell</a> .  É usado para emitir um bipe no alto-falante do PC.  O alto-falante do PC não é algo moderno, nem todo computador o possui e não é ouvido nos fones de ouvido.  É por isso que alguns terminais usam a chamada campainha visual.  Eu uso o urxvt, e ele executa um sino visual, aumentando a sinalização de urgência.  O que é isso?  É uma coisa usada quando uma janela quer dizer que é urgente. </p><br><p>  Você pode verificar como o seu terminal reage ao caráter da campainha agora: </p><br><pre> <code class="plaintext hljs">$ sleep 3; echo $'\a'</code> </pre> <br><p>  São dados três segundos para você alternar para outra janela; pode ser necessário. </p><br><p>  Infelizmente, nem todo terminal pode exibir campainha visual, levantando a bandeira de urgência.  Eu verifiquei o mais popular. </p><br><div class="scrollable-table"><table><thead><tr><th>  Emulador de terminal </th><th>  sino visual como bandeira de urgência </th></tr></thead><tbody><tr><td>  konsole </td><td>  pode estar ativado nas preferências </td></tr><tr><td>  urxvt </td><td>  sim </td></tr><tr><td>  xfce4-terminal </td><td>  pode estar ativado nas preferências </td></tr><tr><td>  xterm </td><td>  não </td></tr><tr><td>  termo retro legal </td><td>  não </td></tr><tr><td>  lxterminal </td><td>  não </td></tr><tr><td>  gnome-terminal </td><td>  não </td></tr></tbody></table></div><br><p>  É muito longo para digitar <code>echo $'\a'</code> , então criei um alias de <code>wake</code> . </p><br><h3 id="aliases">  Aliases </h3><br><p>  Por comandos padrão, <code>cp</code> , <code>scp</code> e <code>rm</code> funcionam de forma não recursiva e isso é péssimo!  É um maldito legado!  Bem, pode ser corrigido usando aliases.  Mas primeiro vamos ver quando o comportamento não recursivo pode ser útil. </p><br><pre> <code class="plaintext hljs">$ mkdir foodir $ cp * foodir</code> </pre> <br><p>  Somente arquivos serão copiados para o <code>foodir</code> , mas não para os diretórios.  A mesma situação ocorre com <code>rm</code> : </p><br><pre> <code class="plaintext hljs">$ rm *</code> </pre> <br><p>  excluirá apenas arquivos e links simbólicos, mas manterá os diretórios.  Mas com que frequência você precisa desse recurso?  Eu gosto de pensar que <code>cp</code> e <code>rm</code> sempre funcionam recursivamente. </p><br><p>  Ok, mas e a segurança?  Talvez o comportamento não recursivo proteja seus arquivos?  Há um caso em que você tem um link simbólico para o diretório e deseja remover esse link simbólico, mas mantenha o diretório.  Se uma barra for anexada (intencionalmente ou ocasionalmente) ao nome do diretório e o modo recursivo for ativado via <code>-r</code> , o diretório ficará vazio!  VAZIO! </p><br><pre> <code class="plaintext hljs">$ ln -s foodir dir_link $ rm -r dir_link/</code> </pre> <br><p>  Sem <code>-r</code> arg, ele abusará e não removerá nada.  Portanto, <code>rm</code> recursiva aumenta o risco de perder um pouco os dados. </p><br><p>  Ativei o modo recursivo para <code>cp</code> , <code>scp</code> e <code>rm</code> e também adicionei <code>-p</code> para <code>mkdir</code> para criar diretórios aninhados facilmente. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> scp=<span class="hljs-string"><span class="hljs-string">'scp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> rm=<span class="hljs-string"><span class="hljs-string">'rm -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> mkdir=<span class="hljs-string"><span class="hljs-string">'mkdir -p'</span></span></code> </pre> <br><p>  Por dois anos, nunca me arrependi desses pseudônimos e nunca perdi dados.  Há também uma desvantagem: é possível copiar / remover menos dados do que o necessário e não avistá-los ao trabalhar no sistema sem apelidos.  Então, por favor tenha cuidado.  Sei o que faço e sempre corro <code>rm</code> com cautela. </p><br><p>  Os mais populares são os aliases de <code>ls</code> e você provavelmente já os usa: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ls=<span class="hljs-string"><span class="hljs-string">'ls -F --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> la=<span class="hljs-string"><span class="hljs-string">'ls -A'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ll=<span class="hljs-string"><span class="hljs-string">'ls -lh'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> lla=<span class="hljs-string"><span class="hljs-string">'ll -A'</span></span></code> </pre> <br><p>  Além disso, um grep colorido é muito mais bonito do que incolor: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grep=<span class="hljs-string"><span class="hljs-string">'grep --colour=auto'</span></span></code> </pre> <br><p>  Aliases não funcionam em scripts, não se esqueça disso!  Você precisa especificar explicitamente todos os argumentos. </p><br><h3 id="touch-typing">  Digitação por toque </h3><br><p>  É óbvio, mas lembro: a digitação por toque ajuda a digitar mais rapidamente.  Vai ser difícil no começo, mas você superará os limites ao longo do tempo. </p><br><p>  O melhor momento para aprender a digitar com toque é nas férias, quando ninguém a incomoda.  Por favor, não se apresse ao aprender!  Seu objetivo é <em>memorizar</em> onde cada personagem está localizado, não tanto com sua mente, mas com seus dedos.  É melhor digitar devagar, mas sem erros, em vez de rápido com erros.  Lembre-se de que os mestres têm bons resultados, não com dedos rápidos, mas sem cometer erros. </p><br><p>  Não se esqueça de fazer uma pausa.  Seu cérebro e seus dedos precisam descansar.  Quando os erros começam a aparecer, isso significa que você precisa fazer uma pausa. </p><br><h3 id="that-is-all-for-today">  Isso é tudo por hoje </h3><br><p>  Espero que essas dicas realmente o ajudem.  Boa sorte </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481940/">https://habr.com/ru/post/pt481940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481926/index.html">Conheça a nova solução Veeam Backup for AWS</a></li>
<li><a href="../pt481930/index.html">Cultura de desenvolvimento: como o desempenho e a eficiência são avaliados</a></li>
<li><a href="../pt481932/index.html">Implantação e bancos de dados sem tempo de inatividade</a></li>
<li><a href="../pt481934/index.html">Análise: por que as ações da Tesla estão crescendo em preço</a></li>
<li><a href="../pt481936/index.html">Prós e contras dos testes A / B: experiência de grandes empresas</a></li>
<li><a href="../pt481942/index.html">De volta ao futuro: que jogos modernos foram apresentados em 2010</a></li>
<li><a href="../pt481944/index.html">O que determina a posição do site na página de pesquisa?</a></li>
<li><a href="../pt481946/index.html">Métodos de comunicação no Microsoft Teams: canais vs bate-papos</a></li>
<li><a href="../pt481948/index.html">Como criar um robô virtual?</a></li>
<li><a href="../pt481950/index.html">Tutorial: Inicialização reativa por mola</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>