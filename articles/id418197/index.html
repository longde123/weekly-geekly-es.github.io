<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“ â¹ï¸ ğŸ™‡ğŸ¿ Kursus MIT "Keamanan Sistem Komputer". Kuliah 4: â€œBerbagi Hak Istimewa,â€ Bagian 2 ğŸ™Œ ğŸ¥‚ ğŸš‘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 4: â€œBerbagi Hak Istimewa,â€ Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418197/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: â€œBuffer Overflows: Exploits and Protectionâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 4: â€œPemisahan Hak Istimewaâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Jadi apa lagi yang kita miliki dalam daftar ini?  Proses  Memori adalah sesuatu yang terjadi bersamaan dengan prosesnya.  Jadi, jika Anda tidak dalam proses ini, maka Anda tidak dapat mengakses memorinya.  Memori virtual dengan sempurna meningkatkan isolasi ini bagi kami.  Selain itu, mekanisme debug memungkinkan Anda untuk "pop" ke dalam memori proses lain, jika Anda memiliki ID pengguna yang sama <br><br>  Selanjutnya kita memiliki jaringan.  Jaringan di <b>Unix</b> tidak cukup sesuai dengan model yang dijelaskan di atas, sebagian karena fakta bahwa <b>sistem</b> operasi <b>Unix</b> pertama kali dikembangkan, dan kemudian sebuah jaringan muncul, yang segera menjadi populer.  Ini memiliki seperangkat aturan yang sedikit berbeda.  Oleh karena itu, operasi yang benar-benar perlu kita perhatikan adalah menghubungkan seseorang ke jaringan jika Anda mengelola jaringan, atau mendengarkan beberapa port jika Anda bertindak sebagai server.  Anda mungkin perlu membaca atau menulis data pada koneksi ini, atau mengirim dan menerima paket <b>mentah</b> . <br><br><img src="https://habrastorage.org/webt/dw/gn/zv/dwgnzva6txwuj_esllvdnx3uexg.jpeg"><br><br>  Dengan demikian, jaringan di <b>Unix</b> sebagian besar tidak terkait dengan <b>userid</b> .  Aturannya adalah siapa pun dapat selalu terhubung ke mesin apa pun atau alamat IP apa pun atau membuka koneksi.  Jika Anda ingin mendengarkan port, maka dalam hal ini ada satu perbedaan, yaitu sebagian besar pengguna dilarang mendengarkan port dengan angka di bawah "nilai ajaib" 1024. Pada prinsipnya, Anda dapat mendengarkan port tersebut, tetapi dalam hal ini Anda harus Jadilah pengguna khusus yang disebut <b>"pengguna super"</b> dengan <b>uid = 0</b> . <br><br>  Secara umum, di Unix ada konsep administrator, atau superuser, yang diwakili oleh pengidentifikasi uid = 0, yang dapat melewati hampir semua pemeriksaan ini, jadi jika Anda bekerja dengan hak root, Anda dapat membaca dan menulis file, mengubah hak akses ke sana.  Sistem operasi akan memungkinkan Anda untuk melakukan ini karena menurutnya Anda harus memiliki semua hak istimewa.  Dan Anda benar-benar membutuhkan hak istimewa untuk mendengarkan pada port dengan angka &lt;1024. Apa pendapat Anda tentang pembatasan aneh seperti itu? <br><br>  <b>Pemirsa:</b> ini mengidentifikasi nomor port tertentu untuk koneksi tertentu, misalnya, untuk <b>http</b> pada port 80. <br><br>  <b>Profesor:</b> ya, secara default <b>protokol HTTP</b> menggunakan port 80. Di sisi lain, layanan lain dapat menggunakan port dengan angka lebih tinggi dari 1024, mengapa pembatasan ini diperlukan?  Apa gunanya di sini? <br><br>  <b>Pemirsa:</b> karena Anda tidak ingin ada orang yang secara tidak sengaja mendengarkan <b>HTTP</b> Anda. <br><br>  <b>Profesor:</b> ya.  Saya pikir alasannya adalah Anda dulu memiliki banyak pengguna di mesin yang sama.  Mereka masuk dengan login mereka, meluncurkan aplikasi mereka, jadi Anda ingin memastikan bahwa beberapa pengguna acak, setelah masuk ke komputer, tidak akan bisa mendapatkan server web yang menjalankannya.  Karena pengguna yang terhubung dari luar tidak tahu siapa yang bekerja di port ini, dan mereka hanya terhubung ke port 80. Jika saya ingin memasuki mesin ini dan memulai server web saya sendiri, maka saya hanya mentransfer semua lalu lintas server web ke mobil ini.  Ini mungkin bukan rencana yang sangat baik, tetapi itu adalah cara subsistem jaringan Unix mencegah pengguna acak dari mengontrol layanan yang dikenal berjalan pada nomor port rendah ini.  Itulah alasan pembatasan semacam itu. <br><br><img src="https://habrastorage.org/webt/ba/0o/qn/ba0oqn2qgabud4-_hmizsks086s.jpeg"><br><br>  Selain itu, dari sudut pandang membaca dan menulis data koneksi, jika Anda memiliki file deskriptor untuk soket tertentu, maka <b>Unix</b> akan memungkinkan Anda untuk membaca dan menulis data apa pun dalam <b>koneksi</b> <b>TCP</b> atau <b>uTP ini</b> .  Dalam mengirim paket <b>mentah</b> , <b>Unix</b> berperilaku seperti paranoid, sehingga tidak akan membiarkan Anda mengirim paket sewenang-wenang melalui jaringan.  Ini harus berada dalam konteks koneksi khusus, kecuali Anda memiliki <b>root -</b> hak dan Anda dapat melakukan apa pun yang Anda inginkan. <br><br>  Jadi, satu pertanyaan menarik yang bisa Anda tanyakan adalah dari mana semua <b>userid</b> ini berasal? <br><br>  Kita berbicara tentang proses memiliki <b>userid</b> atau <b>groupid</b> .  Ketika Anda meluncurkan <b>PS</b> di komputer Anda, Anda pasti akan melihat serangkaian proses dengan nilai <b>uid yang</b> berbeda.  Dari mana mereka berasal? <br><br>  Kami membutuhkan mekanisme untuk memuat semua nilai <b>userid</b> ini.  <b>Unix</b> memiliki beberapa panggilan sistem yang dirancang untuk ini.  Oleh karena itu, untuk mem-bootstrap nilai pengenal ini, ada fungsi yang disebut <b>setuid (uid)</b> , sehingga Anda dapat menetapkan nomor <b>uid</b> dari beberapa proses saat ini ke nilai ini.  Ini sebenarnya operasi berbahaya, seperti semua yang lain dalam tradisi <b>Unix</b> , karena Anda hanya dapat melakukan ini jika <b>uid</b> Anda <b>= 0</b> .  Bagaimanapun, seharusnya begitu. <br><br>  Jadi, jika Anda adalah pengguna dengan hak root dan memiliki <b>uid = 0</b> , maka Anda dapat memanggil <b>setuid (uid)</b> dan mengalihkan pengguna ke proses apa pun.  Ada beberapa panggilan sistem serupa lainnya untuk menginisialisasi <b>gid</b> terkait proses: ini adalah <b>setgid</b> dan <b>setgroups</b> .  Oleh karena itu, panggilan sistem ini memungkinkan Anda untuk mengonfigurasi hak istimewa proses. <br><br><img src="https://habrastorage.org/webt/qs/6m/bk/qs6mbkc520bn-n_vlpznivx1z0q.jpeg"><br><br>  Fakta bahwa proses Anda mendapatkan hak akses yang benar ketika Anda masuk ke mesin <b>Unix</b> tidak terjadi karena Anda memiliki <b>ID yang</b> sama dengan proses, karena sistem belum tahu siapa Anda.  Sebaliknya, di <b>Unix,</b> ada semacam prosedur masuk ketika <b>protokol SSH</b> secure shell memulai proses untuk siapa saja yang terhubung ke komputer dan mencoba untuk mengotentikasi pengguna. <br><br>  Jadi, pada awalnya proses login ini dimulai dengan <b>uid = 0</b> untuk pengguna dengan hak root, dan kemudian, ketika ia menerima nama pengguna dan kata sandi tertentu, ia memeriksanya di database akunnya sendiri.  Sebagai aturan, pada <b>Unix,</b> data ini disimpan dalam dua file: <b>/ etc / password</b> (karena alasan historis, kata sandi tidak lagi disimpan dalam file ini), dan dalam file <b>/ etc / shadow</b> , di mana kata sandi disimpan.  Namun, ada tabel di file <b>/ etc / password</b> yang menampilkan setiap nama pengguna dalam sistem sebagai nilai integer. <br><br>  Dengan demikian, nama pengguna Anda dipetakan ke integer tertentu di <b>file / etc / password ini</b> , dan kemudian proses login memeriksa apakah kata sandi Anda benar sesuai dengan file ini.  Jika ia menemukan integer <b>uid Anda</b> , maka ia mengatur fungsi <b>setuid</b> ke nilai <b>uid itu</b> dan memulai shell dengan perintah <b>exec (/ bin / sh)</b> .  Sekarang Anda dapat berinteraksi dengan shell, tetapi ia bekerja di bawah <b>uid</b> Anda, sehingga Anda tidak akan dapat menyebabkan kerusakan yang tidak disengaja pada mesin ini. <br><br><img src="https://habrastorage.org/webt/oa/vi/t8/oavit8bjjn_skjz8-n1k5dhc6co.jpeg"><br><br>  <b>Pemirsa: apakah</b> mungkin untuk memulai proses baru dengan <b>uid = 0</b> jika <b>uid</b> Anda tidak benar-benar 0? <br><br>  <b>Profesor:</b> jika Anda memiliki hak akses root, Anda dapat membatasi diri untuk <b>uid</b> lain, menurunkan otoritas Anda, tetapi dalam hal apa pun, Anda dapat membuat proses dengan hanya <b>uid yang</b> sama seperti milik Anda.  Tetapi hal itu terjadi karena berbagai alasan Anda ingin meningkatkan hak istimewa Anda.  Misalkan Anda perlu menginstal paket, yang Anda perlukan hak akses <b>root</b> . <br><br>  Ada dua cara untuk mengatur hak istimewa di <b>Unix</b> .  Satu yang telah kami sebutkan adalah deskriptor file.  Jadi jika Anda benar-benar ingin meningkatkan hak istimewa Anda, maka Anda dapat berbicara dengan seseorang yang bekerja di bawah hak root dan memintanya untuk membuka file ini untuk Anda.  Atau Anda perlu menginstal beberapa antarmuka baru, maka asisten ini membuka file untuk Anda dan mengembalikan deskriptor file kepada Anda menggunakan transfer <b>fd</b> .  Ini adalah salah satu cara untuk meningkatkan hak istimewa Anda, tetapi itu tidak nyaman karena dalam beberapa kasus ada proses yang berjalan dengan sejumlah besar hak istimewa.  Untuk ini, <b>Unix</b> memiliki mekanisme bermasalah yang cerdas namun sekaligus disebut <b>"setuid binaries"</b> .  Mekanisme ini adalah executable reguler pada <b>sistem</b> file <b>Unix</b> , kecuali ketika Anda menjalankan <b>exec</b> pada <b>setuid</b> binary, misalnya, <b>/ bin / su</b> pada sebagian besar mesin, atau <b>sudo</b> , saat startup. <br><br>  Sistem <b>Unix yang</b> khas memiliki banyak binari <b>setuid</b> .  Perbedaannya adalah bahwa ketika Anda menjalankan salah satu dari binari ini, itu benar-benar mengalihkan <b>userid dari</b> proses ke pemilik biner ini.  Mekanisme ini terasa aneh ketika Anda pertama kali melihatnya.  Sebagai aturan, cara untuk menggunakannya adalah bahwa "biner" ini kemungkinan besar memiliki pemilik <b>dari</b> 0, karena Anda benar-benar ingin mengembalikan banyak hak istimewa. <br><br><img src="https://habrastorage.org/webt/zt/s5/8d/zts58db83nchnbo1a6qqobpbpuw.jpeg"><br><br>  Anda ingin mengembalikan hak pengguna super sehingga Anda dapat menjalankan perintah <b>su</b> ini, dan kernel, ketika Anda menjalankan biner ini, akan mengalihkan proses <b>uid</b> ke 0, sehingga program ini sekarang akan melakukan beberapa hal istimewa. <br><br>  <b>Pemirsa:</b> jika Anda memiliki <b>uid = 0</b> dan Anda mengubah <b>uid dari</b> semua binari <b>setuid</b> ini ke sesuatu selain 0, dapatkah Anda mengembalikan hak istimewa Anda? <br><br>  <b>Profesor:</b> tidak, banyak proses tidak akan dapat mengembalikan hak istimewa ketika menurunkan tingkat akses, sehingga Anda mungkin terjebak di tempat ini.  Mekanisme ini tidak terikat dengan <b>uid = 0</b> .  Seperti halnya pengguna sistem <b>Unix</b> , Anda dapat membuat file biner apa pun, membangun program, mengompilasinya, dan mengatur bit <b>setuid</b> ini ke program itu sendiri.  Itu milik Anda, pengguna, ID pengguna Anda.  Dan itu berarti bahwa siapa pun yang menjalankan program Anda akan menjalankan kode ini dengan ID pengguna Anda.  Apakah ada masalah dengan ini?  Apa yang perlu dilakukan? <br><br>  <b>Hadirin:</b> yaitu, jika ada kesalahan dalam aplikasi Anda, bisakah seseorang melakukan sesuatu dengan itu, bertindak dengan hak istimewa Anda? <br><br>  <b>Profesor:</b> benar, itu terjadi jika aplikasi saya "buggy", atau jika itu memungkinkan Anda untuk menjalankan semua yang Anda inginkan.  Misalkan saya bisa menyalin shell sistem dan membuatnya <b>setuid</b> untuk saya, tetapi siapa pun dapat menjalankan shell ini di bawah akun saya.  Ini mungkin bukan rencana tindakan terbaik.  Tetapi mekanisme seperti itu tidak menimbulkan masalah, karena satu-satunya orang yang dapat mengatur bit <b>setuid</b> pada file biner adalah pemilik file ini.  Anda, sebagai pemilik file, memiliki hak istimewa <b>uid</b> , sehingga Anda dapat mentransfer akun Anda ke orang lain, tetapi orang lain ini tidak akan dapat membuat biner <b>setuid</b> dengan <b>userid</b> Anda. <br><br>  Bit setuid ini disimpan di sebelah bit izin ini, yaitu, di setiap <b>inode</b> ada juga bit <b>setuid</b> yang mengatakan apakah file yang dapat dieksekusi ini harus atau jika program beralih ke pemilik <b>uid</b> selama eksekusi. <br><br><img src="https://habrastorage.org/webt/4d/o0/cf/4do0cfauri7y6g94omunnrdyv14.jpeg"><br><br>  Ternyata ini adalah mekanisme yang sangat rumit ketika digunakan dengan benar, dan karenanya, kernel mengimplementasikan program dengan benar.  Sebenarnya, ini cukup mudah dilakukan, karena hanya satu pemeriksaan dilakukan: jika <b>setuid</b> ini ada, maka proses beralih ke <b>uid</b> .  Ini sangat sederhana. <br><br>  Tetapi menggunakannya dengan aman cukup sulit, karena, seperti yang baru saja ditunjukkan, jika program ini mengandung kesalahan atau melakukan sesuatu yang tidak terduga, maka Anda mendapatkan kemampuan untuk melakukan hal-hal yang sewenang-wenang di bawah <b>uid = 0</b> atau di bawah <b>uid</b> lainnya.  Di <b>Unix,</b> ketika Anda menjalankan program, Anda mewarisi banyak hal dari proses induk Anda. <br><br>  Misalnya, Anda bisa melewatkan variabel lingkungan ke <b>setuid</b> binari.  Faktanya adalah bahwa di <b>Unix</b> Anda dapat menentukan pustaka bersama yang digunakan untuk proses dengan menetapkan variabel lingkungan, dan binari <b>setuid</b> tidak peduli tentang pemfilteran variabel lingkungan ini. <br><br>  Misalnya, Anda dapat menjalankan <b>bin / su</b> , tetapi menggunakan pustaka bersama untuk fungsi <b>printf</b> , sehingga <b>printf</b> Anda akan mulai ketika <b>bin / su</b> mencetak sesuatu, dan Anda dapat menjalankan shell alih-alih mencetakf. <br><br>  Ada banyak seluk-beluk yang harus Anda pahami dengan benar tentang ketidakpercayaan program terhadap data yang dimasukkan pengguna.  Karena Anda biasanya mempercayai input pengguna, <b>setuid</b> tidak pernah menjadi bagian teraman dari keseluruhan sistem <b>Unix</b> .  Ada pertanyaan tentang ini? <br><br>  <b>Audiens:</b> apakah <b>setuid</b> juga berlaku untuk grup atau hanya untuk pengguna? <br><br>  <b>Profesor:</b> ada bit <b>setgid yang</b> simetris dengan bit <b>setuid</b> , yang bisa Anda atur juga.  Jika file tersebut memiliki <b>gid</b> tertentu dan bit <b>setgid</b> ini diatur saat program dimulai, maka Anda akan mendapatkannya. <br><br>  <b>Setgid</b> tidak digunakan secara khusus, tetapi dapat berguna dalam kasus di mana Anda ingin memberikan hak istimewa yang sangat spesifik.  Sebagai contoh, <b>bin / su</b> mungkin membutuhkan banyak hak istimewa, tetapi mungkin ada beberapa program yang memerlukan sedikit hak istimewa tambahan, misalnya, untuk menulis sesuatu ke file log khusus.  Oleh karena itu, Anda mungkin ingin memberinya grup tertentu dan membuat file log untuknya yang dapat ditulis oleh grup ini.  Jadi, bahkan jika program ini "kereta", maka Anda tidak akan kehilangan apa pun kecuali grup ini.  Ini berguna sebagai mekanisme yang karena alasan tertentu tidak digunakan terlalu sering, karena bagaimanapun, orang harus menggunakan hak root lebih banyak. <br><br>  <b>Hadirin:</b> Apakah ada batasan siapa yang dapat mengubah akses? <br><br>  <b>Profesor:</b> ya.  Implementasi <b>Unix yang</b> berbeda memiliki pemeriksaan yang berbeda untuk ini.  Aturan umum adalah bahwa hanya root yang dapat mengubah pemilik file, karena Anda tidak ingin membuat file yang akan menjadi milik orang lain, dan tentu saja Anda tidak ingin menyesuaikan file orang lain.  Jadi, jika <b>uid</b> Anda bukan 0, maka Anda mandek.  Anda tidak dapat mengubah kepemilikan file apa pun.  Jika <b>uid = 0</b> , Anda memiliki hak akses root dan Anda dapat mengubah pemiliknya menjadi siapa saja.  Ada beberapa komplikasi jika Anda memiliki <b>setuid</b> biner dan Anda beralih dari satu <b>uid</b> ke yang lain, ini cukup rumit, tetapi pada dasarnya Anda pada dasarnya tidak dapat mengubah pemilik file jika Anda tidak memiliki hak akses root. <br><br>  Secara umum, ini adalah sistem yang agak ketinggalan jaman.  Anda mungkin dapat membayangkan banyak cara untuk menyederhanakan proses yang dijelaskan di atas, tetapi pada kenyataannya, sebagian besar sistem yang canggih terlihat seperti ini karena mereka berkembang seiring waktu.  Tetapi Anda dapat dengan sempurna menggunakan mekanisme ini sebagai "kotak pasir". <br><br>  Ini hanya semacam prinsip dasar <b>Unix</b> , yang muncul di hampir setiap sistem operasi mirip Unix: <b>Mac OS X</b> , <b>Linux</b> , <b>FreeBSD</b> , <b>Solaris</b> , jika orang lain menggunakannya, dan seterusnya.  Tetapi masing-masing sistem ini memiliki mekanisme yang lebih canggih yang dapat Anda gunakan.  Misalnya, di <b>Linux</b> ada <b>set</b> "sandbox" <b>COMP</b> , <b>Mac OS X</b> menggunakan "sandbox" <b>Seatbelt</b> .  Minggu depan saya akan memberi Anda contoh kotak pasir yang tersedia di setiap sistem berbasis <b>Unix</b> . <br><br>  Jadi, salah satu mekanisme terakhir, yang akan kami pertimbangkan sebelum masuk ke <b>OKWS</b> , menjelaskan bagaimana Anda harus berurusan dengan binari <b>setuid</b> dan menunjukkan bagaimana Anda dapat melindungi diri dari lubang keamanan yang ada.  Masalahnya adalah bahwa Anda pasti akan memiliki beberapa binari <b>setuid</b> pada sistem Anda, seperti <b>/ bin / su</b> , atau <b>sudo</b> , atau sesuatu yang lain, dan kemungkinan program Anda akan memiliki kesalahan.  Karena itu, seseorang akan dapat menjalankan biner <b>setuid</b> dan prosesnya akan dapat memperoleh akses <b>root</b> , yang tidak ingin Anda izinkan. <br><br><img src="https://habrastorage.org/webt/gy/nt/aa/gyntaadl0kgyfcku6ncq8v334kg.jpeg"><br><br>  Mekanisme <b>Unix</b> , yang sering digunakan untuk mencegah pelaksanaan proses yang berpotensi berbahaya menggunakan <b>setuid</b> binari, adalah dengan menggunakan namespace sistem file untuk mengubahnya menggunakan panggilan sistem <b>chroot</b> , operasi mengubah direktori root.  <b>OKWS</b> , sebagai server web yang berspesialisasi dalam menciptakan layanan web yang cepat dan aman, menggunakan ini dengan cukup luas. <br><br><img src="https://habrastorage.org/webt/m3/x1/xr/m3x1xrg_tmht2b2l8rwd8kzzy7s.jpeg"><br><br>  Jadi, di <b>Unix,</b> Anda dapat menjalankan <b>chroot</b> di direktori tertentu, jadi mungkin Anda juga dapat menjalankan <b>chroot ("/ foo")</b> . <br><br>  Ada 2 penjelasan untuk apa <b>chroot</b> tidak.  Yang pertama hanya intuitif, artinya setelah menjalankan <b>chroot</b> , direktori root atau direktori yang terletak di belakang slash pada dasarnya setara dengan apa yang <b>digunakan</b> sebelum Anda memanggil <b>chroot</b> .  Sepertinya membatasi namespace di bawah <b>/ foo Anda</b> .  Karena itu, jika Anda memiliki file yang dulu bernama <b>/ foo / x</b> , maka setelah memanggil <b>chroot,</b> Anda bisa mendapatkan file ini hanya dengan membuka <b>/ x</b> .  Jadi batasi namespace Anda hanya untuk subdirektori.  Inilah versi intuitifnya. <br><br><img src="https://habrastorage.org/webt/2w/58/wf/2w58wflgecku62k-urraxwggxcc.jpeg"><br><br>  Tentu saja, dalam keamanan, itu bukan versi intuitif yang penting, tetapi apa sebenarnya yang dilakukan kernel dengan panggilan sistem ini?  Dan itu pada dasarnya melakukan dua hal.  Pertama, ia mengubah nilai slash ini, jadi kapan pun Anda mengakses atau ketika Anda memulai nama direktori dengan slash, kernel menyertakan file apa pun yang Anda sediakan dengan operasi <b>chroot</b> .  Dalam contoh kita, ini adalah file <b>/ foo</b> sebelum Anda memanggil <b>chroot</b> , yaitu, kita mendapatkan <b>/ = / foo</b> . <br><br><img src="https://habrastorage.org/webt/gn/yx/-t/gnyx-tksd5brn4avys0dhppaw6c.jpeg"><br><br>  Hal berikutnya yang akan coba dilakukan kernel adalah melindungi Anda agar tidak dapat "melarikan diri" dari <b>/</b> jika Anda melakukannya <b>/../</b> .  Karena pada <b>Unix,</b> saya dapat meminta Anda untuk memberi saya, misalnya, <b>/../etc/password</b> .  Jadi jika saya menambahkan baris ini seperti ini: <b>/foo/../etc/password</b> , itu tidak akan baik, karena saya bisa keluar <b>/ foo</b> dan melanjutkan untuk mendapatkan <b>/ etc / password</b> . <br><br>  Hal kedua yang dilakukan kernel dengan pemanggilan sistem <b>Unix</b> adalah ketika Anda memanggil <b>chroot</b> untuk proses khusus ini, ia mengubah cara <b>/../</b> dievaluasi dalam direktori ini.  Oleh karena itu, ia memodifikasi <b>/../</b> sehingga <b>/ foo</b> menunjuk ke dirinya sendiri.  Dengan demikian, ini tidak memungkinkan Anda untuk "melarikan diri", dan perubahan ini hanya berlaku untuk proses ini dan tidak mempengaruhi sisanya.  Gagasan apa yang Anda miliki tentang cara "melarikan diri" dari lingkungan <b>chroot</b> menggunakan cara penerapannya? <br><br>  Menariknya, kernel hanya memonitor satu direktori <b>chroot</b> , jadi Anda mungkin dapat melakukan operasi <b>chroot = (/ foo)</b> , tetapi Anda akan terjebak di tempat ini.  Jadi Anda ingin mendapatkan <b>/ etc / password</b> , tetapi bagaimana cara melakukannya?  Anda dapat membuka direktori root sekarang dengan mengetik <b>open (* / *)</b> .  Ini akan memberi Anda deskriptor file yang menggambarkan apa <b>/ foo</b> .  Kemudian Anda dapat memanggil <b>chroot</b> lagi dan menjalankan <b>chroot (`/ bar)</b> . <br><br><img src="https://habrastorage.org/webt/er/ce/o6/erceo6xadygvj95nuy8fj-zn1bi.jpeg"><br><br> ,    : <b>root</b>   <b>/foo</b> ,  <b>/foo/bar</b>   <b>/../</b>     <b>/foo / bar/..</b> <br><br><img src="https://habrastorage.org/webt/gi/vb/zy/givbzygict7u1xirzzwneycl3sw.jpeg"><br><br>  ,          <b>/foo</b> .            <b>fchdir (fd)</b>     <b>(*/*)</b> ,      <b>chdir (..)</b> . <br><br><img src="https://habrastorage.org/webt/lb/qz/mx/lbqzmxnz8308avfwfyaxxprq7d8.jpeg"><br><br><img src="https://habrastorage.org/webt/gu/cn/kd/gucnkdez6q9ntda3zwtotnc4igg.jpeg"><br><br>       <b>/foo</b> ,     <b>/../</b> .     <b>/foo</b>        ,       <b>root</b> ,       . <br><br> ,    ,       .       .   <b>Unix</b>    root-   <b>chroot</b> ,  <b>chroot</b>     .  ,  <b>Unix</b>    <b>uid = 0</b>  ,      <b>chroot</b> .   .           ,         ,    <b>chroot</b> ,   <b>userid</b>   .   ,     <b>Unix</b> ,     ,    <b>root</b> ,    . <br><br>       ,  , ,     .      <b>chroot</b>       â€”      .    . <br><br> <b>:</b>  ,       <b>inod</b> ,      ? <br><br> <b>:</b>    !              ,  , , : Â«   <b>inode</b>  23Â»,      -        <b>hroot</b> .  ,  <b>Unix</b>     <b>inode</b>   <b>inode</b> ,  , ,   root-. <br><br>  ,      ,  ,   <b>OKWS</b> .  ,      <b>OKWS</b> . <br><br>  ,     -,   ,      -  ,      .          , , <b>httpd</b> , ,  <b>Apache</b> . <br><br>        <b>userid</b>   <b>www</b>  <b>/etc/password</b> .     ,   ,     <b>SSL</b> ,      <b>PHP</b>   ,        .   ,       , , <b>MySQL</b> ,           .    <b>MySQL</b>     .      <b>MySQL</b> , , ,      . <br><br><img src="https://habrastorage.org/webt/sx/tx/gd/sxtxgdpf7q9jr3q_tfxyzi6zgdc.jpeg"><br><br> ,  ,    ,    <b>MySQL</b>    ,        ,             . <br><br>         ,       ,  ,         ,   .    ,      , ,     <b>Apache</b> ,   <b>SSL</b> , ,  ,       <b>PHP</b> .    , ,    ,     . <br><br> 52:30  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus MIT "Keamanan Sistem Komputer".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 4: Â« Â»,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dNl22h1kW1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   .</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418197/">https://habr.com/ru/post/id418197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418187/index.html">Di Amerika, mereka menyarankan untuk mengganti semua perpustakaan dengan hub Amazon. Publik marah</a></li>
<li><a href="../id418189/index.html">Pewaris Zeus: mengapa Trojan IcedID berbahaya bagi nasabah bank</a></li>
<li><a href="../id418191/index.html">Analog dengan Python dan JavaScript. Bagian tiga</a></li>
<li><a href="../id418193/index.html">Bagaimana rasanya membuat game untuk Game Boy pada tahun 2017</a></li>
<li><a href="../id418195/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 4: â€œBerbagi Hak Istimewa,â€ Bagian 1</a></li>
<li><a href="../id418199/index.html">Cara membuat tugas teknis yang sederhana dan tidak kehilangan uang dan saraf</a></li>
<li><a href="../id418201/index.html">Bisakah kita menghidupkan kembali Perburuan Bebek?</a></li>
<li><a href="../id418203/index.html">GraphQL API (CRUD) on Go</a></li>
<li><a href="../id418205/index.html">Bahasa Space, Vol. 2: Selamat Datang, GJ273b</a></li>
<li><a href="../id418207/index.html">Ulasan laptop gaming ASUS ROG Strix GL504GS SCAR II dan ASUS ROG Strix GL504GM HERO II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>