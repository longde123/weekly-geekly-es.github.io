<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèº üîé üë®‚Äç‚úàÔ∏è Interrompe dispositivos externos em um sistema x86. Parte 3. Configurando o roteamento de interrup√ß√£o no chipset usando o exemplo coreboot üöò ‚õπüèø üë©üèæ‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos a considerar a configura√ß√£o de interrup√ß√µes de dispositivos externos no sistema x86. 
 Na parte 1 (A evolu√ß√£o dos controladores de interru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interrompe dispositivos externos em um sistema x86. Parte 3. Configurando o roteamento de interrup√ß√£o no chipset usando o exemplo coreboot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440304/"> Continuamos a considerar a configura√ß√£o de interrup√ß√µes de dispositivos externos no sistema x86. <br>  Na parte 1 (A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">evolu√ß√£o dos controladores de interrup√ß√£o</a> ), examinamos os fundamentos te√≥ricos dos controladores de interrup√ß√£o e termos gerais; na parte 2 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">op√ß√µes de inicializa√ß√£o do kernel do Linux</a> ), vimos como o sistema operacional faz uma escolha entre controladores na pr√°tica.  Nesta parte, veremos como o BIOS configura o roteamento IRQ para controladores de interrup√ß√£o no chipset. <br><br>  Nenhuma empresa moderna de desenvolvimento de BIOS (AwardBIOS / AMIBIOS / Insyde) divulga o c√≥digo fonte de seus programas.  Felizmente, por√©m, existe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coreboot</a> , um projeto para substituir o BIOS propriet√°rio por software livre.  Em seu c√≥digo, veremos como o roteamento de interrup√ß√£o no chipset est√° configurado. <br><br><img src="https://habrastorage.org/webt/mx/vi/wu/mxviwuisp5rglec_kgsk872hmy8.png"><br><br><a name="habracut"></a><br><h2>  Teoria </h2><br>  Primeiro, atualize e complemente nosso conhecimento te√≥rico.  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1,</a> identificamos um caminho de interrup√ß√£o comum para o caso de PIC e APIC. <br><br>  <b>Pic:</b> <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>APIC:</b> <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  Nestas figuras, o mapeamento do dispositivo PCI ‚Üí PIR √© mostrado abstratamente; na verdade, √© um pouco mais complicado.  Na realidade, cada dispositivo PCI possui 4 linhas de interrup√ß√£o (INTA #, INTB #, INTC #, INTD #).  Cada dispositivo PCI pode ter at√© 8 fun√ß√µes e cada fun√ß√£o j√° possui uma interrup√ß√£o INTx #.  A linha de INTx # que cada fun√ß√£o do dispositivo puxar√° √© fixa no hardware ou √© determinada pela configura√ß√£o do dispositivo. <br><br><img src="https://habrastorage.org/webt/dk/ny/gh/dknyghwfo8gktn5l_lmmqb5awz0.png"><br><br>  Em ess√™ncia, fun√ß√µes s√£o blocos l√≥gicos separados.  Por exemplo, em um dispositivo PCI, pode haver uma fun√ß√£o de controlador Smbus, uma fun√ß√£o de controlador SATA, uma fun√ß√£o de ponte LPC.  No lado do SO, cada fun√ß√£o √© um dispositivo separado com seu pr√≥prio espa√ßo de configura√ß√£o PCI Config. <br><br>  No caso mais simples (e mais comum) de um dispositivo PCI, existe apenas uma fun√ß√£o, cuja interrup√ß√£o ocorre atrav√©s da linha INTA #.  Mas, em geral, o dispositivo pode at√© ter mais de 4 fun√ß√µes (como dissemos antes das 8), ent√£o algumas delas ter√£o que ser plantadas em uma linha INTx # (as interrup√ß√µes do PCI podem dividir a linha).  Al√©m disso, para dispositivos PCI inclu√≠dos no chipset gravando em registros especiais, geralmente √© poss√≠vel indicar quais fun√ß√µes usam quais linhas INTx # (e se elas s√£o usadas). <br><br>  Sistematizando nosso conhecimento, denotamos o caminho (roteamento) de interrup√ß√µes de qualquer fun√ß√£o PCI atrav√©s de INTx # ‚Üí PIRQy ‚Üí IRQz, onde: <br><br><ul><li>  INTx # - linha INT # (INTA #, INTB #, INTC #, INTD #) do dispositivo PCI que a fun√ß√£o usar√° </li><li>  PIRQy - a linha PIRQ (PIRQA, PIRQB, ...) do PIR ao qual a linha INTx # est√° conectada </li><li>  IRQz - linha IRQ (0, 1, 2, ...) no controlador de interrup√ß√£o (APIC / PIC), que est√° conectado √† linha PIRQy </li></ul><br><h3>  Por que voc√™ n√£o pode simplesmente se conectar em qualquer lugar INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, ...? </h3><br>  Por que se preocupar em configurar o roteamento?  Suponha que decidamos n√£o incomodar e obter todas as linhas de interrup√ß√£o de todos os dispositivos PCI para as mesmas linhas PIRQ.  Vamos dizer o seguinte: <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  N¬∫ INTC ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br>  Como dissemos acima, o caso mais comum √© quando um dispositivo PCI tem uma fun√ß√£o e sua interrup√ß√£o √© conectada √† linha INTA # (porque por que o desenvolvedor do dispositivo deve inici√°-lo de maneira diferente?).  Portanto, se de repente decidirmos iniciar todas as linhas como escrevemos, quase todas as interrup√ß√µes dos dispositivos ser√£o divididas em linhas PIRQA.  Digamos que ela acabou no IRQ16.  Ent√£o, toda vez que o processador for informado de que ocorreu uma interrup√ß√£o na linha IRQ16, ele dever√° interrogar os drivers de todos os dispositivos conectados √† linha IRQ16 (PIRQA) se eles t√™m uma interrup√ß√£o.  Se houver muitos desses dispositivos, isso naturalmente n√£o acelerar√° a resposta do sistema √† interrup√ß√£o.  E as linhas PIRQB-PIRQD nesse caso ficar√£o inativas na maior parte do tempo.  Para maior clareza, a figura que ilustra o problema: <br><br><img src="https://habrastorage.org/webt/cz/dv/bf/czdvbfsnymw5xyyqujavawdcv_m.png"><br><br>  Mas tudo poderia ser feito assim: <br><br><img src="https://habrastorage.org/webt/dk/3e/x6/dk3ex67xjmm_9h0q3miq2djqnti.png"><br><br>  A imagem √© um pouco confusa, mas o ponto √© que simplesmente conectamos as linhas INTx # com PIRQy ao round-robin (PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD. ..) <br><br>  Note-se que aqui √© necess√°rio levar em considera√ß√£o n√£o apenas o mesmo n√∫mero de fun√ß√µes PCI em cada linha PIRQ.  Afinal, algumas fun√ß√µes podem criar interrup√ß√µes muito raramente e outras permanentemente (controlador Ethernet, por exemplo).  Nesse caso, mesmo a aloca√ß√£o de uma linha PIRQ separada para interrup√ß√µes com essa fun√ß√£o pode ser bastante justificada. <br><br>  Com base no exposto, o desenvolvedor do BIOS, entre outras coisas, tem a tarefa de garantir que as linhas PIRQ sejam carregadas uniformemente com interrup√ß√µes. <br><br><h3>  O que o BIOS deve fazer? </h3><br>  N√≥s sistematizamos na figura: <br><br><img src="https://habrastorage.org/webt/pm/rq/xg/pmrqxgkdu0nkjz6yb44vdn79a8q.png"><br><br><ul><li>  <b>1) Indique qual linha do INTx # cada fun√ß√£o dos dispositivos PCI extrai</b> <br>  Para dispositivos PCI externos, esse item n√£o √© executado, mas pode ser que, para as fun√ß√µes dos dispositivos PCI inclu√≠dos no chipset. </li><li>  <b>2) Configure o mapeamento INTx # ‚Üí PIRQy para cada dispositivo PCI</b> <br>  Vale a pena notar que pode haver mais de quatro sinais PIRQy padr√£o (PIRQA, PIRQB, PIRQC, PIRQD).  Por exemplo 8: PIRQA-PIRQH. </li></ul><br>  Os sinais PIRQy v√£o na linha IRQz do controlador de interrup√ß√£o selecionado (APIC / PIC).  Como queremos oferecer suporte a todos os m√©todos de carregamento poss√≠veis (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte 2</a> ), precisamos preencher os dois mapeamentos: <br><br><ul><li>  <b>3a) Preencha o mapeamento PIRQy ‚Üí IRQz1 para comunica√ß√£o PIR ‚Üí I / O APIC</b> <br>  Mas geralmente isso n√£o √© necess√°rio, pois as linhas PIRQy s√£o fixadas na linha APIC.  A solu√ß√£o comum √© PIRQA ‚Üí IRQ16, PIRQB ‚Üí IRQ17, ... A solu√ß√£o mais simples, porque  Ao colocar as linhas PIRQy nas linhas do controlador ‚â•16, voc√™ n√£o precisa se preocupar com conflitos com interrup√ß√µes insepar√°veis ‚Äã‚Äãdos dispositivos ISA. </li><li>  <b>3b) Preencha o mapeamento PIRQy ‚Üí IRQz2 para comunica√ß√£o PIR ‚Üí PIC</b> <br>  Isso deve ser fornecido caso usemos roteamento atrav√©s do controlador PIC.  N√£o existe uma solu√ß√£o inequ√≠voca como no caso da APIC, porque no caso da PIC, deve-se lembrar da possibilidade de conflitos com interrup√ß√µes insepar√°veis ‚Äã‚Äãdos dispositivos ISA. </li></ul><br>  O √∫ltimo quarto item √© necess√°rio para ajudar o sistema operacional a determinar o roteamento de interrup√ß√£o.  O pr√≥prio dispositivo geralmente n√£o usa esses registros. <br><br><ul><li>  <b>4) Preencha os registros Linha de interrup√ß√£o / Pin de interrup√ß√£o para cada fun√ß√£o PCI</b> <br>  Em geral, o registro de pino de interrup√ß√£o √© preenchido automaticamente e geralmente √© somente leitura, portanto, o preenchimento provavelmente s√≥ exigir√° o preenchimento do registro de linha de interrup√ß√£o.  Isso deve ser fornecido caso usemos o roteamento atrav√©s do controlador PIC sem fornecer ao sistema operacional nenhuma tabela sobre interrup√ß√µes de roteamento (consulte novamente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte 2</a> ).  Se forem fornecidas tabelas e esse mapeamento for consistente com as tabelas de roteamento ($ PIR / ACPI), o sistema operacional geralmente o deixa. </li></ul><br>  Deve-se observar que ainda n√£o tocamos nas tabelas $ PIR / MPtable / ACPI e consideramos como configurar os registros do chipset em termos de interrup√ß√µes de roteamento antes de transferir o controle para o carregador do sistema.  As tabelas de interrup√ß√£o s√£o um t√≥pico para um artigo separado (possivelmente um futuro). <br><br>  Ent√£o, os fundamentos te√≥ricos s√£o estudados, finalmente come√ßamos a praticar! <br><br><h2>  Pr√°tica </h2><br>  Como exemplo de artigos desta s√©rie, uso uma placa personalizada com um processador Intel Haswell i7 e um chipset LynxPoint-LP.  Neste f√≥rum, lancei o coreboot em conjunto com o SeaBIOS.  O Coreboot fornece inicializa√ß√£o espec√≠fica do hardware e a carga √∫til do SeaBIOS fornece uma interface do BIOS para sistemas operacionais.  Neste artigo, n√£o descreverei o processo de configura√ß√£o do coreboot, mas apenas tentarei mostrar com um exemplo que tipo de configura√ß√µes de BIOS devem ser feitas no chipset para rotear interrup√ß√µes de IRQ de dispositivos externos. <br><br>  Como o projeto coreboot est√° desenvolvendo ativamente para que o artigo esteja sempre atualizado, consideraremos o c√≥digo usando o exemplo da vers√£o fixa mais recente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.9</a> (release 2018-12-20). <br><br>  A placa-m√£e mais pr√≥xima da minha √© o Google Beltino com varia√ß√£o da Panther.  A pasta principal desta placa-m√£e √© a pasta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"src \ mainboard \ google \ beltino"</a> .  Todas as configura√ß√µes est√£o concentradas aqui e o c√≥digo espec√≠fico para esta placa. <br><br>  Ent√£o, vamos come√ßar a resolver onde os itens acima est√£o configurados: <br><br><h4>  1) Indique qual linha do INTx # cada fun√ß√£o dos dispositivos PCI extrai </h4><br>  Esta informa√ß√£o √© definida no arquivo <a href="">‚Äúsrc / mainboard / google / beltino / romstage.c‚Äù</a> na estrutura rcba_config atrav√©s dos registros DxxIP (Device xx Interrupt Pin Register (IP)).  Este registro indica qual pino INTx # (A / B / C / D) cada uma das fun√ß√µes do dispositivo emite uma interrup√ß√£o. <br><br>  Op√ß√µes poss√≠veis (consulte o arquivo <a href="">"src / southbridge / intel / lynxpoint / pch.h"</a> ): <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>h = No interrupt <span class="hljs-number"><span class="hljs-number">1</span></span>h = INTA# <span class="hljs-number"><span class="hljs-number">2</span></span>h = INTB# <span class="hljs-number"><span class="hljs-number">3</span></span>h = INTC# <span class="hljs-number"><span class="hljs-number">4</span></span>h = INTD#</code> </pre> <br>  Sup√µe-se que v√°rias fun√ß√µes usem o mesmo pino. <br><br>  Sup√µe-se que as fun√ß√µes n√£o possam usar o pino para interrup√ß√µes (sem interrup√ß√£o). <br>  Tudo como vimos na figura no in√≠cio do artigo. <br><br>  O c√≥digo completo √© respons√°vel pelo item designado por n√≥s: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt pin register (board specific) */</span></span> RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)), RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)), RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTB &lt;&lt; D28IP_P4IP)), RCBA_SET_REG_32(D27IP, (INTA &lt;&lt; D27IP_ZIP)), RCBA_SET_REG_32(D26IP, (INTA &lt;&lt; D26IP_E2P)), RCBA_SET_REG_32(D22IP, (NOINT &lt;&lt; D22IP_MEI1IP)), RCBA_SET_REG_32(D20IP, (INTA &lt;&lt; D20IP_XHCI)),</code> </pre> <br>  Para uma melhor compreens√£o, considere alguns exemplos: <br><br>  <b>Exemplo 1:</b> <br><br>  O dispositivo 0x1d (29 em decimal) tem uma fun√ß√£o (controlador EHCI). <br><br>  Nesse caso, atribua uma interrup√ß√£o ao INTA #. <br><br>  00: 1d.0 - INTA # <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)),</code> </pre> <br>  <b>Exemplo 2:</b> <br>  O dispositivo 0x1f (31 em decimal) possui as fun√ß√µes Controlador de sensor t√©rmico (00: 1f.6), Controlador SATA 2 (00: 1f.2), Controlador SMBus (00: 1f.3), Controlador SATA 1 (00: 1f .2).  Queremos usar apenas os controladores SMBus, SATA 1 e Thermal Sensor. <br><br>  00: 1f.2 - INTA # (controlador SATA 1) <br>  00: 1f.3 - INTB # (controlador SMBus) <br>  00: 1f.2 - Sem interrup√ß√£o (o controlador SATA 2 n√£o √© usado) <br>  00: 1f.6 - INTC # (controlador do sensor t√©rmico) <br><br>  Para esta configura√ß√£o, voc√™ deve escrever: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)),</code> </pre> <br>  <b>Exemplo 3:</b> <br><br>  Em um dispositivo, o n√∫mero de fun√ß√µes necess√°rias √© maior que 4. No dispositivo 0x1c, cada fun√ß√£o √© respons√°vel pela porta PCI Express.  Para que as portas 0-5 funcionem e as interrup√ß√µes sejam distribu√≠das igualmente entre as linhas, voc√™ pode configurar isso: <br><br>  00: 1c.0 - INTA # (porta PCI Express 0) <br>  00.1c.1 - INTB # (porta PCI Express 1) <br>  00.1c.2 - N¬∫ INTC (porta 2 do PCI Express) <br>  00.1c.3 - INTD # (porta PCI Express 3) <br>  00.1c.4 - INTA # (porta PCI Express 4) <br>  00.1c.5 - INTB # (porta PCI Express 5) <br>  00.1c.6 - Sem interrup√ß√£o (porta n√£o usada) <br>  00.1c.7 - Sem interrup√ß√£o (porta n√£o usada) <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTB &lt;&lt; D28IP_P2IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTD &lt;&lt; D28IP_P4IP) | (INTA &lt;&lt; D28IP_P5IP) | (INTB &lt;&lt; D28IP_P6IP) | (NOINT &lt;&lt; D28IP_P7IP) | (NOINT &lt;&lt; D28IP_P8IP)),</code> </pre> <br><h4>  2) Configure o mapeamento INTx # ‚Üí PIRQy para cada dispositivo PCI </h4><br>  Esta informa√ß√£o tamb√©m √© definida no arquivo <a href="">"src \ mainboard \ google \ beltino \ romstage.c"</a> <br>  na estrutura rcba_config, mas j√° atrav√©s dos registros DxxIR (Device xx Interrupt Route Register). <br><br>  As informa√ß√µes neste registro mostram a qual linha PIRQx (A / B / C / D / E / F / G / H) cada linha de interrup√ß√£o INTx # est√° conectada. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt route registers */</span></span> RCBA_SET_REG_32(D31IR, DIR_ROUTE(PIRQG, PIRQC, PIRQB, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* LPC */</span></span> RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* EHCI */</span></span> RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* PCIE */</span></span> RCBA_SET_REG_32(D27IR, DIR_ROUTE(PIRQG, PIRQG, PIRQG, PIRQG)),<span class="hljs-comment"><span class="hljs-comment">/* HDA */</span></span> RCBA_SET_REG_32(D22IR, DIR_ROUTE(PIRQA, PIRQA, PIRQA, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* ME */</span></span> RCBA_SET_REG_32(D21IR, DIR_ROUTE(PIRQE, PIRQF, PIRQF, PIRQF)),<span class="hljs-comment"><span class="hljs-comment">/* SIO */</span></span> RCBA_SET_REG_32(D20IR, DIR_ROUTE(PIRQC, PIRQC, PIRQC, PIRQC)),<span class="hljs-comment"><span class="hljs-comment">/* XHCI */</span></span> RCBA_SET_REG_32(D23IR, DIR_ROUTE(PIRQH, PIRQH, PIRQH, PIRQH)),<span class="hljs-comment"><span class="hljs-comment">/* SDIO */</span></span></code> </pre> <br>  <b>Exemplo 1:</b> <br><br>  O dispositivo 0x1c (28 no sistema decimal) s√£o as portas PCIe, como j√° descobrimos. <br><br>  Estabelecemos uma conex√£o "direta": <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  N¬∫ INTC ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD))</code> </pre> <br>  <b>Exemplo 2:</b> <br><br>  Dispositivo 0x1d (29 em decimal) - uma fun√ß√£o (controlador EHCI) no INTA #, outras linhas n√£o s√£o usadas. <br><br>  Conecte a linha INTA # ao PIRQD: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD))</code> </pre> <br>  Nesse caso, apenas o primeiro registro PIRQD (para INTA #) faz sentido, o restante n√£o faz sentido. <br><br><h4>  3a) Preencha o mapeamento PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) </h4><br>  Como j√° dissemos, o mapeamento geralmente √© corrigido aqui, e este caso n√£o √© uma exce√ß√£o. <br><br><ul><li>  PIRQA ‚Üí IRQ16 </li><li>  PIRQB ‚Üí IRQ17 </li><li>  ... </li><li>  PIRQH ‚Üí IRQ23 </li></ul><br><h4>  3b) Preencha o mapeamento PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC) </h4><br>  No coreboot, o conte√∫do para preencher esses registros √© definido no arquivo <a href="">devicetree.cb</a> na pasta da placa-m√£e "src \ mainboard \ google \ beltino \". <br><br>  devicetree.cb (o nome devicetree para comunica√ß√£o com um conceito semelhante no kernel Linux e ‚Äúcb‚Äù √© a abrevia√ß√£o de coreboot) √© um arquivo especial que reflete a configura√ß√£o desta placa-m√£e: qual processador, chipset √© usado, quais dispositivos est√£o inclu√≠dos neles, quais desligado etc.  Al√©m disso, informa√ß√µes especiais para a configura√ß√£o do chipset podem ser especificadas neste arquivo.  Este √© apenas o caso que precisamos: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span></code> </pre> <br>  Essas linhas especificam o mapeamento PIRQy ‚Üí IRQz2.  No c√≥digo, depois de analisar o arquivo devicetree.cb, eles s√£o transformados nas vari√°veis ‚Äã‚Äã"config-&gt; pirqX_routing". <br><br>  A vari√°vel "config-&gt; pirqa_routing = 0x8b" significa que o PIRQA est√° conectado √† linha de interrup√ß√£o IRIC11 (0x0b = 11) do controlador PIC, no entanto, o bit mais alto (que √© 0x80) significa que o roteamento de interrup√ß√£o n√£o √© executado.  Honestamente, na minha experi√™ncia, isso √© um erro; por padr√£o, vale a pena ativar o roteamento PIC, o pr√≥prio sistema operacional poder√° mudar para o I / O APIC definindo esse bit como 1, se necess√°rio. <br><br>  Ou seja, nesse caso, seria mais correto escrever: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> <span class="hljs-comment"><span class="hljs-comment"># not used register "pirqf_routing" = "0x80" # not used register "pirqg_routing" = "0x80" # not used register "pirqh_routing" = "0x80" # not used</span></span></code> </pre><br>  N√£o ativamos as √∫ltimas 4 interrup√ß√µes, porque  A interrup√ß√£o do IRQ0 √© sempre usada no timer do sistema e est√° claramente indispon√≠vel (consulte Informa√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerais sobre interrup√ß√µes compat√≠veis com IBM-PC</a> ). <br><br>  Mas se olharmos mais de perto o ponto 2), veremos que alguns dispositivos PCI usam as linhas PIRQE-PIRQH, portanto, deix√°-los desconectados √© o caminho certo para os dispositivos quebrados. <br><br>  Portanto, √© melhor escrever algo como isto: <br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x03"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x04"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x05"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x06"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0e"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0f"</span></span></code> </pre> <br><br>  O preenchimento real dos registros correspondentes ocorre no arquivo <a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c</a> na fun√ß√£o pch_pirq_init. <br><br>  Snippet de c√≥digo respons√°vel pelo preenchimento do registro: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Get the chip configuration */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">config_t</span></span> *config = dev-&gt;chip_info; pci_write_config8(dev, PIRQA_ROUT, config-&gt;pirqa_routing); pci_write_config8(dev, PIRQB_ROUT, config-&gt;pirqb_routing); pci_write_config8(dev, PIRQC_ROUT, config-&gt;pirqc_routing); pci_write_config8(dev, PIRQD_ROUT, config-&gt;pirqd_routing); pci_write_config8(dev, PIRQE_ROUT, config-&gt;pirqe_routing); pci_write_config8(dev, PIRQF_ROUT, config-&gt;pirqf_routing); pci_write_config8(dev, PIRQG_ROUT, config-&gt;pirqg_routing); pci_write_config8(dev, PIRQH_ROUT, config-&gt;pirqh_routing);</code> </pre> <br>  As constantes de endere√ßo de registro s√£o descritas no mesmo arquivo <a href="">pch.h</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQA_ROUT 0x60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQB_ROUT 0x61 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQC_ROUT 0x62 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQD_ROUT 0x63 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQE_ROUT 0x68 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQF_ROUT 0x69 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQG_ROUT 0x6A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQH_ROUT 0x6B</span></span></code> </pre> <br>  O mapeamento de PIRQy ‚Üí IRQz2 para este chipset √© gravado no dispositivo LPC PCI (endere√ßo 00: 1f.0) nos registros PIRQy_ROUT.  Deve-se notar que geralmente nem todas as 15 linhas IRQz2 por PIC s√£o permitidas para uso, mas apenas uma parte (por exemplo, 3,4,5,6,7,9,10,11,12,14,15).  A descri√ß√£o desses registros deve conter informa√ß√µes sobre quais IRQs est√£o dispon√≠veis para atribuir interrup√ß√µes das linhas PIRQ a eles.  Portanto, o mapeamento proposto por n√≥s acima s√≥ √© poss√≠vel se a atribui√ß√£o de PIRQ na linha IRQ3, IRQ4, IRQ5, IRQ6, IRQ6, IRQ10, IRQ11, IRQ14, IRQ15 estiver dispon√≠vel.  Mas se observarmos cuidadosamente o coment√°rio antes da fun√ß√£o pch_pirq_init, veremos que √©: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PIRQ[n]_ROUT[3:0] - PIRQ Routing Control * 0x00 - 0000 = Reserved * 0x01 - 0001 = Reserved * 0x02 - 0010 = Reserved * 0x03 - 0011 = IRQ3 * 0x04 - 0100 = IRQ4 * 0x05 - 0101 = IRQ5 * 0x06 - 0110 = IRQ6 * 0x07 - 0111 = IRQ7 * 0x08 - 1000 = Reserved * 0x09 - 1001 = IRQ9 * 0x0A - 1010 = IRQ10 * 0x0B - 1011 = IRQ11 * 0x0C - 1100 = IRQ12 * 0x0D - 1101 = Reserved * 0x0E - 1110 = IRQ14 * 0x0F - 1111 = IRQ15 * PIRQ[n]_ROUT[7] - PIRQ Routing Control * 0x80 - The PIRQ is not routed. */</span></span></code> </pre> <br><h4>  4) Preencha os registros Linha de interrup√ß√£o / Pin de interrup√ß√£o para cada fun√ß√£o PCI </h4><br>  No espa√ßo de configura√ß√£o do PCI (cada PCI possui fun√ß√µes de acordo com o padr√£o), existem 2 registros de interesse para n√≥s: <br><br><ul><li>  3Ch: Linha de interrup√ß√£o - aqui voc√™ precisa escrever o n√∫mero IRQz2 (um n√∫mero de 0 a 15), o n√∫mero de interrup√ß√£o que a fun√ß√£o eventualmente puxa ao usar o controlador PIC </li><li>  3Dh: Pin de interrup√ß√£o - mostra qual linha INTx # (A / B / C / D) a fun√ß√£o usa </li></ul><br>  Vamos come√ßar com o √∫ltimo.  O registro do pino de interrup√ß√£o ser√° preenchido automaticamente com base nas configura√ß√µes do chipset (registros DxxIP) feitas por n√≥s no par√°grafo 1 e ser√° somente leitura. <br><br>  Portanto, tudo o que resta √© preencher o registro da linha de interrup√ß√£o com uma interrup√ß√£o IRQz2 para cada fun√ß√£o PCI. <br><br>  Conhecendo o mapeamento PIRQy ‚Üí IRQz2 (item 3b) e o mapeamento INTx # ‚Üí PIRQy (item 2), √© poss√≠vel preencher facilmente o registro da Linha de Interrup√ß√£o para cada fun√ß√£o, sabendo qual INTx # interrompe (item 1). <br><br>  No coreboot, os registros da linha de interrup√ß√£o tamb√©m s√£o preenchidos no <a href="">arquivo src \ southbridge \ intel \ lynxpoint \ lpc.c</a> na fun√ß√£o pch_pirq_init: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Eric Biederman once said we should let the OS do this. * I am not so sure anymore he was right. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (irq_dev = all_devices; irq_dev; irq_dev = irq_dev-&gt;next) { u8 int_pin=<span class="hljs-number"><span class="hljs-number">0</span></span>, int_line=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_dev-&gt;enabled || irq_dev-&gt;path.type != DEVICE_PATH_PCI) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; int_pin = pci_read_config8(irq_dev, PCI_INTERRUPT_PIN); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (int_pin) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTA# */</span></span> int_line = config-&gt;pirqa_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTB# */</span></span> int_line = config-&gt;pirqb_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTC# */</span></span> int_line = config-&gt;pirqc_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTD# */</span></span> int_line = config-&gt;pirqd_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!int_line) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pci_write_config8(irq_dev, PCI_INTERRUPT_LINE, int_line); }</code> </pre> <br>  Por alguma raz√£o, esse c√≥digo implica que o mapeamento √©, de qualquer forma, INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, INTC # ‚Üí PIRQC, INTD # ‚Üí PIRQD.  Embora na pr√°tica vimos que pode ser diferente (ver par√°grafo 2). <br><br>  Geralmente "Eric Biederman disse uma vez", e n√≥s o copiamos em qualquer lugar: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"Eric Biederman once said"</span></span> -r src/ src/southbridge/intel/fsp_bd82x6x/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801gx/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801ix/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/lynxpoint/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/sch/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this.</code> </pre> <br>  Em geral, o coreboot realmente n√£o se importa com o suporte a interrup√ß√µes herdadas.  Tanta coisa para se surpreender com esse erro n√£o vale a pena.  Ao carregar um sistema operacional moderno, isso n√£o vai incomod√°-lo, mas se voc√™ precisar carregar repentinamente o Linux com as op√ß√µes ‚Äúacpi = off nolapic‚Äù, isso dificilmente ser√° poss√≠vel. <br><br><h2>  Conclus√£o </h2><br>  Em conclus√£o, repetiremos as informa√ß√µes t√≠picas que precisam ser configuradas no chipset para rotear interrup√ß√µes PCI: <br><br><ol><li>  Indique qual linha INTx # cada fun√ß√£o PCI puxa </li><li>  Configure o mapeamento INTx # ‚Üí PIRQy para cada dispositivo PCI </li><li>  Mapeamento de preenchimento PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) e mapeamento PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC) </li><li>  Preencha os registros Linha de interrup√ß√£o / Pin de interrup√ß√£o do espa√ßo de configura√ß√£o do PCI para cada fun√ß√£o do PCI. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440304/">https://habr.com/ru/post/pt440304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440294/index.html">Roteador MIDI no Raspberry Pi</a></li>
<li><a href="../pt440296/index.html">6 Aplica√ß√µes para a Internet das coisas industrial</a></li>
<li><a href="../pt440298/index.html">Aplicativo do dia dos namorados no Libgdx</a></li>
<li><a href="../pt440300/index.html">10 comandos do console para ajudar a debater o c√≥digo JavaScript como um PRO</a></li>
<li><a href="../pt440302/index.html">CRM - custo de sucesso, custo de erro, custo de propriedade</a></li>
<li><a href="../pt440306/index.html">Escala de banco de dados em sistemas altamente carregados</a></li>
<li><a href="../pt440308/index.html">Divida e conquiste ou escreva devagar - leia rapidamente</a></li>
<li><a href="../pt440310/index.html">Como ensinar uma m√°quina a entender faturas e extrair dados delas</a></li>
<li><a href="../pt440312/index.html">Hackquest 2018. Resultados e revis√µes. Dia 4-7</a></li>
<li><a href="../pt440314/index.html">Candidato de libera√ß√£o do JDK 12: Shenandoah, G1, JMH, Arm64. Bugs no Swing contra-atacam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>