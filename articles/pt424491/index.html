<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëΩ üëÜ üß£ Mapas do hex√°gono da unidade: rugosidade, rios e estradas üëÉ üë®üèø‚Äç‚öñÔ∏è ‚ÜòÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malha, cores e altura das c√©lulas 

 Partes 4-7: solavancos, rios e estradas 

 Pe√ßas 8-11: √°gua, formas terrestres e muralhas 

 Pe√ßas 12...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas do hex√°gono da unidade: rugosidade, rios e estradas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424491/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg" alt="imagem"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 1-3: malha, cores e altura das c√©lulas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 4-7: solavancos, rios e estradas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pe√ßas 8-11: √°gua, formas terrestres e muralhas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pe√ßas 12-15: salvar e carregar, texturas, dist√¢ncias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 16-19: encontrando o caminho, esquadr√µes de jogadores, anima√ß√µes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 20-23: Nevoeiro da Guerra, Pesquisa de Mapas, Gera√ß√£o de Procedimentos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partes 24-27: ciclo da √°gua, eros√£o, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 4: Rugosidade </h1><br><h2>  Sum√°rio </h2><br><ul><li>  Experimente a textura do ru√≠do. </li><li>  Mova os v√©rtices. </li><li>  Preservamos o nivelamento das c√©lulas. </li><li>  Subdividir as bordas das c√©lulas. </li></ul><br>  Enquanto nossa grade era um padr√£o estrito de favos de mel.  Nesta parte, adicionaremos solavancos para tornar o mapa mais natural. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/034/982/e33034982aafb942e1e656b76dde0981.png"></div><br>  <i>N√£o h√° mais hex√°gonos.</i> <br><br><h2>  O barulho </h2><br>  Para adicionar solavancos, precisamos de randomiza√ß√£o, mas n√£o de aleatoriedade verdadeira.  Queremos que tudo seja consistente ao alterar o mapa.  Caso contr√°rio, quando voc√™ fizer alguma altera√ß√£o, os objetos ir√£o pular.  Ou seja, precisamos de alguma forma de ru√≠do pseudo-aleat√≥rio reproduz√≠vel. <br><br>  Um bom candidato √© o barulho de Perlin.  √â reproduz√≠vel em qualquer lugar.  Ao combinar v√°rias frequ√™ncias, tamb√©m cria ru√≠do, que pode variar bastante em grandes dist√¢ncias, mas permanece quase o mesmo em pequenas dist√¢ncias.  Gra√ßas a isso, distor√ß√µes relativamente suaves podem ser criadas.  Os pontos adjacentes um ao outro geralmente permanecem pr√≥ximos e n√£o est√£o espalhados em dire√ß√µes opostas. <br><br>  Podemos gerar ru√≠do Perlin programaticamente.  No tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Noise</a> , explico como fazer isso.  Mas tamb√©m podemos obter amostras de uma textura de ru√≠do pr√©-gerada.  A vantagem de usar a textura √© que ela √© mais simples e muito mais r√°pida que o c√°lculo do ru√≠do multi-frequ√™ncia da Perlin.  Sua desvantagem √© que a textura ocupa mais mem√≥ria e cobre apenas uma pequena √°rea de ru√≠do.  Portanto, deve ser perfeitamente conectado e grande o suficiente para que a repeti√ß√£o n√£o seja impressionante. <br><br><h3>  Textura de ru√≠do </h3><br>  Usaremos a textura, portanto o tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Noise</a> √© opcional.  Ent√£o, precisamos de uma textura.  Aqui est√°: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/8e8/5d7/fbd8e85d783626c737decd6bc69a2519.png"></div><br>  <i>Conecte perfeitamente a textura de ru√≠do perlin.</i> <br><br>  A textura mostrada acima cont√©m o ru√≠do de m√∫ltiplas frequ√™ncias perfeitamente integrado da Perlin.  Esta √© uma imagem em escala de cinza.  Seu valor m√©dio √© 0,5 e os valores extremos tendem a 0 e 1. <br><br>  Mas espere, s√≥ h√° um valor para cada ponto.  Se precisamos de distor√ß√£o 3D, precisamos de pelo menos tr√™s amostras pseudo-aleat√≥rias!  Portanto, precisamos de mais duas texturas com ru√≠do diferente. <br><br>  Podemos cri√°-los ou armazenar diferentes valores de ru√≠do em cada um dos canais de cores.  Isso nos permitir√° armazenar at√© quatro padr√µes de ru√≠do em uma textura.  Aqui est√° essa textura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/509/aca/a1d509acaf05d64de002829afc59cb90.png"></div><br>  <i>Quatro em um.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Como criar essa textura?</b> <div class="spoiler_text">  Eu usei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NumberFlow</a> .  Este √© o editor de textura processual que criei para o Unity. </div></div><br>  Fa√ßa o download dessa textura e importe-a para o seu projeto do Unity.  Como vamos amostrar a textura atrav√©s do c√≥digo, ela deve ser leg√≠vel.  Alterne o <em>Tipo de textura</em> para <em>Avan√ßado</em> e ative a op√ß√£o <em>Leitura / Grava√ß√£o ativada</em> .  Isso salvar√° os dados de textura na mem√≥ria e pode ser acessado a partir do c√≥digo C #.  Defina <em>Format</em> como <em>Automatic Truecolor</em> , caso contr√°rio nada funcionar√°.  N√£o queremos que a compress√£o de textura destrua nosso padr√£o de ru√≠do. <br><br>  Voc√™ pode desativar o <em>recurso Gerar mapas Mip</em> , porque n√£o precisamos deles.  Ative tamb√©m a op√ß√£o <em>Bypass sRGB Sampling</em> .  N√£o precisaremos disso, mas ser√° assim.  Este par√¢metro indica que a textura n√£o cont√©m dados de cores no espa√ßo gama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/c36/e45/3aac36e45d7ead64823dc57b55afe67e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fe/6c8/99a/5fe6c899a966eecb34046d5c243036b7.png"></div><br>  Textura de ru√≠do importada. <br><br><div class="spoiler">  <b class="spoiler_title">Quando a amostragem sRGB √© importante?</b> <div class="spoiler_text">  Se quis√©ssemos usar uma textura em um shader, isso faria diferen√ßa.  Ao usar o modo de renderiza√ß√£o Linear, a amostragem da textura converte automaticamente os dados de cores da gama em um espa√ßo de cores linear.  No caso de nossa textura de ru√≠do, isso levar√° a resultados incorretos, portanto n√£o precisamos disso. </div></div><br><div class="spoiler">  <b class="spoiler_title">Por que minhas configura√ß√µes de importa√ß√£o de textura parecem diferentes?</b> <div class="spoiler_text">  Eles foram alterados ap√≥s a cria√ß√£o deste tutorial.  Voc√™ precisa usar as configura√ß√µes de textura 2D padr√£o, <em>sRGB (Textura de cor)</em> deve estar desativado e <em>Compacta√ß√£o</em> deve estar definido como <em>Nenhum</em> . </div></div><br><h3>  Amostragem de ru√≠do </h3><br>  Vamos adicionar a funcionalidade de amostragem de ru√≠do ao <code>HexMetrics</code> para que voc√™ possa us√°-lo em qualquer lugar.  Isso significa que o <code>HexMetrics</code> deve conter uma refer√™ncia √† textura do ru√≠do. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Texture2D noiseSource;</code> </pre> <br>  Como este n√£o √© um componente, n√£o podemos atribuir uma textura atrav√©s do editor.  Portanto, como intermedi√°rio, usamos o <code>HexGrid</code> .  Como o <code>HexGrid</code> atuar√° primeiro, n√£o haver√° problema se passarmos a textura no in√≠cio de seu m√©todo <code>Awake</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D noiseSource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; ‚Ä¶ }</code> </pre> <br>  No entanto, essa abordagem n√£o sobreviver√° √† recompila√ß√£o no modo de reprodu√ß√£o.  Vari√°veis ‚Äã‚Äãest√°ticas n√£o s√£o serializadas pelo mecanismo do Unity.  Para resolver esse problema, reatribua tamb√©m a textura no m√©todo de evento <code>OnEnable</code> .  Este m√©todo ser√° chamado ap√≥s a recompila√ß√£o. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d87/4fd/3a5/d874fd3a57faad4e57e5af830b202a19.png"></div><br>  <i>Atribua uma textura de ru√≠do.</i> <br><br>  Agora que o <code>HexMetrics</code> tem acesso √† textura, vamos adicionar um m√©todo conveniente de amostragem de ru√≠do.  Este m√©todo assume uma posi√ß√£o no mundo e cria um vetor 4D contendo quatro amostras de ru√≠do. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  As amostras foram criadas por amostragem da textura usando filtragem bilinear, na qual as coordenadas do mundo X e Z foram usadas como coordenadas UV. Como nossa fonte de ru√≠do √© bidimensional, ignoramos a terceira coordenada do mundo.  Se a fonte de ru√≠do fosse tridimensional, tamb√©m usar√≠amos a coordenada Y. <br><br>  Como resultado, obtemos uma cor que pode ser convertida em um vetor 4D.  Essa redu√ß√£o pode ser indireta, ou seja, podemos retornar a cor diretamente, sem incluir explicitamente <code>(Vector4)</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear(position.x, position.z); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Como funciona a filtragem bilinear?</b> <div class="spoiler_text">  Para obter uma explica√ß√£o das coordenadas UV e da filtragem de texturas, consulte o tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Renderiza√ß√£o 2, Fundamentos do Shader</a> . </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Movimento de v√©rtice </h2><br>  Distorceremos nossa grade suave de favos de mel, movendo individualmente cada um dos v√©rtices.  Para fazer isso, vamos adicionar o m√©todo <code>Perturb</code> ao <code>Perturb</code> .  √â preciso um ponto im√≥vel e retorna o ponto movido.  Para fazer isso, ele usa um ponto sem deslocamento ao amostrar ru√≠do. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); }</code> </pre> <br>  Vamos apenas adicionar as amostras de ru√≠do X, Y e Z diretamente √†s coordenadas dos pontos correspondentes e us√°-las como resultado. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x; position.y += sample.y; position.z += sample.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br>  Como <code>HexMesh</code> rapidamente o <code>HexMesh</code> para mover todos os v√©rtices?  Alterando cada v√©rtice ao adicionar v√©rtices √† lista nos <code>AddQuad</code> e <code>AddQuad</code> .  Vamos fazer isso. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); vertices.Add(Perturb(v4)); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Os quadr√¢ngulos permanecer√£o planos depois de mover seus v√©rtices?</b> <div class="spoiler_text">  Provavelmente n√£o.  Eles consistem em dois tri√¢ngulos que n√£o ficam mais no mesmo plano.  No entanto, como esses tri√¢ngulos t√™m dois v√©rtices comuns, as normais desses v√©rtices ser√£o suavizadas.  Isso significa que n√£o teremos transi√ß√µes n√≠tidas entre dois tri√¢ngulos.  Se a distor√ß√£o n√£o for muito grande, ainda perceberemos os quadr√¢ngulos como planos. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/589/55c/47d/58955c47d221104096d943df9f9b948c.png"></div><br>  <i>Os v√©rtices s√£o movidos ou n√£o.</i> <br><br>  Embora as altera√ß√µes n√£o sejam muito vis√≠veis, apenas os r√≥tulos das c√©lulas desapareceram.  Isso aconteceu porque adicionamos amostras de ru√≠do aos pontos, e elas sempre s√£o positivas.  Portanto, como resultado, todos os tri√¢ngulos se elevaram acima de suas marcas, fechando-os.  Devemos centralizar as mudan√ßas para que elas ocorram nas duas dire√ß√µes.  Altere o intervalo da amostra de ru√≠do de 0-1 para -1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.y += sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.z += sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f0/bd6/83a/1f0bd683ad92592fa6c5df171eab646c.png"></div><br>  <i>Deslocamento centralizado.</i> <br><br><h3>  A magnitude (for√ßa) do deslocamento </h3><br>  Agora √© √≥bvio que distorcemos a grade, mas o efeito √© quase impercept√≠vel.  A altera√ß√£o em cada dimens√£o n√£o √© superior a 1 unidade.  Ou seja, o deslocamento m√°ximo te√≥rico √© de ‚àö3 ‚âà 1,73 unidades, o que acontecer√° muito raramente, se √© que ocorrer√°.  Como o raio externo das c√©lulas √© de 10 unidades, os deslocamentos s√£o relativamente pequenos. <br><br>  A solu√ß√£o √© adicionar um par√¢metro de <code>HexMetrics</code> ao <code>HexMetrics</code> para que voc√™ possa dimensionar os movimentos.  Vamos tentar usar a for√ßa 5. Nesse caso, o deslocamento m√°ximo te√≥rico ser√° de ‚àö75 ‚âà 8,66 unidades, o que √© muito mais percept√≠vel. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br>  Aplicamos for√ßa multiplicando-a por amostras em <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.y += (sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/2ef/fc0/fa82effc05a418729e81ee54f0922f26.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b19/fc8/3f0/b19fc83f0828160b2100a346083f1047.png"></div><br>  <i>For√ßa aumentada.</i> <br><br><h3>  Escala de ru√≠do </h3><br>  Embora a grade pare√ßa boa antes da mudan√ßa, tudo pode dar errado depois que as bordas aparecerem.  Seus picos podem ser distorcidos em dire√ß√µes imprevisivelmente diferentes, criando o caos.  Ao usar o ru√≠do Perlin, isso n√£o deve acontecer. <br><br>  O problema surge porque usamos diretamente as coordenadas do mundo para provar o ru√≠do.  Por esse motivo, a textura fica oculta em cada unidade e as c√©lulas s√£o muito maiores que esse valor.  De fato, a textura √© amostrada em pontos arbitr√°rios, destruindo sua integridade existente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/bd1/717/f3fbd1717515fdf4e500e9674d82a08f.png"></div><br>  <i>Linhas de 10 a 10 c√©lulas de sobreposi√ß√£o de grade.</i> <br><br>  Teremos que escalar a amostragem de ru√≠do para que a textura cubra uma √°rea muito maior.  Vamos adicionar essa escala ao <code>HexMetrics</code> e atribuir um valor de 0,003 e, em seguida, dimensionar as coordenadas das amostras por esse fator. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> noiseScale = <span class="hljs-number"><span class="hljs-number">0.003f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); }</code> </pre> <br>  De repente, acontece que nossa textura cobre 333 &amp; frac13;  unidades quadradas e sua integridade local se torna aparente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/219/e7a/9de219e7ae0495bcc9dfc2eca4ce52d6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53c/0fc/e14/53c0fce142f96daecfd5001ac45e2222.png"></div><br>  <i>Ru√≠do em escala.</i> <br><br>  Al√©m disso, uma nova escala aumenta a dist√¢ncia entre as articula√ß√µes do ru√≠do.  De fato, como as c√©lulas t√™m um di√¢metro interno de 10‚àö3 unidades, nunca ser√£o exatamente lado a lado na dimens√£o X. No entanto, devido √† integridade local do ru√≠do, em uma escala maior, ainda seremos capazes de reconhecer padr√µes de repeti√ß√£o, aproximadamente a cada 20 c√©lulas, mesmo se os detalhes n√£o corresponderem.  Mas eles ser√£o √≥bvios apenas no mapa sem outras caracter√≠sticas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Alinhando centros celulares </h2><br>  Mover todos os v√©rtices d√° ao mapa uma apar√™ncia mais natural, mas h√° v√°rios problemas.  Como as c√©lulas agora est√£o irregulares, seus r√≥tulos se cruzam com a malha.  E nas articula√ß√µes das bordas dos penhascos surgem fendas.  Vamos deixar as rachaduras para mais tarde, mas agora vamos nos concentrar nas superf√≠cies das c√©lulas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/320/626/85f/32062685fe221819ba4d9375175f66ee.png"></div><br>  <i>O mapa ficou menos rigoroso, mas surgiram mais problemas.</i> <br><br>  A maneira mais f√°cil de resolver o problema de interse√ß√£o √© tornar os centros das c√©lulas achatados.  Vamos apenas n√£o alterar a coordenada Y no <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-comment"><span class="hljs-comment">// position.y += (sample.y * 2f - 1f) * HexMetrics.cellPerturbStrength; position.z += (sample.z * 2f - 1f) * HexMetrics.cellPerturbStrength; return position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/6f6/38e/bfb6f638e8cdb45d6178d1f18cdb723b.png"></div><br>  <i>C√©lulas alinhadas.</i> <br><br>  Com essa mudan√ßa, todas as posi√ß√µes verticais permanecer√£o inalteradas, tanto no centro das c√©lulas quanto nas etapas das bordas.  Deve-se notar que isso reduz o deslocamento m√°ximo para ‚àö50 ‚âà 7,07 apenas no plano XZ. <br><br>  Essa √© uma boa mudan√ßa, porque simplifica a identifica√ß√£o de c√©lulas individuais e n√£o permite que as bordas fiquem ca√≥ticas demais.  Mas ainda seria bom adicionar um pouco de movimento vertical. <br><br><h3>  Mover altura da c√©lula </h3><br>  Em vez de aplicar o movimento vertical a cada v√©rtice, podemos aplic√°-lo a uma c√©lula.  Nesse caso, cada c√©lula permanecer√° plana, mas a variabilidade ainda permanecer√° entre as c√©lulas.  Tamb√©m seria l√≥gico usar uma escala diferente para mover a altura; adicione-a ao <code>HexMetrics</code> .  Uma for√ßa de 1,5 unidades cria uma pequena varia√ß√£o, aproximadamente igual √† altura de um passo da borda. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationPerturbStrength = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br>  Altere a propriedade <code>HexCell.Elevation</code> para <code>HexCell.Elevation</code> essa movimenta√ß√£o √† posi√ß√£o vertical da c√©lula. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; } }</code> </pre> <br>  Para que a movimenta√ß√£o seja aplicada imediatamente, precisamos definir explicitamente a altura de cada c√©lula em <code>HexGrid.CreateCell</code> .  Caso contr√°rio, a grade ser√° inicialmente plana.  Vamos fazer isso no final, depois de criar a interface do usu√°rio. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Elevation = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/dd7/15c/d4fdd715c130c8cd8b2519ff37c837de.png"></div><br>  <i>Alturas deslocadas com rachaduras.</i> <br><br><h3>  Usando as mesmas alturas </h3><br>  Muitas rachaduras apareceram na malha, porque quando triangulamos a malha, n√£o usamos a mesma altura de c√©lula.  Vamos adicionar uma propriedade ao <code>HexCell</code> para obter sua posi√ß√£o, para que voc√™ possa us√°-la em qualquer lugar. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transform.localPosition; } }</code> </pre> <br>  Agora podemos usar essa propriedade em <code>HexMesh.Triangulate</code> para determinar o centro da c√©lula. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; ‚Ä¶ }</code> </pre> <br>  E podemos us√°-lo em <code>TriangulateConnection</code> ao definir as posi√ß√µes verticais das c√©lulas vizinhas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69b/9a2/d90/69b9a2d90b7f29ef57f658f8206f6dda.png"></div><br>  <i>Uso consistente da altura da c√©lula.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Cell Edge Unit </h2><br>  Embora as c√©lulas tenham uma bela varia√ß√£o, elas ainda parecem hex√°gonos √≥bvios.  Isso por si s√≥ n√£o √© um problema, mas podemos melhorar sua apar√™ncia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/895/e86/6d5895e8650286653b532d9c6fa1c10d.png"></div><br>  <i>C√©lulas hexagonais claramente vis√≠veis.</i> <br><br>  Se tiv√©ssemos mais v√©rtices, haveria maior variabilidade local.  Ent√£o, vamos dividir cada extremidade da c√©lula em duas partes, adicionando a parte superior da borda no meio entre cada par de cantos.  Isso significa que <code>HexMesh.Triangulate</code> deve adicionar n√£o um, mas dois tri√¢ngulos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, v2); AddTriangleColor(cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b09/03c/d20/b0903cd20983599abdc064f04c95aa4f.png"></div><br>  <i>Doze lados em vez de seis.</i> <br><br>  A duplica√ß√£o de v√©rtices e tri√¢ngulos adiciona mais variabilidade √†s bordas da c√©lula.  Vamos torn√°-los ainda mais irregulares, triplicando o n√∫mero de v√©rtices. <br><br><pre> <code class="cs hljs"> Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e2 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, e2); AddTriangleColor(cell.color); AddTriangle(center, e2, v2); AddTriangleColor(cell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/852/e6c/ad2852e6ccbf3db0adca140818545bb3.png"></div><br>  <i>18 lados.</i> <br><br><h3>  Divis√£o de costela </h3><br>  Obviamente, tamb√©m precisamos subdividir as juntas das arestas.  Portanto, passaremos as novas arestas de v√©rtice para <code>TriangulateConnection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, e1, e2, v2); }</code> </pre> <br>  Adicione os par√¢metros apropriados ao <code>TriangulateConnection</code> para que ele possa trabalhar com v√©rtices adicionais. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br>  Tamb√©m precisamos calcular as arestas adicionais das arestas das c√©lulas vizinhas.  Podemos calcul√°-los depois de conectar a ponte ao outro lado. <br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; Vector3 e3 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e4 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>);</code> </pre> <br>  Em seguida, precisamos alterar a triangula√ß√£o da costela.  At√© ignorarmos as pistas com as bordas, basta adicionar tr√™s em vez de um quad. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, e1, v3, e3); AddQuadColor(cell.color, neighbor.color); AddQuad(e1, e2, e3, e4); AddQuadColor(cell.color, neighbor.color); AddQuad(e2, v2, e4, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/9d6/708/afa9d67080045b6ea2951a715c569003.png"></div><br>  <i>Conex√µes subdivididas.</i> <br><br><h3>  A uni√£o das arestas das arestas </h3><br>  Como para descrever as arestas, precisamos agora de quatro v√©rtices, seria l√≥gico combin√°-las em um conjunto.  Isso √© mais conveniente do que trabalhar com quatro v√©rtices independentes.  Crie uma estrutura <code>EdgeVertices</code> simples para isso.  Ele deve conter quatro v√©rtices no sentido hor√°rio ao longo da borda da c√©lula. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EdgeVertices { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Eles n√£o deveriam ser serializ√°veis?</b> <div class="spoiler_text">  Usaremos essa estrutura apenas para triangula√ß√£o.  Nesse est√°gio, n√£o precisamos armazenar os v√©rtices das arestas, portanto, n√£o √© necess√°rio que sejam serializ√°veis. </div></div><br>  Adicione um m√©todo construtor conveniente a ele, que lidar√° com o c√°lculo dos pontos intermedi√°rios da aresta. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v4 = corner2; }</code> </pre> <br>  Agora podemos adicionar um m√©todo de triangula√ß√£o separado ao <code>HexMesh</code> para criar um leque de tri√¢ngulos entre o centro da c√©lula e uma de suas bordas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); }</code> </pre> <br>  E um m√©todo para triangular uma faixa de quadr√¢ngulos entre duas arestas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); }</code> </pre> <br>  Isso nos permitir√° simplificar o m√©todo <code>Triangulate</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); TriangulateEdgeFan(center, e, cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br>  Vamos passar para <code>TriangulateConnection</code> .  Agora podemos usar <code>TriangulateEdgeStrip</code> , mas outras substitui√ß√µes precisam ser feitas.  Onde costum√°vamos usar a <code>v1</code> , precisamos usar <code>e1.v1</code> .  Da mesma forma, <code>v2</code> se torna <code>e1.v4</code> , <code>v3</code> se torna <code>e2.v1</code> e <code>v4</code> se torna <code>e2.v4</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v4 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1.v1, e1.v4, cell, e2.v1, e2.v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.color, e2, neighbor.color); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = e1.v4 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e1.v4, cell, e2.v4, neighbor, v5, nextNeighbor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e2.v4, neighbor, v5, nextNeighbor, e1.v4, cell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } }</code> </pre> <br><h3>  Divis√£o Ledge </h3><br>  Precisamos dividir as bordas.  Portanto, passamos as arestas para <code>TriangulateEdgeTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor); }</code> </pre> <br>  Agora precisamos modificar <code>TriangulateEdgeTerraces</code> para que ele interpole entre arestas e n√£o entre pares de v√©rtices.  Vamos supor que o <code>EdgeVertices</code> tenha um m√©todo est√°tico conveniente para fazer isso.  Isso nos permitir√° simplificar o <code>TriangulateEdgeTerraces</code> vez de complic√°-lo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.color, e2, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); TriangulateEdgeStrip(e1, c1, e2, c2); } TriangulateEdgeStrip(e2, c2, end, endCell.color); }</code> </pre> <br>  O m√©todo <code>EdgeVertices.TerraceLerp</code> simplesmente interpola as bordas entre os quatro pares de v√©rtices de duas arestas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7d/ead/906/a7dead9066cbd1f7ddd29ca751d81cb0.png"></div><br>  <i>Bordas subdivididas.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">unitypackage</a> <br><br><h2>  Reconecte penhascos e sali√™ncias </h2><br>  At√© agora, ignoramos as rachaduras na jun√ß√£o de fal√©sias e sali√™ncias.  √â hora de resolver este problema.  Vejamos primeiro os casos de penhasco-declive-declive (OSS) e declive-precip√≠cio-declive (SOS). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/951/0fa/4029510fa08226cc4e4aee18faf1959b.png"></div><br>  <i>Buracos de malha.</i> <br><br>  O problema surge porque os topos das fronteiras se moveram.  Isso significa que agora eles n√£o est√£o exatamente do lado do penhasco, o que leva a uma rachadura.  √Äs vezes, esses buracos s√£o invis√≠veis e √†s vezes impressionantes. <br><br>  A solu√ß√£o √© n√£o mover o topo da borda.  Isso significa que precisamos controlar se o ponto ser√° movido.  A maneira mais f√°cil seria criar uma alternativa <code>AddTriangle</code> que n√£o mova os v√©rtices. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Altere o <code>TriangulateBoundaryTriangle</code> para que ele use esse m√©todo.  Isso significa que ele ter√° que mover explicitamente todos os v√©rtices, exceto os limites. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), Perturb(v2), boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(Perturb(v1), Perturb(v2), boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(Perturb(v2), Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br>  Vale a pena observar o seguinte: como n√£o usamos a <code>v2</code> para obter outro ponto, podemos mov√™-lo imediatamente.  Essa √© uma otimiza√ß√£o simples e reduz a quantidade de c√≥digo, ent√£o vamos apresent√°-la. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(v2, Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/221/0ed/3fd2210ed0a8148ba9d39ef1655848e8.png"></div><br>  <i>Fronteiras im√≥veis.</i> <br><br>  Parece melhor, mas ainda n√£o terminamos.  Dentro do m√©todo <code>TriangulateCornerTerracesCliff</code> , o ponto de limite √© interpolado entre os pontos esquerdo e direito.  No entanto, esses pontos ainda n√£o foram movidos.  Para que o ponto de contorno corresponda ao penhasco resultante, precisamos interpolar entre os pontos movidos. <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(right), b);</code> </pre> <br>  O mesmo vale para o m√©todo <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(left), b);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/917/670/c189176704e7ebcdfd92bc6a1cffaee3.png"></div><br>  <i>Os buracos se foram.</i> <br><br><h3>  Fal√©sias e declives duplos </h3><br>  Em todos os casos problem√°ticos restantes, dois penhascos e uma inclina√ß√£o est√£o presentes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/408/f2f/4a6/408f2f4a6fca5fffd8659b4380f59e51.png"></div><br>  <i>Buraco grande por causa de um √∫nico tri√¢ngulo.</i> <br><br>  Esse problema √© resolvido movendo manualmente um √∫nico tri√¢ngulo no bloco <code>else</code> no final do <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br>  O mesmo vale para <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/b34/64a/9ffb3464a6de3dc443cede9d42797022.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Livre-se das √∫ltimas rachaduras. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclus√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos uma malha distorcida completamente correta. </font><font style="vertical-align: inherit;">Sua apar√™ncia depende do ru√≠do espec√≠fico, de sua escala e das for√ßas de distor√ß√£o. </font><font style="vertical-align: inherit;">No nosso caso, a distor√ß√£o pode parecer muito forte. </font><font style="vertical-align: inherit;">Embora essa desigualdade pare√ßa bonita, n√£o queremos que as c√©lulas se desviem muito da grade uniforme. </font><font style="vertical-align: inherit;">No final, ainda a usamos para definir a c√©lula a ser redimensionada. </font><font style="vertical-align: inherit;">E se o tamanho das c√©lulas variar muito, ser√° mais dif√≠cil colocar o conte√∫do nelas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/32e/d06/35f32ed066f03b1079ed0bec70ba83ca.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eac/3f5/d6c/eac3f5d6cd6a1e65185d1aec48e8abb0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malhas n√£o distorcidas e distorcidas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que a for√ßa 5 para distorcer as c√©lulas √© muito grande.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A distor√ß√£o das c√©lulas √© de 0 a 5.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos reduzi-lo para 4 para aumentar a conveni√™ncia da grade, sem torn√°-la muito correta. </font><font style="vertical-align: inherit;">Isso garante que o deslocamento m√°ximo de XZ seja ‚àö32 ,65,6 unidades.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/2f6/b8d/8032f6b8d0cf048f5d55c30e2d0e465d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For√ßa da distor√ß√£o celular 4.</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Outro valor que pode ser alterado √© o coeficiente de integridade. </font><font style="vertical-align: inherit;">Se aumentarmos, os centros planos das c√©lulas se tornar√£o maiores, ou seja, haver√° mais espa√ßo para o conte√∫do futuro. </font><font style="vertical-align: inherit;">Obviamente, ao faz√™-lo, eles se tornar√£o mais hexagonais.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coeficiente de integridade de 0,75 a 0,95. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ligeiro aumento do coeficiente de integridade para 0,8 simplificar√° levemente nossa vida no futuro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.8f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/9a2/036/a9a9a2036fbcd0e4e5f11e56078911c1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coeficiente de integridade 0.8. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, voc√™ pode perceber que as diferen√ßas entre os n√≠veis de eleva√ß√£o s√£o muito n√≠tidas. </font><font style="vertical-align: inherit;">Isso √© conveniente quando voc√™ precisa garantir que a malha seja gerada corretamente, mas j√° conclu√≠mos isso. </font><font style="vertical-align: inherit;">Vamos reduzi-lo para 1 unidade por etapa, ou seja, para 3.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cc/4b0/028/5cc4b002843f822556c7ced67b9f54db.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tom √© reduzido para 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamb√©m podemos alterar a for√ßa da distor√ß√£o do tom. </font><font style="vertical-align: inherit;">Mas agora ele tem um valor de 1,5, que √© igual a meio passo de altura, o que nos conv√©m. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pequenos degraus de altura permitem um uso mais l√≥gico de todos os sete n√≠veis de altura. </font><font style="vertical-align: inherit;">Isso aumenta a variabilidade do mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f63/9b3/aac/f639b3aac128c4c72c28fa85d68cc0e4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos sete n√≠veis de altura. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 5: cart√µes maiores </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dividimos a grade em fragmentos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s controlamos a c√¢mera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colorir as cores e alturas separadamente. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use o pincel aumentado das c√©lulas. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, temos trabalhado com um mapa muito pequeno. </font><font style="vertical-align: inherit;">√â hora de aument√°-lo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/11c/4b4/0c811c4b480c13b584a2b824fdae1cee.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â hora de aumentar o zoom.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentos de malha </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o podemos tornar a grade muito grande, porque nos deparamos com os limites do que pode caber em uma malha. </font><font style="vertical-align: inherit;">Como resolver este problema? </font><font style="vertical-align: inherit;">Use v√°rias malhas. </font><font style="vertical-align: inherit;">Para fazer isso, precisamos dividir nossa grade em v√°rios fragmentos. </font><font style="vertical-align: inherit;">Usamos fragmentos retangulares de tamanho constante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/423/453/db2/423453db217ed74da2457198c576ef63.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dividindo a grade em 3 por 3 segmentos,</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vamos usar 5 por 5 blocos, ou seja, 25 c√©lulas por fragmento. </font><font style="vertical-align: inherit;">Defina-os </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeX = <span class="hljs-number"><span class="hljs-number">5</span></span>, chunkSizeZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que tamanho de fragmento pode ser considerado adequado?</font></font></b> <div class="spoiler_text">  .       ,     .      .      ,       (frustum culling),       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora n√£o podemos usar nenhum tamanho para a malha; ela deve ser um m√∫ltiplo do tamanho do fragmento. </font><font style="vertical-align: inherit;">Portanto, vamos alter√°-lo </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele defina seu tamanho n√£o em c√©lulas separadas, mas em fragmentos. </font><font style="vertical-align: inherit;">Defina o tamanho padr√£o como 4 por 3 fragmentos, ou seja, apenas 12 fragmentos ou 300 c√©lulas. </font><font style="vertical-align: inherit;">Portanto, temos um cart√£o de teste conveniente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkCountX = <span class="hljs-number"><span class="hljs-number">4</span></span>, chunkCountZ = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda usamos </font></font><code>width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>height</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas agora eles devem se tornar privados. </font><font style="vertical-align: inherit;">E renomeie-os para </font></font><code>cellCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>cellCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Use o editor para renomear todas as ocorr√™ncias dessas vari√°veis ‚Äã‚Äãde uma s√≥ vez. </font><font style="vertical-align: inherit;">Agora ficar√° claro quando estivermos lidando com o n√∫mero de fragmentos ou c√©lulas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int width = 6; // public int height = 6; int cellCountX, cellCountZ;</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/ff4/160/227ff41602f115787a8a0e5d98ca89c9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especifique o tamanho em fragmentos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que, se necess√°rio, o n√∫mero de c√©lulas seja calculado a partir do n√∫mero de fragmentos. </font><font style="vertical-align: inherit;">Destacamos a cria√ß√£o de c√©lulas em um m√©todo separado, para n√£o entupir </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[cellCountZ * cellCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; cellCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; cellCountX; x++) { CreateCell(x, z, i++); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pr√©-fabricado de fragmentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para descrever os fragmentos de malha, precisamos de um novo tipo de componente. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, criaremos um fragmento pr√©-fabricado. </font><font style="vertical-align: inherit;">Faremos isso duplicando o objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e renomeando-o como </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chunk Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Remova seu componente </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e adicione um componente </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em seguida, transforme-o em uma pr√©-fabricada e remova o objeto da cena.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/a02/bea/106a02bead67c37151be26d5f6a4bea9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cb/586/7a3/1cb5867a3851159ce2bf1747a4e213bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um fragmento pr√©-fabricado com sua pr√≥pria tela e malha. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ele criar√° inst√¢ncias desses fragmentos </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daremos a ele um link para a pr√©-fabricada do fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunkPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/6b8/882/2a96b8882c5d6cc5bdb6345d5217ae83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora com fragmentos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criar inst√¢ncias de fragmentos √© como criar inst√¢ncias de c√©lulas. </font><font style="vertical-align: inherit;">N√≥s os rastrearemos com a ajuda de uma matriz e usaremos um loop duplo para preench√™-la.</font></font><br><br><pre> <code class="cs hljs"> HexGridChunk[] chunks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateChunks(); CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(transform); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inicializa√ß√£o de um fragmento √© semelhante √† forma como inicializamos uma grade de hex√°gonos. </font><font style="vertical-align: inherit;">Ela coloca tudo </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e executa a triangula√ß√£o </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Requer uma refer√™ncia √† sua tela e malha, bem como uma matriz para as c√©lulas. </font><font style="vertical-align: inherit;">No entanto, o fragmento n√£o criar√° essas c√©lulas. </font><font style="vertical-align: inherit;">A grade continuar√° fazendo isso.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { HexCell[] cells; HexMesh hexMesh; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atribuindo c√©lulas a fragmentos </font></font></h3><br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ainda cria todas as c√©lulas. </font><font style="vertical-align: inherit;">Isso √© normal, mas agora precisamos adicionar cada c√©lula a um fragmento adequado e n√£o defini-las usando nossa pr√≥pria malha e tela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); <span class="hljs-comment"><span class="hljs-comment">// cell.transform.SetParent(transform, false); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); // label.rectTransform.SetParent(gridCanvas.transform, false); label.rectTransform.anchoredPosition = new Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; cell.Elevation = 0; AddCellToChunk(x, z, cell); } void AddCellToChunk (int x, int z, HexCell cell) { }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos encontrar o fragmento correto usando a divis√£o inteira </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pelo tamanho do fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando resultados intermedi√°rios, tamb√©m podemos determinar o √≠ndice local da c√©lula nesse fragmento. </font><font style="vertical-align: inherit;">Depois disso, voc√™ pode adicionar uma c√©lula ao fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localX = x - chunkX * HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localZ = z - chunkZ * HexMetrics.chunkSizeZ; chunk.AddCell(localX + localZ * HexMetrics.chunkSizeX, cell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, </font></font><code>HexGridChunk.AddCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coloca a c√©lula em sua pr√≥pria matriz e define os elementos pai para a c√©lula e sua interface do usu√°rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse ponto, ele </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode se livrar da tela de seus filhos e da malha hexagonal, al√©m do c√≥digo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Canvas gridCanvas; // HexMesh hexMesh; void Awake () { HexMetrics.noiseSource = noiseSource; // gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); ‚Ä¶ } // void Start () { // hexMesh.Triangulate(cells); // } // public void Refresh () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde que nos livramos </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, n√£o devemos </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais us√°-lo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; <span class="hljs-comment"><span class="hljs-comment">// hexGrid.Refresh(); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a0/f4b/c99/5a0f4bc99bce766e53ff1a0192abd16e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A grade limpa de hex√°gonos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de iniciar o modo Play, o cart√£o ainda parece o mesmo. </font><font style="vertical-align: inherit;">Mas a hierarquia dos objetos ser√° diferente. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Grade hexadecimal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agora cria objetos filho de fragmento que cont√™m c√©lulas, bem como suas malhas e telas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/bc4/f8e/a7fbc4f8e4898504bc34a4a918ebb567.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos filho no modo Play. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez tenhamos alguns problemas com os r√≥tulos das c√©lulas. </font><font style="vertical-align: inherit;">Inicialmente, definimos a largura do r√≥tulo como 5. Isso foi suficiente para exibir os dois caracteres que eram suficientes para n√≥s em um pequeno mapa. </font><font style="vertical-align: inherit;">Mas agora podemos ter coordenadas como -10, nas quais existem tr√™s caracteres. </font><font style="vertical-align: inherit;">Eles n√£o cabem e ser√£o aparados. </font><font style="vertical-align: inherit;">Para corrigir isso, aumente a largura do r√≥tulo da c√©lula para 10 ou at√© mais.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e7/fd3/4a5/2e7fd34a5b649256e326b73a3aa9227a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/926/fae/f7c926fae8356aa8d2402a21359fea8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≥tulos de c√©lulas estendidos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos criar mapas muito maiores! </font><font style="vertical-align: inherit;">Como geramos toda a grade na inicializa√ß√£o, pode demorar muito tempo para criar mapas grandes. </font><font style="vertical-align: inherit;">Mas ap√≥s a conclus√£o, teremos um enorme espa√ßo para experimenta√ß√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corrigir edi√ß√£o de c√©lulas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A edi√ß√£o parece n√£o funcionar no est√°gio atual, porque n√£o atualizamos mais a grade. </font><font style="vertical-align: inherit;">Precisamos atualizar fragmentos individuais, ent√£o adicione um m√©todo </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando devemos chamar esse m√©todo? </font><font style="vertical-align: inherit;">Sempre atualizamos toda a grade porque t√≠nhamos apenas uma malha. </font><font style="vertical-align: inherit;">Mas agora temos muitos fragmentos. </font><font style="vertical-align: inherit;">Em vez de atualizar todos eles a cada vez, ser√° muito mais eficiente atualizar os fragmentos alterados. </font><font style="vertical-align: inherit;">Caso contr√°rio, a troca de cart√µes grandes se tornar√° uma opera√ß√£o muito lenta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas como sabemos qual fragmento atualizar? </font><font style="vertical-align: inherit;">A maneira mais f√°cil √© fazer com que cada c√©lula saiba a que fragmento pertence. </font><font style="vertical-align: inherit;">A c√©lula poder√° atualizar seu fragmento ao alterar essa c√©lula. </font><font style="vertical-align: inherit;">Ent√£o, vamos dar um </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link para seu fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunk;</code> </pre> <br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode se adicionar √† c√©lula ao adicionar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.chunk = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao combinar-los, adicionar </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e m√©todo </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cada vez que uma c√©lula √© atualizada, ela simplesmente atualiza seu fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o precisamos torn√°-lo </font></font><code>HexCell.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comum, porque a pr√≥pria c√©lula sabe melhor quando foi alterada. </font><font style="vertical-align: inherit;">Por exemplo, depois que sua altura foi alterada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, precisamos atualiz√°-lo somente quando sua altura mudar para um valor diferente. </font><font style="vertical-align: inherit;">Ela nem precisa recalcular nada se atribuirmos a ela a mesma altura de antes. </font><font style="vertical-align: inherit;">Portanto, podemos sair do in√≠cio do levantador.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, tamb√©m ignoraremos os c√°lculos pela primeira vez quando a altura estiver definida como 0, porque esse √© o valor padr√£o da altura da malha. </font><font style="vertical-align: inherit;">Para evitar isso, criaremos o valor inicial como nunca usamos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que √© int.MinValue?</font></font></b> <div class="spoiler_text">   ,    integer.    C# integer ‚Äî <br>  32- ,   2 <sup>32</sup>  integer,    ,    .       . <br><br>  ‚Äî  ‚àí2 <sup>31</sup> = ‚àí2 147 483 648.        ! <br><br>   2 <sup>31</sup> ‚àí 1 = 2 147 483 647.     2 <sup>31</sup> - . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para reconhecer a altera√ß√£o de cor da c√©lula, tamb√©m precisamos transform√°-la em uma propriedade. </font><font style="vertical-align: inherit;">Renomeie-o para </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mai√∫sculas e, em seguida, transforme-o em uma propriedade com uma vari√°vel privada </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O valor padr√£o da cor ser√° preto transparente, o que √© adequado para n√≥s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } color = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } Color color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, quando iniciamos o modo Play, obtemos exce√ß√µes de refer√™ncia nula. </font><font style="vertical-align: inherit;">Isso acontece porque definimos a cor e a altura com seus valores padr√£o antes de atribuir uma c√©lula ao seu fragmento. </font><font style="vertical-align: inherit;">√â normal que n√£o atualizemos os fragmentos nesse est√°gio, porque os triangulamos ap√≥s a conclus√£o de toda a inicializa√ß√£o. </font><font style="vertical-align: inherit;">Em outras palavras, atualizamos um fragmento apenas se ele estiver atribu√≠do.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente podemos mudar as c√©lulas novamente! </font><font style="vertical-align: inherit;">No entanto, surge um problema. </font><font style="vertical-align: inherit;">Ao desenhar ao longo das bordas dos fragmentos, as costuras aparecem.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/94f/50c/41a94f50c430ce8f13fb1a3be274b520.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erros nos limites dos fragmentos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso √© l√≥gico, porque quando uma √∫nica c√©lula muda, todas as conex√µes com seus vizinhos tamb√©m mudam. E esses vizinhos podem estar em outros fragmentos. A solu√ß√£o mais simples √© atualizar todas as c√©lulas vizinhas, se forem diferentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { HexCell neighbor = neighbors[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.chunk != chunk) { neighbor.chunk.Refresh(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora isso funcione, pode ser que atualizemos um fragmento v√°rias vezes. E quando come√ßamos a colorir v√°rias c√©lulas ao mesmo tempo, tudo fica pior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas n√£o somos obrigados a triangular imediatamente ap√≥s a atualiza√ß√£o do fragmento. Em vez disso, simplesmente escrevemos que √© necess√°ria uma atualiza√ß√£o e triangulamos ap√≥s a conclus√£o da altera√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ele </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o faz mais nada, podemos usar o estado ativado para sinalizar a necessidade de atualiza√ß√µes. Ao atualiz√°-lo, inclu√≠mos o componente. Lig√°-lo v√°rias vezes n√£o muda nada. O componente √© atualizado posteriormente. Vamos triangular neste ponto e desativar o componente novamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez disso, </font><font style="vertical-align: inherit;">usamos</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para garantir que a triangula√ß√£o ocorra ap√≥s a conclus√£o da altera√ß√£o no quadro atual. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = true; } void LateUpdate () { hexMesh.Triangulate(cells); enabled = false; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual √© a diferen√ßa entre Update e LateUpdate?</font></font></b> <div class="spoiler_text">     <code>Update</code>    -     .          <code>LateUpdate</code> .      ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como nosso componente √© ativado por padr√£o, n√£o precisamos mais triangular explicitamente </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, esse m√©todo pode ser removido.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void Start () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/104/7c3/a6f1047c34bb9cf9b69360343ab53aac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos de 20 por 20 contendo 10.000 c√©lulas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listas generalizadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora tenhamos alterado significativamente a maneira como a grade √© triangulada, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ela permanece a mesma. </font><font style="vertical-align: inherit;">Tudo o que ele precisa para trabalhar √© uma matriz de c√©lulas. </font><font style="vertical-align: inherit;">Ele n√£o se importa se h√° uma malha de hex√°gonos, ou v√°rios deles. </font><font style="vertical-align: inherit;">Mas ainda n√£o consideramos o uso de v√°rias malhas. </font><font style="vertical-align: inherit;">Talvez algo possa ser melhorado aqui? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">listas </font><font style="vertical-align: inherit;">usadas </font><font style="vertical-align: inherit;">s√£o essencialmente buffers tempor√°rios. </font><font style="vertical-align: inherit;">Eles s√£o usados ‚Äã‚Äãapenas para triangula√ß√£o. </font><font style="vertical-align: inherit;">E os fragmentos s√£o triangulados um de cada vez. </font><font style="vertical-align: inherit;">Portanto, de fato, precisamos apenas de um conjunto de listas, e n√£o de um conjunto para cada objeto de malha hexagonal. </font><font style="vertical-align: inherit;">Isso pode ser alcan√ßado tornando as listas est√°ticas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Color&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// vertices = new List&lt;Vector3&gt;(); // colors = new List&lt;Color&gt;(); // triangles = new List&lt;int&gt;(); }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As listas est√°ticas s√£o realmente t√£o importantes?</font></font></b> <div class="spoiler_text">           .    ,   ,       . <br><br>     ,           .    20  20     100. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Controle da c√¢mera </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A c√¢mera grande √© maravilhosa, mas √© in√∫til se n√£o conseguimos v√™-la. Para inspecionar o mapa inteiro, precisamos mover a c√¢mera. O zoom tamb√©m √© √∫til. Portanto, vamos criar uma c√¢mera para executar essas a√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um objeto fict√≠cio e chame-o de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√¢mera de mapa hexadecimal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Solte seu componente de transforma√ß√£o para que ele se mova para a origem sem alterar sua rota√ß√£o e escala. Adicione um filho a ele chamado </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swivel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e adicione um filho a ele </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stick</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Fa√ßa da c√¢mera principal um filho do Stick e redefina seu componente de transforma√ß√£o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a8/33f/3d9/0a833f3d9eea9b9fef1682ef63a7f372.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A hierarquia da c√¢mera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objetivo da dobradi√ßa da c√¢mera (girat√≥ria) √© controlar o √¢ngulo em que a c√¢mera olha para o mapa. </font><font style="vertical-align: inherit;">Vamos dar uma volta (45, 0, 0). </font><font style="vertical-align: inherit;">A al√ßa (Stick) controla a dist√¢ncia em que as c√¢meras est√£o localizadas. </font><font style="vertical-align: inherit;">Vamos definir uma posi√ß√£o para ela (0, 0, -45). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos de um componente para controlar esse sistema. </font><font style="vertical-align: inherit;">Atribua este componente √† raiz da hierarquia da c√¢mera. </font><font style="vertical-align: inherit;">Vamos dar-lhe um link para a dobradi√ßa e segurar a obten√ß√£o-los em </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Transform swivel, stick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/2e5/44b/eb62e544b9e00bc558dfbc504802cfba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√¢mera de mapa do hex√°gono.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zoom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira fun√ß√£o que criaremos √© o zoom (zoom). </font><font style="vertical-align: inherit;">Podemos controlar o n√≠vel atual de zoom usando a vari√°vel float. </font><font style="vertical-align: inherit;">Um valor de 0 significa que estamos completamente distantes, e um valor de 1 significa que estamos completamente pr√≥ximos. </font><font style="vertical-align: inherit;">Vamos come√ßar com o zoom m√°ximo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoom = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O zoom geralmente √© realizado com a roda do mouse ou o controle anal√≥gico. </font><font style="vertical-align: inherit;">Podemos implement√°-lo usando o eixo de entrada </font><font style="vertical-align: inherit;">padr√£o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouse ScrollWheel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Adicione um m√©todo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que verifique a presen√ßa de um delta de entrada e, se houver, chamar√° o m√©todo de altera√ß√£o de zoom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para alterar o n√≠vel de zoom, basta adicionar um delta e limitar o valor (grampo) para permanecer no intervalo de 0 a 1. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao ampliar e reduzir, a dist√¢ncia da c√¢mera deve mudar de acordo. </font><font style="vertical-align: inherit;">Isso pode ser feito alterando a posi√ß√£o da al√ßa em Z. Adicione duas vari√°veis ‚Äã‚Äãde flutua√ß√£o comuns para ajustar a posi√ß√£o da al√ßa no zoom m√≠nimo e m√°ximo. </font><font style="vertical-align: inherit;">Como estamos desenvolvendo um mapa relativamente pequeno, defina os valores para -250 e -45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stickMinZoom, stickMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s alterar o zoom, realizamos a interpola√ß√£o linear entre esses dois valores com base no novo valor de zoom. </font><font style="vertical-align: inherit;">Em seguida, atualize a posi√ß√£o da al√ßa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cec/f4c/f07/cecf4cf07d627d6eaab94ecdc2953d30.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores m√≠nimos e m√°ximos da vara. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora o zoom funciona, mas at√© agora n√£o √© muito √∫til. </font><font style="vertical-align: inherit;">Normalmente, quando o zoom est√° mais distante, a c√¢mera entra na vista superior. </font><font style="vertical-align: inherit;">Podemos perceber isso girando a dobradi√ßa. </font><font style="vertical-align: inherit;">Portanto, adicionamos as vari√°veis ‚Äã‚Äãmin e max para a dobradi√ßa. </font><font style="vertical-align: inherit;">Vamos definir os valores 90 e 45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> swivelMinZoom, swivelMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim como na posi√ß√£o da al√ßa, interpolamos para encontrar um √¢ngulo de zoom adequado. </font><font style="vertical-align: inherit;">Em seguida, ajustamos a rota√ß√£o da dobradi√ßa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.Lerp(swivelMinZoom, swivelMaxZoom, zoom); swivel.localRotation = Quaternion.Euler(angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/766/0c3/fcd/7660c3fcd621567398ea7c013fae549c.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O valor m√≠nimo e m√°ximo de giro. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A taxa de altera√ß√£o do zoom pode ser ajustada alterando a sensibilidade dos par√¢metros de entrada da roda do mouse. </font><font style="vertical-align: inherit;">Eles podem ser encontrados em </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editar / Configura√ß√µes do projeto / Entrada</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por exemplo, alterando-os de 0,1 para 0,025, obtemos uma altera√ß√£o mais lenta e suave no zoom.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f86/ef3/d43f86ef3587be1bfd15ca208eec418f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op√ß√µes de entrada da roda do mouse.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movendo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos passar a mover a c√¢mera. </font><font style="vertical-align: inherit;">O movimento na dire√ß√£o de X e Z devemos implementar em </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como no caso do zoom. </font><font style="vertical-align: inherit;">Podemos usar eixos de entrada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontais</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verticais</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para isso </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso nos permitir√° mover a c√¢mera com as setas e as teclas WASD.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A abordagem mais simples √© obter a posi√ß√£o atual do sistema da c√¢mera, adicionar deltas X e Z a ele e atribuir o resultado √† posi√ß√£o do sistema. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta); transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido a isso, a c√¢mera se mover√° enquanto segura as setas ou WASD, mas n√£o a uma velocidade constante. </font><font style="vertical-align: inherit;">Isso depender√° da taxa de quadros. </font><font style="vertical-align: inherit;">Para determinar a dist√¢ncia que voc√™ precisa mover, usamos o delta do tempo, bem como a velocidade necess√°ria. </font><font style="vertical-align: inherit;">Portanto, adicionamos uma vari√°vel comum </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a definimos como 100, e a multiplicamos pelo delta do tempo para obter o delta da posi√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta) * distance; transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6da/1bc/307/6da1bc3074dc31868b934a35aaa31b10.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidade de movimento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos nos mover a uma velocidade constante ao longo dos eixos X ou Z. Mas, ao se mover nos dois eixos ao mesmo tempo (na diagonal), o movimento ser√° mais r√°pido. </font><font style="vertical-align: inherit;">Para corrigir isso, precisamos normalizar o vetor delta. </font><font style="vertical-align: inherit;">Isso permitir√° que voc√™ o use como destino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O movimento diagonal agora est√° implementado corretamente, mas de repente acontece que a c√¢mera continua se movendo por um longo tempo, mesmo depois de liberar todas as teclas. Isso acontece porque os eixos de entrada n√£o saltam instantaneamente para os valores limite imediatamente ap√≥s pressionar as teclas. Eles precisam de algum tempo para isso. O mesmo vale para a libera√ß√£o de chaves. Leva tempo para retornar aos valores do eixo zero. No entanto, como normalizamos os valores de entrada, a velocidade m√°xima √© mantida constantemente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ajustar os par√¢metros de entrada para eliminar os atrasos, mas eles proporcionam uma sensa√ß√£o de suavidade que vale a pena salvar. Podemos aplicar o valor mais extremo dos eixos como coeficiente de movimento de amortecimento.</font></font><br><br><pre> <code class="cs hljs"> Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * damping * Time.deltaTime;</code> </pre><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimento com atenua√ß√£o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, o movimento funciona bem, pelo menos com um aumento no zoom. </font><font style="vertical-align: inherit;">Mas, √† dist√¢ncia, acaba sendo muito lento. </font><font style="vertical-align: inherit;">Com zoom reduzido, precisamos acelerar. </font><font style="vertical-align: inherit;">Isso pode ser feito substituindo uma vari√°vel </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por duas para o zoom m√≠nimo e m√°ximo e, em seguida, interpolando. </font><font style="vertical-align: inherit;">Atribua a eles valores de 400 e 100.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public float moveSpeed; public float moveSpeedMinZoom, moveSpeedMaxZoom; void AdjustPosition (float xDelta, float zDelta) { Vector3 direction = new Vector3(xDelta, 0f, zDelta).normalized; float damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); float distance = Mathf.Lerp(moveSpeedMinZoom, moveSpeedMaxZoom, zoom) * damping * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/cb8/65e/5a9cb865ee0a67d4b3ad056317faf479.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A velocidade do movimento varia com o n√≠vel de zoom. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos nos mover rapidamente pelo mapa! </font><font style="vertical-align: inherit;">De fato, podemos ir muito al√©m do mapa, mas isso √© indesej√°vel. </font><font style="vertical-align: inherit;">A c√¢mera deve permanecer dentro do mapa. </font><font style="vertical-align: inherit;">Para garantir isso, precisamos conhecer os limites do mapa, para que seja necess√°rio um link para a grade. </font><font style="vertical-align: inherit;">Adicione e conecte-o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e71/f87/68e/e71f8768e16aee250700a7bd694a0e6b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisa solicitar o tamanho da grade. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de passar para uma nova posi√ß√£o, a limitaremos usando o novo m√©todo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = ClampPosition(position); } <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A posi√ß√£o X tem um valor m√≠nimo de 0 e o m√°ximo √© determinado pelo tamanho do mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O mesmo se aplica √† posi√ß√£o Z. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = grid.chunkCountZ * HexMetrics.chunkSizeZ * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, isso √© um pouco impreciso. </font><font style="vertical-align: inherit;">O ponto de partida est√° no centro da c√©lula, n√£o no lado esquerdo. </font><font style="vertical-align: inherit;">Portanto, queremos que a c√¢mera pare no centro das c√©lulas mais √† direita. </font><font style="vertical-align: inherit;">Para fazer isso, subtraia metade da c√©lula do m√°ximo de X.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.chunkCountX * HexMetrics.chunkSizeX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelo mesmo motivo, precisamos reduzir o Z m√°ximo. Como as m√©tricas s√£o um pouco diferentes, precisamos subtrair a c√©lula completa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.chunkCountZ * HexMetrics.chunkSizeZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com o movimento que terminamos, apenas um pequeno detalhe permanece. </font><font style="vertical-align: inherit;">√Äs vezes, a interface do usu√°rio reage √†s teclas de seta, e isso leva ao fato de que, quando voc√™ move a c√¢mera, o controle deslizante se move. </font><font style="vertical-align: inherit;">Isso acontece quando a interface do usu√°rio se considera ativa, depois que voc√™ clica nela e o cursor continua acima dela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode impedir que a interface do usu√°rio escute a entrada do teclado. </font><font style="vertical-align: inherit;">Isso pode ser feito </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruindo o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objeto </font><em><font style="vertical-align: inherit;">EventSystem a</font></em><font style="vertical-align: inherit;"> n√£o executar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enviar Eventos de Navega√ß√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/313/35c/00831335c530f6fcb06d4fe15890c316.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o h√° mais eventos de navega√ß√£o.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Turn </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quer ver o que est√° por tr√°s do penhasco? </font><font style="vertical-align: inherit;">Seria conveniente poder girar a c√¢mera! </font><font style="vertical-align: inherit;">Vamos adicionar esse recurso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√≠vel de zoom n√£o √© importante para a rota√ß√£o, apenas a velocidade √© suficiente. </font><font style="vertical-align: inherit;">Adicione uma vari√°vel comum </font></font><code>rotationSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e defina-a em 180 graus. </font><font style="vertical-align: inherit;">Verifique o delta de rota√ß√£o </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amostrando o eixo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rota√ß√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e alterando a rota√ß√£o, se necess√°rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Rotation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustRotation(rotationDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c17/189/c8f/c17189c8f16ef3e50aa8af32f7ff34c8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidade de giro. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, o eixo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rota√ß√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o </font><font style="vertical-align: inherit;">√© </font><font style="vertical-align: inherit;">por padr√£o. </font><font style="vertical-align: inherit;">Teremos que criar n√≥s mesmos. </font><font style="vertical-align: inherit;">V√° para os par√¢metros de entrada e duplique a entrada superior, na </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Altere o nome da duplicata para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rota√ß√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e altere as teclas para QE e uma v√≠rgula (,) com um ponto (.).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/6a8/50a/5496a850af906515b57a0d0fd1aea7b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gire o eixo de entrada.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixei o unitypackage, por que n√£o tenho essa entrada?</font></font></b> <div class="spoiler_text">     .       Unity.  ,     .    ,    ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O √¢ngulo de rota√ß√£o que rastrearemos e alteraremos </font></font><code>AdjustRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Depois disso, rodaremos todo o sistema da c√¢mera.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationAngle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como o c√≠rculo completo √© de 360 ‚Äã‚Äãgraus, rolamos o √¢ngulo de rota√ß√£o para que fique no intervalo de 0 a 360. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { rotationAngle += <span class="hljs-number"><span class="hljs-number">360f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &gt;= <span class="hljs-number"><span class="hljs-number">360f</span></span>) { rotationAngle -= <span class="hljs-number"><span class="hljs-number">360f</span></span>; } transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ligue em a√ß√£o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora a rota√ß√£o est√° funcionando. </font><font style="vertical-align: inherit;">Se voc√™ verificar, poder√° ver que o movimento √© absoluto. </font><font style="vertical-align: inherit;">Portanto, depois de girar 180 graus, o movimento ser√° o oposto do esperado. </font><font style="vertical-align: inherit;">Seria muito mais conveniente para o usu√°rio que o movimento seja realizado em rela√ß√£o ao √¢ngulo de vis√£o da c√¢mera. </font><font style="vertical-align: inherit;">Podemos fazer isso multiplicando a rota√ß√£o atual pela dire√ß√£o do movimento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = transform.localRotation * <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; ‚Ä¶ }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deslocamento relativo. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edi√ß√£o Avan√ßada </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos um mapa maior, voc√™ pode melhorar as ferramentas de edi√ß√£o de mapas. </font><font style="vertical-align: inherit;">A altera√ß√£o de uma c√©lula por vez √© muito longa, por isso seria bom criar um pincel maior. </font><font style="vertical-align: inherit;">Tamb√©m ser√° conveniente se voc√™ optar por pintar ou alterar a altura, deixando o resto inalterado.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cor e altura opcionais </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos tornar as cores opcionais adicionando uma op√ß√£o de sele√ß√£o vazia ao grupo de altern√¢ncia. </font><font style="vertical-align: inherit;">Duplique um dos comutadores de cores e substitua seu r√≥tulo por </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">---</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou algo semelhante para indicar que n√£o √© uma cor. </font><font style="vertical-align: inherit;">Em seguida, altere o argumento do evento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para -1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/786/485/b0c/786485b0cbbae8edee6c80873f19afc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√çndice de cores inv√°lido. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, esse √≠ndice n√£o √© v√°lido para uma matriz de cores. </font><font style="vertical-align: inherit;">Podemos us√°-lo para determinar se a cor deve ser aplicada √†s c√©lulas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { applyColor = index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { activeColor = colors[index]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } cell.Elevation = activeElevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A altura √© controlada por um controle deslizante, portanto, n√£o podemos adicionar uma op√ß√£o a ele. </font><font style="vertical-align: inherit;">Em vez disso, podemos usar uma op√ß√£o separada para ativar ou desativar a edi√ß√£o de altura. </font><font style="vertical-align: inherit;">Por padr√£o, ele ser√° ativado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um novo interruptor de altura √† interface do usu√°rio. </font><font style="vertical-align: inherit;">Tamb√©m colocarei tudo em um novo painel e tornarei o controle deslizante de altura horizontal para que a interface do usu√°rio fique mais bonita.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/cab/84d/07dcab84d8e8fe4daac4b6120df34d60.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cor e altura opcionais. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ativar a altura, precisamos de um novo m√©todo, o qual iremos conectar com a interface do usu√°rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyElevation = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao conect√°-lo √† chave de altura, verifique se o m√©todo bool din√¢mico √© usado na parte superior da lista de m√©todos. </font><font style="vertical-align: inherit;">As vers√µes corretas n√£o exibem uma marca de sele√ß√£o no inspetor.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/d5b/1b2/887d5b1b275cb18957b63bcbecf145d4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s transmitimos o status do interruptor de altura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos escolher apenas colorir com flores ou apenas altura. </font><font style="vertical-align: inherit;">Ou ambos, como sempre. </font><font style="vertical-align: inherit;">Podemos at√© optar por n√£o mudar um ou outro, mas at√© agora n√£o √© particularmente √∫til para n√≥s.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterne entre cor e altura.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que a altura √© desativada ao escolher uma cor?</font></font></b> <div class="spoiler_text">  ,       toggle group. ,          ,     toggle group. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamanho do pincel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para oferecer suporte ao tamanho redimension√°vel do pincel, adicione uma vari√°vel inteira </font></font><code>brushSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e um m√©todo para defini-lo por meio da interface do usu√°rio. </font><font style="vertical-align: inherit;">Usaremos o controle deslizante; portanto, novamente teremos que converter o valor de float para int.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brushSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBrushSize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span> { brushSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)size; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/794/bfb/60f/794bfb60f2f1c777fa0363ede3f19540.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controle deslizante de tamanho de pincel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode criar um novo controle deslizante duplicando o controle deslizante de altura. </font><font style="vertical-align: inherit;">Altere seu valor m√°ximo para 4 e anexe-o ao m√©todo correspondente. </font><font style="vertical-align: inherit;">Eu tamb√©m adicionei uma tag para ele.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/8b2/f58/88e8b2f58abfd48657387e6670c51215.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configura√ß√µes do controle deslizante de tamanho do pincel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que podemos editar v√°rias c√©lulas ao mesmo tempo, precisamos usar o m√©todo </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo exigir√° </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todas as c√©lulas envolvidas. </font><font style="vertical-align: inherit;">A c√©lula inicialmente selecionada ser√° considerada o centro do pincel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tamanho do pincel determina o raio da edi√ß√£o. </font><font style="vertical-align: inherit;">Com um raio de 0, essa ser√° apenas uma c√©lula central. </font><font style="vertical-align: inherit;">Com um raio de 1, este ser√° o centro e seus vizinhos. </font><font style="vertical-align: inherit;">Em um raio de 2, os vizinhos do centro e seus vizinhos imediatos s√£o ativados.</font></font> E assim por diante <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/14d/b65/61214db6508869c0ceda156c103ca032.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© o raio 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para editar as c√©lulas, voc√™ precisa contorn√°-las em um loop. </font><font style="vertical-align: inherit;">Primeiro, precisamos das coordenadas X e Z do centro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s encontramos a coordenada Z m√≠nima subtraindo o raio. </font><font style="vertical-align: inherit;">Ent√£o, definimos a linha zero. </font><font style="vertical-align: inherit;">Come√ßando nesta linha, percorremos at√© cobrir a linha no centro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira c√©lula na linha inferior tem a mesma coordenada X que a c√©lula central. </font><font style="vertical-align: inherit;">Essa coordenada diminui com o aumento do n√∫mero da linha. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima c√©lula sempre tem uma coordenada X igual √† coordenada central mais o raio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos fazer um loop em torno de cada linha e obter c√©lulas por suas coordenadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda n√£o temos um m√©todo </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um par√¢metro de coordenada, ent√£o crie-o. </font><font style="vertical-align: inherit;">Converta nas coordenadas dos deslocamentos e obtenha a c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/490/9f2/b594909f28de1c2d52c954d312d7b90f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A parte inferior do pincel, tamanho 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cobrimos o restante do pincel, realizando um ciclo de cima para baixo at√© o centro. </font><font style="vertical-align: inherit;">Nesse caso, a l√≥gica √© espelhada e a linha central precisa ser exclu√≠da.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ + brushSize; z &gt; centerZ; z--, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - brushSize; x &lt;= centerX + r; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/add/c7c/9e8addc7cf0012210cdd5dc0588bc6cf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pincel inteiro, tamanho 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso funciona, a menos que o pincel ultrapasse as bordas da grade. </font><font style="vertical-align: inherit;">Quando isso acontece, obtemos uma exce√ß√£o de √≠ndice fora da faixa. </font><font style="vertical-align: inherit;">Para evitar isso, verifique os limites </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e retorne </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando uma c√©lula inexistente for solicitada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || z &gt;= cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= cellCountX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar a exce√ß√£o de refer√™ncia nula, ele </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve verificar antes de editar se a c√©lula realmente existe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando v√°rios tamanhos de pincel. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alternar visibilidade do r√≥tulo da c√©lula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na maioria das vezes, n√£o precisamos ver os r√≥tulos das c√©lulas. </font><font style="vertical-align: inherit;">Ent√£o, vamos torn√°-los opcionais. </font><font style="vertical-align: inherit;">Como cada fragmento controla sua pr√≥pria tela, adicione um m√©todo </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Quando a interface do usu√°rio deve estar vis√≠vel, ativamos a tela. </font><font style="vertical-align: inherit;">Caso contr√°rio, desative-o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { gridCanvas.gameObject.SetActive(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos ocultar a interface do usu√°rio por padr√£o. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a visibilidade da interface do usu√°rio √© alterada para todo o mapa, adicionamos o m√©todo </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apenas passa a solicita√ß√£o para seus fragmentos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].ShowUI(visible); } }</code> </pre> <br> <code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obt√©m o mesmo m√©todo, passando a solicita√ß√£o para a grade. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { hexGrid.ShowUI(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por fim, podemos adicionar um switch √† interface do usu√°rio e conect√°-lo. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/637/740/120637740d174168d298407ec129c0d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudar a visibilidade da etiqueta. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 6: rios </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicionando rios √†s c√©lulas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arraste e solte o suporte para desenhar rios. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando leitos fluviais. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando v√°rias malhas por fragmento. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie um pool de listas compartilhadas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangula√ß√£o e anima√ß√£o de √°gua corrente. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte anterior, falamos sobre o suporte a mapas grandes. </font><font style="vertical-align: inherit;">Agora podemos passar para elementos de al√≠vio maiores. </font><font style="vertical-align: inherit;">Desta vez, falaremos sobre os rios.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e66/4fb/56ae664fb799dd59d5d8e85397945937.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios fluem das montanhas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√©lulas do rio </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem tr√™s maneiras de adicionar rios a uma grade de hex√°gonos. A primeira maneira √© deix√°-los fluir de c√©lula para c√©lula. √â assim que √© implementado no Endless Legend. A segunda maneira √© permitir que elas fluam entre as c√©lulas, de ponta a ponta. Por isso, √© implementado na Civiliza√ß√£o 5. A terceira maneira n√£o √© criar estruturas especiais de rios, mas usar c√©lulas de √°gua para sugeri-las. Portanto, os rios s√£o implementados no Age of Wonders 3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No nosso caso, as margens das c√©lulas j√° est√£o ocupadas por encostas e fal√©sias. Isso deixa pouco espa√ßo para rios. Portanto, vamos faz√™-los fluir de c√©lula para c√©lula. Isso significa que em cada c√©lula n√£o haver√° rio, ou um rio fluir√° ao longo dela, ou haver√° um come√ßo ou fim no rio. Nas c√©lulas ao longo das quais o rio flui, ele pode fluir reto, dar uma volta um passo ou dois passos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/db2/2a4/e7fdb22a4346f9281865ad95a1946f75.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinco configura√ß√µes poss√≠veis do rio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o apoiaremos a ramifica√ß√£o ou fus√£o de rios. </font><font style="vertical-align: inherit;">Isso complicar√° ainda mais as coisas, principalmente o fluxo de √°gua. </font><font style="vertical-align: inherit;">Al√©m disso, n√£o ficaremos intrigados com grandes volumes de √°gua. </font><font style="vertical-align: inherit;">Vamos consider√°-los em outro tutorial.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acompanhamento fluvial </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A c√©lula ao longo da qual o rio flui pode ser considerada simultaneamente como tendo um rio de entrada e sa√≠da. </font><font style="vertical-align: inherit;">Se ele cont√©m o come√ßo de um rio, ent√£o ele possui apenas um rio de sa√≠da. </font><font style="vertical-align: inherit;">E se ele cont√©m o final do rio, ent√£o ele tem apenas um rio que chega. </font><font style="vertical-align: inherit;">Podemos armazenar essas informa√ß√µes </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usando dois valores booleanos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso n√£o √© suficiente. </font><font style="vertical-align: inherit;">Tamb√©m precisamos saber a dire√ß√£o desses rios. </font><font style="vertical-align: inherit;">No caso de um rio de sa√≠da, indica para onde est√° se movendo. </font><font style="vertical-align: inherit;">No caso de um rio que entra, indica de onde veio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver; HexDirection incomingRiver, outgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos dessas informa√ß√µes ao triangular c√©lulas, portanto, adicionaremos propriedades para ter acesso a elas. </font><font style="vertical-align: inherit;">N√£o apoiaremos a atribui√ß√£o direta deles. </font><font style="vertical-align: inherit;">Para fazer isso, adicionaremos ainda um m√©todo separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasIncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasOutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasOutgoingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection IncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> incomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection OutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma quest√£o importante √© se existe um rio na c√©lula, independentemente dos detalhes. </font><font style="vertical-align: inherit;">Portanto, vamos adicionar uma propriedade para isso tamb√©m.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver || hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra quest√£o l√≥gica: √© o come√ßo ou o fim do rio na c√©lula. </font><font style="vertical-align: inherit;">Se o estado do rio de entrada e sa√≠da for diferente, esse √© apenas o caso. </font><font style="vertical-align: inherit;">Portanto, tornaremos essa outra propriedade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiverBeginOrEnd { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver != hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E, finalmente, ser√° √∫til saber se o rio flui atrav√©s de uma determinada cordilheira, se √© de entrada ou de sa√≠da. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRiverThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver &amp;&amp; incomingRiver == direction || hasOutgoingRiver &amp;&amp; outgoingRiver == direction; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remo√ß√£o do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de come√ßarmos a adicionar um rio a uma c√©lula, vamos primeiro implementar o suporte √† remo√ß√£o de rios. </font><font style="vertical-align: inherit;">Para come√ßar, escreveremos um m√©todo para remover apenas a parte que sai do rio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se n√£o houver rio de sa√≠da na c√©lula, nada precisar√° ser feito. </font><font style="vertical-align: inherit;">Caso contr√°rio, desligue-o e execute a atualiza√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso n√£o √© tudo. </font><font style="vertical-align: inherit;">O rio que sai deve seguir em algum lugar. </font><font style="vertical-align: inherit;">Portanto, deve haver um vizinho com o rio que chega. </font><font style="vertical-align: inherit;">Precisamos nos livrar dela tamb√©m.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.Refresh(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um rio n√£o pode fluir para fora de um mapa?</font></font></b> <div class="spoiler_text">      ,     .     ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A remo√ß√£o de um rio de uma c√©lula altera apenas a apar√™ncia dessa c√©lula. </font><font style="vertical-align: inherit;">Diferente da edi√ß√£o de altura ou cor, ela n√£o afeta os vizinhos. </font><font style="vertical-align: inherit;">Portanto, precisamos atualizar apenas a pr√≥pria c√©lula, mas n√£o seus vizinhos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse m√©todo </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplesmente atualiza o fragmento ao qual a c√©lula pertence. </font><font style="vertical-align: inherit;">Como n√£o mudamos o rio durante a inicializa√ß√£o da rede, n√£o precisamos nos preocupar se um fragmento j√° foi atribu√≠do.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A remo√ß√£o dos rios que chegam funciona da mesma maneira. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveIncomingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasIncomingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(incomingRiver); neighbor.hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E a remo√ß√£o de todo o rio significa simplesmente a remo√ß√£o de ambas as partes que entram e saem do rio. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RemoveOutgoingRiver(); RemoveIncomingRiver(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicionando rios </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para apoiar a cria√ß√£o de rios, precisamos de um m√©todo para especificar o rio de sa√≠da da c√©lula. </font><font style="vertical-align: inherit;">Ele deve redefinir todos os rios de sa√≠da anteriores e definir o rio de entrada correspondente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para come√ßar, n√£o precisamos fazer nada se o rio j√° existir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos garantir que haja um vizinho na dire√ß√£o certa. </font><font style="vertical-align: inherit;">Al√©m disso, os rios n√£o podem fluir. </font><font style="vertical-align: inherit;">Portanto, devemos concluir a opera√ß√£o se o vizinho for maior.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos limpar o rio de sa√≠da anterior. </font><font style="vertical-align: inherit;">E tamb√©m precisamos remover o rio que entra, se estiver sobreposto a um novo rio que sai.</font></font><br><br><pre> <code class="cs hljs"> RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora podemos avan√ßar para a cria√ß√£o do rio de sa√≠da. </font></font><br><br><pre> <code class="cs hljs"> hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; RefreshSelfOnly();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E n√£o se esque√ßa de definir o rio de entrada para outra c√©lula ap√≥s remover o rio de entrada atual, se ele existir. </font></font><br><br><pre> <code class="cs hljs"> neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.RefreshSelfOnly();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Livrar-se dos rios que correm </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que tornamos poss√≠vel adicionar apenas os rios certos, outras a√ß√µes ainda podem criar as erradas. </font><font style="vertical-align: inherit;">Quando mudamos a altura da c√©lula, devemos novamente garantir que os rios s√≥ possam fluir para baixo. </font><font style="vertical-align: inherit;">Todos os rios irregulares devem ser removidos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; elevation &lt; GetNeighbor(outgoingRiver).elevation ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; elevation &gt; GetNeighbor(incomingRiver).elevation ) { RemoveIncomingRiver(); } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mudar rios </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para dar suporte √† edi√ß√£o do rio, precisamos adicionar uma op√ß√£o de rio √† interface do usu√°rio. </font><font style="vertical-align: inherit;">De fato. </font><font style="vertical-align: inherit;">precisamos de suporte para tr√™s modos de edi√ß√£o. </font><font style="vertical-align: inherit;">Precisamos ignorar os rios, adicion√°-los ou exclu√≠-los. </font><font style="vertical-align: inherit;">Podemos usar uma enumera√ß√£o auxiliar simples de comutadores para rastrear o status. </font><font style="vertical-align: inherit;">Como o usaremos apenas dentro do editor, podemos defini-lo dentro da classe </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, junto com o campo do modo rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OptionalToggle { Ignore, Yes, No } OptionalToggle riverMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E precisamos de um m√©todo para alterar o regime fluvial por meio da interface do usu√°rio. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para controlar o regime do rio, adicione tr√™s switches √† interface do usu√°rio e conecte-os ao novo grupo de altern√¢ncia, como fizemos com as cores. </font><font style="vertical-align: inherit;">Eu configurei os switches para que seus r√≥tulos fiquem sob as caixas de sele√ß√£o. </font><font style="vertical-align: inherit;">Devido a isso, eles permanecer√£o finos o suficiente para caber nas tr√™s op√ß√µes em uma linha.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/1bf/d9c/0f51bfd9ce2a73bc23f1ef99cbd4b24e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios da interface do usu√°rio</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que n√£o usar uma lista suspensa?</font></font></b> <div class="spoiler_text">  ,    .   dropdown list  Unity        Play.    ,      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arrastar e soltar reconhecimento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar um rio, precisamos de uma c√©lula e uma dire√ß√£o. </font><font style="vertical-align: inherit;">No momento, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o nos fornece essas informa√ß√µes. </font><font style="vertical-align: inherit;">Portanto, precisamos adicionar suporte a arrastar e soltar de uma c√©lula para outra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos saber se esse arrasto ser√° correto e tamb√©m determinar sua dire√ß√£o. </font><font style="vertical-align: inherit;">E para reconhecer o arrastar e soltar, precisamos lembrar a c√©lula anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isDrag; HexDirection dragDirection; HexCell previousCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, quando o arrasto n√£o √© realizado, a c√©lula anterior n√£o √©. </font><font style="vertical-align: inherit;">Ou seja, quando n√£o h√° entrada ou n√£o interagimos com o cart√£o, voc√™ precisa atribuir um valor a ele </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A c√©lula atual √© a que encontramos cruzando a viga com a malha. </font><font style="vertical-align: inherit;">Ap√≥s editar as c√©lulas, ela √© atualizada e se torna a c√©lula anterior para uma nova atualiza√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); EditCells(currentCell); previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s determinar a c√©lula atual, podemos compar√°-la com a c√©lula anterior, se houver. </font><font style="vertical-align: inherit;">Se obtivermos duas c√©lulas diferentes, poderemos arrastar e soltar corretamente e precisamos verificar isso. </font><font style="vertical-align: inherit;">Caso contr√°rio, isso definitivamente n√£o √© um arrastar e soltar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } EditCells(currentCell); previousCell = currentCell; isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como verificamos o arrastar e soltar? </font><font style="vertical-align: inherit;">Verificando se a c√©lula atual √© vizinha da anterior. </font><font style="vertical-align: inherit;">Verificamos isso contornando seus vizinhos em um ciclo. </font><font style="vertical-align: inherit;">Se encontrarmos uma correspond√™ncia, tamb√©m reconhecemos imediatamente a dire√ß√£o do arrasto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDrag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell currentCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( dragDirection = HexDirection.NE; dragDirection &lt;= HexDirection.NW; dragDirection++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell.GetNeighbor(dragDirection) == currentCell) { isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar arrast√µes bruscos?</font></font></b> <div class="spoiler_text">       ,          .         ¬´¬ª ,     . <br><br>    ,   .            . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterar c√©lulas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que podemos reconhecer o arrastar e soltar, podemos definir os rios que saem. </font><font style="vertical-align: inherit;">Tamb√©m podemos remover rios; por isso, o suporte de arrastar e soltar n√£o √© necess√°rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { previousCell.SetOutgoingRiver(dragDirection); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este c√≥digo ir√° desenhar o rio da c√©lula anterior para a corrente. </font><font style="vertical-align: inherit;">Mas ele ignora o tamanho do pincel. </font><font style="vertical-align: inherit;">Isso √© bastante l√≥gico, mas vamos desenhar os rios para todas as c√©lulas fechadas pelo mato. </font><font style="vertical-align: inherit;">Isso pode ser feito executando opera√ß√µes na c√©lula editada. </font><font style="vertical-align: inherit;">No nosso caso, precisamos garantir que outra c√©lula realmente exista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { otherCell.SetOutgoingRiver(dragDirection); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos editar os rios, mas ainda n√£o os vemos. </font><font style="vertical-align: inherit;">Podemos verificar se isso funciona examinando as c√©lulas modificadas no inspetor de depura√ß√£o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/927/46f/4fe92746f97fc517dc0d1da7c0aeee62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma c√©lula com um rio no inspetor de depura√ß√£o.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que √© um inspetor de depura√ß√£o?</font></font></b> <div class="spoiler_text">             .        .    ,     . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leitos fluviais entre c√©lulas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao triangular um rio, precisamos considerar duas partes: a localiza√ß√£o do leito do rio e a √°gua que flui atrav√©s dele. </font><font style="vertical-align: inherit;">Primeiro, criaremos um canal e deixaremos a √°gua para mais tarde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A parte mais simples do rio √© onde ele flui em jun√ß√µes entre as c√©lulas. </font><font style="vertical-align: inherit;">Enquanto triangulamos esta √°rea com uma faixa de tr√™s quadrantes. </font><font style="vertical-align: inherit;">Podemos adicionar um leito de rio abaixando o quad do meio e adicionando duas paredes de canal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/545/b3c/b93/545b3cb9373e9479011916513c3c51da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionando um rio a uma tira de costela. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para isso, no caso do rio, ser√£o necess√°rios dois quadril√°teros adicionais e ser√° criado um canal com duas paredes verticais. </font><font style="vertical-align: inherit;">Uma abordagem alternativa √© usar quatro quad. </font><font style="vertical-align: inherit;">Ent√£o abaixamos o pico do meio para criar uma cama com paredes inclinadas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/7d9/ac1/7577d9ac1978be05cbdda0f8925c75d0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sempre quatro quad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso constante do mesmo n√∫mero de quadr√¢ngulos √© conveniente, ent√£o vamos escolher esta op√ß√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicionando Tops de Borda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A transi√ß√£o de tr√™s para quatro por aresta requer a cria√ß√£o de um v√©rtice adicional da aresta. </font><font style="vertical-align: inherit;">Reescrevemos </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro renomeando </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em seguida, renomeando </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As a√ß√µes nesta ordem garantem que todo o c√≥digo continue referenciando os v√©rtices corretos. </font><font style="vertical-align: inherit;">Use a op√ß√£o renomear ou refatorar do seu editor para fazer as altera√ß√µes serem aplicadas em todos os lugares. </font><font style="vertical-align: inherit;">Caso contr√°rio, voc√™ ter√° que inspecionar manualmente todo o c√≥digo e fazer altera√ß√µes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de renomear tudo, adicione um novo </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um novo v√©rtice ao construtor. </font><font style="vertical-align: inherit;">Est√° localizado no meio, entre os picos dos cantos. </font><font style="vertical-align: inherit;">Al√©m disso, agora outros v√©rtices devem estar em ¬Ω e ¬æ, e n√£o em &amp; frac13; </font><font style="vertical-align: inherit;">e &amp; frac23;.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e entre </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); result.v5 = HexMetrics.TerraceLerp(a.v5, b.v5, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora devo </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incluir um v√©rtice adicional nos ventiladores dos tri√¢ngulos da costela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); AddTriangle(center, edge.v4, edge.v5); AddTriangleColor(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E tamb√©m em suas faixas de quadril√°teros. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); AddQuadColor(c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/89d/599/81989d5996d7c2832e3dd7f61b4a9bb1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/9b1/6a2/6259b16a2776344c51725d32d70001e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compara√ß√£o de quatro e cinco v√©rtices por aresta.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A altura do leito do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos o canal abaixando a parte superior inferior da costela. </font><font style="vertical-align: inherit;">Determina a posi√ß√£o vertical do leito do rio. </font><font style="vertical-align: inherit;">Embora a posi√ß√£o vertical exata de cada c√©lula esteja distorcida, devemos manter a mesma altura do leito do rio em c√©lulas com a mesma altura. </font><font style="vertical-align: inherit;">Gra√ßas a essa √°gua, ela n√£o precisa fluir a montante. </font><font style="vertical-align: inherit;">Al√©m disso, o leito deve ser baixo o suficiente para permanecer abaixo, mesmo no caso das c√©lulas verticais mais desviadas, deixando ao mesmo tempo espa√ßo suficiente para a √°gua. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos definir esse deslocamento </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e express√°-lo como altura. </font><font style="vertical-align: inherit;">Compensa√ß√µes de um n√≠vel ser√£o suficientes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar essa m√©trica para adicionar propriedades </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obter a posi√ß√£o vertical do leito do rio da c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> StreamBedY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.streamBedElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando um canal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma das seis partes triangulares de uma c√©lula √© triangulada, podemos determinar se um rio flui ao longo de sua borda. </font><font style="vertical-align: inherit;">Nesse caso, podemos diminuir o pico m√©dio da costela at√© a altura do leito do rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; } TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0d/a57/028/d0da570288985442d990858b2831c07a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mude o v√©rtice do meio da nervura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ver como os primeiros sinais do rio aparecem, mas surgem buracos no relevo. </font><font style="vertical-align: inherit;">Para fech√°-las, precisamos alterar outra extremidade e triangular a conex√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/aa9/5f4/b4caa95f424004569e7876bc19c73a20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canais completos das articula√ß√µes das costelas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leitos fluviais passando atrav√©s de uma cela </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos os leitos corretos entre as c√©lulas. Mas quando o rio flui atrav√©s da c√©lula, os canais sempre terminam em seu centro. Para resolver este problema ter√° que funcionar. Vamos come√ßar com o caso em que um rio flui diretamente atrav√©s de uma c√©lula, de uma extremidade √† outra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se n√£o houver rio, cada parte da c√©lula pode ser um simples leque de tri√¢ngulos. Mas quando o rio flui diretamente, √© necess√°rio inserir um canal. De fato, precisamos esticar o v√©rtice central em uma linha, transformando os dois tri√¢ngulos do meio em quadr√¢ngulos. Ent√£o o leque de tri√¢ngulos se transforma em um trap√©zio.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a9/919/ffb/9a9919ffbb99bcded8d44f45e62c3955.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s inserimos o canal no tri√¢ngulo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses canais ser√£o muito mais longos do que aqueles que passam pela conex√£o de c√©lulas. </font><font style="vertical-align: inherit;">Isso se torna aparente quando as posi√ß√µes dos v√©rtices s√£o distorcidas. </font><font style="vertical-align: inherit;">Portanto, vamos dividir o trap√©zio em dois segmentos, inserindo outro conjunto de arestas de v√©rtices no meio entre o centro e a aresta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/f94/109/650f9410923cb781f145b5211dbe4950.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangula√ß√£o do canal. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a triangula√ß√£o com um rio ser√° muito diferente da triangula√ß√£o sem rio, vamos criar um m√©todo separado para isso. </font><font style="vertical-align: inherit;">Se temos um rio, usamos esse m√©todo, caso contr√°rio, deixaremos um leque de tri√¢ngulos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/f0f/526/928f0f526852960fce6c37bdb480b5bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buracos em que deveria haver rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ver melhor o que acontece, desative temporariamente a distor√ß√£o da c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 4f;</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2aa/f49/ae3/2aaf49ae366805585727f1a1ed11c2aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Picos sem distor√ß√£o.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangula√ß√£o diretamente atrav√©s da c√©lula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar um canal diretamente atrav√©s de parte da c√©lula, precisamos esticar o centro em uma linha. </font><font style="vertical-align: inherit;">Esta linha deve ter a mesma largura que o canal. </font><font style="vertical-align: inherit;">Podemos encontrar o v√©rtice esquerdo movendo ¬º da dist√¢ncia do centro para o primeiro canto da parte anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da mesma forma para o v√©rtice certo. </font><font style="vertical-align: inherit;">Nesse caso, precisamos do segundo canto da pr√≥xima parte.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; Vector3 centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A linha do meio pode ser encontrada criando arestas de v√©rtice entre o centro e a aresta. </font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, altere o v√©rtice do meio da costela do meio, bem como o centro, porque eles se tornar√£o os pontos mais baixos do canal. </font></font><br><br><pre> <code class="cs hljs"> m.v3.y = center.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para preencher o espa√ßo entre a linha do meio e a linha da aresta.</font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ab/050/b30/3ab050b301f8815479142c5b8feae26e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canais comprimidos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Infelizmente, os canais parecem compactados. Isso acontece porque os v√©rtices m√©dios da costela est√£o muito pr√≥ximos um do outro. Por que isso aconteceu? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se assumirmos que o comprimento da aresta externa √© 1, o comprimento da linha central ser√° ¬Ω. Como a borda do meio est√° localizada no meio entre eles, seu comprimento deve ser igual a ¬æ. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A largura do canal √© ¬Ω e deve permanecer constante. Como o comprimento da aresta do meio √© ¬æ, apenas ¬º permanece, de acordo com o &amp; frac18; nos dois lados do canal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e1/25f/037/2e125f03727f078ccfd094a29ad4d596.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprimentos relativos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o comprimento da aresta do meio √© ¬æ, o &amp; frac18; </font><font style="vertical-align: inherit;">torna-se relativo ao comprimento da costela m√©dia igual a &amp; frac16;. </font><font style="vertical-align: inherit;">Isso significa que seu segundo e quarto v√©rtices devem ser interpolados com sextos, n√£o com quartos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos fornecer suporte para essa interpola√ß√£o alternativa adicionando a </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outro construtor. </font><font style="vertical-align: inherit;">Em vez de interpola√ß√µes fixas para </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vamos usar um par√¢metro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outerStep</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, outerStep); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> - outerStep); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos us√°-lo com o &amp; frac16; </font><font style="vertical-align: inherit;">c </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4a/df8/cb5/c4adf8cb5aa6b1685f6d5c592976ea3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canais diretos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo tornado o canal reto, podemos ir para a segunda parte do trap√©zio. </font><font style="vertical-align: inherit;">Nesse caso, n√£o podemos usar a faixa de costela, portanto, temos que faz√™-lo manualmente. </font><font style="vertical-align: inherit;">Vamos primeiro criar tri√¢ngulos nas laterais.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/dc7/a5b/10bdc7a5b1d32d03dbc155a2d00bbfb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri√¢ngulos laterais. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece bom, ent√£o vamos preencher o espa√ßo restante com dois quadr√¢ngulos, criando a √∫ltima parte do canal.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddQuad(centerL, center, m.v2, m.v3); AddQuadColor(cell.Color); AddQuad(center, centerR, m.v3, m.v4); AddQuadColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, n√£o temos uma alternativa que </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exija apenas um par√¢metro. </font><font style="vertical-align: inherit;">Enquanto n√£o precis√°vamos disso. </font><font style="vertical-align: inherit;">Ent√£o, vamos cri√°-lo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af0/b62/c32/af0b62c3232b36cd0a136b1fc009b7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canais diretos conclu√≠dos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangula√ß√£o inicial e final </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A triangula√ß√£o de uma parte que tem apenas o come√ßo ou o fim de um rio √© bem diferente e, portanto, requer seu pr√≥prio m√©todo. </font><font style="vertical-align: inherit;">Portanto, verificaremos isso </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e chamaremos o m√©todo apropriado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, queremos concluir o canal no centro, mas ainda usamos duas etapas para isso. </font><font style="vertical-align: inherit;">Portanto, criaremos novamente a borda do meio entre o centro ou a borda. </font><font style="vertical-align: inherit;">Como queremos concluir o canal, estamos muito felizes por ele ser compactado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que o canal n√£o se torne raso muito rapidamente, atribuiremos a altura do leito do rio ao pico do meio. </font><font style="vertical-align: inherit;">Mas o centro n√£o precisa ser mudado.</font></font><br><br><pre> <code class="cs hljs"> m.v3.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos triangular com uma tira de costela e um ventilador. </font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16b/0c5/9e0/16b0c59e0999f2a505e709648c1e1af7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pontos inicial e final.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voltas em uma etapa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, considere as curvas fechadas em zigue-zague entre as c√©lulas adjacentes. </font><font style="vertical-align: inherit;">N√≥s vamos lidar com eles tamb√©m </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, precisamos determinar com que tipo de rio estamos trabalhando.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/523/c03/e37/523c03e370096f804df6b84a97dbdfbf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rio em zigue-zague. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a c√©lula tem um rio que flui na dire√ß√£o oposta, bem como na dire√ß√£o com a qual estamos trabalhando, ent√£o este deve ser um rio reto. </font><font style="vertical-align: inherit;">Nesse caso, podemos salvar a linha central que j√° calculamos. </font><font style="vertical-align: inherit;">Caso contr√°rio, ele retornar√° a um ponto, dobrando a linha central.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL, centerR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/992/4c0/90c9924c049cf8033e7480c90b74b903.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ziguezagues enrolados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos reconhecer curvas fechadas, verificando se a c√©lula tem um rio passando pela parte seguinte ou anterior da c√©lula. </font><font style="vertical-align: inherit;">Se houver, precisamos alinhar a linha central com a aresta entre esta e a parte vizinha. </font><font style="vertical-align: inherit;">Podemos fazer isso colocando o lado correspondente da linha no meio entre o centro e o √¢ngulo comum. </font><font style="vertical-align: inherit;">O outro lado da linha se torna o centro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tendo decidido onde est√£o os pontos esquerdo e direito, podemos determinar o centro resultante calculando a m√©dia deles. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { ‚Ä¶ } center = Vector3.Lerp(centerL, centerR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f14/cc6/4f9/f14cc64f953da69fb270ff2adf613b2e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costela central deslocada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora o canal tenha a mesma largura nos dois lados, ele parece bastante compactado. </font><font style="vertical-align: inherit;">Isso √© causado ao girar a linha central 60 ¬∞. </font><font style="vertical-align: inherit;">Voc√™ pode suavizar esse efeito aumentando ligeiramente a largura da linha central. </font><font style="vertical-align: inherit;">Em vez de interpolar com ¬Ω, usamos &amp; frac23;.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/c01/ea3/28cc01ea3d203243a1dfe49cde5e9802.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ziguezague sem compress√£o.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Curvas de dois est√°gios </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os casos restantes s√£o entre ziguezagues e rios retos. </font><font style="vertical-align: inherit;">S√£o curvas de dois est√°gios que criam rios suavemente curvos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/bab/9b2/67dbab9b235833d69b3201c9b38ac653.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O rio sinuoso. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para distinguir entre duas orienta√ß√µes poss√≠veis, precisamos usar </font></font><code>direction.Next().Next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas vamos torn√°-lo mais conveniente adicionando </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os m√©todos de extens√£o </font></font><code>Next2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Previous2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction -= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt;= HexDirection.NE ? direction : (direction + <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &lt;= HexDirection.NW ? direction : (direction - <span class="hljs-number"><span class="hljs-number">6</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voltar para </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agora podemos reconhecer a dire√ß√£o do nosso rio sinuoso com </font></font><code>direction.Next2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nestes dois √∫ltimos casos, precisamos mudar a linha central para a parte da c√©lula que est√° localizada no interior da curva. </font><font style="vertical-align: inherit;">Se tiv√©ssemos um vetor no meio de uma aresta s√≥lida, poder√≠amos us√°-lo para posicionar o ponto final. </font><font style="vertical-align: inherit;">Vamos imaginar que temos um m√©todo para isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Claro, agora precisamos adicionar esse m√©todo ao </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele s√≥ precisa calcular em m√©dia dois vetores de √¢ngulos adjacentes e aplicar o coeficiente de integridade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSolidEdgeMiddle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * solidFactor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be1/058/429/be1058429e3d36cd25b8e1da0c1be77a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curvas ligeiramente compactadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossas linhas centrais agora est√£o giradas corretamente 30 ¬∞. </font><font style="vertical-align: inherit;">Mas eles n√£o s√£o longos o suficiente, e √© por isso que os canais s√£o um pouco compactados. </font><font style="vertical-align: inherit;">Isso acontece porque o ponto m√©dio da costela est√° mais pr√≥ximo do centro do que o √¢ngulo da costela. </font><font style="vertical-align: inherit;">Sua dist√¢ncia √© igual ao raio interno, n√£o ao externo. </font><font style="vertical-align: inherit;">Ou seja, estamos trabalhando na escala errada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J√° estamos convertendo de raio externo para interno em </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Precisamos executar a opera√ß√£o reversa. </font><font style="vertical-align: inherit;">Ent√£o, vamos disponibilizar os dois fatores de convers√£o </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerToInner = <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerToOuter = <span class="hljs-number"><span class="hljs-number">1f</span></span> / outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos avan√ßar para a escala certa </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Os canais ainda permanecer√£o um pouco apertados devido √† sua vez, mas isso √© muito menos pronunciado do que no caso dos ziguezagues. </font><font style="vertical-align: inherit;">Portanto, n√£o precisamos compensar isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/849/49c/2a284949c066c558391613611b93d093.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curvas suaves. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangula√ß√£o nas proximidades de rios </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossos rios est√£o prontos. </font><font style="vertical-align: inherit;">Mas ainda n√£o triangulamos outras partes das c√©lulas que cont√™m os rios. </font><font style="vertical-align: inherit;">Agora vamos fechar esses buracos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/5fd/74d/f475fd74d147a577e8adb72cd1ff63fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buracos perto dos canais. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a c√©lula tiver um rio, mas n√£o fluir na dire√ß√£o atual, </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamaremos um novo m√©todo em.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateAdjacentToRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste m√©todo, preenchemos o tri√¢ngulo celular com uma faixa e um ventilador. </font><font style="vertical-align: inherit;">Apenas um ventilador n√£o ser√° suficiente para n√≥s, porque os picos devem corresponder √† borda do meio das partes que cont√™m o rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/059/4df/7bb/0594df7bb3225d20852c9e0d0d708101.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobreposi√ß√£o em curvas e rios retos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corresponder ao canal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â claro que precisamos fazer o centro que usamos corresponder √† parte central usada pelas partes do rio. </font><font style="vertical-align: inherit;">Com os ziguezagues, tudo est√° em ordem, e curvas e rios retos exigem aten√ß√£o. </font><font style="vertical-align: inherit;">Portanto, precisamos determinar o tipo de rio e sua orienta√ß√£o relativa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar verificando se estamos dentro da curva. </font><font style="vertical-align: inherit;">Nesse caso, as dire√ß√µes anterior e seguinte cont√™m o rio. </font><font style="vertical-align: inherit;">Nesse caso, precisamos mover o centro para a borda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } } EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/016/620/d89/016620d89847368d487d49bb1c81cdc7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrigido um caso em que o rio flui de ambos os lados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se temos um rio em uma dire√ß√£o diferente, mas n√£o na anterior, ent√£o verificamos se √© reto. </font><font style="vertical-align: inherit;">Nesse caso, mova o centro para o primeiro canto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/85a/366/a1d85a3669a55984eb69a43af5e8631f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrigida meia sobreposi√ß√£o com um rio reto. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o resolvemos o problema com metade das partes adjacentes aos rios retos. </font><font style="vertical-align: inherit;">O √∫ltimo caso - temos um rio na dire√ß√£o anterior e √© reto. </font><font style="vertical-align: inherit;">Nesse caso, voc√™ precisa mover o centro para a pr√≥xima esquina.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous()) &amp;&amp; cell.HasRiverThroughEdge(direction.Next2()) ) { center += HexMetrics.GetSecondSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9d/d1a/20c/c9dd1a20c213658aeed27b9065e6bf58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o h√° mais sobreposi√ß√µes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generaliza√ß√£o HexMesh </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclu√≠mos a triangula√ß√£o de canais. </font><font style="vertical-align: inherit;">Agora podemos ench√™-los com √°gua. </font><font style="vertical-align: inherit;">Como a √°gua √© diferente da terra, precisaremos usar uma malha diferente com diferentes dados de v√©rtices e materiais diferentes. </font><font style="vertical-align: inherit;">Seria bastante conveniente se pud√©ssemos usar </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sushi e √°gua. </font><font style="vertical-align: inherit;">Ent√£o, vamos generalizar </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, transformando-o em uma classe que lida com essas malhas, independentemente do que √© usado. </font><font style="vertical-align: inherit;">Vamos passar a tarefa de triangular suas c√©lulas </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movendo o m√©todo Perturb </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o m√©todo √© </font></font><code>Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bastante generalizado e ser√° usado em lugares diferentes, vamos para </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primeiro, renomeie-o para </font></font><code>HexMetrics.Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este √© um nome de m√©todo incorreto, mas refatora todo o c√≥digo para seu uso adequado. </font><font style="vertical-align: inherit;">Se o seu editor de c√≥digo tiver uma funcionalidade especial para mover m√©todos, use-o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movendo o m√©todo para dentro </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, torne-o geral e est√°tico e corrija seu nome.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©todos de triangula√ß√£o em movimento </font></font></h3><br><font style="vertical-align: inherit;"></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na mudan√ßa de vari√°veis </font></font><code>hexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na vari√°vel compartilhada </font></font><code>terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain; <span class="hljs-comment"><span class="hljs-comment">// HexMesh hexMesh; void Awake () { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = new HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seguir, refatoramos todos os m√©todos </font></font><code>Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>terrain.Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em seguida, mova todos os m√©todos </font></font><code>Triangulate‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Voc√™ pode ent√£o corrigir os nomes de m√©todos </font></font><code>Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e torn√°-los comum. </font><font style="vertical-align: inherit;">Como resultado, todos os m√©todos complexos de triangula√ß√£o ser√£o encontrados </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e m√©todos simples para adicionar dados √† malha permanecer√£o </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda n√£o terminamos. </font><font style="vertical-align: inherit;">Agora, ele </font></font><code>HexGridChunk.LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve chamar seu pr√≥prio m√©todo </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al√©m disso, n√£o deve mais passar c√©lulas como argumento. </font><font style="vertical-align: inherit;">Portanto, ele </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode perder seu par√¢metro. </font><font style="vertical-align: inherit;">E ele deve delegar a limpeza e aplica√ß√£o dos dados da malha </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Triangulate(); <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = false; } public void Triangulate () { terrain.Clear(); // hexMesh.Clear(); // vertices.Clear(); // colors.Clear(); // triangles.Clear(); for (int i = 0; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); // hexMesh.vertices = vertices.ToArray(); // hexMesh.colors = colors.ToArray(); // hexMesh.triangles = triangles.ToArray(); // hexMesh.RecalculateNormals(); // meshCollider.sharedMesh = hexMesh; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione os m√©todos necess√°rios </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); triangles.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); hexMesh.SetColors(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E as SetVertices, SetColors e SetTriangles?</font></font></b> <div class="spoiler_text">        <code>Mesh</code> .        .  ,           . <br><br>  <code>SetTriangles</code>    integer,    .      ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, anexe manualmente o filho da malha ao prefab do fragmento. </font><font style="vertical-align: inherit;">N√£o podemos mais fazer isso automaticamente, porque adicionaremos um segundo filho √† malha em breve. </font><font style="vertical-align: inherit;">Renomeie-o para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para indicar sua finalidade.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/614/3b4/0dc/6143b40dc88ecec6761348d9e6208944.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribua um al√≠vio.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renomear um filho pr√©-fabricado n√£o funciona?</font></font></b> <div class="spoiler_text">          .    ,   .  ,     <em>Apply</em> ,       .        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando pools de listas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora tenhamos movido bastante c√≥digo, nosso mapa ainda deve funcionar da mesma maneira que antes. </font><font style="vertical-align: inherit;">Adicionar outra malha ao fragmento n√£o mudar√° isso. </font><font style="vertical-align: inherit;">Mas se fizermos isso com o presente </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, poder√£o surgir erros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema √© que assumimos que trabalhar√≠amos apenas com uma malha por vez. </font><font style="vertical-align: inherit;">Isso nos permitiu usar listas est√°ticas para armazenar dados de malha tempor√°rios. </font><font style="vertical-align: inherit;">Mas, depois de adicionar √°gua, trabalharemos simultaneamente com duas malhas, para que n√£o possamos mais usar listas est√°ticas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, n√£o retornaremos aos conjuntos de listas para cada inst√¢ncia </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em vez disso, usamos um pool de listas est√°tico. </font><font style="vertical-align: inherit;">Por padr√£o, esse pool n√£o existe, ent√£o vamos come√ßar criando uma classe comum de pool de listas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o ListPool &lt;T&gt; funciona?</font></font></b> <div class="spoiler_text">     ,  <code>List&lt;int&gt;</code>    .  <code>&lt;T&gt;</code>    <code>ListPool</code> ,  ,    .      ,    <code>T</code> (  template). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para armazenar uma cole√ß√£o de listas em um pool, podemos usar a pilha. </font><font style="vertical-align: inherit;">Normalmente, n√£o uso listas porque o Unity n√£o as serializa, mas, neste caso, n√£o importa.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Stack&lt;List&lt;T&gt;&gt; stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;List&lt;T&gt;&gt;(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que significa stack &lt;list &lt;t&gt;&gt;?</font></font></b> <div class="spoiler_text">     .  ,     .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um m√©todo est√°tico comum para obter a lista do pool. </font><font style="vertical-align: inherit;">Se a pilha n√£o estiver vazia, extrairemos a lista superior e retornaremos esta. </font><font style="vertical-align: inherit;">Caso contr√°rio, criaremos uma nova lista no local.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stack.Pop(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para reutilizar listas, voc√™ precisa adicion√°-las ao pool depois de terminar de trabalhar com elas. </font></font><code>ListPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ir√° limpar a lista e coloc√°-la na pilha.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;T&gt; list</span></span></span><span class="hljs-function">)</span></span> { list.Clear(); stack.Push(list); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar as piscinas </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Substitua listas est√°ticas por links privados n√£o est√°ticos. </font><font style="vertical-align: inherit;">Vamos marc√°-los </font></font><code>NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que o Unity n√£o os preserve durante a recompila√ß√£o. </font><font style="vertical-align: inherit;">Ou escreva </font></font><code>System.NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou adicione </font></font><code>using System;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no in√≠cio do script.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">NonSerialized</span></span>] List&lt;Vector3&gt; vertices; [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-comment"><span class="hljs-comment">// static List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;(); // static List&lt;Color&gt; colors = new List&lt;Color&gt;(); // static List&lt;int&gt; triangles = new List&lt;int&gt;();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como a malha √© limpa logo antes de adicionar novos dados, √© aqui que voc√™ precisa obter listas dos pools. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); colors = ListPool&lt;Color&gt;.Get(); triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depois de aplicar essas malhas, n√£o precisamos mais delas, ent√£o aqui podemos adicion√°-las √†s piscinas. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Add(triangles); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por isso, implementamos o uso m√∫ltiplo de listas, independentemente de quantas malhas preenchermos ao mesmo tempo. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colisor opcional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora nosso terreno precise de um colisor, ele n√£o √© realmente necess√°rio para os rios. </font><font style="vertical-align: inherit;">Os raios simplesmente passar√£o pela √°gua e se cruzar√£o com o canal abaixo. </font><font style="vertical-align: inherit;">Vamos fazer para que possamos configurar a presen√ßa de um colisor para </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Percebemos isso adicionando um campo comum </font></font><code>bool useCollider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para terrenos, ligamos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/f19/a3c/4e7f19a3c7eb01a1432618a8be6903e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando um colisor de malha. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos criar e atribuir o colisor somente quando ele estiver ativado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); } hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider.sharedMesh = hexMesh; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cores opcionais </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As cores dos v√©rtices tamb√©m podem ser opcionais. </font><font style="vertical-align: inherit;">Precisamos deles para demonstrar v√°rios tipos de relevo, mas a √°gua n√£o muda de cor. </font><font style="vertical-align: inherit;">Podemos torn√°-los opcionais, assim como tornamos o colisor opcional.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obviamente, o terreno deve usar as cores dos v√©rtices, ent√£o ligue-os. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/624/c01/bbd/624c01bbda8ad0250747b9c1af852590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso de cores.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UV opcional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enquanto fazemos isso, tamb√©m podemos adicionar suporte para coordenadas UV opcionais. </font><font style="vertical-align: inherit;">Embora o al√≠vio n√£o os use, precisaremos deles para obter √°gua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates; [NonSerialized] List&lt;Vector2&gt; uvs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/a99/559/b01a9955989cdc83a2e8de2582c1cbeb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s n√£o usamos coordenadas UV. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para usar esta fun√ß√£o, crie m√©todos para adicionar coordenadas UV a tri√¢ngulos e quadr√¢ngulos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); uvs.Add(uv4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos adicionar um m√©todo adicional </font></font><code>AddQuadUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para adicionar convenientemente uma √°rea UV retangular. </font><font style="vertical-align: inherit;">Este √© o caso padr√£o quando o quadril√°tero e sua textura s√£o os mesmos, vamos us√°-lo para a √°gua do rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rios atuais </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, √© hora de criar √°gua! </font><font style="vertical-align: inherit;">Faremos isso com um quad, que indicar√° a superf√≠cie da √°gua. </font><font style="vertical-align: inherit;">E como trabalhamos com rios, a √°gua deve fluir. </font><font style="vertical-align: inherit;">Para fazer isso, usamos coordenadas UV indicando a orienta√ß√£o do rio. </font><font style="vertical-align: inherit;">Para visualizar isso, precisamos de um novo shader. </font><font style="vertical-align: inherit;">Portanto, crie um novo shader padr√£o e chame-o de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Altere-o para que as coordenadas UV sejam gravadas nos canais verde e vermelho do albedo.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/River" { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo geral </font></font><code>HexMesh rivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">N√≥s limpamos e aplicamos da mesma maneira que no caso de al√≠vio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teremos chamadas adicionais, mesmo que n√£o tenhamos rios?</font></font></b> <div class="spoiler_text">  Unity  ,        .     ,  -  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altere a pr√©-fabricada (por meio da inst√¢ncia), duplicando seu objeto de terreno, renomeando-o para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e conectando-o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/0d6/680/efd0d66801d78d636d07f59b34e5c615.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/119/b43/e46119b43f4cd398d96261715975a36a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmento pr√©-fabricado com rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie o material </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando nosso novo shader e fa√ßa com que o objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> use </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tamb√©m configuramos o componente de malha hexagonal do objeto para que ele use coordenadas UV, mas n√£o use cores de v√©rtice ou colisor.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/db6/134/7dfdb6134b4dc27d843db92492b61708.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subobjeto Rivers.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ågua triangulada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de podermos triangular a √°gua, precisamos determinar o n√≠vel de sua superf√≠cie. </font><font style="vertical-align: inherit;">Vamos fazer uma mudan√ßa de altura </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como fizemos com o leito do rio. </font><font style="vertical-align: inherit;">Como a distor√ß√£o vertical da c√©lula √© igual a metade da mudan√ßa de altura, vamos us√°-la para mudar a superf√≠cie do rio. </font><font style="vertical-align: inherit;">Portanto, garantimos que a √°gua nunca estar√° acima da topografia da c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> riverSurfaceElevationOffset = <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que n√£o diminuir um pouco?</font></font></b> <div class="spoiler_text">          ,   . ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione uma </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade para obter a posi√ß√£o vertical da superf√≠cie do rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.riverSurfaceElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos trabalhar </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Como criaremos muitos quadr√¢ngulos de rios, vamos adicionar um m√©todo separado para isso. </font><font style="vertical-align: inherit;">Vamos dar quatro v√©rtices e uma altura como par√¢metros. </font><font style="vertical-align: inherit;">Isso nos permitir√° definir convenientemente a posi√ß√£o vertical de todos os quatro v√©rtices simultaneamente antes de adicionar quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos adicionar aqui as coordenadas UV do quadril√°tero. </font><font style="vertical-align: inherit;">Basta girar da esquerda para a direita e de baixo para cima.</font></font><br><br><pre> <code class="cs hljs"> rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br> <code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Este √© o primeiro m√©todo ao qual adicionaremos os quadr√¢ngulos dos rios. </font><font style="vertical-align: inherit;">O primeiro quad est√° entre o centro e o meio. </font><font style="vertical-align: inherit;">O segundo √© entre o meio e a costela. </font><font style="vertical-align: inherit;">N√≥s apenas usamos os v√©rtices que j√° temos. </font><font style="vertical-align: inherit;">Como esses picos ser√£o subestimados, a √°gua ficar√° parcialmente sob as paredes inclinadas do canal. </font><font style="vertical-align: inherit;">Portanto, n√£o precisamos nos preocupar com a posi√ß√£o exata da beira da √°gua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateRiverQuad(centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY); TriangulateRiverQuad(m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/418/a40/e9c/418a40e9c73fd3da885ce467e475ff63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os primeiros sinais de √°gua. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que a largura da √°gua muda?</font></font></b> <div class="spoiler_text">  ,     ,      ‚Äî .           .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movendo-se com o fluxo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualmente, as coordenadas UV n√£o s√£o consistentes com a dire√ß√£o do rio. </font><font style="vertical-align: inherit;">Precisamos manter a consist√™ncia aqui. </font><font style="vertical-align: inherit;">Suponha que a coordenada U seja 0 no lado esquerdo do rio e 1 no direito, ao olhar rio abaixo. </font><font style="vertical-align: inherit;">E a coordenada V deve variar de 0 a 1 na dire√ß√£o do rio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando esta especifica√ß√£o, os UVs estar√£o corretos quando o rio de sa√≠da for triangulado, mas eles ficar√£o incorretos e precisar√£o ser revertidos quando o rio de entrada for triangulado. </font><font style="vertical-align: inherit;">Para tornar mais f√°cil, adicione um </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√¢metro </font></font><code>bool reversed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Use-o para virar UV, se necess√°rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sabemos que precisamos virar a dire√ß√£o, quando se lida com o rio entrada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/546/c86/e9d/546c86e9d2d8752caa30523098283542.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A dire√ß√£o acordada dos rios.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O come√ßo e o fim do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No interior, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisamos apenas verificar se temos um rio de entrada para determinar a dire√ß√£o do fluxo. </font><font style="vertical-align: inherit;">Ent√£o podemos inserir outro rio quad entre o meio e a costela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A parte entre o centro e o meio √© um tri√¢ngulo, por isso n√£o podemos us√°-lo </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A √∫nica diferen√ßa significativa aqui √© que o pico central est√° no meio do rio. </font><font style="vertical-align: inherit;">Portanto, sua coordenada U √© sempre igual a ¬Ω.</font></font><br><br><pre> <code class="cs hljs"> center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/07f/539/c0407f539ce2ff6a91081e84062a4097.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ågua no come√ßo e no fim.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faltam por√ß√µes de √°gua nas extremidades?</font></font></b> <div class="spoiler_text">       ,   quad  ,     .           .           . <br><br>      ,  .     ,      .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluxo entre c√©lulas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao adicionar √°gua entre as c√©lulas, devemos ter cuidado com a diferen√ßa de altura. </font><font style="vertical-align: inherit;">Para que a √°gua possa fluir ladeiras e fal√©sias, ela </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve suportar dois par√¢metros de altura. </font><font style="vertical-align: inherit;">Ent√£o, vamos adicionar um segundo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, por conveni√™ncia, vamos adicionar uma op√ß√£o que receber√° uma altura. </font><font style="vertical-align: inherit;">Apenas chamar√° outro m√©todo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, reversed); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos adicionar quad river e in </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Estando entre as c√©lulas, n√£o podemos descobrir imediatamente com que tipo de rio estamos lidando. </font><font style="vertical-align: inherit;">Para determinar se um giro √© necess√°rio, precisamos verificar se temos um rio recebido e se ele est√° se movendo em nossa dire√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/1f2/62e/2831f262ed46e82bebabf45d0a8215f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O rio conclu√≠do.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alongamento de coordenadas V </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, em cada segmento do rio, temos coordenadas V indo de 0 a 1. Ou seja, existem apenas quatro delas na c√©lula. Cinco se tamb√©m adicionarmos conex√µes entre c√©lulas. Tudo o que usamos para texturizar o rio, ele deve ser repetido tantas vezes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos reduzir o n√∫mero de repeti√ß√µes esticando as coordenadas V para que elas passem de 0 a 1 por toda a c√©lula mais uma conex√£o. Isso pode ser feito aumentando a coordenada V em cada segmento em 0,2. Se colocarmos 0,4 no centro, ent√£o no meio ele se tornar√° 0,6 e na borda chegar√° a 0,8. Em seguida, na conex√£o da c√©lula, o valor ser√° 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o rio fluir na dire√ß√£o oposta, ainda podemos colocar 0,4 no centro, mas no meio ele se tornar√° 0,2 e na margem - 0. Se continuarmos at√© a c√©lula se unir, o resultado ser√° -0,2. </font><font style="vertical-align: inherit;">Isso √© normal porque √© semelhante a 0,8 para uma textura com modo de filtragem repetida, assim como 0 √© equivalente a 1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22e/4de/cd9/22e4decd99e9c2f0c9312be9eaaceb9a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudan√ßa de coordenadas V.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para criar suporte para isso, precisamos adicionar </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais um par√¢metro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando a dire√ß√£o n√£o √© invertida, simplesmente usamos a coordenada transmitida na parte inferior do quadril√°tero e adicionamos 0,2 na parte superior. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, v, v + <span class="hljs-number"><span class="hljs-number">0.2f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos trabalhar com uma dire√ß√£o invertida subtraindo a coordenada de 0,8 e 0,6. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span> - v, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> - v); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora devemos transmitir as coordenadas corretas, como se estiv√©ssemos lidando com um rio que sai. </font><font style="vertical-align: inherit;">Vamos come√ßar com </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alterar o seguinte.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/786/63f/44e78663f2d77264660f30917a5e1a94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenadas esticadas em V.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para exibir corretamente o dobramento das coordenadas em V, verifique se elas permanecem positivas no sombreador de rio.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; } o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/30e/a84/aec30ea849af0c8ba42cd6e0cef44635.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenadas </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">recolhidas </font></a><i><font style="vertical-align: inherit;">V. </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anima√ß√£o do rio </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo terminado com as coordenadas UV, podemos passar a animar os rios. O shader do rio far√° isso para que n√£o tenhamos que atualizar constantemente a malha. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o criaremos um shader de rio complexo neste tutorial, mas o faremos mais tarde. Por enquanto, criaremos um efeito simples que permita entender como a anima√ß√£o funciona. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A anima√ß√£o √© criada alterando as coordenadas V com base no tempo do jogo. O Unity permite que voc√™ obtenha seu valor usando uma vari√°vel </font></font><code>_Time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seu componente Y cont√©m o tempo inalterado que usamos. Outros componentes cont√™m diferentes escalas de tempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos nos livrar da dobra ao longo de V, porque n√£o precisamos mais dela. Em vez disso, subtra√≠mos o tempo atual da coordenada V. Isso muda a coordenada para baixo, o que cria a ilus√£o da corrente que flui a jusante do rio.</font></font><br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; // } <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em um segundo, a coordenada V em todos os pontos se tornar√° menor que zero, portanto n√£o veremos mais a diferen√ßa. </font><font style="vertical-align: inherit;">Novamente, isso √© normal ao usar a filtragem no modo de repeti√ß√£o de textura. </font><font style="vertical-align: inherit;">Mas, para ver o que acontece, podemos pegar a parte fracion√°ria da coordenada V.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y = frac(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y); o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenadas em V animadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uso de ru√≠do </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora nosso rio est√° animado, mas na dire√ß√£o e velocidade h√° transi√ß√µes n√≠tidas. </font><font style="vertical-align: inherit;">Nosso padr√£o UV os torna bastante √≥bvios, mas ser√° mais dif√≠cil reconhecer se voc√™ usar um padr√£o mais parecido com a √°gua. </font><font style="vertical-align: inherit;">Ent√£o, em vez de exibir UV cru, vamos provar a textura. </font><font style="vertical-align: inherit;">Podemos usar nossa textura de ru√≠do existente. </font><font style="vertical-align: inherit;">N√≥s o amostramos e multiplicamos a cor do material pelo primeiro canal de ru√≠do.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.y -= _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); fixed4 c = _Color * noise.r; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atribua a textura do ru√≠do ao material do rio e verifique se ele √© branco. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/dd4/e4e/dc8dd4e4ee9b92f2f104ba3107da30ce.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3f/0ca/319/b3f0ca31928fd594a715868ebbb7265c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando textura de ru√≠do. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as coordenadas V s√£o muito esticadas, a textura do ru√≠do tamb√©m se estende ao longo do rio. </font><font style="vertical-align: inherit;">Infelizmente, o curso n√£o √© muito bonito. </font><font style="vertical-align: inherit;">Vamos tentar estic√°-lo de outra maneira - reduzir bastante a escala das coordenadas de U. Um d√©cimo sexto ser√° suficiente. </font><font style="vertical-align: inherit;">Isso significa que apenas amostraremos uma faixa estreita de textura de ru√≠do.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x *= <span class="hljs-number"><span class="hljs-number">0.0625</span></span>; uv.y -= _Time.y;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/957/2a9/aa99572a9c0ad3daaa7b5b4eb3978cc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alongando a coordenada U.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos tamb√©m diminuir para um quarto por segundo, para que a conclus√£o do ciclo de textura leve quatro segundos.</font></font><br><br><pre> <code class="hljs"> uv.y -= _Time.y * 0.25;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O barulho atual.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mistura de ru√≠do </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo j√° parece muito melhor, mas o padr√£o sempre permanece o mesmo. A √°gua n√£o se comporta assim. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como usamos apenas uma pequena faixa de ru√≠do, podemos variar o padr√£o deslocando essa faixa ao longo da textura. Isso √© feito adicionando tempo √† coordenada U. Devemos faz√™-lo lentamente, caso contr√°rio o rio parecer√° fluir de lado. Vamos tentar o coeficiente de 0,005. Isso significa que s√£o necess√°rios 200 segundos para concluir o padr√£o.</font></font><br><br><pre> <code class="hljs markdown"> uv.x = uv.x <span class="hljs-bullet"><span class="hljs-bullet">* 0.0625 + _Time.y *</span></span> 0.005;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barulho em movimento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, isso n√£o parece muito bonito. </font><font style="vertical-align: inherit;">A √°gua ainda parece est√°tica e a mudan√ßa √© claramente percept√≠vel, embora seja muito lenta. </font><font style="vertical-align: inherit;">Podemos ocultar a mudan√ßa combinando duas amostras de ru√≠do e deslocando-as em dire√ß√µes opostas. </font><font style="vertical-align: inherit;">E se usarmos valores ligeiramente diferentes para mover a segunda amostra, criaremos uma anima√ß√£o leve da mudan√ßa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, como resultado, nunca sobrepomos o mesmo padr√£o de ru√≠do, usamos um canal diferente para a segunda amostra.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2); fixed4 c = _Color * (noise.r * noise2.a);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma combina√ß√£o de dois padr√µes de ru√≠do vari√°veis.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ågua transl√∫cida </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso padr√£o parece bastante din√¢mico. </font><font style="vertical-align: inherit;">O pr√≥ximo passo √© torn√°-lo transl√∫cido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, verifique se a √°gua n√£o projeta sombras. </font><font style="vertical-align: inherit;">Voc√™ pode desativ√°-los atrav√©s do componente renderizador do objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na pr√©-fabricada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a61/894/e14/a61894e14d9999315d59b5ff0c0de517.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A proje√ß√£o de sombra est√° desativada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora mude o sombreador para o modo transparente. </font><font style="vertical-align: inherit;">Para indicar isso, use tags shader. </font><font style="vertical-align: inherit;">Em seguida, adicione a </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">palavra </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">chave </font><font style="vertical-align: inherit;">√† linha </font></font><code>alpha</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Enquanto estamos aqui, voc√™ pode remover a palavra-chave </font></font><code>fullforwardshadows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque ainda n√£o projetamos sombras.</font></font><br><br><pre> <code class="hljs cs"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard alpha // fullforwardshadows #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.0</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos mudar a maneira como definimos a cor do rio. </font><font style="vertical-align: inherit;">Em vez de multiplicar o ru√≠do por cor, adicionaremos ru√≠do a ele. </font><font style="vertical-align: inherit;">Em seguida, usamos a fun√ß√£o </font></font><code>saturate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para limitar o resultado para que n√£o exceda 1.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = saturate(_Color + noise.r * noise2.a);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso nos permitir√° usar a cor do material como cor de base. </font><font style="vertical-align: inherit;">O ru√≠do aumentar√° seu brilho e opacidade. </font><font style="vertical-align: inherit;">Vamos tentar usar uma cor azul com uma opacidade bastante baixa. </font><font style="vertical-align: inherit;">Como resultado, obtemos √°gua transl√∫cida azul com salpicos brancos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/3f7/5a1/af83f75a143aabdd3b83525e4114fc3b.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ågua transl√∫cida colorida. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclus√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que tudo parece estar funcionando, √© hora de distorcer os picos novamente. </font><font style="vertical-align: inherit;">Al√©m de deformar as bordas das c√©lulas, isso tornar√° nossos rios irregulares.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c8/ff5/96b/8c8ff596bc247be79a30122e49ca27f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ca/664/808/6ca66480859e94d00e2e558caa17cbf4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Picos distorcidos e distorcidos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos examinar o terreno em busca de problemas que surgiram devido √† distor√ß√£o. </font><font style="vertical-align: inherit;">Parece que eles s√£o! </font><font style="vertical-align: inherit;">Vamos conferir as cachoeiras altas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/95b/a33/df195ba33947744e97173412373f5ad4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ågua truncada por fal√©sias.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A √°gua que cai de uma cachoeira alta desaparece atr√°s de um penhasco. Quando isso acontece, √© muito percept√≠vel, por isso precisamos fazer algo a respeito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muito menos √≥bvio √© que as cachoeiras podem estar inclinadas, em vez de descer diretamente. Embora a √°gua na realidade n√£o flua dessa maneira, ela n√£o √© particularmente percept√≠vel. Nosso c√©rebro ir√° interpret√°-lo de tal maneira que parece normal para n√≥s. Ent√£o apenas ignore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais f√°cil de evitar a perda de √°gua √© aprofundando os leitos dos rios. Ent√£o, criaremos mais espa√ßo entre a superf√≠cie da √°gua e o leito do rio. Isso tamb√©m tornar√° as paredes do canal mais verticais, para n√£o ir muito fundo. Vamos perguntar</font></font><code>HexMetrics.streamBedElevationOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor -1,75. </font><font style="vertical-align: inherit;">Isso resolver√° a maior parte dos problemas e a cama n√£o ficar√° muito profunda. </font><font style="vertical-align: inherit;">Parte da √°gua ainda ser√° cortada, mas n√£o as cachoeiras inteiras.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1.75f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/80c/d26/57b80cd2687ff6afb9be83176e984b7d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canais detalhados. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 7: estradas </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione suporte rodovi√°rio. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangular a estrada. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combinamos estradas e rios. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Melhorando a apar√™ncia das estradas. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f7/b24/05e/9f7b2405e5ceed9842cc1ebd7b549b0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os primeiros sinais da civiliza√ß√£o.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√©lulas com estradas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como rios, as estradas passam de c√©lula em c√©lula, atrav√©s do meio das bordas da c√©lula. </font><font style="vertical-align: inherit;">A grande diferen√ßa √© que n√£o h√° √°gua fluindo nas estradas, portanto elas s√£o bidirecionais. </font><font style="vertical-align: inherit;">Al√©m disso, s√£o necess√°rias interse√ß√µes para uma rede vi√°ria funcional, portanto, precisamos oferecer suporte a mais de duas estradas por c√©lula. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ permitir que as estradas sigam nas seis dire√ß√µes, a c√©lula poder√° conter de zero a seis estradas. </font><font style="vertical-align: inherit;">Isso √© um total de quatorze configura√ß√µes poss√≠veis de estradas. </font><font style="vertical-align: inherit;">Isso √© muito mais do que cinco configura√ß√µes poss√≠veis de rios. </font><font style="vertical-align: inherit;">Para lidar com isso, precisamos usar uma abordagem mais geral que possa lidar com todas as configura√ß√µes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/965/5b7/d469655b7efdbab33a6cac1c42e61a7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14 poss√≠veis configura√ß√µes de estrada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastreamento rodovi√°rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais simples de rastrear estradas em uma c√©lula √© usar uma matriz de valores booleanos. </font><font style="vertical-align: inherit;">Adicione o campo privado da matriz </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e torne-o serializ√°vel para que voc√™ possa v√™-lo no inspetor. </font><font style="vertical-align: inherit;">Defina o tamanho da matriz atrav√©s da prefab da c√©lula para suportar seis estradas.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] roads;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/167/2c4/4391672c4c1de9075138eef3f1cafd73.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela pr√©-fabricada com seis estradas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um m√©todo para verificar se a c√©lula possui um caminho em uma determinada dire√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRoadThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m ser√° conveniente saber se h√° pelo menos uma estrada na c√©lula, portanto, adicionaremos uma propriedade para isso. </font><font style="vertical-align: inherit;">Basta percorrer a matriz no loop e retornar </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assim que encontrarmos o caminho. </font><font style="vertical-align: inherit;">Se n√£o houver estradas, volte </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRoads { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remo√ß√£o de estradas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como nos rios, adicionaremos um m√©todo para remover todas as estradas da c√©lula. </font><font style="vertical-align: inherit;">Isso pode ser feito com um loop que desconecta todas as estradas que foram ativadas anteriormente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obviamente, tamb√©m precisamos desativar as c√©lulas caras correspondentes nos vizinhos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois disso, precisamos atualizar cada uma das c√©lulas. </font><font style="vertical-align: inherit;">Como as estradas s√£o locais para as c√©lulas, precisamos atualizar apenas as pr√≥prias c√©lulas sem seus vizinhos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicionando estradas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionar estradas √© semelhante a remover estradas. </font><font style="vertical-align: inherit;">A √∫nica diferen√ßa √© que atribu√≠mos um valor a booleano </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, n√£o </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Podemos criar um m√©todo privado que pode executar as duas opera√ß√µes. </font><font style="vertical-align: inherit;">Ent√£o ser√° poss√≠vel us√°-lo para adicionar e remover a estrada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { roads[index] = state; neighbors[index].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)index).Opposite()] = state; neighbors[index].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o podemos ter um rio e uma estrada seguindo na mesma dire√ß√£o ao mesmo tempo. </font><font style="vertical-align: inherit;">Portanto, antes de adicionar a estrada, verificaremos se h√° um local para ela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction)) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, as estradas n√£o podem ser combinadas com fal√©sias porque s√£o muito afiadas. </font><font style="vertical-align: inherit;">Ou talvez valha a pena abrir o caminho atrav√©s de um penhasco baixo, mas n√£o atrav√©s de um alto? </font><font style="vertical-align: inherit;">Para determinar isso, precisamos criar um m√©todo que nos diga a diferen√ßa de altura em uma determinada dire√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElevationDifference</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> difference = elevation - GetNeighbor(direction).elevation; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> difference &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? difference : -difference; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos fazer com que as estradas aumentem a uma diferen√ßa de altura suficientemente pequena. </font><font style="vertical-align: inherit;">Vou me limitar apenas a declives, ou seja, no m√°ximo 1 unidade.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remo√ß√£o das estradas erradas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tornamos as estradas adicionadas apenas quando permitidas. </font><font style="vertical-align: inherit;">Agora precisamos garantir que eles sejam removidos se, posteriormente, se tornarem incorretos, por exemplo, ao adicionar um rio. </font><font style="vertical-align: inherit;">Podemos proibir a coloca√ß√£o de rios no topo das estradas, mas os rios n√£o s√£o interrompidos pelas estradas. </font><font style="vertical-align: inherit;">Deixe-os lavar a estrada fora do caminho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√° o suficiente para pedirmos a estrada </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, independentemente de ser a estrada. </font><font style="vertical-align: inherit;">N√£o vai ser sempre atualizado ambas as c√©lulas, de modo que n√£o temos mais necessidade de chamar explicitamente </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; <span class="hljs-comment"><span class="hljs-comment">// RefreshSelfOnly(); neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = true; neighbor.incomingRiver = direction.Opposite(); // neighbor.RefreshSelfOnly(); SetRoad((int)direction, false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra opera√ß√£o que pode dar errado na estrada √© uma mudan√ßa de altura. </font><font style="vertical-align: inherit;">Nesse caso, teremos que procurar estradas em todas as dire√ß√µes. </font><font style="vertical-align: inherit;">Se a diferen√ßa de altura for muito grande, a estrada existente precisar√° ser exclu√≠da.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i] &amp;&amp; GetElevationDifference((HexDirection)i) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edi√ß√£o de estradas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A edi√ß√£o de estradas funciona como a edi√ß√£o de rios. </font><font style="vertical-align: inherit;">Portanto </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √© necess√°ria mais uma op√ß√£o, al√©m de um m√©todo para definir seu estado.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoadMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { roadMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora deve apoiar a remo√ß√£o com a adi√ß√£o de estradas. </font><font style="vertical-align: inherit;">Isso significa que, ao arrastar e soltar, ele pode executar uma das duas a√ß√µes poss√≠veis. </font><font style="vertical-align: inherit;">Estamos reestruturando um pouco o c√≥digo para que, ao executar o arrastar e soltar correto, os estados de ambos os comutadores sejam verificados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.Yes) { otherCell.SetOutgoingRiver(dragDirection); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.Yes) { otherCell.AddRoad(dragDirection); } } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos adicionar rapidamente uma barra de estrada √† interface do usu√°rio copiando a barra do rio e alterando o m√©todo chamado pelos comutadores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtemos uma interface do usu√°rio bastante alta. </font><font style="vertical-align: inherit;">Para consertar isso, mudei o layout do painel colorido para ajustar os pain√©is rodovi√°rios e fluviais mais compactos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fd/de5/a8a/0fdde5a8a4abc86308b771f43b36bf4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI com estradas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como agora eu uso duas linhas de tr√™s op√ß√µes para cores, h√° espa√ßo para outra cor. </font><font style="vertical-align: inherit;">Ent√£o eu adicionei um item para laranja.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/9c6/08d/a069c608dfe531a5e1b2a8c59fef5846.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/12a/499/e9612a49993e3a2d4cb20790186ecf02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinco cores: amarelo, verde, azul, laranja e branco. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos editar as estradas, mas at√© agora elas n√£o s√£o vis√≠veis. </font><font style="vertical-align: inherit;">Voc√™ pode usar o inspetor para garantir que tudo esteja funcionando.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/160/c4f/0e4/160c4f0e496acec2a2a2d739152a7cfa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela com estradas no inspetor. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangula√ß√£o da estrada </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para exibir estradas, voc√™ precisa triangul√°-las. </font><font style="vertical-align: inherit;">Isso √© semelhante √† cria√ß√£o de uma malha para rios, apenas o leito do rio n√£o aparecer√° no relevo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, crie um novo shader padr√£o que usar√° novamente as coordenadas UV para pintar a superf√≠cie da estrada.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Road" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie um material de estrada usando esse shader. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/9e3/2b8/9739e32b82ad2148c559b8f7c4caa868.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estrada material. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defina a pr√©-fabrica√ß√£o do fragmento para que ele receba outra malha filho de hex√°gonos para as estradas. </font><font style="vertical-align: inherit;">Essa malha n√£o deve projetar sombras e deve usar apenas coordenadas UV. </font><font style="vertical-align: inherit;">A maneira mais r√°pida de fazer isso √© atrav√©s de uma inst√¢ncia pr√©-fabricada - duplique o objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e substitua seu material.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/476/a9e/bf8476a9e950a13c69051a5cd43480c1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/4d8/776/a644d8776f3c6f0ba64cf3aef666f475.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas de objeto filho. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois disso, adicione ao </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo geral </font></font><code>HexMesh roads</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e inclua-o </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Conecte-o no inspetor ao objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a95/c0e/c2a/a95c0ec2ae59dccbb249e6a02ccdc7c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objeto Estradas est√° conectado.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estradas entre celas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos primeiro olhar para os segmentos da estrada entre as c√©lulas. </font><font style="vertical-align: inherit;">Como rios, as estradas s√£o fechadas por dois quadriciclos m√©dios. </font><font style="vertical-align: inherit;">Cobrimos completamente esses quadr√¢ngulos de conex√£o com os quadr√¢ngulos da estrada para que as posi√ß√µes dos mesmos seis picos possam ser usadas. </font><font style="vertical-align: inherit;">Adicione isso ao </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como n√£o precisamos mais nos preocupar com o fluxo de √°gua, a coordenada V n√£o √© necess√°ria; portanto, atribu√≠mos o valor 0. em qualquer lugar. Podemos usar a coordenada U para indicar se estamos no meio da estrada ou ao lado. </font><font style="vertical-align: inherit;">Seja igual a 1 no meio e igual a 0 em ambos os lados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26a/730/868/26a73086896099b06098de0a25eb63ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um segmento da estrada entre c√©lulas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seria l√≥gico chamar esse m√©todo </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas apenas se realmente houver uma estrada. </font><font style="vertical-align: inherit;">Adicione um par√¢metro booleano ao m√©todo para passar essas informa√ß√µes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, agora receberemos erros do compilador, porque at√© agora essas informa√ß√µes ainda n√£o foram transmitidas. </font><font style="vertical-align: inherit;">Como o √∫ltimo argumento em todos os casos, a chamada </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser adicionada </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No entanto, tamb√©m podemos declarar que o valor padr√£o deste par√¢metro √© igual </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Devido a isso, o par√¢metro se tornar√° opcional e os erros de compila√ß√£o desaparecer√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como funcionam os par√¢metros opcionais?</font></font></b> <div class="spoiler_text">        ,   . ,  <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }</code> </pre> <br>    <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(x, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br>   .      .    .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para triangular a estrada, basta ligar </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com os seis picos do meio, se necess√°rio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â assim que lidamos com conex√µes de c√©lula plana. </font><font style="vertical-align: inherit;">Para apoiar as estradas nas bordas, tamb√©m precisamos dizer </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde a estrada deve ser adicionada. </font><font style="vertical-align: inherit;">Ele pode simplesmente transmitir essas informa√ß√µes </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.Color, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, endCell.Color, hasRoad); }</code> </pre> <br> <code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamado dentro </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√â aqui que podemos determinar se h√° realmente uma estrada na dire√ß√£o atual, durante a triangula√ß√£o da nervura e a triangula√ß√£o das bordas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces( e1, cell, e2, neighbor, cell.HasRoadThroughEdge(direction) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip( e1, cell.Color, e2, neighbor.Color, cell.HasRoadThroughEdge(direction) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/67d/e7d/d7a67de7d2edeb2d23b63e9b37bc7508.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmentos de estrada entre c√©lulas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√©lula sobre renderiza√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao desenhar estradas, voc√™ ver√° que os segmentos de estrada aparecem entre as c√©lulas. O meio desses segmentos ser√° roxo com uma transi√ß√£o para azul nas bordas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, quando voc√™ move a c√¢mera, os segmentos podem tremer e √†s vezes desaparecer completamente. Isso ocorre porque os tri√¢ngulos das estradas se sobrep√µem exatamente aos tri√¢ngulos do terreno. Tri√¢ngulos para renderiza√ß√£o s√£o selecionados aleatoriamente. Esse problema pode ser corrigido em dois est√°gios. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em primeiro lugar, queremos tra√ßar as estradas depois que o al√≠vio for tra√ßado. Isso pode ser conseguido renderizando-os ap√≥s renderizar a geometria usual, ou seja, colocando-os em uma fila de renderiza√ß√£o posterior.</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, precisamos garantir que as estradas sejam tra√ßadas sobre tri√¢ngulos do terreno na mesma posi√ß√£o. </font><font style="vertical-align: inherit;">Isso pode ser feito adicionando o deslocamento do teste de profundidade. </font><font style="vertical-align: inherit;">Isso permitir√° que a GPU assuma que os tri√¢ngulos est√£o mais pr√≥ximos da c√¢mera do que realmente s√£o.</font></font><br><br><pre> <code class="hljs powershell"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Offset <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estradas atrav√©s das celas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao triangular rios, tivemos que lidar com n√£o mais do que duas dire√ß√µes de rio por c√©lula. Poder√≠amos identificar cinco op√ß√µes poss√≠veis e triangul√°-las de maneira diferente para criar os rios com apar√™ncia correta. No entanto, no caso de estradas, existem catorze op√ß√µes poss√≠veis. N√£o usaremos abordagens separadas para cada uma dessas op√ß√µes. Em vez disso, processaremos cada uma das seis dire√ß√µes da c√©lula da mesma maneira, independentemente da configura√ß√£o espec√≠fica da estrada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando uma estrada passa ao longo de uma parte da c√©lula, vamos tra√ß√°-la diretamente para o centro da c√©lula, sem sair da zona de tri√¢ngulos. Tra√ßaremos um segmento da estrada da borda at√© a metade na dire√ß√£o do centro. Ent√£o usamos dois tri√¢ngulos para fechar o resto no centro.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df0/659/a13/df0659a13206731d401579ba8c7f3b8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangula√ß√£o de uma parte da estrada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para triangular esse esquema, precisamos conhecer o centro da c√©lula, os v√©rtices m√©dios esquerdo e direito e os v√©rtices da aresta. </font><font style="vertical-align: inherit;">Adicione um m√©todo </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com os par√¢metros apropriados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para construir um segmento de estrada, precisamos de um pico adicional. </font><font style="vertical-align: inherit;">Est√° localizado entre os picos do meio esquerdo e direito.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora tamb√©m podemos adicionar os dois tri√¢ngulos restantes. </font></font><br><br><pre> <code class="cs hljs"> TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m precisamos adicionar as coordenadas UV dos tri√¢ngulos. </font><font style="vertical-align: inherit;">Dois de seus picos est√£o no meio da estrada, e o resto est√° √† beira.</font></font><br><br><pre> <code class="cs hljs"> roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por enquanto, vamos nos limitar a c√©lulas nas quais n√£o h√° rios. </font><font style="vertical-align: inherit;">Nesses casos, ele </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplesmente cria um leque de tri√¢ngulos. </font><font style="vertical-align: inherit;">Mova esse c√≥digo para um m√©todo separado. </font><font style="vertical-align: inherit;">Em seguida, adicionamos uma chamada </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando a estrada √© realmente. </font><font style="vertical-align: inherit;">Os v√©rtices m√©dios esquerdo e direito podem ser encontrados por interpola√ß√£o entre o centro e os dois v√©rtices de canto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/ae4/def/29dae4def1f841ae190e64b267f6e4ea.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas passando pelas celas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costelas de estrada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos ver as estradas, mas mais perto do centro das celas elas se estreitam. Como n√£o verificamos qual das catorze op√ß√µes estamos lidando, n√£o podemos mudar o centro da estrada para criar formas mais bonitas. Em vez disso, podemos adicionar arestas adicionais em outras partes da c√©lula. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando as estradas passam pela c√©lula, mas n√£o na dire√ß√£o atual, adicionaremos um tri√¢ngulo √†s bordas da estrada. Este tri√¢ngulo √© definido pelos v√©rtices central, esquerdo e direito. Nesse caso, apenas o pico central fica no meio da estrada. Os outros dois est√£o na costela dela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, Vector3 mL, Vector3 mR</span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/293/6ec/bd12936ec0833f7d7da4e038158bb167.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte da beira da estrada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando precisamos triangular uma estrada cheia ou apenas uma margem, precisamos deix√°-la como est√° </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para fazer isso, esse m√©todo deve saber se a estrada passa pela dire√ß√£o da borda da c√©lula atual. </font><font style="vertical-align: inherit;">Portanto, adicionamos um par√¢metro para isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele ter√° que ligar </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando alguma estrada passar pela c√©lula. </font><font style="vertical-align: inherit;">E ele ter√° que transmitir informa√ß√µes sobre se a estrada passa pela borda atual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89e/f99/1a0/89ef991a0790911d140b68b1457fb9df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas com nervuras conclu√≠das.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suaviza√ß√£o de estradas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As estradas est√£o agora completas. </font><font style="vertical-align: inherit;">Infelizmente, essa abordagem cria protuber√¢ncias no centro das c√©lulas. </font><font style="vertical-align: inherit;">Colocar os picos esquerdo e direito no meio, entre o centro e as esquinas, nos conv√©m quando h√° uma estrada adjacente a eles. </font><font style="vertical-align: inherit;">Mas se n√£o for, ent√£o h√° uma protuber√¢ncia. </font><font style="vertical-align: inherit;">Para evitar isso, nesses casos, podemos colocar os v√©rtices mais pr√≥ximos do centro. </font><font style="vertical-align: inherit;">Mais especificamente, interpolando com ¬º, n√£o com ¬Ω. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar um m√©todo separado para descobrir quais interpoladores usar. </font><font style="vertical-align: inherit;">Como existem dois deles, podemos colocar o resultado </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seu componente X ser√° o interpolador do ponto esquerdo e o componente Y ser√° o interpolador do ponto direito.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se houver uma estrada na dire√ß√£o atual, podemos colocar os pontos no meio. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caso contr√°rio, as op√ß√µes podem ser diferentes. </font><font style="vertical-align: inherit;">Para o ponto esquerdo, podemos usar ¬Ω se houver uma estrada na dire√ß√£o anterior. </font><font style="vertical-align: inherit;">Caso contr√°rio, devemos usar ¬º. </font><font style="vertical-align: inherit;">O mesmo se aplica ao ponto certo, mas levando em considera√ß√£o a seguinte dire√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { interpolators.x = cell.HasRoadThroughEdge(direction.Previous()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; interpolators.y = cell.HasRoadThroughEdge(direction.Next()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora voc√™ pode usar esse novo m√©todo para determinar quais interpoladores s√£o usados. </font><font style="vertical-align: inherit;">Gra√ßas a isso, as estradas ser√£o suavizadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c9/d0b/d12/3c9d0bd1262c2d47a3efc2d300212efd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84c/5fa/4f8/84c5fa4f8ef27bd4f6d294d0bf50acf6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas lisas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A combina√ß√£o de rios e estradas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No est√°gio atual, temos estradas funcionais, mas apenas se n√£o houver rios. </font><font style="vertical-align: inherit;">Se houver um rio na cela, as estradas n√£o ser√£o trianguladas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5e/76f/814/f5e76f814407359057d0c1bb1688988c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o h√° estradas perto dos rios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar um m√©todo </font></font><code>TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para lidar com essa situa√ß√£o. </font><font style="vertical-align: inherit;">Definimos os par√¢metros usuais. </font><font style="vertical-align: inherit;">Vamos cham√°-lo no in√≠cio do m√©todo </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoadAdjacentToRiver(direction, cell, center, e); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para come√ßar, faremos o mesmo que em estradas sem rios. </font><font style="vertical-align: inherit;">Vamos verificar se a estrada passa pela margem atual, obter interpoladores, criar picos m√©dios e ligar </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas como os rios aparecer√£o no caminho, precisamos afastar as estradas deles. </font><font style="vertical-align: inherit;">Como resultado, o centro da estrada estar√° em uma posi√ß√£o diferente. </font><font style="vertical-align: inherit;">Usamos uma vari√°vel para armazenar esta nova posi√ß√£o </font></font><code>roadCenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Inicialmente, ser√° igual ao centro da c√©lula.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, criaremos estradas parciais em celas com rios. </font><font style="vertical-align: inherit;">As dire√ß√µes pelas quais os rios passam cortam as brechas nas estradas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/029/595/95e0295954967415965a3992ffd91882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas com espa√ßos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In√≠cio ou fim do rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos primeiro olhar para as c√©lulas que cont√™m o in√≠cio ou o fim de um rio. </font><font style="vertical-align: inherit;">Para que as estradas n√£o se sobreponham √† √°gua, vamos mover o centro da estrada do rio. </font><font style="vertical-align: inherit;">Para obter a dire√ß√£o do rio de entrada ou sa√≠da, adicione a </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection RiverBeginOrEndDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver ? incomingRiver : outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar essa propriedade </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para mover o centro da estrada na dire√ß√£o oposta. </font><font style="vertical-align: inherit;">Basta mover um ter√ßo para a costela do meio nessa dire√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/12b/280/f1812b2807add77e4d173b85ad65e4da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas modificadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos fechar as lacunas. </font><font style="vertical-align: inherit;">Faremos isso adicionando tri√¢ngulos adicionais √†s margens da estrada quando estivermos perto do rio. </font><font style="vertical-align: inherit;">Se houver um rio na dire√ß√£o anterior, adicionamos um tri√¢ngulo entre o centro da estrada, o centro da c√©lula e o ponto m√©dio esquerdo. </font><font style="vertical-align: inherit;">E se o rio estiver na pr√≥xima dire√ß√£o, adicionamos um tri√¢ngulo entre o centro da estrada, o ponto m√©dio direito e o centro da c√©lula. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos fazer isso independentemente da configura√ß√£o do rio, portanto, coloque esse c√≥digo no final do m√©todo.</font></font><br><br><pre> <code class="cs hljs"> Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ n√£o pode usar a instru√ß√£o else?</font></font></b> <div class="spoiler_text">      .   ,     . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93d/485/bc8/93d485bc8072e6fa8471fb98d084467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas prontas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rios retos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√©lulas com rios retos s√£o particularmente dif√≠ceis porque basicamente dividem o centro da c√©lula em duas. </font><font style="vertical-align: inherit;">J√° adicionamos tri√¢ngulos extras para preencher as lacunas entre os rios, mas tamb√©m precisamos desconectar as estradas em lados opostos do rio.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab6/203/055/ab62030558305530ed4aed038669ba9c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas sobrepostas a um rio reto. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a c√©lula n√£o tiver o in√≠cio ou o fim do rio, podemos verificar se os rios que entram e saem seguem dire√ß√µes opostas. </font><font style="vertical-align: inherit;">Se sim, ent√£o temos um rio direto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar onde o rio √© relativo √† dire√ß√£o atual, precisamos verificar as dire√ß√µes vizinhas. </font><font style="vertical-align: inherit;">O rio √© esquerdo ou direito. </font><font style="vertical-align: inherit;">Como fazemos isso no final do m√©todo, armazenamos essas solicita√ß√µes em cache em vari√°veis ‚Äã‚Äãbooleanas. </font><font style="vertical-align: inherit;">Isso tamb√©m simplificar√° a leitura do nosso c√≥digo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> previousHasRiver = cell.HasRiverThroughEdge(direction.Previous()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> nextHasRiver = cell.HasRiverThroughEdge(direction.Next()); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { } } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos mudar o centro da estrada para um vetor angular apontando na dire√ß√£o oposta ao rio. </font><font style="vertical-align: inherit;">Se o rio passa pela dire√ß√£o anterior, esse √© o segundo √¢ngulo s√≥lido. </font><font style="vertical-align: inherit;">Caso contr√°rio, este √© o primeiro √¢ngulo s√≥lido.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mover a estrada de forma que fique adjacente ao rio, precisamos mover o centro da estrada pela metade da dist√¢ncia at√© esse canto. </font><font style="vertical-align: inherit;">Ent√£o tamb√©m temos que mover o centro da c√©lula um quarto da dist√¢ncia nessa dire√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/6bf/85b/e4c6bf85b3120697996ad75a3256a3a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas divididas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s compartilhamos uma rede de estradas dentro desta c√©lula. </font><font style="vertical-align: inherit;">Isso √© normal quando as estradas est√£o nos dois lados do rio. </font><font style="vertical-align: inherit;">Mas se de um lado n√£o houver estrada, teremos um pequeno peda√ßo de estrada isolada. </font><font style="vertical-align: inherit;">Isso √© il√≥gico, ent√£o vamos nos livrar dessas partes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verifique se h√° uma estrada na dire√ß√£o atual. </font><font style="vertical-align: inherit;">Caso contr√°rio, verifique a outra dire√ß√£o do mesmo lado do rio quanto √† presen√ßa da estrada. </font><font style="vertical-align: inherit;">Se n√£o houver uma estrada que passe por l√° ou por l√°, sairemos do m√©todo antes de triangular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Previous()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetFirstSolidCorner(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/398/532/09e398532543dcd7f78987c23e012571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas truncadas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E as pontes?</font></font></b> <div class="spoiler_text">     .         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rios em zigue-zague </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pr√≥ximo tipo de rio √© em zigue-zague. </font><font style="vertical-align: inherit;">Como esses rios n√£o compartilham a rede de estradas, precisamos apenas mover o centro da estrada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/29b/f56/85129bf56e4948296b17916094fd9d8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ziguezagues passando pelas estradas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais f√°cil de verificar se h√° ziguezagues √© comparando as dire√ß√µes dos rios que entram e saem. </font><font style="vertical-align: inherit;">Se eles s√£o adjacentes, ent√£o temos um zigue-zague. </font><font style="vertical-align: inherit;">Isso leva a duas op√ß√µes poss√≠veis, dependendo da dire√ß√£o do fluxo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos mover o centro da estrada usando um dos cantos da dire√ß√£o do rio que chega. </font><font style="vertical-align: inherit;">O √¢ngulo que voc√™ seleciona depende da dire√ß√£o do fluxo. </font><font style="vertical-align: inherit;">Mova o centro da estrada desse √¢ngulo com um fator de 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { roadCenter -= HexMetrics.GetSecondCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { roadCenter -= HexMetrics.GetFirstCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/3c6/f27/1fa3c6f277079e277491027207f9398f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrada se afastou dos ziguezagues.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dentro dos rios tortos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima configura√ß√£o do rio √© uma curva suave. </font><font style="vertical-align: inherit;">Como no rio direto, este tamb√©m pode separar estradas. </font><font style="vertical-align: inherit;">Mas, neste caso, as partes ser√£o diferentes. </font><font style="vertical-align: inherit;">Primeiro, precisamos trabalhar com o interior da curva.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/566/b8f/3db/566b8f3dbffec4cdc91556abe0f2bf5e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um rio curvo com estradas pavimentadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando temos um rio nos dois lados da dire√ß√£o atual, estamos dentro da curva.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Precisamos mover o centro da estrada em dire√ß√£o √† borda atual da c√©lula, encurtando um pouco a estrada. </font><font style="vertical-align: inherit;">Um coeficiente de 0,7 serve. </font><font style="vertical-align: inherit;">O centro da c√©lula tamb√©m deve mudar com um coeficiente de 0,5.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2d/64f/a82/a2d64fa828544540d43856bf94e34f9d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas encurtadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no caso de rios retos, precisaremos cortar as partes isoladas das estradas. </font><font style="vertical-align: inherit;">Nesse caso, basta verificar apenas a dire√ß√£o atual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasRoadThroughEdge) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/6a0/d9d/30b6a0d9db5fe0960265713c62ef2ae5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cortar estradas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fora dos rios tortos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de verificar todos os casos anteriores, a √∫nica op√ß√£o restante era a parte externa do rio curvo. </font><font style="vertical-align: inherit;">L√° fora, existem tr√™s partes da c√©lula. </font><font style="vertical-align: inherit;">Precisamos encontrar a dire√ß√£o do meio. </font><font style="vertical-align: inherit;">Ap√≥s receb√™-lo, podemos mover o centro da estrada em dire√ß√£o a esta costela por um fator de 0,25.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/84c/a29/8b884ca29118c36e522674cd00ab8613.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudou o lado de fora da estrada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como √∫ltimo passo, precisamos truncar as estradas deste lado do rio. </font><font style="vertical-align: inherit;">A maneira mais f√°cil √© verificar as tr√™s dire√ß√µes da estrada em rela√ß√£o ao meio. </font><font style="vertical-align: inherit;">Se n√£o houver estradas, paramos de trabalhar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56d/69a/d1b/56d69ad1b8d6ffdf74e9adb1c4800695.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/8c3/178/a9a8c3178c8a44738b4bbd01ef5f221d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas antes e depois do recorte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de processar todas as op√ß√µes de rios, nossos rios e estradas podem coexistir. </font><font style="vertical-align: inherit;">Os rios ignoram as estradas e as estradas se adaptam aos rios.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b32/6e4/28b/b326e428b45df027cac2f99a336e71e9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A combina√ß√£o de rios e estradas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A apar√™ncia das estradas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© aquele momento, usamos as coordenadas UV como cores da estrada. </font><font style="vertical-align: inherit;">Como apenas a coordenada U mudou, exibimos a transi√ß√£o entre o meio e a beira da estrada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/cb2/8ac/084cb28ac448ddb258846c09d8b3b83a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exibi√ß√£o de coordenadas UV. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que as estradas est√£o exatamente trianguladas corretamente, podemos alterar o sombreador para tornar algo mais parecido com estradas. </font><font style="vertical-align: inherit;">Como no caso dos rios, ser√° uma visualiza√ß√£o simples, sem frescuras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Come√ßaremos usando cores s√≥lidas para estradas. </font><font style="vertical-align: inherit;">Basta usar a cor do material. </font><font style="vertical-align: inherit;">Eu fiz vermelho.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/304/2e4/ab4/3042e4ab4b01b3389822072244208cb6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas vermelhas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E j√° parece muito melhor! </font><font style="vertical-align: inherit;">Mas vamos continuar e misturar a estrada com o terreno, usando a coordenada U como fator de mistura.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = blend; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que isso n√£o mudou nada. </font><font style="vertical-align: inherit;">Isso aconteceu porque o nosso shader √© opaco. </font><font style="vertical-align: inherit;">Agora ele precisa de mistura alfa. </font><font style="vertical-align: inherit;">Em particular, precisamos de um shader para uma superf√≠cie de decalque correspondente. </font><font style="vertical-align: inherit;">Podemos obter o sombreador necess√°rio adicionando uma </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linha </font><font style="vertical-align: inherit;">√† diretiva </font></font><code>decal:blend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows decal:blend</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/66c/501/7a066c5015ea14533f1b9ed881469323.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A mistura de estradas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por isso, criamos uma mistura linear suave do meio ao extremo que n√£o parece muito bonita. </font><font style="vertical-align: inherit;">Para fazer com que pare√ßa uma estrada, precisamos de uma √°rea s√≥lida, seguida de uma r√°pida transi√ß√£o para uma √°rea opaca. </font><font style="vertical-align: inherit;">Voc√™ pode usar a fun√ß√£o para isso </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele converte uma progress√£o linear de 0 para 1 em uma curva em forma de S.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b0/030/f57/2b0030f57819183470fc7fae72ea18bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Progress√£o linear e passo suave. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possui um par√¢metro m√≠nimo e m√°ximo para ajustar a curva em um intervalo arbitr√°rio. </font><font style="vertical-align: inherit;">Os valores de entrada fora do intervalo s√£o limitados para manter a curva plana. </font><font style="vertical-align: inherit;">Vamos usar 0,4 no in√≠cio da curva e 0,7 no final. </font><font style="vertical-align: inherit;">Isso significa que a coordenada U de 0 a 0,4 ser√° completamente transparente. </font><font style="vertical-align: inherit;">E as coordenadas U de 0,7 a 1 ser√£o completamente opacas. </font><font style="vertical-align: inherit;">A transi√ß√£o ocorre entre 0,4 e 0,7.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/543/fe1/4b4/543fe14b4d760b820ec106626230876f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transi√ß√£o r√°pida entre √°reas opacas e transparentes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estrada com barulho </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a malha da estrada ser√° distorcida, as estradas t√™m larguras variadas. </font><font style="vertical-align: inherit;">Portanto, a largura da transi√ß√£o nas bordas tamb√©m ser√° vari√°vel. </font><font style="vertical-align: inherit;">√Äs vezes √© emba√ßada, √†s vezes dura. </font><font style="vertical-align: inherit;">Essa variabilidade nos conv√©m, se percebermos as estradas como arenosas ou terrosas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos dar o pr√≥ximo passo e adicionar ru√≠do √†s margens da estrada. </font><font style="vertical-align: inherit;">Isso os tornar√° mais irregulares e menos poligonais. </font><font style="vertical-align: inherit;">Podemos fazer isso amostrando a textura do ru√≠do. </font><font style="vertical-align: inherit;">Para amostragem, voc√™ pode usar as coordenadas do mundo XZ, exatamente como fizemos ao distorcer os v√©rtices das c√©lulas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter acesso √† posi√ß√£o do mundo no shader de superf√≠cie, adicione √† estrutura de entrada </font></font><code>float3 worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos usar essa posi√ß√£o </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para provar a textura principal. </font><font style="vertical-align: inherit;">Diminua o zoom tamb√©m, caso contr√°rio a textura ser√° repetida com muita frequ√™ncia.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distorcemos a transi√ß√£o multiplicando a coordenada U por </font></font><code>noise.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas como os valores de ru√≠do s√£o em m√©dia 0,5, a maioria das estradas desaparece. </font><font style="vertical-align: inherit;">Para evitar isso, adicione 0,5 ao ru√≠do antes da multiplica√ß√£o.</font></font><br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blend = IN.uv_MainTex.x; blend *= <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/b7d/e28/c08b7de2879b84c816286530871b6a6f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/bdf/28f/4bebdf28fc519b3f186f119b6e501261.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bordas distorcidas da estrada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para finalizar, tamb√©m distorceremos a cor das estradas. </font><font style="vertical-align: inherit;">Isso dar√° √†s estradas uma sensa√ß√£o de sujeira correspondente a bordas difusas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multiplique a cor por outro canal de ru√≠do, diga por </font></font><code>noise.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, obtemos uma m√©dia da metade do valor da cor. </font><font style="vertical-align: inherit;">Como isso √© demais, reduziremos um pouco a escala de ru√≠do e adicionaremos uma constante para que a soma chegue a 1.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = _Color * (noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/a25/d49/6d2a25d4929cf56f7c4059352b4ed70a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estradas irregulares. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424491/">https://habr.com/ru/post/pt424491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424475/index.html">Relat√≥rio do Centro de Monitoramento de Seguran√ßa da Informa√ß√£o no 1¬∫ semestre de 2018</a></li>
<li><a href="../pt424477/index.html">A disponibilidade de jogos no pygame</a></li>
<li><a href="../pt424481/index.html">Toda a verdade sobre o RTOS. Artigo 11. Tarefas: configura√ß√£o e introdu√ß√£o √† API</a></li>
<li><a href="../pt424483/index.html">Acordo de US $ 38 bilh√µes e suas implica√ß√µes: como a Comcast e a Disney combatem a Amazon e a Netflix com investimentos</a></li>
<li><a href="../pt424485/index.html">Desvio de pinagem SSL no aplicativo iOS</a></li>
<li><a href="../pt424495/index.html">O Google Chrome adicionar√° a capacidade de recusar a sincroniza√ß√£o autom√°tica de perfis ao fazer login nos servi√ßos da empresa *</a></li>
<li><a href="../pt424497/index.html">Pare de suspeitar dos desenvolvedores de impostura. Aprenda a entrevistar melhor</a></li>
<li><a href="../pt424499/index.html">Bem, ele, seu pentesto</a></li>
<li><a href="../pt424501/index.html">Terminais de diagn√≥stico para soldadores reais</a></li>
<li><a href="../pt424503/index.html">Inicie voc√™ mesmo, a primavera est√° chegando (Parte 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>