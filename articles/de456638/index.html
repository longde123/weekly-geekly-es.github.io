<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóûÔ∏è üôã üôãüèø Vergleichen des gleichen Projekts in Rust, Haskell, C ++, Python, Scala und OCaml üß° üïµüèø ‚è≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Semester der Universit√§t habe ich mich f√ºr den CS444-Compilerkurs entschieden . Dort musste jede Gruppe von 1-3 Personen einen Compiler aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vergleichen des gleichen Projekts in Rust, Haskell, C ++, Python, Scala und OCaml</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456638/"> Im letzten Semester der Universit√§t habe ich mich f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den CS444-Compilerkurs entschieden</a> .  Dort musste jede Gruppe von 1-3 Personen einen Compiler aus einer wesentlichen Teilmenge von Java in x86 schreiben.  Sprache, um eine Gruppe auszuw√§hlen.  Dies war eine seltene Gelegenheit, Implementierungen gro√üer Programme mit derselben Funktionalit√§t, die von sehr kompetenten Programmierern in verschiedenen Sprachen geschrieben wurden, zu vergleichen und die Unterschiede in Design und Sprachauswahl zu vergleichen.  Ein solcher Vergleich lie√ü viele interessante Gedanken aufkommen.  Ein derart kontrollierter Sprachvergleich ist selten zu sehen.  Es ist nicht perfekt, aber viel besser als die meisten subjektiven Geschichten, auf denen die Meinungen der Leute √ºber Programmiersprachen basieren. <br><br>  Wir haben unseren Rust-Compiler erstellt und ihn zuerst mit dem Haskell-Teamprojekt verglichen.  Ich hatte erwartet, dass ihr Programm viel k√ºrzer sein w√ºrde, aber es stellte sich heraus, dass es gleich gro√ü oder gr√∂√üer war.  Gleiches gilt f√ºr OCaml.  Dann habe ich es mit dem C ++ - Compiler verglichen, und dort war zu erwarten, dass der Compiler etwa 30% gr√∂√üer war, haupts√§chlich aufgrund von Headern, fehlenden Summentypen und Mustervergleich.  Der folgende Vergleich wurde mit meiner Freundin durchgef√ºhrt, die den Compiler selbst in Python erstellt und aufgrund der M√∂glichkeiten der Metaprogrammierung und der dynamischen Typen weniger als die H√§lfte des Codes im Vergleich zu uns verwendet hat.  Ein anderer Freund hatte ein kleineres Scala-Programm.  Was mich am meisten √ºberraschte, war der Vergleich mit einem anderen Team, das ebenfalls Rust verwendete, aber aufgrund unterschiedlicher Designentscheidungen dreimal so viel Code hatte.  Am Ende war der gr√∂√üte Unterschied in der Codemenge in derselben Sprache! <br><a name="habracut"></a><br>  Ich werde erkl√§ren, warum ich dies f√ºr einen guten Vergleich halte, einige Informationen zu jedem Projekt geben und einige Gr√ºnde f√ºr Unterschiede in der Gr√∂√üe des Compilers erl√§utern.  Ich werde auch aus jedem Vergleich Schlussfolgerungen ziehen.  F√ºhlen Sie sich frei, diese Links zu verwenden, um zu dem Abschnitt von Interesse zu gelangen: <br><br><h1>  Inhalt </h1><br><ul><li>  Warum finde ich das sinnvoll? <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rost (Vergleichsbasis)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haskell</a> : 1,0-1,6 Gr√∂√üen, je nachdem, wie Sie z√§hlen, aus interessanten Gr√ºnden <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++</a> : 1.4 Gr√∂√üen aus offensichtlichen Gr√ºnden <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python</a> : 0,5 Gr√∂√üe durch ausgefallene Metaprogrammierung! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust (eine andere Gruppe)</a> : dreimal so gro√ü aufgrund eines anderen Designs! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scala</a> : 0,7 Gr√∂√üen <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OCaml</a> : 1,0-1,6 Gr√∂√üe, je nachdem, wie Sie z√§hlen, √§hnlich wie bei Haskell </li></ul><br><h1>  Warum finde ich das sinnvoll? </h1><br>  Bevor Sie sagen, dass die Codemenge (ich habe sowohl Zeichenfolgen als auch Bytes verglichen) eine schreckliche Metrik ist, m√∂chte ich darauf hinweisen, dass sie in diesem Fall ein gutes Verst√§ndnis vermitteln kann.  Zumindest ist dies das am besten kontrollierte Beispiel, bei dem verschiedene Teams dasselbe gro√üe Programm schreiben, von dem ich geh√∂rt oder gelesen habe. <br><br><ul><li>  Niemand (einschlie√ülich mir) wusste, dass ich diesen Parameter messen w√ºrde, also versuchte niemand, Metriken abzuspielen. Alle versuchten nur, das Projekt schnell und korrekt abzuschlie√üen. <br></li><li>  Alle (mit Ausnahme des Python-Projekts, auf das ich sp√§ter noch eingehen werde) haben das Programm nur zum Zweck des Bestehens derselben automatisierten Testsuite zur gleichen Zeit implementiert, sodass die Ergebnisse von Gruppen, die unterschiedliche Probleme l√∂sen, nicht stark verzerrt werden k√∂nnen. <br></li><li>  Das Projekt wurde innerhalb weniger Monate mit dem Team abgeschlossen und sollte schrittweise erweitert werden und sowohl bekannte als auch unbekannte Tests bestehen.  Dies bedeutet, dass es n√ºtzlich war, sauberen, klaren Code zu schreiben. <br></li><li>  Abgesehen vom Bestehen der Kurstests wird der Code f√ºr nichts anderes verwendet, niemand wird ihn lesen und als Compiler f√ºr eine begrenzte Teilmenge von Java in Text Assembler wird er nicht n√ºtzlich sein. <br></li><li>  Es sind keine anderen Bibliotheken als die Standardbibliothek zul√§ssig und keine Helfer zum Parsen, selbst wenn sie sich in der Standardbibliothek befinden.  Dies bedeutet, dass der Vergleich nicht durch die leistungsstarken Compiler-Bibliotheken verzerrt werden kann, √ºber die nur einige Befehle verf√ºgen. <br></li><li>  Es gab nicht nur √∂ffentliche, sondern auch geheime Tests.  Sie begannen einmal nach der endg√ºltigen Lieferung.  Dies bedeutete, dass es einen Anreiz gab, Ihren eigenen Testcode zu schreiben und sicherzustellen, dass der Compiler zuverl√§ssig und korrekt ist und komplexe Grenzsituationen handhabt. <br></li><li>  Obwohl alle Teilnehmer Studenten sind, halte ich sie f√ºr ziemlich kompetente Programmierer.  Jeder von ihnen absolvierte mindestens zwei Jahre lang ein Praktikum, haupts√§chlich in High-Tech-Unternehmen, manchmal sogar an Compilern.  Fast alle von ihnen programmieren seit 7-13 Jahren und sind Enthusiasten, die au√üerhalb ihrer Kurse viel im Internet lesen. <br></li><li>  Der generierte Code wurde nicht ber√ºcksichtigt, aber die Grammatikdateien und der Code, der den anderen Code generiert hat, wurden ber√ºcksichtigt. </li></ul><br>  Daher denke ich, dass die Menge an Code ein gutes Verst√§ndnis daf√ºr liefert, wie viel Aufwand erforderlich ist, um jedes Projekt zu unterst√ºtzen, wenn es langfristig w√§re.  Ich denke, dass nicht zu viel Unterschied zwischen den Projekten es Ihnen auch erlaubt, einige au√üergew√∂hnliche Aussagen zu widerlegen, die ich gelesen habe, zum Beispiel, dass der Haskell-Compiler aufgrund der Sprache mehr als halb so gro√ü wie C ++ sein wird. <br><br><a name="1"></a><h1>  Rost (Vergleichsbasis) </h1><br>  Ich und einer meiner Kameraden haben fr√ºher jeweils mehr als 10.000 Zeilen in Rust geschrieben, und der dritte Kollege hat vielleicht 500 Zeilen auf einigen Hackathons geschrieben.  Unser Compiler wurde in 6806 Zeilen <code>wc -l</code> , 5900 Zeilen der Quelle (ohne Leerzeichen und Kommentare) und 220 KB <code>wc -c</code> . <br><br>  Ich habe festgestellt, dass in anderen Projekten diese Proportionen mit wenigen Ausnahmen, die ich bemerken werde, grob eingehalten werden.  F√ºr den Rest des Artikels meine ich, wenn ich mich auf Zeichenfolgen oder Summen beziehe, <code>wc -l</code> , aber das spielt keine Rolle (es sei denn, ich bemerke den Unterschied), und Sie k√∂nnen mit einem Koeffizienten konvertieren. <br><br>  Ich habe einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weiteren Artikel geschrieben, der unser Design beschreibt</a> und alle √∂ffentlichen und geheimen Tests bestanden hat.  Es enth√§lt auch einige zus√§tzliche Funktionen, die wir zum Spa√ü gemacht haben, nicht zum Bestehen von Tests, bei denen wahrscheinlich etwa 400 Zeilen hinzugef√ºgt wurden.  Es hat auch ungef√§hr 500 Zeilen unserer Einheitentests. <br><br><a name="2"></a><h1>  Haskell </h1><br>  Zum Haskell-Team geh√∂rten zwei meiner Freunde, die jeweils ein paar tausend Zeilen Haskell geschrieben und viele Online-Inhalte √ºber Haskell und andere √§hnliche funktionale Sprachen wie OCaml und Lean gelesen haben.  Sie hatten einen anderen Teamkollegen, den ich nicht sehr gut kannte, aber es scheint, dass ein starker Programmierer Haskell zuvor benutzt hat. <br><br>  Ihr Compiler umfasste insgesamt 9.750 Zeilen <code>wc -l</code> , 357 KB und 7777 Codezeilen (SLOC).  Dieses Team hat auch die einzigen signifikanten Unterschiede zwischen diesen Verh√§ltnissen: Ihr Compiler ist 1,4-mal gr√∂√üer als unser in Zeilen, 1,3-mal in SLOC und 1,6-mal in Bytes.  Sie haben keine zus√§tzlichen Funktionen implementiert, 100% der √∂ffentlichen und geheimen Tests bestanden. <br><br>  Es ist wichtig zu beachten, dass die Einbeziehung von Tests dieses Team am meisten betroffen hat.  Da sie sich sorgf√§ltig der Richtigkeit des Codes n√§herten, umfassten sie 1.600 Testzeilen.  Sie haben mehrere Grenzsituationen erfasst, die unser Team nicht erfasst hat, aber diese F√§lle wurden einfach nicht durch Kurstests √ºberpr√ºft.  Ohne Tests auf beiden Seiten (6,3 Tausend Zeilen gegen√ºber 8,1 Tausend Zeilen) ist ihr Compiler also nur 30% h√∂her als unser Compiler. <br><br>  Hier tendiere ich zu Bytes als vern√ºnftigeres Ma√ü f√ºr den Volumenvergleich, da es in einem Haskell-Projekt im Durchschnitt l√§ngere Zeilen gibt, da es keine gro√üe Anzahl von Zeilen aus einer schlie√üenden Klammer enth√§lt und <code>rustfmt</code> nicht einzeilige Funktionsketten in mehrere Zeilen <code>rustfmt</code> . <br><br>  Nachdem wir mit einem meiner Teamkollegen gest√∂bert hatten, fanden wir die folgende Erkl√§rung f√ºr diesen Unterschied: <br><br><ul><li>  Wir verwendeten einen handgeschriebenen lexikalischen Analysator und eine rekursive Abstiegsmethode. Sie verwendeten einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NFA-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DFA-</a> Generator und einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LR-Parser</a> und anschlie√üend einen Durchgang, um den Analysebaum in AST ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abstrakter Syntaxbaum</a> , bequemere Darstellung des Codes) zu konvertieren.  Dies gab ihnen deutlich mehr Code: 2677 Zeilen im Vergleich zu unserem 1705, ungef√§hr 1000 Zeilen mehr. <br></li><li>  Sie verwendeten das phantasievolle generische AST, das zu verschiedenen Typparametern √ºberging, da in jedem Durchgang weitere Informationen hinzugef√ºgt wurden.  Diese und weitere Hilfsfunktionen zum Umschreiben erkl√§ren wahrscheinlich, warum ihr AST-Code etwa 500 Zeilen l√§nger ist als unsere Implementierung, in der wir Strukturliterale sammeln und <code>Option&lt;_&gt;</code> mutieren, um Informationen hinzuzuf√ºgen. <br></li><li>  Sie haben w√§hrend der Generierung immer noch ungef√§hr 400 Codezeilen, die haupts√§chlich mit der gr√∂√üeren Abstraktion verbunden sind, die erforderlich ist, um den Code auf rein funktionale Weise zu generieren und zu kombinieren, wobei wir einfach Mutations- und Schreibzeilen verwenden. </li></ul><br>  Diese Unterschiede plus Tests erkl√§ren alle Volumenunterschiede.  Tats√§chlich sind unsere Dateien f√ºr Faltkonstanten und Kontextaufl√∂sung sehr eng.  Trotzdem gibt es aufgrund l√§ngerer Zeilen einen gewissen Unterschied bei den Bytes: Wahrscheinlich, weil mehr Code ben√∂tigt wird, um den gesamten Baum in jedem Durchgang neu zu schreiben. <br><br>  Aus diesem Grund sind Rust und Haskell meiner Meinung nach gleicherma√üen ausdrucksstark, vielleicht mit einem leichten Vorteil, da Rust die Mutation leicht verwenden kann, wenn es zweckm√§√üig ist.  Es war auch interessant zu wissen, dass sich meine Wahl der rekursiven Abstiegsmethode und des handgeschriebenen lexikalischen Analysators ausgezahlt hat: Es war ein Risiko, das den Empfehlungen und Anweisungen des Professors widersprach, aber ich entschied, dass es einfacher und richtig war. <br><br>  Haskell-Fans werden argumentieren, dass dieses Team die Haskell-Funktionen wahrscheinlich nicht voll ausgenutzt hat, und wenn sie die Sprache besser kennen, k√∂nnten sie ein Projekt mit weniger Code erstellen.  Ich stimme zu, jemand wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Edward Kmett</a> kann denselben Compiler in einer viel geringeren Menge schreiben.  In der Tat verwendete das Team meines Freundes nicht viele ausgefallene, hochentwickelte Abstraktionen und ausgefallene Kombinatorbibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lens</a> .  All dies beeintr√§chtigt jedoch die Lesbarkeit des Codes.  Alle Leute im Team sind erfahrene Programmierer, sie wussten, dass Haskell zu sehr bizarren Dingen f√§hig war, entschieden sich jedoch, sie nicht zu verwenden, weil sie beschlossen, dass das Verstehen mehr Zeit in Anspruch nehmen w√ºrde als sie speichern und den Code f√ºr andere schwieriger zu verstehen machen w√ºrden.  Dies scheint ein echter Kompromiss zu sein, und die Behauptung, Haskell sei magisch f√ºr Compiler geeignet, geht in etwa so: "Haskell erfordert extrem hohe F√§higkeiten beim Schreiben von Compilern, wenn Sie sich nicht f√ºr die Codeunterst√ºtzung f√ºr Leute interessieren, die auch nicht sehr gut mit Haskell umgehen k√∂nnen." <br><br>  Es ist auch interessant festzustellen, dass der Professor zu Beginn jedes Projekts sagt, dass die Studenten jede Sprache verwenden k√∂nnen, die auf einem Universit√§tsserver ausgef√ºhrt wird, warnt jedoch davor, dass sich die Teams in Haskell von den anderen unterscheiden: Sie haben die gr√∂√üte Streuung in den Noten.  Viele Leute √ºbersch√§tzen ihre F√§higkeiten und die Haskell-Teams haben die schlechtesten Noten, obwohl andere genauso gut abschneiden wie meine Freunde. <br><br><a name="3"></a><h1>  C ++ </h1><br>  Dann habe ich mit meinem Freund vom C ++ - Team gesprochen.  Ich kannte nur eine Person in diesem Team, aber C ++ wird in mehreren Kursen an unserer Universit√§t verwendet, sodass wahrscheinlich jeder im Team C ++ - Erfahrung hatte. <br><br>  Ihr Projekt bestand aus 8733 Zeilen und 280 KB, ohne den Testcode, aber mit etwa 500 Zeilen zus√§tzlicher Funktionen.  Damit ist es 1,4-mal gr√∂√üer als unser Code ohne Tests, der auch etwa 500 Zeilen mit zus√§tzlichen Funktionen enth√§lt.  Sie haben 100% der √∂ffentlichen Tests bestanden, aber nur 90% der geheimen Tests.  Vermutlich, weil sie die in der Spezifikation geforderten ausgefallenen vtables-Arrays nicht implementiert haben, die m√∂glicherweise 50 bis 100 Codezeilen belegen. <br><br>  Ich habe mich nicht zu tief mit diesen Gr√∂√üenunterschieden befasst.  Ich denke, das liegt haupts√§chlich an: <br><br><ul><li>  Sie verwenden den LR-Parser und den Baumumschreiber anstelle der rekursiven Abstiegsmethode. <br></li><li>  Das Fehlen von Summentypen und Mustervergleichen in C ++, die wir weit verbreitet haben und die sehr n√ºtzlich waren. <br></li><li>  Die Notwendigkeit, alle Signaturen in den Header-Dateien zu duplizieren, ist in Rust nicht der Fall. </li></ul><br>  Wir haben auch die Kompilierungszeit verglichen.  Auf meinem Laptop dauert der Clean-Debug-Build unseres Compilers 9,7 s, der Clean-Release 12,5 s und der inkrementelle Debug-Build 3,5 s.  Mein Freund hatte keine Zeitangaben f√ºr seinen C ++ - Build (unter Verwendung von parallel make), aber er sagte, dass die Zahlen √§hnlich sind, mit der Einschr√§nkung, dass sie Implementierungen vieler kleiner Funktionen in die Header-Dateien einf√ºgen, um das Duplizieren von Signaturen auf Kosten einer l√§ngeren Zeit zu reduzieren (n√§mlich Daher kann ich den Netzleitungs-Overhead in den Header-Dateien nicht messen. <br><br><a name="4"></a><h1>  Python </h1><br>  Mein Freund, ein sehr guter Programmierer, hat beschlossen, das Projekt alleine in Python zu machen.  Sie implementierte auch erweiterte Funktionen (zum Spa√ü) als jedes andere Team, einschlie√ülich einer SSA-Zwischenansicht mit Registerzuordnung und anderen Optimierungen.  Da es alleine funktionierte und viele zus√§tzliche Funktionen implementierte, achtete es am wenigsten auf die Qualit√§t des Codes, z. B. undifferenzierte Ausnahmen f√ºr alle Fehler (basierend auf Backtraces zum Debuggen), anstatt Fehlertypen und entsprechende Meldungen zu implementieren, wie z uns. <br><br>  Ihr Compiler bestand aus 4581 Zeilen und bestand alle √∂ffentlichen und geheimen Tests.  Sie implementierte auch erweiterte Funktionen als jeder andere Befehl, aber es ist schwierig zu bestimmen, wie viel zus√§tzlicher Code ben√∂tigt wurde, da viele der zus√§tzlichen Funktionen leistungsf√§higere Versionen einfacher Dinge waren, die jeder implementieren musste, wie z. B. Faltkonstanten und Generieren von Code.  Zus√§tzliche Funktionen sind wahrscheinlich mindestens 1000 bis 2000 Zeilen, daher bin ich mir sicher, dass ihr Code mindestens doppelt so aussagekr√§ftig ist wie unser. <br><br>  Ein gro√üer Teil dieses Unterschieds ist wahrscheinlich die dynamische Eingabe.  Nur in unseren <code>ast.rs</code> 500 Zeilen mit Typdefinitionen und viele weitere Typen, die an anderer Stelle im Compiler definiert sind.  Wir sind auch immer auf das Typensystem selbst beschr√§nkt.  Zum Beispiel ben√∂tigen wir eine Infrastruktur, um dem AST ergonomisch neue Informationen hinzuzuf√ºgen, wenn wir ihn durchlaufen und sp√§ter darauf zugreifen.  In Python k√∂nnen Sie einfach neue Felder auf AST-Knoten festlegen. <br><br>  Leistungsstarke Metaprogrammierung erkl√§rt auch einen Teil des Unterschieds.  Obwohl sie beispielsweise einen LR-Parser anstelle einer rekursiven Abstiegsmethode verwendete, war in meinem Fall meines Erachtens weniger Code erforderlich, da ihre LR-Grammatik anstelle einer Baumumschreibung Python-Codeteile zum Erstellen des AST enthielt, den der Generator in Python-Funktionen umwandeln konnte mit <code>eval</code> .  Ein Grund daf√ºr, dass wir den LR-Parser nicht verwendet haben, ist, dass das Erstellen eines AST ohne Umschreiben des Baums viel Zeremonie erfordert (entweder Rust-Dateien oder prozedurale Makros erstellen), um die Grammatik mit Fragmenten des Rust-Codes zu verkn√ºpfen. <br><br>  Ein weiteres Beispiel f√ºr die Leistungsf√§higkeit der Metaprogrammierung und der dynamischen Typisierung ist die 400- <code>visit.rs</code> Datei <code>visit.rs</code> , bei der es sich im Grunde um einen sich wiederholenden Boilerplate-Code handelt, der einen Besucher in einer Reihe von AST-Strukturen implementiert.  In Python kann dies eine kurze Funktion von ungef√§hr 10 Zeilen sein, die die Felder eines AST-Knotens rekursiv <code>__dict__</code> und sie besucht (unter Verwendung des Attributs <code>__dict__</code> ). <br><br>  Als Fan von Rust und statisch typisierten Sprachen im Allgemeinen m√∂chte ich feststellen, dass das Typensystem sehr n√ºtzlich ist, um Fehler zu vermeiden und die Leistung zu verbessern.  Ungew√∂hnliche Metaprogrammierungen k√∂nnen es auch schwierig machen zu verstehen, wie der Code funktioniert.  Dieser Vergleich √ºberraschte mich jedoch durch die Tatsache, dass ich nicht erwartet hatte, dass der Unterschied in der Codemenge so gro√ü sein w√ºrde.  Wenn der Unterschied insgesamt wirklich nahe daran liegt, doppelt so viel Code schreiben zu m√ºssen, halte ich Rust immer noch f√ºr einen geeigneten Kompromiss, aber immer noch halb so viel Code ist ein Argument, und in Zukunft tendiere ich dazu, etwas in Ruby / Python zu tun wenn Sie nur schnell etwas alleine bauen und es dann wegwerfen m√ºssen. <br><br><a name="5"></a><h1>  Rust (eine andere Gruppe) </h1><br>  Der interessanteste Vergleich f√ºr mich war mit meinem Freund, der auch ein Projekt in Rust mit einem Teamkollegen (den ich nicht kannte) durchf√ºhrte.  Mein Freund hatte eine gute Rust Erfahrung.  Er hat zur Entwicklung des Rust-Compilers beigetragen und viel gelesen.  Ich wei√ü nichts √ºber seinen Kameraden. <br><br>  Ihr Projekt bestand aus 17.211 Rohzeilen, 15.000 Quellzeilen und 637 KB, ohne den Testcode und den generierten Code.  Es hatte keine zus√§tzlichen Funktionen und bestand nur 4 von 10 geheimen Tests und 90% der √∂ffentlichen Tests f√ºr die Codegenerierung, da sie vor Ablauf der Frist nicht gen√ºgend Zeit hatten, um bizarrere Teile der Spezifikation zu implementieren.  Ihr Programm ist dreimal gr√∂√üer als unser, in derselben Sprache geschrieben und mit weniger Funktionalit√§t! <br><br>  Dieses Ergebnis war wirklich erstaunlich f√ºr mich und √ºberschattete alle Unterschiede zwischen den Sprachen, die ich bisher gelernt habe.  Aus diesem Grund haben wir die Listen der <code>wc -l</code> Dateigr√∂√üen verglichen und auch √ºberpr√ºft, wie jeder von uns bestimmte Dinge implementiert hat, die zu unterschiedlichen Codegr√∂√üen gef√ºhrt haben. <br><br>  Es scheint, dass alles auf die konsequente Annahme verschiedener Entwurfsentscheidungen hinausl√§uft.  Zum Beispiel ben√∂tigt ihr Frontend (lexikalische Analyse, Analyse, Erstellung von AST) 7597 Zeilen gegen√ºber unserem 2164. Sie verwendeten den lexikalischen DFA-Analysator und den LALR-Parser (1), aber andere Gruppen machten √§hnliche Dinge ohne so viel Code.  Als ich mir ihre Weeder-Datei ansah, bemerkte ich eine Reihe von Designentscheidungen, die sich von unseren unterschieden: <br><br><ul><li>  Sie entschieden sich f√ºr die Verwendung eines vollst√§ndig typisierten Analysebaums anstelle eines standardm√§√üigen, einheitlichen, auf Zeichenfolgen basierenden Analysebaums.  Dies erforderte wahrscheinlich viel mehr Typdefinitionen und zus√§tzlichen Konvertierungscode in der Analysephase oder einen komplexeren Parser. <br></li><li>  Sie verwendeten Tryfrom- <code>tryfrom</code> Implementierungen, um zwischen Parsing-Baumtypen und AST-Typen zu konvertieren und diese zu validieren.  Dies f√ºhrt zu vielen 10-20-Zeilen- <code>impl</code> Bl√∂cken.  Zu diesem Zweck haben wir Funktionen verwendet, die <code>Result</code> , wodurch weniger Zeilen generiert werden. Au√üerdem werden wir ein wenig von der Typstruktur befreit, was die Parametrisierung und Wiederverwendung vereinfacht.  Einige der Dinge, die f√ºr uns einzeilige <code>match</code> Zweige waren, hatten 10-zeilige <code>impl</code> Bl√∂cke. <br></li><li>  Unsere Typen sind so strukturiert, dass das Kopieren und Einf√ºgen reduziert wird.  Beispielsweise verwendeten sie separate Felder <code>is_abstract</code> , <code>is_native</code> und <code>is_static</code> , in denen der Code f√ºr die Einschr√§nkungspr√ºfung zweimal kopiert werden musste: einmal f√ºr Methoden vom Typ void und einmal f√ºr Methoden mit R√ºckgabetyp mit geringf√ºgigen √Ñnderungen.  W√§hrend unsere <code>void</code> nur ein spezieller Typ war, haben wir eine Taxonomie von Modifikatoren mit <code>mode</code> und <code>visibility</code> , die Einschr√§nkungen auf <code>visibility</code> anwendeten, und Einschr√§nkungen wurden standardm√§√üig f√ºr den √úbereinstimmungsoperator generiert, wodurch die Modifikators√§tze in <code>mode</code> und <code>visibility</code> . </li></ul><br>  Ich habe mir den Code der Durchl√§ufe der Analyse ihres Compilers nicht angesehen, aber sie sind auch gro√üartig.  Ich habe mit meinem Freund gesprochen, und es scheint, dass sie nichts √Ñhnliches wie die Infrastruktur von Besuchern implementiert haben, wie unsere.  Ich denke, dass dies zusammen mit einigen anderen kleineren Designunterschieden den Gr√∂√üenunterschied dieses Teils erkl√§rt.  Der Besucher l√§sst zu, dass sich unsere Analysep√§sse nur auf die Teile des AST konzentrieren, die er ben√∂tigt, anstatt das Muster √ºber die gesamte AST-Struktur hinweg abzugleichen.  Dies spart viel Code. <br><br>  Ihr Teil f√ºr die Codegenerierung besteht aus 3594 Zeilen und unser Teil - 1560. Ich habe mir ihren Code angesehen und es scheint, dass fast der gesamte Unterschied darin besteht, dass sie eine Zwischendatenstruktur f√ºr Assembler-Anweisungen gew√§hlt haben, bei der wir nur die Zeichenfolgenformatierung f√ºr die direkte Assembler-Ausgabe verwendet haben .  Sie mussten Typen und Ausgabefunktionen f√ºr alle verwendeten Anweisungen und Operandentypen definieren.  Dies bedeutete auch, dass die Montageanleitung f√ºr den Bau mehr Code ben√∂tigte.  Wo wir einen <code>mov ecx, [edx]</code> mit kurzen Anweisungen hatten, wie z. B. <code>mov ecx, [edx]</code> , brauchten sie einen riesigen <code>rustfmt</code> Operator, der in 6 Zeilen unterteilt war und eine Anweisung mit einer Reihe verschachtelter Zwischentypen f√ºr Operanden mit bis zu 6 Ebenen verschachtelter Klammern erstellte.  Wir k√∂nnten auch Bl√∂cke verwandter Anweisungen, wie z. B. eine Funktionspr√§ambel, in einer einzigen Formatanweisung ausgeben, in der die vollst√§ndige Konstruktion f√ºr jede Anweisung angegeben werden muss. <br><br>  Unser Team erwog, eine solche Abstraktion wie ihre zu verwenden.  Es war einfacher, entweder eine Textassembly auszugeben oder Maschinencode direkt auszugeben, dies war jedoch keine Voraussetzung f√ºr den Kurs.  Dasselbe k√∂nnte mit weniger Code und besserer Leistung unter Verwendung des X86Writer- <code>X86Writer</code> mit Methoden wie <code>push(reg: Register)</code> .  Wir haben auch ber√ºcksichtigt, dass dies das Debuggen und Testen vereinfachen k√∂nnte, aber wir haben festgestellt, dass das Anzeigen des generierten Textassemblers mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshot-Tests</a> einfacher zu lesen und zu testen ist, wenn Sie Kommentare gro√üz√ºgig einf√ºgen.  Aber wir haben (anscheinend richtig) vorausgesagt, dass es viel zus√§tzlichen Code erfordern w√ºrde, und es gab keinen wirklichen Nutzen angesichts unserer wirklichen Bed√ºrfnisse, also machten wir uns keine Sorgen. <br><br>  Es ist gut, dies mit der Zwischendarstellung zu vergleichen, die das C ++ - Team als zus√§tzliche Funktion verwendet hat und f√ºr die nur 500 zus√§tzliche Zeilen ben√∂tigt wurden.  Sie verwendeten eine sehr einfache Struktur (f√ºr einfache Typdefinitionen und Build-Code), die Operationen verwendete, die den Anforderungen von Java nahe kamen.  Dies bedeutete, dass ihre Zwischendarstellung viel kleiner war (und daher weniger Build-Code erforderte) als der resultierende Assembler, da viele Sprachoperationen wie Aufrufe und Casts in viele Assembler-Anweisungen erweitert wurden.  Sie sagen auch, dass es wirklich beim Debuggen geholfen hat, da es viel M√ºll herausgeschnitten und die Lesbarkeit verbessert hat.  Eine √ºbergeordnete Pr√§sentation erm√∂glichte auch einige einfache Optimierungen der Zwischendarstellung.  Das C ++ - Team hat ein wirklich gutes Design entwickelt, das sie mit viel weniger Code viel besser macht. <br><br>  Im Allgemeinen scheint der gemeinsame Grund f√ºr den dreifachen Unterschied im Volumen in der konsequenten √úbernahme verschiedener Entwurfsentscheidungen, sowohl gro√üer als auch kleiner, in Richtung mehr Code zu liegen.  Sie haben eine Reihe von Abstraktionen implementiert, die wir nicht implementiert haben - sie haben mehr Code hinzugef√ºgt und einige unserer Abstraktionen √ºbersprungen, wodurch sich die Codemenge verringert. <br><br>  Dieses Ergebnis hat mich wirklich √ºberrascht.  Ich wusste, dass Designentscheidungen wichtig sind, aber ich h√§tte nicht im Voraus vermutet, dass sie zu Unterschieden dieser Gr√∂√üe f√ºhren w√ºrden, da ich nur Personen untersuchte, die ich als starke kompetente Programmierer betrachte.  Von allen Vergleichsergebnissen ist dies f√ºr mich das wichtigste.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es hat mir wahrscheinlich geholfen, dass ich vor dem Besuch dieses Kurses viel dar√ºber gelesen habe, wie man Compiler schreibt, damit ich intelligente Projekte verwenden kann, die andere Leute entwickelt haben und die gut funktionieren, wie AST-Besucher und die Methode der rekursiven Abstammung, obwohl sie nicht unterrichtet wurden auf unserem Kurs.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was mich wirklich zum Nachdenken gebracht hat, sind die Kosten der Abstraktion. Abstraktionen k√∂nnen die zuk√ºnftige Erweiterung erleichtern oder vor bestimmten Arten von Fehlern sch√ºtzen. Sie m√ºssen jedoch ber√ºcksichtigt werden, da Sie dreimal so viel Code zum Verstehen und Umgestalten erhalten, dreimal so viele m√∂gliche Fehlerstellen und weniger Zeit zum Testen und weiter Entwicklung. Unser Schulungskurs war anders als in der realen Welt: Wir wussten mit Sicherheit, dass wir den Code nach der Entwicklung niemals ber√ºhren w√ºrden. Dadurch entfallen die Vorteile einer proaktiven Abstraktion. Wenn ich jedoch ausw√§hlen m√ºsste, welcher Compiler mit einer beliebigen Funktion erweitert werden soll, was Sie sp√§ter sagen werden, w√ºrde ich unseren ausw√§hlen, ohne meine Vertrautheit damit zu ber√ºcksichtigen. Nur weil es viel weniger Code zu verstehen gibt und ich m√∂glicherweise die beste Abstraktion f√ºr die Anforderungen ausw√§hlen k√∂nnte (z.Zwischendarstellung des C ++ - Befehls), wenn ich die spezifischen Anforderungen kenne.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meiner Ansicht nach wurde auch die Taxonomie von Abstraktionen gest√§rkt: Es gibt solche, die den Code reduzieren und nur die aktuellen Anforderungen ber√ºcksichtigen, wie unsere Besuchervorlage, und es gibt Abstraktionen, die Code hinzuf√ºgen, aber die Vorteile der Erweiterbarkeit, des Debuggens oder der Korrektheit bieten. </font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scala </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe auch mit einem Freund gesprochen, der im letzten Semester ein Projekt √ºber Scala gemacht hat, aber das Projekt und die Tests waren genau gleich. </font><font style="vertical-align: inherit;">Ihr Compiler bestand aus 4141 Zeilen und ~ 160 KB Code, ohne die Tests. </font><font style="vertical-align: inherit;">Sie haben 8 von 10 geheimen Tests und 100% offenen Tests bestanden und keine zus√§tzlichen Funktionen implementiert. </font><font style="vertical-align: inherit;">Im Vergleich zu unseren 5906 Zeilen ohne zus√§tzliche Funktionen und Tests ist ihr Compiler also 30% weniger.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einer der kleinen Designfaktoren war ein anderer Ansatz zum Parsen. Der Kurs erm√∂glichte die Verwendung eines Befehlszeilentools f√ºr den LR-Tabellengenerator. Niemand au√üer diesem Team hat es benutzt. Dies ersparte ihnen die Implementierung des LR-Tabellengenerators. Sie konnten auch vermeiden, LR-Grammatik mit einem Python-Skript mit 150 Zeilen zu schreiben, das die im Internet gefundene Java-Grammatik-Webseite kratzte und in das Eingabeformat des Generators √ºbersetzte. Sie mussten in Scala noch eine Art Baum bauen, aber im Allgemeinen betrug die Analysephase 1073 Zeilen im Vergleich zu unserer 1443, obwohl unsere Gradientenabstiegsmethode hier einen Volumenvorteil gegen√ºber allen anderen Teams bot.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Rest ihres Compilers war auch kleiner als unser, ohne offensichtliche gro√üe Designunterschiede, obwohl ich mich nicht mit dem Code befasst habe. </font><font style="vertical-align: inherit;">Ich vermute, dass dies auf Unterschiede in der Ausdruckskraft von Scala und Rust zur√ºckzuf√ºhren ist. </font><font style="vertical-align: inherit;">Scala und Rust verf√ºgen √ºber √§hnliche Programmierfunktionen, die f√ºr Compiler n√ºtzlich sind, z. B. den Mustervergleich. Der verwaltete Speicher von Scala speichert jedoch den Code, der f√ºr die Funktion des Leihpr√ºfers in Rust erforderlich ist. </font><font style="vertical-align: inherit;">Dar√ºber hinaus hat Scala einen vielf√§ltigeren syntaktischen Zucker als Rust.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OCaml </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da alle Mitglieder unseres Teams ein Praktikum bei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jane Street</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Technologiehandelsunternehmen - ca. Per.) Machen, war ich besonders daran interessiert, das Ergebnis anderer ehemaliger Jane Street-Praktikanten zu betrachten, die OCaml als Autor des Compilers ausgew√§hlt haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Compiler bestand aus 10.914 Zeilen und 377 KB, einschlie√ülich einer kleinen Menge Testcode und ohne zus√§tzliche Funktionen. Sie haben 9/10 Geheimtests und alle √∂ffentlichen Tests bestanden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei anderen Gruppen scheint der Hauptunterschied in der Gr√∂√üe auf die Verwendung des LR-Parsers und des Umschreibens von B√§umen zum Parsen sowie der Regex-&gt; NFA-&gt; DFA-Konvertierungspipeline f√ºr die lexikalische Analyse zur√ºckzuf√ºhren zu sein. Ihr Frontend (lexikalische Analyse, Analyse, AST-Konstruktion) besteht aus 5548 Zeilen und unserem - 2164, mit √§hnlichen Verh√§ltnissen f√ºr Bytes. Sie verwendeten auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tests</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr ihren Parser </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">mit der Erwartung,</font></a><font style="vertical-align: inherit;"> dass dies unseren Snapshot-Tests √§hnlich war, bei denen die erwartete Ausgabe au√üerhalb des Codes lag, sodass ihre Parser-Tests ~ 600 Zeilen der Gesamtzahl und unserer - etwa 200 - ergaben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit verbleiben 5366 Zeilen f√ºr den Rest des Compilers (461 Zeilen davon sind Schnittstellendateien mit Typdeklarationen) und 4642 f√ºr uns. Der Unterschied betr√§gt nur 15%, wenn wir ihre Schnittstellendateien z√§hlen, und fast die gleiche Gr√∂√üe, wenn wir nicht z√§hlen. </font><font style="vertical-align: inherit;">Abgesehen von unseren Parsing-Design-L√∂sungen scheinen Rust und OCaml gleicherma√üen ausdrucksstark zu sein, au√üer dass OCaml Front-End-Dateien ben√∂tigt und Rust nicht.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generell bin ich sehr froh, dass ich diesen Vergleich gemacht habe, viel gelernt habe und viele Male √ºberrascht war. </font><font style="vertical-align: inherit;">Ich denke, die allgemeine Schlussfolgerung ist, dass Designentscheidungen viel wichtiger sind als Sprache, aber Sprache ist wichtig, weil sie Ihnen Werkzeuge f√ºr die Implementierung verschiedener Designs bietet.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456638/">https://habr.com/ru/post/de456638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456622/index.html">So erstellen Sie ein Betriebssystem, das gem√§√ü dem Schutz der Klasse I zertifiziert ist</a></li>
<li><a href="../de456624/index.html">N√ºtzliche Python-Tools</a></li>
<li><a href="../de456630/index.html">Einf√ºhrung von Airflow zur Verwaltung von Spark-Jobs in ivi: Hoffnungen und Kr√ºcken</a></li>
<li><a href="../de456632/index.html">Wir erstellen die vierte Etage von C ++ - Vorlagen in RESTinio. Warum und wie?</a></li>
<li><a href="../de456634/index.html">Nginx-Rezepte: CAS (Central Authorization Service)</a></li>
<li><a href="../de456640/index.html">Analyse des Competitive Intelligence Contest an PHDays 9</a></li>
<li><a href="../de456642/index.html">Der erste Abschluss des JetBrains Corporate Master-Programms und der ITMO University</a></li>
<li><a href="../de456644/index.html">Auf Kickstarter wird ein l√§ngerer kosteng√ºnstiger 3D-Fotopolymerdrucker angezeigt</a></li>
<li><a href="../de456646/index.html">Genuss - wie man Schulden f√ºr Aufgaben loswird</a></li>
<li><a href="../de456650/index.html">Auswahl eines Budget-Taschenoszilloskops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>