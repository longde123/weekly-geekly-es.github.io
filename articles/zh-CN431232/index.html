<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😥 🌓 👩🏻 我们在Node.js上生成漂亮的SVG占位符 🎅🏾 🖥️ 🆕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="使用SVG图像作为占位符是一个很好的主意，尤其是在我们的世界中，当几乎所有站点都包含一堆我们试图异步加载的图片时，尤其如此。 图片越多，数量越多，出现各种问题的可能性就越高，这始于用户不太了解那里加载了什么，然后以加载图片后整个界面的著名跳跃结束。 尤其是在手机上网效果不佳的情况下，它会在多个屏幕上...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们在Node.js上生成漂亮的SVG占位符</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431232/"><p><img src="https://habrastorage.org/webt/ko/6n/vo/ko6nvoj9m3q1bdzvbeogrcbt09i.jpeg"></p><br><p>使用SVG图像作为占位符是一个很好的主意，尤其是在我们的世界中，当几乎所有站点都包含一堆我们试图异步加载的图片时，尤其如此。 图片越多，数量越多，出现各种问题的可能性就越高，这始于用户不太了解那里加载了什么，然后以加载图片后整个界面的著名跳跃结束。 尤其是在手机上网效果不佳的情况下，它会在多个屏幕上飞走。 正是在这样的时刻，存根才得以解救。 使用它们的另一种选择是检查。 有时您需要向用户隐藏图片，但我想保留页面的整体样式，颜色以及图片所占的位置。 </p><br><p> 但是在大多数文章中，每个人都在谈论理论，将所有这些存根图像插入到页面中将是很好的选择，今天我们将在实践中看到如何使用Node.js生成符合您的口味和颜色的图像。 我们将根据SVG图像创建车把模板，并以不同的方式填充它们，从简单的颜色或渐变填充到三角剖分，Voronoi马赛克以及使用滤镜。 所有操作将分步进行。 我相信对于感兴趣的初学者来说，这篇文章会很有趣，他们需要如何做，并且需要对操作进行详细的分析，但是有经验的开发人员也可能喜欢一些想法。 </p><a name="habracut"></a><br><h2 id="podgotovka"> 准备工作 </h2><br><p>首先，我们将进入一个称为NPM的所有内容的无底存储库。 由于生成存根映像的任务涉及在服务器端（甚至在开发人员的机器上，如果我们谈论的是或多或少的静态站点）一次生成它们的存根映像，因此我们不会处理过早的优化。 我们将连接我们喜欢的一切。 因此，我们从<code>npm init</code>拼写开始，然后进行依赖项的选择。 </p><br><p> 对于初学者来说，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ColorThief</a> 。 您可能已经听说过他。 一个很棒的库，可以隔离图片中最常用颜色的调色板。 首先，我们只需要类似的东西。 </p><br><pre> <code class="plaintext hljs">npm i --save color-thief</code> </pre> <br><p> 在Linux下安装此软件包时，出现了一个问题-一些缺少的cairo软件包，该软件包不在NPM目录中。 通过安装某些库的开发版本，解决了此奇怪的错误： </p><br><pre> <code class="plaintext hljs">sudo apt install libcairo2-dev libjpeg-dev libgif-dev</code> </pre> <br><p> 在此过程中将观察该工具的工作方式。 但是立即连接rgb-hex包以将颜色格式从RGB转换为Hex并不是多余的，这从其名称可以明显看出。 我们不会使用如此简单的功能进行骑行。 </p><br><pre> <code class="plaintext hljs">npm i --save rgb-hex</code> </pre> <br><blockquote> 从培训的角度来看，自己编写这样的东西很有用，但是当任务是快速组装一个工作量最小的原型时，然后将NPM目录中的所有内容连接起来是一个好主意。 节省大量时间。 </blockquote><p> 塞子最重要的参数之一是比例。 它们必须匹配原始图像的比例。 因此，我们需要知道它的大小。 我们将使用图像大小包来解决此问题。 </p><br><pre> <code class="plaintext hljs">npm i --save image-size</code> </pre> <br><p> 由于我们将尝试制作不同版本的图片，并且它们都将采用SVG格式，因此会出现一种或多种方式的图片模板问题。 您当然可以在JS中使用模式字符串进行闪避，但是为什么要所有这些呢？ 最好使用“常规”模板引擎。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">把手</a> 。 简单而有品位，对于我们的任务将是正确的。 </p><br><pre> <code class="plaintext hljs">npm i --save handlebars</code> </pre> <br><p> 我们不会立即为该实验安排某种复杂的体系结构。 我们创建main.js文件，并将所有依赖项导入其中，并导入一个用于处理文件系统的模块。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ColorThief = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'color-thief'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Handlebars = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'handlebars'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgbHex = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'rgb-hex'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sizeOf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'image-size'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>);</code> </pre> <br><p>  ColorThief需要额外的初始化 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> thief = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorThief();</code> </pre> <br><p> 使用我们连接的依赖关系，解决“将图片上传到脚本”和“获取图片的大小”的问题并不困难。 假设我们有一张图片1.jpg： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'1.jpg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size = sizeOf(<span class="hljs-string"><span class="hljs-string">'1.jpg'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> height = size.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width = size.width;</code> </pre> <br><p> 对于不熟悉Node.js的人来说，值得一提的是，几乎所有与文件系统相关的事物都可以同步或异步发生。 对于同步方法，在名称末尾添加“同步”。 我们将使用它们，以免遇到不必要的并发症，也不会使我们的大脑发疯。 </p><br><p> 让我们继续第一个示例。 </p><br><h2 id="zalivka-cvetom"> 颜色填充 </h2><br><p><img src="https://habrastorage.org/webt/xa/1p/7g/xa1p7gmnqwkm9rcdntn9qbtnrjm.jpeg"></p><br><p> 首先，我们将解决简单填充矩形的问题。 我们的图片将具有三个参数-宽度，高度和填充颜色。 我们用一个矩形制作一个SVG图像，但是代替这些值，我们替换成对的括号和将包含从脚本传输的数据的字段名称。 您可能已经在传统的HTML中看到了这种语法（例如，Vue使用了类似的东西），但是没有人愿意将它与SVG图像一起使用-模板引擎并不关心它的长远发展。 文字是他和非洲的文字。 </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'1.1'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'http://www.w3.org/2000/svg'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">viewBox</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0 0 100 100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">preserveAspectRatio</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'none'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ height }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ width }}'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 此外，ColorThief为我们提供了最常见的颜色之一，在示例中为灰色。 为了使用模板，我们用它读取文件，例如句柄，以便该库对其进行编译，然后使用完成的SVG存根生成一行。 模板引擎本身会在正确的位置替换我们的数据（颜色和大小）。 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateOneColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = thief.getColor(image); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-one-color.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, color }); fs.writeFileSync(<span class="hljs-string"><span class="hljs-string">'1-one-color.svg'</span></span>, svg, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); }</code> </pre> <br><p> 仅保留将结果写入文件。 如您所见，使用SVG非常好-所有文件都是文本，您可以轻松地读写它们。 结果是一个矩形图片。 没什么有趣的，但至少我们确保该方法有效（在本文结尾处有到完整源的链接）。 </p><br><h2 id="zalivka-gradientom"> 渐变填充 </h2><br><p> 使用渐变是一种更有趣的方法。 在这里，我们可以使用图片中的几种常见颜色，并实现从一个到另一个的平滑过渡。 有时可以在加载长色带的站点上找到它。 </p><br><p><img src="https://habrastorage.org/webt/_e/hk/dp/_ehkdpgdhchgknqkcvbadu8dwpq.jpeg"></p><br><p> 现在，我们的SVG模板已使用此渐变进行了扩展。 例如，我们将使用通常的线性渐变。 我们只对两个参数感兴趣-开头的颜色和结尾的颜色： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">linearGradient</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'my-gradient'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x1</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y1</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x2</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y2</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">gradientTransform</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'rotate(45)'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">stop</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">offset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stop-color:{{ startColor }};stop-opacity:1'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">stop</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">offset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100%'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stop-color:{{ endColor }};stop-opacity:1'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">linearGradient</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'100'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'url(#my-gradient)'</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p> 颜色本身是使用相同的ColorThief获得的。 它有两种操作模式-要么给我们提供一种原色，要么为调色板提供我们指定的颜色数量。 足够舒适。 对于渐变，我们需要两种颜色。 </p><br><p> 否则，此示例与上一个示例相似： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateGradient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palette = thief.getPalette(image, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> startColor = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...palette[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> endColor = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...palette[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-gradient.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, startColor, endColor }); <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre> <br><p> 这样，您可以制作各种渐变-不一定是线性的。 但这仍然是一个相当无聊的结果。 制作某种与原始图像遥遥相似的马赛克会很棒。 </p><br><h2 id="mozaika-iz-pryamougolnikov"> 矩形马赛克 </h2><br><p> 首先，让我们制作很多矩形，并用同一个库将为我们提供的调色板中的颜色填充它们。 </p><br><p><img src="https://habrastorage.org/webt/l6/w2/hd/l6w2hd1l4bgc-pand_tz2gixe3s.jpeg"></p><br><p> 车把可以做很多不同的事情，特别是有循环。 我们将向他传递一系列坐标和颜色，然后他会弄清楚。 我们只将矩形包装在每个模板中： </p><br><pre> <code class="xml hljs">{{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'11'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'11'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p> 因此，在脚本本身中，我们现在有了一个完整的调色板，在X / Y坐标中循环，并从调色板中创建一个具有随机颜色的矩形。 一切都非常简单： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateMosaic</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palette = thief.getPalette(image, <span class="hljs-number"><span class="hljs-number">16</span></span>); palette.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">color, index</span></span></span><span class="hljs-function">) </span></span>{ palette[index] = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...color); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rects = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; x += <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; y += <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = palette[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">15</span></span>)]; rects.push({ x, y, color }); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = Handlebars.compile(fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'template-mosaic.svg'</span></span>, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> svg = template({ height, width, rects }); <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre><br><p> 显然，马赛克虽然在颜色上与图片相似，但是在颜色的排列上，一切都不尽如人意。  ColorThief在此领域的功能有限。 我想得到一个可以猜测原始图片的马赛克，而不仅仅是一组颜色大致相同的砖块。 </p><br><h2 id="uluchshaem-mozaiku"> 改善马赛克 </h2><br><p> 在这里，我们必须更深入一点，从图片中的像素获取颜色... </p><br><p><img src="https://habrastorage.org/webt/qf/mt/60/qfmt60p4wqhi0yil0r28wtdjskq.jpeg"></p><br><p> 由于显然在控制台中通常没有从中获取此数据的画布，因此我们将以get-pixels包的形式使用帮助。 他可以使用我们已经拥有的图片从缓冲区中提取必要的信息。 </p><br><pre> <code class="plaintext hljs">npm i --save get-pixels</code> </pre> <br><p> 它看起来像这样： </p><br><pre> <code class="javascript hljs">getPixels(image, <span class="hljs-string"><span class="hljs-string">'image/jpg'</span></span>, (err, pixels) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// . . . });</span></span></code> </pre> <br><p> 我们得到一个包含数据字段的对象-一个像素数组，与从画布上获得的对象相同。 让我提醒您，为了通过坐标（X，Y）获得像素的颜色，您需要进行简单的计算： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (y * width + x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ];</code> </pre> <br><p> 因此，对于每个矩形，我们可以不使用调色板中的颜色，而直接使用图片中的颜色，然后使用它。 您将获得类似的信息（这里的主要目的是不要忘记图片中的坐标与我们的“归一化”坐标从0到100不同）： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateImprovedMosaic</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getPixels(image, <span class="hljs-string"><span class="hljs-string">'image/jpg'</span></span>, (err, pixels) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rects = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; x += <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realX = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(x * width / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; y += <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realY = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(y * height / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (realY * width + realX); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); rects.push({ x, y, color }); } } <span class="hljs-comment"><span class="hljs-comment">// . . .</span></span></code> </pre> <br><p> 为了获得更大的美观，我们可以稍微增加“砖”的数量，减小其尺寸。 由于我们没有将此尺寸传递给模板（当然，值得将其与图像的宽度或高度设为相同的参数），因此我们将更改模板本身的尺寸值： </p><br><pre> <code class="xml hljs">{{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p> 现在，我们有了一个实际上看起来像原始图像的马赛克，但同时却减少了一个数量级的空间。 </p><br><blockquote> 不要忘记GZIP可以很好地压缩文本文件中的此类重复序列，以便在传输到浏览器时，此类预览的大小将变得更小。 </blockquote><p> 但是，让我们继续前进。 </p><br><h2 id="triangulyaciya"> 三角剖分 </h2><br><p><img src="https://habrastorage.org/webt/by/h7/dq/byh7dqqiigv_3v5ayf-1lw8deyw.jpeg"></p><br><p> 矩形很好，但是三角形通常会产生更多有趣的结果。 因此，让我们尝试从一堆三角形制作马赛克。 有多种方法可以解决此问题，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Delaunay三角剖分</a> ： </p><br><pre> <code class="plaintext hljs">npm i --save delaunay-triangulate</code> </pre> <br><p> 我们将使用的算法的主要优点是，只要有可能，就可以避免三角形的锐角和钝角。 为了获得美丽的图像，我们不需要狭窄和长三角形。 </p><br><blockquote> 这是了解我们领域中存在哪些数学算法以及它们之间有何区别的有用时刻之一。 不必记住它们的所有实现，但是至少知道谷歌搜索有用。 </blockquote><p> 将我们的任务划分为较小的任务。 首先，您需要为三角形的顶点生成点。 最好在其坐标上添加一些随机性： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateTriangulation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// . . . const basePoints = []; for (let x = 0; x &lt;= 100; x += 5) { for (let y = 0; y &lt;= 100; y += 5) { const point = [x, y]; if ((x &gt;= 5) &amp;&amp; (x &lt;= 95)) { point[0] += Math.floor(10 * Math.random() - 5); } if ((y &gt;= 5) &amp;&amp; (y &lt;= 95)) { point[1] += Math.floor(10 * Math.random() - 5); } basePoints.push(point); } } const triangles = triangulate(basePoints); // . . .</span></span></code> </pre> <br><p> 在用三角形检查数组的结构（console.log以帮助我们）之后，我们发现了要获取像素颜色的点。 您可以简单地计算三角形顶点坐标的算术平均值。 然后，我们将额外的点从极端边界移开，以使它们不会在任何地方出现，并且在接收到真实的，未归一化的坐标后，得到像素的颜色，该颜色将变为三角形的颜色。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> polygons = []; triangles.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">triangle</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>]) / <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>]) / <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-number"><span class="hljs-number">100</span></span>) { x = <span class="hljs-number"><span class="hljs-number">99</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y === <span class="hljs-number"><span class="hljs-number">100</span></span>) { y = <span class="hljs-number"><span class="hljs-number">99</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realX = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(x * width / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realY = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(y * height / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixelPosition = <span class="hljs-number"><span class="hljs-number">4</span></span> * (realY * width + realX); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">1</span></span>], pixels.data[pixelPosition + <span class="hljs-number"><span class="hljs-number">2</span></span>] ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = <span class="hljs-string"><span class="hljs-string">'#'</span></span> + rgbHex(...rgb); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> points = <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">1</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-string"><span class="hljs-string">' '</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">','</span></span> + basePoints[triangle[<span class="hljs-number"><span class="hljs-number">2</span></span>]][<span class="hljs-number"><span class="hljs-number">1</span></span>]; polygons.push({ points, color }); });</code> </pre> <br><p> 像以前一样，仅保留字符串中所需点的坐标并将其连同颜色一起发送到车把进行处理。 </p><br><p> 在模板本身中，现在我们将没有矩形，而是多边形： </p><br><pre> <code class="xml hljs">{{# each polygons }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">polygon</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">points</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ points }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'stroke-width:0.1;stroke:{{ color }};fill:{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }}</code> </pre> <br><p> 三角剖分是一件非常有趣的事情。 通过增加三角形的数量，您可以得到漂亮的图片，因为没有人说我们必须仅将它们用作存根。 </p><br><h2 id="mozaika-voronogo"> 沃罗诺伊马赛克 </h2><br><p> 有一个问题，前一个的镜像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Voronoi</a>的分区或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">马赛克</a> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在使用着色器时</a> ，我们已经使用过它，但是在这里它也很有用。 </p><br><p><img src="https://habrastorage.org/webt/ij/-y/4m/ij-y4mnhq9tlbbkewlmfeyn-q0k.jpeg"></p><br><p> 与其他已知算法一样，我们有一个现成的实现： </p><br><pre> <code class="plaintext hljs">npm i --save voronoi</code> </pre> <br><p> 进一步的操作将与我们在前面的示例中所做的非常相似。 唯一的区别是，现在我们有了不同的结构-我们有了一个复杂的对象，而不是三角形数组。 选项略有不同。 否则，一切都差不多。 以相同的方式生成基点数组，请跳过该基点，以免列表过长： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateVoronoi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// . . . const box = { xl: 0, xr: 100, yt: 0, yb: 100 }; const diagram = voronoi.compute(basePoints, box); const polygons = []; diagram.cells.forEach((cell) =&gt; { let x = cell.site.x; let y = cell.site.y; if (x === 100) { x = 99; } if (y === 100) { y = 99; } const realX = Math.floor(x * width / 100); const realY = Math.floor(y * height / 100); const pixelPosition = 4 * (realY * width + realX); const rgb = [ pixels.data[pixelPosition], pixels.data[pixelPosition + 1], pixels.data[pixelPosition + 2] ]; const color = '#' + rgbHex(...rgb); let points = ''; cell.halfedges.forEach((halfedge) =&gt; { const endPoint = halfedge.getEndpoint(); points += endPoint.x.toFixed(2) + ',' + endPoint.y.toFixed(2) + ' '; }); polygons.push({ points, color }); }); // . . .</span></span></code> </pre> <br><p> 结果，我们得到了凸多边形的镶嵌图。 也是一个非常有趣的结果。 </p><br><blockquote> 将所有数字四舍五入为整数或至少两位小数很有用。  SVG中过高的精度在这里是完全没有必要的，它只会增加图片的大小。 </blockquote><br><h2 id="razmytaya-mozaika"> 马赛克模糊 </h2><br><p> 我们将看到的最后一个示例是模糊的马赛克。 我们掌握了SVG的全部功能，那么为什么不使用过滤器呢？ </p><br><p><img src="https://habrastorage.org/webt/xt/us/k1/xtusk1lqy7g9zsolqqanjrmqcva.jpeg"></p><br><p> 取得矩形的第一个马赛克，并向其中添加标准的“模糊”滤镜： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'my-filter'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'0'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">feGaussianBlur</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'SourceGraphic'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stdDeviation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'2'</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">g</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">filter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'url(#my-filter)'</span></span></span><span class="hljs-tag">&gt;</span></span> {{# each rects }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rect</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ x }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ y }}'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'6'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'{{ color }}'</span></span></span><span class="hljs-tag"> /&gt;</span></span> {{/each }} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">g</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 结果是模糊，“删减”了我们的图片预览，它几乎减少了10倍的空间（不压缩），向量，并且可以拉伸到任何屏幕尺寸。 同样，您可以模糊其余马赛克。 </p><br><blockquote> 将此类滤镜应用于规则的矩形马赛克时，可能会出现“吉普效果”，因此，如果在生产中使用此类滤镜，尤其是对大型图片，则对模糊而不是对Voronoi分割应用模糊效果可能会更漂亮。 </blockquote><br><h2 id="vmesto-zaklyucheniya"> 而不是结论 </h2><br><p> 在本文中，我们研究了如何在Node.js上生成各种SVG存根映像，并确保如果您不手工编写所有内容并组装可能的现成模块，那么这并不是一项艰巨的任务。 完整资源<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可在github上找到</a> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431232/">https://habr.com/ru/post/zh-CN431232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431220/index.html">生物学家看我们衰老的根源</a></li>
<li><a href="../zh-CN431222/index.html">网站存档</a></li>
<li><a href="../zh-CN431226/index.html">FPGA Cyclone IV的Snake游戏（带有VGA和SPI游戏杆）</a></li>
<li><a href="../zh-CN431228/index.html">光的障碍物：液晶助您一臂之力</a></li>
<li><a href="../zh-CN431230/index.html">HPC基础架构的存储，或者我们如何在理研日本研究中心收集65 PB的存储</a></li>
<li><a href="../zh-CN431234/index.html">12月11日，莫斯科-Alfa JS MeetUp</a></li>
<li><a href="../zh-CN431236/index.html">如何在2018年用Objective-C编写 第一部分</a></li>
<li><a href="../zh-CN431238/index.html">2018年12月IT领域人力资源专业人员的事件摘要</a></li>
<li><a href="../zh-CN431242/index.html">TLS和Web证书</a></li>
<li><a href="../zh-CN431244/index.html">“两个未过滤的”或射击一条腿的简单方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>