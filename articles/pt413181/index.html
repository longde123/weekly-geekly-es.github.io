<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÆ üëåüèº üëäüèΩ Quando chamadas de fun√ß√£o externas s√£o mais r√°pidas que chamadas C nativas üïû ‚ô†Ô∏è üíä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Adicionado por: good discussion on Hacker News 

 David Yu, no GitHub, desenvolveu um teste de desempenho interessante para chamadas de fun√ß√£o por mei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quando chamadas de fun√ß√£o externas s√£o mais r√°pidas que chamadas C nativas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413181/"> <font color="gray"><i>Adicionado por: good discussion on <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hacker News</a></i></font> <br><br>  David Yu, no GitHub, desenvolveu um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teste de desempenho interessante</a> para chamadas de fun√ß√£o por meio de v√°rias interfaces externas (Foreign Function Interfaces, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FFI</a> ). <br><br>  Ele criou um arquivo de objeto compartilhado ( <code>.so</code> ) com uma fun√ß√£o simples C. Em seguida, ele escreveu um c√≥digo para chamar essa fun√ß√£o repetidamente por cada FFI com uma dimens√£o de tempo. <br><br>  Para C "FFI", ele usou o link din√¢mico padr√£o, n√£o <code>dlopen()</code> .  Essa diferen√ßa √© muito importante, pois realmente afeta os resultados do teste.  Voc√™ pode argumentar qu√£o honesta essa compara√ß√£o √© com a FFI real, mas ainda √© interessante medir. <br><br>  O resultado de refer√™ncia mais surpreendente √© que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> FFI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de LuaJIT</a> √© <b>significativamente mais r√°pido que C.</b>  √â cerca de 25% mais r√°pido que uma chamada C nativa para uma fun√ß√£o de objeto compartilhado.  Como uma linguagem de script de tipo fraco e din√¢mico pode ultrapassar a refer√™ncia C?  O resultado √© preciso? <br><a name="habracut"></a><br>  De fato, isso √© bastante l√≥gico.  O teste √© executado no Linux, portanto, o atraso vem da Tabela de Liga√ß√£o de Procedimentos (PLT).  Eu preparei um experimento realmente simples para demonstrar o efeito na plan√≠cie antiga C: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/skeeto/dynamic-function-benchmark</a> <br><br>  Aqui est√£o os resultados do Intel i7-6700 (Skylake): <br><br> <code>plt: 1.759799 ns/call <br> ind: 1.257125 ns/call <br> jit: 1.008108 ns/call</code> <br> <br>  Existem tr√™s tipos diferentes de chamadas de fun√ß√£o: <br><br><ol><li>  Via PLT. </li><li>  Chamada de fun√ß√£o indireta (via <code>dlsym(3)</code> ) </li><li>  Chamada de fun√ß√£o direta (atrav√©s de uma fun√ß√£o compilada JIT) </li></ol><br>  Como voc√™ pode ver, o √∫ltimo √© o mais r√°pido.  Geralmente n√£o √© usado em programas C, mas √© uma op√ß√£o natural na presen√ßa de um compilador JIT, incluindo, obviamente, LuaJIT. <br><br>  No meu benchmark, a fun√ß√£o <code>empty()</code> √© chamada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Compile em um objeto compartilhado: <br><br><pre> <code class="cpp hljs">$ cc -shared -fPIC -Os -o empty.so empty.c</code> </pre> <br>  Como na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compara√ß√£o</a> anterior do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PRNG</a> , o benchmark tantas vezes quanto poss√≠vel chama essa fun√ß√£o antes do alarme disparar. <br><br><h1>  Tabelas de layout de procedimento </h1><br>  Quando um programa ou biblioteca chama uma fun√ß√£o em outro objeto compartilhado, o compilador n√£o pode saber onde essa fun√ß√£o estar√° na mem√≥ria.  As informa√ß√µes s√£o encontradas apenas em tempo de execu√ß√£o quando o programa e suas depend√™ncias s√£o carregados na mem√≥ria.  Geralmente, a fun√ß√£o est√° localizada em locais aleat√≥rios, por exemplo, de acordo com a randomiza√ß√£o do espa√ßo de endere√ßo (Randomiza√ß√£o de Layout do Espa√ßo de Endere√ßo, ASLR). <br><br>  Como resolver esse problema?  Bem, existem v√°rias op√ß√µes. <br><br>  Uma delas √© marcar todas as chamadas em metadados bin√°rios.  O construtor de tempo de execu√ß√£o din√¢mico <i>insere o</i> endere√ßo correto em todas as chamadas.  O mecanismo espec√≠fico depende do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelo de c√≥digo</a> usado durante a compila√ß√£o. <br><br>  A desvantagem dessa abordagem √© que ela diminui o carregamento, aumenta o tamanho dos arquivos bin√°rios e reduz a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">troca de p√°ginas de c√≥digo</a> entre diferentes processos.  O download √© mais lento porque todos os pares de discagem din√¢mica precisam ser corrigidos com o endere√ßo correto antes de iniciar o programa.  O bin√°rio est√° inchado porque cada entrada precisa de um lugar na tabela.  E a falta de compartilhamento est√° associada a uma altera√ß√£o nas p√°ginas de c√≥digo. <br><br>  Por outro lado, a sobrecarga de invocar fun√ß√µes din√¢micas pode ser eliminada, o que fornece um desempenho semelhante ao JIT, conforme mostrado no benchmark. <br><br>  A segunda op√ß√£o √© rotear todas as chamadas din√¢micas por meio de uma tabela.  O ponto de discagem original refere-se ao esbo√ßo nesta tabela e, a partir da√≠, √† fun√ß√£o din√¢mica real.  Com essa abordagem, o c√≥digo n√£o precisa ser corrigido, o que leva a uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">troca trivial</a> entre processos.  Para cada fun√ß√£o din√¢mica, voc√™ precisa corrigir apenas um registro na tabela.  Al√©m disso, essas corre√ß√µes podem ser feitas <i>pregui√ßosamente</i> , na primeira chamada da fun√ß√£o, o que acelera o carregamento ainda mais. <br><br>  Nos sistemas bin√°rios ELF, essa tabela √© chamada de Tabela de Liga√ß√£o de Procedimentos (PLT).  O pr√≥prio PLT n√£o √© realmente corrigido - √© exibido como somente leitura para o restante do c√≥digo.  Em vez disso, a Global Offset Table (GOT) √© corrigida.  O stub PLT recupera o endere√ßo de uma fun√ß√£o din√¢mica do GOT e salta <i>indiretamente</i> para esse endere√ßo.  Para carregar pregui√ßosamente endere√ßos de fun√ß√£o, essas entradas GOT s√£o inicializadas com o endere√ßo da fun√ß√£o que encontra o caractere de destino, atualiza o GOT com esse endere√ßo e depois passa para a fun√ß√£o.  As chamadas subseq√ºentes usam um endere√ßo detectado pregui√ßosamente. <br><br><img src="https://habrastorage.org/webt/47/2r/yh/472ryhlyogynkwwrxyopa1rg7l0.png"><br><br>  A desvantagem do PLT √© a sobrecarga adicional de chamar uma fun√ß√£o din√¢mica, que √© o que apareceu no benchmark.  Como o benchmark mede <i>apenas</i> chamadas de fun√ß√£o, a diferen√ßa parece bastante significativa, mas na pr√°tica geralmente √© pr√≥xima de zero. <br><br>  Aqui est√° a refer√™ncia: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Cleared by an alarm signal. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plt_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) empty(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  Como <code>empty()</code> est√° em um objeto compartilhado, a chamada passa pelo PLT. <br><br><h1>  Chamadas din√¢micas indiretas </h1><br>  Outra maneira de chamar fun√ß√µes dinamicamente √© percorrer o PLT e obter o endere√ßo da fun√ß√£o de destino no programa, por exemplo, via <code>dlsym(3)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *h = dlopen(<span class="hljs-string"><span class="hljs-string">"path/to/lib.so"</span></span>, RTLD_NOW); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*f)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(<span class="hljs-string"><span class="hljs-string">"f"</span></span>); f();</code> </pre> <br>  Se o endere√ßo da fun√ß√£o for recebido, o custo ser√° menor do que a fun√ß√£o chama pelo PLT.  N√£o h√° fun√ß√£o intermedi√°ria do stub e acesso ao GOT.  (Cuidado: se o programa possui um registro PLT para esta fun√ß√£o, o <code>dlsym(3)</code> pode realmente retornar um endere√ßo de stub). <br><br>  Mas este ainda √© um desafio <i>indireto</i> .  Nas arquiteturas convencionais, <i>as</i> chamadas <i>diretas de</i> fun√ß√£o recebem seu endere√ßo relativo imediato.  Ou seja, o objetivo da chamada √© um deslocamento codificado do ponto de chamada.  A CPU pode descobrir para onde a chamada ir√° muito antes. <br><br>  As chamadas indiretas t√™m mais custos indiretos.  Primeiro, o endere√ßo precisa ser armazenado em algum lugar.  Mesmo que seja apenas um registro, seu uso aumenta o d√©ficit de registros.  Segundo, chamadas indiretas provocam um preditor de ramifica√ß√£o na CPU, impondo carga adicional ao processador.  Na pior das hip√≥teses, uma chamada pode at√© parar o pipeline. <br><br>  Aqui est√° a refer√™ncia: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indirect_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) f(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  A fun√ß√£o passada para esse benchmark √© extra√≠da usando o <code>dlsym(3)</code> , portanto o compilador n√£o pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fazer algo complicado</a> , como converter essa chamada indireta de volta em direta. <br><br>  Se o corpo do loop for complexo o suficiente para causar um d√©ficit de registros e, assim, fornecer o endere√ßo para a pilha, esse benchmark tamb√©m n√£o poder√° ser honestamente comparado ao PLT. <br><br><h1>  Chamadas diretas de fun√ß√£o </h1><br>  Os dois primeiros tipos de chamadas de fun√ß√µes din√¢micas s√£o simples e f√°ceis de usar.  Chamadas <i>diretas</i> para fun√ß√µes din√¢micas s√£o mais dif√≠ceis de organizar, pois exigem altera√ß√µes de c√≥digo durante a execu√ß√£o.  No meu benchmark, montei um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pequeno compilador JIT</a> para gerar uma chamada direta. <br><br>  O truque √© que nas transi√ß√µes expl√≠citas x86-64 s√£o limitadas a um intervalo de 2 GB devido ao operando assinado de 32 bits (assinado imediatamente).  Isso significa que o c√≥digo JIT deve ser colocado quase ao lado da fun√ß√£o de destino, <code>empty()</code> .  Se o c√≥digo JIT precisar chamar duas fun√ß√µes din√¢micas diferentes, divididas por mais de 2 GB, √© imposs√≠vel fazer duas chamadas diretas. <br><br>  Para simplificar a situa√ß√£o, minha refer√™ncia n√£o est√° preocupada com a escolha exata ou muito cuidadosa do endere√ßo do c√≥digo JIT.  Depois de receber o endere√ßo da fun√ß√£o de destino, ele simplesmente subtrai 4 MB, arredonda para a p√°gina mais pr√≥xima, aloca um pouco de mem√≥ria e grava c√≥digo nela.  Se tudo for feito como deveria, ent√£o, para procurar um local, √© necess√°rio verificar suas pr√≥prias representa√ß√µes do programa na mem√≥ria, e isso n√£o pode ser feito de maneira limpa e port√°til.  O Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">requer a an√°lise de arquivos virtuais em / proc</a> . <br><br>  √â assim que minha aloca√ß√£o de mem√≥ria JIT se parece.  Ele pressup√µe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um comportamento razo√°vel para transmitir uintptr_t</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jit_compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct jit_func *f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*empty)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> addr = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)empty; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *desired = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((addr - SAFETY_MARGIN) &amp; PAGEMASK); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = mmap(desired, len, prot, flags, fd, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Duas p√°ginas se destacam aqui: uma para escrita e a outra com c√≥digo n√£o grav√°vel.  Como na minha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca de fechamentos</a> , aqui a p√°gina inferior √© grav√°vel e cont√©m uma vari√°vel em <code>running</code> que √© redefinida para alarme.  Esta p√°gina deve estar ao lado do c√≥digo JIT para fornecer acesso efetivo ao RIP, como uma fun√ß√£o nos outros dois benchmarks.  A p√°gina superior cont√©m este c√≥digo de montagem: <br><br><pre> <code class="hljs vbscript">jit_benchmark: push rbx <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> ebx, ebx .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: mov eax, [rel running] test eax, eax je .done <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span> inc ebx jmp .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> .done: mov eax, ebx pop rbx ret</code> </pre> <br>  <code>call empty</code> √© a √∫nica instru√ß√£o gerada dinamicamente, √© necess√°rio preencher corretamente o endere√ßo relativo (menos 5 √© indicado em rela√ß√£o ao <i>final da</i> instru√ß√£o): <br><br><pre> <code class="hljs lisp"> // call empty uintptr_t rel = (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)empty - (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)p - <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-comment"><span class="hljs-comment">; *p++ = 0xe8; *p++ = rel &gt;&gt; 0; *p++ = rel &gt;&gt; 8; *p++ = rel &gt;&gt; 16; *p++ = rel &gt;&gt; 24;</span></span></code> </pre> <br>  Se a fun√ß√£o <code>empty()</code> n√£o estiver no objeto geral, mas no mesmo arquivo bin√°rio, essa √© essencialmente uma chamada direta que o compilador ir√° gerar para <code>plt_benchmark()</code> , assumindo que, por algum motivo, ele n√£o tenha constru√≠do <code>empty()</code> . <br><br>  Ironicamente, chamar um c√≥digo compilado por JIT requer uma chamada indireta (por exemplo, atrav√©s de um ponteiro de fun√ß√£o), e n√£o h√° como contornar isso.  O que posso fazer aqui, JIT-compila outra fun√ß√£o para uma chamada direta?  Felizmente, isso n√£o importa, porque apenas uma chamada direta √© medida em um loop. <br><br><h1>  Nenhum segredo </h1><br>  Diante desses resultados, fica claro por que o LuaJIT gera chamadas mais eficientes para fun√ß√µes din√¢micas que o PLT, <i>mesmo que permane√ßam chamadas indiretas</i> .  No meu benchmark, as chamadas indiretas sem PLT foram 28% mais r√°pidas que com o PLT, e as chamadas diretas sem PLT foram 43% mais r√°pidas que com o PLT.  Essa pequena vantagem dos programas JIT em rela√ß√£o aos programas nativos antigos simples √© alcan√ßada devido √† rejei√ß√£o absoluta da troca de c√≥digo entre processos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413181/">https://habr.com/ru/post/pt413181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413169/index.html">M√©todos √∫teis de matriz e objeto em JavaScript</a></li>
<li><a href="../pt413171/index.html">Tokamak JET lan√ßa nova campanha de deut√©rio e tr√≠tio</a></li>
<li><a href="../pt413173/index.html">Monitorando erros de JavaScript com window.onerror</a></li>
<li><a href="../pt413175/index.html">An√°lise est√°tica no Go: como economizamos tempo ao verificar o c√≥digo</a></li>
<li><a href="../pt413177/index.html">Eventos digitais em Moscou, de 4 a 10 de junho</a></li>
<li><a href="../pt413183/index.html">Mem√≥ria persistente Optane DC - Optane no formato DIMM</a></li>
<li><a href="../pt413185/index.html">Jogo sujo, ou como os organizadores do sorteio nos enganam</a></li>
<li><a href="../pt413187/index.html">Entrevista com Ryan Dahl, criador do Node.js</a></li>
<li><a href="../pt413189/index.html">Cole√ß√£o de sombras css Box-shadows.css</a></li>
<li><a href="../pt413193/index.html">Compra de ferro contra a nuvem: como contar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>