<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÅÔ∏è üëçüèæ ‚öíÔ∏è Memperkenalkan Versi Alpha dari Snapshots Volume di Kubernetes üßòüèº ü§µüèæ üßñüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Artikel asli baru-baru ini diterbitkan di blog Kubernetes dan ditulis oleh karyawan Google dan Huawei (Jing Xu, Xing Yang, Saad Ali),...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperkenalkan Versi Alpha dari Snapshots Volume di Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/426133/"><img src="https://habrastorage.org/webt/ok/pe/iy/okpeiy2vp8v36hzrr-ddpboknyi.png"><br><br>  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Artikel asli baru-baru ini diterbitkan di blog Kubernetes dan ditulis oleh karyawan Google dan Huawei (Jing Xu, Xing Yang, Saad Ali), yang aktivitasnya sudah pasti Anda lihat di GitHub proyek, jika Anda pernah tertarik dengan fitur dan masalah K8 yang terkait dengan dengan penyimpanan data.</i>  <i>Insinyur berbicara tentang tujuan snapshot volume, kemampuan mereka saat ini dan dasar-dasar bekerja dengan mereka.</i> <a name="habracut"></a><br><br>  Kubernetes v1.12 memperkenalkan versi alfa dukungan untuk snapshot untuk volume.  Fitur ini memungkinkan Anda untuk membuat dan menghapus snapshot volume, serta membuat volume baru dari snapshot menggunakan sarana "asli" dari sistem - melalui API Kubernetes. <br><br><h2>  Apa itu snapshot? </h2><br>  Banyak sistem penyimpanan (seperti Google Cloud Persistent Disk, Amazon Elastic Block Storage, dan banyak sistem penyimpanan di lokasi) menawarkan kemampuan untuk membuat snapshot ("snapshot") untuk volume persisten.  Cuplikan adalah salinan volume pada titik waktu tertentu.  Ini dapat digunakan untuk memberikan volume baru (sudah diisi dengan data dari snapshot) atau mengembalikan volume yang ada ke keadaan sebelumnya (yang disajikan dalam snapshot). <br><br><h2>  Mengapa menambahkan snapshot ke Kubernetes? </h2><br>  Sebuah abstraksi yang kuat sudah tersedia di sistem plug-in volume Kubernetes, mengotomatisasi penyediaan, menghubungkan dan memasang blok dan penyimpanan file. <br><br>  Menyediakan semua kemampuan ini adalah bagian dari tujuan toleransi beban kerja Kubernetes: Kubernetes bertujuan untuk membuat tingkat abstraksi antara aplikasi yang bekerja sebagai sistem terdistribusi dan kluster yang mendasarinya sehingga aplikasi independen dari kluster spesifik yang mereka jalankan, dan penerapan aplikasi tidak memerlukan pengetahuan khusus klaster. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes Storage SIG telah</a> mengidentifikasi operasi snapshot sebagai kemampuan penting untuk berbagai beban kerja stateful.  Misalnya, administrator basis data mungkin ingin memotret basis datanya sebelum melakukan operasi apa pun di dalamnya. <br><br>  Dengan mendapatkan API Kubernetes cara standar untuk menjalankan operasi snapshot, pengguna Kubernetes dapat bekerja dengannya tanpa perlu penyelesaian masalah (dan doa manual operasi khusus untuk sistem penyimpanan).  Sebagai gantinya, pengguna diberi kesempatan untuk menanamkan operasi snapshot dalam alat dan kebijakan mereka dengan pemahaman yang tenang bahwa semuanya akan bekerja dengan kluster Kubernetes apa pun, terlepas dari penyimpanan yang mendasarinya. <br><br>  Selain itu, primitif Kubernetes ini berfungsi sebagai blok bangunan dasar, membuka jalan bagi pengembangan fitur tingkat perusahaan yang lebih maju untuk manajemen penyimpanan - misalnya, untuk perlindungan, replikasi, dan migrasi data. <br><br><h2>  Apa plugin volume yang mendukung snapshot di Kubernetes? </h2><br>  Kubernetes mendukung tiga jenis plugin volume: in-tree, Flex, dan CSI.  Lihat <a href="">FAQ Plugin Volume Kubernetes untuk</a> detailnya. <br><br>  Snapshots hanya didukung untuk driver CSI (mereka tidak didukung untuk in-tree atau Flex).  Untuk memanfaatkan fitur ini, pastikan bahwa driver CSI yang mengimplementasikan dukungan snapshot dikerahkan di cluster Kubernetes. <br><br>  Pada saat posting blog ini <i>(9 Oktober 2018 - <b>sekitar Terjemahan</b> )</i> , Snapshots didukung oleh driver CSI berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Disk Persisten GCE</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenSDS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ceph rbd</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Portworx</a> </li></ul><br>  Dukungan untuk snapshot untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">driver lain</a> sedang dalam pengembangan dan akan segera tersedia.  Rincian lebih lanjut tentang CSI dan cara menggunakan driver CSI dijelaskan dalam publikasi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Container Storage Interface (CSI) untuk Kubernetes Goes Beta</a> " <i>(dan juga lihat terjemahan kami dari catatan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Antarmuka Penyimpanan Kontainer (dalam Kubernetes dan banyak lagi)</a> " - <b>sekitar Terjemahan.</b> )</i> <br><br><h2>  API Kubernetes untuk snapshot </h2><br>  Untuk mengelola snapshot, Volume Snapshots Kubernetes memperkenalkan tiga objek API baru dengan cara yang sama seperti di Kubernetes Persistent Volumes API: <br><br><ul><li> <code>VolumeSnapshot</code> <br> <ul><li>  Dibuat oleh pengguna Kubernetes untuk meminta snapshot untuk volume yang ditentukan.  Berisi informasi tentang operasi snapshot, seperti cap waktu untuk menghapus snapshot dan apakah siap untuk digunakan. </li><li>  Seperti objek <code>PersistentVolumeClaim</code> , membuat dan menghapus objek ini mewakili keinginan pengguna untuk membuat atau menghapus sumber daya klaster (snapshot). </li></ul></li><li> <code>VolumeSnapshotContent</code> <br> <ul><li>  Dibuat oleh driver CSI ketika snapshot berhasil dibuat.  Berisi informasi tentang foto itu termasuk ID-nya. </li><li>  Seperti objek <code>PersistentVolume</code> , itu mewakili sumber daya yang sudah dilayani oleh cluster (snapshot). </li><li>  Seperti objek <code>PersistentVolumeClaim</code> dan <code>PersistentVolume</code> , saat snapshot dibuat, objek <code>VolumeSnapshotContent</code> dilampirkan ke <code>VolumeSnapshot</code> yang dibuatnya (pemetaan satu-ke-satu digunakan). </li></ul></li><li> <code>VolumeSnapshotClass</code> <br> <ul><li>  Didefinisikan oleh administrator cluster untuk menjelaskan snapshot mana yang dapat dibuat.  Termasuk informasi pengemudi, rahasia untuk mengakses foto, dll. </li></ul></li></ul><br>  Penting untuk dicatat bahwa - tidak seperti objek Volume Persisten utama di Kubernetes - objek snap shot ini didefinisikan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CustomResourceDefinitions (CRDs)</a> .  Proyek Kubernetes secara bertahap bergerak menjauh dari tipe sumber daya yang telah ditentukan sebelumnya di Server API, mendekati model di mana Server API tidak tergantung pada objek API.  Pendekatan ini memungkinkan Anda untuk menggunakan kembali server API di proyek lain (selain Kubernetes), dan konsumen (seperti Kubernetes) dapat menetapkan jenis sumber daya yang mereka butuhkan sebagai CRD. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Driver CSI</a> yang mendukung snapshot akan secara otomatis menginstal CRD yang diperlukan.  Pengguna akhir Kubernetes hanya perlu memverifikasi bahwa driver CSI yang mendukung snapshot dikerahkan di cluster. <br><br>  Selain objek-objek baru ini, <code>PersistentVolumeClaim</code> ada <code>PersistentVolumeClaim</code> bidang <code>DataSource</code> baru: <br><br><pre> <code class="plaintext hljs">type PersistentVolumeClaimSpec struct { AccessModes []PersistentVolumeAccessMode Selector *metav1.LabelSelector Resources ResourceRequirements VolumeName string StorageClassName *string VolumeMode *PersistentVolumeMode DataSource *TypedLocalObjectReference }</code> </pre> <br>  Bidang ini (dalam status versi alfa) memungkinkan Anda untuk mengisinya secara otomatis dengan data dari snapshot yang ada saat membuat volume baru. <br><br><h2>  Persyaratan Snapshot Kubernetes </h2><br>  Sebelum menggunakan snapshot volume di Kubernetes, Anda harus: <br><br><ul><li>  pastikan bahwa driver CSI yang mengimplementasikan snapshots dikerahkan dan berjalan di cluster; </li><li>  aktifkan fungsi Volume Snapshotting Kubernetes melalui gerbang fitur baru (dinonaktifkan secara default untuk versi alpha): <br><ul><li>  atur tanda berikut untuk <code>--feature-gates=VolumeSnapshotDataSource=true</code> API Server: <code>--feature-gates=VolumeSnapshotDataSource=true</code> </li></ul></li></ul><br>  Sebelum membuat snapshot, Anda juga harus menentukan driver CSI mana yang akan digunakan, yang dilakukan dengan membuat objek <code>VolumeSnapshotClass</code> dan menentukan driver CSI di bidang <code>snapshotter</code> .  Pada contoh <code>VolumeSnapshotClass</code> bawah ini, driver ini adalah driver <code>com.example.csi-driver</code> .  Setiap penyedia snapshot membutuhkan setidaknya satu objek <code>VolumeSnapshotClass</code> .  Dimungkinkan juga untuk menentukan <code>VolumeSnapshotClass</code> default untuk setiap driver CSI - ini dilakukan dengan mengatur <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> anotasi <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code> dalam definisi kelas: <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: default-snapclass annotations: snapshot.storage.kubernetes.io/is-default-class: "true" snapshotter: com.example.csi-driver apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: csi-snapclass snapshotter: com.example.csi-driver parameters: fakeSnapshotOption: foo csiSnapshotterSecretName: csi-secret csiSnapshotterSecretNamespace: csi-namespace</code> </pre> <br>  Semua parameter yang diperlukan harus ditetapkan sesuai dengan dokumentasi driver CSI.  Pada contoh di atas, parameter <code>fakeSnapshotOption: foo</code> dan semua rahasia yang disebutkan akan diteruskan ke driver CSI selama pembuatan dan penghapusan snapshot.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSI external-snapshotter</a> secara default menyimpan kunci parameter <code>csiSnapshotterSecretNamespace</code> dan <code>csiSnapshotterSecretNamespace</code> . <br><br>  Terakhir, sebelum membuat snapshot, Anda harus membuat volume melalui driver CSI dan mengisinya dengan data yang ingin Anda lihat di sana (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi ini</a> untuk detail tentang cara menggunakan volume CSI). <br><br><h2>  Membuat snapshot baru di Kubernetes </h2><br>  Setelah objek <code>VolumeSnapshotClass</code> ditentukan dan merupakan volume yang ingin Anda hapus snapshot, Anda dapat melakukan operasi ini dengan membuat objek <code>VolumeSnapshot</code> . <br><br>  Sumber untuk snapshot ditentukan oleh dua parameter: <br><br><ul><li>  <code>kind</code> - <code>PersistentVolumeClaim</code> ditunjukkan di sini; </li><li>  <code>name</code> - <code>name</code> sebenarnya dari objek PVC. </li></ul><br>  Dipahami bahwa namespace volume tempat snapshot dibuat ditentukan oleh namespace objek <code>VolumeSnapshot</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: new-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass source: name: mypvc kind: PersistentVolumeClaim</code> </pre> <br>  Spesifikasi <code>VolumeSnapshot</code> dapat <code>VolumeSnapshot</code> <code>VolumeSnapshotClass</code> yang berisi informasi tentang driver CSI mana yang akan digunakan untuk membuat snapshot.  Seperti dilaporkan sebelumnya, setelah membuat objek <code>VolumeSnapshot</code> <code>fakeSnapshotOption: foo</code> parameter <code>fakeSnapshotOption: foo</code> dan semua rahasia <code>VolumeSnapshotClass</code> disebutkan dilewatkan ke plugin CSI <code>com.example.csi-driver</code> di panggilan <code>CreateSnapshot</code> . <br><br>  Menanggapi permintaan tersebut, pengandar CSI mengambil snapshot volume dan kemudian secara otomatis membuat objek <code>VolumeSnapshotContent</code> yang mewakili snapshot baru dan mengikat objek ini ke <code>VolumeSnapshot</code> , membuatnya siap digunakan.  Jika driver CSI tidak dapat membuat snapshot dan mengembalikan kesalahan, kontroler snapshot melaporkan kesalahan ini dalam status objek <code>VolumeSnapshot</code> dan <b>tidak</b> melakukan upaya baru (perilaku ini berbeda dari pengontrol lain di Kubernetes - ini diterapkan agar tidak membuat snapshot pada waktu yang tidak terduga) . <br><br>  Jika kelas snapshot tidak ditentukan, snapshot eksternal akan mencoba menemukan kelas default dan menggunakannya untuk snapshot yang dibuat.  Dalam kasus ini, driver CSI yang ditunjuk oleh <code>snapshotter</code> di kelas default harus sesuai dengan driver CSI yang ditunjukkan oleh <code>provisioner</code> di kelas penyimpanan PVC. <br><br>  Harap dicatat bahwa rilis alpha snapshots untuk Kubernetes tidak memberikan jaminan konsistensi.  Untuk memastikan data lengkap dalam sebuah snapshot, perlu mempersiapkan aplikasi dengan benar (menghentikan aplikasi, membekukan sistem file, dll.) Sebelum menghapusnya. <br><br>  Untuk <code>VolumeSnapshot</code> bahwa objek <code>VolumeSnapshot</code> dibuat dan dikaitkan dengan <code>VolumeSnapshotContent</code> , Anda dapat menggunakan <code>kubectl describe volumesnapshot</code> : <br><br><ul><li>  <code>Ready</code> harus <code>true</code> dalam <code>Status</code> , yang akan menunjukkan bahwa snapshot volume siap digunakan. </li><li>  Bidang <code>Creation Time</code> menunjukkan kapan snapshot benar-benar diambil. </li><li>  Bidang <code>Restore Size</code> adalah ukuran volume minimum untuk memulihkan foto. </li><li>  Bidang <code>Snapshot Content Name</code> dalam spesifikasi menunjuk ke objek <code>VolumeSnapshotContent</code> dibuat untuk snapshot ini. </li></ul><br><h2>  Impor snapshot yang ada ke Kubernetes </h2><br>  Snapshot yang ada dapat diimpor ke Kubernetes dengan secara manual membuat objek <code>VolumeSnapshotContent</code> yang akan mewakili snapshot ini.  Karena <code>VolumeSnapshotContent</code> adalah objek API yang tidak terikat ke namespace, hanya administrator sistem yang memiliki hak untuk membuatnya. <br><br>  Ketika objek <code>VolumeSnapshotContent</code> dibuat, pengguna dapat membuat objek lain - <code>VolumeSnapshot</code> - yang akan menunjuk ke sana.  Pengontrol snapshot eksternal akan menandai snapshot sebagai siap setelah memeriksa keberadaan dan koneksi yang benar antara objek <code>VolumeSnapshot</code> dan <code>VolumeSnapshotContent</code> .  Sebuah snapshot siap digunakan di Kubernetes ketika koneksi ini dibuat. <br><br>  Objek <code>VolumeSnapshotContent</code> harus dibuat dengan bidang-bidang berikut yang mewakili snapshot yang sudah <i>disediakan sebelumnya</i> : <br><br><ul><li>  <code>csiVolumeSnapshotSource</code> - informasi yang mengidentifikasi snapshot: <br><ul><li>  <code>snapshotHandle</code> - nama / pengidentifikasi untuk snapshot.  Bidang wajib; </li><li>  <code>driver</code> - <code>driver</code> CSI yang digunakan untuk bekerja dengan volume ini.  Bidang wajib.  Harus cocok dengan nama <code>snapshotter</code> di controller (snapshot controller); </li><li>  <code>creationTime</code> dan <code>restoreSize</code> - Untuk volume yang telah ditentukan sebelumnya, bidang ini opsional.  Pengontrol snapshot eksternal akan secara otomatis memperbaruinya setelah membuat snapshot. </li></ul></li><li>  <code>volumeSnapshotRef</code> - penunjuk ke objek <code>VolumeSnapshot</code> objek ini (mis. <code>VolumeSnapshotContent</code> ) harus dilampirkan: <br><ul><li>  <code>name</code> and <code>namespace</code> - nama dan namespace dari objek <code>VolumeSnapshot</code> yang isinya terikat; </li><li>  <code>UID</code> - bidang opsional (untuk volume yang disiapkan sebelumnya).  Pengendali snapshot eksternal akan secara otomatis memperbarui bidang ini setelah mengikat.  Jika pengguna menentukan bidang ini, Anda harus memastikan bahwa itu cocok dengan UID dari snapshot yang mengikat terjadi.  Jika tidak ada korespondensi seperti itu, konten dianggap tidak relevan (objek yatim) dan karenanya controller akan menghapusnya dan snapshot terkait. </li></ul></li><li>  <code>snapshotClassName</code> adalah bidang opsional.  Pengontrol snapshot eksternal akan secara otomatis memperbaruinya setelah mengikat. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotContent metadata: name: static-snapshot-content spec: csiVolumeSnapshotSource: driver: com.example.csi-driver snapshotHandle: snapshotcontent-example-id volumeSnapshotRef: kind: VolumeSnapshot name: static-snapshot-demo namespace: demo-namespace</code> </pre> <br>  Objek <code>VolumeSnapshot</code> harus dibuat agar pengguna dapat bekerja dengan snapshot.  Di dalamnya: <br><br><ul><li>  <code>snapshotClassName</code> - nama kelas snapshot volume.  Bidang opsional.  Jika diatur, bidang <code>snapshotter</code> di kelas snapshot harus cocok dengan nama pengontrol snapshot.  Jika tidak disetel, pengontrol akan mencari kelas snapshot default; </li><li>  <code>snapshotContentName</code> - nama isi volume foto.  Bidang wajib untuk volume yang disiapkan sebelumnya. </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: static-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass snapshotContentName: static-snapshot-content</code> </pre> <br>  Ketika objek-objek ini dibuat, pengontrol snapshot akan mengikatnya, setel bidang <code>Ready</code> (dalam <code>Status</code> ) ke <code>True</code> , yang menunjukkan bahwa snapshot siap digunakan. <br><br><h2>  Mempersiapkan volume baru dari snapshot di Kubernetes </h2><br>  Untuk membuat volume baru yang diisi sebelumnya dengan data dari objek snapshot, gunakan bidang <code>dataSource</code> baru di <code>PersistentVolumeClaim</code> .  Ini memiliki tiga parameter: <br><br><ul><li>  <code>name</code> - nama objek <code>VolumeSnapshot</code> mewakili sumber snapshot; </li><li>  <code>kind</code> - harus ditetapkan sebagai <code>VolumeSnapshot</code> ; </li><li>  <code>apiGroup</code> - harus berupa <code>snapshot.storage.k8s.io</code> . </li></ul><br>  Diasumsikan bahwa namespace dari sumber - <code>VolumeSnapshot</code> - cocok dengan namespace dari <code>PersistentVolumeClaim</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-restore Namespace: demo-namespace spec: storageClassName: csi-storageclass dataSource: name: new-snapshot-demo kind: VolumeSnapshot apiGroup: snapshot.storage.k8s.io accessModes: - ReadWriteOnce resources: requests: storage: 1Gi</code> </pre> <br>  Ketika objek <code>PersistentVolumeClaim</code> dibuat, ia akan memanggil penyediaan volume baru, pra-diisi dengan data dari snapshot yang ditentukan. <br><br><h2>  Bagaimana cara menambahkan dukungan snapshot ke driver CSI saya jika saya seorang pengembang penyimpanan? </h2><br>  Untuk memberikan dukungan untuk snapshot, kapabilitas pengontrol tambahan harus ditambahkan ke driver CSI: <code>CREATE_DELETE_SNAPSHOT</code> dan <code>LIST_SNAPSHOTS</code> , serta pengontrol RPC tambahan: <code>CreateSnapshot</code> , <code>DeleteSnapshot</code> , <code>ListSnapshots</code> .  Lihat <a href="">spesifikasi CSI untuk</a> detailnya. <br><br>  Meskipun Kubernetes memberikan <a href="">pedoman</a> paling <a href="">dasar</a> untuk pengemasan dan penggunaan Pengandar Volume CSI, ada <a href="">mekanisme yang disarankan</a> untuk menggunakan pengandar CSI yang dipaketkan secara sewenang-wenang di Kubernetes untuk menyederhanakan proses ini. <br><br>  Sebagai bagian dari proses penyebaran yang disarankan, tim Kubernetes menyarankan untuk menggunakan beragam wadah sespan (yaitu, tambahan), termasuk wadah sespan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">snapshot eksternal</a> . <br><br>  External-snapshotter yang disebutkan memonitor objek <code>VolumeSnapshot</code> dan <code>VolumeSnapshotContent</code> di Server API, menggunakan operasi <code>CreateSnapshot</code> dan <code>DeleteSnapshot</code> untuk titik akhir CSI.  Wadah sespan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyedia eksternal</a> CSI juga telah diperbarui untuk mendukung pemulihan volume dari snapshot menggunakan bidang PVC <code>dataSource</code> baru. <br><br>  Untuk mendukung kemampuan snapshot, produsen penyimpanan disarankan untuk menggunakan wadah sespan dengan snapshot eksternal sebagai tambahan dari penyedia eksternal, dan menempatkan driver CSI di <code>StatefulSet</code> , seperti yang ditunjukkan pada diagram di bawah ini: <br><br><img src="https://habrastorage.org/webt/9e/og/xm/9eogxmximi8i_y-6tlhber-xjts.png"><br><br>  Dalam <a href="">contoh Penerapan ini, ada</a> dua wadah sespan, penyedia eksternal dan snapshot eksternal, dan driver CSI dikerahkan dengan plugin hostpath CSI dalam pod StatefulSet.  Hostpath CSI adalah plugin contoh yang tidak dimaksudkan untuk digunakan dalam produksi. <br><br><h2>  Apa batasan dari versi alpha? </h2><br>  Versi alpha dari implementasi snapshot di Kubernetes memiliki batasan berikut: <br><br><ul><li>  Kembalikan dari volume yang ada ke keadaan sebelumnya yang diwakili oleh foto tidak didukung (hanya penyediaan volume baru dari foto yang didukung). </li><li>  Pemulihan di tempat tidak didukung untuk <code>PersistentVolumeClaim</code> dari snapshot: i.e.  penyediaan volume baru dari karya snapshot, tetapi tidak memperbarui <code>PersistentVolumeClaim</code> ada sehingga mengarah ke volume baru dan PVC kembali ke keadaan sebelumnya (hanya menggunakan volume baru yang dibuat dari snapshot melalui PV / PVC baru didukung). </li><li>  Jaminan untuk konsistensi snapshot tidak melampaui jaminan yang diberikan oleh sistem penyimpanan (misalnya, integritas saat dijatuhkan). </li></ul><br><h2>  Apa selanjutnya </h2><br>  Tim Kubernetes berencana untuk membawa implementasi snapshots untuk CSI ke versi beta dalam rilis 1.13 atau 1.14, tergantung pada umpan balik yang diterima dan adaptasi dari teknologi. <br><br><h2>  Bagaimana cara mengetahui lebih lanjut? </h2><br>  Lihat dokumentasi snapshot tambahan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">k8s.io/docs/concepts/storage/volume-snapshots</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubernetes-csi.github.io/docs</a> . <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes 1.12: Gambaran Umum Inovasi-inovasi Utama</a> ‚Äù; </li><li>  "Kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memahami Antarmuka Penyimpanan Kontainer (dalam Kubernet dan bukan hanya)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rook adalah" gudang data mandiri untuk Kubernetes</a> "; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalaman kami dengan Kubernetes dalam proyek-proyek kecil</a> ‚Äù <i>(review dan laporan video)</i> ; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitoring and Kubernetes</a> ‚Äù <i>(ulasan dan laporan video)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426133/">https://habr.com/ru/post/id426133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426119/index.html">Barang Antik: Cryptonomicon Iron</a></li>
<li><a href="../id426121/index.html">MC.exe (Kompiler pesan), rc.exe, link.exe untuk menghasilkan .dll untuk EventMessageFile</a></li>
<li><a href="../id426123/index.html">Pelajari OpenGL. Pelajaran 6.1. PBR atau Rendering yang Tepat Secara Fisik. Teori</a></li>
<li><a href="../id426125/index.html">Steroid karier. Elevator</a></li>
<li><a href="../id426131/index.html">Unduh konfigurasi ke FPGA melalui USB atau bongkar FTDI MPSSE</a></li>
<li><a href="../id426135/index.html">Cloud Pribadi untuk Internet of Things</a></li>
<li><a href="../id426137/index.html">Zaman Kejujuran</a></li>
<li><a href="../id426141/index.html">Red Hat ganti Docker dengan Podman</a></li>
<li><a href="../id426143/index.html">Animasi 3D - video atau interaktif?</a></li>
<li><a href="../id426145/index.html">Lokakarya Penerimaan Independen, 23 Oktober, Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>