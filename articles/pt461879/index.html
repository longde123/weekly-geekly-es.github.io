<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐼 ⛲️ ✴️ O livro "Linux em ação" 🕺🏾 ✉️ 👩🏿‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi, habrozhiteli! No livro, David Clinton descreve 12 projetos do mundo real, incluindo automatizar um sistema de backup e recuperação, configurar uma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O livro "Linux em ação"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/461879/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/d4/en/xh/d4enxhes8pqnlk78urqxopa7ley.jpeg" align="left" alt="imagem"></a>  Oi, habrozhiteli!  No livro, David Clinton descreve 12 projetos do mundo real, incluindo automatizar um sistema de backup e recuperação, configurar uma nuvem de arquivos pessoal no estilo Dropbox e criar seu próprio servidor MediaWiki.  Com exemplos interessantes, você aprenderá sobre virtualização, recuperação de desastres, segurança, backup, implantação do DevOps e solução de problemas do sistema.  Cada capítulo termina com uma revisão de recomendações práticas, um glossário de novos termos e exercícios. <br><br><h3>  Trecho "10.1.  Criando um túnel OpenVPN » </h3><br><a name="habracut"></a>  Neste livro, eu já falei muito sobre criptografia.  O SSH e o SCP podem proteger os dados transmitidos por conexões remotas (capítulo 3), a criptografia de arquivos permite proteger os dados quando armazenados no servidor (capítulo 8), e os certificados TLS / SSL podem proteger os dados durante a transmissão entre sites e navegadores clientes (capítulo 9).  Mas, às vezes, seus dados exigem proteção em uma ampla variedade de conexões.  Por exemplo, é possível que alguns membros da sua equipe trabalhem na estrada, conectando-se à rede via Wi-Fi através de pontos de acesso público.  Definitivamente, você não deve assumir que todos esses pontos de acesso são seguros, mas seu pessoal realmente precisa de uma maneira de se conectar aos recursos da empresa - nesse caso, uma VPN ajudará. <br><br>  Um túnel VPN projetado corretamente fornece uma conexão direta entre clientes remotos e o servidor de forma a ocultar os dados quando eles são transmitidos por uma rede insegura.  E daí?  Você já viu muitas ferramentas que podem fazer isso com criptografia.  O valor real das VPNs é que, ao abrir o túnel, você pode conectar redes remotas, como se todas estivessem juntas localmente.  Em certo sentido, você está usando uma solução alternativa. <br><br>  Usando uma rede estendida, os administradores podem trabalhar em seus servidores de qualquer lugar.  Mas, mais importante, uma empresa com recursos distribuídos por várias filiais pode torná-las visíveis e acessíveis a todos os grupos que precisam deles, onde quer que estejam (Fig. 10.1). <br><br>  O próprio túnel não garante segurança.  Mas um dos padrões de criptografia pode ser incluído na estrutura da rede, o que aumenta significativamente o nível de segurança.  Os túneis criados usando o pacote OpenVPN de código aberto usam a mesma criptografia TLS / SSL que você já leu.  O OpenVPN não é a única opção disponível para tunelamento, mas uma das mais famosas.  Acredita-se que seja um pouco mais rápido e seguro do que um protocolo de encapsulamento de camada 2 alternativo que usa criptografia IPsec. <br><br>  Deseja que todos na sua equipe se comuniquem com segurança enquanto estão na estrada ou trabalhando em prédios diferentes?  Para fazer isso, você deve criar um servidor OpenVPN para permitir o compartilhamento de aplicativos e acesso ao ambiente de rede local do servidor.  Para isso funcionar, basta iniciar duas máquinas virtuais ou dois contêineres: um para atuar como servidor / host e outro para o cliente.  Criar uma VPN não é um processo fácil, por isso provavelmente vale a pena levar alguns minutos para obter uma visão geral. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vg/gc/o1/vggco1j4npzsjj4rqo8r-5bzmz8.png" alt="imagem"></div><br><h3>  10.1.1  Configurando o servidor OpenVPN </h3><br>  Antes de começar, darei conselhos úteis.  Se você vai fazer tudo sozinho (e eu recomendo isso para você), provavelmente descobrirá que está trabalhando com várias janelas de terminal abertas na área de trabalho, cada uma conectada à sua máquina.  Existe o risco de que em algum momento você digite o comando errado na janela.  Para evitar isso, você pode usar o comando hostname para alterar o nome da máquina exibido na linha de comando para algo que indique claramente onde você está.  Assim que você fizer isso, será necessário sair do servidor e efetuar login novamente para que as novas configurações entrem em vigor.  Aqui está o que parece: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b8/d9/o9/b8d9o9pzt2-m5-rtirtr46hl1lu.png" alt="imagem"></div><br>  Seguindo essa abordagem e atribuindo os nomes correspondentes a cada uma das máquinas com as quais trabalha, você pode acompanhar facilmente onde está. <br><br><blockquote>  Depois de usar o nome do host, você pode encontrar mensagens irritantes de Incapaz de resolver o host OpenVPN-Server ao executar os seguintes comandos.  A atualização do arquivo / etc / hosts com o novo nome de host correspondente deve corrigir o problema. </blockquote><br><h3>  Preparando seu servidor para OpenVPN </h3><br>  A instalação do OpenVPN no seu servidor requer dois pacotes: openvpn e easy-rsa (para controlar o processo de geração da chave de criptografia).  Se necessário, os usuários do CentOS devem primeiro instalar o repositório epel-release, como você fez no capítulo 2. Para poder verificar o acesso ao aplicativo do servidor, você também pode instalar o servidor da web Apache (apache2 para Ubuntu e httpd no CentOS). <br><br>  Enquanto você estiver configurando o servidor, aconselho a ativar um firewall que bloqueie todas as portas, exceto 22 (SSH) e 1194 (a porta OpenVPN padrão).  Este exemplo ilustra como o ufw funcionará no Ubuntu, mas tenho certeza que você ainda se lembra do programa CentOS do firewall do capítulo 9: <br><br><pre><code class="javascript hljs"># ufw enable # ufw allow <span class="hljs-number"><span class="hljs-number">22</span></span> # ufw allow <span class="hljs-number"><span class="hljs-number">1194</span></span></code> </pre> <br>  Para permitir o roteamento interno entre interfaces de rede no servidor, é necessário descomentar uma linha (net.ipv4.ip_forward = 1) no arquivo /etc/sysctl.conf.  Isso permitirá que você redirecione clientes remotos conforme necessário após a conexão.  Para fazer o novo parâmetro funcionar, execute sysctl -p: <br><br><pre> <code class="javascript hljs"># nano /etc/sysctl.conf # sysctl -p</code> </pre> <br>  Agora o ambiente do servidor está totalmente configurado, mas há outra coisa a ser feita antes de você estar pronto: você precisará seguir estas etapas (as consideraremos em mais detalhes abaixo). <br><br><ol><li>  Crie um conjunto de chaves no servidor para criptografar a infraestrutura de chave pública (PKI) usando os scripts que acompanham o pacote easy-rsa.  Em essência, o servidor OpenVPN também atua como sua própria autoridade de certificação (CA). </li><li>  Prepare as chaves apropriadas para o cliente </li><li>  Configure o arquivo server.conf para o servidor </li><li>  Configure seu cliente OpenVPN </li><li>  Verifique sua VPN </li></ol><br><h3>  Geração de chave de criptografia </h3><br>  Para não complicar sua vida, você pode configurar sua infraestrutura de chave na mesma máquina em que o servidor OpenVPN está em execução.  No entanto, as recomendações de segurança geralmente sugerem o uso de um servidor CA separado para implantações em um ambiente de produção.  O processo de geração e alocação de recursos da chave de criptografia para uso no OpenVPN é ilustrado na Fig.  10.2 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/vl/a0/rwvla0o86yzylrzsytcf--7bnms.png" alt="imagem"></div><br>  Quando você instalou o OpenVPN, o diretório / etc / openvpn / foi criado automaticamente, mas ainda não há nada nele.  Os pacotes openvpn e easy-rsa vêm com arquivos de modelo de amostra que você pode usar como base para sua configuração.  Para iniciar o processo de certificação, copie o diretório de modelos easy-rsa de / usr / share / para / etc / openvpn e mude para o diretório easy-rsa /: <br><br><pre> <code class="javascript hljs"># cp -r /usr/share/easy-rsa/ <span class="hljs-regexp"><span class="hljs-regexp">/etc/</span></span>openvpn $ cd /etc/openvpn/easy-rsa</code> </pre> <br>  O diretório easy-rsa agora conterá alguns scripts.  Na mesa  10.1 lista as ferramentas que você usará para criar chaves. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/zx/zt/ihzxztprk0hm0gr9ozc8sz9qsgs.png" alt="imagem"></div><br><blockquote>  Essas operações requerem privilégios de root; portanto, através do sudo su, você precisa se tornar root. </blockquote><br>  O primeiro arquivo com o qual você trabalhará é chamado vars e contém as variáveis ​​de ambiente que o easy-rsa usa ao gerar chaves.  Você precisa editar o arquivo para usar seus próprios valores, em vez dos valores padrão que já existem.  É assim que meu arquivo será (Listagem 10.1). <br><br>  Listagem 10.1.  Os principais fragmentos do arquivo / etc / openvpn / easy-rsa / vars <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> KEY_COUNTRY=<span class="hljs-string"><span class="hljs-string">"CA"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> KEY_PROVINCE=<span class="hljs-string"><span class="hljs-string">"ON"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> KEY_CITY=<span class="hljs-string"><span class="hljs-string">"Toronto"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> KEY_ORG=<span class="hljs-string"><span class="hljs-string">"Bootstrap IT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> KEY_EMAIL=<span class="hljs-string"><span class="hljs-string">"info@bootstrap-it.com"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> KEY_OU=<span class="hljs-string"><span class="hljs-string">"IT"</span></span></code> </pre> <br>  A execução do arquivo vars permitirá transferir seus valores para o ambiente shell, de onde eles serão incluídos no conteúdo de suas novas chaves.  Por que o comando sudo não funciona sozinho?  Porque, no primeiro estágio, editamos o script chamado vars e o aplicamos.  Aplicativo e significa que o arquivo vars transfere seus valores para o ambiente shell, de onde eles serão incluídos no conteúdo de suas novas chaves. <br><br>  Certifique-se de executar novamente o arquivo usando o novo shell para concluir o processo inacabado.  Quando isso for feito, o script solicitará que você execute outro script, clean-all, para remover qualquer conteúdo do diretório / etc / openvpn / easy-rsa / keys /: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2v/b4/ot/2vb4otncxyedhork8j0cs29s_64.png" alt="imagem"></div><br>  Naturalmente, a próxima etapa é executar o script clean-all, seguido de build-ca, que usa o script pkitool para criar o certificado raiz.  Você será solicitado a confirmar as configurações de autenticação fornecidas pelo vars: <br><br><pre> <code class="javascript hljs"># ./clean-all # ./build-ca Generating a <span class="hljs-number"><span class="hljs-number">2048</span></span> bit RSA private key</code> </pre> <br>  Em seguida, vem o script build-key-server.  Como ele usa o mesmo script pkitool junto com o novo certificado raiz, você verá as mesmas perguntas para confirmar a criação do par de chaves.  As chaves receberão nomes com base nos argumentos que você passar, que, a menos que você inicie várias VPNs neste computador, geralmente será servidor, como no exemplo: <br><br><pre> <code class="javascript hljs"># ./build-key-server server [...] Certificate is to be certified until Aug <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-number"><span class="hljs-number">23</span></span>:<span class="hljs-number"><span class="hljs-number">52</span></span>:<span class="hljs-number"><span class="hljs-number">34</span></span> <span class="hljs-number"><span class="hljs-number">2027</span></span> GMT (<span class="hljs-number"><span class="hljs-number">3650</span></span> days) Sign the certificate? [y/n]:y <span class="hljs-number"><span class="hljs-number">1</span></span> out <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> certificate requests certified, commit? [y/n]y Write out database <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> entries Data Base Updated</code> </pre> <br>  O OpenVPN usa os parâmetros gerados pelo algoritmo Diffie-Hellman (usando build-dh) para negociar autenticação para novas conexões.  O arquivo criado aqui não deve ser secreto, mas deve ser gerado usando o script build-dh para as chaves RSA atualmente ativas.  Se você criar novas chaves RSA no futuro, também precisará atualizar o arquivo com base no algoritmo Diffie-Hellman: <br><br><pre> <code class="javascript hljs"># ./build-dh</code> </pre> <br>  Suas chaves do lado do servidor agora estarão no diretório / etc / openvpn / easy-rsa / keys /, mas o OpenVPN não sabe disso.  Por padrão, o OpenVPN procurará as chaves em / etc / openvpn /, portanto, copie-as: <br><br><pre> <code class="javascript hljs"># cp /etc/openvpn/easy-rsa/keys/server* <span class="hljs-regexp"><span class="hljs-regexp">/etc/</span></span>openvpn # cp /etc/openvpn/easy-rsa/keys/dh2048.pem /etc/openvpn # cp /etc/openvpn/easy-rsa/keys/ca.crt /etc/openvpn</code> </pre> <br><h3>  Preparando Chaves de Criptografia do Cliente </h3><br>  Como você já viu, a criptografia TLS usa pares de chaves correspondentes: uma está instalada no servidor e a outra no cliente remoto.  Isso significa que você precisará de chaves do cliente.  Nosso velho amigo pkitool é exatamente o que você precisa para isso.  Neste exemplo, executando o programa no diretório / etc / openvpn / easy-rsa /, passamos o argumento do cliente para ele para gerar arquivos chamados client.crt e client.key: <br><br><pre> <code class="javascript hljs"># ./pkitool client</code> </pre> <br>  Os dois arquivos do cliente, juntamente com o arquivo ca.crt original, que ainda está no diretório keys /, agora devem ser transferidos com segurança para o seu cliente.  Devido à sua afiliação e direitos de acesso, isso pode não ser tão fácil.  A abordagem mais fácil é copiar manualmente o conteúdo do arquivo de origem (e nada além deste conteúdo) para o terminal em execução na área de trabalho do seu PC (selecione o texto, clique com o botão direito do mouse e selecione Copiar no menu).  Em seguida, cole isso em um novo arquivo com o mesmo nome que você cria no segundo terminal conectado ao seu cliente. <br><br>  Mas qualquer um pode cortar e colar.  Em vez disso, pense como administrador, porque você nem sempre terá acesso à GUI, onde é possível uma operação de recortar / colar.  Copie os arquivos para o diretório inicial do usuário (para que a operação scp remota possa acessá-los) e use chown para alterar o proprietário dos arquivos da raiz para um usuário não raiz regular, para que a ação scp remota possa ser executada.  Verifique se todos os seus arquivos estão atualmente instalados e acessíveis.  Você os moverá para o cliente um pouco mais tarde: <br><br><pre> <code class="javascript hljs"># cp /etc/openvpn/easy-rsa/keys/client.key /home/ubuntu/ # cp /etc/openvpn/easy-rsa/keys/ca.crt /home/ubuntu/ # cp /etc/openvpn/easy-rsa/keys/client.crt /home/ubuntu/ # chown ubuntu:ubuntu /home/ubuntu/client.key # chown ubuntu:ubuntu /home/ubuntu/client.crt # chown ubuntu:ubuntu /home/ubuntu/ca.crt</code> </pre> <br>  Com um conjunto completo de chaves de criptografia prontas para a ação, você precisa informar ao servidor como deseja criar uma VPN.  Isso é feito usando o arquivo server.conf. <br><br><blockquote>  <b>Reduza o número de pressionamentos de tecla</b> <br><br>  Demais para imprimir?  Uma extensão entre parênteses ajudará a reduzir esses seis comandos para dois.  Estou certo de que você pode estudar esses dois exemplos e entender o que está acontecendo.  Mais importante, você pode entender como aplicar esses princípios a operações que envolvem dezenas ou até centenas de elementos: <br><br><pre> <code class="javascript hljs"># cp /etc/openvpn/easy-rsa/keys/{ca.crt,client.{key,crt}} /home/ubuntu/ # chown ubuntu:ubuntu /home/ubuntu/{ca.crt,client.{key,crt}}</code> </pre> <br></blockquote><br><h3>  Configurando o arquivo server.conf </h3><br>  Como você pode saber como deve ser o arquivo server.conf?  Lembre-se do modelo de diretório easy-rsa que você copiou de / usr / share /?  Durante a instalação do OpenVPN, um arquivo de modelo de configuração compactado permaneceu, o qual você pode copiar para / etc / openvpn /.  Vou aproveitar o fato de o modelo ter sido arquivado e apresentá-lo a uma ferramenta útil: zcat. <br><br>  Você já sabe como exibir o conteúdo do texto de um arquivo usando o comando cat, mas e se o arquivo for compactado usando o gzip?  Você sempre pode descompactar o arquivo e o gato exibirá com prazer, mas este é um ou dois passos mais do que o necessário.  Em vez disso, como você provavelmente já adivinhou, é possível inserir o comando zcat para carregar o texto descompactado na memória em uma etapa.  No exemplo a seguir, em vez de imprimir texto na tela, você o redireciona para um novo arquivo chamado server.conf: <br><br><pre> <code class="javascript hljs"># zcat \ /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz \ &gt; <span class="hljs-regexp"><span class="hljs-regexp">/etc/</span></span>openvpn/server.conf $ cd /etc/openvpn</code> </pre> <br>  Deixamos de lado a documentação extensa e útil que acompanha o arquivo e vemos como ele pode parecer quando você terminar de editar.  Observe que o ponto-e-vírgula (;) diz ao OpenVPN para não ler ou executar a próxima linha (Listagem 10.2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ft/en/4r/ften4rayxj99stxecmfjb9mx8eg.png" alt="imagem"></div><br>  Vamos passar por algumas dessas configurações. <br><br><ul><li>  Por padrão, o OpenVPN funciona através da porta 1194. Você pode alterar isso, por exemplo, para ocultar ainda mais suas ações ou evitar conflitos com outros túneis ativos.  Como o 1194 requer uma coordenação mínima com os clientes, é melhor fazer isso. </li><li>  O OpenVPN usa o TCP (Transmission Control Protocol) ou o UDP (User Datagram Protocol) para transferência de dados.  O TCP pode ser um pouco mais lento, mas é mais confiável e mais provável de ser entendido pelos aplicativos em execução nas duas extremidades do túnel. </li><li>  Você pode dizer ao dev tun quando quiser criar um túnel IP mais simples e eficiente que transmita o conteúdo dos dados e nada mais.  Se, por outro lado, você precisar conectar várias interfaces de rede (e as redes que elas representam) criando uma ponte Ethernet, terá que selecionar dev tap.  Se você não entender o que tudo isso significa, use o argumento tun. </li><li>  As próximas quatro linhas passam os nomes OpenVPN dos três arquivos de autenticação no servidor e o arquivo de configurações dh2048 que você criou anteriormente. </li><li>  A linha do servidor define o intervalo e a máscara de sub-rede que serão usados ​​para atribuir endereços IP aos clientes no login. </li><li>  O parâmetro push opcional "route 10.0.3.0 255.255.255.0" permite que clientes remotos acessem sub-redes privadas atrás do servidor.  Para executar este trabalho, você também precisa configurar a rede no próprio servidor, para que a sub-rede privada conheça a sub-rede OpenVPN (10.8.0.0). </li><li>  A linha localhost de compartilhamento de porta 80 permite redirecionar o tráfego do cliente que passa pela porta 1194 para o servidor da web local que escuta na porta 80. (Será útil se você pretende usar o servidor da web para testar sua VPN.) Isso só funciona se quando o protocolo tcp estiver selecionado. </li><li>  O usuário ninguém e as linhas de grupo nogroup devem estar ativos - para isso, exclua o ponto e vírgula (;).  Forçar os clientes remotos a trabalharem sob ninguém e nogroup garante que as sessões no servidor não sejam privilegiadas. </li><li>  log indica que as entradas de log atuais substituirão as entradas antigas toda vez que o OpenVPN for iniciado, enquanto o log-append adicionará novas entradas a um arquivo de log existente.  O próprio arquivo openvpn.log é gravado no diretório / etc / openvpn /. </li></ul><br>  Além disso, o valor de cliente para cliente também é frequentemente adicionado ao arquivo de configuração, para que vários clientes possam se ver além do servidor OpenVPN.  Se você estiver satisfeito com sua configuração, poderá iniciar o servidor OpenVPN: <br><br><pre> <code class="javascript hljs"># systemctl start openvpn</code> </pre> <br><blockquote>  Devido à natureza mutável do relacionamento entre o OpenVPN e o systemd, às vezes pode ser necessária a seguinte sintaxe para iniciar um serviço: systemctl start openvpn @ server. </blockquote><br>  A execução de ip addr para exibir a lista de interfaces de rede do seu servidor agora deve exibir um link para uma nova interface denominada tun0.  O OpenVPN o criará para atender os clientes que chegam: <br><br><pre> <code class="javascript hljs">$ ip addr [...] <span class="hljs-number"><span class="hljs-number">4</span></span>: tun0: mtu <span class="hljs-number"><span class="hljs-number">1500</span></span> qdisc [...] link/none inet <span class="hljs-number"><span class="hljs-number">10.8</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> peer <span class="hljs-number"><span class="hljs-number">10.8</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>/<span class="hljs-number"><span class="hljs-number">32</span></span> scope global tun0 valid_lft forever preferred_lft forever</code> </pre> <br>  Pode ser necessário reiniciar o servidor antes que tudo comece a funcionar completamente.  A próxima parada é o computador cliente. <br><br><h3>  10.1.2  Configuração do cliente OpenVPN </h3><br>  Tradicionalmente, os túneis são construídos com pelo menos duas saídas (caso contrário, nós os chamaríamos de cavernas).  Um OpenVPN configurado corretamente no servidor direciona o tráfego de e para o túnel, por um lado.  Mas você também precisa de algum tipo de software do lado do cliente, ou seja, do outro lado do túnel. <br><br>  Nesta seção, vou focar na configuração manual de um computador Linux de um tipo ou de outro para funcionar como um cliente OpenVPN.  Mas essa não é a única maneira de disponibilizar esta oportunidade.  O OpenVPN suporta aplicativos clientes que podem ser instalados e usados ​​em computadores e laptops com Windows ou macOS, bem como em smartphones e tablets baseados no Android e iOS.  Veja openvpn.net para detalhes. <br><br>  O pacote OpenVPN precisará ser instalado no computador cliente, como foi instalado no servidor, embora não seja necessário o easy-rsa, pois as chaves que você usa já existem.  Você precisa copiar o arquivo de modelo client.conf para o diretório / etc / openvpn / que você acabou de criar.  Desta vez, o arquivo não será arquivado, portanto, o comando cp regular executará essa tarefa perfeitamente: <br><br><pre> <code class="javascript hljs"># apt install openvpn # cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf \ /etc/openvpn/</code> </pre> <br>  A maioria das configurações no seu arquivo client.conf será bem direta: elas devem corresponder aos valores no servidor.  Como você pode ver no exemplo de arquivo a seguir, o parâmetro exclusivo é 192.168.1.23 1194 remoto, que informa ao cliente o endereço IP do servidor.  Novamente, verifique se esse é o endereço do seu servidor.  Você também deve forçar o computador cliente a autenticar o certificado do servidor para evitar um possível ataque man-in-the-middle.  Uma maneira de fazer isso é adicionar o servidor remote-cert-tls da linha (Listagem 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m1/nw/2w/m1nw2wwrhwag7fct4mr4ggng5n4.png" alt="imagem"></div><br>  Agora você pode ir para o diretório / etc / openvpn / e extrair as chaves de certificação do servidor.  Substitua o endereço IP do servidor ou o nome de domínio no exemplo pelos seus valores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/u1/rm/ngu1rmk8tyxrntuepummte1wxuo.png" alt="imagem"></div><br>  Provavelmente nada de emocionante acontecerá até você executar o OpenVPN no cliente.  Como você precisa passar alguns argumentos, você fará isso na linha de comando.  O argumento --tls-client diz ao OpenVPN que você atuará como cliente e se conectará usando a criptografia TLS, e --config aponta para o seu arquivo de configuração: <br><br><pre> <code class="javascript hljs"># openvpn --tls-client --config /etc/openvpn/client.conf</code> </pre> <br>  Leia a saída do comando com atenção para garantir que você esteja conectado corretamente.  Se pela primeira vez algo der errado, isso pode ser devido a uma incompatibilidade entre as configurações entre os arquivos de configuração do servidor e do cliente ou a um problema de conexão / firewall de rede.  Aqui estão algumas dicas para solução de problemas. <br><br><ul><li>  Leia com atenção a saída da operação OpenVPN no cliente.  Muitas vezes, contém conselhos valiosos sobre o que exatamente não pode ser executado e por quê. </li><li>  Verifique as mensagens de erro nos arquivos openvpn.log e openvpn-status.log no diretório / etc / openvpn / no servidor. </li><li>  Verifique as mensagens relacionadas ao OpenVPN e apropriadas à hora nos logs do sistema no servidor e no cliente.  (journalctl -ce exibirá as entradas mais recentes.) </li><li>  Verifique se você possui uma conexão de rede ativa entre o servidor e o cliente (para obter mais detalhes, consulte o capítulo 14). </li></ul><br><h3>  Sobre o autor </h3><br>  <b>David Clinton</b> é um administrador de sistemas, professor e escritor.  Ele administrou, escreveu sobre ele e criou materiais de treinamento para muitas disciplinas técnicas importantes, incluindo sistemas Linux, computação em nuvem (em particular a AWS) e tecnologias de contêineres, como o Docker.  Ele escreveu o livro Learn Amazon Web Services em um mês de almoços (Manning, 2017).  Muitos de seus tutoriais em vídeo podem ser encontrados no Pluralsight.com, e links para outros livros (sobre administração do Linux e virtualização de servidores) estão disponíveis em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bootstrap-it.com</a> . <br><br>  »Mais informações sobre o livro podem ser encontradas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site do editor</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conteúdo</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trecho</a> <br><br>  Cupom de 25% de desconto para vendedores ambulantes - <b>Linux</b> <br>  Após o pagamento da versão impressa do livro, um livro eletrônico é enviado por e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461879/">https://habr.com/ru/post/pt461879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461867/index.html">Como reconhecer imagens e textos no seu telefone usando o ML Kit</a></li>
<li><a href="../pt461871/index.html">101 dicas para se tornar um bom programador (e humano)</a></li>
<li><a href="../pt461873/index.html">ViewPager 2 - nova funcionalidade no antigo invólucro</a></li>
<li><a href="../pt461875/index.html">5 nm vs 3 nm</a></li>
<li><a href="../pt461877/index.html">Java vs Kotlin para Android: opiniões dos desenvolvedores</a></li>
<li><a href="../pt461881/index.html">Guia de registro do Node.js.</a></li>
<li><a href="../pt461885/index.html">EDS é outro tipo de fraude</a></li>
<li><a href="../pt461887/index.html">Entrando no Aeronet Episódio 2: Homing Drone</a></li>
<li><a href="../pt461891/index.html">Como fizemos amigos na infraestrutura bancária usando o ManageIQ</a></li>
<li><a href="../pt461895/index.html">Aprenda enquanto viaja - como dirigimos no 1º Dia Europeu da Análise de Negócios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>