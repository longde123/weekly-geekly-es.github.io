<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👫 🏭 🌨️ Arsitektur pragmatis murni. Brainstorming 👊🏼 🍮 👱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apakah ide itu masuk ke kepala Anda untuk menulis ulang aplikasi perusahaan Anda yang berani dari awal? Jika dari awal, maka itu wow. Setidaknya dua k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur pragmatis murni. Brainstorming</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/419179/">  Apakah ide itu masuk ke kepala Anda untuk menulis ulang aplikasi perusahaan Anda yang berani dari awal?  Jika dari awal, maka itu wow.  Setidaknya dua kali lebih sedikit kode, kan?  Tetapi beberapa tahun akan berlalu, dan itu juga akan tumbuh, menjadi warisan ... tidak ada banyak waktu dan uang untuk menulis ulang untuk melakukannya dengan sempurna. <br><br>  Tenang, pihak berwenang masih tidak akan mengizinkan untuk menulis ulang apa pun.  Masih untuk refactor.  Apa cara terbaik untuk menghabiskan sumber daya kecil Anda?  Bagaimana cara refactor tempat membersihkan? <br><br>  Judul artikel ini termasuk referensi ke buku Paman Bob <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Arsitektur Bersih"</a> , dan itu dibuat berdasarkan laporan yang luar biasa dari Victor Rentea ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web</a> ) di JPoint (di bawah kucing ia akan mulai berbicara sebagai orang pertama, tetapi untuk sekarang baca yang pengantar).  Membaca buku pintar, artikel ini tidak menggantikan, tetapi untuk deskripsi singkat diatur dengan sangat baik. <br><br>  Idenya adalah bahwa hal-hal populer seperti "Arsitektur Bersih" sangat berguna.  Kejutan  Jika Anda perlu memecahkan masalah yang sangat spesifik, kode elegan sederhana tidak memerlukan usaha ekstra dan rekayasa berlebihan.  Arsitektur murni mengatakan bahwa Anda perlu melindungi model domain Anda dari efek eksternal, dan memberi tahu Anda dengan tepat bagaimana hal ini dapat dilakukan.  Pendekatan evolusi untuk meningkatkan volume layanan mikro.  Tes yang membuat refactoring kurang menakutkan.  Anda sudah tahu semua ini?  Atau Anda tahu, tetapi Anda bahkan takut untuk memikirkannya, karena itu mengerikan apa yang harus dilakukan? <br><br>  Siapa yang ingin mendapatkan pil anti-prokrastinasi ajaib yang akan membantu berhenti gemetar dan mulai refactoring - selamat datang di rekaman video dari laporan atau di bawah kucing. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mBxpOvlbAow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><br>  Nama saya Victor, saya dari Romania.  Secara formal, saya seorang konsultan, pakar teknis dan arsitek utama di IBM Romania.  Tetapi jika saya diminta untuk memberikan definisi kegiatan saya sendiri, maka saya adalah seorang penginjil kode murni.  Saya suka membuat kode yang cantik, bersih, dan didukung - sebagai aturan, saya berbicara tentang ini di laporan.  Terlebih lagi, saya terinspirasi oleh pengajaran: melatih pengembang di bidang Java EE, Spring, Dojo, Test Driven Development, Performance Java, serta di bidang penginjilan yang disebutkan - prinsip-prinsip pola kode bersih dan pengembangan mereka. <br><br>  Pengalaman yang menjadi dasar teori saya terutama adalah pengembangan aplikasi perusahaan untuk klien IBM terbesar di Rumania - sektor perbankan. <br><br>  Rencana untuk artikel ini adalah sebagai berikut: <br><br><ul><li>  Pemodelan data: struktur data seharusnya tidak menjadi musuh kita; <br></li><li>  Organisasi logika: prinsip "dekomposisi kode, yang terlalu banyak"; <br></li><li>  "Bawang" adalah arsitektur filosofi Naskah Transaksi yang paling murni; <br></li><li>  Menguji sebagai cara untuk menghadapi ketakutan pengembang. <br></li></ul><br><br>  Tapi pertama-tama, mari kita ingat prinsip-prinsip utama yang kita, sebagai pengembang, harus selalu ingat. <br><br><h4>  Prinsip tanggung jawab tunggal </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/353/dd0/cd5/353dd0cd58012749b70e379e37231265.jpg"><br><br>  Dengan kata lain, kuantitas vs kualitas.  Sebagai aturan, semakin banyak fungsionalitas kelas Anda, semakin buruk hasilnya dalam arti kualitatif.  Mengembangkan kelas besar, programmer mulai menjadi bingung, membuat kesalahan dalam membangun dependensi, dan kode besar, antara lain, lebih sulit untuk di-debug.  Lebih baik memecah kelas tersebut menjadi beberapa yang lebih kecil, yang masing-masing akan bertanggung jawab untuk beberapa subtugas.  Lebih baik memiliki beberapa modul yang digabungkan secara ketat daripada yang satu - besar dan lambat.  Modularitas juga memungkinkan penggunaan kembali logika. <br><br><h4>  Penjilidan modul yang lemah </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/1c8/0f7/f721c80f7b3184be2218a01b66f7440a.jpg"><br><br>  Tingkat pengikatan adalah ukuran seberapa dekat modul Anda berinteraksi satu sama lain.  Ini menunjukkan seberapa luas efek perubahan yang Anda buat pada satu titik di sistem dapat menyebar.  Semakin tinggi pengikatannya, semakin sulit untuk membuat modifikasi: Anda mengubah sesuatu dalam satu modul, dan efeknya meluas jauh dan tidak selalu dengan cara yang diharapkan.  Oleh karena itu, indikator pengikatan harus serendah mungkin - ini akan memberikan kontrol lebih besar atas sistem yang mengalami modifikasi. <br><br><h4>  Jangan diulang </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/9de/5c0/2b99de5c00257d6123553c7bfaed0519.jpg"><br><br>  Implementasi Anda sendiri mungkin bagus hari ini, tapi besok tidak begitu baik.  Jangan biarkan diri Anda menyalin praktik terbaik Anda sendiri dan karenanya mendistribusikannya dalam basis kode.  Anda dapat menyalin dari StackOverflow, dari buku - dari sumber otoritatif apa pun yang (seperti yang Anda tahu pasti) menawarkan implementasi yang ideal (atau dekat dengan itu).  Meningkatkan implementasi Anda sendiri, yang terjadi lebih dari sekali, tetapi dikalikan di seluruh basis kode, bisa sangat melelahkan. <br><br><h4>  Kesederhanaan dan keringkasan </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d4/8d4/c85/7d48d4c85408c620ddcbe644c4acb6f9.jpg"><br><br>  Menurut pendapat saya, ini adalah prinsip utama yang harus diperhatikan dalam rekayasa dan pengembangan perangkat lunak.  "Enkapsulasi dini adalah akar kejahatan," kata Adam Bien.  Dengan kata lain, akar kejahatan terletak pada "rekayasa ulang".  Penulis kutipan, Adam Bien, pada suatu waktu terlibat dalam mengambil aplikasi warisan dan, sepenuhnya menulis ulang kode mereka, menerima basis kode 2-3 kali lebih kecil dari yang asli.  Dari mana asal begitu banyak kode tambahan?  Bagaimanapun, itu muncul karena suatu alasan.  Ketakutannya memunculkan kita.  Tampaknya bagi kami bahwa dengan menumpuk sejumlah besar pola, menghasilkan tidak langsung dan abstraksi, kami memberikan kode kami dengan perlindungan - perlindungan dari yang tidak diketahui besok dan persyaratan besok.  Bagaimanapun, pada kenyataannya, hari ini kita tidak memerlukan semua ini, kita menciptakan semua ini hanya demi beberapa "kebutuhan masa depan".  Dan ada kemungkinan bahwa struktur data ini selanjutnya akan mengganggu.  Sejujurnya, ketika beberapa pengembang saya mendatangi saya dan mengatakan bahwa dia datang dengan sesuatu yang menarik yang dapat ditambahkan ke kode produksi, saya selalu menjawab dengan cara yang sama: "Wah, ini tidak akan berguna bagi Anda." <br><br>  Seharusnya tidak ada banyak kode, dan yang harus sederhana - satu-satunya cara untuk bekerja secara normal dengannya.  Ini adalah masalah bagi pengembang Anda.  Anda harus ingat bahwa mereka adalah tokoh kunci untuk sistem Anda.  Cobalah untuk mengurangi konsumsi energi mereka, untuk mengurangi risiko yang harus mereka jalani.  Ini tidak berarti bahwa Anda harus membuat kerangka kerja Anda sendiri, terlebih lagi, saya tidak akan menyarankan Anda untuk melakukan ini: akan selalu ada bug dalam kerangka kerja Anda, semua orang perlu mempelajarinya, dll.  Lebih baik menggunakan aset yang sudah ada, yang jumlahnya banyak hari ini.  Ini harus menjadi solusi sederhana.  Tuliskan penangan kesalahan global, terapkan teknologi aspek, pembuat kode, ekstensi Pegas atau CDI, konfigurasikan lingkup Permintaan / Utas, gunakan manipulasi bytecode dan hasilkan dengan cepat, dll. Semua ini akan menjadi kontribusi Anda pada hal yang benar-benar paling penting - kenyamanan pengembang Anda. <br><br>  Secara khusus, saya ingin menunjukkan kepada Anda penerapan area Permintaan / Utas.  Saya telah berulang kali menyaksikan bagaimana hal ini menyederhanakan aplikasi perusahaan.  Intinya adalah memberi Anda kesempatan, sebagai pengguna yang masuk, untuk menyimpan data RequestContext.  Dengan demikian, RequestContext akan menyimpan data pengguna dalam bentuk yang ringkas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/341/6c5/474/3416c54740aca3b8f514696bf9cf7f3d.jpg"><br><br>  Seperti yang Anda lihat, implementasinya hanya membutuhkan beberapa baris kode.  Setelah menulis permintaan dalam anotasi yang diperlukan (tidak sulit untuk melakukannya jika Anda menggunakan Spring atau CDI), Anda akan membebaskan diri dari kebutuhan untuk meneruskan login pengguna ke metode dan apa pun: metadata permintaan yang disimpan dalam konteks akan secara transparan menavigasi aplikasi.  Proxy cakupan akan memungkinkan Anda untuk mengakses metadata dari permintaan saat ini kapan saja. <br><br><h4>  Tes regresi </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c5/edf/d7a/5c5edfd7a14d760bc335d8e65f0d5666.jpg"><br><br>  Pengembang takut persyaratan yang diperbarui karena mereka takut dengan prosedur refactoring (modifikasi kode).  Dan cara termudah untuk membantu mereka adalah membuat suite pengujian yang andal untuk pengujian regresi.  Dengan itu, pengembang akan memiliki kesempatan kapan saja untuk menguji waktu operasi mereka - untuk memastikan bahwa itu tidak merusak sistem. <br><br>  Pengembang tidak perlu takut untuk merusak apa pun.  Anda harus melakukan segalanya agar refactoring dianggap sebagai sesuatu yang baik. <br>  Refactoring adalah aspek penting dari pengembangan.  Ingat, tepat pada saat pengembang Anda takut refactoring, aplikasi dapat dianggap telah menjadi Warisan. <br><br><h2>  Di mana menerapkan logika bisnis? </h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fb/8a2/08d/4fb8a208dc6d89279a663747de74369f.jpg"><br><br>  Memulai implementasi sistem apa pun (atau komponen sistem), kami bertanya pada diri sendiri pertanyaan: di mana lebih baik menerapkan logika domain, yaitu, aspek fungsional aplikasi kita?  Ada dua pendekatan yang saling bertentangan. <br>  Yang pertama didasarkan pada filosofi <i>Naskah Transaksi</i> .  Di sini, logika diimplementasikan dalam prosedur yang bekerja dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entitas anemia</a> (yaitu, dengan struktur data).  Pendekatan semacam itu baik karena dalam pelaksanaannya dimungkinkan untuk mengandalkan tugas-tugas bisnis yang dirumuskan.  Saat bekerja pada aplikasi untuk sektor perbankan, saya telah berulang kali mengamati transfer prosedur bisnis ke perangkat lunak.  Saya dapat mengatakan bahwa sangat alami untuk mengkorelasikan skenario dengan perangkat lunak. <br><br>  Pendekatan alternatif adalah dengan menggunakan prinsip-prinsip <i>Desain Berbasis Domain</i> .  Di sini Anda perlu menghubungkan spesifikasi dan persyaratan dengan metodologi berorientasi objek.  Penting untuk secara hati-hati mempertimbangkan objek dan memastikan keterlibatan bisnis yang baik.  Kelebihan dari sistem yang dirancang dengan cara ini adalah bahwa di masa depan mereka mudah dipelihara.  Namun, dalam pengalaman saya, menguasai metodologi ini cukup sulit: Anda akan merasa lebih atau kurang berani tidak lebih awal dari setelah enam bulan mempelajarinya. <br><br>  Untuk perkembangan saya, saya selalu memilih pendekatan pertama.  Saya dapat meyakinkan Anda bahwa dalam kasus saya ini berfungsi dengan baik. <br><br><h2>  Pemodelan data </h2><br><br><h4>  Entitas </h4><br><br>  Bagaimana kita memodelkan data?  Segera setelah aplikasi mengambil ukuran yang lebih atau kurang layak, <i>data persisten</i> akan muncul.  Ini adalah jenis data yang perlu Anda simpan lebih lama dari yang lainnya - ini adalah <i>entitas domain dari</i> sistem Anda.  Di mana menyimpannya - baik dalam database, dalam file atau mengelola memori secara langsung - tidak masalah.  Yang penting adalah <i>bagaimana</i> Anda akan menyimpannya - di mana struktur data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a8/56b/127/0a856b127ec938a8c17eb345610b0ee8.jpg"><br><br>  Pilihan ini diberikan kepada Anda sebagai pengembang, dan itu hanya tergantung pada Anda apakah struktur data ini akan bekerja untuk Anda atau melawan Anda saat menerapkan persyaratan fungsional di masa depan.  Agar semuanya menjadi baik, Anda harus mengimplementasikan entitas dengan meletakkannya di dalamnya <i>logika domain yang digunakan kembali</i> .  Bagaimana tepatnya?  Saya akan menunjukkan beberapa metode menggunakan contoh. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/e56/7da/c73e567da2fb69ceb3d627fb408530cd.jpg"><br><br>  Mari kita lihat apa yang saya berikan kepada entitas Pelanggan.  Pertama, saya menerapkan <code>getFullName()</code> <i>getter sintetis</i> yang akan mengembalikan saya gabungan dari firstName dan lastName.  Saya juga menerapkan metode <code>activate()</code> - untuk memantau keadaan entitas saya, sehingga merangkumnya.  Dalam metode ini, saya menempatkan, pertama, <i>operasi validasi</i> , dan, kedua, <i>menetapkan nilai ke</i> status dan diaktifkan oleh <i>bidang</i> , sehingga tidak perlu setter untuk mereka.  Saya juga menambahkan ke entitas Pelanggan metode <code>isActive()</code> dan <code>canPlaceOrders()</code> , yang menerapkan validasi lambda di dalam diri saya.  Ini disebut enkapsulasi predikat.  Predikat seperti itu sangat berguna jika Anda menggunakan filter Java 8: Anda dapat meneruskannya sebagai argumen untuk filter.  Saya menyarankan Anda untuk menggunakan pembantu ini. <br><br>  Mungkin Anda menggunakan semacam ORM seperti Hibernate.  Misalkan Anda memiliki dua entitas dengan komunikasi dua arah.  Inisialisasi harus dilakukan di kedua sisi, jika tidak, seperti yang Anda pahami, Anda akan mengalami masalah saat mengakses data ini di masa mendatang.  Tetapi pengembang sering lupa untuk menginisialisasi objek dari salah satu pihak.  Saat mengembangkan entitas ini, Anda dapat memberikan metode khusus yang akan menjamin inisialisasi dua arah.  Lihatlah <code>addAddress()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c55/7fe/273/c557fe273cc1f2658573f9e78a70ca1d.png"><br><br>  Seperti yang Anda lihat, ini adalah entitas yang sangat biasa.  Namun di dalamnya terletak logika domain.  Entitas semacam itu tidak boleh sedikit dan dangkal, tetapi tidak boleh dibebani dengan logika.  Overflow dengan logika lebih sering terjadi: jika Anda memutuskan untuk mengimplementasikan semua logika di domain, maka untuk setiap kasus penggunaan akan tergoda untuk menerapkan beberapa metode tertentu.  Sebagai aturan, ada banyak kasus penggunaan.  Anda tidak akan menerima entitas, tetapi satu tumpukan besar dari semua jenis logika.  Coba perhatikan ukurannya di sini: hanya <i>logika yang digunakan kembali</i> yang ditempatkan di domain dan hanya <i>dalam jumlah kecil.</i> <i><br><br></i> <h4>  <i>Nilai Objek</i> </h4> <i><br><br></i>  Selain entitas, Anda kemungkinan besar juga akan membutuhkan nilai objek.  Ini tidak lain adalah cara untuk mengelompokkan data domain sehingga Anda dapat memindahkannya di sekitar sistem bersama-sama. <br><br>  Objek nilai harus: <br><br><ul><li>  <b>Kecil</b>  Tidak ada <code>float</code> untuk variabel moneter!  Hati-hati saat memilih tipe data.  Semakin kompak objek Anda, semakin mudah bagi pengembang baru untuk mengetahuinya.  Ini adalah dasar untuk kehidupan yang nyaman. <br></li><li>  <b>Tidak bisa diubah</b> .  Jika objek benar-benar tidak berubah, maka pengembang mungkin tenang bahwa objek Anda tidak akan mengubah nilainya dan tidak akan rusak setelah dibuat.  Ini meletakkan dasar untuk pekerjaan yang tenang dan percaya diri. <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/765/284/a0e76528432de8c55dc146805a8b286d.jpg"><br><br>  Dan jika Anda menambahkan panggilan metode <code>validate()</code> ke konstruktor, pengembang akan dapat tenang untuk validitas entitas yang dibuat (ketika melewati, katakanlah, mata uang tidak ada atau jumlah uang negatif, konstruktor tidak akan berfungsi). <br><br><h4>  Perbedaan antara entitas dan objek nilai </h4><br><br>  Objek nilai berbeda dari entitas karena mereka tidak memiliki ID tetap.  Entitas akan selalu memiliki bidang yang terkait dengan kunci asing pada beberapa tabel (atau penyimpanan lainnya).  Objek nilai tidak memiliki bidang tersebut.  Muncul pertanyaan: apakah prosedur untuk memeriksa kesetaraan dua objek nilai dan dua entitas berbeda?  Karena objek nilai tidak memiliki bidang ID, untuk menyimpulkan bahwa dua objek tersebut sama, Anda harus membandingkan nilai semua bidang mereka berpasangan (yaitu, periksa semua konten).  Saat membandingkan entitas, cukup membuat satu perbandingan tunggal - berdasarkan ID lapangan.  Dalam prosedur perbandingan inilah perbedaan utama antara entitas dan objek nilai terletak. <br><br><h4>  Objek Transfer Data (DTO) </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72a/d31/681/72ad31681509cdef20509d4514b02139.jpg"><br><br>  Apa interaksi dengan antarmuka pengguna (UI)?  Anda harus memberikan <i>data untuk ditampilkan kepadanya</i> .  Apakah Anda benar-benar membutuhkan struktur lain?  Begitulah.  Dan semua karena antarmuka pengguna sama sekali bukan teman Anda.  Dia memiliki permintaannya sendiri: dia membutuhkan data untuk disimpan sesuai dengan bagaimana mereka harus ditampilkan.  Ini sangat luar biasa - kadang-kadang antarmuka pengguna dan pengembangnya yang mengharuskan kami.  Maka mereka perlu mendapatkan data untuk lima baris;  kemudian muncul di pikiran mereka untuk membuat bidang Boolean <code>isDeletable</code> untuk objek (dapatkah objek memiliki bidang seperti itu pada prinsipnya?) untuk mengetahui apakah tombol Hapus aktif atau tidak.  Tapi tidak ada yang marah.  Antarmuka pengguna hanya memiliki persyaratan yang berbeda. <br><br>  Pertanyaannya adalah, bisakah entitas kita dipercayakan kepada mereka untuk digunakan?  Kemungkinan besar, mereka akan mengubahnya, dan dengan cara yang paling tidak diinginkan bagi kita.  Oleh karena itu, kami akan memberi mereka sesuatu yang lain - <i>Data Transfer Objects</i> (DTO).  Mereka akan secara khusus disesuaikan dengan persyaratan eksternal dan untuk logika yang berbeda dari kita.  Beberapa contoh struktur DTO adalah: Formulir / Permintaan (berasal dari UI), Lihat / Respons (dikirim ke UI), SearchCriteria / SearchResult, dll. Anda dapat, dalam arti tertentu, menyebutnya model API. <br><br>  Prinsip penting pertama: DTO harus mengandung logika minimum. <br>  Berikut adalah contoh implementasi dari <code>CustomerDto</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ec/3bb/716/4ec3bb716c630f3b39ca82f8fe4c5e33.jpg"><br><br>  Konten: bidang <i>pribadi</i> , getter <i>publik</i> , dan setter untuknya.  Segalanya tampak super.  OOP dalam segala kejayaannya.  Tetapi satu hal buruk: dalam bentuk getter dan setter saya telah menerapkan terlalu banyak metode.  Di DTO, harus ada logika sesedikit mungkin.  Lalu apa jalan keluar saya?  Saya membuat ladang menjadi publik!  Anda akan mengatakan bahwa ini bekerja buruk dengan referensi metode dari Java 8, bahwa akan ada batasan, dll. Tapi percaya atau tidak, saya melakukan semua proyek saya (10-11 buah) dengan DTO tersebut.  Saudara masih hidup.  Sekarang, karena bidang saya bersifat publik, saya dapat dengan mudah mengatur nilainya menjadi <code>dto.fullName</code> hanya dengan memberi tanda sama dengan.  Apa yang bisa lebih cantik dan lebih sederhana? <br><br><h2>  Organisasi Logika </h2><br><br><h4>  Pemetaan </h4><br><br>  Jadi, kita punya tugas: kita perlu mengubah entitas kita menjadi DTO.  Kami menerapkan transformasi sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/dfd/ca8/995dfdca8c1945fb92a64cee09851259.jpg"><br><br>  Seperti yang Anda lihat, dengan mendeklarasikan DTO, kami beralih ke operasi pemetaan (pemberian nilai).  Apakah saya perlu menjadi pengembang senior untuk menulis tugas reguler dalam angka seperti itu?  Bagi sebagian orang, ini sangat tidak biasa sehingga mereka mulai mengganti sepatu mereka saat bepergian: misalnya, menyalin data menggunakan semacam kerangka pemetaan menggunakan refleksi.  Tetapi mereka kehilangan hal utama - bahwa cepat atau lambat, UI akan berinteraksi dengan DTO, akibatnya entitas dan DTO berbeda dalam maknanya. <br><br>  Orang bisa, katakanlah, meletakkan operasi pemetaan di konstruktor.  Tetapi ini tidak memungkinkan untuk pemetaan apa pun;  khususnya, perancang tidak dapat mengakses database. <br><br>  Dengan demikian, kami terpaksa meninggalkan operasi pemetaan dalam logika bisnis.  Dan jika mereka memiliki penampilan yang kompak, maka tidak ada yang perlu dikhawatirkan.  Jika pemetaan tidak mengambil beberapa baris, tetapi lebih, maka lebih baik untuk menempatkannya di <i>mapper yang</i> disebut.  Seorang mapper adalah kelas yang dirancang khusus untuk menyalin data.  Ini, secara umum, adalah hal kuno dan boilerplate.  Namun di belakang mereka, Anda dapat menyembunyikan banyak tugas kami - untuk membuat kode lebih bersih dan lebih ramping. <br><br>  Ingat: <i>kode yang tumbuh terlalu besar harus dipindahkan ke struktur terpisah</i> .  Dalam kasus kami, operasi pemetaan benar-benar sedikit banyak, jadi kami memindahkannya ke kelas yang terpisah - mapper. <br><br>  Haruskah pembuat peta mengizinkan akses ke database?  Anda dapat mengaktifkannya secara default - ini sering dilakukan karena alasan kesederhanaan dan pragmatisme.  Tapi itu menghadapkan Anda pada risiko tertentu. <br><br>  Saya akan ilustrasikan dengan sebuah contoh.  Berdasarkan DTO yang ada, kami menciptakan entitas <code>Customer</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef3/9e8/b82/ef39e8b82a023a2fad6afe8e3c22b5ec.png"><br><br>  Untuk pemetaan, kita perlu mendapatkan tautan ke grup pelanggan dari basis data.  Jadi saya menjalankan metode <code>getReference()</code> , dan mengembalikan saya beberapa entitas.  Permintaan kemungkinan besar akan masuk ke database (dalam beberapa kasus ini tidak terjadi, dan fungsi rintisan berhasil). <br><br>  Tetapi masalah tidak menunggu kita di sini, tetapi dalam metode yang melakukan operasi terbalik - mengubah entitas menjadi DTO. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6a/e27/7ff/e6ae277ff6b22588b5bc5aaffabf9d0e.png"><br><br>  Dengan menggunakan loop, kami menelusuri semua alamat yang terkait dengan Pelanggan yang ada dan menerjemahkannya ke alamat DTO.  Jika Anda menggunakan ORM, maka, mungkin, ketika Anda memanggil metode <code>getAddresses()</code> , pemuatan malas akan dilakukan.  Jika Anda tidak menggunakan ORM, maka ini akan menjadi permintaan terbuka untuk semua anak dari orang tua ini.  Dan di sini Anda berisiko masuk ke "masalah N +1".  Mengapa <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/001/2bb/e540012bbb4a242d84e55a2dffa5ca11.jpg"><br><br>  Anda memiliki satu set orang tua, yang masing-masing memiliki anak.  Untuk semua ini, Anda perlu membuat analog Anda sendiri di dalam DTO.  Anda perlu melakukan satu kueri <code>SELECT</code> untuk melintasi N entitas induk dan kemudian N <code>SELECT</code> kueri untuk berkeliling anak-anak dari masing-masing.  Total permintaan N + 1.  Untuk 1000 entitas <code>Customer</code> induk, operasi semacam itu akan memakan waktu 5-10 detik, yang tentu saja membutuhkan waktu lama. <br><br>  Misalkan, bagaimanapun, metode <code>CustomerDto()</code> disebut di dalam loop, mengonversi daftar objek Pelanggan ke daftar CustomerDto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58c/9c3/2b3/58c9c32b3e8a01a96d500920dfe5ef07.jpg"><br><br>  Masalah dengan N + 1 kueri memiliki solusi standar sederhana: di <i>JPQL</i> Anda dapat menggunakan <code>FETCH</code> oleh customer.addresses untuk mengambil anak-anak dan kemudian menghubungkan mereka menggunakan <code>JOIN</code> , dan dalam SQL Anda dapat menggunakan bypass dan <code>WHERE</code> . <br><br>  Tetapi saya akan melakukannya secara berbeda.  Anda dapat mengetahui berapa panjang maksimum daftar anak-anak (ini dapat dilakukan, misalnya, berdasarkan pencarian dengan pagination).  Jika daftar hanya berisi 15 entitas, maka kita hanya perlu 16 kueri.  Alih-alih 5ms kita akan menghabiskan segalanya, katakanlah, 15ms - pengguna tidak akan melihat perbedaannya. <br><br><h4>  Tentang pengoptimalan </h4><br><br>  Saya tidak akan menyarankan Anda untuk melihat kembali kinerja sistem pada tahap awal pengembangan.  Seperti yang dikatakan Donald Knud: "Optimalisasi prematur adalah akar kejahatan."  Anda tidak dapat mengoptimalkan dari awal.  Inilah yang perlu dibiarkan nanti.  Dan apa yang sangat penting: <i>tidak ada asumsi - hanya pengukuran dan evaluasi pengukuran!</i> <br><br>  Apakah Anda yakin bahwa Anda kompeten bahwa Anda adalah seorang ahli yang nyata?  Bersikaplah rendah hati dalam mengevaluasi diri sendiri.  Jangan berpikir bahwa Anda memahami JVM sampai Anda membaca setidaknya beberapa buku tentang kompilasi JIT.  Kebetulan programmer terbaik dari tim kami mendatangi saya dan mengatakan bahwa <i>mereka pikir</i> mereka telah menemukan implementasi yang lebih efisien.  Ternyata mereka kembali menemukan sesuatu yang hanya memperumit kode.  Jadi saya jawab berulang-ulang: YAGNI.  Kami tidak membutuhkannya. <br><br>  Seringkali, untuk aplikasi perusahaan, tidak ada optimasi algoritma yang diperlukan sama sekali.  Hambatan bagi mereka, sebagai suatu peraturan, bukanlah kompilasi dan tidak sejauh menyangkut prosesor, tetapi semua jenis operasi input-output.  Misalnya, membaca sejuta baris dari basis data, banyak menulis ke file, berinteraksi dengan soket. <br><br>  Seiring waktu, Anda mulai memahami apa yang menjadi hambatan dalam sistem, dan, dengan memperkuat segala sesuatu dengan pengukuran, Anda akan mulai secara bertahap mengoptimalkan.  Untuk saat ini, jaga kode sebersih mungkin.  Anda akan menemukan bahwa kode semacam itu jauh lebih mudah untuk dioptimalkan lebih lanjut. <br><br><h4>  Lebih suka komposisi daripada warisan </h4><br><br>  Kembali ke DTO kami.  Misalkan kita mendefinisikan DTO seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/180/39d/f91/18039df91fd1cc76a2413b7f373e7c0b.png"><br><br>  Kita mungkin membutuhkannya dalam banyak alur kerja.  Tetapi aliran ini berbeda dan, kemungkinan besar, setiap kasus penggunaan akan mengasumsikan tingkat pengisian bidang yang berbeda.  Misalnya, kita jelas perlu membuat DTO lebih awal daripada ketika kita memiliki informasi pengguna lengkap.  Anda dapat mengosongkan bidang untuk sementara waktu.  Tetapi semakin banyak bidang yang Anda abaikan, semakin Anda ingin membuat DTO yang lebih ketat untuk kasus penggunaan ini. <br><br>  Atau, Anda dapat membuat salinan DTO yang terlalu besar (dalam jumlah kasus penggunaan yang tersedia) dan kemudian menghapus bidang tambahan dari itu untuk setiap salinan.  Tetapi bagi banyak programmer, berdasarkan kecerdasan dan literasi mereka, sangat menyakitkan untuk menekan Ctrl + V.  Aksioma mengatakan copy-paste buruk. <br><br>  Anda dapat menggunakan prinsip <i>pewarisan yang</i> dikenal dalam teori OOP: cukup tentukan DTO dasar dan buat pewaris untuk setiap kasus penggunaan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f7/069/77f/6f706977fec8625d720323b64fe87ad8.png"><br><br>  Prinsip yang terkenal adalah: "Lebih suka komposisi daripada warisan."  Baca apa yang tertulis: <i>"memanjang"</i> .  Tampaknya kita harus "memperluas" kelas sumber.  Tetapi jika Anda memikirkannya, maka apa yang telah kami lakukan bukanlah "ekspansi" sama sekali.  Ini adalah "pengulangan" yang sebenarnya - tampilan sisi salin-tempel yang sama.  Karena itu, kami tidak akan menggunakan warisan. <br><br>  Tapi bagaimana seharusnya kita?  Bagaimana cara komposisi?  Mari kita lakukan dengan cara ini: tulis bidang di CustomerView yang akan menunjuk ke objek DTO yang mendasarinya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/d49/831/1f2d49831b9b286b8bc069c824ac2871.jpg"><br><br>  Dengan demikian, struktur dasar kami akan bersarang di dalamnya.  Beginilah komposisi yang sebenarnya keluar. <br><br>  Apakah kita menggunakan warisan atau memecahkan masalah dengan komposisi - ini semua adalah rincian, seluk-beluk yang muncul secara mendalam selama pelaksanaan kami.  Mereka sangat <i>rapuh</i> .  Apa artinya rapuh?  Lihatlah kode ini dari dekat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/921/eb1/ef2/921eb1ef20effd43b129ad5d28b88253.png"><br><br>  Sebagian besar pengembang yang saya tunjukkan ini segera mengatakan bahwa angka "2" diulang, sehingga harus diambil sebagai konstanta.  Mereka tidak memperhatikan bahwa deuce dalam ketiga kasus memiliki arti yang sama sekali berbeda (atau "nilai bisnis") dan bahwa pengulangannya tidak lebih dari suatu kebetulan.  Menarik dua ke dalam konstanta adalah keputusan yang sah, tetapi sangat rapuh.  Cobalah untuk tidak mengizinkan logika rapuh ke domain.  Jangan pernah bekerja darinya dengan struktur data eksternal, khususnya, dengan DTO. <br><br>  Jadi, mengapa pekerjaan menghilangkan warisan dan memperkenalkan komposisi menjadi tidak berguna?  Justru karena kita membuat DTO bukan untuk diri kita sendiri, tetapi untuk klien eksternal.  Dan bagaimana aplikasi klien akan mem-parsing DTO yang diterima dari Anda - Anda hanya bisa menebak.  Tapi jelas, ini tidak ada hubungannya dengan implementasi Anda.  Pengembang di sisi lain mungkin tidak membuat perbedaan untuk DTO dasar dan non-dasar yang telah Anda pikirkan dengan seksama;  mereka mungkin menggunakan warisan, dan mungkin dengan bodohnya salin-tempel itu saja. <br><br><h4>  Fasad </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/be7/31c/9e4/be731c9e4cfe002cb3b59c11a708f623.jpg"><br><br>  Mari kita kembali ke gambaran keseluruhan aplikasi.  Saya akan menyarankan Anda untuk mengimplementasikan logika domain melalui <i>pola Facade</i> , memperluas fasad dengan <i>layanan domain</i> sesuai kebutuhan.  Layanan domain dibuat ketika terlalu banyak logika terakumulasi dalam fasad, dan lebih mudah untuk menempatkannya di kelas yang terpisah. <br>  Layanan domain Anda harus selalu berbicara bahasa model domain Anda (entitas dan objek nilainya).  Dalam kasus apa pun mereka tidak bekerja dengan DTO, karena DTO, seperti yang Anda ingat, adalah struktur yang terus berubah di sisi klien, terlalu rapuh untuk suatu domain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/eb8/657/3adeb86570a92f804ba491836c99b9e8.jpg"><br><br>  Apa tujuan dari fasad? <br><br><ol><li>  Konversi data.  Jika kita memiliki entitas dari satu ujung dan DTO dari yang lain, perlu untuk melakukan transformasi dari satu ke yang lain.  Dan ini adalah hal pertama yang diperuntukkan bagi fasad.  Jika prosedur konversi bertambah dalam volume - gunakan kelas mapper. <br></li><li>  Implementasi logika.  Di fasad, Anda akan mulai menulis logika utama aplikasi.  Segera setelah itu menjadi banyak - ambil bagian ke layanan domain. <br></li><li>  Validasi data.  Ingat bahwa data yang diterima dari pengguna, menurut definisi, salah (mengandung kesalahan).  Fasad memiliki kemampuan untuk memvalidasi data.  Prosedur-prosedur ini, ketika volume terlampaui, biasanya dibawa ke <i>validator</i> . <br></li><li>  Aspek  Anda dapat melangkah lebih jauh dan membuat setiap kasing menggunakan fasadnya.  Kemudian akan muncul untuk menambahkan hal-hal seperti transaksi, penebangan, penangan pengecualian global ke metode fasad. Saya perhatikan bahwa sangat penting untuk memiliki penangan pengecualian global dalam aplikasi apa pun yang menangkap semua kesalahan yang tidak ditangkap oleh penangan lain.  Mereka akan sangat membantu programmer Anda - mereka akan memberi mereka ketenangan pikiran dan kebebasan bertindak. <br></li></ol><br><br><h4>  Dekomposisi banyak kode </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/604/a9c/8e8/604a9c8e859ff1dc3fb38208d6bf836d.jpg"><br><br>  Beberapa kata lagi tentang prinsip ini.  Jika kelas telah mencapai ukuran yang tidak nyaman untuk saya (katakanlah, 200 baris), maka saya harus mencoba memecahnya menjadi beberapa bagian.  Tetapi mengisolasi kelas baru dari yang sudah ada tidak selalu mudah.  Kita perlu menemukan beberapa cara universal.  Salah satu metode ini adalah mencari nama: Anda mencoba mencari nama untuk subset dari metode kelas Anda.  Segera setelah Anda berhasil menemukan nama, jangan ragu untuk membuat kelas baru.  Tapi ini tidak sesederhana itu.  Dalam pemrograman, seperti yang Anda tahu, hanya ada dua hal kompleks: ini men-cache dan nama inv invating.  Dalam hal ini, menciptakan nama melibatkan mengidentifikasi subtugas - bersembunyi dan karena itu tidak diidentifikasi sebelumnya oleh siapa pun. <br><br>  Contoh: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/fe3/82b/81ffe382b74f6bbd4a91626d83249a97.jpg"><br><br>  Dalam fasad asli <code>CustomerFacade</code> beberapa metode terkait langsung dengan pelanggan, dan beberapa terkait dengan preferensi pelanggan.  Berdasarkan ini, saya akan dapat membagi kelas menjadi dua ketika mencapai ukuran kritis.  Saya mendapatkan dua fasad: <code>CustomerFacade</code> dan <code>CustomerPreferencesFacade</code> .  Satu-satunya hal yang buruk adalah bahwa kedua fasad ini memiliki tingkat abstraksi yang sama.  Pemisahan dengan tingkat abstraksi menyiratkan agak berbeda. <br><br>  Contoh lain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ac/84e/788/2ac84e788af60fb038091aed273a390e.jpg"><br><br>  Misalkan ada kelas <code>OrderService</code> di sistem kami di mana kami menerapkan mekanisme pemberitahuan email.  Sekarang kami sedang membuat <code>DeliveryService</code> dan ingin menggunakan mekanisme pemberitahuan yang sama di sini.  Salin-tempel dikecualikan.  Mari kita lakukan dengan cara ini: ekstrak fungsionalitas pemberitahuan ke kelas <code>AlertService</code> baru dan tulis sebagai ketergantungan untuk kelas <code>DeliveryService</code> dan <code>OrderService</code> .  Di sini, berbeda dengan contoh sebelumnya, pemisahan terjadi tepat pada tingkat abstraksi. <code>DeliveryService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih abstrak daripada </font></font><code>AlertService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena menggunakannya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai bagian dari</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alur kerjanya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemisahan dengan tingkat abstraksi selalu mengasumsikan bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelas yang diekstraksi menjadi ketergantungan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ekstraksi dilakukan untuk digunakan kembali</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas ekstraksi tidak selalu mudah. </font><font style="vertical-align: inherit;">Hal ini juga dapat menyebabkan beberapa kesulitan dan memerlukan beberapa pengujian ulang unit test. </font><font style="vertical-align: inherit;">Namun demikian, menurut pengamatan saya, bahkan lebih sulit bagi pengembang untuk mencari fungsionalitas dalam basis kode monolitik besar aplikasi.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memasangkan pemrograman </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/625/5b2/346/6255b23467294d6224107235443379f1.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak konsultan akan berbicara tentang pemrograman pasangan, tentang fakta bahwa ini adalah solusi universal untuk setiap masalah pengembangan TI saat ini. Selama itu, programmer mengembangkan keterampilan teknis dan pengetahuan fungsional mereka. Selain itu, prosesnya sendiri menarik, menyatukan tim. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbicara bukan sebagai konsultan, tetapi secara manusiawi, yang paling penting adalah ini: pemrograman pasangan meningkatkan "faktor bus". Inti dari "faktor bus" adalah bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus ada sebanyak mungkin orang dengan pengetahuan tentang struktur sistem sebanyak mungkin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kehilangan orang-orang ini berarti kehilangan petunjuk terakhir untuk pengetahuan ini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refactoring pemrograman pasangan adalah seni yang membutuhkan pengalaman dan pelatihan. Hal ini berguna, misalnya, praktik refactoring agresif, melakukan hackathon, pemotongan, Coding Dojo, dll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrograman pasangan berfungsi dengan baik jika Anda perlu menyelesaikan masalah dengan kompleksitas tinggi. Proses bekerja bersama tidak selalu sederhana. Tapi itu menjamin Anda bahwa Anda akan menghindari "rekayasa ulang" - sebaliknya, Anda akan mendapatkan implementasi yang memenuhi persyaratan yang ditetapkan dengan kompleksitas minimal. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5a/5aa/666/a5a5aa666cb29c58dc9bb5b7d5bc6651.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengatur format pekerjaan yang nyaman adalah salah satu tanggung jawab utama Anda kepada tim. Anda harus selalu menjaga kondisi kerja pengembang - berikan mereka kenyamanan dan kebebasan kreativitas yang lengkap, terutama jika mereka diminta untuk meningkatkan arsitektur desain dan kompleksitasnya.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Saya seorang arsitek. </font><font style="vertical-align: inherit;">Menurut definisi, saya selalu benar. "</font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebodohan ini secara berkala diungkapkan di depan umum atau di belakang layar. </font><font style="vertical-align: inherit;">Dalam praktik hari ini, arsitek seperti itu semakin jarang ditemukan. </font><font style="vertical-align: inherit;">Dengan munculnya Agile, peran ini secara bertahap diberikan kepada pengembang senior, karena biasanya semua pekerjaan, dengan satu atau lain cara, dibangun di sekitar mereka. </font><font style="vertical-align: inherit;">Ukuran implementasi secara bertahap tumbuh, dan dengan ini ada kebutuhan untuk refactoring dan fungsionalitas baru sedang dikembangkan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arsitektur bawang </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bawang adalah filosofi Script Transaksi murni. Membangunnya, kami dipandu oleh tujuan melindungi kode yang kami anggap penting, dan untuk ini kami memindahkannya ke modul domain. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a45/bb4/94a/a45bb494a51b04ecfe92606b744c0857.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam aplikasi kami, yang paling penting adalah layanan domain: mereka menerapkan aliran paling kritis. Pindahkan mereka ke modul domain. Tentu saja, ada baiknya juga memindahkan semua objek domain Anda di sini - entitas dan objek nilai. Segala hal lain yang telah kami susun hari ini - DTO, pembuat peta, validator, dll. - menjadi, garis pertahanan pertama dari pengguna. Karena pengguna, sayangnya, bukan teman kita, dan perlu untuk melindungi sistem darinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatian pada ketergantungan ini:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/273/6bd/c7d2736bdc016b732c5c431299bf32ea.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul aplikasi akan tergantung pada modul domain - yaitu, bukan sebaliknya. Dengan mendaftarkan koneksi semacam itu, kami menjamin bahwa DTO tidak akan pernah masuk ke wilayah suci modul domain: mereka tidak terlihat dan tidak dapat diakses dari modul domain. Ternyata dalam arti kami memagari wilayah domain - kami membatasi akses ke sana oleh orang asing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, domain mungkin perlu berinteraksi dengan beberapa layanan eksternal. Dengan eksternal berarti tidak ramah, karena ia dilengkapi dengan DTO-nya. Apa saja pilihan kita? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama: lewati musuh di dalam modul. </font></font><br><br><img src="https://habrastorage.org/webt/un/tn/hk/untnhkiksv5id_i-6c4qwdjxy1c.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, ini adalah pilihan yang buruk: mungkin saja besok layanan eksternal tidak akan ditingkatkan ke versi 2.0, dan kami harus menggambar ulang domain kami. Jangan biarkan musuh di dalam domain!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengusulkan pendekatan yang berbeda: kami akan membuat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> khusus untuk interaksi </font><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/8b1/09c/1238b109c54ac8f19524e6d41b32e85e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adaptor akan menerima data dari layanan eksternal, mengekstrak data yang diperlukan domain kami, dan mengubahnya menjadi jenis struktur yang diperlukan. </font><font style="vertical-align: inherit;">Dalam hal ini, semua yang diperlukan dari kami selama pengembangan adalah untuk mengkorelasikan panggilan ke sistem eksternal dengan persyaratan domain. </font><font style="vertical-align: inherit;">Anggap saja sebagai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besar seperti ini </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya menyebut lapisan ini "anti-korupsi." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, kita mungkin perlu menjalankan kueri LDAP dari domain. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami menerapkan "modul anti-korupsi" </font></font><code>LDAPUserServiceAdapter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/520/fdc/84a/520fdc84a53641a26b957ac010a19c42.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam adaptor kita dapat:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sembunyikan panggilan API yang jelek (dalam kasus kami, sembunyikan metode yang mengambil array Objek); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket pengecualian dalam implementasi kami sendiri; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konversikan struktur data orang lain menjadi milik mereka (menjadi objek domain kami); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Periksa validitas data yang masuk. </font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah tujuan dari adaptor. </font><font style="vertical-align: inherit;">Bagus, di antarmuka dengan setiap sistem eksternal yang Anda perlukan untuk berinteraksi, adaptor Anda harus diinstal. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/663/9c5/b1a6639c58457537fb6a4d9c15e09eae.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, domain tidak akan mengarahkan panggilan ke layanan eksternal, tetapi ke adaptor. </font><font style="vertical-align: inherit;">Untuk melakukan ini, ketergantungan yang sesuai harus didaftarkan di domain (dari adaptor atau dari modul infrastruktur di mana ia berada). </font><font style="vertical-align: inherit;">Tetapi apakah kecanduan ini aman? </font><font style="vertical-align: inherit;">Jika Anda menginstalnya seperti ini, DTO layanan eksternal dapat masuk ke domain kami. </font><font style="vertical-align: inherit;">Kita seharusnya tidak mengizinkan ini. </font><font style="vertical-align: inherit;">Oleh karena itu, saya menyarankan Anda cara lain untuk memodelkan dependensi.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prinsip Pembalikan Ketergantungan </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/058/4a1/f7c/0584a1f7c309505e4e5ea0c2b0b26c21.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita buat antarmuka, tulis di dalamnya tanda tangan dari metode yang diperlukan dan letakkan di dalam domain kami. Tugas adaptor adalah untuk mengimplementasikan antarmuka ini. Ternyata antarmuka di dalam domain, dan adaptor di luar, dalam modul infrastruktur yang mengimpor antarmuka. Dengan demikian, kami memutar arah ketergantungan pada arah yang berlawanan. Pada saat dijalankan, sistem domain akan memanggil kelas apa saja melalui antarmuka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, hanya dengan memperkenalkan antarmuka ke dalam arsitektur, kami dapat menggunakan dependensi dan dengan demikian mengamankan domain kami dari struktur asing dan API yang jatuh ke dalamnya. Pendekatan ini disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inversi ketergantungan</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2c/cc2/cd0/c2ccc2cd0309a4c8f97b7521cfc63fb7.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, inversi dependensi mengasumsikan bahwa Anda menempatkan metode yang menarik bagi Anda dalam antarmuka di dalam modul tingkat tinggi Anda (dalam domain), dan mengimplementasikan antarmuka ini dari luar - dalam satu atau modul jelek jelek lain (infrastruktur). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka yang diimplementasikan di dalam modul domain harus berbicara dalam bahasa domain, yaitu, ia akan beroperasi pada entitasnya, parameternya, dan jenis kembali. Pada saat run time, domain akan memanggil kelas apa saja melalui panggilan polimorfik ke antarmuka. Kerangka kerja injeksi ketergantungan (seperti Spring dan CDI) memberi kita contoh konkret dari kelas yang tepat di runtime.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi yang utama adalah bahwa selama kompilasi modul domain tidak akan melihat isi dari modul eksternal. </font><font style="vertical-align: inherit;">Itu yang kita butuhkan. </font><font style="vertical-align: inherit;">Tidak ada entitas eksternal yang termasuk dalam domain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paman Bob</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , prinsip inversi kontrol (atau, demikian ia menyebutnya, "arsitektur plug-in") mungkin adalah yang terbaik yang ditawarkan paradigma OOP secara umum. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a96/3cf/e13/a963cfe13d030fb1d7ec2bf0f780fe43.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategi ini dapat digunakan untuk integrasi dengan sistem apa pun, untuk panggilan dan pesan yang sinkron dan asinkron, untuk mengirim file, dll.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ikhtisar Bulb </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc3/64d/cdb/dc364dcdb589b35a0597b6e478aace46.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami memutuskan bahwa kami akan melindungi modul domain. </font><font style="vertical-align: inherit;">Di dalamnya ada layanan domain, entitas, objek nilai, dan sekarang antarmuka untuk layanan eksternal, ditambah antarmuka untuk repositori (untuk berinteraksi dengan database). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strukturnya terlihat seperti ini: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/07e/983/0c7/07e9830c76d3b263743f8514b13bf42a.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul aplikasi, modul infrastruktur (melalui inversi dependensi), modul repositori (kami juga mempertimbangkan database sebagai sistem eksternal), modul batch, dan mungkin beberapa modul lain dinyatakan dependensi untuk domain. </font><font style="vertical-align: inherit;">Arsitektur ini disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"bawang"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">itu juga disebut "bersih," "heksagonal," dan "port dan adaptor."</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modul repositori </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan berbicara singkat tentang modul repositori. Apakah akan mengeluarkannya dari domain adalah pertanyaan. Tugas repositori adalah membuat logika lebih bersih, menyembunyikan dari kita kengerian bekerja dengan data persisten. Pilihan untuk orang-orang jompo adalah menggunakan JDBC untuk berinteraksi dengan basis data: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/d70/44a/7edd7044a76373b2c513e246bf6eabaa.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga dapat menggunakan Spring dan JdbcTemplate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/64b/d68/749/64bd68749f5b3de16591a23a8acda193.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atau MyBatis DataMapper: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/423/31b/aa1/42331baa178ff3ad8f0ea8fb92704265.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi itu sangat rumit dan jelek sehingga tidak </font><font style="vertical-align: inherit;">menganjurkan </font><font style="vertical-align: inherit;">keinginan untuk melakukan apa pun lebih jauh. Oleh karena itu, saya sarankan menggunakan JPA / Hibernate atau Spring Data JPA. Mereka akan memberi kita kesempatan untuk mengirim pertanyaan yang dibangun bukan pada skema basis data, tetapi langsung berdasarkan model entitas kita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi untuk JPA / Hibernate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/110/ebf/ef7/110ebfef7dad2a2bb278c50668eecda9.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus Spring Data JPA:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/10b/e2a/0ff/10be2a0ff082a8c1ac962c4754ec55a8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Data JPA dapat secara otomatis menghasilkan metode saat runtime, seperti, misalnya, getById (), getByName (). Ini juga memungkinkan Anda untuk mengeksekusi permintaan JPQL jika perlu - dan bukan ke database, tetapi ke model entitas Anda sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode Hibernate JPA dan Spring Data JPA benar-benar terlihat cukup bagus. Apakah kita perlu mengekstraknya dari domain? Menurut pendapat saya, ini tidak begitu dan perlu. Kemungkinan besar, kode akan lebih bersih jika Anda meninggalkan fragmen ini di dalam domain. Jadi bertindaklah sesuai situasi.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/055/f04/37c/055f0437cf059c9f7001db6b3d231e70.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tetap membuat modul repositori, maka untuk organisasi dependensi lebih baik menggunakan prinsip inversi kontrol dengan cara yang sama. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tempatkan antarmuka di domain dan implementasikan dalam modul repositori. </font><font style="vertical-align: inherit;">Adapun logika repositori, lebih baik untuk mentransfernya ke domain. </font><font style="vertical-align: inherit;">Ini membuat pengujian nyaman, karena Anda dapat menggunakan objek Mock di domain. </font><font style="vertical-align: inherit;">Mereka akan memungkinkan Anda untuk menguji logika dengan cepat dan berulang-ulang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara tradisional, hanya satu entitas yang dibuat untuk repositori dalam domain. </font><font style="vertical-align: inherit;">Mereka memecahnya menjadi potongan-potongan hanya ketika menjadi terlalu tebal. </font><font style="vertical-align: inherit;">Ingat bahwa kelas harus kompak.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c8/9e1/7e7/1c89e17e784e4db6fe8d7c713bcf1ab6.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda bisa membuat modul terpisah, letakkan antarmuka yang diekstraksi dari fasad dan DTO yang bergantung padanya, lalu kemas dalam JAR, dan transfer ke klien Java Anda di formulir ini. </font><font style="vertical-align: inherit;">Memiliki file ini, mereka akan dapat mengirim permintaan ke fasad.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bola Pragmatis </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain dari "musuh" kami kepada siapa kami memberikan fungsionalitas, yaitu, pelanggan, kami juga memiliki musuh dan, di sisi lain, modul-modul yang menjadi sandaran kami sendiri. </font><font style="vertical-align: inherit;">Kita juga perlu melindungi diri kita dari modul-modul ini. </font><font style="vertical-align: inherit;">Dan untuk ini saya menawarkan "bawang" yang sedikit dimodifikasi - di dalamnya seluruh infrastruktur digabungkan menjadi satu modul. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/265/1f1/481/2651f1481062cfe6c18974df9a6dde9b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menyebut arsitektur ini </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"bola pragmatis"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Di sini, pemisahan komponen dilakukan sesuai dengan prinsip "milikku" dan "dapat diintegrasikan": secara terpisah, yang berkaitan dengan domain saya, dan secara terpisah, yang mengacu pada integrasi dengan kolaborator eksternal. Dengan demikian, hanya dua modul yang diperoleh: domain dan aplikasi. Arsitektur seperti itu sangat bagus, tetapi hanya ketika modul aplikasi kecil. Jika tidak, Anda sebaiknya kembali ke bawang tradisional.</font></font><br><br><h2>  Tes </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang saya katakan sebelumnya, jika semua orang takut dengan aplikasi Anda, pertimbangkan bahwa itu telah mengisi kembali jajaran Legacy. </font></font><img src="https://habrastorage.org/getpro/habr/post_images/12a/508/d1b/12a508d1b9595239f6d9b9a8a72c9474.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi tesnya bagus. Mereka memberi kami rasa percaya diri yang memungkinkan kami untuk melanjutkan refactoring. Namun sayangnya, kepercayaan ini dapat dengan mudah berubah menjadi tidak bisa dibenarkan. Saya akan menjelaskan alasannya. TDD (pengembangan melalui pengujian) mengasumsikan bahwa Anda adalah pembuat kode dan pembuat kasus pengujian: Anda membaca spesifikasi, mengimplementasikan fungsionalitas, dan segera menulis rangkaian uji untuknya. Tes, katakanlah, akan berhasil. Tetapi bagaimana jika Anda salah memahami persyaratan spesifikasi? Maka tes akan memeriksa tidak apa yang dibutuhkan. Jadi kepercayaan diri Anda tidak berharga. Dan semua karena Anda menulis kode dan tes sendiri.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi coba tutup mata kita untuk ini. </font><font style="vertical-align: inherit;">Tes masih diperlukan, dan bagaimanapun mereka memberi kita kepercayaan diri. </font><font style="vertical-align: inherit;">Yang paling penting, tentu saja, kami menyukai tes fungsional: tes ini tidak menyiratkan efek samping, tanpa ketergantungan - hanya data input dan output. </font><font style="vertical-align: inherit;">Untuk menguji domain, Anda perlu menggunakan objek tiruan: mereka akan memungkinkan Anda untuk menguji kelas secara terpisah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adapun permintaan basis data, mengujinya tidak menyenangkan. </font><font style="vertical-align: inherit;">Tes-tes ini rapuh, mereka mengharuskan Anda pertama kali menambahkan data uji ke database - dan hanya setelah itu Anda dapat melanjutkan untuk menguji fungsionalitas. </font><font style="vertical-align: inherit;">Tapi seperti yang Anda pahami, tes ini juga diperlukan, bahkan jika Anda menggunakan JPA.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tes unit </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/332/6ec/8bd3326ec6ca9886c78b4239491dc936.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan mengatakan bahwa kekuatan unit test bukan dalam kemungkinan menjalankannya, tetapi dalam apa yang meliputi proses penulisan mereka. Saat Anda menulis tes, Anda memikirkan kembali dan mengerjakan kode - mengurangi konektivitas, memecahnya menjadi kelas - dengan kata lain, melakukan refactoring berikutnya. Kode yang diuji adalah kode murni; itu lebih sederhana, keterhubungannya berkurang di dalamnya; secara umum, ini juga didokumentasikan (unit test yang ditulis dengan sempurna menggambarkan bagaimana kelas bekerja). Tidak mengherankan bahwa tes unit menulis sulit, terutama beberapa bagian pertama. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/116/be7/361/116be7361d4d6a2dc8cac91983808378.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap tes unit pertama, banyak orang benar-benar takut dengan prospek bahwa mereka </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar-benar harus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menguji sesuatu. Mengapa mereka diberikan begitu keras? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena tes ini adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beban pertama di kelas Anda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah pukulan pertama ke sistem, yang, mungkin, akan menunjukkan bahwa itu rapuh dan tipis. Tetapi Anda perlu memahami bahwa beberapa tes ini adalah yang paling penting untuk perkembangan Anda. Mereka, pada dasarnya, adalah teman baik Anda, karena mereka akan mengatakan segalanya karena kualitas kode Anda. Jika Anda takut pada tahap ini, maka Anda tidak akan jauh. Anda harus menjalankan pengujian untuk sistem Anda. Setelah itu, kompleksitas akan berkurang, tes akan ditulis lebih cepat. Menambahkannya satu per satu, Anda akan membuat </font><i><font style="vertical-align: inherit;">basis pengujian regresi yang</font></i><font style="vertical-align: inherit;"> andal untuk sistem Anda</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dan ini sangat penting untuk pekerjaan pengembang Anda di masa depan. </font><font style="vertical-align: inherit;">Akan lebih mudah bagi mereka untuk melakukan refactor; </font><font style="vertical-align: inherit;">Mereka akan memahami bahwa sistem dapat diuji regresi kapan saja, oleh karena itu bekerja dengan basis kode aman. </font><font style="vertical-align: inherit;">Dan, saya yakinkan Anda, mereka akan terlibat dalam refactoring dengan lebih rela. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb5/3d7/cbd/eb53d7cbdc3b190b2b597d6427088b1a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saran saya kepada Anda: jika Anda merasa memiliki banyak kekuatan dan energi hari ini, curahkan diri Anda untuk menulis unit test. </font><font style="vertical-align: inherit;">Dan pastikan masing-masing bersih, cepat, memiliki berat sendiri dan tidak mengulangi yang lain.</font></font><br><br><h2>  Kiat </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Merangkum semua yang telah dikatakan hari ini, saya ingin mengingatkan Anda dengan tips berikut: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sesederhana</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin selama mungkin (dan berapapun biayanya) </font><font style="vertical-align: inherit;">: hindari "rekayasa ulang" dan optimasi yang terlambat, jangan membebani aplikasi;</font></font><br></li><li> <i>   </i> ,        ,   ; <br></li><li>  «»           — <i>     </i> ; <br></li><li>   ,        — <i></i> :         ; <br></li><li>    «»,  ,     — <i>           </i> ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jangan takut pada tes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : beri mereka kesempatan untuk menghancurkan sistem Anda, rasakan semua manfaatnya - pada akhirnya, mereka adalah teman Anda karena mereka dapat dengan jujur ​​menunjukkan masalah.</font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan melakukan hal-hal ini, Anda akan membantu tim Anda dan diri Anda sendiri. </font><font style="vertical-align: inherit;">Dan kemudian, ketika hari pengiriman produk tiba, Anda akan siap untuk itu.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang harus dibaca </font></font></h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/852/a4c/37d/852a4c37d17677fa3fb1e7e021f29e4a.jpg"><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 Keutamaan Obyek yang Baik</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL adalah kesalahan terburuk dalam Ilmu Komputer</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arsitektur bersih</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jargon pemrograman baru</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kualitas kode: WTFs / menit</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa setiap elemen SOLID salah?</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perangkat lunak yang baik ditulis 3 kali</font></font></a> <br></li></ul><br><br><blockquote>  .        <b>JPoint</b> —  ,  19-20   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Joker 2018</a> —    Java-.       .        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419179/">https://habr.com/ru/post/id419179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419165/index.html">Kami mengirim SMS "anonim" dari Konsol ke nomor yang diinginkan menggunakan layanan bytehand dan C ++</a></li>
<li><a href="../id419169/index.html">"Dunia Wild West" melalui mata pengembang</a></li>
<li><a href="../id419171/index.html">Menonaktifkan keadaan runtime memeriksa dalam aplikasi Android</a></li>
<li><a href="../id419173/index.html">Arsitektur bersih dalam konteks pengembangan lintas platform</a></li>
<li><a href="../id419177/index.html">Pola Cahaya Amazon</a></li>
<li><a href="../id419181/index.html">Pemrograman Mouse: Bagaimana Kami Lari Dari Rutin CRM</a></li>
<li><a href="../id419183/index.html">Demopati di Helsinki "Majelis 2018", laporan foto, hari pertama</a></li>
<li><a href="../id419185/index.html">Tinjauan protokol pembangunan konsensus saat ini dalam lingkungan yang terdesentralisasi</a></li>
<li><a href="../id419189/index.html">Mengapa penawaran paket akan segera membentuk dasar ritel</a></li>
<li><a href="../id419193/index.html">Kami menangani objek dalam JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>