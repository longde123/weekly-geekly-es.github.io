<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåã üéª üë®üèº‚Äçüåæ OpenSceneGraph: N≈ìuds de groupe, n≈ìuds de transformation et n≈ìuds de commutation üö∞ ‚õ≤Ô∏è üï¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Lorsqu'un point, une ligne ou un polygone complexe est dessin√© dans un monde en trois dimensions, le r√©sultat final sera finalement aff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: N≈ìuds de groupe, n≈ìuds de transformation et n≈ìuds de commutation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430242/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Pr√©sentation </h1><br>  Lorsqu'un point, une ligne ou un polygone complexe est dessin√© dans un monde en trois dimensions, le r√©sultat final sera finalement affich√© sur un √©cran plat en deux dimensions.  En cons√©quence, les objets tridimensionnels passent par un certain chemin de transformation, se transformant en un ensemble de pixels affich√©s dans une fen√™tre bidimensionnelle. <br><br>  Le d√©veloppement d'outils logiciels qui impl√©mentent des graphiques tridimensionnels est arriv√©, quel que soit celui que vous choisissez, √† peu pr√®s au m√™me concept de descriptions √† la fois math√©matiques et algorithmiques des transformations ci-dessus.  Sur le plan id√©ologique, les API graphiques ¬´propres¬ª comme OpenGL et les moteurs de jeux sympas comme Unity et Unreal, utilisent des m√©canismes similaires pour d√©crire la transformation d'une sc√®ne en trois dimensions.  OpenSceneGraph ne fait pas exception. <br><br>  Dans cet article, nous passerons en revue les m√©canismes de regroupement et de transformation d'objets tridimensionnels dans OSG. <br><a name="habracut"></a><br><h1>  1. Matrice de mod√®le, matrice de vue et matrice de projection </h1><br>  Trois matrices de base impliqu√©es dans la transformation des coordonn√©es sont impliqu√©es dans la transformation entre diff√©rents syst√®mes de coordonn√©es.  Souvent, en termes OpenGL, ils sont appel√©s <em>matrice de</em> <em>mod√®le,</em> <em>matrice de vue</em> et <em>matrice de projection</em> . <br><br>  La matrice du mod√®le est utilis√©e pour d√©crire l'emplacement de l'objet dans le monde 3D.  Il convertit les sommets du <em>syst√®me de coordonn√©es local de l'objet</em> en <em>syst√®me de coordonn√©es mondial</em> .  Soit dit en passant, tous les syst√®mes de coordonn√©es dans OSG sont <em>droitiers</em> . <br><br>  L'√©tape suivante est la transformation des coordonn√©es du monde en un espace de vue, effectu√©e √† l'aide de la matrice de vue.  Supposons que nous ayons une cam√©ra situ√©e √† l'origine du syst√®me de coordonn√©es mondial.  La matrice inverse de la matrice de transformation de la cam√©ra est en fait utilis√©e comme matrice de vue.  Dans un syst√®me de coordonn√©es droitier, OpenGL, par d√©faut, d√©finit toujours une cam√©ra situ√©e au point (0, 0, 0) du syst√®me de coordonn√©es global et dirig√©e le long de la direction n√©gative de l'axe Z. <br><br>  Je note que dans OpenGL la matrice de mod√®le et la matrice de vue ne sont pas s√©par√©es.  Cependant, la matrice mod√®le-vue y est d√©termin√©e, ce qui convertit les coordonn√©es locales de l'objet en coordonn√©es de l'espace de vue.  Cette matrice est en fait le produit de la matrice mod√®le et de la matrice de la forme.  Ainsi, la transformation d'un sommet V de coordonn√©es locales en un espace de la forme peut √™tre conditionnellement √©crite comme le produit <br><br><pre><code class="plaintext hljs">Ve = V * modelViewMatrix</code> </pre> <br>  La prochaine t√¢che importante consiste √† d√©terminer comment les objets 3D seront projet√©s sur le plan de l'√©cran et √† calculer la soi-disant <em>pyramide d'√©cr√™tage</em> - une zone d'espace contenant des objets √† afficher √† l'√©cran.  La matrice de projection est utilis√©e pour sp√©cifier la pyramide d'√©cr√™tage d√©finie dans l'espace mondial par six plans: gauche, droite, inf√©rieure, sup√©rieure, proche et √©loign√©e.  OpenGL fournit la fonction gluPerapective (), qui vous permet de sp√©cifier une pyramide de d√©coupage et un moyen de projeter un monde en trois dimensions sur un plan. <br><br>  Le syst√®me de coordonn√©es obtenu apr√®s les transformations ci-dessus est appel√© <em>syst√®me de coordonn√©es normalis√© de l'appareil</em> , a une plage de coordonn√©es de -1 √† 1 sur chaque axe et est gaucher.  Et, comme derni√®re √©tape, les donn√©es re√ßues sont projet√©es dans le port d'affichage (fen√™tre) de la fen√™tre, d√©fini par le rectangle de la zone cliente de la fen√™tre.  Apr√®s cela, le monde 3D appara√Æt sur notre √©cran 2D.  La valeur finale des coordonn√©es d'√©cran des sommets Vs peut √™tre exprim√©e par la transformation suivante <br><br><pre> <code class="plaintext hljs">Vs = V * modelViewMatrix * projectionMatrix * windowMatrix</code> </pre><br>  ou <br><br><pre> <code class="plaintext hljs">Vs = V * MVPW</code> </pre><br>  o√π MVPW est la matrice de transformation √©quivalente √©gale au produit de trois matrices: matrices vue mod√®le, matrices de projection et matrices de fen√™tre. <br><br>  Vs dans cette situation est un vecteur tridimensionnel qui d√©termine la position d'un pixel 2D avec une valeur de profondeur.  En inversant l'op√©ration de transformation des coordonn√©es, nous obtenons une ligne dans l'espace tridimensionnel.  Par cons√©quent, un point 2D peut √™tre consid√©r√© comme deux points - l'un sur le proche (Zs = 0), l'autre sur le plan de d√©limitation √©loign√© (Zs = 1).  Les coordonn√©es de ces points dans l'espace tridimensionnel <br><br><pre> <code class="plaintext hljs">V0 = (Xs, Ys, 0) * invMVPW V1 = (Xs, Ys, 1) * invMVPW</code> </pre><br>  o√π invMVPW est l'inverse de MVPW. <br><br>  Dans tous les exemples discut√©s jusqu'√† pr√©sent, nous avons cr√©√© un seul objet tridimensionnel dans les sc√®nes.  Dans ces exemples, les coordonn√©es locales de l'objet co√Øncident toujours avec les coordonn√©es globales globales.  Il est maintenant temps de parler d'outils qui vous permettent de placer de nombreux objets dans la sc√®ne et de changer leur position dans l'espace. <br><br><h1>  2. N≈ìuds de groupe </h1><br>  La classe osg :: Group est le soi-disant <em>n≈ìud</em> de <em>groupe</em> d'un graphe de sc√®ne dans OSG.  Il peut avoir n'importe quel nombre de n≈ìuds enfants, y compris des n≈ìuds de feuille de g√©om√©trie ou d'autres n≈ìuds de groupe.  Ce sont les n≈ìuds les plus couramment utilis√©s avec des fonctionnalit√©s √©tendues. <br><br>  La classe osg :: Group est d√©riv√©e de la classe osg :: Node et h√©rite en cons√©quence de la classe osg :: Referenced.  osg :: Group contient une liste de n≈ìuds enfants, o√π chaque n≈ìud enfant est contr√¥l√© par un pointeur intelligent.  Cela garantit qu'il n'y a pas de fuite de m√©moire lors de la mise en cascade d'une branche d'une arborescence de sc√®nes.  Cette classe fournit au d√©veloppeur un certain nombre de m√©thodes publiques. <br><ol><li>  addChild () - ajoute le n≈ìud √† la fin de la liste des n≈ìuds enfants.  D'un autre c√¥t√©, il y a la m√©thode insertChild (), qui place le n≈ìud enfant √† une position sp√©cifique dans la liste, qui est sp√©cifi√©e par un index entier ou un pointeur sur le n≈ìud, pass√© en param√®tre. <br></li><li>  removeChild () et removeChildren () - suppriment un seul n≈ìud ou groupe de n≈ìuds. <br></li><li>  getChild () - obtenir un pointeur vers un n≈ìud par son index dans la liste <br></li><li>  getNumChildren () - obtenir le nombre de n≈ìuds enfants attach√©s √† ce groupe. <br></li></ol><br><h2>  Gestion des n≈ìuds parents </h2><br>  Comme nous le savons d√©j√†, la classe osg :: Group g√®re des groupes de ses objets enfants, parmi lesquels il peut y avoir des instances osg :: Geode qui contr√¥lent la g√©om√©trie des objets de sc√®ne.  Les deux classes ont une interface pour g√©rer les n≈ìuds parents. <br><br>  OSG permet aux n≈ìuds de sc√®ne d'avoir plusieurs n≈ìuds parents (nous en reparlerons un jour plus tard).  En attendant, nous examinerons les m√©thodes d√©finies dans osg :: Node qui sont utilis√©es pour manipuler les n≈ìuds parents: <br><ol><li>  getParent () - retourne un pointeur de type osg :: Group contenant une liste de n≈ìuds parents. <br></li><li>  getNumParants () - renvoie le nombre de n≈ìuds parents. <br></li><li>  getParentalNodePath () - renvoie tous les chemins possibles vers le n≈ìud racine de la sc√®ne √† partir du n≈ìud actuel.  Il renvoie une liste de variables de type osg :: NodePath. <br></li></ol><br>  osg :: NodePath est un vecteur std :: de pointeurs vers les n≈ìuds de sc√®ne. <br><br><img src="https://habrastorage.org/webt/hx/nb/nk/hxnbnknku1ayvk06j3ank2mug9k.png"><br><br>  Par exemple, pour la sc√®ne illustr√©e dans la figure, le code suivant <br><br><pre> <code class="cpp hljs">osg::NodePath &amp;nodePath = child3-&gt;getParentalNodePaths()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nodePath.size(); ++i) { osg::Node *node = nodePath[i]; <span class="hljs-comment"><span class="hljs-comment">// -    }</span></span></code> </pre><br>  renverra les n≈ìuds Root, Child1, Child2. <br><br>  Vous ne devez pas utiliser de m√©canismes de gestion de la m√©moire pour r√©f√©rencer les n≈ìuds parents.  Lorsqu'un n≈ìud parent est supprim√©, tous les n≈ìuds enfants sont automatiquement supprim√©s, ce qui peut entra√Æner un blocage de l'application. <br><br><h1>  3. Ajout de plusieurs mod√®les √† l'arborescence de la sc√®ne </h1><br>  Nous illustrons le m√©canisme d'utilisation des groupes avec l'exemple suivant. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de groupe complet</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Group&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc, (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Fondamentalement, l'exemple diff√®re de tous les pr√©c√©dents en ce que nous chargeons deux mod√®les tridimensionnels et pour les ajouter √† la sc√®ne, nous cr√©ons un n≈ìud racine de groupe et nous y ajoutons nos mod√®les en tant que n≈ìuds enfants <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get());</code> </pre><br><img src="https://habrastorage.org/webt/gu/yg/gx/guyggxstfydtvlfbosbe-ara3jm.png"><br><br>  En cons√©quence, nous obtenons une sc√®ne compos√©e de deux mod√®les - un avion et une dr√¥le de vache miroir.  Soit dit en passant, une vache miroir ne sera pas miroir, sauf si vous copiez sa texture depuis OpenSceneGraph-Data / Images / reflect.rgb dans le r√©pertoire data / Images de notre projet. <br><br>  La classe osg :: Group peut accepter tous les types de n≈ìuds en tant qu'enfants, y compris les n≈ìuds de son type.  Au contraire, la classe osg :: Geode ne contient aucun n≈ìud enfant - c'est un n≈ìud terminal contenant la g√©om√©trie de l'objet sc√®ne.  Ce fait est pratique lorsque vous demandez si le n≈ìud est un n≈ìud de type osg :: Group ou un autre type de d√©riv√© d'osg :: Node.  Regardons un petit exemple. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Group *&gt;(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>));</code> </pre><br>  La valeur renvoy√©e par la fonction osgDB :: readNodeFile () est toujours de type osg :: Node *, mais elle peut √™tre convertie en son descendant osg :: Group *.  Si le n≈ìud du mod√®le Cessna est un n≈ìud de groupe, la conversion r√©ussira, sinon la conversion renverra NULL. <br><br>  Vous pouvez √©galement effectuer la m√™me astuce qui fonctionne sur la plupart des compilateurs <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      osg::ref_ptr&lt;osg::Group&gt; group = ...; //     osg::Node* node1 = dynamic_cast&lt;osg::Node*&gt;( group.get() ); //      osg::Node* node2 = group.get();</span></span></code> </pre><br>  Dans les emplacements de code critiques pour les performances, il est pr√©f√©rable d'utiliser des m√©thodes de conversion sp√©ciales <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>); osg::Group* convModel1 = model-&gt;asGroup(); <span class="hljs-comment"><span class="hljs-comment">//   osg::Geode* convModel2 = model-&gt;asGeode(); //  NULL.</span></span></code> </pre><br><h1>  4. N≈ìuds de transformation </h1><br>  Les n≈ìuds Osg :: Group ne peuvent effectuer aucune transformation, sauf la possibilit√© d'acc√©der √† leurs n≈ìuds enfants.  OSG fournit la classe osg :: Transform pour le mouvement de la g√©om√©trie spatiale.  Cette classe est un successeur de la classe osg :: Group, mais elle est √©galement abstraite - en pratique, ses h√©ritiers sont utilis√©s √† la place, qui impl√©mentent diverses transformations spatiales de la g√©om√©trie.  Lors de la travers√©e du graphe de la sc√®ne, le n≈ìud osg :: Transform ajoute sa transformation √† la matrice de transformation OpenGL actuelle.  Cela √©quivaut √† multiplier les matrices de transformation OpenGL par la commande glMultMatrix () <br><br><img src="https://habrastorage.org/webt/sj/f7/ql/sjf7qlofwivlimwfljauwnll9nw.png"><br><br>  Cet exemple de graphique de sc√®ne peut √™tre traduit dans le code OpenGL suivant <br><br><pre> <code class="cpp hljs">glPushMatrix(); glMultMatrix( matrixOfTransform1 ); renderGeode1(); glPushMatrix(); glMultMatrix( matrixOfTransform2 ); renderGeode2(); glPopMatrix(); glPopMatrix();</code> </pre><br>  Nous pouvons dire que la position de Geode1 est d√©finie dans le syst√®me de coordonn√©es Transform1, et la position de Geode2 est d√©finie dans le syst√®me de coordonn√©es Transform2, d√©cal√©e par rapport √† Transform1.  Dans le m√™me temps, le positionnement en coordonn√©es absolues peut √™tre activ√© dans OSG, ce qui conduira au comportement de l'objet, √©quivalent au r√©sultat de la commande OpenGL glGlobalMatrix () <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::ABSOLUTE_RF );</code> </pre><br>  Vous pouvez revenir au mode de positionnement relatif <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::RELATIVE_RF );</code> </pre><br><h1>  5. Le concept d'une matrice de transformation de coordonn√©es </h1><br>  Le type osg :: Matrix est un type OSG de base non contr√¥l√© par des pointeurs intelligents.  Il fournit une interface pour les op√©rations sur des matrices 4x4 qui d√©crivent la transformation des coordonn√©es, telles que le d√©placement, la rotation, la mise √† l'√©chelle et le calcul des projections.  La matrice peut √™tre sp√©cifi√©e explicitement. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   44 osg::Matrix mat(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f );</span></span></code> </pre><br>  La classe osg :: Matrix fournit les m√©thodes publiques suivantes: <br><br><ol><li>  postMult () et operator * () - la bonne multiplication de la matrice courante par la matrice ou le vecteur pass√© en param√®tre.  La m√©thode preMult () effectue une multiplication √† gauche. <br></li><li>  makeTranslate (), makeRotate () et makeScale () - r√©initialisez la matrice actuelle et cr√©ez une matrice 4x4 qui d√©crit le mouvement, la rotation et la mise √† l'√©chelle.  leurs versions statiques translate (), rotate () et scale () peuvent √™tre utilis√©es pour cr√©er un objet matriciel avec des param√®tres sp√©cifiques. <br></li><li>  invert () - calcule l'inverse de la matrice actuelle.  Sa version statique d'inverse () prend une matrice comme param√®tre et renvoie une nouvelle matrice inverse √† la donn√©e. <br></li></ol><br>  OSG comprend les matrices comme des matrices de cha√Ænes et les vecteurs comme des cha√Ænes.Par cons√©quent, pour appliquer une transformation matricielle √† un vecteur, proc√©dez comme suit <br><br><pre> <code class="cpp hljs">osg::Matrix mat = ‚Ä¶; osg::Vec3 vec = ‚Ä¶; osg::Vec3 resultVec = vec * mat;</code> </pre><br>  L'ordre des op√©rations matricielles est facile √† comprendre en regardant comment les matrices sont multipli√©es pour obtenir une conversion √©quivalente <br><br><pre> <code class="cpp hljs">osg::Matrix mat1 = osg::Matrix::scale(sx, sy, sz); osg::Matrix mat2 = osg::Matrix::translate(x, y, z); osg::Matrix resultMat = mat1 * mat2;</code> </pre><br>  Le d√©veloppeur doit lire le processus de transformation de gauche √† droite.  C'est-√†-dire que dans le fragment de code d√©crit, le vecteur est d'abord mis √† l'√©chelle, puis son mouvement. <br><br>  osg :: Matrixf contient des √©l√©ments de type float. <br><br><h1>  6. Utilisation de la classe osg :: MatrixTransform </h1><br>  Nous appliquons les connaissances th√©oriques acquises en pratique en chargeant deux mod√®les d'avion √† diff√©rents points de la sc√®ne. <br><br><div class="spoiler">  <b class="spoiler_title">Texte int√©gral de l'exemple de transformation</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0, 0.0, 0.0)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0, 0.0, 0.0)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  L'exemple est en fait assez banal.  Chargement du mod√®le d'avion √† partir du fichier <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Cr√©er un n≈ìud de transformation <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform;</code> </pre><br>  Nous d√©finissons comme matrice de transformation le mouvement du mod√®le le long de l'axe X de 25 unit√©s vers la gauche <br><br><pre> <code class="cpp hljs">transform1-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">-25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>));</code> </pre><br>  Nous d√©finissons notre mod√®le pour le n≈ìud de transformation en tant que n≈ìud enfant <br><br><pre> <code class="cpp hljs">transform1-&gt;addChild(model.get());</code> </pre><br>  Nous faisons de m√™me avec la deuxi√®me transformation, mais en tant que matrice, nous r√©glons le mouvement vers la droite de 25 unit√©s <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); transform2-&gt;addChild(model.get());</code> </pre><br>  Nous cr√©ons un n≈ìud racine et en tant que n≈ìuds de transformation, nous d√©finissons des n≈ìuds de transformation transform1 et transform2 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get());</code> </pre><br>  Cr√©ez une visionneuse et passez-lui le n≈ìud racine en tant que donn√©es de sc√®ne <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get());</code> </pre><br>  L'ex√©cution du programme donne une telle image <br><br><img src="https://habrastorage.org/webt/tb/3q/xn/tb3qxnvgrcobwa0w7sz13k2njq8.png"><br><br>  La structure du graphique de sc√®ne dans cet exemple est la suivante. <br><br><img src="https://habrastorage.org/webt/pp/ig/xg/ppigxg36m3wph0idp1bwyln57tq.png"><br><br>  Il ne faut pas confondre le fait que les n≈ìuds de transformation (Child 1.1 et Child 1.2) se r√©f√®rent au m√™me objet enfant du mod√®le d'avion (Child 2).  Il s'agit d'un m√©canisme OSG standard, lorsqu'un n≈ìud enfant d'un graphe de sc√®ne peut avoir plusieurs n≈ìuds parents.  Ainsi, nous n'avons pas besoin de stocker deux instances du mod√®le dans notre m√©moire pour obtenir deux plans identiques dans la sc√®ne.  Ce m√©canisme vous permet d'allouer tr√®s efficacement la m√©moire dans l'application.  Le mod√®le ne sera pas supprim√© de la m√©moire tant qu'il ne sera pas appel√© enfant, au moins un n≈ìud. <br><br>  Dans son action, la classe osg :: MatrixTransform est √©quivalente aux commandes OpenGL glMultMatrix () et glLoadMatrix (), impl√©mente tous les types de transformations spatiales, mais est difficile √† utiliser en raison de la n√©cessit√© de calculer la matrice de transformation. <br><br>  La classe osg :: PositionAttitudeTransform fonctionne comme les fonctions OpenGL glTranslate (), glScale (), glRotate ().  Il fournit des m√©thodes publiques pour convertir les n≈ìuds enfants: <br><br><ol><li>  setPosition () - d√©place le n≈ìud vers un point donn√© dans l'espace sp√©cifi√© par le param√®tre osg :: Vec3 <br></li><li>  setScale () - redimensionne l'objet le long des axes de coordonn√©es.  Les facteurs d'√©chelle le long des axes correspondants sont d√©finis par un param√®tre de type osg :: Vec3 <br></li><li>  setAttitude () - d√©finit l'orientation spatiale de l'objet.  En tant que param√®tre, la transformation de rotation osg :: Quat quaternion est utilis√©e, dont le constructeur a plusieurs surcharges qui vous permettent de sp√©cifier le quaternion √† la fois directement (composant par composant) et, par exemple, via les angles d'Euler osg :: Quat (xAngle, osg :: X_AXIS, yAngle, osg :: Y_AXIS, zAngle, osg :: Z_AXIS) (les angles sont donn√©s en radians!) <br></li></ol><br><br><h1>  7. Changer de n≈ìuds </h1><br>  Prenons une autre classe - osg :: Switch, qui vous permet d'afficher ou d'ignorer le rendu d'un n≈ìud de sc√®ne, en fonction d'une condition logique.  C'est un descendant de la classe osg :: Group et attache une valeur logique √† chacun de ses enfants.  Il a plusieurs m√©thodes publiques utiles: <br><ol><li>  Surcharg√©, addChild (), en tant que deuxi√®me param√®tre, prend une cl√© logique qui indique s'il faut ou non afficher ce n≈ìud. <br></li><li>  setValue () - d√©finit la cl√© de visibilit√© / invisibilit√©.  Il prend l'index du n≈ìud enfant qui nous int√©resse et la valeur de cl√© souhait√©e.  En cons√©quence, getValue () vous permet d'obtenir la valeur de cl√© actuelle par l'index du n≈ìud qui nous int√©resse. <br></li><li>  setNewChildDefaultValue () - d√©finit la valeur par d√©faut pour la cl√© de visibilit√© de tous les nouveaux objets ajout√©s en tant qu'enfants. <br></li></ol><br>  Consid√©rez l'application de cette classe avec un exemple. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de commutateur complet</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), false); root-&gt;addChild(model2.get(), true); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  L'exemple est trivial - nous chargeons deux mod√®les: un cessna conventionnel et un cessna avec l'effet d'un moteur en feu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessnafire.osg"</span></span>);</code> </pre><br>  Cependant, nous cr√©ons osg :: Switch en tant que n≈ìud racine, ce qui nous permet, lors de l'ajout de mod√®les en tant que n≈ìuds enfants, de d√©finir la cl√© de visibilit√© pour chacun d'eux <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Switch&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Switch; root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Autrement dit, model1 ne sera pas rendu, et model2 sera, que nous observerons en ex√©cutant le programme <br><br><img src="https://habrastorage.org/webt/ne/ql/xu/neqlxu8zkqzvsusyzeoaqow8urg.png"><br><br>  En √©changeant les valeurs des cl√©s, nous verrons l'image oppos√©e <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/fs/ae/z4/fsaez4jingyv1u3lx9-4ihsr3zq.png"><br><br>  Armant les deux touches, nous verrons deux mod√®les en m√™me temps <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/vl/7j/za/vl7jzamish8ype6md3lljfnqsp0.png"><br><br>  Vous pouvez activer la visibilit√© et l'invisibilit√© d'un n≈ìud, un enfant d'osg :: Switch, √† tout moment en utilisant la m√©thode setValue () <br><br><pre> <code class="cpp hljs">switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h1>  Conclusion </h1><br>  Dans ce didacticiel, nous avons examin√© toutes les principales classes de n≈ìuds interm√©diaires utilis√©es dans OpenSceeneGraph.  Ainsi, nous avons pos√© une autre brique de base dans la fondation des connaissances sur le dispositif de ce moteur graphique sans aucun doute int√©ressant.  Les exemples discut√©s dans l'article, comme pr√©c√©demment, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont disponibles dans mon r√©f√©rentiel sur Github</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430242/">https://habr.com/ru/post/fr430242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430230/index.html">Comment garder sa place dans une startup en pleine croissance</a></li>
<li><a href="../fr430232/index.html">G√©n√©ration de Close call dans les jeux: ¬´Au bord de la d√©faite¬ª ou ¬´Presque gagn√©¬ª</a></li>
<li><a href="../fr430236/index.html">La NASA annonce un nouveau vol lunaire</a></li>
<li><a href="../fr430238/index.html">Un autre DSL sur Kotlin ou comment j'ai imprim√© un PDF √† partir de React</a></li>
<li><a href="../fr430240/index.html">Vuln√©rabilit√© li√©e au nombre pseudo-al√©atoire de Bitcoin</a></li>
<li><a href="../fr430244/index.html">SpaceX a re√ßu l'autorisation de d√©ployer un r√©seau de satellites de 11943 satellites</a></li>
<li><a href="../fr430246/index.html">D√©localisation vers le socialisme autrichien</a></li>
<li><a href="../fr430252/index.html">Ennemi √† l'int√©rieur: comment je suis entr√© dans le d√©lit d'initi√©</a></li>
<li><a href="../fr430256/index.html">Configuration d'application - M√©tadonn√©es de configuration Spring</a></li>
<li><a href="../fr430258/index.html">Non aux d√©charges de MSW - mettez une ferme de vermicinif√®res sous la fen√™tre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>