<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈹 👨‍👧‍👦 ⚗️ Comprendre l'algorithme FFT 🍿 👩🏿‍🤝‍👩🏾 🚣🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour mes amis. Le cours Algorithms for Developers commence demain, et nous avons encore une traduction non publiée. En fait, nous corrigeons et par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre l'algorithme FFT</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449996/"> Bonjour mes amis.  Le cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Algorithms for Developers</a> commence demain, et nous avons encore une traduction non publiée.  En fait, nous corrigeons et partageons le matériel avec vous.  Allons-y. <br><br>  La transformation de Fourier rapide (FFT) est l'un des algorithmes les plus importants de traitement du signal et d'analyse de données.  Je l'ai utilisé pendant des années sans connaissances formelles en informatique.  Mais cette semaine, il m'est venu à l'esprit que je ne me suis jamais demandé comment la FFT calcule la transformée de Fourier discrète si rapidement.  J'ai secoué la poussière d'un vieux livre sur les algorithmes, l'ai ouvert et j'ai lu avec plaisir l'astuce de calcul trompeusement simple que J.V.Cooley et John Tukey ont décrite dans leur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ouvrage</a> classique de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1965</a> sur ce sujet. <br><br><img src="https://habrastorage.org/webt/n4/54/6k/n4546kuwmamg91yhazlpndgglh4.png"><br><br>  Le but de ce post est de plonger dans l'algorithme FFT de Cooley-Tukey, expliquant les symétries qui y conduisent, et de montrer quelques implémentations Python simples qui appliquent la théorie dans la pratique.  J'espère que cette étude donnera aux spécialistes de l'analyse des données, comme moi, une image plus complète de ce qui se passe sous le capot des algorithmes que nous utilisons. <a name="habracut"></a><br><br>  <b>Transformation de Fourier discrète</b> <br><br>  La FFT est rapide <img src="https://habrastorage.org/webt/bq/s0/ah/bqs0ahni9guseo62jp5hvz3e4x8.png">  un algorithme de calcul de la transformée de Fourier discrète (DFT), qui est directement calculé pour <img src="https://habrastorage.org/webt/ys/jt/e9/ysjte98k7mfch0w1mttpu5fqnbg.png">  .  La DFT, comme la version continue plus familière de la transformée de Fourier, a une forme directe et inverse, qui sont définies comme suit: <br><br>  <i><b>Transformation de Fourier discrète directe (DFT):</b></i> <br><br><img src="https://habrastorage.org/webt/uj/sh/qc/ujshqcnsbasvypykupwcjocfbcg.png"><br><br>  <i><b>Transformée de Fourier discrète inverse (ODPF):</b></i> <br><br><img src="https://habrastorage.org/webt/zg/dp/0t/zgdp0tdylocjv_ck6a0y6m97ac8.png"><br><br>  La conversion de <code>xn → Xk</code> est une traduction de l'espace de configuration vers l'espace de fréquence et peut être très utile à la fois pour étudier le spectre de puissance du signal et pour convertir certaines tâches pour un calcul plus efficace.  Vous pouvez trouver quelques exemples de cela en action dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chapitre 10 de notre futur livre</a> sur l'astronomie et les statistiques, où vous pouvez également trouver des images et du code source Python.  Pour un exemple d'utilisation de la FFT pour simplifier l'intégration d'équations différentielles autrement compliquées, voir mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Résoudre l'équation de Schrödinger en Python»</a> . <br><br>  En raison de l'importance de la FFT (ci-après, l'équivalent FFT - Fast Fourier Transform peut être utilisé) dans de nombreux domaines de Python contient de nombreux outils et shells standard pour le calculer.  NumPy et SciPy ont tous les deux des shells de la bibliothèque FFTPACK extrêmement bien testée, qui sont situés dans les <code>scipy.fftpack</code> <code>numpy.fft</code> et <code>scipy.fftpack</code> respectivement.  La FFT la plus rapide que je connaisse se trouve dans le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FFTW</a> , qui est également disponible en Python via le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PyFFTW</a> . <br><br>  Pour le moment, cependant, laissons ces implémentations de côté et nous demandons comment nous pouvons calculer la FFT en Python à partir de zéro. <br><br>  <b>Calcul de transformée de Fourier discrète</b> <br><br>  Par souci de simplicité, nous ne traiterons que de la conversion directe, car la transformation inverse peut être implémentée de manière très similaire.  En regardant l'expression ci-dessus de la DFT, nous voyons que ce n'est rien de plus qu'une opération linéaire simple: multiplier la matrice par un vecteur <br><br><img src="https://habrastorage.org/webt/mg/qb/es/mgqbesmhfu6rqoztm33y2o6dpd0.png"><br><br><img src="https://habrastorage.org/webt/zi/1a/t2/zi1at2pha9pp2xtnu_if6cps-xe.png"><br><br>  avec matrice M donnée <br><br><img src="https://habrastorage.org/webt/ox/ka/mc/oxkamcki5i2fn5nqafbue7phkki.png"><br><br>  Dans cet esprit, nous pouvons calculer la DFT en utilisant une simple multiplication matricielle comme suit: <br><br>  Dans [1]: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DFT_slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Compute the discrete Fourier Transform of the 1D array x"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] n = np.arange(N) k = n.reshape((N, <span class="hljs-number"><span class="hljs-number">1</span></span>)) M = np.exp(<span class="hljs-number"><span class="hljs-number">-2j</span></span> * np.pi * k * n / N) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.dot(M, x)</code> </pre> <br>  Nous pouvons revérifier le résultat en le comparant avec la fonction FFT intégrée à numpy: <br><br>  Dans [2]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(DFT_slow(x), np.fft.fft(x))</code> </pre> <br>  0ut [2]: <br><br> <code>True</code> <br> <br>  Juste pour confirmer la lenteur de notre algorithme, nous pouvons comparer le temps d'exécution de ces deux approches: <br><br>  Dans [3]: <br><br><pre> <code class="python hljs">%timeit DFT_slow(x) %timeit np.fft.fft(x)</code> </pre> <br><pre> <code class="plaintext hljs">10 loops, best of 3: 75.4 ms per loop 10000 loops, best of 3: 25.5 µs per loop</code> </pre> <br>  Nous sommes plus de 1000 fois plus lents, ce qui est à prévoir pour une telle implémentation simplifiée.  Mais ce n'est pas le pire.  Pour un vecteur d'entrée de longueur N, l'algorithme FFT évolue comme <img src="https://habrastorage.org/webt/ee/qz/zq/eeqzzqrjiwlvtmh8qgpmsa5g_lm.png">  tandis que notre algorithme lent évolue comme <img src="https://habrastorage.org/webt/qk/or/aw/qkoraw_lw5tjqyhr1ubbvmvx0i4.png">  .  Cela signifie que pour <img src="https://habrastorage.org/webt/8s/bu/zi/8sbuziwl0cyxjezr0qezsvibrpo.png">  éléments, nous nous attendons à ce que la FFT se termine dans environ 50 ms, tandis que notre algorithme lent prendra environ 20 heures! <br><br>  Alors, comment la FFT parvient-elle à une telle accélération?  La réponse est d'utiliser la symétrie. <br><br>  <b>Symétries dans la transformée de Fourier discrète</b> <br><br>  L'un des outils les plus importants dans la construction d'algorithmes est l'utilisation de symétries de tâches.  Si vous pouvez montrer analytiquement qu'une partie du problème est simplement liée à l'autre, vous ne pouvez calculer le sous-résultat qu'une seule fois et enregistrer ce coût de calcul.  Cooley et Tukey ont utilisé exactement cette approche pour obtenir la FFT. <br>  Nous commençons par la question du sens <img src="https://habrastorage.org/webt/wv/vq/0t/wvvq0twerwsciysi5sgxfsnfooo.png">  .  De notre expression ci-dessus: <br><br><img src="https://habrastorage.org/webt/hd/el/f3/hdelf3dxco-xuar0bgic_ha89lu.png"><br><br>  où nous avons utilisé l'identité exp [2π in] = 1, qui vaut pour tout entier n. <br><br>  La dernière ligne montre bien la propriété de symétrie de la DFT: <br><br><img src="https://habrastorage.org/webt/ac/dz/wq/acdzwq4jwn4vizgzdafg3as6ila.png"><br><br>  Une extension simple <br><br><img src="https://habrastorage.org/webt/su/bl/c_/sublc_wuerprr4ppl_bqln89c24.png"><br><br>  pour tout entier i.  Comme nous le verrons ci-dessous, cette symétrie peut être utilisée pour calculer la DFT beaucoup plus rapidement. <br><br>  <b>DFT dans FFT: utiliser la symétrie</b> <br><br>  Cooley et Tukey ont montré que les calculs FFT peuvent être divisés en deux parties plus petites.  D'après la définition de DFT, nous avons: <br><br><img src="https://habrastorage.org/webt/dg/lz/lm/dglzlmmd1oue7oqyn39gwavofva.png"><br><br>  Nous avons divisé une transformée de Fourier discrète en deux termes, qui en eux-mêmes sont très similaires aux petites transformées de Fourier discrètes, une aux valeurs avec un nombre impair et une aux valeurs avec un nombre pair.  Cependant, jusqu'à présent, nous n'avons enregistré aucun cycle de calcul.  Chaque terme se compose de (N / 2) ∗ N calculs, total <img src="https://habrastorage.org/webt/bg/lz/we/bglzwecwics3t1gful-oe5auipc.png">  . <br><br>  L'astuce consiste à utiliser la symétrie dans chacune de ces conditions.  Puisque la plage de k est 0≤k &lt;N, et la plage de n est 0≤n &lt;M≡N / 2, nous voyons dans les propriétés de symétrie ci-dessus que nous devons effectuer seulement la moitié des calculs pour chaque sous-tâche.  Notre calcul <img src="https://habrastorage.org/webt/my/tx/pq/mytxpqv7swzpsqfbq5manbp7kme.png">  est devenu <img src="https://habrastorage.org/webt/6l/lv/ln/6llvlnumnlnndoir0whpg7qf_gc.png">  où M est deux fois moins que N. <br><br>  Mais il n'y a aucune raison de s'y attarder: tant que nos petites transformées de Fourier ont un M pair, nous pouvons réappliquer cette approche diviser pour mieux régner, en réduisant chaque fois de moitié le coût de calcul, jusqu'à ce que nos matrices soient suffisamment petites pour que la stratégie ne profite plus.  Dans la limite asymptotique, cette approche récursive évolue comme O [NlogN]. <br><br>  Cet algorithme récursif peut être implémenté très rapidement en Python, à partir de notre code DFT lent, lorsque la taille de la sous-tâche devient assez petite: <br><br>  Dans [4]: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""A recursive implementation of the 1D Cooley-Tukey FFT"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> N % <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"size of x must be a power of 2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> N &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span>: <span class="hljs-comment"><span class="hljs-comment"># this cutoff should be optimized return DFT_slow(x) else: X_even = FFT(x[::2]) X_odd = FFT(x[1::2]) factor = np.exp(-2j * np.pi * np.arange(N) / N) return np.concatenate([X_even + factor[:N / 2] * X_odd, X_even + factor[N / 2:] * X_odd])</span></span></code> </pre> <br><br>  Ici, nous allons vérifier rapidement que notre algorithme donne le résultat correct: <br>  Dans [5]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(FFT(x), np.fft.fft(x))</code> </pre> <br><br>  Sortie [5]: <br> <code>True</code> <br> <br>  Comparez cet algorithme avec notre version lente: <br>  -Dans [6]: <br><br><pre> <code class="python hljs">%timeit DFT_slow(x) %timeit FFT(x) %timeit np.fft.fft(x)</code> </pre> <br><br><pre> <code class="plaintext hljs">10 loops, best of 3: 77.6 ms per loop 100 loops, best of 3: 4.07 ms per loop 10000 loops, best of 3: 24.7 µs per loop</code> </pre> <br>  Notre calcul est plus rapide que la version directe!  De plus, notre algorithme récursif est asymptotiquement <img src="https://habrastorage.org/webt/ee/qz/zq/eeqzzqrjiwlvtmh8qgpmsa5g_lm.png">  : nous avons implémenté la transformée de Fourier rapide. <br><br>  Notez que nous ne sommes toujours pas proches de la vitesse de l'algorithme FFT intégré numpy, et cela devrait être prévu.  L'algorithme FFTPACK derrière <code>fft</code> numpy est une implémentation Fortran qui a reçu des années de raffinement et d'optimisation.  De plus, notre solution NumPy inclut à la fois la récursivité de la pile Python et l'allocation de nombreux tableaux temporaires, ce qui augmente le temps de calcul. <br><br>  Une bonne stratégie pour accélérer le code lorsque vous travaillez avec Python / NumPy consiste à vectoriser les calculs répétitifs autant que possible.  Nous pouvons le faire - dans le processus, supprimez nos appels de fonction récursifs, ce qui rendra notre FFT Python encore plus efficace. <br><br>  <b>Version Numpy vectorisée</b> <br><br>  Veuillez noter que dans l'implémentation récursive de la FFT ci-dessus, au niveau de récursivité le plus bas, nous effectuons <b>N / 32</b> produits matriciels vectoriels identiques.  L'efficacité de notre algorithme gagnera si nous calculons simultanément ces produits matriciels-vectoriels comme un seul produit matriciel-matrice.  À chaque niveau de récursivité suivant, nous effectuons également des opérations répétitives qui peuvent être vectorisées.  NumPy fait un excellent travail d'une telle opération, et nous pouvons utiliser ce fait pour créer cette version vectorisée de la transformée de Fourier rapide: <br><br>  Dans [7]: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFT_vectorized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""A vectorized, non-recursive version of the Cooley-Tukey FFT"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> np.log2(N) % <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"size of x must be a power of 2"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># N_min here is equivalent to the stopping condition above, # and should be a power of 2 N_min = min(N, 32) # Perform an O[N^2] DFT on all length-N_min sub-problems at once n = np.arange(N_min) k = n[:, None] M = np.exp(-2j * np.pi * n * k / N_min) X = np.dot(M, x.reshape((N_min, -1))) # build-up each level of the recursive calculation all at once while X.shape[0] &lt; N: X_even = X[:, :X.shape[1] / 2] X_odd = X[:, X.shape[1] / 2:] factor = np.exp(-1j * np.pi * np.arange(X.shape[0]) / X.shape[0])[:, None] X = np.vstack([X_even + factor * X_odd, X_even - factor * X_odd]) return X.ravel()</span></span></code> </pre> <br>  Bien que l'algorithme soit légèrement plus opaque, il s'agit simplement d'un réarrangement des opérations utilisées dans la version récursive, à une exception près: nous utilisons la symétrie dans le calcul des coefficients et ne construisons que la moitié du tableau.  Encore une fois, nous confirmons que notre fonction donne le résultat correct: <br><br>  Dans [8]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(FFT_vectorized(x), np.fft.fft(x))</code> </pre> <br><br>  Sortie [8]: <br> <code>True</code> <br> <br>  Comme nos algorithmes deviennent beaucoup plus efficaces, nous pouvons utiliser un tableau plus grand pour comparer le temps, laissant <code>DFT_slow</code> : <br>  Dans [9]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) %timeit FFT(x) %timeit FFT_vectorized(x) %timeit np.fft.fft(x)</code> </pre> <br><pre> <code class="plaintext hljs">10 loops, best of 3: 72.8 ms per loop 100 loops, best of 3: 4.11 ms per loop 1000 loops, best of 3: 505 µs per loop</code> </pre> <br>  Nous avons amélioré notre mise en œuvre d'un ordre de grandeur!  Nous sommes maintenant à environ 10 fois loin du benchmark FFTPACK, en utilisant seulement quelques dizaines de lignes de Python + NumPy pur.  Bien que cela ne soit toujours pas cohérent sur le plan des calculs, en termes de lisibilité, la version Python est de loin supérieure au code source FFTPACK, que vous pouvez consulter <a href="">ici</a> . <br><br>  Alors, comment FFTPACK parvient-il à cette dernière accélération?  Eh bien, fondamentalement, c'est juste une question de comptabilité détaillée.  FFTPACK passe beaucoup de temps à réutiliser tous les calculs intermédiaires qui peuvent être réutilisés.  Notre version irrégulière inclut toujours l'allocation et la copie de mémoire en excès;  dans un langage de bas niveau tel que Fortran, il est plus facile de contrôler et de minimiser l'utilisation de la mémoire.  De plus, l'algorithme Cooley-Tukey peut être étendu pour utiliser des partitions d'une taille autre que 2 (ce que nous avons mis en œuvre ici est connu sous le nom de Cooley-Tukey Radix FFT à partir de la base 2).  D'autres algorithmes FFT plus complexes peuvent également être utilisés, y compris des approches fondamentalement différentes basées sur des données de convolution (voir, par exemple, l'algorithme Blueshtein et l'algorithme Raider).  La combinaison des extensions et des méthodes ci-dessus peut conduire à des FFT très rapides même sur des tableaux dont la taille n'est pas une puissance de deux. <br><br>  Bien que les fonctions en Python pur soient probablement inutiles dans la pratique, j'espère qu'elles fournissent un aperçu de ce qui se passe dans le contexte de l'analyse des données basée sur FFT.  En tant que spécialistes des données, nous pouvons faire face à la mise en œuvre de la «boîte noire» des outils fondamentaux créés par nos collègues plus algorithmiques, mais je crois fermement que plus nous comprenons les algorithmes de bas niveau que nous appliquons à nos données, les meilleures pratiques nous le ferons. <br><br>  Ce message a été entièrement écrit dans le bloc-notes IPython.  Le bloc-notes complet peut être téléchargé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ou affiché statiquement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Beaucoup peuvent remarquer que le matériel n'est pas nouveau, mais, comme il nous semble, est tout à fait pertinent.  En général, indiquez si l'article était utile.  En attente de vos commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449996/">https://habr.com/ru/post/fr449996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449984/index.html">Google Actualités et Leo Tolstoy: visualisation des incorporations de mots Word2Vec à l'aide de t-SNE</a></li>
<li><a href="../fr449986/index.html">Blockchain: que devons-nous construire un boîtier?</a></li>
<li><a href="../fr449990/index.html">Comment se faire des amis latex, formules et Habr?</a></li>
<li><a href="../fr449992/index.html">Présentation du modèle de pilote simple (SDM) NodeMCU: interface utilisateur dynamique</a></li>
<li><a href="../fr449994/index.html">Les huit règles d'or de Schneiderman vous aideront à créer une meilleure interface</a></li>
<li><a href="../fr449998/index.html">FAQ: ce qu'un voyageur connaisseur doit savoir sur les vaccinations avant de voyager</a></li>
<li><a href="../fr450000/index.html">(De droite à gauche (À travers le miroir)</a></li>
<li><a href="../fr450002/index.html">Recherche de bogues dans LLVM 8 avec PVS-Studio</a></li>
<li><a href="../fr450004/index.html">Cache C / C ++ rapide, sécurité des threads</a></li>
<li><a href="../fr450006/index.html">Refroidissement du datacenter du refroidisseur: quel liquide de refroidissement choisir?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>