<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎗️ 🗑️ 🍜 MVVM et sélection d'éléments dans l'adaptateur 🛂 👨🏼‍🍳 🎆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Déjà après le 3e adaptateur auto-écrit, dans lequel il était nécessaire de mettre en œuvre la logique de mémorisation de l'élément sélectionné, j'avai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVVM et sélection d'éléments dans l'adaptateur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483552/"><p> Déjà après le 3e adaptateur auto-écrit, dans lequel il était nécessaire de mettre en œuvre la logique de mémorisation de l'élément sélectionné, j'avais pensé qu'il devrait y avoir une solution qui comprend déjà tout le nécessaire.  Surtout si pendant le processus de développement, vous deviez changer la possibilité de sélectionner un seul élément pour un choix multiple. </p><br><p> Après avoir étudié l'approche MVVM et y avoir pleinement plongé, la question susmentionnée s'est posée de manière beaucoup plus marquée.  De plus, l'adaptateur lui-même est au niveau de la <code>View</code> , tandis que les informations sur les éléments sélectionnés sont souvent extrêmement nécessaires pour le <code>ViewModel</code> . </p><br><p>  Peut-être que je n'ai pas passé assez de temps à chercher des réponses sur Internet, mais, en tout cas, je n'ai pas trouvé de solution toute faite.  Cependant, dans l'un des projets, j'ai proposé une idée de mise en œuvre qui pourrait bien être universelle, j'ai donc voulu la partager. <a name="habracut"></a></p><br><p>  <strong><em>Remarque</em></strong> .  Bien qu'il soit logique et approprié que MVVM sur Android fasse une implémentation avec <code>LiveData</code> , à ce stade, je ne suis pas prêt à écrire du code en l'utilisant.  Ce n'est donc que pour l'avenir.  Mais la solution finale s'est avérée sans dépendances <code>Android</code> , ce qui permet potentiellement de l'utiliser sur n'importe quelle plate-forme où kotlin peut fonctionner. </p><br><h2 id="selectionmanager">  SelectionManager </h2><br><p>  Pour résoudre ce problème, l'interface générale de <code>SelectionManager</code> été compilée: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectionManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearSelection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">selectPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPositionSelected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerSelectionChangeListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(listener: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">position</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, isSelected: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Disposable <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSelectedPositions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ArrayList&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAnySelected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSelectionInterceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(interceptor: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">position</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, isSelected: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, callback: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Disposable }</code> </pre> <br><p>  Par défaut, il existe déjà 3 implémentations différentes: </p><br><ul><li>  <code>MultipleSelection</code> - l'objet vous permet de sélectionner autant d'éléments que vous le souhaitez dans la liste; </li><li>  <code>SingleSelection</code> - un objet vous permet de sélectionner un seul élément; </li><li>  <code>NoneSelection</code> - l'objet ne permet pas du tout de sélectionner des éléments. </li></ul><br><p>  Probablement, avec ce dernier, il y aura la plupart de toutes les questions, donc je vais essayer de montrer déjà sur un exemple. </p><br><h2 id="adapter">  Adaptateur </h2><br><p>  Il est censé ajouter l'objet <code>SelectionManager</code> à l'adaptateur en tant que dépendance via le constructeur. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestAdapter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectionManager: SelectionManager) : RecyclerView.Adapter&lt;TestHolder&gt;() { <span class="hljs-comment"><span class="hljs-comment">//class body }</span></span></code> </pre> <br><p>  Dans l'exemple, je ne m'embêterai pas avec la logique de traitement du clic sur un élément, nous convenons donc simplement que le titulaire (sans détails) est entièrement responsable de la nomination de l'écouteur de clic. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestHolder</span></span></span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">, onItemClick: ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//all bind logic } }</span></span></code> </pre> <br><p>  De plus, pour que cette magie fonctionne, l'adaptateur doit effectuer les 3 étapes suivantes: </p><br><h4 id="1-onbindviewholder"> <code>1. onBindViewHolder</code> </h4> <br><p>  Passez un rappel à la méthode de <code>bind</code> du titulaire, qui appellera <code>selectionManager.selectPosition(position)</code> pour l'élément affiché.  Ici aussi, vous devrez probablement modifier l'affichage (le plus souvent uniquement l'arrière-plan) selon que l'élément est actuellement sélectionné - vous pouvez appeler <code>selectionManager.isPositionSelected(position)</code> pour cela. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(holder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TestHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isItemSelected = selectionManager.isPositionSelected(position) <span class="hljs-comment"><span class="hljs-comment">//do whatever you need depending on `isItemSelected` value val item = ... //get current item by `position` value holder.bind(item) { selectionManager.selectPosition(position) } }</span></span></code> </pre> <br><h4 id="2-registerselectionchangelistener"> <code>2. registerSelectionChangeListener</code> </h4> <br><p>  Pour que l'adaptateur mette à jour les éléments pressés en temps opportun, vous devez vous abonner à l'action appropriée.  Et n'oubliez pas que le résultat renvoyé par la méthode d'abonnement doit être enregistré. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectionDisposable = selectionManager.registerSelectionChangeListener { position, isSelected -&gt; notifyItemChanged(position) }</code> </pre> <br><p>  Je note que dans ce cas, la valeur du paramètre <code>isSelected</code> pas importante, car avec tout changement, l'apparence de l'élément change.  Mais rien ne vous empêche d'ajouter des traitements supplémentaires, pour lesquels cette valeur est importante. </p><br><h4 id="3-selectiondisposable"> <code>3. selectionDisposable</code> </h4> <br><p>  À l'étape précédente, je n'ai pas simplement dit que le résultat de la méthode doit être enregistré - un objet est renvoyé qui efface l'abonnement pour éviter les fuites.  Après avoir terminé les travaux, cet objet doit être consulté. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { selectionDisposable.dispose() }</code> </pre> <br><h2 id="viewmodel">  ViewModel </h2><br><p>  Pour que l'adaptateur de magie soit suffisant, nous allons passer à <code>ViewModel</code> .  L'initialisation de <code>SelectionManager</code> extrêmement simple: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestViewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectionManager: SelectionManager = SingleSelection() }</code> </pre> <br><p>  Ici, par analogie avec l'adaptateur, vous pouvez vous abonner aux modifications (par exemple, pour rendre le bouton "Supprimer" inaccessible quand aucun élément n'est sélectionné), mais vous pouvez également cliquer sur un bouton de résumé (par exemple, "Télécharger la sélection") pour obtenir une liste de tous les éléments sélectionnés . </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDownloadClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedPositions: ArrayList&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; = selectionManager.getSelectedPositions() ... }</code> </pre> <br><p>  Et ici, l'un des inconvénients de ma solution apparaît: au stade actuel, l'objet ne peut stocker que les positions des éléments.  Autrement dit, afin d'obtenir exactement les objets sélectionnés, et non leurs positions, une logique supplémentaire sera requise en utilisant la source de données connectée à l'adaptateur (hélas, jusqu'à présent uniquement).  Mais j'espère que vous pourrez y faire face. </p><br><p>  De plus, il ne reste plus qu'à connecter l'adaptateur au modèle de vue.  C'est déjà au niveau de l'activité. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> adapter: TestAdapter <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewModel: TestViewModel <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//`TestViewModel` initialization adapter = TestAdapter(viewModel.selectionManager) } }</span></span></code> </pre> <br><h2 id="gibkost">  Flexibilité </h2><br><p>  Pour certains, cela peut être tout à fait compréhensible, mais je tiens également à noter qu'avec cette implémentation, il s'avère facile de contrôler la méthode de sélection dans les adaptateurs.  L'adaptateur ne peut désormais sélectionner qu'un seul élément, mais si <code>TestViewModel</code> modifiez l'initialisation de la propriété <code>selectionManager</code> dans <code>TestViewModel</code> , le reste du code fonctionnera «d'une nouvelle manière» sans nécessiter aucune modification.  Autrement dit, définissez <code>val selectionManager: SelectionManager = MultipleSelection()</code> , et maintenant l'adaptateur vous permet de sélectionner autant d'éléments que vous le souhaitez. </p><br><p>  Et si vous avez une sorte de classe d'adaptateur de base pour toute l'application, vous ne pouvez pas avoir peur d'inclure le <code>SelectionManager</code> de la même manière.  En effet, en particulier pour les adaptateurs qui n'impliquent aucun choix d'éléments, il existe une implémentation de <code>NoneSelection</code> - peu importe ce que vous en faites, il n'aura jamais les éléments sélectionnés et n'appellera jamais aucun des écouteurs.  Non, il ne lève pas d'exceptions - il ignore simplement tous les appels, mais l'adaptateur n'a pas besoin de le savoir du tout. </p><br><h2 id="interceptor">  Intercepteur </h2><br><p>  Il existe également des cas dans lesquels une modification de la sélection d'un élément s'accompagne d'opérations supplémentaires (par exemple, chargement d'informations détaillées), avant la réussite de laquelle l'application des modifications conduit à un état incorrect.  Surtout pour ces cas, j'ai ajouté un mécanisme d'interception. </p><br><p>  Pour ajouter un intercepteur, vous devez appeler la méthode <code>addSelectionInterceptor</code> (encore une fois, vous devez enregistrer le résultat et y accéder une fois terminé).  L'un des paramètres de l'intercepteur dans l'exemple de <code>callback: () -&gt; Unit</code> - jusqu'à ce qu'il soit appelé, les modifications ne seront pas appliquées.  Autrement dit, en l'absence de réseau, le chargement d'informations détaillées à partir du serveur ne pourra pas se terminer avec succès, en conséquence, l'état du <code>selectionManager</code> utilisé ne changera pas.  Si c'est exactement le comportement que vous recherchez - vous avez besoin de cette méthode. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> interceptionDisposable = selectionManager.addSelectionInterceptor { position: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, isSelected: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, callback: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isSelected) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedItem = ... <span class="hljs-comment"><span class="hljs-comment">//get current item by `position` value val isDataLoadingSuccessful: Boolean = ... //download data for `selectedItem` if(isDataLoadingSuccessful) { callback() } } }</span></span></code> </pre> <br><p>  Si nécessaire, vous pouvez connecter autant d'intercepteurs que vous le souhaitez.  Dans ce cas, l'appel <code>callback()</code> du premier intercepteur commence à traiter le second.  Et seul <code>callback()</code> dans le dernier d'entre eux provoquera finalement un changement dans l'état <code>selectionManager</code> . </p><br><h2 id="perspektivy">  Perspectives </h2><br><ol><li>  L'utilisation de <code>Disposable</code> pour effacer les abonnements est efficace, mais pas aussi pratique que <code>LiveData</code> .  La première amélioration de la gamme consiste à utiliser les capacités de <code>android.arch.lifecycle</code> pour un travail plus pratique.  Il s'agit très probablement d'un projet distinct, afin de ne pas ajouter de dépendance de plateforme au projet actuel. </li><li>  Comme je l'ai dit, obtenir une liste d'objets sélectionnés s'est avéré peu pratique.  Je veux également essayer d'implémenter un objet qui peut fonctionner avec un conteneur de données de la même manière.  Dans le même temps, il peut s'agir d'une source de données pour l'adaptateur. </li></ol><br><h2 id="ssylki">  Les références </h2><br><p>  Vous pouvez trouver les codes source sur le lien - <a href="https://github.com/Ircover/SelectionManager">GitHub</a> <br>  Le projet peut également être implémenté via gradle - <code>ru.ircover.selectionmanager:core:1.0.0</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483552/">https://habr.com/ru/post/fr483552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483538/index.html">Connexion d'un écran 10 "ER-TFT101-1 au STM32F429 via FMC</a></li>
<li><a href="../fr483540/index.html">ChaiScript - langage de script pour C ++</a></li>
<li><a href="../fr483542/index.html">Telecom digest - documents sur le travail des fournisseurs</a></li>
<li><a href="../fr483544/index.html">De nouvelles données réfutent l'hypothèse clé de l'énergie sombre</a></li>
<li><a href="../fr483550/index.html">Développement de services et IaaS: une compilation du cloud, du stockage de données et de 1cloud Evolution</a></li>
<li><a href="../fr483554/index.html">Nouvelle plateforme technologique des années 20. Pourquoi je ne suis pas d'accord avec Zuckerberg</a></li>
<li><a href="../fr483556/index.html">Rapport Bank of America: 5 tendances qui changeront l'économie mondiale au cours des dix prochaines années</a></li>
<li><a href="../fr483558/index.html">Bibliothèque JavaScript Webix vue par un débutant</a></li>
<li><a href="../fr483564/index.html">Copywriting in IT: comment commencer à écrire sur la technologie</a></li>
<li><a href="../fr483568/index.html">Créer un ordinateur primitif à partir de zéro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>