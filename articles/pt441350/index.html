<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üç° ‚õ∑Ô∏è Haskell √© realmente a linguagem dos g√™nios e da academia? ‚úùÔ∏è ‚ÜôÔ∏è üèä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Certa vez, tive uma discuss√£o com o fundador de uma startup israelense desenvolvendo um banco de dados baseado em GPU com foco na velocidade. A pilha ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell √© realmente a linguagem dos g√™nios e da academia?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441350/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  Certa vez, tive uma discuss√£o com o fundador de uma startup israelense desenvolvendo um banco de dados baseado em GPU com foco na velocidade.  A pilha de trabalho inclu√≠a Haskell e C ++, entre outros, e o fundador estava reclamando da dificuldade de encontrar programadores competentes.  O que era parte da raz√£o pela qual ele veio a Moscou. <br><br>  Perguntei cuidadosamente se eles consideravam usar algo mais popular e novo.  E mesmo que a resposta tenha sido bastante educada e bem fundamentada em argumentos, ainda parecia "Vamos l√°, nem traga esses brinquedos". <br><br>  At√© ent√£o, tudo o que ouvi sobre Haskell poderia ser resumido como "tenha MUITO cuidado ao lidar com isso".  Para conhecer melhor os programadores da Haskell, eu vim para um bate-papo t√≥pico do Telegram com algumas perguntas.  No come√ßo, fiquei com muito medo e, como se viu, estava certa. <br><br>  Haskell n√£o se presta a explica√ß√µes populares, e as pessoas aparentemente nem tentam.  Se o t√≥pico for abordado, √© discutido apenas em profundidade e da maneira mais objetiva poss√≠vel.  Algu√©m escreveu para mim: ‚ÄúUma das caracter√≠sticas definidoras do pr√≥prio Haskell e de sua comunidade √© que eles n√£o tentaram alcan√ßar nenhum tipo de reconhecimento convencional.  Em vez disso, eles se concentraram em criar uma maneira l√≥gica e principal de resolver problemas reais, tentando satisfazer o maior p√∫blico poss√≠vel ‚Äù <br><br>  No entanto, algumas pessoas me contaram sobre suas experi√™ncias, que s√£o mostradas abaixo. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">nolane</a> )</b> : Quando eu estava na faculdade, eles me ofereceram para fazer um curso de Coursera em Haskell por cr√©dito extra.  Tamb√©m tivemos um curso de programa√ß√£o funcional que inclu√≠a Haskell.  Eu escrevi um dos meus trabalhos, mais o trabalho de gradua√ß√£o, no GHC.  Ent√£o eu encontrei um emprego como programador Haskell. <br><br>  Foi, e ainda √©, dif√≠cil.  Quando voc√™ come√ßa a aprender Haskell, precisa inserir muitos conceitos novos em sua mente.  √â como aprender a codificar do zero novamente. <br><br>  As pessoas tendem a esquecer (ou suavizar) suas mem√≥rias anteriores: como quando estavam lutando para entender o que era um "ponteiro", "fun√ß√£o" ou "classe".  Talvez seja por isso que √© t√£o dif√≠cil para eles aprenderem Haskell: fica mais dif√≠cil aprender coisas novas com a idade. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Uma vez que eu falhei no meu per√≠odo de teste em um emprego por causa de uma foda no Redux, tentei me sentir um pouco mais confort√°vel assistindo v√≠deos do criador.  Primeiro pratiquei em JavaScript, mas depois aprendi sobre Haskell, considerado a linguagem funcional "verdadeira".  Fiquei fascinado por seus conceitos √∫nicos e como era legal. <br><br>  Os tutoriais n√£o s√£o muito f√°ceis de usar, por√©m, al√©m de seu hist√≥rico imperativo, impede que novos conceitos surjam. <br><br>  <b>Yuri Syrovetskiy ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">cblp</a> )</b> : o mais dif√≠cil √© aprender Haskell como sua segunda l√≠ngua, quando as lembran√ßas de aprender a primeira ainda est√£o frescas, <br><br><h2>  O que Haskell √© bom e ruim? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : √â conciso, elegante e flex√≠vel.  N√£o √© √† toa que metade das bibliotecas existem no EDSL (ou pelo menos parece). <br><br>  <b>Yuri Syrovetskiy</b> : √â (subjetivamente) f√°cil adaptar seus pensamentos ao c√≥digo, possui um grande equil√≠brio de paradigmas imperativos e funcionais.  Construir abstra√ß√µes de dados e algoritmos √© bastante simples, o que permite pensar na tarefa em quest√£o sem se distrair demais com pequenos aborrecimentos. <br><br>  <b>John Doe</b> : Tipifica√ß√£o rigorosa e forte (at√© mesmo fascista). <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">interphx</a> )</b> : Um √≥timo sistema de tipos.  N√£o √© t√£o poderoso quanto em Idris ou Agda, mas ainda atinge o ponto intermedi√°rio conveniente, onde voc√™ pode descrever quase tudo, e ainda assim a infer√™ncia de tipos funciona bem.  Voc√™ n√£o precisa marc√°-los manualmente todas as vezes. <br><br>  Mas um sistema de tipos poderoso obriga a prestar mais aten√ß√£o aos valores transmitidos.  Um monte de defini√ß√µes de tipo pode parecer um clich√™.  Cada comando tem seu pr√≥prio conjunto de extens√µes ou n√£o os possui.  O c√≥digo √© "mais denso" - cada string geralmente carrega mais informa√ß√µes do que em outros idiomas, portanto, √© mais dif√≠cil ler para um desenvolvedor inexperiente. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Ao aprender Haskell, voc√™ provavelmente encontrar√° este ditado: "Se compilar, provavelmente estar√° correto".  Nulo n√£o existe, o pr√≥prio paradigma funcional √© muito rigoroso e mant√©m voc√™ dentro de certas diretrizes, que na maioria dos casos levam a um melhor design. <br><br>  Por exemplo, Haskell n√£o tem vari√°veis ‚Äã‚Äã- apenas constantes.  Voc√™ n√£o precisa acompanhar o que est√° atribu√≠do a onde.  Haskell incentiva o uso de fun√ß√µes "puras", que n√£o t√™m efeitos colaterais.  O design funcional for√ßa o programa a funcionar como um todo, em oposi√ß√£o √†s linguagens orientadas a objetos, onde muitos objetos tentam se comunicar usando esses efeitos colaterais, transformando o aplicativo em uma bagun√ßa imprevis√≠vel.  Sofremos muito isso no C # e no Unity no trabalho. <br><br>  <b>Denis Mirzoev</b> : Quando o idioma √© naturalmente "pregui√ßoso", geralmente √© mais expressivo.  Os algoritmos ficam mais simples.  Se resultados intermedi√°rios n√£o forem usados, aumentar√° bastante o desempenho. <br><br>  <b>Igor Shevnin</b> : A ‚Äúpregui√ßa‚Äù geralmente ajuda, mas quando a ordem das chamadas de fun√ß√£o √© importante, √†s vezes √© realmente dif√≠cil entender o que est√° acontecendo. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Se estiver em conformidade, provavelmente √© muito r√°pido. <br><br>  <b>Denis Mirzoev</b> : Em termos de desempenho, √© compar√°vel ao Java, mas n√£o t√£o r√°pido quanto o C. <br><br>  <b>Igor Shevnin</b> : Possui suporte de extens√£o <b>pronto</b> para uso, o que permite adaptar o idioma e o sistema de tipos ao seu gosto.  Existem muitas extens√µes amplamente usadas pela comunidade e com amostras e documenta√ß√£o decentes. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : A biblioteca Prelude padr√£o tem muitas fun√ß√µes ruins, como read, head, readFile, que podem lan√ßar uma exce√ß√£o e travar o aplicativo em vez de retornar Maybe.  Ent√£o eu tenho que usar alternativas ou escrever as minhas. <br><br>  <b>Igor Shevnin</b> : o maior problema √© a falta de padr√µes, a ponto de muitas pessoas substituirem a biblioteca padr√£o por uma das alternativas, que n√£o s√£o de forma alguma compat√≠veis entre si.  A divis√£o da comunidade sobre o que deveria ser a biblioteca padr√£o, o que deve ser inclu√≠do na distribui√ß√£o principal e o que pode ser descarregado para as extens√µes ... Na minha opini√£o, isso impede o desenvolvimento da linguagem. <br><br>  <b>Denis Mirzoev</b> : Faltam ferramentas: n√£o h√° um IDE adequado, muito poucos benchmarks de desempenho, nenhuma depura√ß√£o "passo a passo" - √© uma quest√£o fundamental. <br><br><h2>  Para quais projetos o Haskell √© mais adequado? </h2><br>  <b>YS</b> : Para tarefas complexas, relacionadas √† seguran√ßa e finan√ßas, onde os erros s√£o caros. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Para tudo onde voc√™ precisa calcular, converter e analisar.  Estou surpreso que Haskell seja menos popular em aplicativos de ci√™ncia de dados do que Python. <br><br>  <b>IS</b> : Eu n√£o arriscaria us√°-lo para sistemas embarcados (√© r√°pido, mas ainda h√° sobrecarga significativa de mem√≥ria devido √† computa√ß√£o ‚Äúlenta‚Äù) ou pequenos scripts (onde sua natureza estrita n√£o √© necess√°ria).  Tamb√©m √© importante entender o qu√£o dif√≠cil √© encontrar desenvolvedores em compara√ß√£o com os idiomas comuns. <br><br>  <b>John Doe</b> : Para escrever c√≥digo industrial que ser√° lido por outras pessoas, voc√™ precisar√° de toda uma equipe de desenvolvedores da Haskell.  N√£o h√° muitos deles. <br><br>  <b>IS</b> : Mas, gra√ßas √† natureza concisa e estrita, voc√™ pode usar Haskell para quase tudo. <br><br><h2>  √â uma boa id√©ia come√ßar sua carreira de desenvolvimento na Haskell? </h2><br>  <b>IS</b> : Provavelmente n√£o, porque a grande maioria das bases de c√≥digo com as quais um desenvolvedor precisa trabalhar n√£o est√° escrita nela. <br><br>  <b>John Doe</b> : M√° ideia!  Idiomas n√£o-ML - que s√£o quase tudo em aplica√ß√µes industriais - seriam um choque para voc√™. <br><br>  <b>DS</b> : Muitas vezes as pessoas aprendem matem√°tica primeiro e mudam para a programa√ß√£o mais tarde.  Ent√£o, teoricamente, aprender uma linguagem que requer muitos conceitos de matem√°tica (tipos de dados alg√©bricos, fun√ß√µes puras) deve ser mais f√°cil do que linguagens imperativas.  Eu acho que √© uma boa ideia. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Todos os desenvolvedores novatos com quem trabalho, apresento Haskell primeiro.  As pessoas que n√£o t√™m a bagagem do estilo imperativo s√£o muito mais r√°pidas para aprender c√≥digo funcional e, mesmo depois de trabalharem com linguagens orientadas a objetos, tendem a utilizar boas solu√ß√µes de arquitetura porque est√£o acostumadas. <br><br>  <b>YS</b> : √â melhor come√ßar com algumas linguagens fundamentalmente diferentes, como C, Haskell e Smalltalk, em qualquer ordem.  Nenhum idioma poderia lhe dar um entendimento completo da paisagem. <br><br><h2>  Haskell √© uma linguagem bastante antiga.  Isso √© bom ou ruim? </h2><br>  <b>YS</b> : A linguagem √© desenvolvida muito ativamente, e n√£o leva em considera√ß√£o o peso da compatibilidade com vers√µes anteriores. <br><br>  <b>John Doe</b> : foi padronizado em 1998, mas voc√™ n√£o notaria: at√© hoje, aproximadamente a cada 6 meses, h√° uma nova vers√£o do compilador que pode potencialmente quebrar a compatibilidade com vers√µes anteriores. <br><br>  <b>DS</b> : Haskell n√£o √© velho, √© simplesmente experimentado e testado.  N√£o (e nunca) introduzir√° mudan√ßas irracionais.  Portanto, provavelmente √© bom para a sa√∫de da comunidade. <br><br><h2>  Costuma-se dizer que Haskell √© uma das l√≠nguas mais dif√≠ceis de aprender.  √â mesmo? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Como uma linguagem em si - n√£o.  A parte mais dif√≠cil s√£o as abstra√ß√µes que ele usa.  Uma pessoa que nunca viu um c√≥digo Haskell antes pode enlouquecer com a quantidade de novas informa√ß√µes e instru√ß√µes estranhas.  O que n√£o ajuda √© que a linguagem "restringe" muitas coisas que n√£o se encaixam no seu conceito funcional. <br><br>  <b>John Doe</b> : Levei dois meses de livros, manuais e tutoriais para dormir antes de compilar meu primeiro projeto.  Pensamentos, uma vez que finalmente foi compilado, funcionou imediatamente a plena carga (m√©dia de 6k RPS, com 15k picos) por meio ano, sem altera√ß√µes. <br><br>  <b>DS</b> : Eu apostaria que, se voc√™ der um estudante universit√°rio Haskell como primeira l√≠ngua e ele for muito longe, a programa√ß√£o imperativa pareceria complicada e menos intuitiva para ele. <br><br>  <b>IS</b> : √â tudo relativo.  Fora das linguagens convencionais, considero o C ++ o mais dif√≠cil.  Linguagens que comprovam teoremas (como Agda ou Coq) s√£o mais dif√≠ceis do que Haskell conceitualmente.  Haskell n√£o √© uma linguagem dif√≠cil, mas leva tempo para aprender seu padr√£o e bibliotecas (padr√£o e de terceiros). <br><br><h2>  Sua complexidade √© justificada? </h2><br>  <b>IS</b> : Padr√µes e um alto n√≠vel de abstra√ß√£o s√£o justificados, pois tornam o c√≥digo mais curto e mais dur√°vel.  Mas acho que operadores, nomes de fun√ß√µes e muitas outras coisas poderiam ter sido um pouco mais amig√°veis ‚Äã‚Äãao usu√°rio. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Muitas vezes, a complexidade de Haskell permite criar solu√ß√µes muito curtas, flex√≠veis e modulares. <br><br>  <b>YS</b> : Eu diria que apenas o controle de efeitos √© um pouco inst√°vel, embora ainda seja quase sempre prefer√≠vel a nenhum controle.  E h√° um projeto em andamento para simplific√°-lo. <br><br>  <b>John Doe</b> : Para pessoas acostumadas a Python / PHP / qualquer outra coisa, Haskell se sente desalojado da realidade.  Para aqueles que voc√™ ainda n√£o estava interessado na teoria das categorias, √© muito dif√≠cil aprender do zero.  Mas quando voc√™ o entende, encontra uma nova abordagem para resolver um problema. <br><br><h2>  Costuma-se dizer que Haskell n√£o √© uma linguagem para desenvolvedores, mas para matem√°ticos.  √â por isso que n√£o √© popular? </h2><br>  <b>DS</b> : Mostra a principal id√©ia dos principais desenvolvedores de Haskell - "evite o sucesso a todo custo".  N√£o significa "evitar o sucesso", mas "evitar um sucesso muito caro". <br><br>  Eles poderiam ter feito Haskell popular.  Por exemplo, a Microsoft suporta o idioma.  Eles poderiam ter tornado mais imperativo, sacrificar a rigidez pela popularidade.  H√° muitos truques sujos que eles poderiam ter usado, mas nunca usaram. <br><br>  Claro, o idioma n√£o √© popular, mas isso significa que a qualidade n√£o sofre.  As vantagens de Haskell em compara√ß√£o com as linguagens imperativas s√£o √≥bvias para mim e todos os seus problemas podem ser resolvidos, ent√£o acredito que se popularizar√° mais tarde. <br><br>  <b>YS</b> : Apenas pessoas que n√£o sabem nada sobre isso dizem isso.  Haskell √© muito usado no desenvolvimento do "mundo real"; provavelmente voc√™ pode encontrar exemplos em seu mecanismo de pesquisa favorito.  Em particular, n√≥s da Kaspersky Labs estamos muito felizes com a Haskell e n√£o a trocamos por mais nada. <br><br>  <b>IS</b> : O que √© uma "linguagem do matem√°tico"?  √â o R / MatLab / Mathematica criado especificamente para estat√≠sticas e c√°lculos, ou Python, porque √© mais simples e n√£o requer tanto conhecimento de engenharia.  Mas n√£o Haskell.  Tem coisas de √°lgebra, como mon√≥ides, mas tem aplica√ß√£o pr√°tica. <br><br>  A raz√£o pela qual C / C ++ / Java √© t√£o popular √© porque eles historicamente t√™m sido muito difundidos no espa√ßo corporativo.  Eles encheram um nicho.  Atualmente, por√©m, muitas empresas come√ßam a usar o Haskell e outras linguagens funcionais. <br><br><h2>  Com qual PL voc√™ compararia Haskell? </h2><br>  <b>John Doe</b> : fora dos populares, provavelmente com Erlang.  Mas Erlang √© mais simples de aprender e escrever. <br><br>  <b>DS</b> : Conhe√ßo C, C ++, Java e Haskell.  C ++ √© horr√≠vel e n√£o pode ser comparado a nada.  C √© √≥timo para desenvolvimento de baixo n√≠vel.  Em todas as outras aplica√ß√µes, eu prefiro Haskell. <br><br>  Escolher entre Java e Haskell √© mais dif√≠cil, mas depende do aplicativo.  Por exemplo, Java √© melhor para Android, mas em aplicativos de servidor eles s√£o quase iguais.  Se o ambiente - ferramentas, bibliotecas - permitir, eu geralmente escolho Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Eu comparo com C #.  Apenas o Google "como fazer Talvez em C # e Haskell".  √â estranho que uma linguagem estritamente funcional como Haskell pare√ßa muito mais flex√≠vel e livre.  Mas, na realidade, eles s√£o os opostos polares. <br><br>  C # √© uma das linguagens mais orientadas a objetos e suas vantagens contrastam com Haskell.  O C # sempre obriga a escrever muitas coisas extras, o que torna o c√≥digo mais lento e geralmente o torna menos elegante.  Ap√≥s as solu√ß√µes curtas e organizadas de Haskell, √© dif√≠cil voltar. <br><br>  <b>IS</b> : Com Rust, e at√© agora Rust provavelmente vence.  √â preciso muito do Haskell e de outras linguagens funcionais, mas combina abordagens funcionais e imperativas, al√©m de os desenvolvedores terem lidado com seu desenvolvimento de maneira muito mais inteligente. <br><br><h2>  Qual a sua opini√£o sobre a comunidade Haskell? </h2><br>  <b>John Doe</b> : A grande maioria das pessoas √© muito amig√°vel e pronta para ajudar, o que √© um bom contraste com muitas outras l√≠nguas. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : As comunidades Haskell geralmente est√£o cheias de pessoas terrivelmente inteligentes.  Os memes locais sobre PhDs e academia existem por uma raz√£o.  Em outras comunidades, as pessoas discutem principalmente problemas regulares de produ√ß√£o e estruturas de dados, enquanto em um bate-papo de Haskell as pessoas discutem m√¥nadas, functores aplicativos, tipos malucos e coisas assim. <br><br>  Voc√™ sempre aprende algo que nunca pensou antes. <br><br><h2>  Dizem que os desenvolvedores da Haskell s√£o muito cheios de si mesmos.  √â verdade? </h2><br>  <b>DS</b> : Sim.  Eu sinto que √© porque eles realmente gostam da sua l√≠ngua e est√£o desapontados com o qu√£o impopular ela √©. <br><br>  <b>John Doe</b> : Nada disso. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : As pessoas provavelmente dizem isso porque muitos desenvolvedores convencionais se irritam com um haskellist e come√ßam a falar sobre programa√ß√£o funcional e suas vantagens.  O Haskellist, enquanto isso, fica irritado porque ningu√©m o ouve e come√ßa a usar a terminologia, e assim √© rotulado como "cheio de si". <br><br>  <b>IS</b> : √â um pouco duro cham√°-los assim.  Provavelmente porque a programa√ß√£o funcional, OOP, diferen√ßas entre classes e tipos de uni√£o OOP, o problema de extens√£o e muitas outras defini√ß√µes se desenvolvem lentamente em uma imagem coerente, e ent√£o √© dif√≠cil entender as pessoas que continuam as guerras sagradas entre OOP e FP. <br><br><h2>  Por que as linguagens FP s√£o t√£o espec√≠ficas? </h2><br>  <b>DS</b> : Suas vantagens n√£o s√£o suficientes para interessar aos programadores.  Ser dif√≠cil de aprender tamb√©m n√£o ajuda.  As quest√µes de ferramentas tamb√©m assustam as pessoas, mesmo que esse problema provavelmente fosse resolvido se mais pessoas estivessem interessadas.  √â um ciclo vicioso. <br><br>  <b>IS</b> : Bem, os conceitos de FP abrem caminho lentamente para outras l√≠nguas ... <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Doctor_Ryner</a></b> : Os princ√≠pios fundamentais do FP e suas l√≠nguas j√° s√£o bastante difundidos.  At√© a Sharp possui o Linq e algumas outras bibliotecas semelhantes.  Mas linguagens puramente funcionais provavelmente t√™m apenas muitos conceitos novos para serem populares. <br><br>  N√£o se esque√ßa que, h√° 20 anos, o hardware ainda n√£o era r√°pido o suficiente para lidar com linguagens funcionais; portanto, ele entrou no mainstream recentemente e o pr√≥prio Haskell est√° crescendo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441350/">https://habr.com/ru/post/pt441350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441338/index.html">Como criamos um sistema de pagamento em criptomoeda: cinco problemas principais</a></li>
<li><a href="../pt441340/index.html">A heran√ßa cultural do Cazaquist√£o em modelos 3D</a></li>
<li><a href="../pt441344/index.html">Entre no c√©u. Uma hist√≥ria honesta sobre uma paix√£o s√©ria pelo paraquedismo</a></li>
<li><a href="../pt441346/index.html">Conhe√ßa um estrategista de conte√∫do: uma entrevista com Dmitry Kabanov, curador do Techstars Startup Digest e consultor SXSW</a></li>
<li><a href="../pt441348/index.html">Roteamento direto e balanceamento com NFT vs Nginx</a></li>
<li><a href="../pt441352/index.html">Padr√µes e anti-padr√µes de CI / CD. Parte 2</a></li>
<li><a href="../pt441356/index.html">Como entender o c√≥digo "estrangeiro" e ingressar em uma nova equipe?</a></li>
<li><a href="../pt441358/index.html">Lan√ßou o primeiro lander lunar comercial da Beresheet</a></li>
<li><a href="../pt441360/index.html">Openshift - artesanato com chap√©u vermelho</a></li>
<li><a href="../pt441362/index.html">Guia do Usu√°rio Kibana. Visualiza√ß√£o. Parte 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>