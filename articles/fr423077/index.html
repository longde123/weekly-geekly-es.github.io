<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∑ ü§õüèø üìã Guide de l'assembleur X86 pour les d√©butants üå¥ üë©üèΩ‚Äçüî¨ üõ§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nos jours, il est rarement n√©cessaire d'√©crire en pur assembleur, mais je le recommande d√©finitivement √† toute personne int√©ress√©e par la programma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide de l'assembleur X86 pour les d√©butants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423077/"> De nos jours, il est rarement n√©cessaire d'√©crire en pur assembleur, mais je le recommande d√©finitivement √† toute personne int√©ress√©e par la programmation.  Vous verrez les choses sous un angle diff√©rent et les comp√©tences vous seront utiles lors du d√©bogage de code dans d'autres langues. <br><br>  Dans cet article, nous allons √©crire √† partir de z√©ro une calculatrice <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RPN (Reverse Polish Notation)</a> en assembleur x86 pur.  Lorsque nous avons termin√©, nous pouvons l'utiliser comme ceci: <br><br><pre><code class="bash hljs">$ ./calc <span class="hljs-string"><span class="hljs-string">"32+6*"</span></span> <span class="hljs-comment"><span class="hljs-comment"># "(3+2)*6"    30</span></span></code> </pre> <br>  Tout le code de l'article est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Il est abondamment comment√© et peut servir de mat√©riel √©ducatif √† ceux qui connaissent d√©j√† l'assembleur. <br><br>  Commen√ßons par √©crire le programme de base <i>Hello world!</i>  pour v√©rifier les param√®tres d'environnement.  Passons ensuite aux appels syst√®me, √† la pile d'appels, aux cadres de pile et √† la convention d'appel x86.  Ensuite, pour la pratique, nous allons √©crire quelques fonctions de base dans l'assembleur x86 - et commencer √† √©crire une calculatrice RPN. <br><a name="habracut"></a><br>  On suppose que le lecteur a une certaine exp√©rience de programmation en C et une connaissance de base de l'architecture informatique (par exemple, qu'est-ce qu'un registre de processeur).  Puisque nous utiliserons Linux, vous devriez √©galement pouvoir utiliser la ligne de commande Linux. <br><br><h1>  Configuration de l'environnement </h1><br>  Comme d√©j√† mentionn√©, nous utilisons Linux (64 bits ou 32 bits).  Le code ci-dessus ne fonctionne pas sur Windows ou Mac OS X. <br><br>  Pour l'installation, vous n'avez besoin que de l'√©diteur de liens GNU <code>ld</code> de <code>binutils</code> , qui est pr√©install√© sur la plupart des distributions, et de l'assembleur NASM.  Sur Ubuntu et Debian, vous pouvez installer les deux avec une seule commande: <br><br><pre> <code class="bash hljs">$ sudo apt-get install binutils nasm</code> </pre> <br>  Je recommanderais √©galement de garder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une table ASCII √†</a> port√©e de main. <br><br><h1>  Bonjour tout le monde! </h1><br>  Pour v√©rifier l'environnement, enregistrez le code suivant dans le fichier <code>calc.asm</code> : <br><br><pre> <code class="hljs 1c">;   <span class="hljs-built_in"><span class="hljs-built_in"></span></span> _start     ; . global _start ;   .rodata  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> ( <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ) ;   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ,       section .rodata ;     hello_world.   NASM ;   ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  , ;  . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    hello_world: db <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 ;   .text,     section .text _start: mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>   eax (<span class="hljs-number"><span class="hljs-number">0</span></span>x04 = write()) mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span>x1 ;   (<span class="hljs-number"><span class="hljs-number">1</span></span> =  , <span class="hljs-number"><span class="hljs-number">2</span></span> =  ) mov ecx, hello_world ;     mov edx, <span class="hljs-number"><span class="hljs-number">14</span></span> ;   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>  <span class="hljs-number"><span class="hljs-number">0</span></span>x80,   ;     mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x01 ; <span class="hljs-number"><span class="hljs-number">0</span></span>x01 = exit() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80</code> </pre> <br>  Les commentaires expliquent la structure g√©n√©rale.  Pour une liste des registres et des instructions g√©n√©rales, consultez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide de l'assembleur x86 de</a> l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Universit√© de Virginie</a> .  Avec une discussion plus approfondie des appels syst√®me, cela sera d'autant plus n√©cessaire. <br><br>  Les commandes suivantes collectent le fichier assembleur dans un fichier objet, puis compilent le fichier ex√©cutable: <br><br><pre> <code class="bash hljs">$ nasm -f elf_i386 calc.asm -o calc $ ld -m elf_i386 calc.o -o calc</code> </pre> <br>  Apr√®s avoir commenc√©, vous devriez voir: <br><br><pre> <code class="bash hljs">$ ./calc Hello world!</code> </pre> <br><h3>  Makefile </h3><br>  C'est une partie facultative, mais vous pouvez cr√©er un <code>Makefile</code> pour simplifier la construction et la mise en page √† l'avenir.  Enregistrez-le dans le m√™me r√©pertoire que <code>calc.asm</code> : <br><br><pre> <code class="hljs powershell">CFLAGS= <span class="hljs-operator"><span class="hljs-operator">-f</span></span> elf32 LFLAGS= <span class="hljs-literal"><span class="hljs-literal">-m</span></span> elf_i386 all: calc calc: calc.o ld <span class="hljs-variable"><span class="hljs-variable">$</span></span>(LFLAGS) calc.o <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc calc.o: calc.asm nasm <span class="hljs-variable"><span class="hljs-variable">$</span></span>(CFLAGS) calc.asm <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc.o clean: rm <span class="hljs-operator"><span class="hljs-operator">-f</span></span> calc.o calc .INTERMEDIATE: calc.o</code> </pre> <br>  Ensuite, au lieu des instructions ci-dessus, lancez simplement make. <br><br><h1>  Appels syst√®me </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les appels syst√®me Linux</a> indiquent au syst√®me d'exploitation de faire quelque chose pour nous.  Dans cet article, nous utilisons uniquement deux appels syst√®me: <code>write()</code> pour √©crire une ligne dans un fichier ou un flux (dans notre cas, il s'agit d'un p√©riph√©rique de sortie standard et d'une erreur standard) et <code>exit()</code> pour quitter le programme: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error_code) error_code -  <span class="hljs-number"><span class="hljs-number">0</span></span>         (  <span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd, char *string, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>) fd ‚Äî  <span class="hljs-number"><span class="hljs-number">1</span></span>   , <span class="hljs-number"><span class="hljs-number">2</span></span>      string ‚Äî      <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> ‚Äî    </code> </pre> <br>  Les appels syst√®me sont configur√©s en stockant le num√©ro d'appel syst√®me dans le registre <code>eax</code> , puis ses arguments dans <code>ebx</code> , <code>ecx</code> , <code>edx</code> dans cet ordre.  Vous pouvez remarquer que <code>exit()</code> qu'un seul argument - dans ce cas, ecx et edx n'ont pas d'importance. <br><br><table><tbody><tr><th>  eax </th><th>  ebx </th><th>  ecx </th><th>  edx </th></tr><tr><td align="center">  Num√©ro d'appel syst√®me </td><td align="center">  arg1 </td><td align="center">  arg2 </td><td align="center">  arg3 </td></tr></tbody></table><br><br><h1>  Pile d'appels </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/2b0/574/ea2/2b0574ea20054a1e428d6f0518a80388.png"><br><br>  Une pile d'appels est une structure de donn√©es qui stocke des informations sur chaque appel √† une fonction.  Chaque appel a sa propre section dans la pile - le "cadre".  Il stocke quelques informations sur l'appel en cours: les variables locales de cette fonction et l'adresse de retour (o√π le programme doit aller apr√®s l'ex√©cution de la fonction). <br><br>  Imm√©diatement, je note une chose non √©vidente: la pile augmente <i>la</i> m√©moire.  Lorsque vous ajoutez quelque chose en haut de la pile, il est ins√©r√© √† une adresse m√©moire inf√©rieure √† l'√©l√©ment pr√©c√©dent.  En d'autres termes, √† mesure que la pile grandit, l'adresse m√©moire en haut de la pile diminue.  Pour √©viter toute confusion, je vous rappellerai toujours ce fait. <br><br>  L'instruction <code>push</code> quelque chose au-dessus de la pile, et <code>pop</code> sortir les donn√©es de l√†.  Par exemple, <code>push </code> alloue une place en haut de la pile et y place la valeur du registre <code>eax</code> , et <code>pop </code> transf√®re toutes les donn√©es du haut de la pile vers <code>eax</code> et lib√®re cette zone de m√©moire. <br><br>  Le but du registre <code>esp</code> est de pointer vers le haut de la pile.  Toute donn√©e au-dessus de <code>esp</code> consid√©r√©e comme n'atteignant pas la pile, il s'agit de donn√©es d'ordures.  L'ex√©cution d'une instruction <code>push</code> (ou <code>pop</code> ) d√©place <code>esp</code> .  Vous pouvez manipuler <code>esp</code> directement, si vous donnez un rapport sur vos actions. <br><br>  Le registre <code>ebp</code> est similaire √† <code>esp</code> , mais il pointe toujours approximativement vers le milieu de la trame de pile actuelle, juste avant les variables locales de la fonction courante (nous en parlerons plus tard).  Cependant, appeler une autre fonction ne d√©place pas automatiquement <code>ebp</code> , cela doit √™tre fait manuellement √† chaque fois. <br><br><h1>  Convention d'appel d'architecture X86 </h1><br>  Dans x86, il n'y a pas de concept de fonction int√©gr√© comme dans les langages de haut niveau.  L' <code>goto</code> <code>call</code> <code>goto</code> simplement <code>jmp</code> ( <code>goto</code> ) vers une autre adresse m√©moire.  Pour utiliser des routines comme fonctions dans d'autres langages (qui peuvent prendre des arguments et renvoyer des donn√©es), vous devez suivre la convention d'appel (il existe de nombreuses conventions, mais nous utilisons CDECL, la convention la plus populaire pour x86 parmi les compilateurs C et les programmeurs assembleurs).  Il garantit √©galement que les registres de routine ne sont pas confondus lors de l'appel d'une autre fonction. <br><br><h3>  R√®gles d'appelant </h3><br>  Avant d'appeler la fonction, l'appelant doit: <br><br><ol><li>  Enregistrez les registres que l'appelant doit enregistrer sur la pile.  La fonction appel√©e peut changer certains registres: pour ne pas perdre de donn√©es, l'appelant doit les sauvegarder en m√©moire jusqu'√† ce qu'elles soient pouss√©es sur la pile.  Ce sont les <code>edx</code> <code>eax</code> , <code>ecx</code> et <code>edx</code> .  Si vous n'en utilisez aucun, vous ne pouvez pas les enregistrer. </li><li>  √âcrivez les arguments de la fonction dans la pile dans l'ordre inverse (premier dernier argument, premier premier argument √† la fin).  Cet ordre garantit que la fonction appel√©e re√ßoit ses arguments de la pile dans le bon ordre. </li><li>  Appelez le sous-programme. </li></ol><br>  Si possible, la fonction enregistrera le r√©sultat dans <code>eax</code> .  Imm√©diatement apr√®s l' <code>call</code> appelant doit: <br><br><ol><li>  Supprimez les arguments de fonction de la pile.  Cela se fait g√©n√©ralement en ajoutant simplement le nombre d'octets √† <code>esp</code> .  N'oubliez pas que la pile grandit, donc pour la retirer de la pile, vous devez ajouter des octets. </li><li>  Restaurez les registres enregistr√©s en les sortant de la pile dans l'ordre inverse.  La fonction appel√©e ne changera aucun autre registre. </li></ol><br>  L'exemple suivant montre comment ces r√®gles s'appliquent.  Supposons que la fonction <code>_subtract</code> deux arguments entiers (4 octets) et renvoie le premier argument moins le second.  Dans la sous <code>_mysubroutine</code> routine <code>_mysubroutine</code> appelez <code>_subtract</code> avec les arguments <code>10</code> et <code>2</code> : <br><br><pre> <code class="hljs perl">_mysubroutine: ; ... ;  -  ; ... <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;   (    eax) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ;  ,      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> call _subtract ; eax   <span class="hljs-number"><span class="hljs-number">10</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>=<span class="hljs-number"><span class="hljs-number">8</span></span> add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> ;  <span class="hljs-number"><span class="hljs-number">8</span></span>    (   <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;    <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; ... ;  - ,        eax ; ...</code> </pre> <br><h3>  R√®gles de la routine appel√©e </h3><br>  Avant d'appeler, le sous-programme doit: <br><br><ol><li>  Enregistrez le pointeur de registre de base <code>ebp</code> de la trame pr√©c√©dente en l'√©crivant dans la pile. </li><li>  Ajustez <code>ebp</code> de l'image pr√©c√©dente au courant (valeur <code>esp</code> actuelle). </li><li>  Allouez plus d'espace sur la pile pour les variables locales, si n√©cessaire, d√©placez le pointeur <code>esp</code> .  Au fur et √† mesure que la pile se d√©veloppe, vous devez soustraire la m√©moire manquante de <code>esp</code> . </li><li>  Sauvegardez les registres de la routine appel√©e sur la pile.  Ce sont <code>ebx</code> , <code>edi</code> et <code>esi</code> .  Il n'est pas n√©cessaire de sauvegarder des registres dont la modification n'est pas pr√©vue. </li></ol><br>  Pile d'appels apr√®s l'√©tape 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d15/55e/4c4/d1555e4c4d0851f1f8ddec2b527e4877.png"><br><br>  La pile d'appels apr√®s l'√©tape 2: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/e1a/9bc/2bae1a9bc4aff273c6badbd5ec94d2c8.png"><br><br>  Pile d'appels apr√®s l'√©tape 4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c4/4bf/a7b/8c44bfa7bfb67546110925a9606e27cd.png"><br><br>  Dans ces diagrammes, une adresse de retour est indiqu√©e dans chaque trame de pile.  Il est automatiquement pouss√© sur la pile par une instruction d' <code>call</code> .  L' <code>ret</code> r√©cup√®re l'adresse du haut de la pile et y saute.  Nous n'avons pas besoin de cette instruction, je viens de montrer pourquoi les variables locales de la fonction sont 4 octets au-dessus d' <code>ebp</code> , mais les arguments de la fonction sont 8 octets au-dessous d' <code>ebp</code> . <br><br>  Dans le dernier diagramme, vous pouvez √©galement remarquer que les variables locales de la fonction commencent toujours 4 octets au-dessus de <code>ebp</code> partir de l'adresse <code>ebp-4</code> (soustraction ici, car nous <code>ebp-4</code> la pile), et les arguments de la fonction commencent toujours 8 octets sous <code>ebp</code> partir de l'adresse <code>ebp+8</code> (addition, car nous descendons la pile).  Si vous suivez les r√®gles de cette convention, il en sera de m√™me pour les variables et les arguments de n'importe quelle fonction. <br><br>  Lorsque la fonction est termin√©e et que vous souhaitez revenir, vous devez d'abord d√©finir <code>eax</code> sur la valeur de retour de la fonction, si n√©cessaire.  De plus, vous avez besoin de: <br><br><ol><li>  Restaurez les registres enregistr√©s en les sortant de la pile dans l'ordre inverse. </li><li>  Lib√©rez de l'espace sur la pile allou√©e par la variable locale √† l'√©tape 3, si n√©cessaire: en installant simplement <code>esp</code> dans ebp </li><li>  Restaurez le pointeur de base <code>ebp</code> de l'image pr√©c√©dente en le <code>ebp</code> de la pile. </li><li>  Retour avec <code>ret</code> </li></ol><br>  Maintenant, nous impl√©mentons la fonction <code>_subtract</code> de notre exemple: <br><br><pre> <code class="hljs perl">_subtract: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp ;      mov ebp, esp ;  ebp ;          ,      ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>   ;  ;   , eax     ;     ,     ;       ,       <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp ;      ret</code> </pre> <br><h3>  Entr√©e et sortie </h3><br>  Dans l'exemple ci-dessus, vous pouvez remarquer que la fonction s'ex√©cute toujours de la m√™me mani√®re: <code>push ebp</code> , <code>mov ebp</code> , <code>esp</code> et allocation de m√©moire pour les variables locales.  L'ensemble x86 a une instruction pratique qui fait tout cela: <code>enter ab</code> , o√π <code>a</code> est le nombre d'octets que vous souhaitez allouer aux variables locales, <code>b</code> est le "niveau d'imbrication", que nous allons toujours mettre √† <code>0</code> .  De plus, la fonction se termine toujours par les instructions <code>pop ebp</code> et <code>mov esp</code> , <code>ebp</code> (bien qu'elles ne soient n√©cessaires que lors de l'allocation de m√©moire aux variables locales, mais en tout cas ne font pas de mal).  Cela peut √©galement √™tre remplac√© par une seule d√©claration: <code>leave</code> .  Nous apportons des modifications: <br><br><pre> <code class="hljs perl">_subtract: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>  ;   ;   , eax     ;     ,     leave ;      ret</code> </pre> <br><h1>  √âcriture de certaines fonctions de base </h1><br>  Apr√®s avoir ma√Ætris√© la convention d'appel, vous pouvez commencer √† √©crire certaines routines.  Pourquoi ne pas g√©n√©raliser le code qui affiche "Bonjour tout le monde!" Pour sortir des lignes: la fonction <code>_print_msg</code> . <br><br>  Ici, nous avons besoin d'une autre fonction <code>_strlen</code> pour compter la longueur de la cha√Æne.  En C, cela pourrait ressembler √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*s != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   length++; s++; } //   return length; }</span></span></code> </pre> <br>  En d'autres termes, d√®s le d√©but de la ligne, nous ajoutons 1 √† la valeur de retour pour chaque caract√®re sauf z√©ro.  D√®s que le caract√®re nul est remarqu√©, nous retournons la valeur accumul√©e dans la boucle.  Dans l'assembleur, c'est aussi assez simple: vous pouvez utiliser la fonction <code>_subtract</code> pr√©c√©demment √©crite comme base: <br><br><pre> <code class="hljs 1c">_strlen: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;   ;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, 0 ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function"> = 0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+8] ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">   ;  </span></span></span></span>)   ecx (   ; ,      ) _strlen_loop_start: ;  ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span> cmp byte [ecx], <span class="hljs-number"><span class="hljs-number">0</span></span> ;       . <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>  (<span class="hljs-number"><span class="hljs-number">4</span></span> ). ;    .    ;     ( <span class="hljs-built_in"><span class="hljs-built_in"></span></span>) je _strlen_loop_end ;  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>     inc eax ;    ,  <span class="hljs-number"><span class="hljs-number">1</span></span>    add ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;       jmp _strlen_loop_start ;      _strlen_loop_end: ;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br>  D√©j√† pas mal, non?  L'√©criture du code C en premier peut √™tre utile, car la majeure partie est directement convertie en assembleur.  Vous pouvez maintenant utiliser cette fonction dans <code>_print_msg</code> , o√π nous appliquons toutes les connaissances acquises: <br><br><pre> <code class="hljs perl">_print_msg: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    mov eax, <span class="hljs-number"><span class="hljs-number">0x04</span></span> ; <span class="hljs-number"><span class="hljs-number">0x04</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0x1</span></span> ; <span class="hljs-number"><span class="hljs-number">0x1</span></span> =   mov ecx, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;       , ;   edx   .    _strlen <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;     (    edx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> dword [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   _strlen  _print_msg.  NASM ; ,    ,  , . ;      dword (<span class="hljs-number"><span class="hljs-number">4</span></span> , <span class="hljs-number"><span class="hljs-number">32</span></span> ) call _strlen ; eax     mov edx, eax ;     edx,     add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ;  <span class="hljs-number"><span class="hljs-number">4</span></span>    ( <span class="hljs-number"><span class="hljs-number">4</span></span>-  char*) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;     <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;      _strlen,     <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> leave ret</code> </pre> <br>  Et voyez les fruits de notre travail acharn√©, en utilisant cette fonction dans le programme complet "Hello, world!". <br><br><pre> <code class="hljs pgsql">_start: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     (    ) push hello_world ;    _print_msg <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Croyez-le ou non, nous avons couvert tous les principaux sujets n√©cessaires pour √©crire des programmes d'assembleur x86 de base!  Nous avons maintenant tout le mat√©riel d'introduction et la th√©orie, nous allons donc nous concentrer compl√®tement sur le code et appliquer les connaissances acquises pour √©crire notre calculatrice RPN.  Les fonctions seront beaucoup plus longues et utiliseront m√™me certaines variables locales.  Si vous voulez voir imm√©diatement le programme termin√©, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> . <br><br>  Pour ceux d'entre vous qui ne sont pas familiers avec la notation polonaise invers√©e (parfois appel√©e notation polonaise invers√©e ou notation postfix√©e), les expressions sont √©valu√©es ici √† l'aide de la pile.  Par cons√©quent, vous devez cr√©er une pile, ainsi que les fonctions <code>_pop</code> et <code>_push</code> pour manipuler cette pile.  Vous aurez √©galement <code>_print_answer</code> fonction <code>_print_answer</code> , qui affichera une repr√©sentation sous forme de cha√Æne du r√©sultat num√©rique √† la fin du calcul. <br><br><h1>  Cr√©ation de pile </h1><br>  Tout d'abord, nous d√©finissons l'espace en m√©moire de notre pile, ainsi que la variable globale <code>stack_size</code> .  Il est conseill√© de modifier ces variables afin qu'elles ne tombent pas dans la section <code>.rodata</code> , mais dans <code>.data</code> . <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">section</span></span> .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> stack_size: dd 0 ;   dword (4 )   0 stack: times 256 dd 0 ;   </span></span></code> </pre> <br>  Vous pouvez maintenant impl√©menter les fonctions <code>_push</code> et <code>_pop</code> : <br><br><pre> <code class="hljs powershell">_push: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    push eax push edx mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov edx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>], edx ;    .   ;       dword inc dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;  <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size ;     pop edx pop eax leave ret _pop: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     dec dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov eax, [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>] ;       eax ;     ,     leave ret</code> </pre> <br><h1>  Sortie num√©rique </h1><br>  <code>_print_answer</code> beaucoup plus compliqu√©: vous devez convertir des nombres en cha√Ænes et utiliser plusieurs autres fonctions.  Vous aurez <code>_putc</code> fonction <code>_putc</code> , qui <code>_putc</code> un caract√®re, la fonction <code>mod</code> pour calculer le reste de la division (module) des deux arguments et <code>_pow_10</code> pour augmenter √† la puissance de 10. Plus tard, vous comprendrez pourquoi ils sont n√©cessaires.  C'est assez simple, voici le code: <br><br><pre> <code class="hljs powershell">_pow_10: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  ecx (  )  ;  mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">10</span></span> (<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>) _pow_10_loop_start: ;  eax  <span class="hljs-number"><span class="hljs-number">10</span></span>,  ecx   <span class="hljs-number"><span class="hljs-number">0</span></span> cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _pow_10_loop_end imul eax, <span class="hljs-number"><span class="hljs-number">10</span></span> sub ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _pow_10_loop_start _pow_10_loop_end: leave ret _mod: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> push ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;   mov eax, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov ebx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">12</span></span>] idiv ebx ;  <span class="hljs-number"><span class="hljs-number">64</span></span>-  [<span class="hljs-type"><span class="hljs-type">edx</span></span>:<span class="hljs-type"><span class="hljs-type">eax</span></span>]  ebx.    ;  <span class="hljs-number"><span class="hljs-number">32</span></span>-  eax,    edx  ; . ;    eax,   edx.  ,  ;       , ;    . mov eax, edx ;     () pop ebx leave ret _putc: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ; write() mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   lea ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   mov edx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 leave ret</code> </pre> <br>  Alors, comment d√©river des nombres individuels dans un nombre?  Tout d'abord, notez que le dernier chiffre du nombre est le reste de la division par 10 (par exemple, <code>123 % 10 = 3</code> ), et le chiffre suivant est le reste de la division par 100, divis√© par 10 (par exemple, <code>(123 % 100)/10 = 2</code> ).  En g√©n√©ral, vous pouvez trouver un chiffre sp√©cifique d'un nombre (de droite √† gauche) en trouvant <code>( % 10**n) / 10**(n-1)</code> , o√π le nombre d'unit√©s sera <code>n = 1</code> , le nombre de dizaines est <code>n = 2</code> etc. <br><br>  En utilisant cette connaissance, vous pouvez trouver tous les chiffres d'un nombre de <code>n = 1</code> √† <code>n = 10</code> (c'est le nombre maximum de bits dans un entier sign√© de 4 octets).  Mais il est beaucoup plus facile d'aller de gauche √† droite - nous pouvons donc imprimer chaque caract√®re d√®s que nous le trouvons et nous d√©barrasser des z√©ros sur le c√¥t√© gauche.  Par cons√©quent, nous trions les nombres de <code>n = 10</code> √† <code>n = 1</code> . <br><br>  En C, le programme ressemblera √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_DIGITS 10 void print_answer(int a) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (a </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 0) { //    putc('-'); //   ¬´¬ª a = -a; //     } int started = 0; for (int i = MAX_DIGITS; i &gt; 0; i--) { int digit = (a % pow_10(i)) / pow_10(i-1); if (digit == 0 &amp;&amp; started == 0) continue; //     started = 1; putc(digit + '0'); } }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous comprenez maintenant pourquoi nous avons besoin de ces trois fonctions. </font><font style="vertical-align: inherit;">Impl√©mentons ceci dans l'assembleur:</font></font><br><br><pre> <code class="hljs perl">%define MAX_DIGITS <span class="hljs-number"><span class="hljs-number">10</span></span> _print_answer: enter <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-string"><span class="hljs-string">"started"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   <span class="hljs-string"><span class="hljs-string">"a"</span></span> cmp eax, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    ;  jge _print_answer_negate_end ; call putc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0x2d</span></span> ;  <span class="hljs-string"><span class="hljs-string">'-'</span></span> call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax neg eax ;     _print_answer_negate_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ; started = <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, MAX_DIGITS ;  i _print_answer_loop_start: cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _print_answer_loop_end ;  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>  ecx.   ebx   <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C. ;    edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx dec ecx ; i-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;    _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> mov edx, eax ; edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;   i  ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ; end pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call mov ebx, edx ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) imul ebx, <span class="hljs-number"><span class="hljs-number">10</span></span> ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) ;  _mod  (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)),   (eax mod ebx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx ; arg2, ebx = digit = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ; arg1, eax = a call _mod mov ebx, eax ; digit = ebx = a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i+<span class="hljs-number"><span class="hljs-number">1</span></span>), almost there add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   mod ;  ebx ( <span class="hljs-string"><span class="hljs-string">"digit"</span></span> )  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) (edx).    ; ,   idiv     edx, eax.  ; edx   ,    - ;   <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov esi, edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax mov eax, ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv esi ; eax   () mov ebx, eax ; ebx = (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)) / pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> esi ; end division cmp ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  digit == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end cmp byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ;  started == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end jmp _print_answer_loop_continue ; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> _print_answer_trailing_zeroes_check_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span> ; started = <span class="hljs-number"><span class="hljs-number">1</span></span> add ebx, <span class="hljs-number"><span class="hljs-number">0x30</span></span> ; digit + <span class="hljs-string"><span class="hljs-string">'0'</span></span> ;  putc <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   putc _print_answer_loop_continue: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jmp</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_start</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_end</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebx</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce fut un test difficile! </font><font style="vertical-align: inherit;">J'esp√®re que les commentaires aideront √† le r√©gler. </font><font style="vertical-align: inherit;">Si vous pensez maintenant: "Pourquoi ne pouvez-vous pas simplement √©crire </font></font><code>printf("%d")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?", Alors vous aimerez la fin de l'article, o√π nous remplacerons la fonction par juste cela! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons toutes les fonctions n√©cessaires, il reste √† impl√©menter la logique de base dans </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- et c'est tout!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calcul de la notation polonaise invers√©e </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous l'avons d√©j√† dit, la notation polonaise inverse est calcul√©e √† l'aide de la pile. </font><font style="vertical-align: inherit;">Lors de la lecture, le nombre est pouss√© sur la pile et lors de la lecture, l'op√©rateur est appliqu√© √† deux objets en haut de la pile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, si nous voulons calculer </font></font><code>84/3+6*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(cette expression peut √©galement √™tre √©crite dans le formulaire </font></font><code>6384/+*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), le processus est le suivant:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtape </font></font></th><th>  Symbole </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Empiler avant </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pile apr√®s </font></font></th></tr><tr><td align="center">  1 </td><td align="center"> <code>8</code> </td> <td align="center"> <code>[]</code> </td> <td align="center"> <code>[8]</code> </td> </tr><tr><td align="center">  2 </td><td align="center"> <code>4</code> </td> <td align="center"> <code>[8]</code> </td> <td align="center"> <code>[8, 4]</code> </td> </tr><tr><td align="center">  3 </td><td align="center"> <code>/</code> </td> <td align="center"> <code>[8, 4]</code> </td> <td align="center"> <code>[2]</code> </td> </tr><tr><td align="center">  4 </td><td align="center"> <code>3</code> </td> <td align="center"> <code>[2]</code> </td> <td align="center"> <code>[2, 3]</code> </td> </tr><tr><td align="center">  5 </td><td align="center"> <code>+</code> </td> <td align="center"> <code>[2, 3]</code> </td> <td align="center"> <code>[5]</code> </td> </tr><tr><td align="center">  6 </td><td align="center"> <code>6</code> </td> <td align="center"> <code>[5]</code> </td> <td align="center"> <code>[5, 6]</code> </td> </tr><tr><td align="center">  7 </td><td align="center"> <code>*</code> </td> <td align="center"> <code>[5, 6]</code> </td> <td align="center"> <code>[30]</code> </td> </tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'entr√©e est une expression de suffixe valide, √† la fin des calculs, il ne reste qu'un √©l√©ment sur la pile - c'est la r√©ponse, le r√©sultat des calculs. </font><font style="vertical-align: inherit;">Dans notre cas, le nombre est 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'assembleur, vous devez impl√©menter quelque chose comme ce code en C:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// , 256      int stack_size = 0; int main(int argc, char *argv[]) { char *input = argv[0]; size_t input_length = strlen(input); for (int i = 0; i &lt; input_length; i++) { char c = input[i]; if (c &gt;= '0' &amp;&amp; c &lt;= '9') { //   ‚Äî   push(c - '0'); //          } else { int b = pop(); int a = pop(); if (c == '+') { push(a+b); } else if (c == '-') { push(ab); } else if (c == '*') { push(a*b); } else if (c == '/') { push(a/b); } else { error("Invalid input\n"); exit(1); } } } if (stack_size != 1) { error("Invalid input\n"); exit(1); } print_answer(stack[0]); exit(0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant que nous avons toutes les fonctions n√©cessaires pour l'impl√©menter, commen√ßons. </font></font><br><br><pre> <code class="hljs perl">_start: ;  _start   ,    . ;   esp    argc ( ),  ; esp+<span class="hljs-number"><span class="hljs-number">4</span></span>   argv. , esp+<span class="hljs-number"><span class="hljs-number">4</span></span>    ; , esp+<span class="hljs-number"><span class="hljs-number">8</span></span> -       mov esi, [esp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ; esi = <span class="hljs-string"><span class="hljs-string">"input"</span></span> = argv[<span class="hljs-number"><span class="hljs-number">0</span></span>] ;  _strlen      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi call _strlen mov ebx, eax ; ebx = input_length add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ; end _strlen call mov ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; ecx = <span class="hljs-string"><span class="hljs-string">"i"</span></span> _main_loop_start: cmp ecx, ebx ;  (i &gt;= input_length) jge _main_loop_end mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> mov dl, [esi + ecx] ;          ; edx.   edx . ; edx =  c = input[i] cmp edx, <span class="hljs-string"><span class="hljs-string">'0'</span></span> jl _check_operator cmp edx, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jg _print_error <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function">, '0' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function"> </span></span>; eax =  c - <span class="hljs-string"><span class="hljs-string">'0'</span></span> (,  ) jmp _push_eax_and_continue _check_operator: ;   _pop    b  edi, a  b -  eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _pop mov edi, eax ; edi = b call _pop ; eax = a <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; end call _pop cmp edx, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jne _subtract add eax, edi ; eax = a+b jmp _push_eax_and_continue _subtract: cmp edx, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jne _multiply <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span></span>; eax = ab jmp _push_eax_and_continue _multiply: cmp edx, <span class="hljs-string"><span class="hljs-string">'*'</span></span> jne _divide imul eax, edi ; eax = a*b jmp _push_eax_and_continue _divide: cmp edx, <span class="hljs-string"><span class="hljs-string">'/'</span></span> jne _print_error <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx ;  edx,      idiv mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv edi ; eax = a/b <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;   eax     _push_eax_and_continue: ;  _push <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;   call _push add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;  call _push inc ecx jmp _main_loop_start _main_loop_end: cmp byte [stack_size], <span class="hljs-number"><span class="hljs-number">1</span></span> ;  (stack_size != <span class="hljs-number"><span class="hljs-number">1</span></span>),   jne _print_error mov eax, [stack] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax call _print_answer ; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> a final newline <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0xA</span></span> call _putc ; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> successfully mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> ;    _print_error: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> error_msg call _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devrez √©galement ajouter une ligne </font></font><code>error_msg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la section </font></font><code>.rodata</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs 1c">section .rodata ;     error_msg.  db  NASM ;    ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ; . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    error_msg: db <span class="hljs-string"><span class="hljs-string">"Invalid input"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et nous avons termin√©! </font><font style="vertical-align: inherit;">Surprenez tous vos amis si vous en avez. </font><font style="vertical-align: inherit;">J'esp√®re que vous allez maintenant r√©agir plus chaleureusement aux langages de haut niveau, surtout si vous vous souvenez que de nombreux anciens programmes ont √©t√© √©crits compl√®tement ou presque compl√®tement en assembleur, par exemple, le RollerCoaster Tycoon original! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout le code est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Merci d'avoir lu! </font><font style="vertical-align: inherit;">Je peux continuer si cela vous int√©resse.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actions suppl√©mentaires </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez vous entra√Æner en impl√©mentant plusieurs fonctions suppl√©mentaires: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Renvoie un message d'erreur au lieu de segfault si le programme ne re√ßoit pas d'argument. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez la prise en charge des espaces suppl√©mentaires entre les op√©randes et les op√©rateurs dans l'entr√©e. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez la prise en charge des op√©randes multi-bits. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Autorisez les nombres n√©gatifs. </font></font></li><li>  <code>_strlen</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  C</a> ,  <code>_print_answer</code>   <code>printf</code> . </li></ol><br><h1>  Mat√©riel suppl√©mentaire </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´   x86  ¬ª</a> ‚Äî     ,  ,          x86. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´   Intel¬ª</a> .    x86 ‚Äî   ,      .        ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NASM: Intel x86 Instruction Reference</a> ‚Äî       x86. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423077/">https://habr.com/ru/post/fr423077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423067/index.html">Outils de d√©veloppement Python de Microsoft. Pour commencer</a></li>
<li><a href="../fr423069/index.html">√âv√©nement sp√©cial Apple, septembre 2018 [archives de traduction de texte]</a></li>
<li><a href="../fr423071/index.html">Je n'ai pas peur de ton NDA</a></li>
<li><a href="../fr423073/index.html">Syst√®me de fichiers interplan√©taire - hachage trivial (identit√©), bloc DAG et tampons de protocole</a></li>
<li><a href="../fr423075/index.html">Pourquoi les directeurs financiers sont-ils si d√©sireux de traduire les d√©penses d'investissement en informatique en op√©rations</a></li>
<li><a href="../fr423079/index.html">Points cl√©s d'une entrevue avec Elon Musk chez Joe Rogan</a></li>
<li><a href="../fr423083/index.html">Comment je suis devenu d√©veloppeur chez ABBYY</a></li>
<li><a href="../fr423085/index.html">√âquilibrage pr√©cis de la charge</a></li>
<li><a href="../fr423087/index.html">Ne me pousse pas dans les yeux</a></li>
<li><a href="../fr423089/index.html">Programmeurs √† MBLT DEV 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>