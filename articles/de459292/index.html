<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♀️ 🌤️ 🛢️ Testautomatisierung für mobile Anwendungen: Toolvergleich ❓ 👩‍👧‍👦 👨🏽‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Testautomatisierung hilft bei der gleichzeitigen Lösung mehrerer Probleme - auch bei mobilen Anwendungen. Anstatt routinemäßige arbeitsintensive V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testautomatisierung für mobile Anwendungen: Toolvergleich</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/459292/">  Die Testautomatisierung hilft bei der gleichzeitigen Lösung mehrerer Probleme - auch bei mobilen Anwendungen.  Anstatt routinemäßige arbeitsintensive Verfahren manuell durchzuführen, können Spezialisten einen erheblichen Teil davon an die Frameworks delegieren.  Die Automatisierung vereinfacht das Testen und beschleunigt das Testen von Regressionen. Außerdem können zuvor unzugängliche Testtypen verwendet werden. <br><br>  Wir werden verschiedene Tools vergleichen, die sich auf dem Markt etabliert haben und weiterentwickeln.  Dieses Wissen hilft Ihnen bei der Auswahl der Lösung zum Testen einer bestimmten mobilen Anwendung. <br><br><img src="https://habrastorage.org/webt/fh/nx/t-/fhnxt-nrmjzskbyw-vub5mtdgje.png"><a name="habracut"></a><br><br>  Es ist unwahrscheinlich, dass dieser Artikel Fachleuten neue Horizonte eröffnet. Er kann jedoch für Anfänger nützlich sein, die die Grundlagen des mobilen Testens erlernen möchten, und in gewissem Maße für mittelständische Spezialisten. <br><br><h2>  Werkzeugklassifizierung </h2><br>  Das erste, worauf Sie aufbauen sollten, ist die Plattform, auf der die Anwendung ausgeführt wird.  Auf dieser Grundlage klassifizieren wir die Liste der Werkzeuge wie folgt: <br><br>  <b>Android</b> <br><br><ul><li>  Espresso </li><li>  UI Automator </li></ul><br>  <b>iOS</b> <br><br><ul><li>  XCUITest </li><li>  Earlgrey </li></ul><br>  <b>Universal</b> <br><br><ul><li>  Detox </li><li>  Appium </li><li>  Ranorex </li><li>  TestComplete Mobile </li></ul><br><h2>  Testautomatisierung für Android-Anwendungen </h2><br><h2>  UI Automator </h2><br>  Leistungsstarkes Testtool mit erweiterter externer Integration.  Dies bedeutet, dass Sie mit diesem Framework nicht nur die Anwendung selbst testen können, sondern auch mit dem Betriebssystem und anderen Anwendungen „kommunizieren“ können. Aktivieren und deaktivieren Sie beispielsweise Wi-Fi und GPS, öffnen Sie das Einstellungsmenü während des Tests und führen Sie andere externe Interaktionen durch. <br><br>  Der Zweck von UI Automator ist das Black-Box-Testen.  Dies bedeutet, dass die Analyse von der Position eines externen Benutzers aus ohne Zugriff auf den Code durchgeführt wird. <br><br>  Zu den Hauptmerkmalen gehören: <br><br><ul><li>  UI Automator Viewer zum Verfolgen und Analysieren von Komponenten, die während des Tests auf dem Bildschirm angezeigt werden.  Es enthält Informationen zu Elementen und ihren Eigenschaften, wodurch es einfacher wird, relevantere Tests zu erstellen. </li><li>  API zum Abrufen von Informationen zum Status des Geräts und zum Ausführen von Prozessen auf dem Gerät. </li><li>  UI Automator-APIs für plattformübergreifende Tests. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Dokumentation</a> . <br><br><h2>  Espresso </h2><br>  Ein leichteres Tool als UI Automator, das nicht für die Interaktion mit externen Anwendungen geeignet ist, aber zum Testen einer White-Box mit Zugriff auf den Quellcode einer bestimmten Anwendung oder zum Testen einer Gray-Box mit geeignet ist die Zugriff auf einige interne Prozesse und Strukturen hat. <br><br>  Espresso zeichnet sich jedoch durch seine leistungsstarke API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/hamcrest aus</a> .  Die Benutzeroberfläche fügt praktische Methoden zum Überprüfen von Autotests hinzu, zum Beispiel: <br>  assert_that (1, less_or_equal (2)).  Zum Testen der Webansicht werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spezielle</a> Methoden verwendet. <br><br>  UI Automator und Espresso ergänzen sich gegenseitig und können in Kombination innerhalb desselben Projekts verwendet werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Dokumentation</a> . <br><br><h2>  Testautomatisierung für iOS-Anwendungen </h2><br><h2>  XCUITest </h2><br>  Ein Tool zum Black-Box-Testen ohne Zugriff auf den Anwendungscode.  Es funktioniert nur mit nativen Produkten - leider funktionieren app-übergreifende Tests nicht. <br><br>  Andererseits ist die native Natur des Frameworks unter dem Gesichtspunkt von Vorteil, dass bei Verwendung von XCUITest der Grad des gegenseitigen Verständnisses von Entwicklern und Testern auf einem viel höheren Niveau liegt als in Fällen, in denen die eine und die andere unterschiedliche Sprachen verwenden. <br><br>  Eine nützliche Ergänzung ist der Testrekorder, mit dem Tests geschrieben werden können, indem Aktionen in der Anwendung aufgezeichnet werden, auch für diejenigen, die nicht mit dem Code arbeiten. <br><br>  Mit dem Tool können Sie häufige Fehler und unnötige, für den Benutzer unzugängliche Manipulationen mit dem Code vermeiden.  XCUITest hat jedoch auch einige Nachteile. <br><br>  XCUITest arbeitet im Gegensatz zu Espresso in einem separaten Thread. Während des Tests müssen Sie auf das Erscheinen bestimmter Elemente und Parameter warten.  Der aktuelle Status der Anwendung wird nicht gelesen, und Verzögerungen beim Aktualisieren von Daten können dazu führen, dass die angeforderten Elemente nicht erkannt werden können. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XCTest- und XCUITest-Dokumentation</a> . <br><br><h2>  Earlgrey </h2><br>  EarlGreys Schwerpunkt liegt auf der Reproduktion der Benutzererfahrung.  Solange die Elemente auf dem Bildschirm nicht visuell dargestellt werden, wird die Simulation der Arbeit mit der Anwendung nicht gestartet. <br><br>  Gleichzeitig werden eine Reihe von Annehmlichkeiten und Vorteilen festgestellt.  Zuallererst mögen Experten die Art und Weise, wie das Framework Anforderungen, Benutzeroberflächen und Threads synchronisiert.  Es sind keine Wartezeiten und Wartezeiten erforderlich. <br><br>  Zweitens wird, wie bereits erwähnt, besonderes Augenmerk auf die Verfolgung der Sichtbarkeit von Elementen gelegt.  Das Tool verfügt über eine zusätzliche Ebene zum Überprüfen des Ladens der Benutzeroberfläche und reproduziert Benutzergesten - Wischen, Klicken - direkt auf der Ebene des Anwendungsereignisses. <br><br>  Repository-Links: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/google/EarlGrey</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">google.github.io/EarlGrey</a> . <br><br><h2>  Universalwerkzeuge </h2><br>  Mit universellen Tools (oder „Mähdreschern“) können Sie Ihre Auswahl nicht nur auf Android oder iOS beschränken, sondern mit beiden Plattformen arbeiten. <br><br>  Solche Tools eignen sich zum Testen von Anwendungen der folgenden Typen: <br><br><ul><li>  Native Apps (native Apps) - direkt unter dem Android-, iOS- und Windows-SDK geschrieben. </li><li>  Mobile Web-Apps - Verfügbar über einen mobilen Browser wie Safari oder Chrome. </li><li>  Hybridanwendungen (Hybridanwendungen) - Der Benutzer arbeitet mit der Shell der Webanwendung, dh er interagiert mit Webinhalten über die Schnittstelle der nativen Anwendung. </li></ul><br><h2>  Detox </h2><br>  Unserer Meinung nach eignet sich Detox für Anwendungen, die in React Native geschrieben wurden.  Tests werden in JavaScript geschrieben, während iOS- und Android-Anwendungen aus demselben JavaScript-Code generiert werden und so ähnlich wie möglich sind.  Auf diese Weise können Sie für beide Plattformen dieselben Tests verwenden. <br><br>  Ein wichtiges Merkmal von Detox sind Gray-Box-Tests.  In diesem Fall hat das Framework Zugriff auf interne Mechanismen, mit denen Sie das externe Verhalten der Anwendung mit dem korrelieren können, was auf einer tieferen Ebene geschieht. <br><br>  Detox kann auf den Speicher zugreifen und laufende Prozesse verfolgen.  Das Gray-Box-Prinzip hilft bei der Bekämpfung der Instabilität, was sich in der Tatsache widerspiegelt, dass bei End-to-End-Tests: <br><br><ul><li>  Der Test kann auch ohne Änderungen im Code zufällig abstürzen. </li><li>  Die Ergebnisse sind nicht deterministisch - aufgrund der großen Anzahl heterogener Funktionen und Prozesse innerhalb der Anwendung können sich die Ergebnisse jedes Starts unvorhersehbar voneinander unterscheiden. </li><li>  Tester sind gezwungen, manuell zu synchronisieren, was zu einer Verringerung der Zuverlässigkeit und Qualität der Ergebnisse führt. </li></ul><br>  Seltsamerweise zeigt die „graue Box“ nicht nur eine bessere Stabilität, sondern auch eine höhere Geschwindigkeit als die „schwarze Box“.  Wenn Sie alle Arten von Pausen vermeiden, kann waitUntil, grey-box 5-10 mal schneller sein. <br><br>  Detox benötigt keinen WebDriver und arbeitet mit dem nativen Treiber über JSON.  Es verwendet native Methoden direkt auf dem Gerät.  In diesem Framework werden EarlGrey für iOS und Espresso für Android verwendet. <br><br>  Das Framework funktioniert sowohl mit Emulatoren als auch mit physischen Geräten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Dokumentation</a> . <br><br><h2>  Appium </h2><br>  Der Vorteil von Appium besteht darin, dass Tests für jede Plattform mit einer einzigen API geschrieben werden können, ohne dass die Anwendung in eine spezielle Form konvertiert werden muss, die mit dem Framework kompatibel ist. <br><br>  Beim Testen werden Frameworks von Anbietern verwendet - das heißt, Sie arbeiten mit der ursprünglichen Anwendung.  Für Android 4.2+ wird UiAutomator / UiAutomator2 und für iOS 9.3+ - XCUITest verwendet.  WebDriver (auch bekannt als Selenium WebDriver) wird als Framework-Framework verwendet. <br><br>  Appium-Prinzipien: <br><br><ul><li>  Sie müssen die Anwendung nicht neu kompilieren oder ändern, um das Testen zu automatisieren. </li><li>  Es ist nicht erforderlich, an eine Sprache oder ein Framework gebunden zu sein. </li><li>  Es ist nicht erforderlich, das Rad neu zu erfinden, wenn es um Automatisierungs-APIs geht. </li></ul><br>  Die Verwendung von Appium ist gerechtfertigt, wenn Sie ein Tool benötigen, um das Testen auf mehreren Plattformen gleichzeitig zu automatisieren.  Dies ist nützlich, wenn Sie über Spezialisten mit Erfahrung im Testen von Webanwendungen verfügen, jedoch keine Erfahrung mit der Automatisierung des Testens mobiler Anwendungen haben. <br><br>  Im Allgemeinen ist dies ein flexibles Tool, das an die Anforderungen des Projekts angepasst werden kann, ohne dass eine Anpassung an eine begrenzte Anzahl von Entwicklungssprachen erforderlich ist. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Dokumentation</a> . <br><br><h2>  Ranorex </h2><br>  Bezahltes umfassendes Tool zum Testen von Desktop-, Mobil- und Webanwendungen.  Es ermöglicht das Testen sowohl mit der Programmierung als auch ohne Verwendung von Skripten.  Bietet die Möglichkeit, nicht nur über Emulatoren, sondern auch auf Live-Geräten zu testen. <br><br>  Mit dem Tool können Sie Tests erstellen, konfigurieren und zentral verwalten.  Sie können einen Test im Kontrollzentrum erstellen und in verschiedenen externen Umgebungen und auf beliebigen Geräten ausführen. <br><br>  Einfache Integration in Ihre vorhandene CI-Umgebung: in Anwendungsverwaltungssysteme wie Jira und TFS sowie in Versionskontrollsysteme wie Git und SVN. <br><br>  Ranorex bietet datengesteuerte Tests mit Daten, die aus SQL, CSV und Excel geladen werden. <br><br>  Das Tool ist für absolut jedes Gerät geeignet und unterstützt parallele Tests an jedem von ihnen. <br><br>  Es kombiniert alle drei Testansätze: Black-Box, White-Box und Gray-Box. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Dokumentation</a> . <br><br><h2>  Test abgeschlossen </h2><br>  Bezahlte Umgebung zum Testen der Automatisierung von Mobil-, Web- und Desktopanwendungen.  Es unterstützt Android und iOS sowie im Kontext der Anwendungstypen: native, Webanwendungen und Hybrid. <br><br>  Das Tool konzentriert sich hauptsächlich auf Funktions- und Komponententests und bietet auch die Möglichkeit, viele andere Arten von Tests durchzuführen: <br><br><ul><li>  Regression; </li><li>  Datengesteuertes Testen; </li><li>  Verteilte Tests und mehr. </li></ul><br>  In TestComplete gibt es einen Rekorder - darin werden Tests erstellt, indem Aktionen aufgezeichnet und Befehle im Editor festgelegt werden.  Anschließend können sie entweder direkt im Tool selbst gestartet oder in Anwendungen von Drittanbietern exportiert werden. <br><br>  Dieses Tool erkennt Objekte und Steuerelemente, indem es spezielle Befehle zum Emulieren der Benutzerinteraktion mit ihnen anbietet.  Integriert in Jenkins, Git und Jira, sodass Sie kontinuierliche nahtlose Tests durchführen können. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Dokumentation</a> . <br><br><h2>  Zusammenfassend </h2><br>  Beachten Sie beim Testen dieser oder jener mobilen Anwendung die oben aufgeführten Tools.  Jeder von ihnen hat seine eigenen Eigenschaften und manchmal Einschränkungen. <br><br>  Schauen wir uns ein Beispiel an.  Wenn Sie vor der Aufgabe stehen, eine kleine Anwendung in kurzer Zeit zu testen, müssen Sie zunächst Faktoren wie die Art der getesteten Anwendung und die Erfahrung Ihrer Spezialisten berücksichtigen.  Wenn ein Entwickler Tests schreibt, ist es besser, eine Muttersprache und ein Tool für seine Plattform auszuwählen (siehe Tabelle unten).  Wenn die Tests von SDET-Spezialisten durchgeführt werden, die mit anderen Sprachen (Java, JavaScript, Python usw.) vertraut sind und mit Selenium gearbeitet haben, ist es zweckmäßig, Appium zu verwenden.  Wenn das Team kein erfahrenes SDET enthält und QS-Spezialisten Tests schreiben, ist es besser, kostenpflichtige Frameworks zu wählen, da diese über Dienstprogramme zum Aufzeichnen von Tests und einen stabileren technischen Support verfügen als Open Source-Frameworks. <br><br>  <i>Aus unserer Praxis:</i> <i><br></i>  <i>Wir haben mit einem Online-Shop gearbeitet, der zwei mobile Anwendungen hatte - auf iOS und Android.</i>  <i>Um die Hauptbenutzerszenarien mit Tests zu testen, haben wir uns aus mehreren Gründen für Appium entschieden:</i> <i><br><br></i> <ul><li>  <i>plattformübergreifend die Möglichkeit, den Code teilweise wiederzuverwenden</i> </li><li>  <i>Geeignet für End-to-End-Tests, kann mit Web arbeiten</i> </li><li>  <i>die Präsenz von Spezialisten im Team, die sich des Selens bewusst sind, das als Hülle dieses Frameworks dient.</i> </li></ul> <i><br></i>  <i>Infolgedessen hat Appium die Erwartungen voll erfüllt und Tests für iOS und Android erfolgreich durchgeführt.</i>  <i>Es ist zu beachten, dass solche End-to-End-Tests mit Appium nicht bei jeder Zusammenführungsanforderung durchgeführt werden, da dies viel Zeit in Anspruch nimmt.</i> <br><br>  Abschließend machen wir Sie auf eine Tabelle aufmerksam, die Ihnen bei der Auswahl des Tools für Ihr Projekt hilft.  Es ist zu beachten, dass in einigen Fällen die Aufteilung in der Tabelle an Bedingungen geknüpft ist.  Der Einfachheit halber wird eine Verallgemeinerung vorgenommen und nur die grundlegendsten Parameter angegeben.  Die Testwerkzeuge werden ständig weiterentwickelt. Bei der Auswahl eines Frameworks ist es daher wichtig, die aktuelle Dokumentation zu überprüfen. <br><br><img src="https://habrastorage.org/webt/fi/m1/7t/fim17tgj4mzjsf1mea_mswscy7i.jpeg"><br><br>  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459292/">https://habr.com/ru/post/de459292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459276/index.html">Epic Fail Resistance 2 oder warum Sie sich mit FireFox-Plugins nicht auf den Datenschutz einlassen sollten</a></li>
<li><a href="../de459280/index.html">Warum lieben Entwickler es, native Apps zu erstellen?</a></li>
<li><a href="../de459284/index.html">Kurze Einführung in die Priorisierung von Produktstrategien und Funktionen</a></li>
<li><a href="../de459286/index.html">Halbmetall-Wolfram-Tellurid - das Schweizer Messer des Tages der Nanotechnologie</a></li>
<li><a href="../de459288/index.html">Native Implementierung der ECS-Bibliothek</a></li>
<li><a href="../de459294/index.html">Was ist wichtiger: eine Programmiersprache kennen oder ein Geschäftsproblem lösen können?</a></li>
<li><a href="../de459296/index.html">JavaScript Preis 2019</a></li>
<li><a href="../de459298/index.html">Winkel: Status im Jahr 2019</a></li>
<li><a href="../de459300/index.html">Quasar 1.0: Ein neues nützliches Tool für Vue-Entwickler und nicht nur für sie</a></li>
<li><a href="../de459302/index.html">Wiederholen fehlgeschlagener HTTP-Anforderungen in Angular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>