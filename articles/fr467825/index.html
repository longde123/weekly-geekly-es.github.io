<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈂️ 👩🏻‍🎓 ☎️ Algorithmes d'apprentissage automatique indispensables 🚤 ◀️ 🧓🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr, bonjour. 

 Cet article est un bref aperçu des algorithmes généraux d'apprentissage automatique. Chacun est accompagné d'une brève description, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmes d'apprentissage automatique indispensables</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467825/">  Habr, bonjour. <br><br>  Cet article est un bref aperçu des algorithmes généraux d'apprentissage automatique.  Chacun est accompagné d'une brève description, de guides et de liens utiles. <br><br><h2>  Méthode des composants principaux (PCA) / SVD </h2><br>  Il s'agit de l'un des algorithmes d'apprentissage machine de base.  Vous permet de réduire la dimensionnalité des données, en perdant le moins d'informations.  Il est utilisé dans de nombreux domaines, tels que la reconnaissance d'objets, la vision par ordinateur, la compression de données, etc. Le calcul des principaux composants se réduit au calcul des vecteurs propres et des valeurs propres de la matrice de covariance des données sources ou à la décomposition singulière de la matrice de données. <br><br><img src="https://habrastorage.org/webt/q1/s1/jh/q1s1jh5xtwmuvbklcbapvgcmk4a.png" alt="image"><br><br>  SVD est un moyen de calculer les composants ordonnés. <br><br>  Liens utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scipy.linalg.svd</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.decomposition.pca</a> </li></ul><br>  Guide d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tutoriel sur l'analyse des composants de base</a> </li></ul><a name="habracut"></a><br><h2>  Méthode des moindres carrés </h2><br>  La méthode des moindres carrés est une méthode mathématique utilisée pour résoudre divers problèmes, basée sur la minimisation de la somme des carrés des écarts de certaines fonctions par rapport aux variables souhaitées.  Il peut être utilisé pour «résoudre» des systèmes d'équations surdéterminés (lorsque le nombre d'équations dépasse le nombre d'inconnues), pour trouver une solution dans le cas de systèmes d'équations non linéaires ordinaires (non redéfinis), et aussi pour approximer les valeurs ponctuelles d'une fonction. <br><br><img src="https://habrastorage.org/webt/7s/uw/cm/7suwcmx0ilzbfou_eqzltg4-hsm.jpeg" alt="image"><br><br>  Utilisez cet algorithme pour ajuster des courbes / régressions simples. <br><br>  Liens utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">numpy.linalg.lstsq</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Numpy</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">numpy.polyfit</a> </li></ul><br>  Guide d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression linéaire de Stanford (PDF)</a> </li></ul><br><h2>  Régression linéaire limitée </h2><br>  La méthode des moindres carrés peut confondre les valeurs aberrantes, les faux champs, etc. Des contraintes sont nécessaires pour réduire la variance de la ligne que nous mettons dans l'ensemble de données.  La bonne solution consiste à adapter un modèle de régression linéaire qui garantit que les poids ne se comportent pas «mal».  Les modèles peuvent avoir la norme L1 (LASSO) ou L2 (Ridge Regression) ou les deux (régression élastique). <br><br><img src="https://habrastorage.org/webt/rn/a7/wk/rna7wkkbva6w6qrbq_lk0ayxshg.jpeg" alt="image"><br><br>  Utilisez cet algorithme pour faire correspondre les lignes de régression contraintes, en évitant de remplacer. <br><br>  Lien utile: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèles linéaires généralisés</a> </li></ul><br>  Guides d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression de crête</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression LASSO</a> </li></ul><br><h2>  Méthode K-means </h2><br>  Algorithme de clustering incontrôlé préféré de tous.  Étant donné un ensemble de données sous forme de vecteurs, nous pouvons créer des groupes de points en fonction des distances entre eux.  Il s'agit de l'un des algorithmes d'apprentissage automatique qui déplace séquentiellement les centres des grappes, puis regroupe les points avec chaque centre de la grappe.  L'entrée est le nombre de clusters à créer et le nombre d'itérations. <br><br><img src="https://habrastorage.org/webt/2u/pa/9z/2upa9z52ro49nolljotlbb9sfgg.png" alt="image"><br><br>  Lien utile: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.cluster.KMeans</a> </li></ul><br>  Guides d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vidéo de regroupement</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction au clustering</a> </li></ul><br><h2>  Régression logistique </h2><br>  La régression logistique est limitée par une régression linéaire avec non-linéarité (principalement en utilisant la fonction sigmoïde ou tanh) après application des poids, par conséquent, la limitation de sortie est proche des classes +/- (qui sont 1 et 0 dans le cas d'un sigmoïde).  Les fonctions de perte d'entropie croisée sont optimisées en utilisant la méthode de descente de gradient. <br><br>  Remarque pour les débutants: la régression logistique est utilisée pour la classification, pas la régression.  En général, il est similaire à un réseau neuronal monocouche.  Formé en utilisant des techniques d'optimisation telles que la descente de gradient ou le L-BFGS.  Les développeurs de NLP l'utilisent souvent, l'appelant «classification d'entropie maximale». <br><br><img src="https://habrastorage.org/webt/gc/yv/ne/gcyvnenl933eapskav1qili-vde.jpeg" alt="image"><br><br>  Utilisez LR pour former des classificateurs simples mais très «solides». <br><br>  Lien utile: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.linear_model.LogisticRegression</a> </li></ul><br>  Guide d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression logistique |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classification</a> </li></ul><br><h2>  SVM (Support Vector Method) </h2><br>  SVM est un modèle linéaire tel que la régression linéaire / logistique.  La différence est qu'il a une fonction de perte basée sur la marge.  Vous pouvez optimiser la fonction de perte à l'aide de méthodes d'optimisation telles que L-BFGS ou SGD. <br><br><img src="https://habrastorage.org/webt/ic/0b/n6/ic0bn6jtbl4eyukyrbfbysgiazi.jpeg" alt="image"><br><br>  Une chose unique que SVM peut faire est d'apprendre les classificateurs de classe. <br><br>  SVM peut être utilisé pour former des classificateurs (même des régresseurs). <br><br>  Lien utile: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.svm.SVC</a> </li></ul><br>  Guides d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Soutenir la machine vectorielle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.linear_model.SGDClassifier</a> </li></ul><br><h2>  Réseaux de neurones à distribution directe </h2><br>  Fondamentalement, ce sont des classificateurs multiniveaux de régression logistique.  De nombreuses couches de poids sont séparées par des non-linéarités (sigmoïde, tanh, relu + softmax et cool new selu).  Ils sont également appelés perceptrons multicouches.  Les FFNN peuvent être utilisés pour la classification et la «formation sans enseignant» comme auto-encodeurs. <br><br><img src="https://habrastorage.org/webt/t0/zf/km/t0zfkm_ouawuvewy-ypy4uamh0e.jpeg" alt="image"><br><br>  FFNN peut être utilisé pour entraîner le classificateur ou extraire des fonctions en tant qu'encodeurs automatiques. <br><br>  Liens utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.neural_network.MLPClassifier</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.neural_network.MLPRegressor</a> </li></ul><br>  Guides d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ffnn</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Encodeurs automatiques</a> </li></ul><br><h2>  Réseaux de neurones convolutifs </h2><br>  Presque toutes les réalisations modernes dans le domaine de l'apprentissage automatique ont été obtenues en utilisant des réseaux de neurones convolutionnels.  Ils sont utilisés pour classer des images, détecter des objets ou même segmenter des images.  Inventés par Jan Lekun au début des années 90, les réseaux ont des couches convolutionnelles qui agissent comme des extracteurs hiérarchiques d'objets.  Vous pouvez les utiliser pour travailler avec du texte (et même pour travailler avec des graphiques). <br><br><img src="https://habrastorage.org/webt/rw/2c/jh/rw2cjhlifo_p6xwl2bpdjftfaxy.png" alt="image"><br><br>  Liens utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Système d'apprentissage interactif GPU avec Deep Learning</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TorchCV: PyTorch Vision Library imite ChainerCV</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ChainerCV: bibliothèque pour l'apprentissage en profondeur et la vision par ordinateur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation Keras</a> </li></ul><br>  Guides d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CNN pour la reconnaissance visuelle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide du débutant CNN</a> </li></ul><br><h2>  Réseaux de neurones récurrents (RNN) </h2><br>  Les RNN modélisent les séquences en appliquant récursivement le même ensemble de poids à l'état de l'agrégateur au temps t et à l'entrée au temps t.  Les RNN purs sont rarement utilisés actuellement, mais ses analogues, par exemple, LSTM et GRU, sont les plus modernes dans la plupart des tâches de modélisation de séquence.  LSTM, qui est utilisé à la place d'une simple couche dense en RNN pur. <br><br><img src="https://habrastorage.org/webt/qn/g3/-b/qng3-bibabexlnufcac1i3edeaa.png" alt="image"><br><br>  Utilisez RNN pour toute tâche de classification de texte, de traduction automatique, de modélisation de langage. <br><br>  Liens utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèles et exemples créés avec TensorFlow</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Référence de classification de texte dans PyTorch</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Système de traduction open source</a> </li></ul><br>  Guides d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprentissage en profondeur pour le traitement des langues de Stanford</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Articles RNN</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre LSTM</a> </li></ul><br><h2>  Champs aléatoires conditionnels (CRF) </h2><br>  Ils sont utilisés pour la modélisation de séquences, comme les RNN, et peuvent être utilisés en combinaison avec des RNN.  Ils peuvent également être utilisés dans d'autres tâches de prévision structurée, par exemple, dans la segmentation d'images.  CRF modélise chaque élément d'une séquence (par exemple, une phrase) de sorte que les voisins influencent l'étiquette d'un composant dans la séquence, et non toutes les étiquettes qui sont indépendantes les unes des autres. <br><br>  Utilisez CRF pour lier des séquences (dans le texte, l'image, les séries chronologiques, l'ADN, etc.). <br><br>  Lien utile: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn-crfsuite</a> </li></ul><br>  Guides d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction aux champs aléatoires conditionnels</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liste de lecture YouTube pour les champs aléatoires conditionnels</a> </li></ul><br><h2>  Arbres de décision et forêts aléatoires </h2><br>  L'un des algorithmes d'apprentissage automatique les plus courants.  Utilisé dans les statistiques et l'analyse des données pour les modèles de prévision.  La structure est «feuilles» et «branches».  Les attributs dont dépend la fonction objectif sont enregistrés sur les «branches» de l'arbre de décision, les valeurs de la fonction objectif sont écrites dans les «feuilles» et les attributs qui distinguent les cas sont enregistrés dans les nœuds restants. <br><br>  Pour classer un nouveau cas, vous devez descendre l'arborescence jusqu'à la feuille et émettre la valeur correspondante.  L'objectif est de créer un modèle qui prédit la valeur de la variable cible en fonction de plusieurs variables d'entrée. <br><br>  Liens utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.ensemble.RandomForestClassifier</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sklearn.ensemble.GradientBoostingClassifier</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation XGBoost</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation CatBoost</a> </li></ul><br>  Guides d'introduction: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction aux arbres de décision</a> </li><li>  <a href="">Comprendre les forêts aléatoires: de la théorie à la pratique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">XGBoost en Python</a> </li></ul><br>  Vous en apprendrez plus sur l'apprentissage automatique et la science des données en vous abonnant à mon compte sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Habré</a> et sur la chaîne Telegram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Neuron</a> .  Ne sautez pas les futurs articles. <br><br>  Toutes les connaissances! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467825/">https://habr.com/ru/post/fr467825/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467813/index.html">Révision des changements dans le 17e ordre du FSTEC</a></li>
<li><a href="../fr467815/index.html">Les médias ont paniqué que "les adresses IP s'épuisent en Russie". Comment vraiment?</a></li>
<li><a href="../fr467817/index.html">Un peu sur les modèles de conception génératifs</a></li>
<li><a href="../fr467821/index.html">Simplifiez et éliminez les besoins: entretien avec John Romero, créateur de Doom</a></li>
<li><a href="../fr467823/index.html">Analyse: MOO sur Kubernetes</a></li>
<li><a href="../fr467827/index.html">Comment nous avons fait notre petite unité à partir de zéro</a></li>
<li><a href="../fr467831/index.html">La voie épineuse de la programmation</a></li>
<li><a href="../fr467837/index.html">MCU «Terrible» à trois cents - un bref aperçu des microcontrôleurs coûtant moins de 0,1 $</a></li>
<li><a href="../fr467841/index.html">Rendez-vous plus facile: Entretien avec John Romero, développeur de Doom</a></li>
<li><a href="../fr467843/index.html">Comment économiser jusqu'à un demi-million de dollars en AWS?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>