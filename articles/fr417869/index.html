<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚕️ 🕯️ 🌆 Comment déboguer WebRTC 💐 🐳 🛵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chez Voximplant, nous utilisons WebRTC depuis sa création: d'abord comme alternative à Flash pour les appels vocaux et vidéo, puis comme remplacement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment déboguer WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/417869/">  Chez Voximplant, nous utilisons WebRTC depuis sa création: d'abord comme alternative à Flash pour les appels vocaux et vidéo, puis comme remplacement complet.  La technologie a parcouru un chemin de développement long et douloureux, ce n'est que récemment que tous les principaux navigateurs ont commencé à la prendre en charge, il y a des difficultés avec le transfert d'écran, plusieurs flux vidéo et parfois le navigateur se bloque simplement si vous désactivez et activez le flux vidéo.  L'expérience accumulée nous permet de traduire des articles intéressants pour Habr, et aujourd'hui nous passons le mot à Lee Sylvester de Xirsys, qui parlera de débogage (vidéo) des appels dans Chrome, Firefox, Safari et Edge.  Le débogage de WebRTC n'est pas facile, nous avons même des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instructions</a> spéciales pour supprimer les journaux dans les navigateurs populaires.  Et ce que Lee a - vous le découvrirez sous la coupe (spoiler: beaucoup de tout, y compris WireShark). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/yz/h0/cfyzh02gdgxjvmew9ifyv8p9iju.jpeg"></div><a name="habracut"></a><br><h2>  Le côté obscur de WebRTC </h2><br>  En travaillant chez Xirsys, j'ai vu des applications vraiment cool qui utilisaient WebRTC.  Mais alors qu'un petit groupe de développeurs crée des trucs de haute technologie, la plupart des programmeurs ne peuvent même pas commencer à utiliser WebRTC.  Pourquoi?  Et tout est simple.  C'est compliqué. <br><br>  Beaucoup d'entre nous connaissent une application Web typique.  Une telle application a un client qui envoie des requêtes et un serveur qui répond à ces requêtes.  Un processus simple, linéaire et facilement prévisible.  En cas de problème, nous savons généralement où consulter les journaux et ce qui pourrait arriver.  Mais avec WebRTC, tout n'est pas si simple. <br><br><h2>  Asynchronie </h2><br>  Si vous avez déjà écrit une application multi-thread, vous connaissez probablement le mal de tête que ce développement apporte.  Vols, mauvaise mémoire - mais le plus souvent seulement des bugs difficiles à trouver. <br><br>  WebRTC est de nature asynchrone.  Et ce n'est pas du tout la simple asynchronie AJAX.  Pour faire une analogie, ce sont plusieurs requêtes AJAX lancées simultanément qui tentent de réconcilier les données sur deux ordinateurs.  C'est toujours du divertissement. <br><br><h2>  Champ de mines de contournement NAT </h2><br>  La création d'applications Web revient à développer quelque chose qui s'exécute sur le serveur et répond aux demandes.  La pire chose qui puisse arriver est le port qui n'est pas ouvert dans IPTables.  Il est traité en 2 minutes.  Vous ne pouvez pas dire sur WebRTC. <br><br>  Les serveurs Web, pas même leurs logiciels, mais leur matériel, sont des appareils avec des adresses IP publiques.  Ils sont faits pour être accessibles de partout.  Et WebRTC est conçu pour envoyer et recevoir des données à partir des ordinateurs des utilisateurs.  Qui ont généralement une adresse IP de 192.168. Quelque chose et ne brûle pas avec le désir de répondre aux demandes du réseau. <br><br>  Les auteurs de WebRTC le savent, de sorte que le moteur triera différentes méthodes de connexion, dans le but d'établir une connexion entre deux ordinateurs qui ne sont pas très conçus pour cela. <br><br><h2>  Par où commencer le débogage </h2><br>  Dans cet article, je parle des outils de base pour résoudre les problèmes les plus courants.  Mais avant cela, voyons comment WebRTC établit généralement une connexion. <br><br><h2>  Comment WebRTC établit une connexion </h2><br>  Toutes les connexions WebRTC nécessitent un peu d'aide du protocole de signalisation.  «Peu d'aide» est votre propre serveur et protocole avec lequel l'appelant pourra communiquer avec la personne qu'il appelle avant d'établir une connexion d'égal à égal. <br><br>  WebRTC utilisera le protocole de signalisation pour transmettre des informations sur les adresses IP, la capacité de capturer et de lire la voix et la vidéo, la topologie du réseau et les données transmises. <br><br>  Le protocole couramment utilisé est COMET (ou SIP - note du traducteur) et les sockets Web.  WebRTC ne limite pas les développeurs à quoi que ce soit, vous pouvez donc utiliser ce que vous voulez, au moins transférer des données via le Bloc-notes et copier-coller (fait dans l'un des ateliers, cela fonctionne - encore une fois un traducteur).  La signalisation connectée aux deux ordinateurs vous permet de démarrer une connexion déjà via WebRTC. <br><br><h4>  Offrir et répondre </h4><br>  Les connexions WebRTC utilisent "offre" et "réponse": <br><br><ol><li>  L'initiateur de la connexion crée et passe à l'autre côté «offre». </li><li>  L'autre partie reçoit une «offre», crée une «réponse» et la renvoie. </li><li>  L'initiateur de la connexion reçoit une «réponse». </li></ol><br>  C'est en théorie.  Dans la pratique, l'échange de courtoisies n'est pas si simple. <br><br><ol><li>  Avant de transmettre «offre», l'initiateur de connexion crée une instance de <b>RTCPeerConnection</b> et en reçoit le paquet de texte «SDP» (Session Description Protocol) à l'aide de <b>rtcPeerConnection.createOffer ()</b> ;  Ce package décrit la capacité de recevoir / transmettre de la voix et de la vidéo pour le navigateur. </li><li>  Le contenu du package SDP est défini comme «description du côté local de la connexion» à l'aide de <b>rtcPeerConnection.setLocalDescription ()</b> . </li><li>  Le paquet est envoyé à l'autre côté, où son contenu est défini comme «la description de l'autre côté de la connexion» à l'aide de <b>rtcPeerConnection.setRemoteDescription ()</b> . </li><li>  De l'autre côté de la connexion, son propre package SDP est créé à l'aide de <b>rtcPeerConnection.createAnswer ()</b> , son contenu est défini comme la «description du côté local de la connexion». </li><li>  Le paquet est transmis à l'initiateur de la connexion, qui définit son contenu comme «une description de l'autre côté de la connexion». </li></ol><br>  Et seulement après toutes les actions, les deux parties connectées connaissent leurs capacités respectives de réception et d'envoi de voix / vidéo. <br><br><h4>  Candidats ICE </h4><br>  Mais la capacité de travailler avec les médias ne suffit pas.  Après tout, les parties contractantes n'ont encore rien dit sur l'état du réseau. <br><br>  Vous pouvez savoir quels codecs vidéo le navigateur prend en charge et s'il y a une caméra sur l'ordinateur portable presque instantanément.  Il faut du temps pour connaître votre adresse IP externe et la logique de fonctionnement NAT, et les informations sur l'état du réseau sont échangées à mesure que ces informations sont reçues. <br><br>  Grâce à la technologie Trickle ICE (non prise en charge par tous les navigateurs - note du traducteur), la connexion entre deux appareils WebRTC peut être établie à tout moment - dès qu'un «candidat» approprié est trouvé. <br><br>  Le développeur doit s'abonner à l'événement <b>onicecandidate</b> (tout en minuscules!) Et passer les paquets SDP reçus de l'autre côté, où ils doivent être transmis par WebRTC en utilisant la méthode <b>addIceCandidate</b> (et ici, surprise, majuscule).  Cela fonctionne dans les deux sens. <br><br><h2>  Connexion </h2><br>  WebRTC utilise des éléments comme STUN (Session Traversal Utilities for NAT) et TURN (Traversal Using Relay around NAT) pour établir une connexion.  Cela semble effrayant, mais en réalité, il n'y a que deux protocoles réseau. <br><br><h4>  Serveur STUN </h4><br>  Le premier des deux protocoles est un peu plus compliqué que le serveur d'écho.  Lors de la connexion, les participants veulent décrire comment s'y connecter, ils ont besoin de leur adresse IP publique.  Et ce ne sera probablement pas l'adresse IP de l'ordinateur, les appareils publics sont rarement attribués aux appareils des utilisateurs.  Toute la technologie NAT a été inventée pour ne pas isoler.  Pour connaître toujours votre adresse publique, le navigateur fait une demande au serveur STUN.  En passant par NAT, le paquet réseau change son adresse de retour en public.  Après avoir reçu le paquet avec la demande, le serveur STUN copie l'adresse de retour du paquet dans sa charge utile et renvoie le paquet.  En passant par NAT dans la direction opposée, le paquet perd son adresse IP publique, mais une copie de cette adresse reste dans la charge utile, où WebRTC peut la lire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/vo/8r/qhvo8rafhc4akmapxnb7vtni2pe.png"></div><br><h2>  Serveur TURN </h2><br>  Le serveur TURN utilise l'extension de protocole STUN.  Les mêmes packages, en-têtes et une nouveauté: la <b>commande</b> .  Le serveur est un proxy: les deux clients s'y connectent via le port d' <b>allocation</b> UDP et transmettent leurs données via le serveur. <br><br>  Les serveurs TURN sont conçus de telle manière que l'initiateur de la connexion possède plus de fonctionnalités que l'autre côté.  Cela conduit à un effet intéressant lorsqu'un appel via un serveur TURN est réussi ou échoué, selon qui appelle qui (rappelez-vous tous Skype - traducteur de notes). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/07/j6/qq/07j6qqsbyc7fod_yx2vuk_9zctu.png"></div><br><h2>  Débogage </h2><br>  Donc, vous lisez ce paragraphe.  Nous sommes satisfaits du traducteur et rappelons que l'article concerne le débogage de WebRTC.  Mais tout ce qui précède est un minimum nécessaire, sans lequel vous ne pouvez même pas commencer.  Mais si vous commencez et que vous n'avez pas de chance inhumaine, alors cela se cassera. <br><br>  Il se brisera de différentes manières.  Le premier est le manque de connectivité.  Vous avez transmis les paramètres de serveur STUN et TURN aux deux WebRTC, les avez aidés à échanger des offres, des réponses et des candidats ICE, mais il n'y a ni vidéo ni voix.  Par où commencer?  Avec des problèmes de lecture locale. <br><br><h2>  Débogage local WebRTC </h2><br>  Comme je l'ai écrit ci-dessus, le travail principal de WebRTC se produit du côté du navigateur.  Les serveurs STUN et TURN sont incroyablement simples, donc la plupart des problèmes se produisent dans votre code JavaScript, qui s'exécute dans deux navigateurs.  Triste mais vrai.  D'un autre côté, si la chose la plus intéressante se produit localement dans les navigateurs, vous avez amplement l'occasion de déboguer! <br><br>  La première chose à vérifier est votre signalisation.  C'est votre code qui transmet la configuration de l'audio avec la vidéo (offre, réponse) et les informations sur les paramètres réseau (candidats Ice) entre les navigateurs.  Vous devez vérifier quels paquets ont été envoyés, lesquels ont reçu et transmis WebRTC: <br><br><ul><li>  l'autre côté de la connexion a reçu une offre?  L'initiateur de la connexion a-t-il reçu une réponse?  Une connexion ne sera pas établie sans cet échange minimal de commodités; </li><li>  WebRTC aux deux extrémités de la connexion vous at-il transmis des paquets avec des candidats ICE?  Avez-vous échangé ces paquets et les avez-vous renvoyés de l'autre côté en utilisant <b>addIceCandidate</b> ? </li><li>  si tout s'est bien passé avec l'échange de paquets, le <b>gestionnaire d'</b> événement <b>onaddstream</b> a-t-il été <b>appelé</b> et avez-vous installé l'objet résultant dans un élément HTML pour lire la vidéo (ou l'audio)? </li></ul><br>  Si l'échange de paquets n'est pas suspect, vous pouvez plonger dans les tripes de la session. <br><br><h2>  Protocole de description de session </h2><br>  Les packages d'offres, de réponses et de candidats ICE sont créés par WebRTC au format texte SDP.  À première vue, le contenu des packages semble effrayant, mais avec un peu de préparation, vous pouvez en tirer beaucoup d'avantages lors du débogage.  Wikipedia décrit assez bien le SDP, mais j'ai trouvé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">meilleure description</a> pour vous. <br><br>  Le champ le plus important dans les paquets SDP ICE candidats est <b>typ</b> .  Pour WebRTC, un champ peut avoir l'une des trois valeurs suivantes: <br><br><ul><li>  hôte de type; </li><li>  typ srflx; </li><li>  relais de type. </li></ul><br><h4>  hôte de type </h4><br>  Le type d' <b>hôte</b> spécifie le candidat ICE pour une connexion locale (WebRTC énumère plusieurs candidats dans l'espoir d'établir une connexion, on ne sait pas à l'avance lequel se révélera - note du traducteur).  Une telle connexion ne nécessite ni serveur STUN ni serveur TURN, car les périphériques du réseau local peuvent souvent établir directement des connexions réseau.  Lors du débogage à partir du réseau local, il vous suffit de vérifier et de déboguer la transmission des paquets <b>hôtes</b> et de vous assurer que les périphériques peuvent s’envoyer des paquets UDP.  Bien qu'il y ait des exceptions, dans la pratique, j'ai vu des configurations de réseau dans lesquelles le navigateur avait besoin d'un serveur TURN pour se connecter ... à lui-même. <br><br><h4>  typ srflx </h4><br>  La combinaison des lettres «srflx» signifie «Server Reflexive» et marque les candidats à la connexion en utilisant une adresse IP externe, où un serveur STUN est suffisant pour la connexion (en utilisant la technologie de pénétration NAT, qui réussit dans environ 80% des cas, note le traducteur). <br><br><h4>  relais type </h4><br>  «Relay» marque la connexion via un serveur TURN, qui est presque toujours réussie.  Il est important de se rappeler que WebRTC n'est pas requis pour créer exactement trois packages différents avec le champ «typ»;  la façon dont les candidats sont sélectionnés dépend de l'implémentation de WebRTC dans une version de navigateur spécifique. <br><br><h2>  Test de la connectivité des appareils </h2><br>  Google propose une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application Web</a> dédiée pour tester les connexions WebRTC sur votre appareil.  Ouvrez la page, cliquez sur le bouton "Démarrer" et le code JavaScript tentera d'établir une connexion avec le serveur Google en utilisant la signalisation, les serveurs STUN et TURN de Google. <br><br><h2>  Internes WebRTC </h2><br>  Vous avez examiné tous les packages, vérifié le code, tout semble correct, mais cela ne fonctionne pas?  Pour de tels cas, Google a fourni à son navigateur Chrome une section spéciale qui montre les composants internes de WebRTC pendant la configuration de la connexion et quelques beaux graphiques en cas de connexion réussie.  Pour l'utiliser, ouvrez un lien technique spécial dans le navigateur: <br><br> <code>chrome://webrtc-internals</code> <br> <br>  Si vous avez déjà une application utilisant WebRTC ouverte, vous verrez immédiatement un tas de données techniques.  Sinon, ouvrez simplement un autre onglet et il y a quelque chose qui utilise WebRTC.  L'onglet affiche tous les appels à l'objet <b>RTCPeerConnection</b> et vous permet de voir en temps réel comment la connexion est établie. <br><br><h2>  Configuration ICE </h2><br>  En haut de la page se trouve la chaîne ICE qui a été utilisée pour initialiser la connexion.  Si une erreur a été commise lors de sa formation, elle sera immédiatement visible (par la "ligne ICE" l'auteur se réfère à la configuration de l'objet RTCPeerConnection avec une liste de serveurs STUN et TURN (l'objet 'iceServers') - note du traducteur).  Peut-être qu'il n'y a pas de liste de serveurs?  Vous devez configurer l'objet RTCPeerConnection avant d'effectuer le premier appel à <b>createOffer</b> ou <b>createAnswer</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/hz/xo/lohzxoou7x8sbrhqfwuruhcwsw4.png"></div><br><h2>  Événements RTCPeerConnection </h2><br>  La section interne suivante montre les appels aux méthodes <b>RTCPeerConnection</b> et les événements reçus de l'objet dans l'ordre chronologique.  Les erreurs sont soigneusement mises en évidence en rouge.  Veuillez noter que le rouge <b>addIceCandidateFailed n'est</b> souvent pas un signe d'erreur et que la connexion peut s'établir normalement.  Si la connexion réussit, le dernier événement de la liste sera un événement <b>iceconnectionstatechange</b> avec la valeur <b>complete</b> . <br><br><h2>  Section 'stats' </h2><br>  La section suivante est pertinente lorsque la connexion est établie avec succès.  Il contient des statistiques sur les données transmises et les retards du réseau.  Les deux options les plus intéressantes sont: <b>ssrc</b> et <b>bweforvideo</b> . <br><br><ul><li>  <b>ssrc</b> , "Stream Source", marque chacune de vos pistes audio et vidéo.  Affiche les statistiques des données transmises et des paramètres tels que le temps d' <b>aller-retour</b> ; </li><li>  <b>bweforvideo</b> , BandWidth Estimate, affiche la largeur du canal réseau utilisé. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/9e/wt/te9ewt2nl26jhbezdqj3_rkr8d4.png"></div><br><h2>  Fonction GetStats </h2><br>  Souvent, vous ne pourrez pas accéder à la page des internes.  Par exemple, lorsqu'un problème survient avec votre utilisateur.  Dans ce cas, vous pouvez obtenir les mêmes données que la page des éléments internes montre en appelant la méthode <b>getStats</b> sur l'objet <b>RTCPeerConnection</b> .  Cette méthode met en place une fonction de rappel que WebRTC appellera chaque fois que quelque chose d'intéressant se produit.  La fonction appelée obtient un objet avec les champs que la page interne affiche: <br><br><pre> <code class="javascript hljs">rtcPeerConnection.getStats(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"lostpackets"</span></span>).innerText = stats.packetsLost; });</code> </pre><br>  Un autre outil utile est l'événement <b>oniceconnectionstatechange</b> d'un objet <b>RTCPeerConnection</b> .  Le gestionnaire d'événements recevra des informations sur la progression de la connexion.  Options possibles: <br><br><ul><li>  <b>nouveau</b> : WebRTC attend des candidats du deuxième côté de la connexion, qui doit être ajouté à l'aide de la méthode <b>addIceCandidate</b> ; </li><li>  <b>vérification</b> : WebRTC a reçu les candidats du deuxième côté de la connexion, les compare avec les candidats locaux et répète les options; </li><li>  <b>connecté</b> : une paire de candidats appropriée est sélectionnée et la connexion est établie.  Il est à noter qu'après cela, les candidats peuvent continuer à venir, conformément au protocole Trickle ICE; </li><li>  <b>terminé</b> : tous les candidats sont reçus et la connexion est établie. </li><li>  <b>déconnecté</b> : la connexion est <b>déconnectée</b> .  Sur les canaux instables WebRTC est capable de se reconnecter, nous surveillons l'indicateur <b>connecté</b> ; </li><li>  <b>fermée</b> : la connexion est déconnectée et WebRTC ne fonctionne plus avec elle. </li></ul><br>  Si la connexion s'est terminée dans l'état <b>défaillant</b> , alors nous pouvons examiner les candidats reçus des deux côtés et comprendre pourquoi la connexion a échoué.  Par exemple, si un côté a fourni <b>des</b> <b>candidats</b> <b>hôte</b> et <b>srflx</b> , l'autre côté <b>hôte</b> et <b>relais</b> , mais les périphériques étaient sur des réseaux différents. <br><br><h2>  Rectangle noir au lieu de la vidéo </h2><br>  Il y a souvent une situation où la connexion est établie, le son est transmis, mais au lieu de la vidéo, un ou les deux participants ont un rectangle noir.  Le plus souvent, cela se produit si vous affectez l'objet vidéo reçu à un élément HTML avant que la connexion ne passe à l'état <b>terminé</b> . <br><br><h2>  Comment pousser une baguette à l'extérieur </h2><br>  En plus de l'objet <b>RTCPeerConnection lui</b> - <b>même</b> et des éléments internes affichés par le navigateur, vous pouvez utiliser des outils d'analyse de paquets réseau tels que Wireshark.  Ces outils peuvent afficher des paquets de protocoles WebRTC utilisés.  Par exemple, Wireshark vous montrera le contenu des paquets STUN dans la fenêtre principale, et vous pouvez les filtrer en tapant le mot clé "stun" dans le champ de filtre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/89/jf/c489jf68awl5u25fah6xnv8piee.png"></div><br>  Que regarder dans les réponses du serveur?  Si vous ne voyez que des réponses de type <b>Liaison</b> , cela signifie que seul STUN (conversation IP externe) est pris en charge et WebRTC ne peut proposer que des candidats <b>srflx</b> .  Si les réponses contiennent l' <b>allocation de</b> packages spécifiques à TURN et <b>CreatePermission</b> , WebRTC aura la possibilité d'essayer de se connecter via un serveur proxy.  L'analyseur de paquets marque l' <b>allocation</b> réussie et non réussie.  S'il n'y en a pas un, il est probable que les mauvais paramètres d'accès aux serveurs TURN (qui se protègent presque toujours avec un nom d'utilisateur et un mot de passe - la note du traducteur) soient transmis. <br><br>  S'il y a un <b>package CreatePermission Success Response</b> dans le journal, nous pouvons supposer que tout va bien avec les configurations STUN et TURN.  Et s'il existe également un package <b>ChannelBind</b> , il était possible d'établir une connexion au serveur TURN à grande vitesse. <br><br><h2>  Problèmes cellulaires </h2><br>  Dans ma pratique, de nombreuses solutions WebRTC qui établissent une connexion WiFi ne peuvent pas se connecter via 3G / 4G.  Une application lancée sur un appareil mobile est plus difficile à déboguer: nous n'avons pas un analyseur de paquets aussi simple que Wireshark, et Safari ne peut pas afficher les internes de WebRTC.  La logique suggère que si l'application fonctionne correctement via WiFi, le problème ne vient pas de l'application elle-même, mais de la communication cellulaire.  Comment déboguer?  Prenez un ordinateur portable et connectez-y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dongle 3G</a> .  Vous disposez donc d'un analyseur de paquets et de journaux pratiques avec lesquels vous pouvez trouver la racine de tous les problèmes dans un délai raisonnable. <br><br><h2>  Conclusions </h2><br>  Le débogage de WebRTC n'est pas facile, mais si vous recherchez bien sur Internet, vous pouvez trouver de nombreux articles et exemples.  Si vous travaillez dans le domaine des communications en temps réel, je vous recommande de lire les spécifications RFC pour les protocoles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">STUN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TURN</a> et la technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebRTC</a> .  Les documents sont volumineux, mais les informations qu'ils contiennent aident à prendre des décisions fiables et à répondre à la question «pourquoi ça ne sonne pas». </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417869/">https://habr.com/ru/post/fr417869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417859/index.html">Intégration 3CX avec Microsoft Dynamics 365</a></li>
<li><a href="../fr417861/index.html">Motif premier sans fin</a></li>
<li><a href="../fr417863/index.html">Les enfants à commander bientôt? Le UK Ethics Council autorise le génie génétique des embryons humains</a></li>
<li><a href="../fr417865/index.html">Accessibilité Android - un loup déguisé en mouton? Conférence Yandex</a></li>
<li><a href="../fr417867/index.html">Comment évaluer la durée d'un projet informatique et quand cela ne vaut pas la peine de le faire</a></li>
<li><a href="../fr417871/index.html">À la ligne d'arrivée du tourisme suborbital</a></li>
<li><a href="../fr417873/index.html">Façons de créer des fenêtres pop-up</a></li>
<li><a href="../fr417875/index.html">Sortir du spa Rabbit Hole avec des rails modernes</a></li>
<li><a href="../fr417877/index.html">Comment Tinder cache (légèrement) votre position</a></li>
<li><a href="../fr417879/index.html">Comment passer des examens de Microsoft gratuitement [par exemple, un récent concours]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>