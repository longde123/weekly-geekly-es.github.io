<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öïÔ∏è üïØÔ∏è üåÜ Comment d√©boguer WebRTC üíê üê≥ üõµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chez Voximplant, nous utilisons WebRTC depuis sa cr√©ation: d'abord comme alternative √† Flash pour les appels vocaux et vid√©o, puis comme remplacement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment d√©boguer WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/417869/">  Chez Voximplant, nous utilisons WebRTC depuis sa cr√©ation: d'abord comme alternative √† Flash pour les appels vocaux et vid√©o, puis comme remplacement complet.  La technologie a parcouru un chemin de d√©veloppement long et douloureux, ce n'est que r√©cemment que tous les principaux navigateurs ont commenc√© √† la prendre en charge, il y a des difficult√©s avec le transfert d'√©cran, plusieurs flux vid√©o et parfois le navigateur se bloque simplement si vous d√©sactivez et activez le flux vid√©o.  L'exp√©rience accumul√©e nous permet de traduire des articles int√©ressants pour Habr, et aujourd'hui nous passons le mot √† Lee Sylvester de Xirsys, qui parlera de d√©bogage (vid√©o) des appels dans Chrome, Firefox, Safari et Edge.  Le d√©bogage de WebRTC n'est pas facile, nous avons m√™me des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instructions</a> sp√©ciales pour supprimer les journaux dans les navigateurs populaires.  Et ce que Lee a - vous le d√©couvrirez sous la coupe (spoiler: beaucoup de tout, y compris WireShark). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/yz/h0/cfyzh02gdgxjvmew9ifyv8p9iju.jpeg"></div><a name="habracut"></a><br><h2>  Le c√¥t√© obscur de WebRTC </h2><br>  En travaillant chez Xirsys, j'ai vu des applications vraiment cool qui utilisaient WebRTC.  Mais alors qu'un petit groupe de d√©veloppeurs cr√©e des trucs de haute technologie, la plupart des programmeurs ne peuvent m√™me pas commencer √† utiliser WebRTC.  Pourquoi?  Et tout est simple.  C'est compliqu√©. <br><br>  Beaucoup d'entre nous connaissent une application Web typique.  Une telle application a un client qui envoie des requ√™tes et un serveur qui r√©pond √† ces requ√™tes.  Un processus simple, lin√©aire et facilement pr√©visible.  En cas de probl√®me, nous savons g√©n√©ralement o√π consulter les journaux et ce qui pourrait arriver.  Mais avec WebRTC, tout n'est pas si simple. <br><br><h2>  Asynchronie </h2><br>  Si vous avez d√©j√† √©crit une application multi-thread, vous connaissez probablement le mal de t√™te que ce d√©veloppement apporte.  Vols, mauvaise m√©moire - mais le plus souvent seulement des bugs difficiles √† trouver. <br><br>  WebRTC est de nature asynchrone.  Et ce n'est pas du tout la simple asynchronie AJAX.  Pour faire une analogie, ce sont plusieurs requ√™tes AJAX lanc√©es simultan√©ment qui tentent de r√©concilier les donn√©es sur deux ordinateurs.  C'est toujours du divertissement. <br><br><h2>  Champ de mines de contournement NAT </h2><br>  La cr√©ation d'applications Web revient √† d√©velopper quelque chose qui s'ex√©cute sur le serveur et r√©pond aux demandes.  La pire chose qui puisse arriver est le port qui n'est pas ouvert dans IPTables.  Il est trait√© en 2 minutes.  Vous ne pouvez pas dire sur WebRTC. <br><br>  Les serveurs Web, pas m√™me leurs logiciels, mais leur mat√©riel, sont des appareils avec des adresses IP publiques.  Ils sont faits pour √™tre accessibles de partout.  Et WebRTC est con√ßu pour envoyer et recevoir des donn√©es √† partir des ordinateurs des utilisateurs.  Qui ont g√©n√©ralement une adresse IP de 192.168. Quelque chose et ne br√ªle pas avec le d√©sir de r√©pondre aux demandes du r√©seau. <br><br>  Les auteurs de WebRTC le savent, de sorte que le moteur triera diff√©rentes m√©thodes de connexion, dans le but d'√©tablir une connexion entre deux ordinateurs qui ne sont pas tr√®s con√ßus pour cela. <br><br><h2>  Par o√π commencer le d√©bogage </h2><br>  Dans cet article, je parle des outils de base pour r√©soudre les probl√®mes les plus courants.  Mais avant cela, voyons comment WebRTC √©tablit g√©n√©ralement une connexion. <br><br><h2>  Comment WebRTC √©tablit une connexion </h2><br>  Toutes les connexions WebRTC n√©cessitent un peu d'aide du protocole de signalisation.  ¬´Peu d'aide¬ª est votre propre serveur et protocole avec lequel l'appelant pourra communiquer avec la personne qu'il appelle avant d'√©tablir une connexion d'√©gal √† √©gal. <br><br>  WebRTC utilisera le protocole de signalisation pour transmettre des informations sur les adresses IP, la capacit√© de capturer et de lire la voix et la vid√©o, la topologie du r√©seau et les donn√©es transmises. <br><br>  Le protocole couramment utilis√© est COMET (ou SIP - note du traducteur) et les sockets Web.  WebRTC ne limite pas les d√©veloppeurs √† quoi que ce soit, vous pouvez donc utiliser ce que vous voulez, au moins transf√©rer des donn√©es via le Bloc-notes et copier-coller (fait dans l'un des ateliers, cela fonctionne - encore une fois un traducteur).  La signalisation connect√©e aux deux ordinateurs vous permet de d√©marrer une connexion d√©j√† via WebRTC. <br><br><h4>  Offrir et r√©pondre </h4><br>  Les connexions WebRTC utilisent "offre" et "r√©ponse": <br><br><ol><li>  L'initiateur de la connexion cr√©e et passe √† l'autre c√¥t√© ¬´offre¬ª. </li><li>  L'autre partie re√ßoit une ¬´offre¬ª, cr√©e une ¬´r√©ponse¬ª et la renvoie. </li><li>  L'initiateur de la connexion re√ßoit une ¬´r√©ponse¬ª. </li></ol><br>  C'est en th√©orie.  Dans la pratique, l'√©change de courtoisies n'est pas si simple. <br><br><ol><li>  Avant de transmettre ¬´offre¬ª, l'initiateur de connexion cr√©e une instance de <b>RTCPeerConnection</b> et en re√ßoit le paquet de texte ¬´SDP¬ª (Session Description Protocol) √† l'aide de <b>rtcPeerConnection.createOffer ()</b> ;  Ce package d√©crit la capacit√© de recevoir / transmettre de la voix et de la vid√©o pour le navigateur. </li><li>  Le contenu du package SDP est d√©fini comme ¬´description du c√¥t√© local de la connexion¬ª √† l'aide de <b>rtcPeerConnection.setLocalDescription ()</b> . </li><li>  Le paquet est envoy√© √† l'autre c√¥t√©, o√π son contenu est d√©fini comme ¬´la description de l'autre c√¥t√© de la connexion¬ª √† l'aide de <b>rtcPeerConnection.setRemoteDescription ()</b> . </li><li>  De l'autre c√¥t√© de la connexion, son propre package SDP est cr√©√© √† l'aide de <b>rtcPeerConnection.createAnswer ()</b> , son contenu est d√©fini comme la ¬´description du c√¥t√© local de la connexion¬ª. </li><li>  Le paquet est transmis √† l'initiateur de la connexion, qui d√©finit son contenu comme ¬´une description de l'autre c√¥t√© de la connexion¬ª. </li></ol><br>  Et seulement apr√®s toutes les actions, les deux parties connect√©es connaissent leurs capacit√©s respectives de r√©ception et d'envoi de voix / vid√©o. <br><br><h4>  Candidats ICE </h4><br>  Mais la capacit√© de travailler avec les m√©dias ne suffit pas.  Apr√®s tout, les parties contractantes n'ont encore rien dit sur l'√©tat du r√©seau. <br><br>  Vous pouvez savoir quels codecs vid√©o le navigateur prend en charge et s'il y a une cam√©ra sur l'ordinateur portable presque instantan√©ment.  Il faut du temps pour conna√Ætre votre adresse IP externe et la logique de fonctionnement NAT, et les informations sur l'√©tat du r√©seau sont √©chang√©es √† mesure que ces informations sont re√ßues. <br><br>  Gr√¢ce √† la technologie Trickle ICE (non prise en charge par tous les navigateurs - note du traducteur), la connexion entre deux appareils WebRTC peut √™tre √©tablie √† tout moment - d√®s qu'un ¬´candidat¬ª appropri√© est trouv√©. <br><br>  Le d√©veloppeur doit s'abonner √† l'√©v√©nement <b>onicecandidate</b> (tout en minuscules!) Et passer les paquets SDP re√ßus de l'autre c√¥t√©, o√π ils doivent √™tre transmis par WebRTC en utilisant la m√©thode <b>addIceCandidate</b> (et ici, surprise, majuscule).  Cela fonctionne dans les deux sens. <br><br><h2>  Connexion </h2><br>  WebRTC utilise des √©l√©ments comme STUN (Session Traversal Utilities for NAT) et TURN (Traversal Using Relay around NAT) pour √©tablir une connexion.  Cela semble effrayant, mais en r√©alit√©, il n'y a que deux protocoles r√©seau. <br><br><h4>  Serveur STUN </h4><br>  Le premier des deux protocoles est un peu plus compliqu√© que le serveur d'√©cho.  Lors de la connexion, les participants veulent d√©crire comment s'y connecter, ils ont besoin de leur adresse IP publique.  Et ce ne sera probablement pas l'adresse IP de l'ordinateur, les appareils publics sont rarement attribu√©s aux appareils des utilisateurs.  Toute la technologie NAT a √©t√© invent√©e pour ne pas isoler.  Pour conna√Ætre toujours votre adresse publique, le navigateur fait une demande au serveur STUN.  En passant par NAT, le paquet r√©seau change son adresse de retour en public.  Apr√®s avoir re√ßu le paquet avec la demande, le serveur STUN copie l'adresse de retour du paquet dans sa charge utile et renvoie le paquet.  En passant par NAT dans la direction oppos√©e, le paquet perd son adresse IP publique, mais une copie de cette adresse reste dans la charge utile, o√π WebRTC peut la lire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/vo/8r/qhvo8rafhc4akmapxnb7vtni2pe.png"></div><br><h2>  Serveur TURN </h2><br>  Le serveur TURN utilise l'extension de protocole STUN.  Les m√™mes packages, en-t√™tes et une nouveaut√©: la <b>commande</b> .  Le serveur est un proxy: les deux clients s'y connectent via le port d' <b>allocation</b> UDP et transmettent leurs donn√©es via le serveur. <br><br>  Les serveurs TURN sont con√ßus de telle mani√®re que l'initiateur de la connexion poss√®de plus de fonctionnalit√©s que l'autre c√¥t√©.  Cela conduit √† un effet int√©ressant lorsqu'un appel via un serveur TURN est r√©ussi ou √©chou√©, selon qui appelle qui (rappelez-vous tous Skype - traducteur de notes). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/07/j6/qq/07j6qqsbyc7fod_yx2vuk_9zctu.png"></div><br><h2>  D√©bogage </h2><br>  Donc, vous lisez ce paragraphe.  Nous sommes satisfaits du traducteur et rappelons que l'article concerne le d√©bogage de WebRTC.  Mais tout ce qui pr√©c√®de est un minimum n√©cessaire, sans lequel vous ne pouvez m√™me pas commencer.  Mais si vous commencez et que vous n'avez pas de chance inhumaine, alors cela se cassera. <br><br>  Il se brisera de diff√©rentes mani√®res.  Le premier est le manque de connectivit√©.  Vous avez transmis les param√®tres de serveur STUN et TURN aux deux WebRTC, les avez aid√©s √† √©changer des offres, des r√©ponses et des candidats ICE, mais il n'y a ni vid√©o ni voix.  Par o√π commencer?  Avec des probl√®mes de lecture locale. <br><br><h2>  D√©bogage local WebRTC </h2><br>  Comme je l'ai √©crit ci-dessus, le travail principal de WebRTC se produit du c√¥t√© du navigateur.  Les serveurs STUN et TURN sont incroyablement simples, donc la plupart des probl√®mes se produisent dans votre code JavaScript, qui s'ex√©cute dans deux navigateurs.  Triste mais vrai.  D'un autre c√¥t√©, si la chose la plus int√©ressante se produit localement dans les navigateurs, vous avez amplement l'occasion de d√©boguer! <br><br>  La premi√®re chose √† v√©rifier est votre signalisation.  C'est votre code qui transmet la configuration de l'audio avec la vid√©o (offre, r√©ponse) et les informations sur les param√®tres r√©seau (candidats Ice) entre les navigateurs.  Vous devez v√©rifier quels paquets ont √©t√© envoy√©s, lesquels ont re√ßu et transmis WebRTC: <br><br><ul><li>  l'autre c√¥t√© de la connexion a re√ßu une offre?  L'initiateur de la connexion a-t-il re√ßu une r√©ponse?  Une connexion ne sera pas √©tablie sans cet √©change minimal de commodit√©s; </li><li>  WebRTC aux deux extr√©mit√©s de la connexion vous at-il transmis des paquets avec des candidats ICE?  Avez-vous √©chang√© ces paquets et les avez-vous renvoy√©s de l'autre c√¥t√© en utilisant <b>addIceCandidate</b> ? </li><li>  si tout s'est bien pass√© avec l'√©change de paquets, le <b>gestionnaire d'</b> √©v√©nement <b>onaddstream</b> a-t-il √©t√© <b>appel√©</b> et avez-vous install√© l'objet r√©sultant dans un √©l√©ment HTML pour lire la vid√©o (ou l'audio)? </li></ul><br>  Si l'√©change de paquets n'est pas suspect, vous pouvez plonger dans les tripes de la session. <br><br><h2>  Protocole de description de session </h2><br>  Les packages d'offres, de r√©ponses et de candidats ICE sont cr√©√©s par WebRTC au format texte SDP.  √Ä premi√®re vue, le contenu des packages semble effrayant, mais avec un peu de pr√©paration, vous pouvez en tirer beaucoup d'avantages lors du d√©bogage.  Wikipedia d√©crit assez bien le SDP, mais j'ai trouv√© une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">meilleure description</a> pour vous. <br><br>  Le champ le plus important dans les paquets SDP ICE candidats est <b>typ</b> .  Pour WebRTC, un champ peut avoir l'une des trois valeurs suivantes: <br><br><ul><li>  h√¥te de type; </li><li>  typ srflx; </li><li>  relais de type. </li></ul><br><h4>  h√¥te de type </h4><br>  Le type d' <b>h√¥te</b> sp√©cifie le candidat ICE pour une connexion locale (WebRTC √©num√®re plusieurs candidats dans l'espoir d'√©tablir une connexion, on ne sait pas √† l'avance lequel se r√©v√©lera - note du traducteur).  Une telle connexion ne n√©cessite ni serveur STUN ni serveur TURN, car les p√©riph√©riques du r√©seau local peuvent souvent √©tablir directement des connexions r√©seau.  Lors du d√©bogage √† partir du r√©seau local, il vous suffit de v√©rifier et de d√©boguer la transmission des paquets <b>h√¥tes</b> et de vous assurer que les p√©riph√©riques peuvent s‚Äôenvoyer des paquets UDP.  Bien qu'il y ait des exceptions, dans la pratique, j'ai vu des configurations de r√©seau dans lesquelles le navigateur avait besoin d'un serveur TURN pour se connecter ... √† lui-m√™me. <br><br><h4>  typ srflx </h4><br>  La combinaison des lettres ¬´srflx¬ª signifie ¬´Server Reflexive¬ª et marque les candidats √† la connexion en utilisant une adresse IP externe, o√π un serveur STUN est suffisant pour la connexion (en utilisant la technologie de p√©n√©tration NAT, qui r√©ussit dans environ 80% des cas, note le traducteur). <br><br><h4>  relais type </h4><br>  ¬´Relay¬ª marque la connexion via un serveur TURN, qui est presque toujours r√©ussie.  Il est important de se rappeler que WebRTC n'est pas requis pour cr√©er exactement trois packages diff√©rents avec le champ ¬´typ¬ª;  la fa√ßon dont les candidats sont s√©lectionn√©s d√©pend de l'impl√©mentation de WebRTC dans une version de navigateur sp√©cifique. <br><br><h2>  Test de la connectivit√© des appareils </h2><br>  Google propose une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application Web</a> d√©di√©e pour tester les connexions WebRTC sur votre appareil.  Ouvrez la page, cliquez sur le bouton "D√©marrer" et le code JavaScript tentera d'√©tablir une connexion avec le serveur Google en utilisant la signalisation, les serveurs STUN et TURN de Google. <br><br><h2>  Internes WebRTC </h2><br>  Vous avez examin√© tous les packages, v√©rifi√© le code, tout semble correct, mais cela ne fonctionne pas?  Pour de tels cas, Google a fourni √† son navigateur Chrome une section sp√©ciale qui montre les composants internes de WebRTC pendant la configuration de la connexion et quelques beaux graphiques en cas de connexion r√©ussie.  Pour l'utiliser, ouvrez un lien technique sp√©cial dans le navigateur: <br><br> <code>chrome://webrtc-internals</code> <br> <br>  Si vous avez d√©j√† une application utilisant WebRTC ouverte, vous verrez imm√©diatement un tas de donn√©es techniques.  Sinon, ouvrez simplement un autre onglet et il y a quelque chose qui utilise WebRTC.  L'onglet affiche tous les appels √† l'objet <b>RTCPeerConnection</b> et vous permet de voir en temps r√©el comment la connexion est √©tablie. <br><br><h2>  Configuration ICE </h2><br>  En haut de la page se trouve la cha√Æne ICE qui a √©t√© utilis√©e pour initialiser la connexion.  Si une erreur a √©t√© commise lors de sa formation, elle sera imm√©diatement visible (par la "ligne ICE" l'auteur se r√©f√®re √† la configuration de l'objet RTCPeerConnection avec une liste de serveurs STUN et TURN (l'objet 'iceServers') - note du traducteur).  Peut-√™tre qu'il n'y a pas de liste de serveurs?  Vous devez configurer l'objet RTCPeerConnection avant d'effectuer le premier appel √† <b>createOffer</b> ou <b>createAnswer</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/hz/xo/lohzxoou7x8sbrhqfwuruhcwsw4.png"></div><br><h2>  √âv√©nements RTCPeerConnection </h2><br>  La section interne suivante montre les appels aux m√©thodes <b>RTCPeerConnection</b> et les √©v√©nements re√ßus de l'objet dans l'ordre chronologique.  Les erreurs sont soigneusement mises en √©vidence en rouge.  Veuillez noter que le rouge <b>addIceCandidateFailed n'est</b> souvent pas un signe d'erreur et que la connexion peut s'√©tablir normalement.  Si la connexion r√©ussit, le dernier √©v√©nement de la liste sera un √©v√©nement <b>iceconnectionstatechange</b> avec la valeur <b>complete</b> . <br><br><h2>  Section 'stats' </h2><br>  La section suivante est pertinente lorsque la connexion est √©tablie avec succ√®s.  Il contient des statistiques sur les donn√©es transmises et les retards du r√©seau.  Les deux options les plus int√©ressantes sont: <b>ssrc</b> et <b>bweforvideo</b> . <br><br><ul><li>  <b>ssrc</b> , "Stream Source", marque chacune de vos pistes audio et vid√©o.  Affiche les statistiques des donn√©es transmises et des param√®tres tels que le temps d' <b>aller-retour</b> ; </li><li>  <b>bweforvideo</b> , BandWidth Estimate, affiche la largeur du canal r√©seau utilis√©. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/9e/wt/te9ewt2nl26jhbezdqj3_rkr8d4.png"></div><br><h2>  Fonction GetStats </h2><br>  Souvent, vous ne pourrez pas acc√©der √† la page des internes.  Par exemple, lorsqu'un probl√®me survient avec votre utilisateur.  Dans ce cas, vous pouvez obtenir les m√™mes donn√©es que la page des √©l√©ments internes montre en appelant la m√©thode <b>getStats</b> sur l'objet <b>RTCPeerConnection</b> .  Cette m√©thode met en place une fonction de rappel que WebRTC appellera chaque fois que quelque chose d'int√©ressant se produit.  La fonction appel√©e obtient un objet avec les champs que la page interne affiche: <br><br><pre> <code class="javascript hljs">rtcPeerConnection.getStats(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"lostpackets"</span></span>).innerText = stats.packetsLost; });</code> </pre><br>  Un autre outil utile est l'√©v√©nement <b>oniceconnectionstatechange</b> d'un objet <b>RTCPeerConnection</b> .  Le gestionnaire d'√©v√©nements recevra des informations sur la progression de la connexion.  Options possibles: <br><br><ul><li>  <b>nouveau</b> : WebRTC attend des candidats du deuxi√®me c√¥t√© de la connexion, qui doit √™tre ajout√© √† l'aide de la m√©thode <b>addIceCandidate</b> ; </li><li>  <b>v√©rification</b> : WebRTC a re√ßu les candidats du deuxi√®me c√¥t√© de la connexion, les compare avec les candidats locaux et r√©p√®te les options; </li><li>  <b>connect√©</b> : une paire de candidats appropri√©e est s√©lectionn√©e et la connexion est √©tablie.  Il est √† noter qu'apr√®s cela, les candidats peuvent continuer √† venir, conform√©ment au protocole Trickle ICE; </li><li>  <b>termin√©</b> : tous les candidats sont re√ßus et la connexion est √©tablie. </li><li>  <b>d√©connect√©</b> : la connexion est <b>d√©connect√©e</b> .  Sur les canaux instables WebRTC est capable de se reconnecter, nous surveillons l'indicateur <b>connect√©</b> ; </li><li>  <b>ferm√©e</b> : la connexion est d√©connect√©e et WebRTC ne fonctionne plus avec elle. </li></ul><br>  Si la connexion s'est termin√©e dans l'√©tat <b>d√©faillant</b> , alors nous pouvons examiner les candidats re√ßus des deux c√¥t√©s et comprendre pourquoi la connexion a √©chou√©.  Par exemple, si un c√¥t√© a fourni <b>des</b> <b>candidats</b> <b>h√¥te</b> et <b>srflx</b> , l'autre c√¥t√© <b>h√¥te</b> et <b>relais</b> , mais les p√©riph√©riques √©taient sur des r√©seaux diff√©rents. <br><br><h2>  Rectangle noir au lieu de la vid√©o </h2><br>  Il y a souvent une situation o√π la connexion est √©tablie, le son est transmis, mais au lieu de la vid√©o, un ou les deux participants ont un rectangle noir.  Le plus souvent, cela se produit si vous affectez l'objet vid√©o re√ßu √† un √©l√©ment HTML avant que la connexion ne passe √† l'√©tat <b>termin√©</b> . <br><br><h2>  Comment pousser une baguette √† l'ext√©rieur </h2><br>  En plus de l'objet <b>RTCPeerConnection lui</b> - <b>m√™me</b> et des √©l√©ments internes affich√©s par le navigateur, vous pouvez utiliser des outils d'analyse de paquets r√©seau tels que Wireshark.  Ces outils peuvent afficher des paquets de protocoles WebRTC utilis√©s.  Par exemple, Wireshark vous montrera le contenu des paquets STUN dans la fen√™tre principale, et vous pouvez les filtrer en tapant le mot cl√© "stun" dans le champ de filtre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/89/jf/c489jf68awl5u25fah6xnv8piee.png"></div><br>  Que regarder dans les r√©ponses du serveur?  Si vous ne voyez que des r√©ponses de type <b>Liaison</b> , cela signifie que seul STUN (conversation IP externe) est pris en charge et WebRTC ne peut proposer que des candidats <b>srflx</b> .  Si les r√©ponses contiennent l' <b>allocation de</b> packages sp√©cifiques √† TURN et <b>CreatePermission</b> , WebRTC aura la possibilit√© d'essayer de se connecter via un serveur proxy.  L'analyseur de paquets marque l' <b>allocation</b> r√©ussie et non r√©ussie.  S'il n'y en a pas un, il est probable que les mauvais param√®tres d'acc√®s aux serveurs TURN (qui se prot√®gent presque toujours avec un nom d'utilisateur et un mot de passe - la note du traducteur) soient transmis. <br><br>  S'il y a un <b>package CreatePermission Success Response</b> dans le journal, nous pouvons supposer que tout va bien avec les configurations STUN et TURN.  Et s'il existe √©galement un package <b>ChannelBind</b> , il √©tait possible d'√©tablir une connexion au serveur TURN √† grande vitesse. <br><br><h2>  Probl√®mes cellulaires </h2><br>  Dans ma pratique, de nombreuses solutions WebRTC qui √©tablissent une connexion WiFi ne peuvent pas se connecter via 3G / 4G.  Une application lanc√©e sur un appareil mobile est plus difficile √† d√©boguer: nous n'avons pas un analyseur de paquets aussi simple que Wireshark, et Safari ne peut pas afficher les internes de WebRTC.  La logique sugg√®re que si l'application fonctionne correctement via WiFi, le probl√®me ne vient pas de l'application elle-m√™me, mais de la communication cellulaire.  Comment d√©boguer?  Prenez un ordinateur portable et connectez-y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dongle 3G</a> .  Vous disposez donc d'un analyseur de paquets et de journaux pratiques avec lesquels vous pouvez trouver la racine de tous les probl√®mes dans un d√©lai raisonnable. <br><br><h2>  Conclusions </h2><br>  Le d√©bogage de WebRTC n'est pas facile, mais si vous recherchez bien sur Internet, vous pouvez trouver de nombreux articles et exemples.  Si vous travaillez dans le domaine des communications en temps r√©el, je vous recommande de lire les sp√©cifications RFC pour les protocoles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">STUN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TURN</a> et la technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebRTC</a> .  Les documents sont volumineux, mais les informations qu'ils contiennent aident √† prendre des d√©cisions fiables et √† r√©pondre √† la question ¬´pourquoi √ßa ne sonne pas¬ª. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417869/">https://habr.com/ru/post/fr417869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417859/index.html">Int√©gration 3CX avec Microsoft Dynamics 365</a></li>
<li><a href="../fr417861/index.html">Motif premier sans fin</a></li>
<li><a href="../fr417863/index.html">Les enfants √† commander bient√¥t? Le UK Ethics Council autorise le g√©nie g√©n√©tique des embryons humains</a></li>
<li><a href="../fr417865/index.html">Accessibilit√© Android - un loup d√©guis√© en mouton? Conf√©rence Yandex</a></li>
<li><a href="../fr417867/index.html">Comment √©valuer la dur√©e d'un projet informatique et quand cela ne vaut pas la peine de le faire</a></li>
<li><a href="../fr417871/index.html">√Ä la ligne d'arriv√©e du tourisme suborbital</a></li>
<li><a href="../fr417873/index.html">Fa√ßons de cr√©er des fen√™tres pop-up</a></li>
<li><a href="../fr417875/index.html">Sortir du spa Rabbit Hole avec des rails modernes</a></li>
<li><a href="../fr417877/index.html">Comment Tinder cache (l√©g√®rement) votre position</a></li>
<li><a href="../fr417879/index.html">Comment passer des examens de Microsoft gratuitement [par exemple, un r√©cent concours]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>