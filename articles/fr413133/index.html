<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏾 👩‍💻 🧑🏽 Antipatterns populaires: pagination 🤽🏼 👩🏾‍🚀 🖖🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, je m'appelle Dmitry Karlovsky et je ... n'aime pas lire des livres, car pendant que vous tournez la page, vous sortez d'une histoire fascinan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Antipatterns populaires: pagination</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413133/"><p>  Bonjour, je m'appelle Dmitry Karlovsky et je ... n'aime pas lire des livres, car pendant que vous tournez la page, vous sortez d'une histoire fascinante.  Et cela mérite une petite hésitation lorsque vous oubliez la fin de la dernière phrase de la page précédente, et vous devez revenir en arrière pour la relire.  Et si ce n'est pas si effrayant avec des livres physiques, alors avec la publication d'un serveur de repos, tout est beaucoup plus triste - après tout, il y a maintenant des données sur la page, et après une seconde, c'est complètement différent.  Réfléchissons à la façon dont cela s'est produit, qui est à blâmer et surtout - que faire. </p><br><p><img src="https://habrastorage.org/webt/v7/fn/sv/v7fnsvuaiwms-qzqkljva1dasym.png" alt="Puginateurs divers"></p><a name="habracut"></a><br><h2 id="problema">  Le problème </h2><br><p>  Nous devons donc émettre tous les messages de la requête "pagination", en commençant par les plus récents (les <strong>derniers changés par le haut</strong> ) ou dans un ordre délicat.  Tout va bien, tant que nous avons moins d'une centaine de ces messages - nous faisons simplement une sélection dans la base de données et renvoyons les données: </p><br><p>  Demande du client: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /message/<span class="hljs-type"><span class="hljs-type">text</span></span>=/</code> </pre> <br><p>  Demande de base de données: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Message <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> LICENE <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">changed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  Schéma de réponse JSON pour le client: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Array</span></span>&lt;{ <span class="hljs-attribute"><span class="hljs-attribute">id </span></span>: number , text : string }&gt;</code> </pre> <br><p>  Mais le nombre de messages augmente et nous avons les problèmes suivants: </p><br><ol><li>  Les requêtes de base de données deviennent plus lentes à mesure que davantage de données doivent être récupérées. </li><li>  L'envoi de données sur le réseau prend de plus en plus de temps. </li><li>  Le rendu de ces données sur le client s'allonge de plus en plus. </li></ol><br><p>  A partir d'un certain seuil, les retards deviennent si importants qu'il devient impossible d'utiliser notre site.  Si, bien sûr, il ne s'était pas encore couché, fatigué d'un grand nombre de lourdes demandes parallèles. </p><br><p>  La solution la plus simple, qui vient peut-être d'abord à l'esprit, et vous pouvez la trouver maintenant dans n'importe quel grille-pain - pour diffuser des données non pas en masse, mais divisées en pages.  Tout ce que nous devons faire est de simplement jeter un paramètre supplémentaire du client dans la demande de base de données: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /message/<span class="hljs-type"><span class="hljs-type">text</span></span>=/page=<span class="hljs-number"><span class="hljs-number">5</span></span>/</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Message <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> LICENE <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">changed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SKIP</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Message <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> LICENE <span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre> <br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">pageItems </span></span>: Array&lt;{ id : number , text : string }&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">totalCount</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">number</span></span> }</code> </pre> <br><p>  Eh bien, oui, nous devions toujours recompter tous les messages afin que le client puisse dessiner une liste de pages ou calculer la hauteur du défilement virtuel, mais au moins nous n'avions pas besoin d'obtenir tous ces 100500 messages de la base de données. </p><br><p>  Et tout irait bien si nous avions une sorte de forum non populaire pendant longtemps, des sujets plus pertinents.  Mais ils nous écrivent et nous écrivent, écrivent et écrivent, et pendant que l'utilisateur lit la cinquième page, la liste des messages change au-delà de la reconnaissance: de nouveaux sont ajoutés et les anciens sont supprimés.  Ainsi, nous obtenons deux types de problèmes du point de vue de l'utilisateur: </p><br><ol><li>  Sur la page suivante, des messages peuvent apparaître à nouveau qui étaient déjà sur le précédent. </li><li>  L'utilisateur ne verra pas du tout certains messages, car il a réussi à passer de la page 6 à 5 exactement entre la transition de l'utilisateur de 5 à 6. </li></ol><br><p>  De plus, nous avons toujours des problèmes de performances.  Chaque transition vers la page suivante conduit au fait que nous devons effectuer jusqu'à deux requêtes de recherche dans la base de données avec un nombre croissant d'éléments ignorés des pages précédentes. </p><br><p>  Oui, et une implémentation compétente du côté client n'est pas si simple - vous devez toujours être préparé au fait que toute réponse du serveur peut renvoyer un nouveau nombre total de messages, ce qui signifie que nous devrons redessiner le paginateur et rediriger vers une autre page si la page actuelle est soudainement est vide.  Et bien sûr, vous ne pouvez pas tomber en cas de doublons. </p><br><p>  En outre, le client doit parfois mettre à jour les résultats de la recherche, mais la charge recevra toujours les données qu'elle peut déjà avoir des demandes précédentes. </p><br><p>  Comme vous pouvez le voir, la pagination pose de nombreux problèmes.  N'y a-t-il vraiment pas de meilleure solution? </p><br><h2 id="reshenie">  Solution </h2><br><p>  Tout d'abord, notons que lorsque vous travaillez avec la base de données, il y a 2 opérations qui sont essentiellement différentes: </p><br><ol><li>  Cherchez.  Opération relativement lourde de recherche de pointeurs vers des données pour une requête. </li><li>  Échantillonnage.  Une opération relativement simple d'obtention de données. </li></ol><br><p>  Ce serait idéal: </p><br><ol><li>  Une fois la recherche et un endroit pour se souvenir de ses résultats sous la forme d'un instantané à un certain moment. </li><li>  Sélectionnez rapidement les données en petites portions selon les besoins. </li></ol><br><p>  Où stocker les instantanés?  il y a 2 options: </p><br><ol><li>  Sur le serveur.  Mais ensuite, nous les obstruons avec un tas d'ordures avec des résultats de recherche qui doivent être nettoyés au fil du temps. </li><li>  Au client.  Mais vous devez ensuite transférer immédiatement tous les instantanés au client. </li></ol><br><p>  Estimons la taille de l'instantané, qui n'est qu'une liste d'identifiants.  Il est peu probable que l'utilisateur ait eu la patience de rouler au moins 100 pages sans utiliser de filtrage et de tri.  Disons que nous avons 20 éléments par page.  Chaque identifiant n'occupera pas plus de 10 octets dans la représentation json.  Multipliez et obtenez pas plus de 20 Ko.  Et probablement beaucoup moins.  Il serait raisonnable de fixer une limite stricte sur la taille de la sortie en, disons, 1000 éléments. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /message/<span class="hljs-type"><span class="hljs-type">text</span></span>=/</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Message <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> LICENE <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">changed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;number&gt;</code> </pre> <br><p>  Désormais, le client peut dessiner au moins un paginateur, au moins un parchemin virtuel, ne demandant des données que pour les identifiants qui l'intéressent. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /message=<span class="hljs-number"><span class="hljs-number">49</span></span>,<span class="hljs-number"><span class="hljs-number">48</span></span>,<span class="hljs-number"><span class="hljs-number">47</span></span>,<span class="hljs-number"><span class="hljs-number">46</span></span>,<span class="hljs-number"><span class="hljs-number">45</span></span>,<span class="hljs-number"><span class="hljs-number">42</span></span>,<span class="hljs-number"><span class="hljs-number">41</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">39</span></span>,<span class="hljs-number"><span class="hljs-number">37</span></span>/</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Message <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> [<span class="hljs-number"><span class="hljs-number">49</span></span>,<span class="hljs-number"><span class="hljs-number">48</span></span>,<span class="hljs-number"><span class="hljs-number">47</span></span>,<span class="hljs-number"><span class="hljs-number">46</span></span>,<span class="hljs-number"><span class="hljs-number">45</span></span>,<span class="hljs-number"><span class="hljs-number">42</span></span>,<span class="hljs-number"><span class="hljs-number">41</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>,<span class="hljs-number"><span class="hljs-number">39</span></span>,<span class="hljs-number"><span class="hljs-number">37</span></span>]</code> </pre> <br><pre> <code class="hljs vbscript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt; { id : number , text : <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } | { id : number , <span class="hljs-keyword"><span class="hljs-keyword">error</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } &gt;</code> </pre> <br><p>  Ce que nous obtenons finalement: </p><br><ol><li>  API normalisée: recherchez séparément, sélectionnez les données séparément. </li><li>  Réduisez le nombre de requêtes de recherche. </li><li>  Vous ne pouvez pas demander des données qui ont déjà été téléchargées ou les mettre à jour en arrière-plan. </li><li>  Code relativement simple et universel côté client. </li></ol><br><p>  Parmi les lacunes, on peut noter que: </p><br><ol><li>  Pour afficher quelque chose, l'utilisateur doit effectuer au moins 2 demandes consécutives. </li><li>  Il est nécessaire de traiter le cas lorsque l'identifiant est, et les données sur celui-ci ne sont plus disponibles. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413133/">https://habr.com/ru/post/fr413133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413121/index.html">Visite photo du coworking à Moscou #tceh</a></li>
<li><a href="../fr413123/index.html">JOIN dans les bases de données NoSQL</a></li>
<li><a href="../fr413125/index.html">La thérapie génique donne aux petits patients atteints d'atrophie musculaire une chance de survivre</a></li>
<li><a href="../fr413127/index.html">Quelques mots sur les performances réelles de l'hyperviseur</a></li>
<li><a href="../fr413129/index.html">25 erreurs d'un programmeur débutant</a></li>
<li><a href="../fr413135/index.html">Mission de test de révision de code des développeurs juniors de React</a></li>
<li><a href="../fr413137/index.html">Classer de grandes quantités de données sur Apache Spark à l'aide de modèles d'apprentissage automatique arbitraires</a></li>
<li><a href="../fr413139/index.html">Voitures électriques: la révolution arrive</a></li>
<li><a href="../fr413141/index.html">Classer de grandes quantités de données sur Apache Spark à l'aide de modèles d'apprentissage automatique arbitraires</a></li>
<li><a href="../fr413143/index.html">Bobby Urban Lite: le nouveau sac à dos urbain de XD Design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>