<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèæ ‚ò¢Ô∏è üôçüèª Programa√ß√£o ass√≠ncrona - desempenho ass√≠ncrono: entenda os custos do ass√≠ncrono e aguarde üë©üèª‚Äçüíº üë©üèº üßõüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √© bastante antigo, mas n√£o perdeu sua relev√¢ncia. Quando se trata de ass√≠ncrono / espera, geralmente aparece um link para ele. N√£o consegu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o ass√≠ncrona - desempenho ass√≠ncrono: entenda os custos do ass√≠ncrono e aguarde</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458332/"><p>  Este artigo √© bastante antigo, mas n√£o perdeu sua relev√¢ncia.  Quando se trata de ass√≠ncrono / espera, geralmente aparece um link para ele.  N√£o consegui encontrar uma tradu√ß√£o para o russo, decidi ajudar algu√©m que n√£o √© fluente. </p><br><hr><br><p>  A programa√ß√£o ass√≠ncrona tem sido o reino dos desenvolvedores mais experientes com desejo de masoquismo - aqueles que tinham tempo livre suficiente, inclina√ß√£o e capacidade ps√≠quica para pensar em retornos de retorno de retorno de chamada em um fluxo n√£o linear de execu√ß√£o.  Com o advento do Microsoft .NET Framework 4.5, o C # e o Visual Basic nos trouxeram assincronia, para que meros mortais agora possam escrever m√©todos ass√≠ncronos quase t√£o facilmente quanto os s√≠ncronos.  Retornos de chamada n√£o s√£o mais necess√°rios.  N√£o h√° mais c√≥digo expl√≠cito de empacotamento de um contexto de sincroniza√ß√£o para outro.  N√£o h√° mais preocupa√ß√µes sobre como os resultados ou exce√ß√µes da execu√ß√£o se movem.  N√£o h√° necessidade de truques que distorcem os meios das linguagens de programa√ß√£o para a conveni√™ncia de desenvolver c√≥digo ass√≠ncrono.  Em suma, n√£o h√° mais problemas e dor de cabe√ßa. </p><a name="habracut"></a><br><p>  Obviamente, embora agora seja f√°cil come√ßar a escrever m√©todos ass√≠ncronos (consulte os artigos de Eric Lippert e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mads Torgersen</a> nesta <em>MSDN Magazine [outubro de 2011]</em> ), √© necess√°rio entendimento para fazer isso corretamente. o que acontece debaixo do cap√¥.  Sempre que uma linguagem ou biblioteca aumenta o n√≠vel de abstra√ß√£o que um desenvolvedor pode usar, isso √© inevitavelmente acompanhado por custos ocultos que reduzem a produtividade.  Em muitos casos, esses custos s√£o insignificantes e, portanto, podem ser negligenciados na maioria dos casos pela maioria dos programadores.  No entanto, desenvolvedores avan√ßados devem entender completamente quais custos est√£o presentes para tomar as medidas necess√°rias e resolver poss√≠veis problemas, se eles se manifestarem.  Isso √© necess√°rio ao usar ferramentas de programa√ß√£o ass√≠ncronas em C # e Visual Basic. </p><br><p>  Neste artigo, descreverei as entradas e sa√≠das de m√©todos ass√≠ncronos, descreverei como os m√©todos ass√≠ncronos s√£o implementados e discutirei alguns dos custos menores.  Observe que essa n√£o √© uma recomenda√ß√£o para distorcer o c√≥digo leg√≠vel em algo dif√≠cil de manter, em nome da microoptimiza√ß√£o e desempenho.  Esse √© apenas o conhecimento que ajudar√° a diagnosticar problemas que voc√™ pode encontrar e um conjunto de ferramentas para super√°-los.  Al√©m disso, este artigo √© baseado na visualiza√ß√£o do .NET Framework vers√£o 4.5 e provavelmente os detalhes espec√≠ficos da implementa√ß√£o podem mudar na vers√£o final. </p><br><h4 id="poluchit-udobnuyu-model-myshleniya">  Obtenha um modelo de pensamento confort√°vel </h4><br><p>  Por d√©cadas, os programadores t√™m usado as linguagens de programa√ß√£o de alto n√≠vel C #, Visual Basic, F # e C ++ para desenvolver aplicativos produtivos.  Essa experi√™ncia permitiu aos programadores avaliar os custos de v√°rias opera√ß√µes e obter conhecimento sobre as melhores t√©cnicas de desenvolvimento.  Por exemplo, na maioria dos casos, chamar um m√©todo s√≠ncrono √© relativamente econ√¥mico, especialmente se o compilador puder incorporar o conte√∫do do m√©todo chamado diretamente no ponto de chamada.  Portanto, os desenvolvedores est√£o acostumados a dividir o c√≥digo em m√©todos pequenos e f√°ceis de manter, sem precisar se preocupar com as consequ√™ncias negativas do aumento do n√∫mero de chamadas.  O modelo de pensamento desses programadores √© projetado para lidar com chamadas de m√©todo. </p><br><p>  Com o advento dos m√©todos ass√≠ncronos, √© necess√°rio um novo modelo de pensamento.  C # e Visual Basic com seus compiladores s√£o capazes de criar a ilus√£o de que o m√©todo ass√≠ncrono funciona como seu equivalente s√≠ncrono, embora tudo esteja completamente errado por dentro.  O compilador gera uma enorme quantidade de c√≥digo para o programador, muito semelhante ao modelo padr√£o que os desenvolvedores escreveram para dar suporte √† assincronia durante o tempo em que era necess√°rio faz√™-lo manualmente.  Al√©m disso, o c√≥digo gerado pelo compilador cont√©m chamadas para as fun√ß√µes de biblioteca do .NET Framework, reduzindo ainda mais a quantidade de trabalho que um programador precisa realizar.  Para ter o modelo certo de pensamento e us√°-lo para tomar decis√µes informadas, √© importante entender o que o compilador gera para voc√™. </p><br><h4 id="bolshe-razmer-metodov-menshe-vyzovov">  Mais m√©todos, menos chamadas </h4><br><p>  Ao trabalhar com c√≥digo s√≠ncrono, a execu√ß√£o de m√©todos com conte√∫do vazio √© praticamente in√∫til.  Para m√©todos ass√≠ncronos, esse n√£o √© o caso.  Considere este m√©todo ass√≠ncrono, consistindo em uma instru√ß√£o (e que, devido √† falta de instru√ß√µes de espera, ser√° executada de forma s√≠ncrona): </p><br><pre><code class="plaintext hljs">public static async Task SimpleBodyAsync() { Console.WriteLine("Hello, Async World!"); }</code> </pre> <br><p>  Um descompilador de linguagem intermedi√°ria (IL) revelar√° o verdadeiro conte√∫do dessa fun√ß√£o ap√≥s a compila√ß√£o, produzindo algo semelhante √† Figura 1. O que era um liner simples transformado em dois m√©todos, um dos quais pertence √† classe auxiliar da m√°quina de estado.  O primeiro √© um m√©todo stub que possui uma assinatura semelhante √† escrita pelo programador (este m√©todo tem o mesmo nome, o mesmo escopo, usa os mesmos par√¢metros e retorna o mesmo tipo), mas n√£o cont√©m c√≥digo escrito pelo programador.  Ele cont√©m apenas um padr√£o para a configura√ß√£o inicial.  O c√≥digo de configura√ß√£o inicial inicializa a m√°quina de estado necess√°ria para representar o m√©todo ass√≠ncrono e a inicia usando uma chamada para o m√©todo do utilit√°rio MoveNext.  O tipo de objeto da m√°quina de estado cont√©m uma vari√°vel com o estado de execu√ß√£o do m√©todo ass√≠ncrono, permitindo que voc√™ a salve ao alternar entre pontos de espera ass√≠ncronos.  Ele tamb√©m cont√©m c√≥digo gravado por um programador, modificado para garantir a transfer√™ncia de resultados de execu√ß√£o e exce√ß√µes para o objeto Task retornado;  mantendo a posi√ß√£o atual no m√©todo para que a execu√ß√£o possa continuar a partir dessa posi√ß√£o depois de retomar etc. </p><br><p>  <strong>Figura 1</strong> Modelo de m√©todo ass√≠ncrono </p><br><pre> <code class="plaintext hljs">[DebuggerStepThrough] public static Task SimpleBodyAsync() { &lt;SimpleBodyAsync&gt;d__0 d__ = new &lt;SimpleBodyAsync&gt;d__0(); d__.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create(); d__.MoveNext(); return d__.&lt;&gt;t__builder.Task; } [CompilerGenerated] [StructLayout(LayoutKind.Sequential)] private struct &lt;SimpleBodyAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public void MoveNext() { try { if (this.&lt;&gt;1__state == -1) return; Console.WriteLine("Hello, Async World!"); } catch (Exception e) { this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetException(e); return; } this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetResult(); } ... }</code> </pre> <br><p>  Quando voc√™ se perguntar quanto custa as chamadas para m√©todos ass√≠ncronos, lembre-se desse padr√£o.  O bloco try / catch no m√©todo MoveNext √© necess√°rio para impedir uma poss√≠vel tentativa de incorporar esse m√©todo pelo JIT pelo compilador, portanto, pelo menos, obtemos o custo de chamar o m√©todo, enquanto, ao usar o m√©todo s√≠ncrono, provavelmente essa chamada n√£o ser√° (desde conte√∫do minimalista).  Receberemos v√°rias chamadas para os procedimentos do Framework (por exemplo, SetResult).  Bem como v√°rias opera√ß√µes de grava√ß√£o nos campos do objeto de m√°quina de estado.  Obviamente, precisamos comparar todos esses custos com os do Console.WriteLine, que provavelmente prevalecer√° (eles incluem os custos de bloqueio, E / S, etc.) Preste aten√ß√£o √†s otimiza√ß√µes que o ambiente faz para voc√™.  Por exemplo, um objeto de uma m√°quina de estado √© implementado como uma estrutura (struct).  Essa estrutura ser√° encaixotada em um heap gerenciado apenas se o m√©todo precisar pausar a execu√ß√£o, aguardando a conclus√£o da opera√ß√£o, e isso nunca acontecer√° neste m√©todo simples.  Portanto, o padr√£o desse m√©todo ass√≠ncrono n√£o exigir√° aloca√ß√£o de mem√≥ria do heap.  O compilador e o tempo de execu√ß√£o tentar√£o minimizar o n√∫mero de opera√ß√µes de aloca√ß√£o de mem√≥ria. </p><br><h4 id="kogda-ne-nuzhno-ispolzovat-async">  Quando n√£o usar o Async </h4><br><p>  O .NET Framework tenta gerar implementa√ß√µes eficientes para m√©todos ass√≠ncronos usando v√°rios m√©todos de otimiza√ß√£o.  No entanto, os desenvolvedores, com base em sua experi√™ncia, geralmente aplicam seus m√©todos de otimiza√ß√£o, que podem ser arriscados e impratic√°veis ‚Äã‚Äãpara automa√ß√£o pelo compilador e pelo tempo de execu√ß√£o, enquanto tentam usar abordagens universais.  Se voc√™ n√£o esquecer disso, a rejei√ß√£o do uso de m√©todos ass√≠ncronos √© ben√©fica em v√°rios casos espec√≠ficos, em particular, isso se aplica a m√©todos em bibliotecas que podem ser usadas com configura√ß√µes mais refinadas.  Geralmente isso acontece quando se sabe ao certo que o m√©todo pode ser executado de forma s√≠ncrona, pois os dados dos quais depende j√° est√£o prontos. </p><br><p>  Ao criar m√©todos ass√≠ncronos, os desenvolvedores do .NET Framework gastaram muito tempo otimizando o n√∫mero de opera√ß√µes de gerenciamento de mem√≥ria.  Isso √© necess√°rio porque o gerenciamento de mem√≥ria incorre no maior custo no desempenho de uma infraestrutura ass√≠ncrona.  A opera√ß√£o de alocar mem√≥ria para um objeto geralmente √© relativamente barata.  Alocar mem√≥ria para objetos √© semelhante a encher o carrinho com produtos no supermercado - voc√™ n√£o gasta nada quando os coloca no carrinho.  Os gastos ocorrem quando voc√™ paga no caixa, retira sua carteira e d√° dinheiro decente.  E se a aloca√ß√£o de mem√≥ria for f√°cil, a coleta de lixo subsequente poder√° afetar seriamente o desempenho do aplicativo.  Quando voc√™ inicia a coleta de lixo, a varredura e a marca√ß√£o de objetos atualmente localizados na mem√≥ria, mas sem links, s√£o executadas.  Quanto mais objetos s√£o colocados, mais tempo leva para marc√°-los.  Al√©m disso, quanto maior o n√∫mero de objetos de tamanho grande colocados, mais frequentemente √© necess√°ria a coleta de lixo.  Esse aspecto do trabalho com mem√≥ria tem um impacto global no sistema: quanto mais lixo √© produzido por m√©todos ass√≠ncronos, mais lento o aplicativo √© executado, mesmo que os microtestes n√£o demonstrem custos significativos. </p><br><p>  Para m√©todos ass√≠ncronos que suspendem sua execu√ß√£o (aguardando dados que ainda n√£o est√£o prontos), o ambiente deve criar um objeto do tipo Tarefa, que ser√° retornado do m√©todo, pois esse objeto serve como uma refer√™ncia exclusiva para a chamada.  No entanto, chamadas de m√©todo frequentemente ass√≠ncronas podem ser feitas sem suspens√£o.  Em seguida, o tempo de execu√ß√£o pode retornar do cache o objeto Task conclu√≠do anteriormente, que √© usado repetidamente sem a necessidade de criar novos objetos Task.  √â verdade que isso √© permitido apenas sob certas condi√ß√µes, por exemplo, quando o m√©todo ass√≠ncrono retorna um objeto n√£o universal (n√£o gen√©rico), Task, Task ou quando a tarefa universal √© especificada por um tipo de refer√™ncia TResult e null √© retornado do m√©todo.  Embora a lista dessas condi√ß√µes esteja se expandindo ao longo do tempo, ainda √© melhor se voc√™ souber como a opera√ß√£o √© implementada. <br></p><p>  Considere uma implementa√ß√£o como MemoryStream.  MemoryStream √© herdado do Stream e redefine os novos m√©todos implementados no .NET 4.5: ReadAsync, WriteAsync e FlushAsync, a fim de fornecer otimiza√ß√£o de c√≥digo espec√≠fica da mem√≥ria.  Como a opera√ß√£o de leitura √© realizada a partir de um buffer localizado na mem√≥ria, ou seja, na verdade √© uma c√≥pia da √°rea de mem√≥ria, o melhor desempenho ser√° se o ReadAsync for executado no modo s√≠ncrono.  Uma implementa√ß√£o disso em um m√©todo ass√≠ncrono pode ser assim: </p><br><pre> <code class="plaintext hljs">public override async Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { cancellationToken.ThrowIfCancellationRequested(); return this.Read(buffer, offset, count); }</code> </pre> <br><p>  Simples o suficiente.  E como o Read √© uma chamada s√≠ncrona e o m√©todo n√£o tem instru√ß√µes de espera para controlar as expectativas, todas as chamadas para este ReadAsync ser√£o realmente executadas de forma s√≠ncrona.  Agora, vamos ver um caso padr√£o de uso de threads, por exemplo, uma opera√ß√£o de c√≥pia: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Observe que no exemplo ReadAsync fornecido, o fluxo de origem √© sempre chamado com o mesmo par√¢metro de tamanho do buffer, o que significa que √© muito prov√°vel que o valor de retorno (o n√∫mero de bytes lidos) tamb√©m seja repetido.  Exceto em algumas circunst√¢ncias raras, √© improv√°vel que a implementa√ß√£o do ReadAsync use o objeto de tarefa em cache como o valor de retorno, mas voc√™ pode faz√™-lo. </p><br><p>  Considere outra op√ß√£o de implementa√ß√£o para esse m√©todo, mostrada na Figura 2. Usando as vantagens de seus aspectos inerentes nos scripts padr√£o para esse m√©todo, podemos otimizar a implementa√ß√£o excluindo opera√ß√µes de aloca√ß√£o de mem√≥ria, que √© improv√°vel que seja esperado do tempo de execu√ß√£o.  Podemos eliminar completamente a perda de mem√≥ria retornando o mesmo objeto Task que foi usado na chamada ReadAsync anterior, se o mesmo n√∫mero de bytes tiver sido lido.  E para uma opera√ß√£o de baixo n√≠vel, que provavelmente ser√° muito r√°pida e ser√° chamada repetidamente, essa otimiza√ß√£o ter√° um efeito significativo, especialmente no n√∫mero de coletas de lixo. </p><br><p>  <strong>Figura 2</strong> Otimiza√ß√£o da cria√ß√£o de tarefas </p><br><pre> <code class="plaintext hljs">private Task&lt;int&gt; m_lastTask; public override Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { if (cancellationToken.IsCancellationRequested) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetCanceled(); return tcs.Task; } try { int numRead = this.Read(buffer, offset, count); return m_lastTask != null &amp;&amp; numRead == m_lastTask.Result ? m_lastTask : (m_lastTask = Task.FromResult(numRead)); } catch(Exception e) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetException(e); return tcs.Task; } }</code> </pre> <br><p>  Um m√©todo de otimiza√ß√£o semelhante, eliminando a cria√ß√£o desnecess√°ria de objetos Task, pode ser usado se o armazenamento em cache for necess√°rio.  Considere um m√©todo desenvolvido para recuperar o conte√∫do de uma p√°gina da Web e armazen√°-lo em cache para refer√™ncia futura.  Como m√©todo ass√≠ncrono, isso pode ser escrito da seguinte maneira (usando a nova biblioteca System.Net.Http.dll para .NET 4.5): </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,string&gt; s_urlToContents; public static async Task&lt;string&gt; GetContentsAsync(string url) { string contents; if (!s_urlToContents.TryGetValue(url, out contents)) { var response = await new HttpClient().GetAsync(url); contents = response.EnsureSuccessStatusCode().Content.ReadAsString(); s_urlToContents.TryAdd(url, contents); } return contents; }</code> </pre> <br><p>  Esta √© uma implementa√ß√£o de testa.  E para chamadas GetContentsAsync que n√£o encontram dados no cache, a sobrecarga de cria√ß√£o de um novo objeto de Tarefa pode ser negligenciada em compara√ß√£o com o custo de recebimento de dados pela rede.  No entanto, no caso de obter dados do cache, esses custos se tornam significativos se voc√™ simplesmente agrupar e fornecer dados locais dispon√≠veis. <br></p><p>  Para eliminar esses custos (se necess√°rio para obter alto desempenho), voc√™ pode reescrever o m√©todo conforme mostrado na Figura 3. Agora, temos dois m√©todos: um m√©todo p√∫blico s√≠ncrono e um m√©todo privado ass√≠ncrono, aos quais o p√∫blico delega.  A cole√ß√£o Dictionary agora armazena em cache os objetos Task criados, e n√£o seu conte√∫do, para que futuras tentativas de recuperar o conte√∫do de uma p√°gina obtida anteriormente com √™xito possam ser realizadas, basta acessar a cole√ß√£o para retornar o objeto Task existente.  Por dentro, voc√™ pode tirar vantagem do uso dos m√©todos ContinueWith do objeto Task, que nos permitem salvar o objeto executado na cole√ß√£o - caso o carregamento da p√°gina tenha sido bem-sucedido.  Obviamente, esse c√≥digo √© mais complexo e requer muito desenvolvimento e suporte, como de costume ao otimizar o desempenho: voc√™ n√£o quer gastar tempo escrevendo-o at√© que o teste de desempenho mostre que essas complica√ß√µes levam a sua melhoria, o que √© impressionante e √≥bvio.  Quais melhorias realmente depender√£o do m√©todo de aplica√ß√£o.  Voc√™ pode fazer um conjunto de testes que simula casos de uso comuns e avaliar os resultados para determinar se o jogo vale a pena. </p><br><p>  <strong>Figura 3</strong> Tarefas de armazenamento em cache manualmente </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,Task&lt;string&gt;&gt; s_urlToContents; public static Task&lt;string&gt; GetContentsAsync(string url) { Task&lt;string&gt; contents; if (!s_urlToContents.TryGetValue(url, out contents)) { contents = GetContentsInternalAsync(url); contents.ContinueWith(delegate { s_urlToContents.TryAdd(url, contents); }, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion | TaskContinuatOptions.ExecuteSynchronously, TaskScheduler.Default); } return contents; } private static async Task&lt;string&gt; GetContentsInternalAsync(string url) { var response = await new HttpClient().GetAsync(url); return response.EnsureSuccessStatusCode().Content.ReadAsString(); }</code> </pre> <br><p>  Outro m√©todo de otimiza√ß√£o associado aos objetos Task √© determinar se um objeto desse tipo √© retornado pelo m√©todo ass√≠ncrono.  O C # e o Visual Basic oferecem suporte a m√©todos ass√≠ncronos que retornam um valor nulo (nulo) e n√£o criam objetos de tarefa.  M√©todos ass√≠ncronos nas bibliotecas sempre devem retornar Tarefa e Tarefa, pois ao projetar uma biblioteca, voc√™ n√£o pode saber que eles n√£o ser√£o usados ‚Äã‚Äãaguardando a conclus√£o.  No entanto, ao desenvolver aplicativos, os m√©todos que retornam nulos podem encontrar seu lugar.  O principal motivo da exist√™ncia de tais m√©todos √© fornecer ambientes orientados a eventos existentes, como ASP.NET e Windows Presentation Foundation (WPF).  Usando async e wait, esses m√©todos facilitam a implementa√ß√£o de manipuladores de bot√£o, eventos de carregamento de p√°gina etc.  Se voc√™ pretende usar um m√©todo ass√≠ncrono com void, tenha cuidado ao lidar com exce√ß√µes: exce√ß√µes aparecer√£o em qualquer SynchronizationContext que estava ativo no momento em que o m√©todo foi chamado. <br></p><h4 id="ne-zabyvayte-o-kontekste">  N√£o esque√ßa o contexto </h4><br><p>  Existem muitos contextos diferentes no .NET Framework: LogicalCallContext, SynchronizationContext, HostExecutionContext, SecurityContext, ExecutionContext e outros (sua quantidade gigantesca pode sugerir que os criadores do Framework foram motivados financeiramente para criar novos contextos, mas sei com certeza que isso n√£o √© assim).  Alguns desses contextos afetam fortemente m√©todos ass√≠ncronos, n√£o apenas em termos de funcionalidade, mas tamb√©m em desempenho. </p><br><p>  <strong>SynchronizationContext</strong> SynchronizationContext desempenha um papel importante nos m√©todos ass√≠ncronos.  Um "contexto de sincroniza√ß√£o" √© apenas uma abstra√ß√£o para garantir que uma chamada de delegado com os detalhes de uma determinada biblioteca ou ambiente seja empacotada.  Por exemplo, o WPF possui um DispatcherSynchronizationContext para representar um thread da interface do usu√°rio do Dispatcher: o envio de um representante para esse contexto de sincroniza√ß√£o faz com que esse representante seja colocado na fila para execu√ß√£o pelo Dispatcher em seu thread.  O ASP.NET fornece um AspNetSynchronizationContext usado para garantir que as opera√ß√µes ass√≠ncronas envolvidas no processamento de uma solicita√ß√£o ASP.NET sejam executadas seq√ºencialmente e estejam vinculadas ao estado correto HttpContext.  Bem, etc.  Em geral, existem cerca de 10 especializa√ß√µes do SynchronizationContext no .NET Framework, algumas abertas, outras internas. </p><br><p>  Ao aguardar tarefas ou objetos de outros tipos pelos quais o .NET Framework pode implementar isso, os objetos que esperam por eles (por exemplo, TaskAwaiter) capturam o SynchronizationContext atual no momento em que a espera (espera) come√ßa.  Ap√≥s a conclus√£o da espera, se o SynchronizationContext foi capturado, a continua√ß√£o do m√©todo ass√≠ncrono √© enviada para esse contexto de sincroniza√ß√£o.  Devido a isso, os programadores que escrevem m√©todos ass√≠ncronos chamados do fluxo da interface do usu√°rio n√£o precisam empacotar manualmente as chamadas de volta para o fluxo da interface do usu√°rio para atualizar os controles da interface do usu√°rio: o Framework executa essa empacotamento automaticamente. </p><br><p>  Infelizmente, esse empacotamento tem um pre√ßo.  Para desenvolvedores de aplicativos que aguardam para implementar seu fluxo de controle, o empacotamento autom√°tico √© a solu√ß√£o certa.  As bibliotecas geralmente t√™m uma hist√≥ria completamente diferente.  Para desenvolvedores de aplicativos, esse empacotamento √© principalmente necess√°rio para o c√≥digo controlar o contexto em que √© executado, por exemplo, para acessar os controles da interface do usu√°rio ou para acessar o HttpContext correspondente √† solicita√ß√£o do ASP.NET necess√°ria.  No entanto, as bibliotecas geralmente n√£o s√£o necess√°rias para atender a esse requisito.  Como resultado, o empacotamento autom√°tico geralmente gera custos adicionais completamente desnecess√°rios.  Vamos dar uma nova olhada no c√≥digo que copia dados de um fluxo para outro: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Se essa c√≥pia for chamada do fluxo da interface do usu√°rio, cada opera√ß√£o de leitura e grava√ß√£o for√ßar√° a execu√ß√£o a retornar ao fluxo da interface do usu√°rio.  No caso de um megabyte de dados na origem e nos fluxos que l√™em e gravam de forma ass√≠ncrona (ou seja, a maioria de suas implementa√ß√µes), isso significa cerca de 500 op√ß√µes do fluxo de segundo plano para o fluxo da interface do usu√°rio.  Para lidar com esse comportamento nos tipos de tarefas e tarefas, o m√©todo ConfigureAwait √© criado.  Este m√©todo aceita o par√¢metro continueOnCapturedContext de um tipo booleano que controla empacotamento.  Se true (o padr√£o), aguardar retornar√° automaticamente o controle para o SynchronizationContext capturado.  Se false for usado, o contexto de sincroniza√ß√£o ser√° ignorado e o ambiente continuar√° executando a opera√ß√£o ass√≠ncrona no encadeamento em que foi interrompido.  A implementa√ß√£o dessa l√≥gica fornecer√° uma vers√£o mais eficiente do c√≥digo de c√≥pia entre os threads: <br></p><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); }</code> </pre> <br><p>  Para desenvolvedores de bibliotecas, essa acelera√ß√£o por si s√≥ √© suficiente para sempre pensar em usar o ConfigureAwait, com exce√ß√£o de raras condi√ß√µes nas quais a biblioteca conhece o tempo de execu√ß√£o e precisar√° executar o m√©todo com acesso ao contexto correto. </p><br><p>  Al√©m do desempenho, h√° outro motivo pelo qual voc√™ precisa usar o ConfigureAwait ao desenvolver bibliotecas.  Imagine que o m√©todo CopyStreamToStreamAsync, implementado com uma vers√£o do c√≥digo sem ConfigureAwait, seja chamado de um fluxo de UI no WPF, por exemplo, assim: </p><br><pre> <code class="plaintext hljs">private void button1_Click(object sender, EventArgs args) { Stream src = ‚Ä¶, dst = ‚Ä¶; Task t = CopyStreamToStreamAsync(src, dst); t.Wait(); // deadlock! }</code> </pre> <br><p>  Nesse caso, o programador precisou escrever button1_Click como um m√©todo ass√≠ncrono no qual o operador de espera espera executar a tarefa e n√£o usar o m√©todo de espera s√≠ncrona desse objeto.  O m√©todo Wait precisa ser usado em muitos outros casos, mas quase sempre ser√° um erro us√°-lo para aguardar em um fluxo da interface do usu√°rio, como mostrado aqui.  O m√©todo Wait n√£o retornar√° at√© que a tarefa seja conclu√≠da.  No caso de CopyStreamToStreamAsync, seu fluxo ass√≠ncrono tenta retornar a execu√ß√£o enviando dados para o SynchronizationContext capturado e n√£o pode concluir at√© que essas transfer√™ncias sejam conclu√≠das (porque s√£o necess√°rias para continuar sua opera√ß√£o).  Mas esses despachos, por sua vez, n√£o podem ser executados, porque o thread da interface do usu√°rio que deve manipul√°-los √© bloqueado pela chamada Aguardar.  Essa √© uma depend√™ncia c√≠clica que leva a um impasse.  Se CopyStreamToStreamAsync for implementado com ConfigureAwait (false), n√£o haver√° depend√™ncia e bloqueio. </p><br><p>  <strong>ExecutionContext</strong> ExecutionContext √© uma parte importante do .NET Framework, mas ainda assim muitos programadores desconhecem sua exist√™ncia. ExecutionContext ‚Äì  ,        SecurityContext  LogicalCallContext,   ,         .  ,    ThreadPool.QueueUserWorkItem, Task.Run, Delegate.BeginInvoke, Stream.BeginRead, WebClient.DownloadStringAsync      Framework,    ExecutionContext   ExecutionContext.Run ( ). ,  ,  ThreadPool.QueueUserWorkItem,  Windows  (identity),           WaitCallback.   ,   Task.Run    LogicalCallContext,         LogicalCallContext    Action. ExecutionContext     . </p><br><p>  Framework    ,          ExecutionContext,     ,      .     Windows      LogicalCallContext     .     (WindowsIdentity.Impersonate  CallContext.LogicalSetData)               . </p><br><h4 id="osvobodites-ot-sborki-musora">     </h4><br><p>        .    C#  Visual Basic     ,        .          await.  ,      ,    -   .   C#  Visual Basic  (¬´¬ª)      ,     await  (boxed)  ,     . </p><br><p>                  .   ,     . ,       ,     ,     . </p><br><p>       C#  Visual Basic      ,      . ,     </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dto = DateTimeOffset.Now; var dt = dto.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>    dto      await,     .    ,  , -    dto: </p><br><p> <strong>Figure 4</strong>    </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Sequential), CompilerGenerated] private struct &lt;FooAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public DateTimeOffset &lt;dto&gt;5__1; public DateTime &lt;dt&gt;5__2; private object &lt;&gt;t__stack; private object &lt;&gt;t__awaiter; public void MoveNext(); [DebuggerHidden] public void &lt;&gt;t__SetMoveNextDelegate(Action param0); }</code> </pre> <br><p>         ,     .   ,     ,  , ,        .       ,        : </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dt = DateTimeOffset.Now.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>  ,   .NET (GC)    ,  ,      ,  :      0,  ,    ,     (.NET GC    0, 1  2).      ,    GC        .     ,  ,   ,    ,     ,     ,   .     0,   ,    ,   .   ,     ,         ,    . </p><br><p>                (        ,       ).    JIT   ,        ,               ,        ,      .          ,    ,        .   ,      ,  ,     ,     .   ,          ,     .  ,  C#  Visual Basic        ,       ,     . </p><br><h4 id="izbegayte-slozhnosti">   </h4><br><p>  C#  Visual Basic  ,       awaits:  .   await      ,     Task  ,       ,  . ,   ,      : <br></p><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return Sum(await a, await b, await c); } private static int Sum(int a, int b, int c) { return a + b + c; }</code> </pre> <br><p>  C#     ‚Äúawait b‚Äù    Sum.      await,       Sum,  -       async ,   ¬´¬ª     await.    ,       await       .   ,  ,       CLR,    ,      ,       .         ,                 &lt;&gt;t__stack.         ,   ,   Tuple&lt;int, int&gt;             &lt;&gt;__stack.  ,     ,    ,          . ,    SumAsync : </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int ra = await a; int rb = await b; int rc = await c; return Sum(ra, rb, rc); }</code> </pre> <br><p>            ,   ra, rb  rc,    .  ,    :                   .          ,           ,        ,    .  ,           ,    ,       ,          . </p><br><p> ,        ,        .      Sum   ,    await   ,       .     ,    await   ,  .      await  ,      Task.WhenAll: </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int [] results = await Task.WhenAll(a, b, c); return Sum(results[0], results[1], results[2]); }</code> </pre> <br><p>  Task.WhenAll  Task&lt;TResult[]&gt;,    ,       ,     ,       .           .     ,         WhenAll,    Task  Task.        ,          ,    ,   ,   ,    WhenAll ,    .         WhenAll,     , ,   params,       .    ,  ,         .   Figure 5 <br></p><p> <strong>Figure 5</strong>     </p><br><pre> <code class="plaintext hljs">public static Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return (a.Status == TaskStatus.RanToCompletion &amp;&amp; b.Status == TaskStatus.RanToCompletion &amp;&amp; c.Status == TaskStatus.RanToCompletion) ? Task.FromResult(Sum(a.Result, b.Result, c.Result)) : SumAsyncInternal(a, b, c); } private static async Task&lt;int&gt; SumAsyncInternal(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { await Task.WhenAll((Task)a, b, c).ConfigureAwait(false); return Sum(a.Result, b.Result, c.Result); }</code> </pre> <br><h4 id="asinhronnost-i-proizvoditelnost">    </h4><br><p>      ,           .  ,         .            ,            . ,      ,     :      ,      ,      /          ,       .     .NET Framework              ,       .   ,       .NET Framework,     .  ,  ,       Framework,   ,     ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458332/">https://habr.com/ru/post/pt458332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458316/index.html">Yandex Retro Games Battle 2019 - desenvolvimento de jogos para o ZX Spectrum</a></li>
<li><a href="../pt458324/index.html">Tudo o que voc√™ precisa para come√ßar a usar o Vue.js</a></li>
<li><a href="../pt458326/index.html">Yandex abre conjuntos de dados Toloka para pesquisadores</a></li>
<li><a href="../pt458328/index.html">Como duplicar metas do Yandex.Metrica no Google Analytics</a></li>
<li><a href="../pt458330/index.html">N√£o h√° limite para a perfei√ß√£o: como as interfaces neurais ajudam a humanidade</a></li>
<li><a href="../pt458334/index.html">Replica√ß√£o Cont√≠nua do Antigo para o Novo PostgreSQL com Slony</a></li>
<li><a href="../pt458336/index.html">O ciclo completo do desenvolvimento de produtos de TI usando o exemplo do projeto: fun√ß√µes da equipe, tarefas do cliente, est√°gios</a></li>
<li><a href="../pt458338/index.html">Application Security Manager. Desenvolvedor ou seguran√ßa?</a></li>
<li><a href="../pt458342/index.html">Texturiza√ß√£o ou o que voc√™ precisa saber para se tornar um Artista de Superf√≠cie. Parte 1. Pixel</a></li>
<li><a href="../pt458344/index.html">Usando mensagens ass√≠ncronas para melhorar a disponibilidade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>