<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💼 🐉 👨‍👩‍👦 39 neue Funktionen in Java 12 🚺 💇🏾 📿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aus einem wunderbaren Interview über Habré: „Simon Ritter hat von Anfang an an Java gearbeitet und tut dies weiterhin als stellvertretender technische...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>39 neue Funktionen in Java 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446590/"><blockquote>  Aus einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wunderbaren Interview</a> über Habré: „Simon Ritter hat von Anfang an an Java gearbeitet und tut dies weiterhin als stellvertretender technischer Direktor von Azul, einem Unternehmen, das an der virtuellen Maschine Zing JVM arbeitet, und einem der besten Müllsammler, C4 (Continuously Concurrent Compacting) Sammler) » <br>  Im Folgenden finden Sie eine Übersetzung seines Artikels über die neuen JDK 12-Funktionen und einige Schwierigkeiten, die bei der Migration auf einen neuen Build auftreten können. </blockquote><p> Ich habe mehrere Blog-Beiträge geschrieben, in denen alle Änderungen für die neuesten Java-Versionen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JDK 10</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JDK 11</a> ) aufgeführt sind.  Ich werde jetzt die Schattenseiten von JDK 12 untersuchen und mich auf einige der Fallstricke konzentrieren, die Probleme verursachen können, wenn Sie die Anwendung auf diese Version portieren möchten. </p><br><img src="https://habrastorage.org/webt/0e/rn/j0/0ernj0wwnqnwdejls6zvzjup5k8.png"><br><p><a name="habracut"></a>  JDK 12 hat die geringste Anzahl neuer Funktionen aus allen bisherigen Java-Versionen (ich habe 109 in JDK 10 und 90 in JDK 11 gezählt).  Dies ist nicht schlecht - aufgrund von Veröffentlichungszyklen enthalten einige Versionen mehr Änderungen, andere weniger. </p><br><p>  Ich werde neue Funktionen in offensichtliche logische Bereiche unterteilen: Java, Bibliotheken, JVMs und andere JDK-Funktionen. </p><br><h2>  Sprachänderungen </h2><br><p>  Die Funktion, die ich (und ich gehe davon aus, dass viele andere Personen) in JDK 12 am sichtbarsten ist, ist die neue switch-Anweisung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 325</a> ).  Dies ist auch die erste Sprachänderung, die als Funktion für die „Vorschau“ verwendet wird.  Die Idee der „Vorschau“ wurde Anfang 2018 im Rahmen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 12 eingeführt</a> .  Dies ist im Wesentlichen eine Möglichkeit, Beta-Versionen neuer Funktionen mithilfe von Befehlszeilenoptionen zu aktivieren.  Mithilfe der Vorschau können weiterhin Änderungen basierend auf dem Feedback der Benutzer vorgenommen und im schlimmsten Fall eine Funktion vollständig entfernt werden, wenn sie nicht ordnungsgemäß empfangen wurde.  Der Schlüssel zur Vorschau von Funktionen liegt darin, dass sie nicht in der Java SE-Spezifikation enthalten sind.  Über den neuen Schalter gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sehr gute Übersetzung</a> auf Habré. <br>  In JDK 12 ist ein Schalter zu einem Ausdruck geworden, der seinen „Inhalt“ auswertet, um ein Ergebnis zu erzielen.  Ich werde sofort erklären, dass dies keine Auswirkungen auf die Abwärtskompatibilität hat. Sie müssen also keinen Code ändern, der switch als Operator verwendet. </p><br><p>  Ich werde das Beispiel von JEP verwenden, da es einfach und klar ist: </p><br><div class="spoiler">  <b class="spoiler_title">Alter Schalter</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FRIDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SUNDAY: numLetters = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SATURDAY: numLetters = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); }</code> </pre> </div></div><br><p>  Wie Sie sehen können, ordnen wir den Wochentag dem Namen des variablen <code>day</code> und weisen dann den Wert <code>numLetters</code> .  Jetzt, da switch ein Operator ist, können wir die Zuweisung einmal ausführen (wodurch die Wahrscheinlichkeit eines fehlerhaften Codes erheblich verringert wird), indem wir das Ergebnis der switch-Anweisung verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY -&gt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY, SATURDAY -&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY -&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); };</code> </pre> <br><p>  Sie werden schnell zwei Syntaxänderungen bemerken.  OpenJDK-Entwickler stießen auf eine wenig bekannte Syntaxfunktion, die als durch Kommas getrennte Liste bezeichnet wird.  Auch der Lambda-Ausdrucksoperator <code>-&gt;</code> erleichtert die Rückgabe des Wertes.  Sie können <code>break</code> mit einem Wert verwenden, wenn Sie dies wirklich möchten.  Es gibt einige andere Details zu dieser Funktion, aber es ist wahrscheinlich einfacher, JEP zu lesen. </p><br><h2>  Bibliotheken </h2><br><p>  Es gibt eine Änderung, die ich sehr nützlich finde.  Es gibt auch eine Reihe von sekundären. </p><br><h3>  Abschlag Sammler </h3><br><p>  Die Streams-API verfügt wie üblich über einen neuen Collector, der von der Collectors-Dienstprogrammklasse bereitgestellt wird.  Ein neuer Kollektor kann mit der <code>teeing()</code> -Methode erhalten werden.  Der Abschlagsammler führt drei Argumente an: zwei Sammler und eine Bifunktion.  Um die Arbeit dieses Sammlers zu verstehen, empfehle ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel über Habré</a> . <br>  Um zu verstehen, wie er das macht, habe ich ein Diagramm gezeichnet: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/821/2db/503/8212db5034c04db49aed57dd44697b22.jpg" alt="Bild"><br><p>  Alle Werte aus dem Eingabestream werden an jeden Kollektor übergeben.  Das Ergebnis jedes Kollektors wird als Argument an BiFunction übergeben und das Endergebnis generiert. </p><br><p>  Ein einfaches Beispiel ist die Berechnung des Durchschnittswerts (ja, ich weiß, dass es dafür bereits Kollektoren gibt, wie beispielsweise <code>averagingInt()</code> , aber dies ist ein einfaches Beispiel, um das Konzept besser zu verstehen). </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Assume Collectors is statically imported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average = Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .collect(teeing( summingDouble(i -&gt; i), counting(), (sum, n) -&gt; sum / n) );</code> </pre> <br><p>  Der erste Kollektor berechnet die Summe des Eingabestreams und der zweite die Anzahl der Elemente.  BiFunction dividiert die Summe durch die Anzahl der Elemente, um den Durchschnittswert zu erhalten. </p><br><h3>  java.io </h3><br><p>  <code>InputStream skipNBytes(long n)</code> - überspringt und verwirft genau n Bytes aus dem Eingabestream InputStream.  Wenn n Null oder weniger ist, werden Bytes nicht übersprungen. </p><br><h3>  java.lang </h3><br><p>  Es wurde ein neues Paket veröffentlicht, java.lang.constant, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil der konstanten JVM-API JEP 334 ist</a> . </p><br><p>  Jede Java-Klassendatei verfügt über einen persistenten Pool, in dem Operanden für Bytecode-Anweisungen in der Klasse gespeichert sind.  Für Entwickler ist es schwierig, Klassendateien zu bearbeiten, da beim Laden von Klassen Probleme auftreten.  Die konstante JVM-API bietet symbolische Referenztypen zur Beschreibung jeder Form einer Konstante (Klasse, ladbare Konstante, <code>MethodHandle</code> , <code>MethodHandle</code> Konstante, <code>MethodType</code> Konstante). </p><br><p>  Es beeinflusste auch mehrere andere Klassen.  Alle folgenden Klassen haben jetzt eine Methode <code>describeConstable()</code> : </p><br><ul><li>  Klasse </li><li>  Doppel </li><li>  Aufzählung </li><li>  Float </li><li>  Ganzzahl </li><li>  Lang </li><li>  String </li><li>  Methodenhandle </li><li>  MethodType </li><li>  Varhandle </li></ul><br><p>  Als Brite finde ich das ziemlich lustig.  Der Begriff Constable, <code>describeConstable</code> wird seit dem 11. Jahrhundert verwendet, und so beziehen wir uns oft auf Polizisten.  Es ist auch der Name des berühmten Künstlers John Constable aus dem 18. Jahrhundert.  Ich frage mich daher, ob die Methode verifyTurner <code>describeTurner()</code> in einer zukünftigen Version verfügbar sein wird.  Offensichtlich handelt es sich in diesem Fall um eine Abkürzung der <code>Constant Table</code> , die nicht mit einem Juristen oder Landschaftsmaler verwandt ist. </p><br><p>  Die folgenden Klassen enthalten jetzt die Methode <code>resolveConstantDesc()</code> : </p><br><ul><li>  Doppel </li><li>  Enum.EnumDesc </li><li>  Float </li><li>  Ganzzahl </li><li>  Lang </li><li>  String </li></ul><br><h3>  java.lang.Character </h3><br><p>  Innere Klassen wurden aktualisiert, um neue Unicode-Blöcke aufzunehmen.  Ich möchte immer sehen, was die Leute gefunden haben, um Unicode hinzuzufügen. Hier einige Beispiele: </p><br><ul><li>  Schachsymbole </li><li>  Maya-Zahlen </li><li>  Sogdisch ist eine ostiranische Sprache, die im 11. Jahrhundert nicht mehr verwendet wurde. </li><li>  Old Sogdian ist eine ältere (und, wie ich vermute, noch eingeschränktere) Version von Sogdian </li></ul><br><h3>  java.lang.Class </h3><br><p>  <code>arrayType()</code> gibt <code>Class</code> für den Typ des Arrays zurück, dessen Komponententyp von dieser <code>Class</code> beschrieben wird.  Dies kann mit <code>jshell</code> überprüft werden: </p><br><pre> <code class="bash hljs">jshell&gt; (new String[2]).getClass().getName() <span class="hljs-variable"><span class="hljs-variable">$11</span></span> ==&gt; <span class="hljs-string"><span class="hljs-string">"[Ljava.lang.String;"</span></span> jshell&gt; (new String[2]).getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$12</span></span> ==&gt; class [[Ljava.lang.String; jshell&gt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$15</span></span> ==&gt; class [Ljava.lang.String;</code> </pre> <br><p>  Ich bin mir nicht ganz sicher, was die Bedeutung dieser Methode ist, da sie lediglich dem Typ, den diese Klasse darstellt, eine <code>Class</code> hinzufügt. </p><br><p>  <code>componentType()</code> , wie <code>getComponentType()</code> .  Die Frage lautet: Warum eine redundante Methode hinzufügen? </p><br><p>  <code>descriptorString()</code> - gibt wieder das gleiche Ergebnis wie <code>getName()</code> .  Dies ist jedoch erforderlich, da <code>Class</code> jetzt die <code>TypeDescriptor</code> Schnittstelle implementiert, die der neuen konstanten JVM-API zugeordnet ist. </p><br><h3>  lava.lang.String </h3><br><p>  <code>indent()</code> - Fügt einer Zeichenfolge eine Reihe führender Leerzeichen hinzu.  Wenn der Parameter negativ ist, wird diese Anzahl führender Leerzeichen entfernt (falls möglich). </p><br><p>  <code>transform()</code> - Wendet die bereitgestellte Funktion auf eine Zeichenfolge an.  Das Ergebnis ist möglicherweise keine Zeichenfolge. </p><br><h3>  java.lang.invoke </h3><br><p>  <code>VarHandle</code> jetzt <code>toString()</code> , um eine kompakte Beschreibung zurückzugeben. </p><br><p>  <code>java.net.SecureCacheResponse</code> und <code>java.net.ssl.HttpsConnection</code> haben eine neue Methode, <code>getSSLSession()</code> die <code>Optional</code> <code>SSLSession</code> die in der Verbindung verwendete <code>SSLSession</code> enthält. </p><br><h3>  java.nio.files </h3><br><p>  Die <code>Files</code> Klasse verfügt über eine neue Methode, <code>mismatch()</code> , die die Position des ersten Mismatch-Bytes im Inhalt von zwei Dateien findet und zurückgibt, oder -1L, wenn keine Mismatch vorliegt. </p><br><h3>  java.text </h3><br><p>  Es gibt eine neue Klasse <code>CompactNumberFormat</code> .  Dies ist eine Unterklasse von <code>NumberFormat</code> , die eine Dezimalzahl in kompakter Form formatiert.  Ein Beispiel für eine kompakte Form - <code>1M</code> statt <code>1000000</code> - erfordert zwei statt neun Zeichen.  <code>NumberFormat</code> und <code>java.text.spi.NumberFormatProvider</code> wurden um die neue Methode <code>getCompactNumberInstance()</code> .  Es gibt auch eine neue Aufzählung, <code>NumberFormatStyle</code> die zwei Bedeutungen hat: LONG und SHORT. </p><br><h3>  java.util.concurrent </h3><br><p>  CompletionStage enthält jetzt mehrere überladene Formulare mit drei Methoden: </p><br><ul><li>  ausnahmsweise asynchron </li><li>  außergewöhnlich komponieren </li><li>  außergewöhnlichComposeAsync </li></ul><br><p>  Diese Methoden erweitern die Möglichkeiten, eine neue <code>CompletionStage</code> aus einer vorhandenen zu erstellen, <code>CompletionStage</code> wenn die aktuelle mit einer Ausnahme endet.  Weitere Informationen finden Sie in der API-Dokumentation. </p><br><h3>  javax.crypto </h3><br><p>  Die <code>Cipher</code> Klasse verfügt über eine neue <code>toString()</code> -Methode, die eine Zeichenfolge zurückgibt, die die <code>Cipher</code> Transformation, den Modus und den Anbieter enthält. </p><br><h3>  javax.naming.ldap.spi </h3><br><p>  Dies ist ein neues Paket in JDK 12, das zwei Klassen enthält: <code>LdapDnsProvider</code> , die Anbieterklasse für DNS-Suchvorgänge während LDAP-Vorgängen, und <code>LdapDnsProviderResults</code> die das DNS- <code>LdapDnsProviderResults</code> für die LDAP-URL kapselt. </p><br><h3>  Schaukel </h3><br><p>  Swing wird noch aktualisiert!  Ja, <code>filechooser.FileSystemView</code> verfügt jetzt über eine neue Methode <code>getChooserShortcutPanelFiles()</code> .  Es gibt ein Array von Dateien zurück, die die Werte darstellen, die standardmäßig in der Verknüpfungsleiste für die Dateiauswahl angezeigt werden sollen. </p><br><h2>  JVM-Änderungen </h2><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 189: Shenandoah: Müllsammler mit</a> geringer Pause </h3><br><p>  Shenandoah ist ein 2014 von Red Hat angekündigtes Forschungsprojekt, das sich auf Anwendungsanforderungen mit geringer Latenz für die Speicherverwaltung in der JVM konzentriert.  Seine Ziele sind eine maximale Pausenzeit von 1..10 ms für einen Haufen von mehr als 20 GB ( <del>  Daher ist es nicht für kleine Anwendungen gedacht </del>  - Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer der Entwickler von Shenandoah antwortete</a> , ist dies nicht der Fall und es leistet hervorragende Arbeit bei kleinen Anwendungen.  Dieser Kollektor arbeitet parallel zu Anwendungsthreads. Vermeiden Sie daher die Probleme, die bei den meisten Garbage Collectors auftreten. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 344: Gemischte G1-Sammlungen</a> </h3><br><p>  Diese Änderung soll das Verhalten des G1-Kollektors verbessern, wenn er das festgelegte Verzögerungsziel erreicht.  G1 unterteilt den Heap-Raum (sowohl alt als auch alt) in Regionen.  Die Idee ist, dass Sie in der alten Generation keinen Müll in einem Arbeitsgang sammeln müssen.  Wenn G1 Müll sammeln muss, wählt es die Regionen aus, die es definiert.  Dies wird als Sammlungskit bezeichnet.  Vor JDK 12, als die Arbeiten am Set begannen, mussten alle Arbeiten im Wesentlichen als atomare Operation abgeschlossen werden.  Das Problem war, dass sich der Sammlungssatz manchmal aufgrund von Änderungen bei der Verwendung des Heapspeichers durch die Anwendung als zu groß herausstellte und zu viel Zeit zum Sammeln benötigte, was dazu führte, dass eine Pausenzeit nicht erreicht wurde. </p><br><p>  Wenn G1 in JDK 12 diese Situation erkennt, wird die Datenerfassung zur Hälfte unterbrochen, wenn dies die Fähigkeit der Anwendung nicht beeinträchtigt, weiterhin Speicherplatz für neue Objekte zuzuweisen.  Der Nettoeffekt von G1 ist besser, wenn eine kurze Pausenzeit erreicht ist. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 346: Geben Sie schnell nicht verwendeten zugewiesenen Speicher von G1 zurück</a> </h3><br><p>  Dies ist eine weitere Leistungsverbesserung für G1, aber eine andere hängt damit zusammen, wie die JVM mit dem Rest des Systems interagiert.  Offensichtlich wird Speicher für den JVM-Heap benötigt, und beim Start wird Speicher vom virtuellen Speicherzuweiser des Betriebssystems angefordert.  Wenn die Anwendung gestartet wird, kann es vorkommen, dass die für den Heap erforderliche Speichermenge abnimmt und ein Teil des zugewiesenen Speichers zur Verwendung durch andere Anwendungen an das Betriebssystem zurückgegeben werden kann. </p><br><p>  G1 tut dies bereits, kann dies jedoch nur an einer von zwei Stellen tun.  Erstens während einer vollständigen Sammlung und zweitens während eines der parallelen Zyklen.  G1 versucht, keine vollständige Erfassung durchzuführen, und bei geringer Speichernutzung kann es zwischen den Erfassungszyklen zu erheblichen Zeiträumen kommen.  Dies führt dazu, dass G1 einen festen Speicher für eine lange Zeit behalten kann. </p><br><p>  In JDK 12 versucht G1 regelmäßig, eine parallele Schleife fortzusetzen oder auszuführen, während die Anwendung inaktiv ist, um die allgemeine Verwendung des Java-Heaps zu bestimmen.  Nicht verwendeter Speicher kann zeitnaher und vorhersehbarer an das Betriebssystem zurückgegeben werden. </p><br><p>  Mit dem neuen Befehlszeilenflag <code>-XX:G1PeriodicGCInterval</code> kann die Anzahl der Millisekunden zwischen den Überprüfungen festgelegt werden. </p><br><p>  Diese Funktion führt zu einer konservativeren Verwendung des JVM-Speichers für Anwendungen, die längere Zeit nicht verwendet wurden. </p><br><h2>  Weitere neue JDK-Funktionen </h2><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 230: Microbenchmarking Kit</a> </h3><br><p>  Java Microbenchmarking Harness (JMH) wurde von Alexey Shipilev bei Oracle entwickelt und bietet eine umfangreiche Plattform für die Entwicklung von Leistungstests für Java-Anwendungen.  Alexey hat hervorragende Arbeit geleistet und Menschen dabei geholfen, viele einfache Fehler zu vermeiden, die sie bei der Analyse der Anwendungsleistung machen: Aufwärmen, Ausnahmen vermeiden usw. </p><br><p>  Jetzt kann JMH in OpenJDK aufgenommen werden.  Jeder, der daran interessiert ist, am JDK selbst zu arbeiten und den Code zu ändern, kann damit die Leistung vor und nach den Änderungen sowie die Leistung in verschiedenen Versionen vergleichen.  Eine Reihe von Tests ist enthalten, um das Testen zu ermöglichen.  Das Design von JMH ist so, dass es einfach ist, neue Tests dort hinzuzufügen, wo sie benötigt werden. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 340: Ein Aarch64-Port, nicht zwei</a> </h3><br><p>  OpenJDK verfügt über zwei Ports für die Arm64-Architektur, einen von Oracle und einen von Red Hat.  Da dies nicht erforderlich war und Oracle die Unterstützung von Arm für seine JDK-Binärdateien eingestellt hat, wurde beschlossen, nur den Red Hat-Port zu verwenden, der noch unterstützt und entwickelt wird. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JEP 341: Standard-CDS-Archive</a> </h3><br><p>  Die Data Sharing (CDS) -Klasse war früher eine kommerzielle Funktion in Oracle JDK.  Mit einem kürzlich in JDK 11 vorgenommenen Übergang, um alle funktionalen Unterschiede zwischen Oracle JDK und OpenJDK zu beseitigen, wurde es in OpenJDK aufgenommen. </p><br><p>  Um CDS verwenden zu können, benötigen Sie ein Archiv, das für Klassen erstellt wurde, die beim Start der Anwendung geladen werden.  JDK 12 für 64-Bit-Plattformen enthält jetzt die Datei <code>classes.jsa</code> im Verzeichnis <code>lib/server</code> .  Dies ist das CDS-Archiv für "Standardklassen".  Ich gehe davon aus, dass dies alle öffentlichen Klassen in JDK-Modulen bedeutet.  Ich konnte keinen Weg finden, es auszupacken, um es zu überprüfen.  Da CDS standardmäßig aktiviert ist, was der Option <code>-Xshare:auto</code> in der Befehlszeile entspricht, profitieren Benutzer von verbesserten Startzeiten der Anwendung. </p><br><h2>  Schlussfolgerungen </h2><br><p>  JDK 12 bietet eine kleine Anzahl neuer Funktionen und APIs, wobei die <code>switch</code> für Entwickler am interessantesten ist.  G1-Benutzer werden die Leistungsverbesserungen sicherlich zu schätzen wissen. </p><br><p>  Mit der neuen Version der Version würde ich allen Benutzern empfehlen, ihre Anwendungen in dieser Version zu testen.  Wenn Sie inkrementelle Änderungen im Auge behalten, können Sie Überraschungen vermeiden, wenn Sie sich für die nächste Version des langfristigen Supports entscheiden. </p><br><p>  Wir haben kostenlose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JDK 12-</a> Builds <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für die Zulu Community Edition</a> , die Sie beim Testen unterstützen.  Probieren Sie sie unbedingt aus. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446590/">https://habr.com/ru/post/de446590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446576/index.html">Importsubstitution oder wie russische Hubschrauber etwas falsch gemacht haben</a></li>
<li><a href="../de446578/index.html">Postkartenbasierte Programmiersprache</a></li>
<li><a href="../de446582/index.html">Überlegungen zum Solar Hosting für Bienen</a></li>
<li><a href="../de446586/index.html">Netzwerkeinstellungen von FreeRadius über DHCP</a></li>
<li><a href="../de446588/index.html">Überprüfen des Roslyn-Quellcodes</a></li>
<li><a href="../de446592/index.html">Überprüfen des Quellcodes von Roslyn</a></li>
<li><a href="../de446598/index.html">Neuerstellen von CRT-Schriftarten</a></li>
<li><a href="../de446602/index.html">Maximaler Gleichstrom durch Feldeffekttransistor</a></li>
<li><a href="../de446604/index.html">ESET: Neue Backdoor-Lieferprogramme für OceanLotus Cybergroup</a></li>
<li><a href="../de446606/index.html">Überprüfen Sie, wie gut Sie in der additiven Technologie sind</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>