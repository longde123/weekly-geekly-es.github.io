<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆔 👂🏾 🤘🏾 Nous tirons dans le pied, traitant les données d'entrée 🤐 🕉️ 👩🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le lien dans l'article d'aujourd'hui est différent de l'habituel. Ce n'est pas un projet pour lequel le code source a été analysé, mais une série de r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous tirons dans le pied, traitant les données d'entrée</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/433932/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/iw/l-/jhiwl-y02cm4bhppsrj9flbpqsi.png"></div><br>  Le lien dans l'article d'aujourd'hui est différent de l'habituel.  Ce n'est pas un projet pour lequel le code source a été analysé, mais une série de réponses de la même règle de diagnostic dans plusieurs projets différents.  Quel est l'intérêt ici?  Le fait que certains des fragments de code considérés contiennent des erreurs reproductibles lorsque vous travaillez avec l'application, tandis que d'autres contiennent des vulnérabilités (CVE).  De plus, à la fin de l'article, nous discuterons un peu du sujet des défauts de sécurité. <br><a name="habracut"></a><br><h2>  Brève préface </h2><br>  Toutes les erreurs qui seront examinées aujourd'hui dans l'article ont un schéma similaire: <br><br><ul><li>  le programme reçoit des données du flux <i>stdin</i> ; </li><li>  une vérification est effectuée pour la réussite de la lecture des données; </li><li>  si les données ont été lues avec succès, le caractère de report est supprimé de la ligne. </li></ul><br>  Cependant, tous les fragments qui seront considérés contiennent des erreurs et sont vulnérables aux entrées truquées.  Étant donné que les données sont reçues d'un utilisateur qui peut violer la logique d'exécution de l'application, il y avait une grande tentation d'essayer de casser quelque chose.  Ce que j'ai fait. <br><br>  Tous les problèmes ci-dessous ont été découverts par l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyseur statique PVS-Studio</a> , qui recherche des erreurs dans le code non seulement pour C, C ++, mais aussi pour C #, Java. <br><br>  Bien sûr, trouver un problème avec un analyseur statique est bien, mais trouver et reproduire est un niveau de plaisir complètement différent.  :) <br><br><h2>  Freeswitch </h2><br>  Le premier fragment de code suspect a été trouvé dans le code du module <i>fs_cli.exe</i> , qui fait partie du kit de distribution FreeSWITCH: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">basic_gets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cnt)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = getchar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets(command_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(command_buf) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) != command_buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } command_buf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(command_buf)<span class="hljs-number"><span class="hljs-number">-1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* remove endline */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-20 Les</a> données contaminées non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôlées</a> sont utilisées dans l'index: 'strlen (command_buf)'. <br><br>  L'analyseur avertit d'un appel suspect par index au tableau <i>command_buf</i> .  Il est considéré comme suspect car des données externes non vérifiées sont utilisées comme index.  Externe - car ils sont obtenus via la fonction <i>fgets</i> du flux <i>stdin</i> .  Non vérifié - car aucune vérification n'a été effectuée avant utilisation.  L'expression <i>fgets (command_buf, ....)! = Command_buf</i> ne compte pas, car de cette façon, nous vérifions uniquement le fait de recevoir les données, mais pas leur contenu. <br><br>  Le problème avec ce code est que, dans certaines conditions, «\ 0» sera écrit en dehors du tableau, ce qui entraînera un comportement non défini.  Pour ce faire, il suffit d'entrer une chaîne de longueur nulle (une chaîne de longueur nulle du point de vue du langage C, c'est-à-dire une chaîne dans laquelle le premier caractère sera '\ 0'). <br><br>  Estimons ce qui se passe si vous passez une chaîne de longueur nulle à l'entrée: <br><br><ul><li>  <i>fgets (command_buf, ....)</i> -&gt; <i>command_buf</i> ; </li><li>  <i>fgets (....)! = command_buf</i> -&gt; <i>false</i> ( <i>alors la</i> branche de l' <i>instruction if est</i> ignorée); </li><li>  <i>strlen (command_buf)</i> -&gt; <i>0</i> ; </li><li>  <i>command_buf [strlen (command_buf) - 1]</i> -&gt; <i>command_buf [-1]</i> . </li></ul><br>  Oups! <br><br>  Ce qui est intéressant ici, c'est que cet avertissement de l'analyseur peut être «ressenti avec vos mains».  Pour répéter le problème, vous avez besoin de: <br><br><ul><li>  amener le programme à cette fonction; </li><li>  affinez l'entrée afin que l'appel <i>getchar ()</i> renvoie une valeur négative; </li><li>  passez pour la fonction <i>fgets</i> une ligne avec un terminal zéro au début, qu'elle doit lire avec succès. </li></ul><br>  En fouillant un peu dans la source, j'ai composé une séquence spécifique pour reproduire le problème: <br><br><ul><li>  Exécutez <i>fs_cli.exe</i> en mode batch ( <i>fs_cli.exe -b</i> ).  Je note que pour effectuer d'autres étapes, la connexion <i>fs_cli.exe</i> au serveur doit réussir.  Pour ce faire, il suffit, par exemple, d'exécuter <i>FreeSwitchConsole.exe localement en</i> tant qu'administrateur. </li><li>  Nous effectuons l'entrée de sorte que l'appel <i>getchar ()</i> renvoie une valeur négative. </li><li>  Entrez une ligne avec un terminal zéro au début (par exemple, '\ 0Oops'). </li><li>  .... </li><li>  PROFIT! </li></ul><br>  Voici une lecture vidéo du problème: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jSYJirPIK8E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Ncftp </h2><br>  Un problème similaire a été découvert dans le projet NcFTP, mais il s'est déjà rencontré à deux endroits.  Étant donné que le code semble similaire, ne considérez qu'un seul endroit problématique: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NcFTPConfirmResumeDownloadProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets(newname, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(newname) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) newname[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; newname[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(newname) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  <b>Avertissement PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-20 Les</a> données corrompues non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôlées</a> sont utilisées dans l'index: 'strlen (nouveau nom)'. <br><br>  Ici, contrairement à l'exemple de FreeSWITCH, le code est écrit pire et plus sujet aux problèmes.  Par exemple, l'écriture de «\ 0» se produit indépendamment du fait que la lecture a réussi à l'aide de <i>fgets</i> ou non.  Autrement dit, il existe encore plus de possibilités pour briser la logique normale d'exécution.  Allons d'une manière éprouvée - à travers des lignes de longueur nulle. <br><br>  Le problème reproduit est un peu plus compliqué qu'avec FreeSWITCH.  La séquence des étapes est décrite ci-dessous: <br><br><ul><li>  démarrage et connexion au serveur à partir duquel vous pouvez télécharger le fichier.  Par exemple, j'ai utilisé <i>speedtest.tele2.net</i> (à la fin, la commande de lancement d'application ressemble à ceci: <i>ncftp.exe <a href="">speedtest.tele2.net</a></i> ); </li><li>  télécharger un fichier depuis le serveur.  Localement, un fichier du même nom mais avec des propriétés différentes devrait déjà exister.  Vous pouvez, par exemple, télécharger un fichier à partir du serveur, le modifier et réessayer d'exécuter la commande de téléchargement (par exemple, <i>obtenez 512 Ko.zip</i> ); </li><li>  répondez à la question sur le choix d'une action avec une ligne commençant par le caractère «N» (par exemple, <i>maintenant amusons-nous</i> ); </li><li>  entrez '\ 0' (ou quelque chose de plus intéressant); </li><li>  .... </li><li>  PROFIT! </li></ul><br>  La reproduction du problème est également enregistrée sur vidéo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8DBQjvPQ7tk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Openldap </h2><br>  Dans le projet OpenLDAP (plus précisément, dans l'un des utilitaires associés), ils ont marché sur le même râteau que dans FreeSWITCH.  Une tentative de suppression d'un caractère de saut de ligne se produit uniquement si la ligne a été lue avec succès, mais il n'y a pas non plus de protection contre les lignes de longueur nulle. <br><br>  Extrait de code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[ <span class="hljs-number"><span class="hljs-number">4096</span></span> ]; FILE *fp = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { fp = <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( fp == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc == <span class="hljs-number"><span class="hljs-number">0</span></span> || contoper) &amp;&amp; fgets(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), fp) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { buf[ <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( buf ) - <span class="hljs-number"><span class="hljs-number">1</span></span> ] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* remove trailing newline */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *buf != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> ) { rc = dodelete( ld, buf ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( rc != <span class="hljs-number"><span class="hljs-number">0</span></span> ) retval = rc; } } } .... }</code> </pre> <br>  <b>Avertissement PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-20 Les</a> données contaminées non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôlées</a> sont utilisées dans l'index: 'strlen (buf)'. <br><br>  Nous jetons l'excédent pour que l'essence du problème devienne plus évidente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (.... &amp;&amp; fgets(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), fp) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { buf[ <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( buf ) - <span class="hljs-number"><span class="hljs-number">1</span></span> ] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  Ce code est meilleur que NcFTP, mais reste vulnérable.  Si à la demande <i>fgets</i> pour passer une chaîne de longueur nulle à l'entrée: <br><br><ul><li>  <i>fgets (buf, ....)</i> -&gt; <i>buf</i> ; </li><li>  <i>fgets (....)! = NULL</i> -&gt; <i>true</i> (le corps de la <i>boucle while</i> commence à s'exécuter); </li><li>  <i>strlen (buf) - 1</i> -&gt; <i>0 - 1</i> -&gt; <i>-1</i> ; </li><li>  <i>buf [-1] = '\ 0'</i> . </li></ul><br><h2>  libidn </h2><br>  Malgré le fait que les erreurs discutées ci-dessus sont assez intéressantes (elles sont reproduites de manière stable et elles peuvent être «touchées» (à moins que je ne puisse pas toucher le problème OpenLDAP)), elles ne peuvent pas être appelées vulnérabilités, ne serait-ce que pour la raison que les identifiants CVE ne sont pas attribués aux problèmes. <br><br>  Cependant, certaines vulnérabilités réelles ont le même schéma de problème.  Les deux extraits de code ci-dessous s'appliquent au projet libidn. <br><br>  Extrait de code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets (readbuf, BUFSIZ, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feof (<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; error (EXIT_FAILURE, errno, _(<span class="hljs-string"><span class="hljs-string">"input error"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readbuf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (readbuf) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) readbuf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (readbuf) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  <b>Avertissement PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-20 Les</a> données contaminées non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôlées</a> sont utilisées dans l'index: 'strlen (readbuf)'. <br><br>  La situation est similaire, sauf que, contrairement aux exemples précédents, où l'enregistrement a été effectué à l'indice <i>-1</i> , la lecture a lieu ici.  Cependant, ce comportement n'est toujours pas défini.  Cette erreur a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reçu</a> son propre identifiant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CVE</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CVE-2015-8948</a> ). <br><br>  Après avoir détecté un problème, ce code a été modifié comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getline (&amp;line, &amp;linelen, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feof (<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; error (EXIT_FAILURE, errno, _(<span class="hljs-string"><span class="hljs-string">"input error"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  Un peu surpris?  Ça arrive.  Nouvelle vulnérabilité, identifiant CVE correspondant: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CVE-2016-6262</a> . <br><br>  <b>Avertissement PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1010</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-20 Les</a> données contaminées non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contrôlées</a> sont utilisées dans l'index: 'strlen (ligne)'. <br><br>  Lors d'une autre tentative, le problème a été résolu en ajoutant une vérification de la longueur de la chaîne d'entrée: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) line[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> (line) - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>;</code> </pre> <br>  Jetons un coup d'œil aux dates.  L'engagement de «clôture» CVE-2015-8948 - 08/10/2015.  Valider la clôture CVE-2016-62-62 - 14/01/2016.  Autrement dit, la différence entre les corrections ci-dessus est de <i>5 mois</i> !  Ici, vous vous souvenez d'un tel avantage de l'analyse statique que la détection d'erreurs dans les premières étapes de l'écriture de code ... <br><br><h2>  Analyse statique et sécurité </h2><br>  Il n'y aura pas d'autres exemples de code, mais plutôt des statistiques et un raisonnement.  Dans cette section, l'opinion de l'auteur peut ne pas coïncider avec l'opinion du lecteur beaucoup plus qu'auparavant dans cet article. <br><br>  <b>Remarque</b>  Je vous recommande de lire un autre article sur un sujet similaire - " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment PVS-Studio peut-il aider à trouver des vulnérabilités?</a> ".  Il existe des exemples intéressants de vulnérabilités qui ressemblent à de simples erreurs.  De plus, dans cet article, j'ai parlé un peu de la terminologie et de la raison pour laquelle l'analyse statique est indispensable si vous êtes préoccupé par le sujet de la sécurité. <br><br>  Regardons les statistiques sur le nombre de vulnérabilités découvertes au cours des 10 dernières années pour évaluer la situation.  J'ai pris les données du site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CVE Details</a> . <br><br><p><img src="https://habrastorage.org/webt/lu/au/2i/luau2ik1aoqytidzblkeqjy8vhs.png" alt="Image 2"></p><br><br>  Une situation intéressante se profile.  Jusqu'en 2014, le nombre de CVE enregistrés n'a pas dépassé la barre des 6000 unités, et à partir de - il n'est pas descendu en dessous.  Mais le plus intéressant ici, bien sûr, ce sont les statistiques pour 2017 - le leader absolu (14714 unités).  Quant à l'année en cours - 2018 -, elle n'est pas encore terminée, mais bat déjà des records - 15 310 unités. <br><br>  Est-ce à dire que tous les nouveaux logiciels sont remplis de trous comme un tamis?  Je ne pense pas, et voici pourquoi: <br><br><ul><li>  Intérêt accru pour le sujet des vulnérabilités.  Certes, même si vous n'êtes pas très proche du sujet de la sécurité, vous avez rencontré à plusieurs reprises des articles, des notes, des rapports et des vidéos sur le sujet de la sécurité.  En d'autres termes, une sorte de «battage médiatique» a été créé.  C'est mauvais?  Probablement pas.  En fin de compte, tout se résume au fait que les développeurs sont plus préoccupés par la sécurité des applications, ce qui est bien. </li><li>  Une augmentation du nombre d'applications développées.  Plus de code - plus susceptible de se produire toute vulnérabilité qui reconstituera les statistiques. </li><li>  Outils de recherche de vulnérabilité améliorés et assurance qualité du code.  Plus de demande -&gt; plus d'offre.  Les analyseurs, fuzzers et autres outils sont de plus en plus avancés, ce qui joue entre les mains de ceux qui veulent rechercher des vulnérabilités (quel que soit le côté des barricades sur lequel ils se trouvent). </li></ul><br>  Ainsi, la tendance émergente ne peut pas être qualifiée de exclusivement négative - les éditeurs sont plus préoccupés par la sécurité de l'information, les outils pour détecter les problèmes sont améliorés, et tout cela est sans aucun doute positif. <br><br>  Est-ce à dire que vous pouvez vous détendre et ne pas vous «baigner»?  Je pense que non.  Si vous êtes préoccupé par le sujet de la sécurité de vos applications, vous devez prendre autant de mesures de sécurité que possible.  Cela est particulièrement vrai si le code source est dans le domaine public, car il: <br><br><ul><li>  plus susceptibles d'intégrer des vulnérabilités externes; </li><li>  plus enclins à "sonder" par ces "messieurs" qui sont intéressés par des trous dans votre application dans le but de les exploiter.  Bien que les sympathisants dans ce cas pourront vous aider davantage. </li></ul><br>  Je ne veux pas dire que vous n'avez pas besoin de traduire vos projets sous open source.  Gardez simplement à l'esprit les contrôles de qualité / sécurité appropriés. <br><br>  L'analyse statique est-elle une mesure supplémentaire?  Oui  L'analyse statique fait un bon travail pour détecter les vulnérabilités potentielles qui pourraient devenir réelles à l'avenir. <br><br>  Il me semble (j'avoue que je me trompe) que beaucoup considèrent les vulnérabilités comme un phénomène de haut niveau.  Oui et non.  Les problèmes de code qui semblent être de simples erreurs de programmation peuvent également être de graves vulnérabilités.  Encore une fois, quelques exemples de telles vulnérabilités sont fournis dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article mentionné précédemment</a> .  Ne sous-estimez pas les erreurs «simples». <br><br><h2>  Conclusion </h2><br>  N'oubliez pas que les données d'entrée peuvent être de longueur nulle, et cela doit également être pris en compte. <br><br>  Conclusions pour savoir si tout le battage publicitaire avec des vulnérabilités est juste du battage médiatique, ou si le problème existe, faites-le vous-même. <br><br>  Pour ma part, à moins que je ne propose d'essayer votre projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> , si vous ne l'avez pas déjà fait. <br><br>  Meilleurs vœux! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Sergey Vasiliev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tirez-vous dans le pied lors de la manipulation des données d'entrée</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433932/">https://habr.com/ru/post/fr433932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433918/index.html">Pourquoi le Web est-il si compliqué?</a></li>
<li><a href="../fr433920/index.html">Le géant chinois du silicium polycristallin augmente sa capacité</a></li>
<li><a href="../fr433922/index.html">Kubernetes Intensive: Support Jobs</a></li>
<li><a href="../fr433926/index.html">Framework Javascript: tendances 2019</a></li>
<li><a href="../fr433930/index.html">Profils distincts pour les indépendants et les clients</a></li>
<li><a href="../fr433934/index.html">SAFe ou Scaled Agile Framework</a></li>
<li><a href="../fr433936/index.html">Vous cherchez un cadeau high-tech pour un enfant? Pensez à un terrain de jeu, pas à un parc</a></li>
<li><a href="../fr433938/index.html">Comment Yandex et Google résument l'année</a></li>
<li><a href="../fr433940/index.html">Combien coûte Review dans l'AppStore</a></li>
<li><a href="../fr433944/index.html">Des exceptions dévastatrices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>