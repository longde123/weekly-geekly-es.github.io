<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚û°Ô∏è üì• üö∫ Implementierung des k-means (k-means) -Algorithmus am Beispiel der Arbeit mit Pixeln üåº ‚úäüèª üòó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Vor kurzem war es notwendig, Code zu schreiben, um die Bildsegmentierung unter Verwendung der k-means-Methode (englisch k-means) zu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung des k-means (k-means) -Algorithmus am Beispiel der Arbeit mit Pixeln</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427761/">  Hallo allerseits!  Vor kurzem war es notwendig, Code zu schreiben, um die Bildsegmentierung unter Verwendung der k-means-Methode (englisch k-means) zu implementieren.  Nun, das erste, was Google tut, ist Hilfe.  Ich habe viele Informationen gefunden, beispielsweise aus mathematischer Sicht (alle Arten komplexer mathematischer Skizzen dort, Sie werden verstehen, was zum Teufel dort geschrieben steht) sowie einige Software-Implementierungen, die im englischen Internet verf√ºgbar sind.  Diese Codes sind sicherlich wundersch√∂n - kein Zweifel, aber das Wesentliche der Idee ist schwer zu fassen.  Irgendwie ist dort alles kompliziert, verwirrt und doch, von Hand, von Hand, schreiben Sie den Code nicht, Sie verstehen nichts.  In diesem Artikel m√∂chte ich eine einfache, nicht produktive, aber hoffentlich verst√§ndliche Implementierung dieses wunderbaren Algorithmus zeigen.  Okay, lass uns gehen! <br><a name="habracut"></a><br>  Was ist Clustering in Bezug auf unsere Wahrnehmungen?  Lassen Sie mich ein Beispiel geben, sagen wir, es gibt ein sch√∂nes Bild mit Blumen aus dem Haus Ihrer Gro√ümutter. <br><br><img src="https://habrastorage.org/webt/o2/0j/p5/o20jp5rx4sfpjieou7ipk8mfika.jpeg"><br><br>  Die Frage ist: um festzustellen, wie viele Bereiche auf diesem Foto mit ungef√§hr derselben Farbe gef√ºllt sind.  Nun, es ist √ºberhaupt nicht schwierig: wei√üe Bl√ºtenbl√§tter - eins, gelbe Zentren - zwei (ich bin kein Biologe, ich wei√ü nicht, wie sie hei√üen), drei gr√ºne.  Diese Abschnitte werden als Cluster bezeichnet.  Ein Cluster ist eine Kombination von Daten mit gemeinsamen Merkmalen (Farbe, Position usw.).  Das Bestimmen und Platzieren jeder Komponente von Daten in solchen Clustern wird als Clustering bezeichnet. <br><br>  Es gibt viele Clustering-Algorithmen, aber der einfachste davon ist k - medium, worauf sp√§ter noch eingegangen wird.  K-means ist ein einfacher und effizienter Algorithmus, der mithilfe einer Softwaremethode einfach zu implementieren ist.  Die Daten, die wir in Clustern verteilen, sind Pixel.  Wie Sie wissen, besteht ein Farbpixel aus drei Komponenten: Rot, Gr√ºn und Blau.  Durch das Auferlegen dieser Komponenten wird eine Palette vorhandener Farben erstellt. <br><br><img src="https://habrastorage.org/webt/gf/5u/b1/gf5ub1f-9xv56o7b86jsozumzlw.jpeg"><br><br>  Im Speicher des Computers ist jede Farbkomponente durch eine Zahl von 0 bis 255 gekennzeichnet. Wenn Sie also verschiedene Werte f√ºr Rot, Gr√ºn und Blau kombinieren, wird eine Farbpalette auf dem Bildschirm angezeigt. <br><br>  Am Beispiel von Pixeln implementieren wir unseren Algorithmus.  K-means ist ein iterativer Algorithmus, dh er liefert nach einer bestimmten Anzahl von Wiederholungen einiger mathematischer Berechnungen das richtige Ergebnis. <br><br><h3>  Algorithmus </h3><br><ol><li>  Sie m√ºssen im Voraus wissen, wie viele Cluster Sie zum Verteilen der Daten ben√∂tigen.  Dies ist ein wesentlicher Nachteil dieser Methode, aber dieses Problem wird durch verbesserte Implementierungen des Algorithmus gel√∂st, aber dies ist, wie sie sagen, eine ganz andere Geschichte. </li><li>  Wir m√ºssen die Anfangszentren unserer Cluster ausw√§hlen.  Wie?  Ja zuf√§llig.  Warum?  Damit k√∂nnen Sie jedes Pixel in der Mitte des Clusters einrasten lassen.  Das Zentrum ist wie der K√∂nig, um den sich seine Motive versammeln - Pixel.  Es ist der ‚ÄûAbstand‚Äú von der Mitte zum Pixel, der bestimmt, wem jedes Pixel gehorcht. </li><li>  Wir berechnen den Abstand von jedem Zentrum zu jedem Pixel.  Dieser Abstand wird als euklidischer Abstand zwischen Punkten im Raum und in unserem Fall als Abstand zwischen den drei Farbkomponenten betrachtet: <p><math> </math> $$ display $$ \ sqrt {(R_ {2} -R_ {1}) ^ 2 + (G_ {2} -G_ {1}) ^ 2 + (B_ {2} -B_ {1}) ^ 2} $$ Anzeige $$ </p>  Wir berechnen den Abstand vom ersten Pixel zu jedem Zentrum und bestimmen den kleinsten Abstand zwischen diesem Pixel und den Zentren.  F√ºr das Zentrum, dessen Abstand am kleinsten ist, berechnen wir die Koordinaten als arithmetisches Mittel zwischen jeder Komponente des Pixels - dem K√∂nig und dem Pixel - des Subjekts neu.  Unser Zentrum verschiebt sich nach Berechnungen im Raum. </li><li>  Nachdem wir alle Zentren nachgez√§hlt haben, verteilen wir die Pixel in Cluster und vergleichen den Abstand zwischen jedem Pixel und den Zentren.  Ein Pixel wird in einem Cluster platziert, an dessen Zentrum es n√§her liegt als an den anderen Zentren. </li><li>  Alles beginnt von vorne, solange sich die Pixel in denselben Clustern befinden.  Oft kann dies nicht passieren, da sich bei einer gro√üen Datenmenge die Zentren in einem kleinen Radius bewegen und die Pixel entlang der Kanten der Cluster in den einen oder anderen Cluster springen.  Bestimmen Sie dazu die maximale Anzahl von Iterationen. </li></ol><br><h3>  Implementierung </h3><br>  Ich werde dieses Projekt in C ++ implementieren.  Die erste Datei ist "k_means.h", darin habe ich die Hauptdatentypen, Konstanten und die Hauptklasse f√ºr die Arbeit definiert - "K_means". <br>  Um jedes Pixel zu charakterisieren, erstellen Sie eine Struktur, die aus drei Pixelkomponenten besteht, f√ºr die ich den Doppeltyp f√ºr genauere Berechnungen ausgew√§hlt und einige Konstanten f√ºr das Programm definiert habe: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> KK = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const int max_iterations = 100; //   typedef struct { double r; double g; double b; } rgb;</span></span></code> </pre> <br>  K_ bedeutet Klasse selbst: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K_means</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; pixcel; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q_klaster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k_pixcel; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; centr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identify_centers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rgb k1, rgb k2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.r - k2.r),<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.g - k2.g), <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.b - k2.b), <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: K_means() : q_klaster(<span class="hljs-number"><span class="hljs-number">0</span></span>), k_pixcel(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}; K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb *mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster); K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clustering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream &amp; os)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ~K_means(); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k); };</code> </pre><br>  Lassen Sie uns die Komponenten der Klasse durchgehen: <br><br>  vectorpixcel - ein Vektor f√ºr Pixel; <br>  q_klaster - Anzahl der Cluster; <br>  k_pixcel - Anzahl der Pixel; <br>  vectorcentr - ein Vektor f√ºr Clustering-Zentren, dessen Anzahl durch q_klaster bestimmt wird; <br>  identity_centers () - eine Methode zur zuf√§lligen Auswahl von Anfangszentren unter den Eingabepixeln; <br>  integrierte Methoden compute () und compute_s () zum Berechnen des Abstands zwischen Pixeln bzw. Neuberechnungszentren; <br>  Drei Konstruktoren: Der erste dient standardm√§√üig zum Initialisieren von Pixeln aus einem Array, der dritte zum Initialisieren von Pixeln aus einer Textdatei (in meiner Implementierung wird die Datei zun√§chst versehentlich mit Daten gef√ºllt, und dann werden Pixel aus dieser Datei gelesen, damit das Programm funktioniert, warum nicht direkt in den Vektor - nur in meinem Fall ben√∂tigt); <br>  Clustering (std :: ostream &amp; os) - Clustering-Methode; <br>  Methode und √úberladung der Ausgabeanweisung zum Ver√∂ffentlichen der Ergebnisse. <br><br>  Methodenimplementierung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::identify_centers() { srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); rgb temp; rgb *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rgb[q_klaster]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { temp = pixcel[<span class="hljs-number"><span class="hljs-number">0</span></span> + rand() % k_pixcel]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &lt; q_klaster; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp.r != mas[j].r &amp;&amp; temp.g != mas[j].g &amp;&amp; temp.b != mas[j].b) { mas[j] = temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { centr.push_back(mas[i]); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> []mas; }</code> </pre><br>  Dies ist eine Methode zum Ausw√§hlen der anf√§nglichen Clustering-Zentren und zum Hinzuf√ºgen dieser zum Center-Vektor.  In diesen F√§llen wird eine √úberpr√ºfung durchgef√ºhrt, um die Zentren zu wiederholen und zu ersetzen. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb * mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { pixcel.push_back(*(mas + i)); } q_klaster = n_klaster; k_pixcel = n; identify_centers(); }</code> </pre><br>  Eine Konstruktorimplementierung zum Initialisieren von Pixeln aus einem Array. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os) : q_klaster(n_klaster) { rgb temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (os &gt;&gt; temp.r &amp;&amp; os &gt;&gt; temp.g &amp;&amp; os &gt;&gt; temp.b) { pixcel.push_back(temp); } k_pixcel = pixcel.size(); identify_centers(); }</code> </pre><br>  Wir √ºbergeben diesem Konstruktor ein Eingabeobjekt, um Daten sowohl aus der Datei als auch aus der Konsole eingeben zu k√∂nnen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::clustering(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n :"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*             :        ,    -  ,    ,   ,        .*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_1(k_pixcel, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_2(k_pixcel, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n----------------  ‚Ññ"</span></span> &lt;&lt; iter &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ----------------\n\n"</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*  :          .      ,   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[j], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     m_k      .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"  #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; centr[m_k].r = compute_s(pixcel[j].r, centr[m_k].r); centr[m_k].g = compute_s(pixcel[j].g, centr[m_k].g); centr[m_k].b = compute_s(pixcel[j].b, centr[m_k].b); os &lt;&lt; centr[m_k].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mas; } <span class="hljs-comment"><span class="hljs-comment">/*   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *mass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[k_pixcel]; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n  : "</span></span>&lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; k_pixcel; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[k], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*  .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } mass[k] = m_k; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"     #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*            .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n    : \n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k_pixcel; i++) { os &lt;&lt; mass[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; check_1[i] = *(mass + i); } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itr = KK + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mass[j] == i) { os &lt;&lt; pixcel[j].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; mass[j] = ++itr; } } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mass; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : \n"</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*         ‚Äì  .*/</span></span> iter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_1 == check_2 || iter &gt;= max_iterations) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } check_2 = check_1; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n ."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre>  Die Hauptmethode f√ºr das Clustering. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.k_pixcel; i++) { os &lt;&lt; k.pixcel[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - ‚Ññ"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.q_klaster; i++) { os &lt;&lt; k.centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n : "</span></span> &lt;&lt; k.q_klaster &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; k.k_pixcel &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre><br>  Die Ausgabe der Anfangsdaten. <br><br><h4>  Ausgabebeispiel </h4><br><div class="spoiler">  <b class="spoiler_title">Ausgabebeispiel</b> <div class="spoiler_text">  <em>Startpixel:</em> <em><br></em>  <em>255 140 50 - Nr. 0</em> <em><br></em>  <em>100 70 1 - Nr. 1</em> <em><br></em>  <em>150 20 200 - Nr. 2</em> <em><br></em>  <em>251 141 51 - Nr.3</em> <em><br></em>  <em>104 69 3 - Nr. 4</em> <em><br></em>  <em>153 22 210 - Nr. 5</em> <em><br></em>  <em>252 138 54 - Nr. 6</em> <em><br></em>  <em>101 74 4 - Nr. 7</em> <em><br><br></em>  <em>Zuf√§llige anf√§ngliche Clustering-Zentren:</em> <em><br></em>  <em>150 20 200 - # 0</em> <em><br></em>  <em>104 69 3 - # 1</em> <em><br></em>  <em>100 70 1 - # 2</em> <em><br><br></em>  <em>Anzahl der Cluster: 3</em> <em><br></em>  <em>Anzahl der Pixel: 8</em> <em><br><br></em>  <em>Cluster-Start:</em> <em><br><br></em>  <em>Iterationsnummer 0</em> <em><br><br></em>  <em>Abstand von Pixel 0 zur Mitte # 0: 218.918</em> <em><br></em>  <em>Abstand von Pixel 0 zur Mitte Nr. 1: 173.352</em> <em><br></em>  <em>Abstand von Pixel 0 zur Mitte Nr. 2: 176,992</em> <em><br></em>  <em>Minimaler Achsabstand # 1</em> <em><br></em>  <em>Neuberechnung des Zentrums Nr. 1: 179,5 104,5 26,5</em> <em><br></em>  <em>Abstand von Pixel 1 zur Mitte # 0: 211.189</em> <em><br></em>  <em>Abstand von Pixel 1 zur Mitte Nr. 1: 90,3369</em> <em><br></em>  <em>Abstand von Pixel 1 zur Mitte Nr. 2: 0</em> <em><br></em>  <em>Minimaler Achsabstand # 2</em> <em><br></em>  <em>Neuberechnung des Zentrums Nr. 2: 100 70 1</em> <em><br></em>  <em>Abstand von Pixel 2 zur Mitte # 0: 0</em> <em><br></em>  <em>Abstand von Pixel 2 zur Mitte Nr. 1: 195,225</em> <em><br></em>  <em>Abstand von Pixel 2 zur Mitte Nr. 2: 211.189</em> <em><br></em>  <em>Minimaler Achsabstand # 0</em> <em><br></em>  <em>Z√§hlen der Mitte # 0: 150 20 200</em> <em><br></em>  <em>Abstand von Pixel 3 zur Mitte # 0: 216.894</em> <em><br></em>  <em>Abstand von Pixel 3 zur Mitte Nr. 1: 83,933</em> <em><br></em>  <em>Abstand von Pixel 3 zur Mitte Nr. 2: 174,19</em> <em><br></em>  <em>Minimaler Achsabstand # 1</em> <em><br></em>  <em>Z√§hlen der Mitte Nr. 1: 215,25 122,75 38,75</em> <em><br></em>  <em>Abstand von Pixel 4 zur Mitte # 0: 208.149</em> <em><br></em>  <em>Abstand von Pixel 4 zur Mitte Nr. 1: 128.622</em> <em><br></em>  <em>Abstand von Pixel 4 zur Mitte Nr. 2: 4,58258</em> <em><br></em>  <em>Minimaler Achsabstand # 2</em> <em><br></em>  <em>Z√§hlen der Mitte # 2: 102 69,5 2</em> <em><br></em>  <em>Abstand von Pixel 5 zur Mitte # 0: 10.6301</em> <em><br></em>  <em>Abstand von Pixel 5 zur Mitte Nr. 1: 208.212</em> <em><br></em>  <em>Abstand von Pixel 5 zur Mitte Nr. 2: 219,366</em> <em><br></em>  <em>Minimaler Achsabstand # 0</em> <em><br></em>  <em>Neuberechnung des Zentrums # 0: 151,5 21 205</em> <em><br></em>  <em>Abstand von Pixel 6 zur Mitte # 0: 215.848</em> <em><br></em>  <em>Abstand von Pixel 6 zur Mitte Nr. 1: 42.6109</em> <em><br></em>  <em>Abstand von Pixel 6 zur Mitte Nr. 2: 172.905</em> <em><br></em>  <em>Minimaler Achsabstand # 1</em> <em><br></em>  <em>Neuberechnung des Zentrums Nr. 1: 233.625 130.375 46.375</em> <em><br></em>  <em>Abstand von Pixel 7 zur Mitte # 0: 213.916</em> <em><br></em>  <em>Abstand von Pixel 7 zur Mitte Nr. 1: 150,21</em> <em><br></em>  <em>Abstand von Pixel 7 zur Mitte Nr. 2: 5.02494</em> <em><br></em>  <em>Minimaler Achsabstand # 2</em> <em><br></em>  <em>Neuberechnung des Zentrums Nr. 2: 101,5 71,75 3</em> <em><br><br></em>  <em>Lassen Sie uns die Pixel klassifizieren:</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 0 zur Mitte Nr. 0: 221.129</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 0 zur Mitte Nr. 1: 23.7207</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 0 zur Mitte Nr. 2: 174,44</em> <em><br></em>  <em>Pixel Nr. 0 am n√§chsten zur Mitte Nr. 1</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 1 zur Mitte Nr. 0: 216.031</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 1 zur Mitte Nr. 1: 153,492</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 1 zur Mitte Nr. 2: 3.05164</em> <em><br></em>  <em>Pixel Nr. 1 am n√§chsten zur Mitte Nr. 2</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 2 zur Mitte Nr. 0: 5,31507</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 2 zur Mitte Nr. 1: 206,825</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 2 zur Mitte Nr. 2: 209.378</em> <em><br></em>  <em>Pixel Nr. 2 am n√§chsten zur Mitte Nr. 0</em> <em><br></em>  <em>Der Abstand von der Pixelnummer 3 zur Mitte # 0: 219.126</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 3 zur Mitte Nr. 1: 20,8847</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 3 zur Mitte Nr. 2: 171.609</em> <em><br></em>  <em>Pixel Nr. 3 am n√§chsten zur Mitte Nr. 1</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 4 zur Mitte Nr. 0: 212.989</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 4 zur Mitte Nr. 1: 149,836</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 4 zur Mitte Nr. 2: 3,71652</em> <em><br></em>  <em>Pixel Nr. 4 am n√§chsten zur Mitte Nr. 2</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 5 zur Mitte Nr. 0: 5,31507</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 5 zur Mitte Nr. 1: 212.176</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 5 zur Mitte Nr. 2: 219.035</em> <em><br></em>  <em>Pixel Nr. 5 am n√§chsten zur Mitte Nr. 0</em> <em><br></em>  <em>Der Abstand von der Pixelnummer 6 zur Mitte # 0: 215.848</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 6 zur Mitte Nr. 1: 21.3054</em> <em><br></em>  <em>Der Abstand von der Pixelnummer 6 zur Mitte # 2: 172.164</em> <em><br></em>  <em>Pixel Nr. 6 am n√§chsten zur Mitte Nr. 1</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 7 zur Mitte Nr. 0: 213.916</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 7 zur Mitte Nr. 1: 150,21</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 7 zur Mitte Nr. 2: 2,51247</em> <em><br></em>  <em>Pixel Nr. 7 am n√§chsten zur Mitte Nr. 2</em> <em><br><br></em>  <em>Eine Reihe √ºbereinstimmender Pixel und Zentren:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Clustering-Ergebnis:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Neue Zentren:</em> <em><br></em>  <em>151,5 21 205 - # 0</em> <em><br></em>  <em>233.625 130.375 46.375 - # 1</em> <em><br></em>  <em>101,5 71,75 3 - # 2</em> <em><br><br></em>  <em>Iterationsnummer 1</em> <em><br><br></em>  <em>Abstand von Pixel 0 zur Mitte # 0: 221.129</em> <em><br></em>  <em>Abstand von Pixel 0 zur Mitte Nr. 1: 23.7207</em> <em><br></em>  <em>Abstand von Pixel 0 zur Mitte Nr. 2: 174,44</em> <em><br></em>  <em>Minimaler Achsabstand # 1</em> <em><br></em>  <em>Z√§hlen des Zentrums Nr. 1: 244.313 135.188 48.1875</em> <em><br></em>  <em>Abstand von Pixel 1 zur Mitte # 0: 216.031</em> <em><br></em>  <em>Abstand von Pixel 1 zur Mitte Nr. 1: 165,234</em> <em><br></em>  <em>Abstand von Pixel 1 zur Mitte Nr. 2: 3.05164</em> <em><br></em>  <em>Minimaler Achsabstand # 2</em> <em><br></em>  <em>Neuberechnung des Zentrums Nr. 2: 100,75 70,875 2</em> <em><br></em>  <em>Abstand von Pixel 2 zur Mitte # 0: 5.31507</em> <em><br></em>  <em>Abstand von Pixel 2 zur Mitte Nr. 1: 212.627</em> <em><br></em>  <em>Abstand von Pixel 2 zur Mitte Nr. 2: 210,28</em> <em><br></em>  <em>Minimaler Achsabstand # 0</em> <em><br></em>  <em>Neuberechnung des Zentrums # 0: 150,75 20,5 202,5</em> <em><br></em>  <em>Abstand von Pixel 3 zur Mitte # 0: 217.997</em> <em><br></em>  <em>Abstand von Pixel 3 zur Mitte Nr. 1: 9,29613</em> <em><br></em>  <em>Abstand von Pixel 3 zur Mitte Nr. 2: 172.898</em> <em><br></em>  <em>Minimaler Achsabstand # 1</em> <em><br></em>  <em>Z√§hlen der Mitte Nr. 1: 247.656 138.094 49.5938</em> <em><br></em>  <em>Abstand von Pixel 4 zur Mitte # 0: 210,566</em> <em><br></em>  <em>Abstand von Pixel 4 zur Mitte Nr. 1: 166.078</em> <em><br></em>  <em>Abstand von Pixel 4 zur Mitte Nr. 2: 3.88306</em> <em><br></em>  <em>Minimaler Achsabstand # 2</em> <em><br></em>  <em>Z√§hlen der Mitte Nr. 2: 102.375 69.9375 2.5</em> <em><br></em>  <em>Abstand von Pixel 5 zur Mitte # 0: 7.97261</em> <em><br></em>  <em>Abstand von Pixel 5 zur Mitte Nr. 1: 219.471</em> <em><br></em>  <em>Abstand von Pixel 5 zur Mitte Nr. 2: 218,9</em> <em><br></em>  <em>Minimaler Achsabstand # 0</em> <em><br></em>  <em>Z√§hlen der Mitte # 0: 151.875 21.25 206.25</em> <em><br></em>  <em>Abstand von Pixel 6 zur Mitte # 0: 216.415</em> <em><br></em>  <em>Abstand von Pixel 6 zur Mitte Nr. 1: 6.18805</em> <em><br></em>  <em>Abstand von Pixel 6 zur Mitte Nr. 2: 172,257</em> <em><br></em>  <em>Minimaler Achsabstand # 1</em> <em><br></em>  <em>Neuberechnung des Zentrums Nr. 1: 249.828 138.047 51.7969</em> <em><br></em>  <em>Abstand von Pixel 7 zur Mitte # 0: 215.118</em> <em><br></em>  <em>Abstand von Pixel 7 zur Mitte Nr. 1: 168.927</em> <em><br></em>  <em>Abstand von Pixel 7 zur Mitte Nr. 2: 4,54363</em> <em><br></em>  <em>Minimaler Achsabstand # 2</em> <em><br></em>  <em>Neuberechnung des Zentrums Nr. 2: 101.688 71.9688 3.25</em> <em><br><br></em>  <em>Lassen Sie uns die Pixel klassifizieren:</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 0 zur Mitte Nr. 0: 221.699</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 0 zur Mitte Nr. 1: 5,81307</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 0 zur Mitte Nr. 2: 174,122</em> <em><br></em>  <em>Pixel Nr. 0 am n√§chsten zur Mitte Nr. 1</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 1 zur Mitte Nr. 0: 217,244</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 1 zur Mitte Nr. 1: 172,218</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 1 zur Mitte Nr. 2: 3,43309</em> <em><br></em>  <em>Pixel Nr. 1 am n√§chsten zur Mitte Nr. 2</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 2 zur Mitte Nr. 0: 6.64384</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 2 zur Mitte Nr. 1: 214.161</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 2 zur Mitte Nr. 2: 209.154</em> <em><br></em>  <em>Pixel Nr. 2 am n√§chsten zur Mitte Nr. 0</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 3 zur Mitte Nr. 0: 219.701</em> <em><br></em>  <em>Abstand von Pixel 3 zu Mitte 1: 3,27555</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 3 zur Mitte Nr. 2: 171,288</em> <em><br></em>  <em>Pixel Nr. 3 am n√§chsten zur Mitte Nr. 1</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 4 zur Mitte Nr. 0: 214.202</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 4 zur Mitte Nr. 1: 168,566</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 4 zur Mitte Nr. 2: 3,77142</em> <em><br></em>  <em>Pixel Nr. 4 am n√§chsten zur Mitte Nr. 2</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 5 zur Mitte Nr. 0: 3,9863</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 5 zur Mitte Nr. 1: 218.794</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 5 zur Mitte Nr. 2: 218.805</em> <em><br></em>  <em>Pixel Nr. 5 am n√§chsten zur Mitte Nr. 0</em> <em><br></em>  <em>Der Abstand von der Pixelnummer 6 zur Mitte # 0: 216.415</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 6 zur Mitte Nr. 1: 3.09403</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 6 zur Mitte Nr. 2: 171,842</em> <em><br></em>  <em>Pixel Nr. 6 am n√§chsten zur Mitte Nr. 1</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 7 zur Mitte Nr. 0: 215,118</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 7 zur Mitte Nr. 1: 168,927</em> <em><br></em>  <em>Der Abstand vom Pixel Nr. 7 zur Mitte Nr. 2: 2,27181</em> <em><br></em>  <em>Pixel Nr. 7 am n√§chsten zur Mitte Nr. 2</em> <em><br><br></em>  <em>Eine Reihe √ºbereinstimmender Pixel und Zentren:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Clustering-Ergebnis:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Neue Zentren:</em> <em><br></em>  <em>151,875 21,25 206,25 - # 0</em> <em><br></em>  <em>249.828 138.047 51.7969 - # 1</em> <em><br></em>  <em>101.688 71.9688 3.25 - # 2</em> <em><br><br></em>  <em>Das Ende des Clusters.</em> <br></div></div><br>  Dieses Beispiel ist im Voraus geplant, die Pixel werden speziell zur Demonstration ausgew√§hlt.  Zwei Iterationen reichen aus, damit das Programm die Daten in drei Cluster gruppiert.  Wenn Sie sich die Zentren der letzten beiden Iterationen ansehen, k√∂nnen Sie sehen, dass sie praktisch an Ort und Stelle geblieben sind. <br><br>  Interessanter sind die F√§lle zuf√§llig erzeugter Pixel.  Nachdem ich 50 Punkte generiert hatte, die in 10 Cluster unterteilt werden m√ºssen, erhielt ich 5 Iterationen.  Nachdem ich 50 Punkte generiert habe, die in 3 Cluster unterteilt werden m√ºssen, habe ich alle 100 maximal zul√§ssigen Iterationen erhalten.  M√∂glicherweise stellen Sie fest, dass es f√ºr das Programm umso einfacher ist, die √§hnlichsten Pixel zu finden und zu kleineren Gruppen zu kombinieren, je mehr Cluster vorhanden sind. Wenn nur wenige Cluster und viele Punkte vorhanden sind, endet der Algorithmus h√§ufig erst, wenn die maximale Anzahl von Iterationen √ºberschritten wird, da einige Pixel st√§ndig springen von einem Cluster zum anderen.  Die Masse wird jedoch immer noch vollst√§ndig in ihren Clustern bestimmt. <br><br>  Nun wollen wir das Ergebnis des Clusters √ºberpr√ºfen.  Ich habe das Ergebnis einiger Cluster aus dem Beispiel von 50 Punkten pro 10 Cluster genommen und das Ergebnis dieser Daten in Illustrator √ºbertragen. Folgendes ist passiert: <br><br><img src="https://habrastorage.org/webt/b2/fl/me/b2flmelfv6bqxeautb8s4ywwstm.jpeg"><br><br>  Es ist zu sehen, dass in jedem Cluster Farbt√∂ne vorherrschen, und hier muss man verstehen, dass die Pixel zuf√§llig ausgew√§hlt wurden. Das Analogon eines solchen Bildes im wirklichen Leben ist eine Art Bild, auf das alle Farben versehentlich gespr√ºht wurden, und es ist schwierig, Bereiche mit √§hnlichen Farben auszuw√§hlen. <br><br>  Nehmen wir an, wir haben so ein Foto.  Wir k√∂nnen eine Insel als einen Cluster definieren, aber mit zunehmender Zunahme sehen wir, dass sie aus verschiedenen Gr√ºnt√∂nen besteht. <br><br><img src="https://habrastorage.org/webt/s8/qv/um/s8qvumchfqerkbdfo5gx7ijm4to.jpeg"><br><br>  Und dies ist Cluster 8, aber in einer kleineren Version ist das Ergebnis √§hnlich: <br><br><img src="https://habrastorage.org/webt/dt/ia/eb/dtiaebsnf1uzpi69jqmbkvui5uo.jpeg"><br><br>  Die Vollversion des Programms kann auf meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> eingesehen werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427761/">https://habr.com/ru/post/de427761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427749/index.html">Apple und Samsung haben zum ersten Mal eine Geldstrafe wegen Verlangsamung alter Telefone verh√§ngt</a></li>
<li><a href="../de427751/index.html">CudaText Erhabene Ideen</a></li>
<li><a href="../de427755/index.html">Neue Version von GitLab 11.4 mit Peer Review von Zusammenf√ºhrungsanforderungen und Feature-Flags</a></li>
<li><a href="../de427757/index.html">Zusammengebaute Microcode-Hintert√ºren des X86-Prozessors</a></li>
<li><a href="../de427759/index.html">√úber die L√∂sbarkeit von Umgehungsproblemen in der Polynomzeit</a></li>
<li><a href="../de427763/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 13: Netzwerkprotokolle, Teil 1</a></li>
<li><a href="../de427767/index.html">Situation: In Kanada wurde vorgeschlagen, eine Steuer auf Streaming einzuf√ºhren - wir diskutieren das Problem</a></li>
<li><a href="../de427771/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 13: Netzwerkprotokolle, Teil 2</a></li>
<li><a href="../de427773/index.html">Ich habe eine browser√ºbergreifende Erweiterung f√ºr Registerkarten geschrieben, aber das tun Sie nicht</a></li>
<li><a href="../de427775/index.html">Ein als Programmierer getarnter Bot korrigiert Codefehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>