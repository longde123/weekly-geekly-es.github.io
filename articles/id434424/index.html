<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏸 🧕🏽 🏥 Dasar-dasar API SUARA JAVA 😯 🤲🏽 📗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan bagi Anda terjemahan artikel “Java Sound, Getting Started, Part 1, Playback” . 

 Suara di JAWA, Bagian Satu, Awal. M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar API SUARA JAVA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434424/">  Halo, Habr!  Saya mempersembahkan bagi Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Java Sound, Getting Started, Part 1, Playback”</a> . <br><br><h3>  Suara di JAWA, Bagian Satu, Awal.  Memutar suara </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1JZnj4eNHXE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ini adalah awal dari serangkaian delapan pelajaran yang akan membiasakan Anda dengan Java Sound API. <br><a name="habracut"></a><br>  Apa yang masuk akal dalam persepsi manusia?  Ini adalah perasaan yang kita alami ketika perubahan tekanan udara ditransmisikan ke area sensorik kecil di dalam telinga kita. <br><br>  Dan tujuan utama pembuatan API Suara adalah untuk memberi Anda sarana untuk menulis kode, yang akan membantu mentransfer gelombang tekanan ke telinga subjek yang tepat pada waktu yang tepat. <br><br>  Jenis suara di Jawa: <br><br><ol><li>  Java Sound API mendukung dua jenis utama audio (suara). </li><li>  Suara didigitalkan dan direkam langsung sebagai file </li><li>  Rekam sebagai file MIDI.  Sangat jauh, tetapi mirip dengan notasi musik, di mana alat musik dimainkan dalam urutan yang diinginkan. </li></ol><br>  Jenis ini sangat berbeda dalam esensinya dan kami akan berkonsentrasi pada yang pertama, karena dalam kebanyakan kasus kita berurusan dengan suara yang harus didigitalkan untuk merekam dari sumber eksternal ke file atau sebaliknya untuk mereproduksi suara yang sebelumnya direkam dari file tersebut. <br><br><h3>  Pratinjau </h3><br>  Java Sound API didasarkan pada konsep <i>garis dan mixer.</i> <br><br>  Selanjutnya: <br>  Kami akan menjelaskan karakteristik fisik dan listrik dari representasi analog suara sebagaimana diterapkan pada <i>mixer audio</i> . <br><br>  Kami akan beralih ke skenario band rock awal, yang menggunakan enam mikrofon dan dua speaker stereo dalam kasus ini.  Kami membutuhkan ini untuk memahami pengoperasian mixer audio. <br><br>  Selanjutnya, kita melihat sejumlah tema Java Sound untuk pemrograman, seperti garis, mixer, format untuk data audio, dan banyak lagi. <br><br>  Kami akan memahami hubungan yang ada antara objek SourceDataLine, Klip, Mixer, AudioFormat dan membuat program sederhana yang mereproduksi audio. <br><br>  Di bawah ini kami berikan contoh program ini, yang dapat Anda gunakan untuk merekam dan kemudian memutar suara yang direkam. <br><br>  Di masa mendatang, kami akan memberikan penjelasan lengkap tentang kode program yang digunakan untuk tujuan ini.  Tetapi sama sekali tidak sepenuhnya dalam pelajaran ini. <br><br><h3>  Contoh dan Pertimbangan Kode </h3><br>  <b>Karakteristik fisik dan listrik dari suara analog</b> <br><br>  Tujuan dari pelajaran kami adalah untuk memperkenalkan Anda pada dasar-dasar pemrograman Java menggunakan Java Sound API. <br><br>  Java Sound API didasarkan pada konsep mixer audio, yang merupakan perangkat yang biasa digunakan ketika memutar suara hampir di mana saja: dari konser rock hingga mendengarkan CD di rumah.  Tetapi sebelum memulai penjelasan rinci tentang pengoperasian mixer audio, akan berguna untuk membiasakan diri dengan karakteristik fisik dan listrik dari suara analog itu sendiri. <br><br>  <i>Lihatlah Gambar.</i>  <i>1</i> <br><br><img src="https://habrastorage.org/webt/ez/tu/sq/eztusq7byax0l9nu-5r6vj3vkxe.gif"><br><br>  Vasya Pupyrkin mendorong sebuah pidato. <br><br>  Gambar ini menunjukkan Vasya berpidato menggunakan sistem yang dikenal sebagai alamat beralamat lebar.  Sistem seperti itu biasanya meliputi mikrofon, amplifier, dan speaker.  Tujuan dari sistem ini adalah untuk memperkuat suara Vasya sehingga ia dapat didengar bahkan dalam kerumunan besar. <br><br>  <b>Goyangan di udara</b> <br><br>  Secara singkat, ketika Vasya berbicara, pita suaranya menyebabkan partikel udara bergetar di laringnya.  Ini mengarah pada munculnya gelombang suara, yang, pada gilirannya, menyebabkan membran mikrofon bergetar dan kemudian berubah menjadi getaran listrik dengan amplitudo sangat kecil yang secara tepat mensimulasikan getaran suara dari sumber asli Vasya.  Sebuah penguat, seperti namanya, memperkuat getaran listrik ini.  Kemudian mereka sampai ke pengeras suara, yang melakukan transformasi kebalikan dari getaran listrik yang diamplifikasi menjadi gelombang suara yang sangat diperkuat, tetapi yang bagaimanapun persisnya mengulangi gelombang yang sama yang dihasilkan dalam pita suara Vasya Pupyrkin. <br><br>  <b>Mikrofon dinamis</b> <br><br>  Sekarang mari kita lihat Gambar.  2, yang menunjukkan diagram skematik dari mikrofon yang disebut dinamis. <br><br><img src="https://habrastorage.org/webt/hz/1v/ui/hz1vui2-yqnq4cg3xdpi5iy-1w0.gif"><br>  <i>Fig.</i>  <i>2 Rangkaian mikrofon dinamis</i> <br><br>  <b>Getaran suara mempengaruhi membran</b> <br><br>  Tekanan getaran suara bekerja pada membran fleksibel di dalam mikrofon.  Ini menyebabkan membran bergetar, sementara getaran membran mengulangi getaran gelombang suara. <br><br>  <b>Koil bergerak</b> <br><br>  Sebuah gulungan kawat tipis melekat pada membran mikrofon.  Sebagai membran berosilasi, koil juga membuat gerakan bolak-balik di medan magnet inti yang terbuat dari magnet permanen yang kuat.  Dan seperti Faraday juga didirikan, arus listrik muncul di koil. <br><br>  <b>Sinyal listrik mengikuti bentuk gelombang suara.</b> <br><br>  Dengan demikian, dari arus yang sangat lemah yang diinduksi dalam koil, sinyal listrik bolak-balik diperoleh, mengulangi bentuk gelombang suara yang bekerja pada membran mikrofon.  Selanjutnya, sinyal ini dalam bentuk tegangan bolak-balik dimasukkan ke input penguat dari Gambar.  1. <br><br>  <b>Loudspeaker</b> <br><br>  Bahkan, prinsip pengoperasian speaker mengulangi perangkat mikrofon dinamis, hanya dihidupkan ke arah yang berlawanan.  <i>(Secara alami, dalam hal ini, kabel belitan jauh lebih tebal, dan membran jauh lebih besar untuk memastikan operasi dengan sinyal yang diperkuat)</i> <i><br></i> <br><br><img src="https://habrastorage.org/webt/0e/ec/4x/0eec4xwyiyp2icsx69azgymv78c.gif"><br><br>  Osilasi membran pengeras suara memengaruhi partikel udara dan menciptakan gelombang suara yang kuat.  Bentuk gelombang ini persis mengulangi bentuk gelombang suara dengan intensitas yang jauh lebih rendah yang diciptakan oleh pita suara Vasya.  Tetapi intensitas gelombang baru sekarang cukup untuk memastikan bahwa getaran suara dari Vasya mencapai telinga orang yang berdiri bahkan di barisan belakang kerumunan besar. <br><br>  <b>Konser rock</b> <br><br>  Pada saat ini, Anda mungkin bertanya-tanya, apa hubungannya semua ini dengan Java Sound API?  Tapi tunggu sebentar, kami memimpin jalan menuju dasar-dasar mixer audio. <br><br>  Sirkuit yang dijelaskan di atas cukup sederhana.  Terdiri dari Vasya Pupyrkin, satu mikrofon, penguat dan pembicara.  Sekarang perhatikan sirkuit dengan Gambar.  4, yang menyajikan panggung yang disiapkan untuk konser rock dari grup musik awal. <br><br><img src="https://habrastorage.org/webt/jh/zh/qo/jhzhqouio0xa25axcr164jch4du.gif"><br><br>  <b>Enam mikrofon dan dua speaker</b> <br><br>  Dalam Fig.  4 enam mikrofon terletak di atas panggung.  Dua pengeras suara (speaker) terletak di sisi panggung.  Ketika konser dimulai, para pemain menyanyikan atau memainkan musik di masing-masing dari enam mikrofon.  Dengan demikian, kita akan memiliki enam sinyal listrik, yang harus diperkuat secara individual dan kemudian diumpankan ke kedua speaker.  Selain itu, pemain dapat menggunakan berbagai efek khusus suara, misalnya, reverb, yang juga perlu dikonversi menjadi sinyal listrik sebelum menerapkannya ke speaker. <br><br>  Dua speaker di sisi panggung dirancang untuk menciptakan efek suara stereo.  Artinya, sinyal listrik yang berasal dari mikrofon yang terletak di atas panggung ke kanan harus jatuh ke speaker yang terletak di sebelah kanan.  Demikian pula, sinyal dari mikrofon ke kiri harus diumpankan ke speaker yang terletak di sebelah kiri tempat kejadian.  Tetapi sinyal listrik dari mikrofon lain yang terletak lebih dekat ke tengah panggung harus sudah dikirim ke kedua speaker dalam proporsi yang sesuai.  Dan dua mikrofon tepat di tengah harus mentransmisikan sinyalnya ke kedua speaker secara sama. <br><br>  <b>Mixer audio</b> <br><br>  Tugas yang dibahas di atas hanya dilakukan oleh perangkat elektronik yang disebut mixer audio. <br><br>  <b>Garis audio (saluran)</b> <br><br>  Meskipun penulis bukan ahli dalam mixer audio, dalam pengertiannya yang sederhana, mixer audio khas memiliki kemampuan untuk menerima input sejumlah independen dari masing-masing sinyal listrik lainnya, yang masing-masing mewakili sinyal audio asli atau saluran <i>(saluran).</i> <br><br>  (Konsep saluran audio akan menjadi sangat penting ketika kita mulai memahami Java Sound API secara rinci. <br><br>  <b>Pemrosesan independen setiap saluran audio</b> <br><br>  Bagaimanapun, mixer audio standar memiliki kemampuan untuk memperkuat setiap saluran audio secara independen dari saluran lainnya.  Juga, mixer biasanya memiliki kemampuan untuk memaksakan efek suara khusus, seperti, misalnya, reverb ke salah satu jalur audio.  Pada akhirnya, mixer, seperti namanya, dapat mencampur semua sinyal listrik individu di saluran output seperti yang akan diatur, sehingga untuk mengontrol kontribusi setiap saluran audio ke saluran output. (Kontrol ini biasanya disebut panci atau panci - distribusi dalam ruang). <br><br>  <b>Kembali ke suara stereo</b> <br><br>  Jadi, dalam diagram dengan Gambar.  4, insinyur suara dari mixer audio memiliki kemampuan untuk menggabungkan sinyal dari enam mikrofon untuk mendapatkan dua sinyal output, yang masing-masing ditransmisikan ke pengeras suara. <br><br>  Agar operasi berhasil, sinyal dari masing-masing mikrofon harus disediakan dalam proporsi yang sesuai, tergantung pada lokasi fisik mikrofon di atas panggung.  (Dengan mengubah panning, sound engineer yang berkualitas dapat mengubah kontribusi setiap mikrofon jika perlu, jika, misalnya, vokalis utama bergerak di sekitar panggung selama konser). <br><br>  <b>Saatnya kembali ke dunia pemrograman</b> <br><br>  Mari kita kembali dari dunia fisik ke dunia pemrograman.  Menurut Sun: <i>“Java Sound tidak melibatkan konfigurasi perangkat keras khusus;</i>  <i>Ini dirancang untuk memungkinkan berbagai komponen audio dipasang pada sistem dan tersedia untuk pengguna melalui API.</i>  <i>Java Sound mendukung fungsi input dan output standar dari kartu suara (misalnya, untuk merekam dan memutar file audio), serta kemampuan untuk mencampur beberapa stream audio ”</i> <br><br>  <b>Mixer dan saluran</b> <br><br>  Seperti yang telah disebutkan, Java Sound API dibangun di atas konsep mixer dan saluran.  Jika Anda berpindah dari dunia fisik ke dunia pemrograman, maka Sun menulis yang berikut tentang mixer: <br><br>  <i>“Mixer adalah perangkat audio dengan satu atau lebih saluran.</i>  <i>Tetapi mixer yang benar-benar mencampur sinyal audio harus memiliki beberapa saluran input sumber sumber dan setidaknya satu saluran target keluaran. "</i> <br><br>  Baris input dapat menjadi instance dari kelas dengan objek SourceDataLine, dan baris output dapat objek TargetDataLine.  Mixer juga dapat menerima suara yang direkam sebelumnya dan loop sebagai input, mendefinisikan saluran sumber inputnya sebagai instance dari objek kelas yang mengimplementasikan antarmuka Klip. <br><br>  Antarmuka saluran saluran. <br><br>  Sun melaporkan hal-hal berikut dari antarmuka Line: “ <i>Line adalah elemen dari pipa audio digital seperti input atau output port audio, mixer, atau jalur audio ke atau dari mixer.</i>  <i>Data audio yang melewati saluran dapat berupa mono atau multi-saluran (misalnya, stereo).</i>  <i>... Saluran dapat memiliki Kontrol, seperti gain, pan, dan reverb. "</i> <br><br>  <b>Menyatukan persyaratan</b> <br><br>  Jadi, kutipan di atas dari Sun menunjukkan persyaratan berikut <br><br>  Sourcedataline <br>  Targetgetataline <br>  Pelabuhan <br>  Klip <br>  Kontrol <br><br>  <i>Fig.</i>  <i>Gambar 5 menunjukkan contoh penggunaan istilah-istilah ini untuk membangun program keluaran audio sederhana.</i> <br><br><img src="https://habrastorage.org/webt/e1/5r/gh/e15rghejgy0b2reeciyvircdvua.gif"><br><br>  <b>Skrip program</b> <br><br>  Dari sudut pandang perangkat lunak  5 memperlihatkan objek Mixer yang diperoleh dengan satu objek Klip dan dua objek SourceDataLine. <br><br>  <b>Apa itu Klip</b> <br><br>  Klip adalah objek pada input mixer, yang isinya tidak berubah seiring waktu.  Dengan kata lain, Anda memuat data audio ke objek Klip sebelum Anda memainkannya.  Konten audio objek Klip mungkin diputar satu kali atau lebih.  Anda dapat memutar kembali Klip dan kemudian konten akan diputar berulang kali. <br><br>  <b>Input stream</b> <br><br>  Objek SourceDataLine, di sisi lain, adalah objek aliran pada input mixer.  Objek jenis ini dapat menerima aliran data audio dan mengirimkannya ke mixer secara real time.  Data audio yang diperlukan dapat diperoleh dari berbagai sumber, seperti file audio, koneksi jaringan atau buffer memori. <br><br>  <b>Berbagai jenis saluran</b> <br><br>  Dengan demikian, objek Klip dan SourceDataLine dapat dianggap sebagai saluran input untuk objek Mixer.  Masing-masing saluran input ini dapat memiliki: pan, gain, dan reverb. <br><br>  <b>Putar konten audio</b> <br><br>  Dalam sistem sederhana seperti itu, Mixer membaca data dari jalur input, menggunakan kontrol untuk mencampur sinyal input, dan memberikan output ke satu atau lebih saluran output, seperti speaker, output line, jack headphone, dan sebagainya. <br><br>  Listing 11 menunjukkan program sederhana yang menangkap data audio dari port mikrofon, menyimpan data ini dalam memori, dan kemudian memainkannya melalui port speaker. <br><br>  Kami hanya akan membahas pengambilan dan pemutaran.  Sebagian besar program di atas adalah membuat jendela dan antarmuka grafis untuk pengguna sehingga memungkinkan untuk mengontrol perekaman dan pemutaran.  Kami tidak akan membahas bagian ini sebagai melampaui tujuan.  Tetapi kemudian kita akan mempertimbangkan penangkapan dan pemutaran data.  Kami akan membahas kehilangan dalam pelajaran ini, dan menangkap di berikutnya.  Sepanjang jalan, kita akan menggambarkan penggunaan saluran audio dengan Java Sound API. <br><br>  Data yang diambil disimpan dalam objek ByteArrayOutputStream. <br><br>  Potongan kode menyediakan untuk membaca data audio dari mikrofon dan menyimpannya sebagai objek ByteArrayOutputStream. <br><br>  Metode yang disebut playAudio, yang dimulai pada Listing 1, memainkan data audio yang ditangkap dan disimpan dalam objek ByteArrayOutputStream. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">playAudio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> audioData[] = byteArrayOutputStream. toByteArray(); InputStream byteArrayInputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteArrayInputStream( audioData);</code> </pre> <br>  <i>Listing 1</i> <br><br>  <b>Kami mulai dengan kode standar.</b> <br><br>  Cuplikan program pada Listing 1 sebenarnya belum terkait dengan Java Sound. <br><br>  Tujuannya adalah untuk: <br><br><ul><li>  Konversi data yang disimpan sebelumnya ke array tipe byte. </li><li>  Dapatkan aliran input untuk array data byte. </li></ul><br>  Kami membutuhkan ini untuk membuat data audio tersedia untuk pemutaran nanti. <br><br>  <b>Buka API Suara</b> <br><br>  Baris kode pada Listing 2 sudah terkait dengan Java Sound API. <br><br><pre> <code class="java hljs"> AudioFormat audioFormat = getAudioFormat();</code> </pre><br>  <i>Listing 2</i> <br><br>  Di sini kita secara singkat menyentuh topik tersebut, yang akan dibahas secara rinci dalam pelajaran selanjutnya. <br><br>  <b>Dua format independen</b> <br><br>  Paling sering kita berhadapan dengan dua format independen untuk data audio. <br><br>  Format file, (apa saja) yang berisi data audio (dalam program kami belum, karena data disimpan dalam memori) <br><br>  Format data audio yang dikirimkan itu sendiri. <br><br>  <b>Apa itu format audio?</b> <br><br>  Inilah yang Sun tulis tentang itu: <br><br>  <i>“Setiap saluran data memiliki format audio sendiri yang terkait dengan aliran datanya.</i>  <i>Format (turunan dari AudioFormat) menentukan urutan byte dari aliran audio.</i>  <i>Parameter format dapat berupa jumlah saluran, frekuensi sampling, bit kuantisasi, metode pengkodean, dll. Metode pengkodean yang biasa dapat berupa modulasi kode pulsa linier PCM dan variannya. "</i> <br><br>  <b>Urutan byte</b> <br><br>  Sumber data audio adalah urutan byte dari data biner.  Ada berbagai opsi untuk bagaimana Anda dapat mengatur dan menafsirkan urutan ini.  Kami tidak akan mulai membahas semua opsi ini secara terperinci, tetapi kami akan membahas sedikit format audio yang kami gunakan di sini dalam program kami. <br><br>  <b>Penyimpangan kecil</b> <br><br>  Di sini kita meninggalkan metode playAudio untuk saat ini dan melihat metode getAudioFormat dari Listing 2. <br><br>  <i>Metode getAudioFormat lengkap ditunjukkan pada Listing 3.</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> AudioFormat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAudioFormat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sampleRate = <span class="hljs-number"><span class="hljs-number">8000.0F</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sampleSizeInBits = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> channels = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> signed = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> bigEndian = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioFormat( sampleRate, sampleSizeInBits, channels, signed, bigEndian); }<span class="hljs-comment"><span class="hljs-comment">//end getAudioFormat</span></span></code> </pre><br>  <i>Listing 3</i> <br><br>  Selain mendeklarasikan variabel yang diinisialisasi, kode dalam Listing 3 berisi satu ekspresi yang dapat dieksekusi. <br><br>  <b>Objek AudioFormat</b> <br><br>  Metode getAudioFormat membuat dan mengembalikan instance objek kelas AudioFormat.  Inilah yang Sun tulis tentang kelas ini: <br><br>  <i>“Kelas AudioFormat mendefinisikan urutan data spesifik dalam aliran audio.</i>  <i>Beralih ke bidang objek AudioFormat, Anda bisa mendapatkan informasi tentang cara menafsirkan bit dengan benar dalam aliran data biner. "</i> <br><br>  <b>Kami menggunakan konstruktor paling sederhana</b> <br><br>  Kelas AudioFormat memiliki dua jenis konstruktor (kami akan mengambil yang paling sepele).  Parameter berikut diperlukan untuk konstruktor ini: <br><br><ul><li>  Laju pengambilan sampel atau laju sampel per detik (Nilai yang tersedia: 8000, 11025, 16000, 22050, dan 44100 sampel per detik) </li><li>  Kedalaman bit data (tersedia 8 dan 16 bit per hitungan) </li><li>  Jumlah saluran (satu saluran untuk mono dan dua untuk stereo) </li><li>  Data yang ditandatangani atau tidak ditandatangani yang digunakan dalam aliran (misalnya, nilainya bervariasi dari 0 hingga 255 atau dari -127 hingga +127) </li><li>  Urutan byte Big-endian atau little-endian.  (jika Anda mentransmisikan nilai byte stream 16-bit, penting untuk mengetahui byte mana yang lebih dulu - rendah atau tinggi, karena ada kedua opsi). </li></ul><br>  Seperti yang Anda lihat di Listing 3, dalam kasus kami, kami menggunakan parameter berikut untuk instance objek AudioFormat. <br><br><ul><li>  8000 sampel per detik </li><li>  16 ukuran data </li><li>  data penting </li><li>  Perintah little-endian </li></ul><br>  Secara default, data dikodekan oleh PCM linier. <br><br>  Konstruktor yang kami gunakan membuat turunan dari objek AudioFormat menggunakan modulasi kode pulsa linier dan parameter yang ditunjukkan di atas (Kami akan kembali ke PCM linier dan metode penyandian lainnya dalam pelajaran berikut) <br><br>  <b>Kembali ke metode playAudio lagi</b> <br><br>  Sekarang kita mengerti bagaimana format data audio bekerja dalam suara Java, mari kita kembali ke metode playAudio.  Segera setelah kami ingin memutar data audio yang tersedia, kami membutuhkan objek kelas AudioInputStream.  Kami mendapatkan instance dari itu di Listing 4. <br><br><pre> <code class="java hljs"> audioInputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioInputStream( byteArrayInputStream, audioFormat, audioData.length/audioFormat. getFrameSize());</code> </pre><br>  <i>Listing 4</i> <br><br>  <b>Parameter untuk konstruktor AudioInputStream</b> <br><br><ul><li>  Konstruktor untuk kelas AudioInputStream memerlukan tiga parameter berikut: </li><li>  Aliran tempat instance objek AudioInputStream akan berbasis (seperti yang kita lihat untuk tujuan ini, kami menggunakan instance dari objek ByteArrayInputStream yang dibuat sebelumnya) </li><li>  Format data audio untuk aliran ini (untuk tujuan ini kami telah membuat turunan dari objek AudioFormat) </li><li>  Ukuran bingkai (frame) untuk data dalam aliran ini (lihat deskripsi di bawah) </li><li>  Dua parameter pertama jelas dari kode pada Listing 4. Namun, parameter ketiga tidak begitu jelas. </li></ul><br>  <b>Dapatkan ukuran bingkai</b> <br><br>  Seperti yang dapat kita lihat dari Listing 4, nilai parameter ketiga dibuat menggunakan perhitungan.  Ini hanyalah salah satu atribut dari format audio yang belum kami sebutkan sebelumnya, dan itu disebut bingkai. <br><br>  <b>Apa itu bingkai?</b> <br><br>  Untuk PCM linier sederhana yang digunakan dalam program kami, frame berisi sekumpulan sampel untuk semua saluran pada waktu tertentu. <br><br>  Dengan demikian, ukuran frame sama dengan ukuran hitungan dalam byte kali jumlah saluran. <br><br>  Seperti yang mungkin sudah Anda duga, metode yang disebut getFrameSize mengembalikan ukuran bingkai dalam byte. <br><br>  <b>Perhitungan ukuran bingkai</b> <br><br>  Dengan demikian, panjang data audio dalam suatu bingkai dapat dihitung dengan membagi jumlah total byte dalam urutan data audio dengan jumlah byte dalam satu frame.  Perhitungan ini digunakan untuk parameter ketiga dalam Listing 4. <br><br>  <b>Mendapatkan Objek SourceDataLine</b> <br><br>  Bagian selanjutnya dari program yang akan kita bahas adalah sistem output audio sederhana.  Seperti yang dapat kita lihat dari diagram pada Gambar. 5, untuk menyelesaikan masalah ini, kita memerlukan objek SourceDataLine. <br><br>  Ada beberapa cara untuk mendapatkan instance dari objek SourceDataLine, yang semuanya sangat rumit.  Kode dalam Listing 5 mengambil dan menyimpan referensi ke turunan objek SourceDataLine. <br><br>  (Perhatikan bahwa kode ini tidak hanya membuat instance objek SourceDataLine. Ia mendapatkannya dengan cara yang agak bundar.) <br><br><pre> <code class="java hljs"> DataLine.Info dataLineInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataLine.Info( SourceDataLine.class, audioFormat); sourceDataLine = (SourceDataLine) AudioSystem.getLine( dataLineInfo);</code> </pre><br>  <i>Listing 5</i> <br><br>  Apa itu objek SourceDataLine? <br><br>  Tentang ini, Sun menulis sebagai berikut: <br><br>  <i>“SourceDataLine adalah saluran data tempat data dapat ditulis.</i>  <i>Ini berfungsi sebagai input untuk mixer.</i>  <i>Aplikasi menulis urutan byte ke SourceDataLine, yang buffer data dan mengirimkannya ke mixer.</i>  <i>Mixer dapat mengirimkan data yang diprosesnya ke tahap berikutnya, misalnya, ke port output.</i> <i><br><br></i>  <i>Perhatikan bahwa konvensi penamaan untuk pemasangan ini mencerminkan hubungan antara saluran dan mixernya. "</i> <br><br>  <b>Metode GetLine untuk kelas AudioSystem</b> <br><br>  Salah satu cara untuk mendapatkan instance dari objek SourceDataLine adalah dengan memanggil metode getLine statis dari kelas AudioSystem (Kami akan memiliki banyak untuk melaporkannya dalam pelajaran berikutnya). <br><br>  Metode getLine memerlukan parameter input dari tipe Line.Info dan mengembalikan objek Line yang cocok dengan deskripsi di objek Line.Info yang sudah ditentukan. <br><br>  <b>Penyimpangan singkat lainnya</b> <br><br>  Sun melaporkan informasi berikut tentang objek Line.Info: <br><br>  “Saluran memiliki objek informasinya sendiri (turunan Line.Info), yang menunjukkan mixer mana (jika ada) mengirim data audio campuran sebagai output langsung ke saluran, dan mixer mana (jika ada) yang menerima data audio sebagai input langsung dari saluran.  Varietas Garis dapat sesuai dengan subkelas Line.Info, yang memungkinkan Anda menentukan jenis parameter lain yang terkait dengan jenis saluran tertentu ” <br><br>  <b>Objek DataLine.Info</b> <br><br>  Ekspresi pertama di Listing 5 membuat instance baru dari objek DataLine.Info, yang merupakan bentuk khusus (subkelas) dari objek Line.Info. <br><br>  Ada beberapa konstruktor kelebihan beban untuk kelas DataLine.Info.  Kami telah memilih yang paling mudah digunakan.  Konstruktor ini memerlukan dua parameter. <br><br>  <b>Obyek Kelas</b> <br><br>  Parameter pertama adalah Kelas, yang mewakili kelas yang kami definisikan sebagai SourceDataLine.class <br><br>  Parameter kedua menentukan format data yang diinginkan untuk saluran.  Kami menggunakan instance objek AudioFormat untuknya, yang telah ditentukan sebelumnya. <br><br>  <b>Di mana kita sudah?</b> <br><br>  Sayangnya, kami masih belum memiliki objek SourceDataLine yang paling dibutuhkan.  Sejauh ini, kami memiliki objek yang hanya menyediakan informasi tentang objek SourceDataLine yang kami butuhkan. <br><br>  <b>Mendapatkan Objek SourceDataLine</b> <br><br>  Ekspresi kedua di Listing 5 akhirnya membuat dan menyimpan instance dari SourceDataLine yang kita butuhkan.  Ini terjadi dengan memanggil metode statis getLine dari kelas AudioSystem dan meneruskan dataLineInfo sebagai parameter.  (Dalam pelajaran selanjutnya, kita akan melihat bagaimana cara mendapatkan objek Line, bekerja langsung dengan objek Mixer). <br><br>  Metode getLine mengembalikan referensi ke objek tipe Line, yang merupakan induk dari SourceDataLine.  Oleh karena itu, downcast diperlukan di sini sebelum nilai kembali disimpan sebagai SourceDataLine. <br><br>  <b>Mari kita siap menggunakan objek SourceDataLine</b> <br><br>  Setelah kita mendapatkan instance dari objek SourceDataLine, kita perlu menyiapkannya untuk membuka dan menjalankan, seperti yang ditunjukkan pada Listing 6. <br><br><pre> <code class="java hljs"> sourceDataLine.open(audioFormat); sourceDataLine.start();</code> </pre><br>  <i>Listing 6</i> <br><br>  <b>Metode pembukaan</b> <br><br>  Seperti yang Anda lihat dari Listing 6, kami mengirim objek AudioFormat ke metode pembukaan untuk objek SourceDataLine. <br><br>  Menurut Sun, ini adalah metode: <br><br>  <i>"Membuka saluran (saluran) dengan format yang ditentukan sebelumnya, memungkinkan dia untuk menerima sumber daya sistem apa pun yang dia butuhkan dan berada dalam kondisi kerja (berfungsi)"</i> <br><br>  <b>Negara penemuan</b> <br><br>  Ada sedikit lagi yang ditulis Sun tentangnya di utas ini. <br><br>  <i>“Membuka dan menutup saluran mempengaruhi distribusi sumber daya sistem.</i>  <i>Pembukaan saluran yang berhasil memastikan bahwa semua sumber daya yang diperlukan disediakan untuk saluran tersebut.</i> <i><br><br></i>  <i>Pembukaan mixer, yang memiliki port input dan output untuk data audio, termasuk, antara lain, menggunakan perangkat keras platform tempat pekerjaan dan inisialisasi komponen perangkat lunak yang diperlukan berlangsung.</i> <i><br><br></i>  <i>Membuka saluran, yang merupakan rute untuk data audio ke atau dari mixer, termasuk menginisialisasi dan menerima sumber daya mixer tanpa batas.</i>  <i>Dengan kata lain, mixer memiliki jumlah saluran yang terbatas, sehingga beberapa aplikasi dengan kebutuhan saluran mereka sendiri (dan bahkan kadang-kadang satu aplikasi) harus membagikan sumber daya mixer dengan benar) ”</i> <br><br>  <b>Panggil metode mulai di saluran</b> <br><br>  Menurut Sun, memanggil metode mulai untuk saluran berarti yang berikut: <br><br>  <i>“Saluran diizinkan menggunakan jalur I / O.</i>  <i>Jika upaya dilakukan untuk menggunakan jalur yang sudah beroperasi, metode tidak melakukan apa-apa.</i>  <i>Tetapi setelah buffer data kosong, baris melanjutkan mulai I / O, mulai dari frame pertama yang tidak berhasil diproses setelah buffer dimuat penuh. "</i> <br><br>  Dalam kasus kami, tentu saja, saluran tidak berhenti.  Sejak kami meluncurkannya untuk pertama kalinya. <br><br>  <b>Sekarang kami memiliki hampir semua yang kami butuhkan</b> <br><br>  Pada titik ini, kami menerima semua sumber daya audio yang kami perlukan untuk memutar data audio yang sebelumnya kami rekam dan simpan dalam instance objek ByteArrayOutputStream.  (Ingat bahwa objek ini hanya ada di RAM komputer). <br><br>  <b>Kami mulai mengalir</b> <br><br>  Kami akan membuat dan memulai aliran untuk memutar audio.  Kode dalam Listing 7 membuat dan memulai utas ini. <br><br>  (Jangan bingung panggilan ke metode mulai di utas ini dengan panggilan ke metode mulai di objek SourceDataLine dari Listing 6. Ini adalah operasi yang sama sekali berbeda) <br><br><pre> <code class="java hljs">Thread playThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayThread()); playThread.start(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e); System.exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }<span class="hljs-comment"><span class="hljs-comment">//end catch }//end playAudio</span></span></code> </pre><br>  <i>Listing 7</i> <br><br>  <b>Kode bersahaja</b> <br><br>  Cuplikan program di Listing 7, meskipun sangat sederhana, menunjukkan contoh pemrograman multi-utas di Jawa.  Jika Anda tidak memahaminya, maka Anda harus membiasakan diri dengan topik ini dalam topik khusus untuk mempelajari Java. <br><br>  Setelah streaming dimulai, itu akan berfungsi sampai semua data audio yang direkam sebelumnya telah diputar sampai akhir. <br><br>  <b>Objek Utas Baru</b> <br><br>  Kode dalam Listing 7 membuat turunan objek Thread dari kelas PlayThread.  Kelas ini didefinisikan sebagai kelas dalam di program kami.  Uraiannya dimulai pada Listing 8. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayThread</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> tempBuffer[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">10000</span></span>];</code> </pre><br>  <i>Listing 8</i> <br><br>  <b>Metode jalankan di kelas Thread</b> <br><br>  Kecuali untuk mendeklarasikan variabel tempBuffer (yang mengacu pada array byte), definisi lengkap dari kelas ini hanyalah definisi dari metode yang dijalankan.  Seperti yang seharusnya sudah Anda ketahui, memanggil metode mulai pada objek Thread menyebabkan menjalankan metode objek ini untuk mengeksekusi <br><br>  Metode run untuk utas ini dimulai pada Listing 9. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt; <span class="hljs-comment"><span class="hljs-comment">//  //    -1 // while((cnt = audioInputStream. read(tempBuffer, 0, tempBuffer.length)) != -1){ if(cnt &gt; 0){ //   //    //    //   . sourceDataLine.write( tempBuffer, 0, cnt); }//end if }//end while</span></span></code> </pre><br>  <i>Listing 9</i> <br><br>  <b>Bagian pertama dari fragmen program dalam menjalankan metode</b> <br><br>  Metode run berisi dua bagian penting, yang pertama ditunjukkan pada Listing 9. <br><br>  Singkatnya, sebuah loop digunakan di sini untuk membaca data audio dari AudioInputStream dan meneruskannya ke SourceDataLine. <br><br>  Data yang dikirim ke objek SourceDataLine secara otomatis ditransfer ke output audio default.  Ini bisa berupa speaker komputer built-in atau output line.  (Kami akan belajar menentukan perangkat suara yang diperlukan dalam pelajaran berikut).  Variabel cnt dan buffer data tempBuffer digunakan untuk mengontrol aliran data antara operasi baca dan tulis. <br><br>  <b>Membaca data dari AudioInputStream</b> <br><br>  Siklus baca dari objek AudioInputStream membaca jumlah maksimum byte data yang ditentukan dari AudioInputStream dan menempatkan array byte mereka. <br><br>  <b>Nilai pengembalian</b> <br><br>  Selanjutnya, metode ini mengembalikan jumlah total byte yang dibaca, atau -1, jika akhir dari urutan yang direkam tercapai.  Jumlah byte yang dibaca disimpan dalam variabel cnt. <br><br>  <b>SourceDataLine menulis loop</b> <br><br>  Jika jumlah byte yang dibaca lebih besar dari nol, maka ada transisi ke siklus penulisan data ke SourceDataLine.  Dalam loop ini, data audio memasuki mixer.  Bytes dibaca dari array byte sesuai dengan indeks mereka dan ditulis ke buffer saluran. <br><br>  <b>Saat aliran input mengering</b> <br><br>  Ketika loop baca mengembalikan -1, ini berarti bahwa semua data audio yang direkam sebelumnya telah berakhir dan kontrol lebih lanjut diteruskan ke fragmen program dalam Listing 10. <br><br><pre> <code class="java hljs"> sourceDataLine.drain(); sourceDataLine.close(); }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e); System.exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }<span class="hljs-comment"><span class="hljs-comment">//end catch }//end run }//   PlayThread</span></span></code> </pre><br>  <i>Listing 10</i> <br><br>  <b>Kunci dan tunggu</b> <br><br>  Kode dalam Listing 10 memanggil metode drain pada objek SourceDataLine sehingga program dapat memblokir dan menunggu buffer internal kosong di SourceDataLine.  Ketika buffer kosong, itu berarti seluruh bagian selanjutnya dikirim ke output suara komputer. <br><br>  <b>Menutup SourceDataLine</b> <br><br>  Kemudian program memanggil metode tutup untuk menutup saluran, sehingga menunjukkan bahwa semua sumber daya sistem yang digunakan oleh saluran sekarang bebas.  Sun melaporkan penutupan saluran berikut: <br><br>  <i>“Menutup sinyal saluran bahwa semua sumber daya yang terlibat untuk saluran ini dapat dibebaskan.</i>  <i>Untuk membebaskan sumber daya, aplikasi harus menutup saluran, apakah mereka sudah terlibat atau belum, serta ketika aplikasi berakhir.</i>  <i>Diasumsikan bahwa mixer berbagi sumber daya sistem dan dapat ditutup dan dibuka berulang kali.</i>  <i>Saluran lain mungkin atau mungkin tidak mendukung pembukaan kembali setelah ditutup.</i>  <i>Secara umum, mekanisme untuk membuka garis bervariasi sesuai dengan subtipe yang berbeda. "</i> <br><br>  <b>Dan sekarang akhir dari cerita</b> <br><br>  Jadi di sini kami memberikan penjelasan tentang bagaimana program kami menggunakan Java Sound API untuk memastikan pengiriman data audio dari memori internal komputer ke kartu suara. <br><br>  <b>Jalankan programnya</b> <br><br>  Sekarang Anda dapat mengkompilasi dan menjalankan program dari Listing 11, yang menandai akhir dari pelajaran kami. <br><br>  <b>Tangkap dan putar data audio</b> <br><br>  Program ini menunjukkan kemampuan untuk merekam data dari mikrofon dan memutarnya melalui kartu suara komputer Anda.  Petunjuk untuk menggunakannya sangat sederhana. <br><br>  Jalankan programnya.  GUI GUI sederhana, yang ditunjukkan pada Gambar 6, akan muncul di layar. <br><br><img src="https://habrastorage.org/webt/lf/7l/ew/lf7lew65yqcqstjqvdvmptmhevy.gif"><br><br><ul><li>  Klik tombol Ambil dan rekam suara apa pun ke mikrofon. </li><li>  Klik tombol Stop untuk berhenti merekam. </li><li>  Klik tombol Playback untuk memutar rekaman melalui output suara komputer Anda. </li></ul><br>  Jika Anda tidak mendengar apa pun, coba tingkatkan sensitivitas mikrofon atau volume speaker Anda. <br><br>  Program menyimpan catatan dalam memori komputer, jadi berhati-hatilah.  Jika Anda mencoba menyimpan terlalu banyak data audio, Anda mungkin kehabisan RAM. <br><br>  <b>Kesimpulan</b> <br><br><ul><li>  Kami menemukan bahwa Java Sound API didasarkan pada konsep saluran dan mixer. </li><li>  Kami mendapat informasi awal tentang karakteristik fisik dan listrik dari suara analog, untuk kemudian memahami perangkat mixer audio. </li><li>  Kami menggunakan skenario konser rock amatir menggunakan enam mikrofon dan dua speaker stereo untuk menggambarkan kemungkinan menggunakan mixer audio. </li><li>  Kami membahas sejumlah topik pemrograman Java Sound, termasuk mixer, saluran, format data, dan banyak lagi. </li><li>  Kami menjelaskan hubungan umum antara objek SourceDataLine, Klip, Mixer, AudioFormat, dan porta dalam program sederhana untuk menghasilkan data audio. </li><li>  Kami berkenalan dengan sebuah program yang memungkinkan kami untuk merekam dan kemudian memutar data audio. </li><li>  Kami menerima penjelasan rinci tentang kode yang digunakan untuk memutar data audio yang direkam sebelumnya di memori komputer. </li></ul><br>  <b>Apa selanjutnya</b> <br><br>  Dalam tutorial ini, kami menemukan bahwa Java Sound API didasarkan pada konsep mixer dan saluran.  Namun, kode yang kami diskusikan tidak menyertakan mixer secara eksplisit.  Kelas AudioSystem memberi kami metode statis yang memungkinkan untuk menulis program pemrosesan audio tanpa secara langsung mengakses mixer.  Dengan kata lain, metode statis ini mengambil mixer dari kami. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam pelajaran berikutnya, kami menyajikan kode pengambilan data yang dimodifikasi dibandingkan dengan yang disajikan dalam pelajaran ini. </font><font style="vertical-align: inherit;">Versi baru secara eksplisit akan menggunakan mixer untuk menunjukkan kepada Anda bagaimana menggunakannya ketika Anda benar-benar membutuhkannya.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.event.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.sound.sampled.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AudioCapture01</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JFrame</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> stopCapture = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ByteArrayOutputStream byteArrayOutputStream; AudioFormat audioFormat; TargetDataLine targetDataLine; AudioInputStream audioInputStream; SourceDataLine sourceDataLine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String args[])</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioCapture01(); }<span class="hljs-comment"><span class="hljs-comment">//end main public AudioCapture01(){ final JButton captureBtn = new JButton("Capture"); final JButton stopBtn = new JButton("Stop"); final JButton playBtn = new JButton("Playback"); captureBtn.setEnabled(true); stopBtn.setEnabled(false); playBtn.setEnabled(false); captureBtn.addActionListener( new ActionListener(){ public void actionPerformed( ActionEvent e){ captureBtn.setEnabled(false); stopBtn.setEnabled(true); playBtn.setEnabled(false); //  //   //   Stop captureAudio(); } } ); getContentPane().add(captureBtn); stopBtn.addActionListener( new ActionListener(){ public void actionPerformed( ActionEvent e){ captureBtn.setEnabled(true); stopBtn.setEnabled(false); playBtn.setEnabled(true); //  //    stopCapture = true; } } ); getContentPane().add(stopBtn); playBtn.addActionListener( new ActionListener(){ public void actionPerformed( ActionEvent e){ //  //    playAudio(); } } ); getContentPane().add(playBtn); getContentPane().setLayout( new FlowLayout()); setTitle("Capture/Playback Demo"); setDefaultCloseOperation( EXIT_ON_CLOSE); setSize(250,70); setVisible(true); } //    //     //   ByteArrayOutputStream private void captureAudio(){ try{ //    audioFormat = getAudioFormat(); DataLine.Info dataLineInfo = new DataLine.Info( TargetDataLine.class, audioFormat); targetDataLine = (TargetDataLine) AudioSystem.getLine( dataLineInfo); targetDataLine.open(audioFormat); targetDataLine.start(); //     //    //   //    Thread captureThread = new Thread( new CaptureThread()); captureThread.start(); } catch (Exception e) { System.out.println(e); System.exit(0); } } //    // ,    //  ByteArrayOutputStream private void playAudio() { try{ //  //  byte audioData[] = byteArrayOutputStream. toByteArray(); InputStream byteArrayInputStream = new ByteArrayInputStream( audioData); AudioFormat audioFormat = getAudioFormat(); audioInputStream = new AudioInputStream( byteArrayInputStream, audioFormat, audioData.length/audioFormat. getFrameSize()); DataLine.Info dataLineInfo = new DataLine.Info( SourceDataLine.class, audioFormat); sourceDataLine = (SourceDataLine) AudioSystem.getLine( dataLineInfo); sourceDataLine.open(audioFormat); sourceDataLine.start(); //    //     //     //      Thread playThread = new Thread(new PlayThread()); playThread.start(); } catch (Exception e) { System.out.println(e); System.exit(0); } } //     //  AudioFormat private AudioFormat getAudioFormat(){ float sampleRate = 8000.0F; //8000,11025,16000,22050,44100 int sampleSizeInBits = 16; //8,16 int channels = 1; //1,2 boolean signed = true; //true,false boolean bigEndian = false; //true,false return new AudioFormat( sampleRate, sampleSizeInBits, channels, signed, bigEndian); } //===================================// //    //    class CaptureThread extends Thread{ byte tempBuffer[] = new byte[10000]; public void run(){ byteArrayOutputStream = new ByteArrayOutputStream(); stopCapture = false; try{ while(!stopCapture){ int cnt = targetDataLine.read( tempBuffer, 0, tempBuffer.length); if(cnt &gt; 0){ //     byteArrayOutputStream.write( tempBuffer, 0, cnt); } } byteArrayOutputStream.close(); }catch (Exception e) { System.out.println(e); System.exit(0); } } } //===================================// //   //     class PlayThread extends Thread{ byte tempBuffer[] = new byte[10000]; public void run(){ try{ int cnt; //     -1 while((cnt = audioInputStream. read(tempBuffer, 0, tempBuffer.length)) != -1){ if(cnt &gt; 0){ //    //   //    //    sourceDataLine.write( tempBuffer, 0, cnt); } } sourceDataLine.drain(); sourceDataLine.close(); }catch (Exception e) { System.out.println(e); System.exit(0); } } } //===================================// }//end outer class AudioCapture01.java</span></span></code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 11</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434424/">https://habr.com/ru/post/id434424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434412/index.html">Penghapusan roket sebelum diluncurkan di Vostochny</a></li>
<li><a href="../id434414/index.html">Gunung es</a></li>
<li><a href="../id434416/index.html">Baca tentang liburan. Posting terbaik di blog kami untuk 2018</a></li>
<li><a href="../id434418/index.html">Lebih cepat, lebih keras, lebih cerah: fisika perkawinan kolibri “menari”</a></li>
<li><a href="../id434422/index.html">Hal-hal yang tidak menguntungkan</a></li>
<li><a href="../id434426/index.html">Daftar Periksa: Cara mengirim laporan tentang sistem pajak yang disederhanakan untuk 2018</a></li>
<li><a href="../id434428/index.html">Kami merakit, memperbaiki, dan memakai jam tangan digital vintage</a></li>
<li><a href="../id434430/index.html">IBM menunjukkan chip memori analog fase-perubahan 8-bit</a></li>
<li><a href="../id434432/index.html">Viya, Vaya, Vaya, Vaya - “kesulitan terjemahan”, atau apa yang ada di balik platform baru SAS Viya (Vaya)</a></li>
<li><a href="../id434440/index.html">[Video] Kapal perang, bot, dan menembak uang di server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>