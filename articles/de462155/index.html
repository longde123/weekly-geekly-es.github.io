<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏿 🎅🏿 🕔 Arbeiten Sie mit Worker "wie Sie möchten", nicht "so viel wie möglich". 🌼 💅🏼 🔡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird die Methode DIRTY, unsicher, "Krücke", beängstigend usw. verwendet. Die Schwachen lesen nicht! 


 Ich muss sofort sagen, dass ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten Sie mit Worker "wie Sie möchten", nicht "so viel wie möglich".</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/462155/"><p> In diesem Artikel wird die Methode DIRTY, unsicher, "Krücke", beängstigend usw. verwendet.  Die Schwachen lesen nicht! </p><br><p>  Ich muss sofort sagen, dass es nicht möglich war, einige Usability-Probleme zu lösen: Sie können Closure nicht in dem Code verwenden, der an den Worker übergeben wird. <br><img src="https://habrastorage.org/webt/t1/dt/x4/t1dtx4olv1-uzfyxmrltaxi9zyq.jpeg" alt="Arbeiten Sie mit Worker &quot;wie Sie möchten&quot;, aber nicht &quot;so viel wie möglich&quot;."></p><a name="habracut"></a><br><p>  Wir alle mögen neue Technologien und wir mögen es, wenn es bequem ist, diese Technologien zu verwenden.  Im Falle eines Arbeitnehmers ist dies jedoch nicht ganz richtig.  Worker arbeitet mit einer Datei oder einem Dateilink, dies ist jedoch unpraktisch.  Ich möchte in der Lage sein, jede Aufgabe in den Arbeiter zu stecken, und nicht nur speziell geplanten Code. </p><br><p>  Was ist erforderlich, um die Arbeit mit dem Arbeitnehmer bequemer zu gestalten?  Meiner Meinung nach Folgendes: </p><br><ul><li>  Möglichkeit, jederzeit beliebigen Code im Worker auszuführen </li><li>  Fähigkeit, komplexe Daten an Worker zu übergeben (Klasseninstanzen, Funktionen) </li><li>  Fähigkeit, Versprechen mit einer Antwort des Arbeitnehmers zu erhalten. </li></ul><br><p>  Zunächst benötigen wir ein Kommunikationsprotokoll zwischen dem Arbeiter und dem Hauptfenster.  Im Allgemeinen ist ein Protokoll einfach die Struktur und die Datentypen, mit denen das Browserfenster und der Worker kommunizieren.  Es ist nichts kompliziert.  Sie können so etwas verwenden oder Ihre eigene Version schreiben.  In jeder Nachricht haben wir eine ID und Daten, die für einen bestimmten Nachrichtentyp spezifisch sind.  Zunächst haben wir zwei Arten von Nachrichten für den Arbeiter: </p><br><ul><li>  Hinzufügen von Bibliotheken / Dateien zum Worker </li><li>  Arbeitsbeginn </li></ul><br><h2 id="fayl-vnutri-worker">  Datei innerhalb des Arbeiters </h2><br><p>  Bevor Sie mit dem Erstellen eines Workers beginnen, müssen Sie eine Datei beschreiben, die im Worker funktioniert, und das von uns beschriebene Protokoll unterstützen.  Ich liebe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OOP</a> , also wird es eine Klasse namens WorkerBody sein.  Diese Klasse muss das Ereignis über das übergeordnete Fenster abonnieren. </p><br><pre> <code class="javascript hljs">self.onmessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMessage(message.data); };</code> </pre> <br><p>  Jetzt können wir Ereignisse aus dem übergeordneten Fenster abhören.  Wir haben zwei Arten von Ereignissen: diejenigen, auf die die Antwort impliziert ist, und alle anderen.  Wir verarbeiten Ereignisse. <br>  Das Hinzufügen von Bibliotheken und Dateien zum Worker erfolgt über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">importScripts-</a> API. </p><br><p>  Und das Schlimmste: Wir werden <em>eval verwenden</em> , um eine beliebige Funktion auszuführen. </p><br><pre> <code class="javascript hljs">... onMessage(message) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.ADD_LIBS: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addLibs(message.libs); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.WORK: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doWork(message); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } doWork(message) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processor = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(message.job); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> params = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parser.parse(message.params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = processor(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &amp;&amp; result.then &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> result.then === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { result.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: data }); }, (error) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { error = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(error); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: error }); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: result }); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }); } } send(data) { data.body = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._serializer.serialize(data.body); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { self.postMessage(data); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toSet = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: data.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }; self.postMessage(toSet); } }</code> </pre><br><p>  Die <code>onMessage</code> Methode <code>onMessage</code> für den Empfang der Nachricht und die Auswahl des <code>doWork</code> <code>onMessage</code> verantwortlich. <code>doWork</code> die übergebene Funktion und sendet die Antwort an das übergeordnete Fenster. </p><br><h2 id="parser-i-serializator">  Parser und Serializer </h2><br><p>  Nachdem wir den Inhalt des Workers haben, müssen wir lernen, wie Daten serialisiert und analysiert werden, um sie an den Worker weiterzugeben.  Beginnen wir mit dem Serializer.  Wir möchten in der Lage sein, alle Daten an den Worker zu übergeben, einschließlich Klasseninstanzen, Klassen und Funktionen.  Mit den nativen Funktionen von Worker können wir jedoch nur JSON-ähnliche Daten übertragen.  Um dieses Verbot zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgehen</a> , brauchen wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bewertung</a> .  Alles, was JSON nicht akzeptieren kann, werden wir in die entsprechenden String-Konstruktionen einschließen und auf der anderen Seite ausführen.  Um die Unveränderlichkeit zu erhalten, werden die erhaltenen Daten im laufenden Betrieb geklont, und diejenigen, die nicht auf die übliche Weise serialisiert werden können, werden durch Serviceobjekte ersetzt, und sie werden wiederum durch den Parser auf der anderen Seite ersetzt.  Auf den ersten Blick scheint diese Aufgabe nicht schwierig zu sein, aber es gibt viele Fallstricke.  Die schlimmste Einschränkung dieses Ansatzes ist die Unfähigkeit, einen Verschluss zu verwenden, der einen etwas anderen Schreibstil für Code enthält.  Beginnen wir mit dem Einfachsten, mit der Funktion.  Zuerst müssen Sie lernen, wie Sie eine Funktion von einem Klassenkonstruktor unterscheiden. </p><br><p>  Versuchen wir zu unterscheiden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isFunction(Factory){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Factory.prototype) { <span class="hljs-comment"><span class="hljs-comment">// Arrow function has no prototype return true; } const prototypePropsLength = Object.getOwnPropertyNames(Factory.prototype) .filter(item =&gt; item !== 'constructor') .length; return prototypePropsLength === 0 &amp;&amp; Serializer.getClassParents(Factory).length === 1; } static getClassParents(Factory) { const result = [Factory]; let tmp = Factory; let item = Object.getPrototypeOf(tmp); while (item.prototype) { result.push(item); tmp = item; item = Object.getPrototypeOf(tmp); } return result.reverse(); }</span></span></code> </pre><br><p>  Zuerst werden wir herausfinden, ob die Funktion einen Prototyp hat.  Wenn dies nicht der Fall ist, ist dies definitiv eine Funktion.  Dann betrachten wir die Anzahl der Eigenschaften im Prototyp, und wenn im Prototyp nur der Konstruktor und die Funktion nicht die Erben einer anderen Klasse sind, betrachten wir dies als eine Funktion. </p><br><p>  Nachdem wir eine Funktion gefunden haben, ersetzen wir sie einfach durch ein Serviceobjekt mit den Feldern <code>__type = "serialized-function"</code> und <code>template</code> , die der Vorlage dieser Funktion ( <code>func.toString()</code> ) entsprechen. </p><br><p>  Überspringen Sie vorerst die Klasse und analysieren Sie die Klasseninstanz.  Weiter in den Daten müssen wir gewöhnliche Objekte von Klasseninstanzen unterscheiden. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isInstance(some) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> = some.<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>; if (!<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !Serializer.isNative(<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>); } static isNative(data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-regexp"><span class="hljs-regexp">/function .*?\(\) \{ \[native code\] \}/</span></span>.test(data.toString()); }</code> </pre><br><p>  Wir betrachten ein Objekt als gewöhnlich, wenn es keinen Konstruktor hat oder sein Konstruktor eine native Funktion ist.  Nachdem wir die Klasseninstanz identifiziert haben, ersetzen wir sie durch ein Serviceobjekt mit Feldern: </p><br><ul><li>  <code>__type</code> - 'serialisierte Instanz' </li><li>  <code>data</code> - Daten, die in der Instanz waren </li><li>  <code>index</code> - Der Klassenindex dieser Instanz in der Klassendienstliste. </li></ul><br><p>  Um Daten zu übertragen, müssen wir ein zusätzliches Feld erstellen: Darin speichern wir eine Liste aller eindeutigen Klassen, die wir übergeben.  Der schwierigste Teil ist, dass wenn eine Klasse erkannt wird, nicht nur ihre Vorlage, sondern auch die Vorlage aller übergeordneten Klassen genommen und als separate Klassen gespeichert wird - so dass jedes "übergeordnete" nicht mehr als einmal übergeben wird - und die Prüfung auf Instanz von gespeichert wird.  Das Definieren einer Klasse ist einfach: Dies ist eine Funktion, die unseren Serializer.isFunction-Test nicht bestanden hat.  Beim Hinzufügen einer Klasse prüfen wir, ob eine solche Klasse in der Liste der serialisierten Daten vorhanden ist, und fügen nur eindeutige hinzu.  Der Code, der die Klasse in einer Vorlage sammelt, ist ziemlich groß und liegt <a href="">hier</a> . </p><br><p>  Im Parser gehen wir zuerst alle an uns übergebenen Klassen durch und kompilieren sie, wenn sie noch nicht übergeben wurden.  Dann durchlaufen wir rekursiv jedes Datenfeld und ersetzen die Serviceobjekte durch kompilierte Daten.  Das Interessanteste ist in der Klasseninstanz.  Wir haben eine Klasse und es gibt Daten, die in ihrer Instanz waren, aber wir können sie nicht einfach instanziieren, da der Aufruf des Konstruktors möglicherweise Parameter enthält, die wir nicht haben.  Eine fast vergessene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Object.create-</a> Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hilft</a> uns dabei, ein Objekt mit einem bestimmten Prototyp zurückzugeben.  Wir vermeiden es also, den Konstruktor aufzurufen und eine Instanz der Klasse abzurufen, und schreiben dann einfach die Eigenschaften in die Instanz um. </p><br><h2 id="sozdanie-worker">  Schöpfungsarbeiter </h2><br><p>  Damit der Worker erfolgreich arbeiten kann, benötigen wir einen Parser und einen Serializer innerhalb und außerhalb des Workers. Daher nehmen wir den Serializer und verwandeln den Serializer, Parser und den Body des Workers in eine Vorlage.  Wir machen einen Blob aus der Vorlage und erstellen einen Download-Link über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">URL.createObjectURL</a> (diese Methode funktioniert möglicherweise nicht mit einigen "Content-Security-Policy").  Diese Methode eignet sich auch zum Ausführen von beliebigem Code aus einer Zeichenfolge. </p><br><pre> <code class="javascript hljs">_createWorker(customWorker) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = <span class="hljs-string"><span class="hljs-string">`var MyWorker = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._createTemplate(customWorker)}</span></span></span><span class="hljs-string">;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob([template], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/javascript'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(URL.createObjectURL(blob)); } _createTemplate(WorkerBody) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Name = Serializer.getFnName(WorkerBody); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Name) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unnamed Worker Body class! Please add name to Worker Body class!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'(function () {'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Serializer, <span class="hljs-string"><span class="hljs-string">'Serializer'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Parser, <span class="hljs-string"><span class="hljs-string">'Parser'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(WorkerBody, <span class="hljs-string"><span class="hljs-string">'WorkerBody'</span></span>), <span class="hljs-string"><span class="hljs-string">`return new WorkerBody(Serializer, Parser)})();`</span></span> ].join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); }</code> </pre><br><h2 id="rezultat">  Ergebnis </h2><br><p>  So haben wir eine benutzerfreundliche Bibliothek erhalten, die beliebigen Code in Worker ausführen kann.  Es unterstützt Klassen aus TypeScript.  Zum Beispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = workerWrapper.create(); wrapper.process(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// This code in worker. Cannot use closure! // do some hard work return 100; // or return Promise.resolve(100) }, params).then((result) =&gt; { // result = 100; }); wrapper.terminate() // terminate for kill worker process</span></span></code> </pre> <br><h2 id="dalneyshie-plany">  Weitere Pläne </h2><br><p>  Diese Bibliothek ist leider alles andere als ideal.  Es ist erforderlich, Unterstützung für Setter und Getter für Klassen, Objekte, Prototypen und statische Eigenschaften hinzuzufügen.  Wir möchten auch Caching hinzufügen, ein alternatives Skript ohne Auswertung über URL.createObjectURL ausführen lassen und der Assembly eine Datei mit dem Inhalt des Workers hinzufügen (falls die Erstellung nicht im laufenden Betrieb verfügbar ist).  Komm ins <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462155/">https://habr.com/ru/post/de462155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462145/index.html">Warum dauert das Abbestellen mehrere Tage?</a></li>
<li><a href="../de462147/index.html">Arbeiten mit der Navigation beim Refactoring eines Projekterbes in React Native</a></li>
<li><a href="../de462149/index.html">Zugriffsbeschränkungsmodus für Zubehör auf iOS-Geräten und deren Umgehung</a></li>
<li><a href="../de462151/index.html">5 Top-Kubernetes-Distributionen</a></li>
<li><a href="../de462153/index.html">Unity Interactive Map Shader</a></li>
<li><a href="../de462159/index.html">Aufbau eines Gesichtserkennungssystems basierend auf Golang und OpenCV</a></li>
<li><a href="../de462161/index.html">Erleben Sie die Installation von Apache Airflow unter Windows 10</a></li>
<li><a href="../de462163/index.html">Technologien, die 2020 populär sein werden</a></li>
<li><a href="../de462165/index.html">Wie 25 Leute dazu gebracht wurden, für eine nicht existierende Spielefirma zu arbeiten</a></li>
<li><a href="../de462167/index.html">Umgehen Sie das LinkedIn-Suchlimit, indem Sie mit der API spielen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>