<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí´ üòº üßîüèΩ Sogar Kinder werden verstehen: eine einfache Erkl√§rung von Async / Warten und Versprechen in JavaScript üë©üèø‚Äçü§ù‚Äçüë©üèæ üç¨ üï•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Ich pr√§sentiere Ihnen die √úbersetzung des Artikels ‚ÄûJavaScript Async / Await and Promises: Erkl√§rt, als w√§ren Sie f√ºnf Jahre alt‚Äú von Jack ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sogar Kinder werden verstehen: eine einfache Erkl√§rung von Async / Warten und Versprechen in JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474726/">  Hallo habr  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûJavaScript Async / Await and Promises: Erkl√§rt, als w√§ren Sie f√ºnf Jahre alt‚Äú</a> von Jack Pordi. <br><br>  Jeder, der sich irgendwann als JavaScript-Entwickler betrachtet, sollte auf Callback-Funktionen, Versprechungen oder in j√ºngerer Zeit auf die async / await-Syntax gesto√üen sein.  Wenn Sie lange genug im Spiel waren, sind Sie wahrscheinlich auf Zeiten gesto√üen, in denen verschachtelte R√ºckruffunktionen der einzige Weg waren, um eine Asynchronit√§t in JavaScript zu erreichen. <br><br>  Als ich anfing, in JavaScript zu lernen und zu schreiben, gab es bereits eine Milliarde Tutorials und Tutorials, in denen erkl√§rt wurde, wie Asynchronit√§t in JavaScript erreicht werden kann.  Viele von ihnen erkl√§rten jedoch einfach, wie man R√ºckruffunktionen in Versprechungen oder Versprechungen in async / await umwandelt.  F√ºr viele ist dies wahrscheinlich mehr als genug, um mit ihnen auszukommen und sie in ihrem Code zu verwenden. <br><br>  Wenn Sie jedoch wie ich die asynchrone Programmierung (und nicht nur die JavaScript-Syntax!) Wirklich verstehen m√∂chten, stimmen Sie mir m√∂glicherweise zu, dass es an Materialien mangelt, die die asynchrone Programmierung von Grund auf erkl√§ren. <a name="habracut"></a><br><br><h2>  Was bedeutet asynchron? </h2><br><img src="https://habrastorage.org/webt/sk/ml/pc/skmlpcgi3gmhov77moxcfyengek.jpeg" alt="Das Bild zeigt eine denkende Person"><br><br>  Wenn Sie diese Frage stellen, k√∂nnen Sie in der Regel Folgendes h√∂ren: <br><br><ul><li>  Es gibt mehrere Threads, die gleichzeitig Code ausf√ºhren. </li><li>  Es wird mehr als ein Codeteil gleichzeitig ausgef√ºhrt. </li><li>  Das ist Parallelit√§t. </li></ul><br>  Bis zu einem gewissen Grad sind alle Optionen korrekt.  Aber anstatt Ihnen eine technische Definition zu geben, die Sie wahrscheinlich bald vergessen werden, werde ich <b>ein Beispiel geben, das selbst ein Kind verstehen kann</b> . <br><br><h2>  Lebensbeispiel </h2><br><img src="https://habrastorage.org/webt/lu/gq/ww/lugqwwbgniupu-afgs3oxavro9a.jpeg" alt="Das Bild zeigt Gem√ºse und ein K√ºchenmesser"><br><br>  Stellen Sie sich vor, Sie kochen Gem√ºsesuppe.  Nehmen wir f√ºr eine gute und einfache Analogie an, dass eine Gem√ºsesuppe nur aus Zwiebeln und Karotten besteht.  Das Rezept f√ºr eine solche Suppe kann wie folgt lauten: <br><br><ol><li>  Karotten hacken. </li><li>  Zwiebel hacken. </li><li>  Geben Sie Wasser in die Pfanne, schalten Sie den Herd ein und warten Sie, bis er kocht. </li><li>  Die Karotten in die Pfanne geben und 5 Minuten ruhen lassen. </li><li>  Die Zwiebeln in die Pfanne geben und weitere 10 Minuten kochen lassen. </li></ol><br>  Diese Anweisungen sind einfach und verst√§ndlich, aber wenn einer von Ihnen, der dies liest, wirklich wei√ü, wie man kocht, k√∂nnen Sie sagen, dass dies nicht die effektivste Art des Kochens ist.  Und Sie werden Recht haben, deshalb: <br><br><ul><li>  Die Schritte 3, 4 und 5 erfordern <i><b>nicht, dass</b></i> Sie als Koch etwas anderes tun, als den Prozess zu beobachten und die Zeit im Auge zu behalten. </li><li>  In den Schritten 1 und 2 <i><b>m√ºssen</b></i> Sie aktiv etwas unternehmen. </li></ul><br>  Daher kann das Rezept f√ºr einen erfahrenen Koch wie folgt lauten: <br><br><ol><li>  Fangen Sie an, einen Topf Wasser zu kochen. </li><li>  <b>W√§hrend Sie darauf warten, dass der Topf kocht,</b> beginnen Sie mit dem Schneiden der Karotten. </li><li>  <b>Wenn Sie mit dem</b> Hacken der Karotten <b>fertig sind</b> , sollte das Wasser kochen, also f√ºgen Sie die Karotten hinzu. </li><li>  <b>W√§hrend die Karotten in einer Pfanne gekocht werden,</b> die Zwiebeln hacken. </li><li>  Zwiebeln hinzuf√ºgen und weitere 10 Minuten kochen. </li></ol><br>  Trotz der Tatsache, dass alle Aktionen gleich geblieben sind, k√∂nnen Sie davon ausgehen, dass diese Option viel schneller und effizienter ist.  Dies ist genau das Prinzip der asynchronen Programmierung: <b>Sie m√∂chten sich nie zur√ºcklehnen und nur auf etwas warten, w√§hrend Sie Ihre Zeit f√ºr andere n√ºtzliche Dinge aufwenden k√∂nnen.</b> <b><br></b> <br>  Wir alle wissen, dass beim Programmieren ziemlich oft <b>auf</b> etwas <b>gewartet wird</b> - ob auf eine HTTP-Antwort von einem Server oder auf eine Aktion eines Benutzers oder auf etwas anderes.  Aber die Ausf√ºhrungszyklen Ihres Prozessors sind kostbar und sollten <b>immer</b> aktiv genutzt werden, etwas tun und nicht erwarten: Dies f√ºhrt zu einer <b>asynchronen Programmierung</b> . <br><br><h2>  Kommen wir jetzt zu JavaScript, okay? </h2><br>  Nach dem gleichen Beispiel einer Gem√ºsesuppe werde ich einige Funktionen schreiben, um die Schritte des oben beschriebenen Rezepts darzustellen. <br><br>  Schreiben wir zun√§chst synchrone Funktionen, die Aufgaben darstellen, die keine Zeit in Anspruch nehmen.  Dies sind die guten alten JavaScript-Funktionen, aber beachten Sie, dass ich die <b><code>chopOnions</code></b> <b><code>chopCarrots</code></b> und <b><code>chopOnions</code></b> als Aufgaben beschrieben habe, die aktive Arbeit (und Zeit) erfordern, sodass sie einige lange Berechnungen durchf√ºhren k√∂nnen.  Der vollst√§ndige Code ist am Ende des Artikels [1] verf√ºgbar. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }</code> </pre><br>  Bevor ich auf asynchrone Funktionen √ºbergehe, werde ich zun√§chst kurz erl√§utern, wie das JavaScript-Typensystem mit Asynchronit√§t umgeht: Grunds√§tzlich sollten <b>alle Ergebnisse (einschlie√ülich Fehler) von asynchronen Operationen in die Zusage (n) eingeschlossen werden</b> . <br><br>  Damit eine Funktion ein Versprechen zur√ºckgibt, k√∂nnen Sie: <br><br><ul><li>  das Versprechen ausdr√ºcklich zur√ºckgeben, d.h.  <b><code>return new Promise(‚Ä¶)</code></b> ; </li><li>  Ein Versprechen implizit zur√ºckgeben - <b><code>async</code></b> zur Funktionsdeklaration hinzu, d. <b><code>async</code></b>  <b><code>async function foo()</code></b> ; </li><li>  <i>Verwenden Sie beide Optionen</i> . </li></ul><br>  Es gibt einen ausgezeichneten Artikel [2], der √ºber den Unterschied zwischen asynchronen Funktionen und Funktionen spricht, die ein Versprechen zur√ºckgeben.  In meinem Artikel werde ich mich daher nicht mit diesem Thema befassen. Das Wichtigste ist, dass Sie in asynchronen Funktionen <i><b>immer</b></i> das <b><code>async</code></b> sollten. <br><br>  Unsere asynchronen Funktionen, die die Schritte 3 bis 5 der Zubereitung von Gem√ºsesuppe darstellen, lauten wie folgt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">letPotKeepBoiling</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">time</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,      } async function boilPot() { return; //  ,       }</span></span></code> </pre><br>  Ich habe die Implementierungsdetails erneut gel√∂scht, um nicht von ihnen abgelenkt zu werden, aber sie werden am Ende des Artikels ver√∂ffentlicht [1]. <br><br>  Es ist wichtig zu wissen, dass Sie, um auf das Ergebnis des Versprechens zu warten, sp√§ter etwas damit anfangen k√∂nnen, einfach das Schl√ºsselwort <b><code>await</code></b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  ... */</span></span> } result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncFunction();</code> </pre><br>  Jetzt m√ºssen wir nur noch alles zusammenf√ºgen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Aber warte!  Das funktioniert nicht!  Sie sehen den <b><code>SyntaxError: await is only valid in async functions</code></b> .  Warum?  Denn wenn Sie eine Funktion nicht mit dem <b><code>async</code></b> , definiert JavaScript diese standardm√§√üig als synchrone Funktion - und synchron bedeutet kein Warten!  [3]  Dies bedeutet auch, dass Sie das Warten nicht au√üerhalb einer Funktion verwenden k√∂nnen. <br><br>  Deshalb f√ºgen wir der <b><code>makeSoup</code></b> Funktion einfach das <b><code>async</code></b> <b><code>makeSoup</code></b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Und voila!  Beachten Sie, dass ich in der zweiten Zeile die asynchrone Funktion <b><code>boilPot</code></b> ohne das Schl√ºsselwort <b><code>await</code></b> <b><code>boilPot</code></b> , da wir nicht warten m√∂chten, bis die Pfanne kocht, bevor wir mit dem Schneiden der Karotten beginnen.  Wir erwarten nur das Versprechen eines <b><code>pot</code></b> in der f√ºnften Zeile, bevor wir die Karotten in die Pfanne legen m√ºssen, weil wir dies nicht tun wollen, bevor das Wasser kocht. <br><br>  Was passiert beim <b><code>await</code></b> Anrufe?  Nun, nichts ... irgendwie ... <br><br>  Im Kontext der Funktion <b><code>makeSoup</code></b> k√∂nnen Sie sich das einfach so <b><code>makeSoup</code></b> als w√ºrden Sie erwarten, dass etwas passiert (oder ein Ergebnis, das irgendwann zur√ºckgegeben wird). <br><br>  Aber denken <b>Sie</b> daran: <b>Sie (wie Ihr Prozessor) werden niemals einfach nur da sitzen und auf etwas warten wollen, w√§hrend Sie Ihre Zeit f√ºr andere Dinge aufwenden k√∂nnen</b> . <br><br>  Anstatt nur Suppe zu kochen, k√∂nnten wir also etwas anderes parallel kochen: <br><br><pre> <code class="javascript hljs">makeSoup(); makePasta();</code> </pre><br>  W√§hrend wir auf <b><code>letPotKeepBoiling</code></b> warten, k√∂nnen wir zum Beispiel Pasta kochen. <br><br>  Sehen Sie?  Die asynchrone / warten-Syntax ist eigentlich ziemlich einfach zu verwenden, wenn Sie es verstehen, stimmen Sie zu? <br><br><h2>  Was ist mit offenen Versprechungen? </h2><br>  Nun, wenn Sie darauf bestehen, werde ich mich der Verwendung expliziter Versprechen zuwenden ( <i>ca. √úbersetzt: Durch explizite Versprechen impliziert der Autor direkt die Syntax der Versprechen und durch implizite Versprechen die Syntax async / await, da sie das Versprechen implizit zur√ºckgibt - keine Notwendigkeit zum Schreiben <code>return new Promise(‚Ä¶)</code></i> ).  Beachten Sie, dass die Async / Warten-Methoden <b>auf den Versprechungen selbst basieren und daher beide Optionen vollst√§ndig kompatibel sind</b> . <br><br>  Meiner Meinung nach liegen explizite Versprechungen zwischen den alten R√ºckrufen und der neuen asynchronen / erwarteten sexuellen Syntax.  Alternativ k√∂nnen Sie sich die asynchrone / wartende sexuelle Syntax auch als nichts anderes als implizite Versprechen vorstellen.  Am Ende folgte das async / await-Konstrukt den Versprechungen, die wiederum den R√ºckruffunktionen folgten. <br><br>  Verwenden Sie unsere Zeitmaschine, um zur R√ºckrufh√∂lle zu gelangen [4]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callbackHell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boilPot( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>, chopCarrots(), chopOnions() ); }</code> </pre><br>  Ich werde nicht l√ºgen, ich habe dieses Beispiel spontan geschrieben, als ich an diesem Artikel gearbeitet habe, und es hat viel mehr Zeit gekostet, als ich zugeben m√∂chte.  Viele von Ihnen wissen vielleicht nicht einmal, was hier los ist.  <i><b>Mein lieber Freund, sind all diese R√ºckruffunktionen nicht schrecklich?</b></i>  <i><b>Lassen Sie es sich zu einer Lektion machen, Callback-Funktionen nie wieder zu verwenden ...</b></i> <br><br>  Und wie versprochen das gleiche Beispiel mit expliziten Versprechungen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reject, resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { chopCarrots(); chopOnions(); resolve(); }), boilPot() ]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }); }</code> </pre><br>  Wie Sie sehen, √§hneln Versprechen immer noch den R√ºckruffunktionen. <br>  Ich werde nicht auf Details eingehen, aber am wichtigsten: <br><br><ul><li>  <b><code>.then</code></b> ist eine Versprechungsmethode, die das Ergebnis aufnimmt und an die Argumentfunktion (im Wesentlichen an eine R√ºckruffunktion ...) √ºbergibt. </li><li>  Sie k√∂nnen das Ergebnis eines Versprechens niemals au√üerhalb des Kontexts von <b><code>.then</code></b> .  Im Wesentlichen ist .then wie ein asynchroner Block, der ein Ergebnis erwartet und es dann an eine R√ºckruffunktion √ºbergibt. </li><li>  Neben der <b><code>.then</code></b> Methode gibt es eine weitere Methode in <b><code>.catch</code></b> - <b><code>.catch</code></b> .  Es wird ben√∂tigt, um Fehler in Versprechungen zu behandeln.  Ich werde jedoch nicht auf Details eingehen, da es zu diesem Thema bereits eine Milliarde Artikel und Tutorials gibt. </li></ul><br><h2>  Fazit </h2><br>  Ich hoffe, Sie haben in diesem Artikel eine Vorstellung von Versprechungen und asynchroner Programmierung bekommen oder vielleicht zumindest ein gutes Beispiel aus dem Leben gelernt, um dies jemand anderem zu erkl√§ren. <br><br>  <b>Also, welchen Weg benutzt du: Versprechen oder asynchron / warten?</b> <br>  Die Antwort liegt ganz bei Ihnen - und ich w√ºrde sagen, dass es nicht so schlimm ist, sie zu kombinieren, da beide Ans√§tze vollst√§ndig miteinander kompatibel sind. <br><br>  Ich pers√∂nlich bin jedoch zu 100% im Async / Wait-Camp, da der Code f√ºr mich viel verst√§ndlicher ist und das wahre Multitasking der asynchronen Programmierung besser widerspiegelt. <br><br><hr><br>  <b>[1]</b> : Vollst√§ndiger Quellcode ist <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a></u> verf√ºgbar. <br>  <b>[2]</b> : Originalartikel <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûAsync-Funktion vs.</a></u>  <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Funktion, die ein Versprechen zur√ºckgibt "</a></u> , √úbersetzung des Artikels <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">" Der Unterschied zwischen einer asynchronen Funktion und einer Funktion, die ein Versprechen zur√ºckgibt</a></u> . <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a></u> <br>  <b>[3]</b> : Sie k√∂nnen argumentieren, dass JavaScript wahrscheinlich den asynchronen / erwarteten Typ aus dem Funktionsumfang bestimmen und rekursiv √ºberpr√ºfen kann, aber JavaScript wurde nicht entwickelt, um die Sicherheit statischer Typen beim Kompilieren zu gew√§hrleisten, ganz zu schweigen davon dass es f√ºr Entwickler viel bequemer ist, die Art der Funktion explizit zu sehen. <br>  <b>[4]</b> : Ich habe "asynchrone" Funktionen geschrieben, vorausgesetzt, sie funktionieren unter der gleichen Schnittstelle wie <b><code>setTimeout</code></b> .  Beachten Sie, dass R√ºckrufe nicht mit Versprechungen kompatibel sind und umgekehrt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474726/">https://habr.com/ru/post/de474726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474716/index.html">Bugs C ++ 20. Ergebnisse des Treffens in Belfast</a></li>
<li><a href="../de474718/index.html">Sicherheit in der Autoelektronik - Hallo Welt auf dem Armaturenbrett-Controller</a></li>
<li><a href="../de474720/index.html">Radiolabor Nischni Nowgorod und Losevs ‚ÄûCristadins‚Äú</a></li>
<li><a href="../de474722/index.html">‚ÄûNiemand sagt anderen, was sie tun m√ºssen‚Äú: Nicol√≤ Ribaudo √ºber die Entwicklung von Babel und mehr</a></li>
<li><a href="../de474724/index.html">Was wird mit PHP in 5 Jahren passieren? Wir haben die Sprecher der n√§chsten Moskauer Mitap gefragt</a></li>
<li><a href="../de474732/index.html">Arbeiten Sie mit der Liste der Pins in C ++ f√ºr Mikrocontroller (am Beispiel von CortexM).</a></li>
<li><a href="../de474738/index.html">Geometrische Modellierung von Verrundungsoberfl√§chen</a></li>
<li><a href="../de474740/index.html">Das Beste aus dem Computer History Museum in Mountain View</a></li>
<li><a href="../de474744/index.html">Uber steigt in den Finanzdienstleistungsmarkt ein und startet den Gesch√§ftsbereich Uber Money</a></li>
<li><a href="../de474746/index.html">Objektspeicher im Hinterzimmer oder So werden Sie Ihr eigener Dienstleister</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>