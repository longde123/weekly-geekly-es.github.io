<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💫 😼 🧔🏽 Sogar Kinder werden verstehen: eine einfache Erklärung von Async / Warten und Versprechen in JavaScript 👩🏿‍🤝‍👩🏾 🍬 🕥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Ich präsentiere Ihnen die Übersetzung des Artikels „JavaScript Async / Await and Promises: Erklärt, als wären Sie fünf Jahre alt“ von Jack ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sogar Kinder werden verstehen: eine einfache Erklärung von Async / Warten und Versprechen in JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474726/">  Hallo habr  Ich präsentiere Ihnen die Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„JavaScript Async / Await and Promises: Erklärt, als wären Sie fünf Jahre alt“</a> von Jack Pordi. <br><br>  Jeder, der sich irgendwann als JavaScript-Entwickler betrachtet, sollte auf Callback-Funktionen, Versprechungen oder in jüngerer Zeit auf die async / await-Syntax gestoßen sein.  Wenn Sie lange genug im Spiel waren, sind Sie wahrscheinlich auf Zeiten gestoßen, in denen verschachtelte Rückruffunktionen der einzige Weg waren, um eine Asynchronität in JavaScript zu erreichen. <br><br>  Als ich anfing, in JavaScript zu lernen und zu schreiben, gab es bereits eine Milliarde Tutorials und Tutorials, in denen erklärt wurde, wie Asynchronität in JavaScript erreicht werden kann.  Viele von ihnen erklärten jedoch einfach, wie man Rückruffunktionen in Versprechungen oder Versprechungen in async / await umwandelt.  Für viele ist dies wahrscheinlich mehr als genug, um mit ihnen auszukommen und sie in ihrem Code zu verwenden. <br><br>  Wenn Sie jedoch wie ich die asynchrone Programmierung (und nicht nur die JavaScript-Syntax!) Wirklich verstehen möchten, stimmen Sie mir möglicherweise zu, dass es an Materialien mangelt, die die asynchrone Programmierung von Grund auf erklären. <a name="habracut"></a><br><br><h2>  Was bedeutet asynchron? </h2><br><img src="https://habrastorage.org/webt/sk/ml/pc/skmlpcgi3gmhov77moxcfyengek.jpeg" alt="Das Bild zeigt eine denkende Person"><br><br>  Wenn Sie diese Frage stellen, können Sie in der Regel Folgendes hören: <br><br><ul><li>  Es gibt mehrere Threads, die gleichzeitig Code ausführen. </li><li>  Es wird mehr als ein Codeteil gleichzeitig ausgeführt. </li><li>  Das ist Parallelität. </li></ul><br>  Bis zu einem gewissen Grad sind alle Optionen korrekt.  Aber anstatt Ihnen eine technische Definition zu geben, die Sie wahrscheinlich bald vergessen werden, werde ich <b>ein Beispiel geben, das selbst ein Kind verstehen kann</b> . <br><br><h2>  Lebensbeispiel </h2><br><img src="https://habrastorage.org/webt/lu/gq/ww/lugqwwbgniupu-afgs3oxavro9a.jpeg" alt="Das Bild zeigt Gemüse und ein Küchenmesser"><br><br>  Stellen Sie sich vor, Sie kochen Gemüsesuppe.  Nehmen wir für eine gute und einfache Analogie an, dass eine Gemüsesuppe nur aus Zwiebeln und Karotten besteht.  Das Rezept für eine solche Suppe kann wie folgt lauten: <br><br><ol><li>  Karotten hacken. </li><li>  Zwiebel hacken. </li><li>  Geben Sie Wasser in die Pfanne, schalten Sie den Herd ein und warten Sie, bis er kocht. </li><li>  Die Karotten in die Pfanne geben und 5 Minuten ruhen lassen. </li><li>  Die Zwiebeln in die Pfanne geben und weitere 10 Minuten kochen lassen. </li></ol><br>  Diese Anweisungen sind einfach und verständlich, aber wenn einer von Ihnen, der dies liest, wirklich weiß, wie man kocht, können Sie sagen, dass dies nicht die effektivste Art des Kochens ist.  Und Sie werden Recht haben, deshalb: <br><br><ul><li>  Die Schritte 3, 4 und 5 erfordern <i><b>nicht, dass</b></i> Sie als Koch etwas anderes tun, als den Prozess zu beobachten und die Zeit im Auge zu behalten. </li><li>  In den Schritten 1 und 2 <i><b>müssen</b></i> Sie aktiv etwas unternehmen. </li></ul><br>  Daher kann das Rezept für einen erfahrenen Koch wie folgt lauten: <br><br><ol><li>  Fangen Sie an, einen Topf Wasser zu kochen. </li><li>  <b>Während Sie darauf warten, dass der Topf kocht,</b> beginnen Sie mit dem Schneiden der Karotten. </li><li>  <b>Wenn Sie mit dem</b> Hacken der Karotten <b>fertig sind</b> , sollte das Wasser kochen, also fügen Sie die Karotten hinzu. </li><li>  <b>Während die Karotten in einer Pfanne gekocht werden,</b> die Zwiebeln hacken. </li><li>  Zwiebeln hinzufügen und weitere 10 Minuten kochen. </li></ol><br>  Trotz der Tatsache, dass alle Aktionen gleich geblieben sind, können Sie davon ausgehen, dass diese Option viel schneller und effizienter ist.  Dies ist genau das Prinzip der asynchronen Programmierung: <b>Sie möchten sich nie zurücklehnen und nur auf etwas warten, während Sie Ihre Zeit für andere nützliche Dinge aufwenden können.</b> <b><br></b> <br>  Wir alle wissen, dass beim Programmieren ziemlich oft <b>auf</b> etwas <b>gewartet wird</b> - ob auf eine HTTP-Antwort von einem Server oder auf eine Aktion eines Benutzers oder auf etwas anderes.  Aber die Ausführungszyklen Ihres Prozessors sind kostbar und sollten <b>immer</b> aktiv genutzt werden, etwas tun und nicht erwarten: Dies führt zu einer <b>asynchronen Programmierung</b> . <br><br><h2>  Kommen wir jetzt zu JavaScript, okay? </h2><br>  Nach dem gleichen Beispiel einer Gemüsesuppe werde ich einige Funktionen schreiben, um die Schritte des oben beschriebenen Rezepts darzustellen. <br><br>  Schreiben wir zunächst synchrone Funktionen, die Aufgaben darstellen, die keine Zeit in Anspruch nehmen.  Dies sind die guten alten JavaScript-Funktionen, aber beachten Sie, dass ich die <b><code>chopOnions</code></b> <b><code>chopCarrots</code></b> und <b><code>chopOnions</code></b> als Aufgaben beschrieben habe, die aktive Arbeit (und Zeit) erfordern, sodass sie einige lange Berechnungen durchführen können.  Der vollständige Code ist am Ende des Artikels [1] verfügbar. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }</code> </pre><br>  Bevor ich auf asynchrone Funktionen übergehe, werde ich zunächst kurz erläutern, wie das JavaScript-Typensystem mit Asynchronität umgeht: Grundsätzlich sollten <b>alle Ergebnisse (einschließlich Fehler) von asynchronen Operationen in die Zusage (n) eingeschlossen werden</b> . <br><br>  Damit eine Funktion ein Versprechen zurückgibt, können Sie: <br><br><ul><li>  das Versprechen ausdrücklich zurückgeben, d.h.  <b><code>return new Promise(…)</code></b> ; </li><li>  Ein Versprechen implizit zurückgeben - <b><code>async</code></b> zur Funktionsdeklaration hinzu, d. <b><code>async</code></b>  <b><code>async function foo()</code></b> ; </li><li>  <i>Verwenden Sie beide Optionen</i> . </li></ul><br>  Es gibt einen ausgezeichneten Artikel [2], der über den Unterschied zwischen asynchronen Funktionen und Funktionen spricht, die ein Versprechen zurückgeben.  In meinem Artikel werde ich mich daher nicht mit diesem Thema befassen. Das Wichtigste ist, dass Sie in asynchronen Funktionen <i><b>immer</b></i> das <b><code>async</code></b> sollten. <br><br>  Unsere asynchronen Funktionen, die die Schritte 3 bis 5 der Zubereitung von Gemüsesuppe darstellen, lauten wie folgt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">letPotKeepBoiling</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">time</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,      } async function boilPot() { return; //  ,       }</span></span></code> </pre><br>  Ich habe die Implementierungsdetails erneut gelöscht, um nicht von ihnen abgelenkt zu werden, aber sie werden am Ende des Artikels veröffentlicht [1]. <br><br>  Es ist wichtig zu wissen, dass Sie, um auf das Ergebnis des Versprechens zu warten, später etwas damit anfangen können, einfach das Schlüsselwort <b><code>await</code></b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  ... */</span></span> } result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncFunction();</code> </pre><br>  Jetzt müssen wir nur noch alles zusammenfügen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Aber warte!  Das funktioniert nicht!  Sie sehen den <b><code>SyntaxError: await is only valid in async functions</code></b> .  Warum?  Denn wenn Sie eine Funktion nicht mit dem <b><code>async</code></b> , definiert JavaScript diese standardmäßig als synchrone Funktion - und synchron bedeutet kein Warten!  [3]  Dies bedeutet auch, dass Sie das Warten nicht außerhalb einer Funktion verwenden können. <br><br>  Deshalb fügen wir der <b><code>makeSoup</code></b> Funktion einfach das <b><code>async</code></b> <b><code>makeSoup</code></b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Und voila!  Beachten Sie, dass ich in der zweiten Zeile die asynchrone Funktion <b><code>boilPot</code></b> ohne das Schlüsselwort <b><code>await</code></b> <b><code>boilPot</code></b> , da wir nicht warten möchten, bis die Pfanne kocht, bevor wir mit dem Schneiden der Karotten beginnen.  Wir erwarten nur das Versprechen eines <b><code>pot</code></b> in der fünften Zeile, bevor wir die Karotten in die Pfanne legen müssen, weil wir dies nicht tun wollen, bevor das Wasser kocht. <br><br>  Was passiert beim <b><code>await</code></b> Anrufe?  Nun, nichts ... irgendwie ... <br><br>  Im Kontext der Funktion <b><code>makeSoup</code></b> können Sie sich das einfach so <b><code>makeSoup</code></b> als würden Sie erwarten, dass etwas passiert (oder ein Ergebnis, das irgendwann zurückgegeben wird). <br><br>  Aber denken <b>Sie</b> daran: <b>Sie (wie Ihr Prozessor) werden niemals einfach nur da sitzen und auf etwas warten wollen, während Sie Ihre Zeit für andere Dinge aufwenden können</b> . <br><br>  Anstatt nur Suppe zu kochen, könnten wir also etwas anderes parallel kochen: <br><br><pre> <code class="javascript hljs">makeSoup(); makePasta();</code> </pre><br>  Während wir auf <b><code>letPotKeepBoiling</code></b> warten, können wir zum Beispiel Pasta kochen. <br><br>  Sehen Sie?  Die asynchrone / warten-Syntax ist eigentlich ziemlich einfach zu verwenden, wenn Sie es verstehen, stimmen Sie zu? <br><br><h2>  Was ist mit offenen Versprechungen? </h2><br>  Nun, wenn Sie darauf bestehen, werde ich mich der Verwendung expliziter Versprechen zuwenden ( <i>ca. Übersetzt: Durch explizite Versprechen impliziert der Autor direkt die Syntax der Versprechen und durch implizite Versprechen die Syntax async / await, da sie das Versprechen implizit zurückgibt - keine Notwendigkeit zum Schreiben <code>return new Promise(…)</code></i> ).  Beachten Sie, dass die Async / Warten-Methoden <b>auf den Versprechungen selbst basieren und daher beide Optionen vollständig kompatibel sind</b> . <br><br>  Meiner Meinung nach liegen explizite Versprechungen zwischen den alten Rückrufen und der neuen asynchronen / erwarteten sexuellen Syntax.  Alternativ können Sie sich die asynchrone / wartende sexuelle Syntax auch als nichts anderes als implizite Versprechen vorstellen.  Am Ende folgte das async / await-Konstrukt den Versprechungen, die wiederum den Rückruffunktionen folgten. <br><br>  Verwenden Sie unsere Zeitmaschine, um zur Rückrufhölle zu gelangen [4]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callbackHell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boilPot( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>, chopCarrots(), chopOnions() ); }</code> </pre><br>  Ich werde nicht lügen, ich habe dieses Beispiel spontan geschrieben, als ich an diesem Artikel gearbeitet habe, und es hat viel mehr Zeit gekostet, als ich zugeben möchte.  Viele von Ihnen wissen vielleicht nicht einmal, was hier los ist.  <i><b>Mein lieber Freund, sind all diese Rückruffunktionen nicht schrecklich?</b></i>  <i><b>Lassen Sie es sich zu einer Lektion machen, Callback-Funktionen nie wieder zu verwenden ...</b></i> <br><br>  Und wie versprochen das gleiche Beispiel mit expliziten Versprechungen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reject, resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { chopCarrots(); chopOnions(); resolve(); }), boilPot() ]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }); }</code> </pre><br>  Wie Sie sehen, ähneln Versprechen immer noch den Rückruffunktionen. <br>  Ich werde nicht auf Details eingehen, aber am wichtigsten: <br><br><ul><li>  <b><code>.then</code></b> ist eine Versprechungsmethode, die das Ergebnis aufnimmt und an die Argumentfunktion (im Wesentlichen an eine Rückruffunktion ...) übergibt. </li><li>  Sie können das Ergebnis eines Versprechens niemals außerhalb des Kontexts von <b><code>.then</code></b> .  Im Wesentlichen ist .then wie ein asynchroner Block, der ein Ergebnis erwartet und es dann an eine Rückruffunktion übergibt. </li><li>  Neben der <b><code>.then</code></b> Methode gibt es eine weitere Methode in <b><code>.catch</code></b> - <b><code>.catch</code></b> .  Es wird benötigt, um Fehler in Versprechungen zu behandeln.  Ich werde jedoch nicht auf Details eingehen, da es zu diesem Thema bereits eine Milliarde Artikel und Tutorials gibt. </li></ul><br><h2>  Fazit </h2><br>  Ich hoffe, Sie haben in diesem Artikel eine Vorstellung von Versprechungen und asynchroner Programmierung bekommen oder vielleicht zumindest ein gutes Beispiel aus dem Leben gelernt, um dies jemand anderem zu erklären. <br><br>  <b>Also, welchen Weg benutzt du: Versprechen oder asynchron / warten?</b> <br>  Die Antwort liegt ganz bei Ihnen - und ich würde sagen, dass es nicht so schlimm ist, sie zu kombinieren, da beide Ansätze vollständig miteinander kompatibel sind. <br><br>  Ich persönlich bin jedoch zu 100% im Async / Wait-Camp, da der Code für mich viel verständlicher ist und das wahre Multitasking der asynchronen Programmierung besser widerspiegelt. <br><br><hr><br>  <b>[1]</b> : Vollständiger Quellcode ist <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a></u> verfügbar. <br>  <b>[2]</b> : Originalartikel <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Async-Funktion vs.</a></u>  <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Funktion, die ein Versprechen zurückgibt "</a></u> , Übersetzung des Artikels <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">" Der Unterschied zwischen einer asynchronen Funktion und einer Funktion, die ein Versprechen zurückgibt</a></u> . <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a></u> <br>  <b>[3]</b> : Sie können argumentieren, dass JavaScript wahrscheinlich den asynchronen / erwarteten Typ aus dem Funktionsumfang bestimmen und rekursiv überprüfen kann, aber JavaScript wurde nicht entwickelt, um die Sicherheit statischer Typen beim Kompilieren zu gewährleisten, ganz zu schweigen davon dass es für Entwickler viel bequemer ist, die Art der Funktion explizit zu sehen. <br>  <b>[4]</b> : Ich habe "asynchrone" Funktionen geschrieben, vorausgesetzt, sie funktionieren unter der gleichen Schnittstelle wie <b><code>setTimeout</code></b> .  Beachten Sie, dass Rückrufe nicht mit Versprechungen kompatibel sind und umgekehrt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474726/">https://habr.com/ru/post/de474726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474716/index.html">Bugs C ++ 20. Ergebnisse des Treffens in Belfast</a></li>
<li><a href="../de474718/index.html">Sicherheit in der Autoelektronik - Hallo Welt auf dem Armaturenbrett-Controller</a></li>
<li><a href="../de474720/index.html">Radiolabor Nischni Nowgorod und Losevs „Cristadins“</a></li>
<li><a href="../de474722/index.html">„Niemand sagt anderen, was sie tun müssen“: Nicolò Ribaudo über die Entwicklung von Babel und mehr</a></li>
<li><a href="../de474724/index.html">Was wird mit PHP in 5 Jahren passieren? Wir haben die Sprecher der nächsten Moskauer Mitap gefragt</a></li>
<li><a href="../de474732/index.html">Arbeiten Sie mit der Liste der Pins in C ++ für Mikrocontroller (am Beispiel von CortexM).</a></li>
<li><a href="../de474738/index.html">Geometrische Modellierung von Verrundungsoberflächen</a></li>
<li><a href="../de474740/index.html">Das Beste aus dem Computer History Museum in Mountain View</a></li>
<li><a href="../de474744/index.html">Uber steigt in den Finanzdienstleistungsmarkt ein und startet den Geschäftsbereich Uber Money</a></li>
<li><a href="../de474746/index.html">Objektspeicher im Hinterzimmer oder So werden Sie Ihr eigener Dienstleister</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>