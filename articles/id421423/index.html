<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏽 🚣🏽 🧑🏾‍🤝‍🧑🏼 Enterprise DevOps: cara perusahaan besar mengumpulkan layanan microser 🤷🏿 🤞🏾 👨🏽‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 


 NetCracker telah mengembangkan dan memasok aplikasi perusahaan untuk pasar global operator telekomunikasi selama bertahun-tahun. Pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enterprise DevOps: cara perusahaan besar mengumpulkan layanan microser</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/netcracker/blog/421423/"><p>  Halo semuanya! </p><br><p>  NetCracker telah mengembangkan dan memasok aplikasi perusahaan untuk pasar global operator telekomunikasi selama bertahun-tahun.  Pengembangan solusi semacam itu cukup rumit: ratusan orang berpartisipasi dalam proyek, dan jumlah proyek aktif dalam puluhan. </p><br><p>  Sebelumnya, produknya monolitik, tetapi sekarang kami dengan percaya diri bergerak menuju aplikasi layanan mikro.  DevOps menghadapi tugas yang agak ambisius - untuk menyediakan lompatan teknologi ini. </p><br><p>  Hasilnya, kami mendapat konsep perakitan yang sukses, yang ingin kami bagikan sebagai praktik terbaik.  Deskripsi implementasi dengan detail teknis akan sangat banyak, kami tidak akan melakukan ini dalam kerangka artikel ini. </p><a name="habracut"></a><br><p>  <i>Dalam kasus umum, perakitan adalah transformasi beberapa artefak menjadi artefak lainnya.</i> <i><br></i> </p><br><h2>  Siapa yang akan tertarik </h2><br><p>  Perusahaan-perusahaan yang menyediakan perangkat lunak siap pakai untuk organisasi pihak ketiga yang sepenuhnya dan dibayar untuk itu. </p><br><p>  Inilah yang mungkin terlihat seperti pengembangan tanpa pengiriman eksternal: </p><br><ul><li>  Departemen TI di pabrik mengembangkan perangkat lunak untuk perusahaannya. </li><li> Perusahaan ini bergerak dalam bidang outsourcing untuk pelanggan asing.  Pelanggan secara independen mengkompilasi dan mengoperasikan kode ini di server webnya sendiri. </li><li>  Perusahaan memasok perangkat lunak ke pelanggan eksternal, tetapi di bawah lisensi sumber terbuka.  Dengan demikian, sebagian besar tanggung jawab dibebaskan. </li></ul><br><p>  Jika Anda tidak dihadapkan dengan pasokan eksternal, maka banyak dari apa yang tertulis di bawah ini akan tampak berlebihan atau bahkan paranoid. </p><br><p>  Dalam praktiknya, semuanya harus dilakukan sesuai dengan persyaratan internasional untuk lisensi dan enkripsi yang digunakan, jika tidak setidaknya konsekuensi hukum akan muncul. </p><br><p>  Contoh pelanggaran adalah mengambil kode dari perpustakaan dengan lisensi GPL3 dan menanamkannya dalam aplikasi komersial. </p><br><h2>  Munculnya layanan mikro membutuhkan perubahan </h2><br><p>  Kami telah memperoleh pengalaman luas dalam perakitan dan pengiriman aplikasi monolitik. </p><br><p>  Beberapa server Jenkins, ribuan pekerjaan CI, beberapa jalur perakitan sepenuhnya otomatis berdasarkan Jenkins, puluhan insinyur rilis khusus, kelompok ahli sendiri tentang manajemen konfigurasi. </p><br><p>  Secara historis, pendekatan di perusahaan adalah ini: pengembang menulis kode sumber, dan DevOps menemukan dan menulis konfigurasi sistem perakitan. </p><br><p>  Sebagai hasilnya, kami memiliki dua atau tiga konfigurasi perakitan khas yang dirancang untuk operasi di ekosistem perusahaan.  Secara skematis, tampilannya seperti ini: </p><br><img src="https://habrastorage.org/webt/pr/hi/rm/prhirmtpwufl-vfhheebwfaujpg.png"><br><p>  Alat bangun biasanya semut atau pakar, dan sesuatu diterapkan oleh plug-in yang tersedia untuk umum, ada sesuatu yang ditulis sendiri.  Ini bekerja dengan baik ketika perusahaan menggunakan serangkaian teknologi yang sempit. </p><br><p>  <i>Layanan microser berbeda dari aplikasi monolitik terutama dalam beragam teknologi.</i> </p><br><p>  Ternyata banyak konfigurasi perakitan untuk setidaknya setiap bahasa pemrograman.  Kontrol terpusat menjadi tidak mungkin. </p><br><p>  Diperlukan untuk menyederhanakan skrip perakitan sebanyak mungkin dan memungkinkan pengembang untuk mengeditnya secara mandiri. </p><br><p>  Selain kompilasi dan pengemasan sederhana (dalam diagram <font color="green">berwarna hijau</font> ), skrip ini berisi banyak kode untuk integrasi dengan ekosistem perusahaan (dalam diagram <font color="red">berwarna merah</font> ). </p><br><p>  Oleh karena itu, diputuskan untuk menganggap perakitan sebagai "kotak hitam", di mana lingkungan perakitan "cerdas" dapat menyelesaikan semua masalah, kecuali untuk kompilasi dan pengemasan sendiri. </p><br><p>  Pada awal pekerjaan tidak jelas bagaimana cara mendapatkan sistem seperti itu.  Membuat keputusan arsitektur untuk tugas-tugas DevOps membutuhkan pengalaman dan pengetahuan.  Bagaimana cara mendapatkannya?  Opsi yang memungkinkan di bawah ini: </p><br><ul><li>  Cari informasi di Internet. </li><li>  Pengalaman dan pengetahuan sendiri dari tim DevOps.  Untuk melakukan ini, ada baiknya membuat tim programmer ini dengan pengalaman serbaguna. </li><li>  Pengalaman dan pengetahuan yang diperoleh di luar tim DevOps.  Banyak pengembang di perusahaan memiliki ide bagus - Anda perlu mendengarnya.  Komunikasi sangat membantu. </li><li>  Kami menciptakan dan bereksperimen! </li></ul><br><h2>  Apakah saya memerlukan otomatisasi? </h2><br><p>  Untuk menjawab pertanyaan ini, Anda perlu memahami pada tahap evolusi apa pendekatan perakitan kami.  Secara umum, tugas melewati level berikut. </p><br><ol><li>  Tingkat Bawah Sadar <br><br><img width="150" src="https://habrastorage.org/webt/an/e2/uv/ane2uvhcdznwqj-bncv49oo58p8.jpeg"><br><br><p>  Kita perlu merilis satu perakitan per minggu, orang-orang kita baik-baik saja.  Ini wajar, mengapa membicarakannya? </p></li><li>  Level "artisan", akhirnya berubah menjadi level "dodger" <br><br><img width="150" src="https://habrastorage.org/webt/ck/mc/-a/ckmc-a4-76nvtsanjjwf4ilsf-i.gif"><br><br><p>  Perlu untuk menghasilkan dua majelis per hari secara stabil dan tanpa kesalahan.  Kami memiliki Vasya, ia melakukannya dengan tenang, dan tidak ada seorang pun selain dia yang menghabiskan waktu ini. </p></li><li>  Tingkat pabrik <br><br><img width="150" src="https://habrastorage.org/webt/hw/_x/57/hw_x572z1bstsfv4gcp9ntekdho.jpeg"><br><br><p>  Banyak hal sudah berjalan jauh.  Anda membutuhkan 20 kebaktian per hari, Vasya tidak bisa mengatasinya, dan sekarang tim yang terdiri dari sepuluh orang sudah duduk.  Mereka memiliki bos, rencana, liburan, cuti sakit, motivasi, pembangunan tim, pelatihan, tradisi, dan aturan.  Ini adalah spesialisasi, pekerjaan mereka harus dipelajari. <br></p><br><p>  Pada tingkat ini, tugas dipisahkan dari pelaksana konkret dan dengan demikian berubah menjadi sebuah proses. </p><br><p>  Hasilnya akan menjadi deskripsi yang jelas, dikerjakan, dijalankan dan dikoreksi ratusan kali dari proses dengan teks. </p></li><li>  Tingkat "produksi otomatis" <br><br><img width="150" src="https://habrastorage.org/webt/mw/2c/pt/mw2cptkfee3fmatsj6aw-21eka4.jpeg"><br><br><p>  Persyaratan modern untuk majelis tumbuh: semuanya harus cepat, dapat diandalkan, 800 majelis harus disediakan per hari.  Ini penting, karena tanpa volume seperti itu perusahaan akan kehilangan keunggulan kompetitif. </p><br><p>  Otomasi yang mahal sedang berlangsung, dan beberapa DevOps yang memenuhi syarat dapat menjaga proses tetap berjalan.  Penskalaan lebih lanjut tidak lagi menjadi masalah. </p></li></ol><br><p>  <i>Tidak setiap tugas harus mencapai tahap terakhir otomatisasi.</i> </p><br><p>  Seringkali satu pengrajin dengan garis perintah akan menyelesaikan masalah dengan mudah dan efektif. </p><br><p>  Otomasi “membekukan” proses, mengurangi biaya operasi dan meningkatkan biaya perubahan. </p><br><p>  Anda dapat langsung pergi ke perakitan mobil, tetapi sistemnya akan tidak nyaman, tidak akan mengimbangi persyaratan bisnis dan, sebagai hasilnya, akan menjadi usang. </p><br><h2>  Apa majelis dan mengapa masalahnya tidak diselesaikan oleh sistem perakitan siap pakai <br></h2><br><img src="https://habrastorage.org/webt/0s/s1/dk/0ss1dkrnmpubpcllntnzuuwofw0.png"><br><p>  Kami menggunakan klasifikasi berikut untuk menentukan tingkat agregasi perakitan. <br><br></p><ul><li><p>  L1.  Bagian independen kecil dari aplikasi besar.  Itu bisa satu komponen, microservice atau satu perpustakaan tambahan.  Perakitan L1 adalah solusi untuk masalah teknis linier: kompilasi, pengemasan, bekerja dengan dependensi.  Maven, gradle, npm, grunt, dan sistem build lainnya melakukan tugasnya dengan baik.  Ada ratusan dari mereka. </p><p>  <i>Perakitan L1 harus dilakukan menggunakan alat pihak ketiga yang sudah jadi.</i> </p></li><li><p>  L2 +.  Entitas Integrasi.  Entitas L1 digabungkan ke dalam formasi yang lebih besar, misalnya, ke dalam aplikasi layanan-mikro sepenuhnya.  Beberapa aplikasi ini dapat dibundel sebagai solusi tunggal.  Kami menggunakan tanda "+", karena tergantung pada tingkat agregasi perakitan, tingkat L3 atau bahkan L4 dapat ditetapkan. </p><br><p>  Contoh majelis seperti itu di dunia pihak ketiga adalah persiapan distribusi Linux.  Paket meta di sana. </p><br><p>  Selain tugas teknis yang cukup rumit (seperti ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ru.wikipedia.org/wiki/Dependency_hell</a> ).  Majelis L2 + sering merupakan produk akhir dan oleh karena itu memiliki banyak persyaratan proses: sistem hak, perbaikan orang yang bertanggung jawab, tidak adanya kesalahan hukum, pasokan berbagai dokumentasi. </p><br><p>  <i>Pada L2 +, persyaratan proses diprioritaskan dengan otomatisasi.</i> </p><br><p>  Jika solusi otomatis tidak berfungsi karena nyaman bagi orang yang tertarik, itu tidak akan diterapkan. </p><br><p>  Majelis L2 + kemungkinan besar akan dilakukan oleh alat berpemilik yang dirancang khusus untuk proses perusahaan.  Apakah Anda pikir manajer paket Linux baru saja melakukannya? </p></li></ul><br><br><h2>  Praktik terbaik kami </h2><br><h3>  Infrastruktur </h3><br><h4>  Ketersediaan zat besi secara permanen </h4><br><p>  Seluruh infrastruktur perakitan terletak di server tertutup di dalam jaringan perusahaan.  Dalam beberapa kasus, layanan cloud komersial dimungkinkan. <br></p><br><h4>  Otonomi </h4><br><p>  Di semua proses CI, Internet tidak tersedia.  Semua sumber daya yang diperlukan dicerminkan dan di-cache secara internal.  Sebagian bahkan github.com (terima kasih, npm!) Sebagian besar masalah ini diselesaikan oleh Artifactory. </p><br><p>  Karena itu, kita tenang ketika menghapus artefak dari pakar pusat atau menutup repositori populer.  Ada sebuah contoh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">community.oracle.com/community/java/javanet-forge-sunset</a> . </p><br><p>  Mencerminkan secara signifikan mengurangi waktu perakitan, membebaskan saluran Internet perusahaan.  Lebih sedikit sumber daya jaringan yang kritis meningkatkan stabilitas pembangunan. </p><br><h4>  Tiga repositori untuk setiap jenis artefak </h4><br><ol><li>  Dev adalah repositori tempat siapa pun dapat mempublikasikan artefak asal apa pun.  Di sini Anda dapat bereksperimen dengan pendekatan baru yang fundamental tanpa mengadaptasinya dengan standar perusahaan sejak hari pertama. </li><li>  Staging adalah repositori yang hanya diisi dengan pipa rakitan. </li><li>  Rilis - rakitan tunggal, siap untuk pengiriman eksternal.  Itu diisi dengan operasi transfer khusus dengan konfirmasi manual. </li></ol><br><h4>  Aturan 30 hari <br></h4><br><p>  Dari repositori Dev dan Staging- kami menghapus semua yang lebih lama dari 30 hari.  Ini membantu memastikan setiap orang memiliki peluang penerbitan yang sama dengan menghabiskan ruang disk server yang terbatas. </p><br><p>  Rilis disimpan selamanya, pengarsipan dilakukan jika perlu. </p><br><h4>  Bersihkan lingkungan perakitan <br></h4><br><p>  Seringkali setelah rakitan, file tambahan tetap berada dalam sistem, yang dapat memengaruhi proses perakitan lainnya.  Contoh umum: </p><br><ul><li>  masalah yang paling umum adalah cache yang rusak oleh satu perakitan yang salah (cara menangani cache, dijelaskan di bawah); </li><li>  beberapa utilitas, seperti npm, meninggalkan file layanan di direktori $ HOME yang memengaruhi semua peluncuran selanjutnya dari utilitas ini; </li><li>  rakitan tertentu dapat menghabiskan semua ruang disk di beberapa partisi / tmp, yang akan menyebabkan tidak tersedianya lingkungan secara umum. </li></ul><br><p>  Oleh karena itu, lebih baik untuk meninggalkan lingkungan terpadu demi wadah buruh pelabuhan.  Wadah harus hanya berisi perangkat lunak yang diperlukan untuk perakitan khusus dengan versi tetap. </p><br><p>  DevOps menyimpan koleksi gambar buruh pelabuhan perakitan, yang terus diperbarui.  Awalnya ada sekitar enam, lalu di bawah 30, lalu kami menyiapkan pembuatan gambar otomatis dari daftar perangkat lunak.  Sekarang cukup tentukan persyaratan seperti membutuhkan ('maven 3.3.9', 'python') - dan lingkungan sudah siap. </p><br><h4>  Diagnosis diri </h4><br><p>  Tidak hanya perlu mengatur dukungan pengguna untuk permintaan, kita juga harus menganalisis perilaku sistem kita sendiri.  Kami terus mengumpulkan log, mencari kata kunci yang menunjukkan masalah. </p><br><p>  Pada sistem "langsung", cukup menulis 20-30 ekspresi reguler sehingga untuk setiap majelis Anda dapat memberi tahu alasan penurunannya di level: </p><br><ul><li>  Git server crash </li><li>  ruang disk telah habis di sana; </li><li>  membangun kesalahan karena kesalahan pengembang; </li><li>  Bug yang dikenal di Docker. </li></ul><br><p>  Jika ada sesuatu yang jatuh, tetapi tidak ada satu pun masalah yang diketahui telah terdeteksi, ini adalah kesempatan untuk mengisi kembali koleksi topeng. </p><br><p>  Lalu kami pergi ke pengguna dan mengatakan bahwa ia memiliki build dan ini dapat diperbaiki dengan cara ini. </p><br><p>  Anda akan terkejut betapa banyak masalah yang tidak dilaporkan pengguna dalam mendukung.  Lebih baik memperbaikinya terlebih dahulu dan pada waktu yang tepat.  Seringkali, kesalahan publikasi kecil diabaikan selama dua minggu, dan pada Jumat malam ternyata ini memblokir output eksternal. </p><br><h4>  Kami dengan hati-hati memilih sistem yang tergantung pada perakitan <br></h4><br><p>  Idealnya, secara umum, memastikan otonomi penuh majelis, tetapi paling sering ini tidak mungkin.  Untuk majelis berbasis java, Anda memerlukan setidaknya Artifactory untuk mirroring - lihat di atas untuk otonomi.  Setiap sistem terintegrasi meningkatkan risiko kegagalan.  Sangat diharapkan bahwa semua sistem bekerja dalam mode HA yang layak. </p><br><h3>  Antarmuka jalur perakitan </h3><br><h4>  Antarmuka tunggal untuk memanggil rakitan </h4><br><p>  Kami membuat segala jenis perakitan dengan satu sistem.  Sidang dari semua tingkatan (L1, L2 +) dijelaskan oleh kode program dan dipanggil melalui satu pekerjaan Jenkins. </p><br><p>  Namun, pendekatan ini tidak ideal.  Lebih baik menggunakan mekanisme pembangkitan otomatis pekerjaan Jenkins: misalnya, 1 pekerjaan = 1 repositori git atau 1 pekerjaan = 1 cabang git.  Ini akan mencapai yang berikut: </p><br><ul><li>  log dari majelis heterogen tidak bingung dalam satu cerita di halaman kerja Jenkins; </li><li>  pada kenyataannya, Anda mendapatkan pekerjaan yang dialokasikan dengan nyaman untuk tim atau untuk pengembang;  perasaan nyaman dapat ditingkatkan dengan menyesuaikan grafik dari hasil junit, cobertura, sonar. </li></ul><br><h4>  Kebebasan memilih teknologi <br></h4><br><p>  Memulai build adalah panggilan ke skrip bash “./build.sh”.  Dan kemudian - sistem rakitan, bahasa pemrograman, dan semua hal lain yang diperlukan untuk menyelesaikan tugas bisnis.  Ini memberikan pendekatan untuk perakitan sebagai kotak hitam. </p><br><h4>  Pos cerdas </h4><br><p>  Jalur perakitan memotong publikasi dari kotak hitam dan menempatkannya di penyimpanan perusahaan.  Untuk ini, masalah yang membosankan seperti menghasilkan nama gambar buruh pelabuhan dan memilih repositori yang tepat untuk publikasi secara otomatis diselesaikan. </p><br><p>  Pementasan dan rilis repositori selalu ada pesanan.  Diperlukan untuk mendukung publikasi spesifik dari berbagai jenis: pakar, npm, file, buruh pelabuhan. </p><br><h4>  Deskriptor majelis <br></h4><br><p>  Build.sh menjelaskan cara mengkompilasi kode, tetapi ini tidak cukup untuk wadah perakitan. </p><br><p>  Anda juga harus tahu: </p><br><ol><li>  lingkungan perakitan apa yang digunakan; </li><li>  variabel lingkungan tersedia di build.sh; </li><li>  publikasi apa yang akan dilakukan; </li><li>  opsi spesifik lainnya. </li></ol><br><p>  Kami telah memilih cara yang mudah untuk menggambarkan informasi ini dalam bentuk file yaml yang menyerupai .gitlab-ci.yaml. </p><br><h4>  Parameterisasi perakitan <br></h4><br><p>  Pengguna dapat menentukan parameter arbitrer tanpa menjalankan perintah git commit tepat di awal perakitan. </p><br><p>  Kami telah menerapkan ini dengan mendefinisikan variabel lingkungan langsung dari antarmuka kerja Jenkins. </p><br><p>  Misalnya, kami mentransfer versi pustaka dependen ke parameter perakitan seperti itu dan, dalam beberapa kasus, mendefinisikan kembali versi ini ke versi eksperimental.  Tanpa mekanisme seperti itu, pengguna harus menjalankan perintah "git commit" setiap kali. </p><br><h4>  Portabilitas sistem <br></h4><br><p>  Anda harus dapat mereproduksi proses perakitan tidak hanya di server CI utama, tetapi juga di komputer pengembang.  Ini membantu dalam men-debug skrip pembuatan yang rumit.  Selain itu, daripada Jenkins, terkadang akan lebih mudah menggunakan Gitlab CI.  Oleh karena itu, sistem build haruslah aplikasi java yang independen.  Kami menerapkannya sebagai plugin gradle. </p><br><h4>  Satu artefak dapat diterbitkan dengan nama yang berbeda. <br></h4><br><p>  Ada dua persyaratan yang berlawanan untuk publikasi yang dapat muncul secara bersamaan. </p><br><p>  Di satu sisi, untuk penyimpanan jangka panjang dan manajemen pelepasan, perlu untuk memastikan keunikan nama-nama artefak yang diterbitkan.  Setidaknya ini akan melindungi artefak agar tidak ditimpa. </p><br><p>  Di sisi lain, kadang-kadang nyaman untuk memiliki satu artefak yang sebenarnya dengan nama tetap seperti terbaru.  Misalnya, pengembang tidak perlu mengetahui versi pasti dari ketergantungan setiap kali, Anda hanya bisa bekerja dengan yang terbaru. </p><br><p>  Artefak dalam kasus ini diterbitkan dengan dua atau lebih nama, karena cocok untuk semua orang. </p><br><p>  Sebagai contoh: </p><br><ol><li>  nama unik dengan cap waktu atau UUID - untuk mereka yang membutuhkan akurasi; </li><li>  nama "terbaru" - untuk pengembang mereka, yang selalu mengambil kode terbaru; </li><li>  nama "&lt;versi utama&gt; .x-latest" adalah untuk tim tetangga yang siap untuk mengambil versi terbaru, tetapi hanya dalam kerangka utama tertentu. </li></ol><br><p>  Maven melakukan sesuatu yang serupa dalam pendekatannya ke SNAPSHOT. </p><br><h4>  Kurang pembatasan keamanan <br></h4><br><p>  Semua orang dapat memulai perakitan.  Ini tidak akan membahayakan siapa pun, karena majelis hanya menciptakan artefak. </p><br><h3>  Kepatuhan Hukum </h3><br><h4>  Kontrol interaksi eksternal dari proses perakitan </h4><br><p>  Majelis tidak dapat menggunakan apa pun yang dilarang dalam proses kerjanya. </p><br><p>  Untuk ini, perekaman lalu lintas jaringan dan akses ke cache file diimplementasikan.  Kami mendapatkan log aktivitas jaringan perakitan dalam bentuk daftar url dengan hash256 hash data yang diterima.  Selanjutnya, setiap url divalidasi: </p><br><ol><li>  daftar putih statis; </li><li>  database dinamis artefak yang diizinkan (misalnya, untuk dependensi maven-, rpm-, npm-).  Setiap kecanduan dipertimbangkan secara individual.  Izin otomatis atau larangan penggunaan mungkin berhasil, dan diskusi panjang dengan pengacara juga dapat dimulai. </li></ol><br><h4>  Konten transparan artefak yang diterbitkan <br></h4><br><p>  Kadang-kadang tugasnya adalah menyediakan daftar perangkat lunak pihak ketiga di dalam perakitan apa pun.  Untuk melakukan ini, mereka membuat penganalisa komposisi sederhana yang menganalisis semua file dan arsip dalam majelis, mengenali pihak ketiga dengan hash dan membuat laporan. </p><br><h4>  Kode sumber yang dikeluarkan tidak dapat dihapus dari GIT <br></h4><br><p>  Terkadang Anda mungkin perlu menemukan kode sumber dengan melihat artefak biner yang dikompilasi dua tahun lalu.  Untuk melakukan ini, perlu untuk mengalokasikan tag di Git secara otomatis dengan output eksternal, serta melarang penghapusannya. </p><br><h3>  Logistik dan Akuntansi <br></h3><br><h4>  Semua majelis disimpan dalam database. </h4><br><p>  Kami menggunakan repositori file di Artifactory untuk tujuan ini.  Ini berisi semua informasi pendukung: siapa yang meluncurkannya, apa hasil pemeriksaannya, artefak apa yang diterbitkan, hash git mana yang digunakan, dll. </p><br><h4>  Kami tahu cara mereproduksi perakitan seakurat mungkin </h4><br><p>  Menurut hasil majelis, kami menyimpan informasi berikut: </p><br><ul><li>  keadaan pasti kode yang dikumpulkan; </li><li>  dengan parameter apa peluncuran dilakukan; </li><li>  perintah apa yang disebut; </li><li>  apa akses ke sumber daya eksternal terjadi; </li><li>  lingkungan perakitan bekas. </li></ul><br><p>  Jika perlu, kita dapat secara akurat menjawab pertanyaan tentang bagaimana itu dikumpulkan. </p><br><h4>  Komunikasi dua arah perakitan dengan tiket JIRA <br></h4><br><p>  Pastikan Anda dapat memecahkan masalah berikut: </p><br><ol><li>  untuk perakitan, buat daftar tiket JIRA yang termasuk di dalamnya; </li><li>  tuliskan di tiket JIRA majelis mana yang termasuk di dalamnya. </li></ol><br><p>  Komunikasi dua arah yang ketat antara majelis dan komit git disediakan.  Dan kemudian dari teks komentar Anda sudah bisa mengetahui tentang semua tautan ke JIRA. </p><br><h3>  Kecepatan </h3><br><h4>  Tembolok sistem perakitan </h4><br><p>  Tidak adanya cache maven dapat meningkatkan waktu pembuatan satu jam. </p><br><p>  Cache melanggar isolasi lingkungan rakitan dan kebersihan rakitan.  Masalah ini dapat diselesaikan dengan menentukan asalnya untuk setiap artefak yang di-cache.  Kami memiliki masing-masing file cache yang dikaitkan dengan tautan https dari mana file itu pernah diunduh.  Selanjutnya kami memproses pembacaan cache sebagai alamat jaringan. </p><br><h4>  Tembolok Sumber Daya Jaringan </h4><br><p>  Pertumbuhan geografis perusahaan mengarah pada kebutuhan untuk mentransfer file 300 MB antar benua.  Banyak waktu dihabiskan, terutama jika Anda harus sering melakukan ini. </p><br><p>  Git repositori, gambar buruh pelabuhan dari lingkungan perakitan, penyimpanan file - semuanya harus di-cache dengan hati-hati.  Yah, tentu saja, bersih secara berkala. </p><br><h4>  Perakitan - secepat mungkin, yang lainnya - lalu </h4><br><p>  Tahap pertama: kami melakukan perakitan dan segera, tanpa gerakan yang tidak perlu, kami memberikan hasilnya. </p><br><p>  Tahap kedua: validasi, analisis, akuntansi dan birokrasi lainnya.  Ini dapat dilakukan sudah dalam pekerjaan Jenkins yang terpisah dan tanpa batas waktu yang ketat. </p><br><h2>  Apa hasilnya </h2><br><ol><li>  Hal utama adalah bahwa <i>perakitan menjadi jelas bagi pengembang</i> , mereka sendiri dapat mengembangkan dan mengoptimalkannya. </li><li>  Yayasan ini telah dibuat untuk membangun proses bisnis yang bergantung pada perakitan: instalasi, manajemen masalah, pengujian, manajemen rilis, dll. </li><li>  Tim DevOps tidak lagi menulis skrip perakitan: pengembang melakukannya. </li><li>  Persyaratan perusahaan yang kompleks berubah menjadi laporan transparan dengan daftar cek terakhir. </li><li>  Siapa pun dapat membangun repositori apa pun hanya dengan memanggil build.sh melalui satu antarmuka.  Cukup baginya untuk menentukan koordinat git dari kode sumber.  Orang ini bisa menjadi manajer tim, insinyur QA / IT, dll. </li></ol><br><p>  Dan beberapa angka </p><br><ol><li>   .   15    Jenkins job    build.sh.   15    docker-,   ,  .      .        . </li><li>  .         .      2200 .   —  on-commit-. </li><li>      300 git-,     . </li><li>      30   ,   (25 ) —  docker. </li><li>      ,     : <br><ol><li> glide, golang, promu; </li><li> maven, gradle; </li><li> python &amp; pip; </li><li> ruby; </li><li> nodejs &amp; npm; </li><li> docker; </li><li> rpm build tools &amp; gcc; </li><li>  Android   ADT; </li><li>  ; </li><li>    legacy-; </li><li>   . </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421423/">https://habr.com/ru/post/id421423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421413/index.html">Akses yang tepat ke metode antarmuka standar melalui refleksi di Java 8, 9, 10</a></li>
<li><a href="../id421415/index.html">Magic Leap - tempat sampah yang menyedihkan</a></li>
<li><a href="../id421417/index.html">Mesin kopi untuk pecandu kopi, atau mesin kopi mobile Wacaco</a></li>
<li><a href="../id421419/index.html">Ode untuk "membuahkan" nikel, safir yang tidak ada, dan wakil menteri Soviet: ikon OTTO SX-P1 di Jepang, Amerika Serikat dan Uni Soviet</a></li>
<li><a href="../id421421/index.html">LAppS: Setengah Juta Pesan 1KB-WebSocket per Detik dengan TLS pada Satu CPU</a></li>
<li><a href="../id421425/index.html">Jinak dan Konsolidasi: Kisah Pindah ke Oracle Supercluster</a></li>
<li><a href="../id421429/index.html">LSTM - ANN Dynamic Pricing dalam Retail Barang Rumah</a></li>
<li><a href="../id421431/index.html">Manajemen Waktu, atau Manajemen Kekacauan yang Efektif</a></li>
<li><a href="../id421433/index.html">Hanya ada satu hari tersisa sebelum server dimulai.</a></li>
<li><a href="../id421435/index.html">"Kenapa kita semua melakukan ini?" - Pencipta Prisma dan mantan pemimpin proyek VK tentang proyek rahasia barunya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>