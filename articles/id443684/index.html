<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔻 🧐 👩🏻‍🤝‍👨🏽 Daftar lengkap perbedaan antara VB.NET dan C #. Bagian 1 👩🏿‍🤝‍👩🏻 🦍 🚴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menurut peringkat TIOBE pada tahun 2018, VB.NET melampaui popularitas C #. Secara kebetulan atau tidak, tetapi pada bulan Februari, Eric Lippert, sala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Daftar lengkap perbedaan antara VB.NET dan C #. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/443684/"><img src="https://habrastorage.org/webt/lv/zu/ex/lvzuexv-rlsyr8aeycle0f9r--4.png" alt="gambar"><br><br>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peringkat</a> TIOBE pada tahun 2018, VB.NET melampaui popularitas C #.  Secara kebetulan atau tidak, tetapi pada bulan Februari, Eric Lippert, salah satu pencipta C #, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendesak</a> pembaca untuk memperhatikan blog temannya, mantan rekan satu tim dari kompiler Roslyn dan, dalam kombinasi, seorang penggemar VB.NET yang bersemangat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anthony Green</a> .  "Sumber daya semacam itu adalah perincian mendalam dari para ahli yang tidak begitu mudah ditemukan dengan membaca dokumentasinya," tulis Eric.  Kami mempersembahkan perhatian Anda pada bagian pertama dari terjemahan artikel Anthony Green “Daftar Perbedaan yang Luas Antara VB.NET dan C #”.  Mungkin justru pada perbedaan-perbedaan inilah letak rahasia dinamika peringkat bahasa-bahasa ini. <br><a name="habracut"></a><br>  Selama hampir setengah hidup saya, saya telah menyaksikan dan berpartisipasi dalam diskusi yang tak terhitung jumlahnya tentang seberapa mirip atau berbeda dua bahasa .NET yang paling populer.  Pertama, sebagai seorang amatir, kemudian sebagai seorang profesional, dan akhirnya, sebagai penasihat pelanggan, manajer program dan perancang bahasa, saya dapat mengatakan tanpa berlebihan berapa kali saya mendengar atau membaca sesuatu seperti: <br><blockquote>  <i>"... VB.NET benar-benar hanya lapisan tipis di atas IL, seperti C # ..."</i> </blockquote>  atau <blockquote>  <i>"... VB.NET sebenarnya hanya C # tanpa titik koma ..."</i> </blockquote> Seolah-olah bahasa adalah konversi XML atau style sheet. <br><br>  Dan jika beberapa pengunjung yang bersemangat tidak menulis ini dalam komentar, maka sering kali ini tersirat dalam pertanyaan seperti: <i>"Halo, Anthony!</i>  <i>Saya menemukan perbedaan kecil di satu tempat - apakah ini bug?</i>  <i>Bagaimana mungkin kedua bahasa yang identik ini, yang seharusnya identik atas nama semua yang baik dan suci di dunia ini, tersebar di satu tempat ini?</i>  <i>Mengapa kita membutuhkan ketidakadilan seperti itu ?!</i> <br><br>  " <b>Pisahkan,</b> " seolah-olah mereka sama sampai terjadi mutasi, dan <i>kemudian</i> menjadi spesies yang terpisah.  Hah! <br><br>  Tapi saya mengerti itu.  Sebelum saya bergabung dengan Microsoft, saya mungkin juga memegang gagasan ini secara samar-samar dan menggunakannya sebagai argumen untuk menanggapi lawan atau meyakinkan seseorang.  Saya mengerti pesonanya.  Mudah dimengerti dan sangat mudah diulang.  Tetapi bekerja pada Roslyn (pada dasarnya menulis ulang VB dan C # sepenuhnya dari awal) selama 5 tahun, saya menyadari betapa <b>salahnya ide ini</b> .  Saya bekerja dengan tim pengembang dan penguji untuk mengimplementasikan kembali setiap inci dari kedua bahasa, serta alat-alat mereka dalam solusi multi-proyek besar dengan jutaan baris kode yang ditulis dalam kedua bahasa.  Dan dengan mempertimbangkan sejumlah besar pengembang beralih di antara mereka bolak-balik, dan tingkat kompatibilitas yang tinggi dengan hasil dan pengalaman dari versi sebelumnya, serta kebutuhan untuk secara andal mereproduksi volume raksasa API secara sangat terperinci, saya dipaksa untuk mengetahui perbedaannya dengan sangat dekat.  Bahkan, kadang-kadang saya merasa bahwa saya belajar sesuatu yang baru tentang VB.NET (bahasa favorit saya) setiap hari. <br><br>  Dan akhirnya, saya mengambil waktu untuk duduk dan membongkar dari otak sebuah partikel dari apa yang saya pelajari menggunakan dan menciptakan VB.NET selama 15 tahun terakhir, dengan harapan setidaknya saya dapat menghemat waktu saya di waktu berikutnya. <br><br>  Sebelum pindah ke daftar, saya akan menguraikan aturan dasar: <br><br><ul><li>  Daftar ini tidak lengkap dalam arti biasa.  Dia lengkap.  Ini tidak semua perbedaan.  Ini bahkan tidak semua perbedaan yang umumnya saya tahu.  Ini hanya perbedaan yang bisa saya ingat pertama, sampai saya terlalu lelah untuk melanjutkan;  sampai aku kehabisan kekuatan.  Jika saya atau salah satu dari Anda bertemu atau mengingat perbedaan lainnya, saya akan dengan senang hati memperbarui daftar ini. </li><li>  Saya akan mulai pada awal spesifikasi VB 11 dan bergerak ke bawah menggunakan kontennya untuk mengingatkan diri saya tentang perbedaan yang muncul pertama kali dalam topik ini. </li><li>  <b>Ini BUKAN daftar fungsi dalam VB yang tidak dalam C #.</b>  Jadi tidak ada "XML literal versus pointer."  Ini terlalu biasa, dan sudah ada banyak daftar seperti itu di Internet (beberapa di antaranya ditulis oleh saya, dan mungkin di masa depan saya akan menulis lebih banyak).  Saya akan fokus terutama pada konstruksi yang memiliki analog dalam kedua bahasa, dan di mana pengamat yang kurang informasi dapat menyarankan bahwa kedua hal ini berperilaku sama, tetapi di mana ada perbedaan kecil atau besar;  mereka mungkin terlihat sama, tetapi bekerja secara berbeda atau pada akhirnya menghasilkan kode yang berbeda. </li><li>  <b>Ini BUKAN daftar perbedaan sintaksis antara VB dan C #</b> (yang tak terhitung jumlahnya).  Saya terutama akan berbicara tentang perbedaan semantik (apa artinya), dan bukan tentang perbedaan sintaksis (bagaimana segala sesuatu ditulis).  Jadi tidak ada bagian seperti "VB memulai komentar dengan ', dan C # menggunakan //" atau "dalam C # _ adalah pengidentifikasi yang valid, tetapi tidak dalam VB".  Tetapi saya akan melanggar aturan ini untuk beberapa kasus.  Bagaimanapun, bagian pertama dari spesifikasi adalah tentang aturan leksikal. </li><li>  Cukup sering, saya akan memberikan contoh, dan kadang-kadang saya akan memberikan alasan mengapa desain bisa berjalan dengan satu atau lain cara.  Beberapa keputusan desain dibuat di depan mata saya, tetapi sebagian besar mendahului waktu saya, dan saya hanya bisa menebak mengapa itu dibuat. </li><li>  Silakan tinggalkan komentar atau tweet saya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ThatVBGuy</a> ) untuk memberi tahu saya perbedaan favorit Anda dan / atau yang ingin Anda ketahui lebih lanjut. </li></ul><br>  Setelah menetapkan harapan dan tanpa penundaan lebih lanjut ... <br><br><h2>  Isi </h2><br><div class="spoiler">  <b class="spoiler_title">Teks tersembunyi</b> <div class="spoiler_text"><h4>  Sintaks dan preprocessing </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Kata kunci dan operator VB dapat menggunakan karakter lebar penuh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. VB mendukung kutipan cerdas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Konstanta preprocessing dapat dari jenis primitif (termasuk tanggal) dan dapat mengandung nilai konstan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Operator aritmatika dapat digunakan dalam ekspresi preprocessing</a> </li></ul><br><h4>  Pengumuman, dll. </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. VB kadang-kadang melewatkan deklarasi implementasi dalam IL untuk mencegah implementasi implisit antarmuka dengan nama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. VB secara default menyembunyikan anggota kelas dasar dengan nama (Bayangan), dan bukan dengan nama dan tanda tangan (Kelebihan)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. VB11 dan di bawah ini lebih ketat untuk anggota yang dilindungi dalam generik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Sintaks "Named argumen" dalam atribut selalu menginisialisasi properti / bidang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9. Semua deklarasi tingkat atas (biasanya) secara implisit terletak di root namespace proyek.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">10. Modul tidak dihasilkan sebagai kelas abstrak disegel di IL, sehingga mereka tidak persis terlihat seperti kelas C # statis dan sebaliknya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">11. Anda tidak perlu metode eksplisit untuk titik masuk (Sub Utama) dalam aplikasi WinForms</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">12. Jika Anda memanggil beberapa metode runtime VB usang (misalnya, FileOpen), metode panggilan akan secara implisit ditandai dengan atribut untuk menonaktifkan inlining karena alasan kebenaran</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">13. Jika tipe Anda ditandai dengan atribut DesignerGenerated dan tidak mengandung deklarasi konstruktor eksplisit, maka kompiler yang dihasilkan secara default akan memanggil InitializeComponent jika itu ditentukan untuk tipe ini.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">14. Tidak adanya pengubah parsial TIDAK berarti bahwa jenisnya tidak parsial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">15. Di kelas default, tingkat akses Publik adalah untuk semua hal kecuali bidang, dan dalam struktur Publik, untuk bidang juga</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">16. VB menginisialisasi bidang SETELAH konstruktor dasar dipanggil, sedangkan C # menginisialisasi bidang-bidang SEBELUM konstruktor dasar disebut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">17. Bidang dukungan yang dinyatakan secara implisit dari peristiwa VB memiliki nama yang berbeda dari pada C # dan dapat diakses dengan nama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">18. Bidang bantu yang dinyatakan secara implisit dari properti-otomatis VB memiliki nama yang sama dan dapat diakses dengan nama ini</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">19. Bidang pembantu baca-saja yang dinyatakan secara implisit memungkinkan penulisan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">20. Atribut acara kadang-kadang diterapkan ke bidang acara tambahan</a> </li></ul><br><h4>  Instruksi </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">21. Ruang lingkup label adalah badan dari seluruh metode yang mengandungnya;</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat melompat ke dalam balok (tidak semua)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">22. Masa hidup variabel lokal &lt;&gt; ruang lingkup</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">23. Variabel selalu diinisialisasi ke nilai default untuk jenis yang sesuai.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">24. RaiseEvent TIDAK melempar pengecualian jika bidang bantu nol</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">25. Tugas tidak selalu sama;</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terkadang penugasan tipe referensi melakukan klon dangkal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">26. Select Case tidak mendukung fall-through;</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak perlu istirahat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">27. Setiap blok Kasus memiliki cakupannya sendiri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">28, 29, 30. Select Case berfungsi dengan tipe non-primitif, dapat menggunakan ekspresi non-konstan sewenang-wenang dalam pemeriksaan, dan secara default menggunakan operator =</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">31. Variabel yang dideklarasikan di dalam loop mempertahankan artinya di antara iterasi dengan beberapa cara</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">32. Tiga untuk ekspresi loop dievaluasi hanya sekali di awal loop.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">33. Untuk Setiap loop di VB dapat menggunakan metode ekstensi GetEnumerator</a> </li></ul></div></div><br><h2>  Sintaks dan preprocessing </h2><br><a name="section1"></a><h3>  1. Kata kunci dan operator VB dapat menggunakan karakter lebar penuh </h3><br>  Beberapa bahasa (saya tidak tahu berapa tepatnya, tetapi setidaknya dalam beberapa bentuk bahasa Cina, Jepang dan Korea) menggunakan karakter lebar-lebar.  Singkatnya, ini berarti bahwa ketika menggunakan font monospace (seperti kebanyakan programmer), karakter Cina akan memakan ruang horizontal dua kali lebih banyak daripada karakter Latin yang biasa kita lihat di barat.  Sebagai contoh: <br><br><img src="https://habrastorage.org/webt/wl/j8/0u/wlj80uri5nr810dqgpwymj5eru0.png"><br><br>  Di sini saya memiliki deklarasi variabel yang ditulis dalam bahasa Jepang, dan inisialisasi dengan string juga ditulis dalam bahasa Jepang.  Menurut penerjemah Bing, variabel ini disebut "ucapan" dan baris mengatakan "Halo Dunia!"  Nama variabel dalam bahasa Jepang hanya 2 karakter, tetapi membutuhkan ruang 4 karakter setengah-lebar yang biasanya diberikan keyboard saya, seperti yang ditunjukkan oleh komentar pertama.  Ada versi angka dengan lebar penuh dan semua karakter ASCII tercetak lainnya yang memiliki lebar yang sama dengan karakter Jepang.  Untuk menunjukkan ini, saya menulis komentar kedua menggunakan angka lebar-penuh "1" dan "2".  Ini bukan "1" dan "2" seperti pada komentar pertama.  Tidak ada spasi di antara angka-angka.  Anda juga dapat melihat bahwa ukuran karakter tidak tepat 2 karakter, ada sedikit offset.  Ini sebagian karena program ini menggabungkan karakter lebar-lebar dan setengah-lebar dalam satu baris dan dalam ketiga baris. <br><br>  Spasi setengah lebar, karakter alfanumerik adalah lebar penuh.  Kami bukan pemrogram kecuali kami terobsesi dengan perataan teks.  Dan menurut saya, jika Anda orang Cina, Jepang, atau Korea (atau orang lain yang menggunakan karakter berukuran penuh untuk bahasa mereka) dan menggunakan pengidentifikasi atau string yang ditulis dalam bahasa asli mereka, kesalahan penyejajaran kecil ini menyebalkan. <br><br>  Sejauh yang saya mengerti, tergantung pada keyboard Jepang Anda, beralih antara hieroglif dan Latin itu mudah, tetapi lebih baik menggunakan karakter Latin lebar-lebar.  VB mendukung ini dalam kata kunci, spasi, operator, dan bahkan tanda kutip.  Jadi semua ini bisa ditulis seperti ini: <br><br><img src="https://habrastorage.org/webt/me/mq/ph/memqph465sxyx_tvxov6fglrjfw.png"><br><br>  Seperti yang Anda lihat, dalam versi ini kata kunci, spasi, komentar, operator, bahkan tanda kutip menggunakan versi ukuran penuhnya.  Ke dalam kekacauan membawa ketertiban. <br><br>  Ya  Orang Jepang menggunakan VB.  Bahkan, meskipun sintaksinya mirip dengan bahasa Inggris (dan mungkin itu sebabnya), bagi sebagian besar pengguna VB yang saya lihat di forum, bahasa Inggris bukanlah bahasa utama.  Selama bekerja di Microsoft, saya bertemu VB MVP Jepang beberapa kali, setidaknya salah satu dari mereka terus-menerus membawa permen Jepang.  Jika Anda seorang programmer VB dari China, Jepang atau Korea (atau dari negara lain yang menggunakan karakter lebar penuh), silakan tulis di komentar.  (Dalam komentar kepada penulis, mereka menulis bahwa orang Jepang mencoba di mana-mana dalam kode untuk menggunakan ascii - <i>kira</i> - <i>kira Per.</i> ) <br><br>  <i><b>Lucu saat:</b> Ketika saya awalnya menerapkan garis interpolasi di VB, saya (saya malu) tidak memperhitungkan kemungkinan kurung keriting lebar penuh di tempat-tempat substitusi.</i>  <i>Vladimir Reshetnikov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@vreshetnikov</a> ) menemukan dan memperbaiki kesalahan ini, sehingga tradisi besar toleransi VB pada lebar karakter tetap valid.</i> <br><br><a name="section2"></a><h3>  2. VB mendukung kutipan cerdas </h3><br>  Oke, ini, tentu saja, agak sepele, tetapi layak disebutkan.  Pernahkah Anda melihat kode sampel dalam dokumen teks seperti ini: <br><br><img src="https://habrastorage.org/webt/ls/8l/qc/ls8lqckokgku3b0raqiboefn9bc.png"><br><br>  Dan setelah menyalin contoh ke kode Anda, apakah Anda menemukan bahwa tidak ada kutipan (yang disorot) yang berfungsi, karena Word mengganti semua kutipan ASCII yang biasa dengan <code>“</code> kutipan pintar <code>”</code> ? <br><br>  Saya tidak.  Oke, saya sudah memilikinya, tetapi hanya ketika saya menyalin contoh ke C #.  Di VB, kutipan cerdas adalah pembatas yang valid untuk string (lucu bahwa tanda kutip Rusia <code>«»</code> tidak berfungsi - Perkiraan. Per.): <br><br><img src="https://habrastorage.org/webt/l0/yk/wi/l0ykwi3ebeigkgrkkrzq8lfrwhm.png"><br><br>  Mereka juga bekerja di dalam string, meskipun mungkin dengan cara yang aneh.  Jika Anda menggandakan kutipan pintar untuk melarikan diri, maka yang Anda dapatkan saat runtime hanyalah tanda kutip ("dumb").  Ini mungkin tampak sedikit aneh, tetapi tetap sangat praktis, karena hampir di mana pun kutipan pintar diizinkan dalam string.  Kompiler TIDAK membuat Anda pasti mengakhiri dengan kutipan cerdas atau menggunakan yang benar jika Anda mulai dengan yang cerdas, sehingga Anda dapat mencampurnya tanpa khawatir.  Dan ya, ini juga berfungsi dengan karakter kutipan tunggal yang digunakan untuk komentar: <br><br><img src="https://habrastorage.org/webt/4y/9j/8n/4y9j8n7mexmkyvtx_vmj-jesfak.png"><br><br>  Saya mencoba membuat Paul Wick ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@panopticoncntrl</a> ) mengakui bahwa dia melakukan ini semata-mata karena dia tersiksa dengan masalah ini ketika mengerjakan spesifikasi, tetapi dia menyangkal kesalahan apa pun.  Ini tidak terjadi di VB6, jadi seseorang menambahkan ini nanti. <br><br><a name="section3"></a><h3>  3. Konstanta preprocessing dapat dari jenis primitif (termasuk tanggal) dan dapat mengandung nilai konstan </h3><br><p><img src="https://habrastorage.org/webt/sd/0f/jv/sd0fjva0vsarlwmx7vgwn8yf8xq.png"></p><br><a name="section4"></a><h3>  4. Operator aritmatika dapat digunakan dalam ekspresi preprocessing </h3><br><p><img src="https://habrastorage.org/webt/hx/cw/0k/hxcw0k25imfieuvg_ncshwbizim.png"></p><br><br><h2>  Pengumuman, dll. </h2><br><a name="section5"></a><h3>  5. VB terkadang melewatkan IL mengimplementasikan deklarasi untuk mencegah implementasi implisit antarmuka dengan nama. </h3><br>  Item ini dari kategori esoterisme.  Dalam VB, implementasi antarmuka selalu dilakukan secara eksplisit.  Tetapi ternyata bahwa dengan tidak adanya implementasi eksplisit, perilaku default dari CLR ketika memanggil metode antarmuka adalah mencari metode publik dengan nama dan tanda tangan.  Dalam kebanyakan kasus, ini normal, karena VB <i>biasanya</i> perlu menyediakan implementasi untuk setiap anggota antarmuka yang Anda implementasikan, kecuali untuk satu kasus: <br><br><pre> <code class="vbscript hljs">Interface IFoo <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Bar() <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Baz() <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Interface <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Foo Implements IFoo <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Bar() Implements IFoo.Bar <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> IFoo_Baz() Implements IFoo.Baz <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> FooDerived Inherits Foo Implements IFoo <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Bar() Implements IFoo.Bar <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Baz() <span class="hljs-comment"><span class="hljs-comment">' Does something unrelated to what an IFoo.Baz would do. End Sub End Class</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/39634fd98a0cacc093719ab62d7ab1e6#file-partial-re-implementation-vb</a> <br><br>  Dalam contoh ini, kelas <code>FooDerived</code> hanya ingin menetapkan kembali <code>IFoo.Bar</code> ke metode baru, tetapi membiarkan implementasi yang tersisa tidak berubah.  Ternyata jika kompiler hanya menghasilkan arahan implement untuk <code>FooDerived</code> , CLR juga akan mengambil <code>FooDerived.Baz</code> sebagai implementasi baru dari <code>IFoo.Baz</code> (walaupun dalam contoh ini tidak terkait dengan <code>IFoo</code> ).  Dalam C #, ini terjadi secara implisit (dan saya tidak yakin apakah saya bisa menolaknya), tetapi dalam VB, kompiler sebenarnya menghilangkan 'Implements' dari seluruh deklarasi untuk menghindari ini, dan menimpa hanya anggota tertentu yang diimplementasikan kembali.  Dengan kata lain, jika Anda bertanya kepada <code>FooDerived</code> apakah <code>IFoo</code> secara langsung, ia akan mengatakan tidak: <br><p><img src="https://habrastorage.org/webt/kz/u7/fr/kzu7fr0j1zz4eadll-m5gto7f8q.png"></p><br>  Mengapa saya tahu ini dan mengapa ini penting?  Selama bertahun-tahun, pengguna VB telah meminta dukungan untuk implementasi implisit dari sebuah antarmuka (tanpa secara eksplisit menentukan <code>Implements</code> dalam setiap deklarasi), biasanya untuk pembuatan kode.  Hanya menggabungkan ini dengan sintaks saat ini akan melanggar perubahan, karena <code>FooDerived.Baz</code> sekarang secara implisit mengimplementasikan <code>IFoo.Baz</code> , meskipun belum pernah melakukan ini sebelumnya.  Tetapi baru-baru ini, saya belajar lebih banyak tentang perilaku ini ketika membahas potensi masalah dalam desain fitur "implementasi antarmuka default", yang akan memungkinkan antarmuka untuk memasukkan implementasi standar dari beberapa anggota dan tidak memerlukan implementasi ulang di setiap kelas.  Ini akan berguna untuk kelebihan beban, misalnya, ketika implementasi cenderung sama untuk semua pelaksana (pendelegasian ke kelebihan beban utama).  Skenario lain adalah versi.  Jika sebuah antarmuka dapat menyertakan implementasi default, Anda dapat menambahkan anggota baru ke dalamnya tanpa merusak implementasi lama.  Tapi ada masalah.  Karena perilaku default di CLR adalah untuk mencari implementasi publik dengan nama dan tanda tangan, jika kelas VB tidak mengimplementasikan anggota antarmuka dengan implementasi default, tetapi memiliki anggota publik dengan nama dan tanda tangan yang sesuai, mereka secara implisit mengimplementasikan anggota antarmuka ini, bahkan jika Anda melakukannya sepenuhnya tidak seharusnya.  Ada hal-hal yang dapat Anda lakukan untuk menyiasati hal ini ketika set lengkap anggota antarmuka diketahui pada waktu kompilasi.  Tetapi jika anggota ditambahkan setelah mengkompilasi kode, itu hanya mengubah perilaku diam-diam saat runtime. <br><br><a name="section6"></a><h3>  6. VB secara default menyembunyikan anggota kelas dasar dengan nama (Bayangan), dan bukan dengan nama dan tanda tangan (Kelebihan) </h3><br>  Saya pikir perbedaan ini cukup terkenal.  Skenarionya adalah ini: Anda mewarisi kelas dasar ( <code>DomainObject</code> ), mungkin di luar kendali Anda, dan mendeklarasikan metode dengan nama yang masuk akal dalam konteks kelas Anda, misalnya, <code>Print</code> : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> DomainObject <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Invoice Inherits DomainObject <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Print(copies As Integer) <span class="hljs-comment"><span class="hljs-comment">' Sends contents of invoice to default printer. End Sub End Class</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/863cfd1e7536fe8bda7cd145795eaf9f#file-shadows-example-vb</a> <br><br>  Fakta bahwa faktur dapat dicetak masuk akal.  Tetapi dalam versi API berikutnya di mana kelas dasar Anda dideklarasikan, mereka memutuskan untuk debugging untuk menambahkan ke semua DomainObjects metode yang menampilkan konten penuh objek di jendela debug.  Metode ini secara brilian disebut Cetak.  Masalahnya adalah bahwa klien API Anda mungkin memperhatikan bahwa objek Faktur memiliki metode <code>Print()</code> dan <code>Print(Integer)</code> , dan berpikir bahwa ini adalah kelebihan beban terkait.  Mungkin yang pertama hanya mencetak satu salinan.  Tapi ini sama sekali bukan apa yang Anda bayangkan sebagai penulis Faktur.  Anda tidak tahu bahwa <code>DomainObject.Print</code> akan muncul.  Jadi ya, ini tidak berfungsi di VB.  Ketika situasi ini muncul, peringatan muncul, tetapi yang lebih penting, perilaku default di VB adalah untuk menyembunyikan nama.  Yaitu, sampai Anda secara eksplisit menunjukkan dengan kata kunci <code>Overloads</code> bahwa <code>Print</code> Anda adalah kelebihan <code>Print</code> kelas dasar, anggota kelas dasar (dan kelebihannya) sepenuhnya tersembunyi.  Hanya API yang awalnya Anda nyatakan yang ditampilkan kepada klien kelas Anda.  Ini berfungsi secara default, tetapi Anda dapat melakukannya secara eksplisit melalui kata kunci Shadows.  C # hanya dapat melakukan <code>Overloads</code> (meskipun memperhitungkan <code>Shadows</code> ketika merujuk ke pustaka VB) dan melakukannya secara default (menggunakan kata kunci <code>new</code> ).  Tetapi perbedaan ini muncul dari waktu ke waktu ketika beberapa hierarki warisan muncul dalam proyek-proyek di mana satu kelas didefinisikan dalam satu bahasa dan yang lain dalam bahasa lain, dan ada metode kelebihan beban, tetapi ini di luar ruang lingkup item saat ini dalam daftar perbedaan. <br><br><a name="section7"></a><h3>  7. VB11 dan di bawah ini lebih ketat untuk anggota yang dilindungi dalam generik </h3><br>  Bahkan, kami mengubah ini antara VS2013 dan VS2015.  Secara khusus, kami memutuskan untuk tidak repot dengan implementasi ulang.  Tapi saya menulis perbedaan ini jika Anda menggunakan versi lama dan perhatikan.  Singkatnya: jika anggota yang dilindungi dideklarasikan dalam tipe generik, maka pewarisnya, yang juga generik, dapat mengakses anggota yang dilindungi ini hanya melalui instance turunan dengan argumen tipe yang sama. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Base(Of T) Protected x As T <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Derived</span></span>(Of T) Inherits Base(Of T) <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> F(y As <span class="hljs-built_in"><span class="hljs-built_in">Derived</span></span>(Of <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)) <span class="hljs-comment"><span class="hljs-comment">' Error: Derived(Of T) cannot access Derived(Of String)'s ' protected members yx = "a" End Sub End Class</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/ce12ac986219eb51d6c85fa02c339a2f#file-protected-in-generics-vb</a> <br><br><a name="section8"></a><h3>  8. Sintaks "Named argumen" dalam atribut selalu menginisialisasi properti / bidang </h3><br>  VB menggunakan sintaks yang sama <code>:=</code> untuk menginisialisasi properti atribut / bidang seperti untuk melewati argumen metode dengan nama.  Oleh karena itu, tidak ada cara untuk meneruskan argumen ke konstruktor atribut dengan nama. <br><br><a name="section9"></a><h3>  9. Semua deklarasi tingkat atas (biasanya) secara implisit terletak di root namespace proyek </h3><br>  Perbedaan ini hampir dalam kategori "fitur-fitur canggih", tetapi saya telah memasukkannya dalam daftar karena itu mengubah makna kode.  Ada bidang dalam properti proyek VB: <br><br><p><img src="https://habrastorage.org/webt/0y/hy/7_/0yhy7_k2xkchvxq70v1duka5z4a.png"></p><br>  Secara default, ini hanyalah nama proyek Anda pada saat pembuatan.  Ini <b>BUKAN</b> bidang yang sama dengan "Ruang nama default" di properti proyek C #.  Namespace default hanya menetapkan kode mana yang ditambahkan secara default ke file baru di C #.  Tetapi root namespace di VB berarti bahwa, kecuali dinyatakan sebaliknya, setiap deklarasi tingkat atas dalam proyek ini secara implisit ada dalam namespace ini.  Inilah sebabnya mengapa templat dokumen VB biasanya tidak mengandung deklarasi namespace.  Selain itu, jika Anda menambahkan deklarasi namespace, itu tidak menimpa root, tetapi ditambahkan ke dalamnya: <br><br><pre> <code class="vbscript hljs">Namespace Controllers <span class="hljs-comment"><span class="hljs-comment">' Child namespace. End Namespace Namespace Global.Controllers ' Top-level namespace End Namespace</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/fd1e5e3a58aee862a5082e1d2b078084#file-root-namespace-vb</a> <br><br>  Dengan demikian, namespace <code>Controllers</code> sebenarnya mendeklarasikan namespace <code>VBExamples.Controllers</code> , kecuali Anda menyingkirkan mekanisme ini dengan secara eksplisit mendeklarasikan <code>Global</code> di namespace. <br><br>  Ini nyaman karena menyimpan satu tingkat lekukan dan satu konsep tambahan untuk setiap file VB.  Dan ini sangat berguna jika Anda membuat aplikasi UWP (karena semuanya harus ada dalam namespace di UWP), dan itu sangat nyaman jika Anda memutuskan untuk mengubah namespace tingkat atas untuk seluruh proyek Anda, katakanlah, dari beberapa nama kode seperti Roslyn ke rilis yang lebih lama, seperti <code>Microsoft.CodeAnalysis</code> , karena Anda tidak perlu memperbarui setiap file secara manual dalam solusi.  Penting juga untuk mengingat hal ini ketika bekerja dengan generator kode, ruang nama XAML, dan <code>.vbproj</code> file <code>.vbproj</code> baru. <br><br><a name="section10"></a><h3>  10. Modul tidak dihasilkan sebagai kelas abstrak disegel di IL, sehingga mereka tidak persis terlihat seperti kelas C # statis dan sebaliknya. </h3><br>  Modul di VB ada sebelum kelas C # statis, meskipun kami mencoba pada 2010 untuk membuatnya sama dalam hal IL.  Sayangnya, ini merupakan perubahan besar, karena XML Serializer (atau mungkin itu biner) untuk versi .NET (saya pikir mereka memperbaikinya) tidak ingin menyambungkan tipe yang bersarang ke dalam tipe yang tidak dapat dibuat (dan kelas abstrak) tidak bisa).  Dia melemparkan pengecualian. <br><br>  Kami menemukan ini setelah melakukan perubahan dan mengembalikannya karena beberapa kode di suatu tempat menggunakan tipe enum yang tertanam dalam modul.  Dan karena Anda tidak tahu versi serializer mana program yang dikompilasi akan bekerja, itu tidak akan pernah mungkin untuk mengubahnya, karena itu akan bekerja dalam satu versi aplikasi dan memberikan pengecualian pada yang lain. <br><br><a name="section11"></a><h3>  11. Anda tidak perlu metode eksplisit untuk titik masuk (Sub Utama) dalam aplikasi WinForms </h3><br>  Jika proyek Anda menggunakan Formulir sebagai objek awal dan tidak menggunakan "Kerangka Aplikasi" (lebih lanjut tentang ini di posting berikutnya), VB menghasilkan <code>Sub Main</code> , yang membuat formulir awal Anda dan meneruskannya ke <code>Application.Run</code> , menyelamatkan Anda seluruh file Untuk mengelola proses ini, baik metode tambahan di <code>Form</code> Anda, atau bahkan perlu memikirkan masalah ini. <br><br><a name="section12"></a><h3>  12. Jika Anda memanggil beberapa metode runtime VB lama (misalnya, FileOpen), metode pemanggilan akan ditandai secara implisit dengan atribut untuk menonaktifkan inlining karena alasan kebenaran </h3><br>  Singkatnya, metode untuk bekerja dengan file gaya VB6 seperti <code>FileOpen</code> mengandalkan konteks khusus untuk perakitan di mana kode berada.  Sebagai contoh, file # 1 dapat berupa log in satu proyek dan konfigurasi di yang lain.  Untuk menentukan perakitan mana yang sedang berjalan, <code>Assembly.GetCallingAssembly()</code> dipanggil.  Tetapi jika JIT memasukkan metode Anda ke dalam penelepon, maka dari sudut pandang tumpukan, metode runtime VB tidak akan dipanggil oleh metode Anda, tetapi oleh penelepon, yang mungkin berada di majelis berbeda, yang kemudian dapat memungkinkan kode Anda untuk mengakses atau melanggar keadaan internal penelepon. objek  Ini bukan masalah keamanan, karena jika kode yang berkompromi sedang berjalan dalam proses Anda, Anda telah kehilangan.  Ini masalah kebenaran.  Oleh karena itu, jika Anda menggunakan metode ini, kompiler menonaktifkan inlining. <br><br>  Perubahan ini dibuat pada saat terakhir di 2010, karena JIT x64 SANGAT agresif ketika inlining / mengoptimalkan kode, dan kami menemukannya sangat terlambat, dan itu adalah pilihan paling aman. <br><br><a name="section13"></a><h3>  13. Jika tipe Anda ditandai dengan atribut DesignerGenerated dan tidak mengandung deklarasi konstruktor eksplisit, maka kompiler yang dihasilkan secara default akan memanggil InitializeComponent jika itu ditentukan untuk tipe ini </h3><br>  Di era sebelum munculnya jenis Parsial, tim VB berperang untuk mengurangi kode boilerplate dalam proyek-proyek WinForms.  Tetapi bahkan dengan <code>Partial</code> ini berguna karena memungkinkan file yang dihasilkan untuk sepenuhnya menghilangkan konstruktor, dan pengguna dapat secara manual mendeklarasikannya dalam file-nya jika diperlukan, atau tidak menyatakannya jika tidak.  Tanpa ini, perancang akan dipaksa untuk menambahkan konstruktor hanya untuk memanggil <code>InitializeComponent</code> , dan jika pengguna menambahkan juga, mereka akan menjadi duplikat, atau toolkit harus cukup pintar untuk memindahkan konstruktor dari file desainer ke pengguna dan tidak membuat ulang di perancang, jika dia sudah ada di file pengguna. <br><br><a name="section14"></a><h3>  14. Tidak adanya pengubah parsial TIDAK berarti bahwa jenisnya tidak parsial </h3><br>  Secara teknis, dalam VB, hanya satu kelas yang harus ditandai sebagai Partial.  Ini biasanya (dalam proyek GUI) file yang dihasilkan. <br><br>  <b>Mengapa</b>  Ini membuat file pengguna cantik dan bersih, dan bisa sangat nyaman untuk dimasukkan setelah membuat atau menambahkan kode khusus ke kode yang dihasilkan.  Namun, disarankan bahwa paling banyak satu kelas tidak memiliki pengubah Parsial, jika tidak, peringatan akan dikeluarkan. <br><br><a name="section15"></a><h3>  15. Di kelas default, tingkat akses Publik adalah untuk semua hal kecuali bidang, dan dalam struktur Publik, untuk bidang juga </h3><br>  Saya memiliki perasaan campur aduk tentang ini.  Dalam C #, semuanya bersifat <code>private</code> secara default (sorakan, enkapsulasi!), Tapi ada argumen yang harus dilakukan tergantung pada apa yang sering Anda nyatakan: kontrak publik atau detail implementasi.  Properti dan acara umumnya ditujukan untuk penggunaan eksternal ( <code>public</code> ), dan operator tidak dapat diakses selain <code>public</code> .  Namun, saya jarang mengandalkan aksesibilitas default (dengan pengecualian demo seperti contoh dalam artikel ini). <br><br><a name="section16"></a><h3>  16. VB menginisialisasi bidang SETELAH konstruktor dasar dipanggil, sedangkan C # menginisialisasi bidang-bidang SEBELUM konstruktor dasar disebut </h3><br>  Pernahkah Anda mendengar bagaimana "beberapa" mengatakan bahwa hal pertama yang terjadi di konstruktor adalah panggilan ke konstruktor kelas dasar?  Ya, bukan itu masalahnya, setidaknya dalam C #.  Di C #, sebelum memanggil <code>base()</code> , eksplisit atau implisit, inisialisasi bidang dieksekusi terlebih dahulu, lalu panggilan konstruktor, dan kemudian kode Anda.  Keputusan ini memiliki konsekuensi, dan saya pikir saya tahu mengapa pengembang bahasa bisa berjalan dengan satu atau lain cara.  Saya percaya salah satu konsekuensi ini adalah bahwa kode berikut tidak dapat langsung diterjemahkan ke C #: <br><br><pre> <code class="vbscript hljs">Imports System.Reflection <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> ReflectionFoo <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> StringType As Type = GetType(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> StringLengthProperty As PropertyInfo = StringType.GetProperty(<span class="hljs-string"><span class="hljs-string">"Length"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> StringGetEnumeratorMethod As MethodInfo = StringType.GetMethod(<span class="hljs-string"><span class="hljs-string">"GetEnumerator"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> StringEnumeratorType As Type = StringGetEnumeratorMethod.ReturnType <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">New</span></span>() Console.WriteLine(StringType) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/37d01c8e7f085e06172bfaf6a1e567d4#file-field-in-init-me-reference-vb</a> <br><br>  Pada hari-hari ketika saya terlibat dalam Refleksi, saya sering menulis kode seperti itu.  Dan saya samar-samar mengingat seorang rekan sebelum Microsoft (Josh), yang menerjemahkan kode saya ke C #, kadang-kadang mengeluh tentang perlunya port semua inisialisasi saya ke konstruktor.  Dalam C #, dilarang untuk merujuk ke objek yang dibuat sebelum <code>base()</code> dipanggil.  Dan karena inisialisasi bidang dieksekusi sebelum panggilan yang ditentukan, mereka juga tidak dapat merujuk ke bidang lain atau anggota instance objek.  Jadi contoh ini juga hanya berfungsi di VB: <br><br><pre> <code class="vbscript hljs">MustInherit <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Base <span class="hljs-comment"><span class="hljs-comment">' OOP OP? Private Cached As Object = DerivedFactory() Protected MustOverride Function DerivedFactory() As Object End Class Class Derived Inherits Base Protected Overrides Function DerivedFactory() As Object Return New Object() End Function End Class</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/fe5ca89e5a98efee97ffee93aa684e50#file-base-derived-init-vb</a> <br><br>  Di sini kita memiliki kelas dasar, yang seharusnya memiliki banyak fungsi, tetapi membutuhkan beberapa objek kunci untuk manajemen, pekerjaan, yang ditentukan oleh tipe turunan.  Ada banyak cara untuk mengimplementasikan template seperti itu, tetapi saya biasanya menggunakan ini karena: <br><br><ul><li>  dia pendek; </li><li>  tidak mengharuskan saya untuk mendeklarasikan konstruktor; </li><li>  tidak mengharuskan saya untuk memasukkan kode inisialisasi ke dalam konstruktor, jika ada; </li><li>  memungkinkan saya untuk men-cache objek yang dibuat dan tidak memerlukan tipe turunan untuk mendeklarasikan dan mengelola penyimpanan untuk objek yang disediakan, meskipun sekarang ini bukan masalah dengan properti-otomatis. </li></ul><br>  Lebih jauh, saya telah dalam kedua situasi: ketika sebuah bidang dalam tipe turunan ingin memanggil metode yang dideklarasikan di kelas dasar, dan ketika inisialisasi bidang dari kelas dasar perlu memanggil anggota <code>MustOverride</code> diimplementasikan oleh tipe turunan.  Keduanya valid dalam VB dan tidak ada dalam C #, dan itu masuk akal.  Jika penginisialisasi bidang C # dapat memanggil anggota kelas dasar, anggota ini dapat bergantung pada bidang yang diinisialisasi dalam konstruktor basis (yang belum berjalan) dan hasilnya hampir pasti salah, dan tidak ada jalan lain untuk mengatasi hal ini. <br><br>  Tetapi dalam VB, konstruktor dasar telah bekerja, sehingga Anda dapat melakukan apa saja!  Dalam situasi yang berlawanan, semuanya sedikit lebih rumit, karena memanggil anggota <code>Overridable</code> dari penginisialisasi (atau konstruktor) dari kelas dasar dapat menyebabkan akses ke bidang sebelum mereka "diinisialisasi".  Tetapi hanya implementasi Anda yang tahu apakah ini masalah.  Dalam skrip saya, ini tidak terjadi.  Mereka tidak bergantung pada keadaan instance, tetapi tidak dapat menjadi anggota yang <code>Shared Overridable</code> karena Anda tidak dapat memiliki anggota yang <code>Shared Overridable</code> dalam bahasa apa pun karena alasan teknis di luar cakupan artikel ini.  Selain itu, secara jelas ditentukan apa yang terjadi pada bidang sebelum memulai inisialisasi khusus - mereka diinisialisasi dengan nilai default, seperti semua variabel dalam VB.  Tidak ada kejutan. <br><br>  <b>Jadi mengapa?</b>  Sebenarnya, saya tidak tahu apakah skrip saya adalah apa yang ada dalam pikiran tim VB.NET asli saat mereka mendesainnya.  Ini hanya berfungsi dalam kasus saya!  ,       :  VB ,         ,       .              .          . <br><br> <i> ,              ,    ,          C#  VB,       ,    VB  ,   C#.</i> <br><br><a name="section17"></a><h3> 17.     (backing field)  VB   ,   C#,     </h3><br>          (       ).        <code>E</code> ,  VB   (  IDE)    <code>EEvent</code> .  C#     <code>E</code> ,     ,   <code>E</code>   ,    . <br><br><a name="section18"></a><h3> 18.      VB         </h3><br>      <code>P</code> ,      <code>_P'</code> .    IntelliSense,      .  C#    «» ( <i>mangled</i> ) ,  ,            C#     . <br><br> <b> ?</b>  VB    , -,             «WithEvents»,  -,     ,   -     ,        . <br><br><a name="section19"></a><h3> 19.     read-only    </h3><br>    ,        ,  ….   VB     « »    .    <code>WithEvents</code> -, non-Custom           ,       ,     .    IntelliSense,      ,     ,  .   FTW!  ,   VB  ,    private set;   C#. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Alarm <span class="hljs-keyword"><span class="hljs-keyword">Private</span></span> ReadOnly Code As Integer ReadOnly <span class="hljs-keyword"><span class="hljs-keyword">Property</span></span> Status As <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"Disarmed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">New</span></span>(code As Integer) <span class="hljs-keyword"><span class="hljs-keyword">Me</span></span>.Code = code <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Arm() <span class="hljs-comment"><span class="hljs-comment">' I'm motifying the value of this externally read-only property here. _Status = "Armed" End Sub Function Disarm(code As Integer) As Boolean If code = Me.Code Then ' And here. _Status = "Disarmed" Return True Else Return False End If End Function End Class</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/57ce7962700c5498894ad417296f9066#file-read-only-auto-property-backing-field-is-writeable-vb</a> <br><br><a name="section20"></a><h3> 20.         </h3><br>  ,  <code>NonSerialized</code> . <br><br>   VB       (expanded) Custom-  2005  (?) <b></b>       ,         ,  ,   <code>NonSerialized</code> .  ,     ,   ,   ,       «»       ,    « ». <br><br>     ,   ,          ,  ,   . , , ,     ,     two-way bindable ( ,   <code>PropertyChanged</code> ),     ,    , , ,    . <br><br>   ,     ,       CLSA «Expert Business Objects» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  (Rocky Lhotka)</a> ,      undo/redo (    ,    ,   - ,  ,     ),       .  ,         .  ,  ,        ,    . <br><br><h2>  </h2><br><a name="section21"></a><h3> 21.    —    ,  ;      ( ) </h3><br>   ,      <code>GoTo</code>     .   ,        -   . ,       <code>For</code>  <code>For Each</code> ;  <code>Using</code> , <code>SyncLock</code>  <code>With</code> ,   ,     ,        <code>Finally</code> .   <code>If</code>  <code>Select Case</code> ,  <code>Do</code>  <code>While</code> ,    Try —    ,        : <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> retryCount = <span class="hljs-number"><span class="hljs-number">0</span></span> Try Retry: <span class="hljs-comment"><span class="hljs-comment">' IO call. Catch ex As IO.IOException When retryCount &lt; 3 retryCount += 1 GoTo Retry End Try End Sub End Module</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/b93adcf3c3705e4768dcab0b05b187a0#file-try-goto-retry-vb</a> <br><br>  ,  ,   ,   .NET  VB      «».  VB6        Quick Basic  ( )       .      QB,      .     ,       « »,           .        GoTo,         —   ,        . <br><br> <b></b> :    <code>Try</code>    ,  VB -   <code>await</code>   <code>Catch</code>  <code>Finally</code> ,  ,     <code>GoTo</code>    . <br><br><a name="section22"></a><h3> 22.     &lt;&gt;   </h3><br>    ,  VB   (     )  ( <code>static</code> )        (      ).    ,     .        <code>Catch</code>       3 .      <code>Try</code>      <code>Catch</code> ,      ,   ,       <code>Try</code>     . <br><br>  ,  VB.NET     ,     .       CLR      VB   .      :           ,    . <br><br> <i>, C# ,        ,       «».   VB.NET     .</i> <br><br><a name="section22"></a><h3> 23.          </h3><br>       ,        ,    C#       « » ( <i>definite assignment</i> ).   ,    , ,         « ».   ,   ( )           ,   ,          .    C/C++.      , !   ,        .  ,        ,    , —  .           ,     ,   ,         ,  ,         ,      ,          ,    .  ,  BASIC   ,          ,      «» ,       <code>= Nothing</code> , <code>= 0</code> , <code>= False</code>  .. <br><br> ,   ( <i>flow analysis</i> )  VB    ,    . <br><br>         ,    C#   ,  ,          ,            . VB    <i></i>  ,       ,        ,       .  Roslyn, , API       « »,       ,      . <br><br><a name="section24"></a><h3> 24. RaiseEvent   ,     null </h3><br>     ,  -     C#  VB. <code>RaiseEvent</code>  VB —        ,     <code>null</code> ( ),    <code>null</code> - —  ,      . <br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">' You don't have to write this: If PropertyChangedEvent IsNot Nothing Then RaiseEvent PropertyChanged(Me, e) End If ' You don't have to write this: Dim handlers = PropertyChangedEvent If handlers IsNot Nothing Then handlers(Me, e) End If ' You don't have to write this either: PropertyChangedEvent?(Me, e) ' Just write this: RaiseEvent PropertyChanged(Me, e)</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/c3dea3d91ef4ffc50cfa92c41f967937#file-null-safe-event-raising-vb</a> <br><br> ,    null-conditional   C#  VS2015     C#   ,      VB (  ),       ,     ;   VB.NET    . <br><br><a name="section25"></a><h3> 25.    ;        (shallow clone) </h3><br>     , ,        17 , ,     .     (boxed)      Object,       <code>System.Runtime.CompilerServices.RuntimeHelper.GetObjectValue</code> .   ,   CLR.    ,    : <br><br><ul><li>     ,      . <br></li><li>       ,    (,     Integer ),      . <br></li><li>        ,            . <br></li></ul><br>    ,     ,  ,    ,       ( <i>late-bound situations</i> ). ,        ,     (    )  ,           ,   ,        ,      ( <i>caller's copy</i> ).          ,     ,  - , —     . <br><br>          .     : <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> MyEventArgs <span class="hljs-keyword"><span class="hljs-keyword">Property</span></span> Value As Object <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> Structure MyStruct <span class="hljs-keyword"><span class="hljs-keyword">Public</span></span> X, Y As Integer <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Structure Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> defaultValue As Object = <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> MyStruct <span class="hljs-keyword"><span class="hljs-keyword">With</span></span> {.X = <span class="hljs-number"><span class="hljs-number">3</span></span>, .Y = <span class="hljs-number"><span class="hljs-number">5</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> MyEventArgs <span class="hljs-keyword"><span class="hljs-keyword">With</span></span> {.Value = defaultValue} RaiseEvent DoSomething(<span class="hljs-literal"><span class="hljs-literal">Nothing</span></span>, e) <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> e.Value <span class="hljs-keyword"><span class="hljs-keyword">Is</span></span> defaultValue <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> <span class="hljs-comment"><span class="hljs-comment">' No handlers have changed anything. Console.WriteLine("Unchanged.") End If End Sub Event DoSomething(sender As Object, e As MyEventArgs) End Module</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/422ac4574af92d9bbbf59f0fbc40b74d#file-get-object-value-vb</a> <br><br>      ,     WPF,               .    ,     . ,                     ,        .    ,    .   ,    -   ,  , ,              . <br><br> ,    ,   « »         .    IronRuby/Python,    <code>dynamic</code>  C# (  C#): C#    <code>GetObjectValue</code>     .         <code>object.ReferenceEquals</code> ,  ,    ,   <i></i>    -    <code>dynamic</code> C# (     ).       <code>==</code> ,    .   C#,    ,          . <br><br><a name="section26"></a><h3> 26. Select Case   «» (fall-through);   break </h3><br>     Friday    ,  Sunday —  ,  5   . <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> Today.DayOfWeek <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Monday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Tuesday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Wednesday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Thursday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Friday: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Weekday"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Saturday: <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Sunday: Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Weekend"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/7b7e136c71dd11b2417a6c7267bb3546#file-select-case-no-fallthrough-vb</a> <br><br>     Roslyn C#  ,  -      : <i>«,    ?   !»</i>   <i>«,  »</i> .   . VS    ,    ,   ,    ,      ,     .    ! <br><br>       . C# ,        C,       C.       .  , C#     ,    case   .   -  ,     <code>goto</code> ,  <code>break</code> .     VB   <code>break</code> , <code>Exit Select</code> ,       ,    VB   . <br><br><a name="section27"></a><h3> 27.   Case     </h3><br>      ,      .           C#,   : <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> Today.DayOfWeek <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Monday, DayOfWeek.Tuesday, DayOfWeek.Wednesday, DayOfWeek.Thursday, DayOfWeek.Friday <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> message = <span class="hljs-string"><span class="hljs-string">"Get to work!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span> DayOfWeek.Saturday, DayOfWeek.Sunday <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> message = <span class="hljs-string"><span class="hljs-string">"Funtime!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/bd642061896246c9336255881fb78546#file-select-case-scopes-vb</a> <br><br>   ,  <code>message</code>        ,    C#   <code>switch</code>         <code>case</code> —   .     . ,  ,  -    (  ,  C):        , , ,  ,     . <br><br><a name="section28to30"></a><h3> 28, 29, 30. Select Case    ,             = </h3><br> ,  ,     ,            ,     <code>Select Case</code>             . <br><br>             ,       ,     .    : <br><br><ul><li> <code>Select Case</code> —  ,           , … <br></li><li> <code>switch</code> —   / ,   « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   ». <br></li></ul><br>  ,    26-30. <code>switch</code>    ,    ,  , ,     <code>if</code> .  IL   <code>switch</code> ,   ,   <code>If</code> ,   VB        ,   .    switch       , ,    C   .  VB    . <br><br><a name="section31"></a><h3> 31. ,   ,         </h3><br>       <code>x</code>    ,      ,      -1, -2, -3: <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> x As Integer x -= <span class="hljs-number"><span class="hljs-number">1</span></span> Console.WriteLine(x) <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/cbc3a9c70677354973d64f1d993a3c5d#file-loop-variables-retain-their-values-vb</a> <br><br>    <i>«     ,    ,    »</i> ( ).   ,      VB2008  ,    -: <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> lambdas = <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> List(Of Action) <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> x As Integer x -= <span class="hljs-number"><span class="hljs-number">1</span></span> lambdas.Add(<span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span>() Console.WriteLine(x)) <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Each</span></span> lambda <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> lambdas lambda() <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/2ef9ba3dfcf9a1abe0e94b0cde12faf1#file-loop-variables-captured-per-iteration-vb</a> <br><br>     -1, -2, -3.     <code>x</code> — « », -   <code>x</code>    ,      .          ,        <code>x</code>     .     flow analysis API — ! ( <i>«… …  ?»</i> ) <br><br> <b>?</b>   ,  ,      ,    ,      ,        #22.         ,        ,       -,         . <br><br> ,   VB  C#      ( <i>control variables</i> )  <code>For Each</code>  VS2012 (?),  -   « ».   10000%    ,    (  , VB      ,      ).  ,    VB         <code>For</code> ,        .            ,      .      ,   VB  <code>For</code>      <code>For Each</code> ,  <code>for</code>  <code>foreach</code>  C#.          ,   <code>For</code>  VB -  ,    ,      . <br><br><a name="section32"></a><h3> 32.    For        </h3><br>         <code>For</code> .        ,   ,       1,3,5,7,9,          ,     . <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> lower = <span class="hljs-number"><span class="hljs-number">1</span></span>, upper = <span class="hljs-number"><span class="hljs-number">9</span></span>, increment = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> i = lower <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> upper <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span> increment Console.WriteLine(i) upper += <span class="hljs-number"><span class="hljs-number">1</span></span> increment -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/1e48113be204f515c51e221858666ac7#file-for-loop-bounds-cached-vb</a> <br><br>    ,          (       ),   ,     ,    ,          <code>IndexOutOfRangeExceptions</code> ,    . <br><br>   ,   ,      , , ,       C,    VB .  - ,  VB ,  <code>For i = a To b Step c</code>   (  ,  <code>i&gt; b</code> )   (  ,  <code>i &lt;b</code> ),   <code>c</code>    ?    ,    ,      ,   <code>b</code>   ,   — .    ,     , , ,       . <br><br><a name="section33"></a><h3> 33. For Each   VB     GetEnumerator </h3><br>       <code>For Each</code> ,     <code>IEnumerable</code> ,       <code>GetEnumerator</code>  ,    <code>For Each</code> . <br> ,   ,     <code>For Each</code>  <code>IEnumerator</code>  ,          , : <br><br><pre> <code class="vbscript hljs">Module Program <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> Main() <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">New</span></span> List(Of Integer) From {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> info = list.FirstAndRest() <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> info.First IsNot <span class="hljs-literal"><span class="hljs-literal">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> Console.Write(info.First.GetValueOrDefault()) <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Each</span></span> other <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> info.Additional Console.Write(<span class="hljs-string"><span class="hljs-string">", "</span></span>) Console.Write(other) <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> Console.WriteLine() <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sub</span></span> &lt;Runtime.CompilerServices.Extension&gt; <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> FirstAndRest(Of T As Structure)(sequence As IEnumerable(Of T)) As (First As T?, Additional As IEnumerator(Of T)) <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> enumerator = sequence.GetEnumerator() <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> enumerator.MoveNext() <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> Return (enumerator.Current, enumerator) <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span> Return (<span class="hljs-literal"><span class="hljs-literal">Nothing</span></span>, enumerator) <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> &lt;Runtime.CompilerServices.Extension&gt; <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> GetEnumerator(Of T)(enumerator As IEnumerator(Of T)) As IEnumerator(Of T) Return enumerator <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> Module</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gist.github.com/AnthonyDGreen/d7dbb7a5b98a940765c4adc33e3eaeee#file-for-each-extension-get-enumerator-vb</a> <br><br>           F#        ,    <code>IEnumerator</code> ,     <code>For Each</code>    ,   . <br><br>  VB   ,            ( <i>well-known name</i> ),      .   , ,   Add,   . C#     ,          (. <code>async</code> / <code>await</code> ).      ,    C# Roslyn ()     ,     . <br><blockquote>  Menit periklanan. 15-16   -    .NET- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DotNext 2019 Piter</a> .   ,       .       ,      .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443684/">https://habr.com/ru/post/id443684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443672/index.html">Pengujian Berbasis Risiko</a></li>
<li><a href="../id443676/index.html">Vinyl alih-alih perangko: jarang terjadi</a></li>
<li><a href="../id443678/index.html">Keterbacaan kode</a></li>
<li><a href="../id443680/index.html">Empat hari kerja seminggu. Pengalaman Rusia</a></li>
<li><a href="../id443682/index.html">Monetisasi cloud: cara menarik pelanggan dan tidak bangkrut</a></li>
<li><a href="../id443686/index.html">30 - 31 Maret, SIBUR CHALLENGE di Nizhny Novgorod</a></li>
<li><a href="../id443690/index.html">Parallels RAS: ada apa dan dengan apa ia makan?</a></li>
<li><a href="../id443692/index.html">Alkimia Abad 21: Mengubah Deuterium Logam Cair menjadi Plasma</a></li>
<li><a href="../id443694/index.html">Bagaimana browser membantu Kamerad Utama</a></li>
<li><a href="../id443698/index.html">Google telah berhenti "mencekik angsa": DuckDuckGo termasuk dalam daftar mesin pencari Chrome standar untuk 60 negara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>