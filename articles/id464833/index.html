<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¥Ÿ ğŸš ğŸ™Œ Hitung Scoring de la Fer atau studi tentang penilaian kredit sebagai bagian dari memperluas wawasan seseorang. Bagian 2 ğŸ€ ğŸ‘§ğŸ» ğŸŒœ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AntipovSN dan MihhaCF 


 Bagian dua, di mana Athos memiliki semua aturan, tetapi Count de la Fer kehilangan sesuatu 


 UPD Bagian Satu ada di sini 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hitung Scoring de la Fer atau studi tentang penilaian kredit sebagai bagian dari memperluas wawasan seseorang. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464833/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">AntipovSN</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">MihhaCF</a> </p><br><p>  <em>Bagian dua, di mana Athos memiliki semua aturan, tetapi Count de la Fer kehilangan sesuatu</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>UPD Bagian Satu ada di sini</strong></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>UPD bagian tiga di sini</strong></a> </p><br><p>  <strong>Pengantar dari penulis:</strong> </p><br><p>  Selamat siang  Hari ini kami melanjutkan serangkaian artikel yang ditujukan untuk penilaian dan penggunaan teori grafik di dalamnya.  Anda dapat membiasakan diri dengan artikel pertama di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Semua alegori komik, sisipan, dll. Dirancang untuk sedikit mengurangi narasi dan tidak membiarkannya jatuh ke dalam kuliah yang membosankan.  Kami meminta maaf kepada semua orang yang tidak masuk ke humor kami </p><br><p>  <strong>Tujuan artikel ini: dalam waktu</strong> tidak lebih dari 30 menit, untuk menggambarkan cara utama menyimpan data grafik dan menjelaskan aturan dan prinsip-prinsip membangun model kami untuk penilaian peminjam. </p><br><p>  <strong>Ketentuan dan definisi:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tabel hash</a> adalah struktur data yang mengimplementasikan antarmuka array asosiatif, yang memungkinkan Anda untuk menyimpan pasangan (kunci, nilai) dan melakukan tiga operasi: operasi menambahkan pasangan baru, operasi pencarian, dan operasi menghapus pasangan dengan kunci.  Pencarian berdasarkan tabel hash, rata-rata, dilakukan selama O (1) waktu. </li></ul><br><p>  Auditor yang disewa oleh Korol PJSC untuk menilai kelayakan kredit One for All NPO mengalami beberapa masalah.  Di satu sisi, sangat mudah untuk menggambarkan skema interaksi 10-15 perusahaan dan melakukan penilaian awal interaksi antara perusahaan, cukup untuk memiliki selembar kertas dan pena di tangan.  Tetapi bagaimana jika Anda memiliki informasi tentang interaksi puluhan atau ratusan ribu perusahaan?  <em>Misalnya, jika Anda perlu menggambarkan interaksi Aramis dengan semua gairah hidupnya atau D'artagnan dengan semua orang yang ia lawan?</em> </p><a name="habracut"></a><br><p>  Bagaimana cara menyimpan data tentang interaksi ini? </p><br><p>  Struktur dan pendekatan data apa yang digunakan? </p><br><p>  Auditor harus menanamkan seluruh korps penulis monastik untuk pekerjaan ini. <br>  Kami tidak akan melakukan ini dan akan memberi auditor kami pengetahuan dan teknologi masa depan ( <em>kami akan mengirimkan Prometheus dalam bentuk T-800 kepada mereka, yang akan memberi mereka cahaya pengetahuan</em> ). </p><br><p>  Baiklah, mari kita mulai menjawab pertanyaan yang diajukan.  Jadilah terang! </p><br><p>  Saat kami menulis dan menggambar di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , grafik adalah rasio 2 set - satu set node dan satu set tepi.  Apa cara terbaik untuk menyimpan grafik? </p><br><p>  Sebelum menjawab pertanyaan tentang cara menyimpan grafik, Anda perlu memutuskan apa yang ingin kami simpan dan dalam bentuk apa. </p><br><p>  Menurut teori grafik, simpul grafik dapat berupa objek apa pun dengan set parameter apa pun (fakta ini akan berguna bagi kita nanti, untuk model lanjutan / adaptif untuk menghitung bola penilaian). </p><br><p>  Jadi apa yang perlu kita simpan? </p><br><p>  Minimal, pengidentifikasi simpul dan pengidentifikasi tetangganya (dengan siapa ia terkait).  Kehadiran data ini sudah memungkinkan Anda untuk mencari lebar dan dalam. </p><br><p>  Apakah saya perlu menyimpan data tepi grafik?  Ya, jika kita berurusan dengan grafik berbobot.  Dalam kasus kami, kami berurusan dengan grafik berbobot dan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama</a> kami menggambar grafik seperti itu. </p><br><p>  Apakah informasi ini cukup?  Tidak. </p><br><p>  Dari mana tulang rusuk itu berasal?  Dalam buku teks, informasi ini ada di sana, seseorang telah mengumpulkan dan memprosesnya sebelum kita.  Di akhir Abad Pertengahan kita (saat itu Musketeers hidup) tidak ada yang mau repot menghitung bobot tepi Count kita.  Kita harus melakukannya sendiri.  Dalam artikel ini dan artikel berikutnya, kami tidak akan menjelaskan metodologi spesifik untuk menghitung bobot satu sisi, ini akan dilakukan dalam artikel 4.  Sekarang penting bagi kita untuk memutuskan informasi apa tentang grafik kita yang akan kita simpan. </p><br><p>  Jadi, dalam kasus kami, ada tiga parameter utama yang perlu kita ketahui untuk menghitung skor penilaian dengan benar: </p><br><ul><li>  Penilaian internal suatu simpul - terdiri dari indikator yang mengkarakterisasi simpul tersebut (omset, utang, denda, dll.)  Dalam contoh kita, ini akan menjadi: <br><ul><li>  Evaluasi - simpul baik atau buruk terkait dengan NPO "Satu untuk semua"; </li><li>  Peringkat simpul - Raja memiliki peringkat tertinggi, Bonacieux - terendah; </li><li>  Volume dana, dengan kata lain, solvabilitas. </li></ul></li><li>  Peringkat iga  Dalam kasus kami, penilaian koneksi akan untuk setiap node - ini berarti bahwa hubungan Bonacieux - Constance mungkin tidak sama dengan koneksi Constance - Bonacieux, karena  mereka memiliki kemungkinan berbeda untuk saling mempengaruhi. </li><li>  Level simpul - tidak akan disimpan, tetapi merupakan indikator penting. </li></ul><br><p>  Jangan tanya dari mana semua angka-angka ini berasal dari model, D'artanyan melihatnya.  Dalam kehidupan nyata, indikator-indikator ini juga tidak akan dihitung oleh kami (perdagangan, utang, denda, dll., Kami ambil dari sumber yang ada, kami tidak berada di Abad Pertengahan, semacam). </p><br><p>  Dari semua hal di atas, ternyata di samping pengidentifikasi node, kita harus menyimpan parameter setiap node dan bobot tepi yang kita dapatkan berdasarkan pada agregasi parameter dari node tersebut. </p><br><p>  Total, informasi berikut dapat disimpan: </p><br><ul><li>  Nama simpul; </li><li>  Parameter simpul </li><li>  Simpul tetangga; </li><li>  Berat iga untuk setiap tetangga. </li></ul><br><p>  Hebat!  Kami menemukan apa yang perlu kami simpan.  Sekarang - cara menyimpan. </p><cut></cut><br><p>  Dan sekali lagi penyimpangan kecil. </p><br><p>  Seperti apa proses penilaian kami dalam bentuk yang disederhanakan: </p><br><ul><li>  Pengumpulan data objek; </li><li>  Pembentukan objek yang akan menggambarkan model grafik.  Di fasilitas inilah kami akan melakukan semua operasi penilaian kami. </li></ul><br><p>  Berdasarkan dua langkah ini, kami memiliki tiga opsi: </p><br><ul><li>  Kami menyimpan data tentang objek penilaian pada server SQL / NoSQL.  Semua operasi yang terkait dengan perhitungan, algoritma, dll. Dilakukan langsung di server; </li><li>  Kami menyimpan data tentang objek penilaian pada server SQL / NoSQL.  Berdasarkan data ini, kami membuat objek terpisah (misalnya, tabel hash) yang dengannya kami melakukan semua perhitungan dasar; </li><li>  Data tentang objek penilaian disimpan dalam RAM.  Berdasarkan data ini, kami membuat objek terpisah (misalnya, tabel hash) yang dengannya kami melakukan semua perhitungan dasar. </li></ul><br><p>  Persyaratan dasar untuk proses ini: </p><br><ul><li>  Kecepatan kerja; </li><li>  Keandalan </li><li>  Verifikasi. <br>  Sekarang mari kita bicara.  <em>Kami akan duduk, seperti musketeer kami sambil minum apa yang mereka minum di sana, teh, misalnya.</em>  <em>Yang utama adalah kita tidak mengganggu semua jenis ayam dengan para penjaga.</em> </li></ul><br><p>  Jika penyimpanan jangka panjang diperlukan, maka Anda dapat memilih tabel dengan bidang signifikan yang sesuai.  Dalam NoSQL atau RAM, lebih baik menyimpan data dalam bentuk daftar atau direktori (tabel hash) objek. </p><br><pre><code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">'Id'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Title'</span></span>: <span class="hljs-string"><span class="hljs-string">'   '</span></span>, <span class="hljs-string"><span class="hljs-string">'Rang'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'Type'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'Profit'</span></span>: <span class="hljs-number"><span class="hljs-number">10000</span></span> }</code> </pre> <br><p>  Dengan puncak lebih atau kurang jelas.  Apa cara terbaik untuk mewakili lengkok / tepi grafik?  Untuk melakukan ini, Anda perlu memahami prinsip dasar dari setiap operasi analitik pada grafik - akses ke busur / tepi harus terjadi dengan sangat cepat, diharapkan bahwa waktu akses sama dengan O (1).  Array atau matriks langsung terlintas dalam pikiran - struktur di mana setiap elemen dapat diakses dengan cepat berdasarkan indeks. </p><br><p>  [i, j] - elemen matriks menunjukkan busur dari grafik, di mana i adalah pengidentifikasi titik awal, j adalah pengidentifikasi titik akhir, akses dan pemilihan titik awal terjadi secara langsung oleh pengidentifikasi titik awal.  Persimpangan i dan j menyimpan bobot tepi. </p><br><p>  Ada beberapa kelemahan pada tampilan ini: </p><br><ul><li>  Seringkali, strukturnya redundan, terutama jika grafiknya jarang (sejumlah kecil tepian), ada banyak nilai kosong yang menunjukkan bahwa tidak ada koneksi. </li><li>  Untuk menemukan semua tetangga vertex, perlu untuk memilah-milah semua elemen dari baris ke-i dari matriks hubungan. </li><li>  Matriks dengan banyak kolom tidak dapat disimpan dalam database. </li></ul><br><p>  Opsi selanjutnya untuk menyimpan busur / tepi adalah tabel, yaitu, kumpulan kolom dan baris. <br>  Sebagai contoh: </p><br><p><img src="https://habrastorage.org/webt/r-/nv/_o/r-nv_ourlwvnfu5fwvvctw0ngho.png"></p><br><p>  Struktur seperti itu dapat dengan mudah disimpan dalam basis data relasional dan pilih nilai yang diperlukan ketika mengeksekusi query SQL, tetapi ketika menyangkut RAM, kompleksitas menemukan semua tepi verteks meningkat dan dalam kasus umum mengambil O (n) di mana n adalah jumlah semua tepi grafik. </p><br><p>  Ada metode penyimpanan grafik lain yang sangat bagus untuk digunakan di hampir semua sistem, tanpa kekurangan yang dijelaskan di atas - ini adalah referensi nilai kunci atau tabel hash.  Mendapatkan semua tepi dari simpul yang diinginkan terjadi dengan kecepatan O (1). <br>  Sebuah kekurangan yang signifikan adalah bahwa tidak semua bahasa pemrograman mendukung desain ini. </p><br><p>  Bagaimana seseorang dapat membayangkan struktur yang serupa dalam sistem yang berbeda? </p><br><p>  Di database relasional, Anda bisa menerapkan hubungan tabel objek dan tepi (paragraf sebelumnya) </p><br><p><img src="https://habrastorage.org/webt/eh/s8/nu/ehs8nurxkqi_ruedkyoxbure8iw.png"></p><cut></cut><br><p>  <strong>NoSQL</strong> </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">'Id'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Title'</span></span>: <span class="hljs-string"><span class="hljs-string">'   '</span></span>, <span class="hljs-string"><span class="hljs-string">'Rang'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'Type'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'Profit'</span></span>: <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-string"><span class="hljs-string">'Relations'</span></span>: [{<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}, â€¦ {n, <span class="hljs-number"><span class="hljs-number">-5</span></span>}] }</code> </pre> <br><p>  Saat mengakses objek dengan kuncinya, kami segera mendapatkan satu set koneksinya.  Jika kami memiliki grafik yang tidak berbobot, alih-alih larik objek, Anda dapat melewati larik pengidentifikasi tetangga Hubungan: [3,4, ... n].  Dalam bentuk referensi, kuncinya adalah nilainya, opsi ini mirip dengan yang sebelumnya.  Dalam direktori, nilai kunci, Anda dapat menyimpan objek yang sama seperti pada contoh sebelumnya, kunci, tentu saja, akan menjadi pengidentifikasi titik (mungkin ada angka, mungkin ada string, dll., Yang memungkinkan sistem pengembangan tertentu).  Juga di direktori Anda hanya dapat menyimpan array tautan, dan informasi tentang simpul di direktori lain. </p><br><pre> <code class="python hljs">Graf[<span class="hljs-number"><span class="hljs-number">1</span></span>] = { <span class="hljs-string"><span class="hljs-string">'Id'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Title'</span></span>: <span class="hljs-string"><span class="hljs-string">'   '</span></span>, <span class="hljs-string"><span class="hljs-string">'Rang'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'Type'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'Profit'</span></span>: <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-string"><span class="hljs-string">'Relations'</span></span>: [{<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}, â€¦ {n, <span class="hljs-number"><span class="hljs-number">-5</span></span>}] }</code> </pre> <br><p>  atau </p><br><pre> <code class="python hljs">graf[<span class="hljs-string"><span class="hljs-string">'one_for_all'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Relations'</span></span>: [{<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}, â€¦ {n, <span class="hljs-number"><span class="hljs-number">-5</span></span>}]</code> </pre> <br><p>  Sebagai contoh kami, kami memilih opsi untuk menyimpan data dalam RAM dengan membuat tabel hash untuk mencetak data.  Hasil antara akan ditulis ke file di server. </p><br><p>  Kami memiliki struktur penyimpanan yang buruk dan tidak terdefinisi dengan baik, sekarang saatnya untuk mencari tahu di mana harus mulai membangun model analitik kami.  Mari kita mulai dengan yang sederhana - kita mendefinisikan interaksi dengan tetangga terdekat dan dengan tetangga tetangga (teman teman). </p><br><p>  Dengan demikian, dimungkinkan untuk menentukan interaksi dengan semua simpul yang saling berhubungan.  Menurut pengamatan kami, interaksi dengan tetangga yang lebih dalam dari level 2 hanya menarik dalam kasus-kasus khusus dan dihitung dengan metode lain.  Kompleksitas perhitungan ini cukup besar 0 (2 ^ n). </p><br><p>  Untuk menghitung bola, kami akan menggunakan algoritma pencarian kedalaman yang sedikit dimodifikasi. </p><br><p>  Penyempurnaan akan sebagai berikut: </p><br><ol><li>  Kita perlu menemukan bukan simpul tertentu, tetapi mengurutkan semua simpul ke kedalaman n, untuk tugas kita n = 2. </li><li>  Kita tidak boleh menyimpan informasi yang tidak perlu dan harus mengasumsikan bahwa perhitungan dapat dibuat untuk setiap simpul dalam grafik, sehingga tingkat simpul tidak akan disimpan dalam grafik. </li><li>  Jika 2 atau lebih jalur mengarah ke atas, maka semua jalur dievaluasi, karena  kita berhadapan dengan komunikasi dua arah dan perlu untuk sepenuhnya mengevaluasi interaksi node. </li><li>  Anda harus dapat menentukan tingkat bersarang dari setiap titik untuk perhitungan tertentu. </li></ol><br><p>  Yah, baik, perhitungan teoretis dasar telah dibuat, bahkan jika mereka menganggap seseorang sesuatu yang sederhana dan dangkal.  Tetapi bagi kami Gascons, ini semua penting dan menarik, hampir sama dengan memasuki Royal Musketeers. </p><br><p>  Kami memberikan implementasi praktis.  Satu untuk semua dan semua untuk satu! </p><br><p>  Aku akan menemuimu!  Kami pasti akan bertemu!  Mungkin dalam 10 tahun atau 20!  Tapi ketemu! </p><br><p>  Artikel selanjutnya sudah dekat! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464833/">https://habr.com/ru/post/id464833/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464811/index.html">Apple Music untuk pengembang</a></li>
<li><a href="../id464813/index.html">Mengganti Punto Switcher, tata letak Birman dengan skrip autohotkey</a></li>
<li><a href="../id464819/index.html">Hari keenam saya dengan Haiku: di bawah tenda sumber daya, ikon dan paket</a></li>
<li><a href="../id464823/index.html">Kami mempertimbangkan gaji rata-rata seorang "ahli data data." Parsim hh.ru menggunakan panda / python</a></li>
<li><a href="../id464831/index.html">Tambahkan fungsionalitas Razor Pages ke .NET standar</a></li>
<li><a href="../id464837/index.html">Dari Gangga ke Volga: bagaimana cara menyelamatkan sungai dari polusi?</a></li>
<li><a href="../id464839/index.html">Tentang satu paten Tesla Motors</a></li>
<li><a href="../id464841/index.html">Habr Weekly # 15 / Tentang kekuatan cerita yang bagus (dan sedikit tentang ayam goreng)</a></li>
<li><a href="../id464843/index.html">Menyenangkan dengan pengembangan atau manfaat untuk ASIO di C ++</a></li>
<li><a href="../id464847/index.html">Proyek Pelatihan di Godot - Pong (Bagian 1) Membuat dan menyesuaikan adegan permainan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>