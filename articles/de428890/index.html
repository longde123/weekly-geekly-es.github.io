<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏾 👨‍🔬 🌲 Die ganze Wahrheit über RTOS. Artikel Nr. 18. Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen 🗻 🤷 ✋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden weiterhin Ereignisflaggruppen beschrieben. 

 Frühere Artikel in der Reihe: 

 Artikel Nr. 17. Ereignisflag-Gruppen: Einführu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel Nr. 18. Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428890/"><img src="https://habrastorage.org/webt/uv/-u/8d/uv-u8dltglarzrr6lq6czxprtnk.jpeg"><br><br>  In diesem Artikel werden weiterhin Ereignisflaggruppen beschrieben. <br><br>  Frühere Artikel in der Reihe: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><a name="habracut"></a><br><h2>  Event Flag Group Helper Services </h2><br>  Nucleus RTOS verfügt über drei API-Aufrufe, die Hilfsfunktionen für Ereignisflaggruppen bereitstellen: Abrufen von Gruppeninformationen, Abrufen von Informationen zur Anzahl der Ereignisflaggruppen in einer Anwendung und Abrufen von Zeigern auf alle Ereignisflaggruppen.  Die ersten beiden Herausforderungen werden in Nucleus SE implementiert. <br><br><h3>  Abrufen von Ereignisflag-Gruppeninformationen </h3><br>  Dieser Dienstprogrammaufruf gibt Informationen über die Gruppe von Ereignisflags zurück.  Die Implementierung dieses Aufrufs in Nucleus SE unterscheidet sich von der Implementierung in Nucleus RTOS darin, dass weniger Informationen zurückgegeben werden, da die Objektbenennung und die Reihenfolge der Aufgabenpause nicht unterstützt werden und die Aufgabenpause selbst deaktiviert werden kann. <br><br>  <b><i>Ein Aufruf zum Abrufen von Ereignisgruppeninformationen in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Event_Group_Information (NU_EVENT_GROUP * Gruppe, CHAR * Name, UNSIGNED * Ereignisflags, UNSIGNED * Aufgaben_Warten, NU_TASK ** first_task);</b> <br><br>  Parameter: <br>  <b>group</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock für eine Gruppe von Ereignisflags; <br>  <b>name</b> - ein Zeiger auf den 8-stelligen Bereich für den Namen der Gruppe von Ereignisflags, einschließlich der abschließenden Null; <br>  <b>event_flags</b> - Zeiger auf eine Variable, die den aktuellen Wert der angegebenen Gruppe von Ereignisflags annimmt. <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable, die die Anzahl der angehaltenen Aufgaben in dieser Gruppe von Ereignisflags übernimmt; <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NU_TASK</b> , der einen Zeiger auf die erste angehaltene Task nimmt. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_GROUP</b> - ungültiger Zeiger auf eine Gruppe von Ereignisflags. <br><br>  <b><i>Ein Aufruf zum Abrufen von Ereignisgruppeninformationen in Nucleus SE</i></b> <br>  Dieser Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Event_Group_Information (Gruppe NUSE_EVENT_GROUP, U8 * Ereignisflags, U8 * Aufgaben_Warten, NUSE_TASK * Erste_Aufgabe);</b> <br><br>  Parameter: <br>  <b>Gruppe</b> - Der Index der Gruppe von Ereignisflags, über die Informationen angefordert werden. <br>  <b>event_flags</b> - Zeiger auf eine Variable, die den aktuellen Wert der angegebenen Gruppe von Ereignisflags annimmt. <br>  <b>task_waiting</b> - Ein Zeiger auf eine Variable, die die Anzahl der angehaltenen Aufgaben in dieser Gruppe von Ereignisflags übernimmt (wenn die Aufgabe angehalten wird, wird nichts zurückgegeben). <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NUSE_TASK</b> , die den Index der ersten angehaltenen Aufgabe übernimmt (nichts wird zurückgegeben, wenn die Unterbrechung von Aufgaben deaktiviert ist). <br><br>  Rückgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_GROUP</b> - Ungültiger Ereignisflag-Gruppenindex. <br><br>  <b><i>Implementierung von Ereignisgruppeninformationen in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist ziemlich einfach: <br><br><pre><code class="hljs pgsql">*event_flags = NUSE_Event_Group_Data[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { U8 <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>&lt;NUSE_TASK_NUMBER; <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((LONIB(NUSE_Task_Status[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]) == NUSE_EVENT_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]) == <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { *first_task = <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; break; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *first_task = <span class="hljs-number"><span class="hljs-number">0</span></span>; } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> *tasks_waiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; *first_task = <span class="hljs-number"><span class="hljs-number">0</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS;</code> </pre> <br>  Die Funktion gibt den Wert der Gruppe von Ereignisflags zurück.  Wenn dann API-Aufrufe zum Blockieren von Aufgaben aktiviert werden, werden die Anzahl der ausstehenden Aufgaben und der Index der ersten zurückgegeben (andernfalls werden diese beiden Parameter auf Null gesetzt). <br><br><h3>  Abrufen der Anzahl der Ereignisflag-Gruppen </h3><br>  Dieser Dienstprogrammaufruf gibt die Anzahl der Ereignisflaggruppen in der Anwendung zurück.  In Nucleus RTOS ändert sich dieser Wert im Laufe der Zeit, und der Rückgabewert zeigt die aktuelle Anzahl von Gruppen an, während in Nucleus SE dieser Wert während des Zusammenbaus bestimmt wird und sich nicht mit der Zeit ändert. <br><br>  <b><i>Aufrufen des Zählers von Ereignisflag-Gruppen in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Establised_Event_Groups (VOID);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  Rückgabewert: <br>  Die aktuelle Anzahl der erstellten Ereignisflaggruppen. <br><br>  <b><i>Aufrufen des Zählers der Ereignisflag-Gruppen in Nucleus SE</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Event_Group_Count (void);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  Rückgabewert: <br>  Die Anzahl der konfigurierten Ereignisflaggruppen. <br><br>  <b><i>Implementieren eines Ereignisflag-Gruppenzählers in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist ziemlich trivial: Der Wert des Symbols <b>#define</b> <b>NUSE_EVENT_GROUP_NUMBER</b> wird <b>zurückgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Wie alle anderen Nucleus SE-Objekte verwenden Ereignisflaggruppen ein oder zwei Arrays von Datenstrukturen (beide befinden sich im RAM). Die Größe der Arrays hängt von der Anzahl der in den Einstellungen definierten Gruppen ab. <br><br>  Ich empfehle dringend, dass der Anwendungscode keinen direkten Zugriff auf diese Datenstrukturen verwendet, sondern über die bereitgestellten API-Funktionen auf sie verweist.  Dies vermeidet Inkompatibilität mit zukünftigen Versionen von Nucleus SE und unerwünschte Nebenwirkungen und vereinfacht die Portierung der Anwendung auf Nucleus RTOS.  Zum besseren Verständnis des Serviceabrufcodes und des Debuggens wird im Folgenden eine detaillierte Übersicht über die Datenstrukturen bereitgestellt. <br><br><h3>  RAM-Daten </h3><br>  Diese Daten haben folgende Struktur: <br>  <b>NUSE_Event_Group_Data []</b> - ein Array von Daten vom Typ <b>U8</b> mit einem Datensatz für jede konfigurierte Gruppe von Flags;  Es speichert Ereignisflag-Daten. <br>  <b>NUSE_Event_Group_Blocking_Count []</b> - Ein Array vom Typ <b>U8,</b> das einen Zähler für blockierte Aufgaben in jeder Gruppe von Ereignisflags enthält.  Dieses Array ist nur vorhanden, wenn die Sperrfunktion in der API aktiviert ist. <br><br>  Diese Datenstrukturen werden beim <b>Start von</b> Nucleus SE in der Funktion <b>NUSE_Init_Event_Group ()</b> mit Nullen initialisiert.  Einer der folgenden Artikel enthält eine vollständige Beschreibung der Startvorgänge von Nucleus SE. <br><br>  Im Folgenden werden diese Datenstrukturen in der Datei <b>nuse_init.c beschrieben</b> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">RAM</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">U8</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">NUSE_Event_Group_Data</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[NUSE_EVENT_GROUP_NUMBER]</span></span>; <span class="hljs-selector-id"><span class="hljs-selector-id">#if</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">NUSE_BLOCKING_ENABLE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">RAM</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">U8</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">NUSE_Event_Group_Blocking_Count</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[NUSE_EVENT_GROUP_NUMBER]</span></span>; <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span></code> </pre><br><h3>  ROM-Daten </h3><br>  Zum Implementieren von Gruppen von Ereignisflags werden keine Daten im ROM verwendet. <br><br><h3>  Speichergröße für Ereignisflaggruppen </h3><br>  Wie bei allen Nucleus SE-Kernelobjekten ist die für Ereignisflaggruppen erforderliche Speichermenge vorhersehbar. <br><br>  Die Datenmenge im ROM für alle Gruppen von Ereignisflags in der Anwendung beträgt 0. <br><br>  Die Speicherkapazität im RAM für alle Gruppen von Ereignisflags mit aktivierter API- <b>Sperrfunktion</b> beträgt <b>NUSE_EVENT_GROUP_NUMBER * 2</b> . <br><br>  Andernfalls ist es <b>NUSE_EVENT_GROUP_NUMBER</b> . <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Drei API-Aufrufe für Ereignisflaggruppen, die in Nucleus RTOS zu finden sind, wurden in Nucleus SE nicht implementiert. <br><br><h3>  Erstellen einer Ereignisflag-Gruppe </h3><br>  Dieser API-Aufruf erstellt eine Gruppe von Ereignisflags.  Nucleus SE benötigt diesen Aufruf nicht, da Ereignisflaggruppen statisch erstellt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Create_Event_Group (NU_EVENT_GROUP * Gruppe, CHAR * Name);</b> <br><br>  Parameter: <br><br>  <b>group</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock für eine Gruppe von Ereignisflags;  Wird als Deskriptor zum Verwalten von Gruppen von Ereignisflags in anderen API-Aufrufen verwendet <br>  <b>name</b> - Ein Zeiger auf den 8-stelligen Namen der Gruppe von Ereignisflags mit einem abschließenden Nullbyte in diesem Bereich. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_GROUP</b> - Nullzeiger auf die Steuereinheit der Ereignisflaggruppe ( <b>NULL</b> ) oder bereits verwendet. <br><br><h3>  Löschen einer Gruppe von Ereignisflags </h3><br>  Dieser API-Aufruf entfernt die zuvor erstellte Ereignisflaggruppe.  Nucleus SE benötigt diesen Aufruf nicht, da Ereignisflaggruppen statisch erstellt werden und nicht gelöscht werden können. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Delete_Event_Group (Gruppe NU_EVENT_GROUP *);</b> <br><br>  Parameter: <br><br>  <b>group</b> - Ein Zeiger auf den Steuerblock der Gruppe von Ereignisflags. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_GROUP</b> - ungültiger Zeiger auf eine Gruppe von Ereignisflags. <br><br><h3>  Ereignisflaggengruppenzeiger </h3><br>  Dieser API-Aufruf erstellt eine sequentielle Liste von Zeigern auf alle Gruppen von Ereignisflags im System.  Nucleus SE benötigt diesen Aufruf nicht, da Ereignisflaggruppen einfache Indizes und keine Zeiger haben. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>UNSIGNED NU_Event_Group_Pointers (NU_EVENT_GROUP * pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Parameter: <br><br>  <b>pointer_list</b> - ein Zeiger auf ein Array von Zeigern <b>NU_EVENT_GROUP</b> . Dieses Array ist mit Zeigern auf Gruppen von Ereignisflags gefüllt, die im System erstellt wurden. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern im Array. <br><br>  Rückgabewert: <br><br>  Die Anzahl der <b>NU_EVENT_GROUP-</b> Zeiger im Array. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Bei der Entwicklung von Nucleus SE war es mein Ziel, ein Höchstmaß an Codekompatibilität mit Nucleus RTOS sicherzustellen.  Gruppen von Ereignisflags waren keine Ausnahme und werden aus Sicht des Entwicklers fast genauso implementiert wie in Nucleus RTOS.  Es gibt einige Inkompatibilitäten, die ich für gültig gehalten habe, da der endgültige Code in Bezug auf die erforderliche Speichermenge verständlicher und effizienter wird.  Andernfalls können Nucleus RTOS-API-Aufrufe fast direkt als Nucleus SE-Aufrufe verwendet werden. <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch Datenstrukturen (Steuereinheiten) eines bestimmten Typs beschrieben.  Ein Zeiger auf diese Steuereinheit ist eine Kennung für eine Gruppe von Ereignisflags.  Ich entschied, dass in Nucleus SE ein anderer Ansatz für eine effiziente Speichernutzung erforderlich ist: Alle Kernelobjekte werden durch mehrere Tabellen im RAM und / oder ROM beschrieben.  Die Größe dieser Tabellen wird durch die Anzahl der konfigurierten Objekte jedes Typs bestimmt.  Die Kennung eines bestimmten Objekts ist der Index in dieser Tabelle.  Daher habe ich <b>NUSE_EVENT_GROUP</b> als Äquivalent zu <b>U8 definiert</b> . Eine Variable dieses Typs (kein Zeiger) dient als Kennung für eine Gruppe von Ereignisflags.  Diese leichte Inkompatibilität ist leicht zu handhaben, wenn der Code von Nucleus SE nach Nucleus RTOS und umgekehrt portiert wird.  In der Regel werden keine anderen Operationen an Objektkennungen als Verschieben und Speichern ausgeführt. <br><br>  Nucleus RTOS unterstützt auch das Benennen von Ereignisflaggruppen.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Die Anzahl der Flags in der Gruppe </h3><br>  In Nucleus RTOS enthalten Ereignisflag-Gruppen jeweils 32 Flags, in Nucleus SE habe ich ihre Anzahl auf acht reduziert, da dies für einfache Anwendungen ausreicht und RAM spart.  Nucleus SE kann leicht geändert werden, wenn größere Gruppen von Ereignisflags erforderlich sind. <br><br><h3>  Flag Absorptionsfunktion </h3><br>  Nucleus RTOS hat die Funktion, Ereignisflags nach dem Lesen zu löschen (zu absorbieren).  Ich habe beschlossen, diese Funktion aus Nucleus SE auszuschließen, um das System zu vereinfachen, da das Absorbieren (Entfernen) von Flags erfolgt, wenn alle blockierten Aufgaben Flags zum Lesen erhalten haben, und dies schwierig zu implementieren wäre.  Bei Bedarf kann eine Flag-Leseaufgabe diese jederzeit mithilfe eines separaten API-Aufrufs löschen. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterstützt sieben Dienstprogrammaufrufe für die Arbeit mit Ereignisflaggruppen.  Von diesen sind drei in Nucleus SE nicht implementiert.  Die Details dieser Herausforderungen sowie die Entscheidung, sie von Nucleus SE auszuschließen, wurden oben beschrieben. <br>  Der nächste Artikel befasst sich mit Semaphoren. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428890/">https://habr.com/ru/post/de428890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428876/index.html">Es gibt kein Zurück: die persönliche Erfahrung des Testers</a></li>
<li><a href="../de428878/index.html">Schweineflug oder Optimierung von Bytecode-Interpreten</a></li>
<li><a href="../de428880/index.html">Neue Authentifizierungsmethoden - eine Bedrohung für die Privatsphäre?</a></li>
<li><a href="../de428882/index.html">Mobile Yandex. Blitz: Wir analysieren Aufgaben</a></li>
<li><a href="../de428888/index.html">qml: Kraft und Einfachheit</a></li>
<li><a href="../de428892/index.html">So erstellen Sie eine Spiel-KI: eine Anleitung für Anfänger</a></li>
<li><a href="../de428894/index.html">Mehrwertsteuer auf inländische Einkäufe</a></li>
<li><a href="../de428896/index.html">Neuronale Netze der Hentai-Zensur</a></li>
<li><a href="../de428898/index.html">Problematische Aspekte der Programmierung in C ++</a></li>
<li><a href="../de428900/index.html">Radroboter liefern Waren an Einwohner der USA und Großbritanniens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>