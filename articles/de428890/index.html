<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèæ üë®‚Äçüî¨ üå≤ Die ganze Wahrheit √ºber RTOS. Artikel Nr. 18. Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen üóª ü§∑ ‚úãüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden weiterhin Ereignisflaggruppen beschrieben. 

 Fr√ºhere Artikel in der Reihe: 

 Artikel Nr. 17. Ereignisflag-Gruppen: Einf√ºhru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel Nr. 18. Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428890/"><img src="https://habrastorage.org/webt/uv/-u/8d/uv-u8dltglarzrr6lq6czxprtnk.jpeg"><br><br>  In diesem Artikel werden weiterhin Ereignisflaggruppen beschrieben. <br><br>  Fr√ºhere Artikel in der Reihe: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><a name="habracut"></a><br><h2>  Event Flag Group Helper Services </h2><br>  Nucleus RTOS verf√ºgt √ºber drei API-Aufrufe, die Hilfsfunktionen f√ºr Ereignisflaggruppen bereitstellen: Abrufen von Gruppeninformationen, Abrufen von Informationen zur Anzahl der Ereignisflaggruppen in einer Anwendung und Abrufen von Zeigern auf alle Ereignisflaggruppen.  Die ersten beiden Herausforderungen werden in Nucleus SE implementiert. <br><br><h3>  Abrufen von Ereignisflag-Gruppeninformationen </h3><br>  Dieser Dienstprogrammaufruf gibt Informationen √ºber die Gruppe von Ereignisflags zur√ºck.  Die Implementierung dieses Aufrufs in Nucleus SE unterscheidet sich von der Implementierung in Nucleus RTOS darin, dass weniger Informationen zur√ºckgegeben werden, da die Objektbenennung und die Reihenfolge der Aufgabenpause nicht unterst√ºtzt werden und die Aufgabenpause selbst deaktiviert werden kann. <br><br>  <b><i>Ein Aufruf zum Abrufen von Ereignisgruppeninformationen in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Event_Group_Information (NU_EVENT_GROUP * Gruppe, CHAR * Name, UNSIGNED * Ereignisflags, UNSIGNED * Aufgaben_Warten, NU_TASK ** first_task);</b> <br><br>  Parameter: <br>  <b>group</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock f√ºr eine Gruppe von Ereignisflags; <br>  <b>name</b> - ein Zeiger auf den 8-stelligen Bereich f√ºr den Namen der Gruppe von Ereignisflags, einschlie√ülich der abschlie√üenden Null; <br>  <b>event_flags</b> - Zeiger auf eine Variable, die den aktuellen Wert der angegebenen Gruppe von Ereignisflags annimmt. <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable, die die Anzahl der angehaltenen Aufgaben in dieser Gruppe von Ereignisflags √ºbernimmt; <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NU_TASK</b> , der einen Zeiger auf die erste angehaltene Task nimmt. <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_GROUP</b> - ung√ºltiger Zeiger auf eine Gruppe von Ereignisflags. <br><br>  <b><i>Ein Aufruf zum Abrufen von Ereignisgruppeninformationen in Nucleus SE</i></b> <br>  Dieser Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NUSE_Event_Group_Information (Gruppe NUSE_EVENT_GROUP, U8 * Ereignisflags, U8 * Aufgaben_Warten, NUSE_TASK * Erste_Aufgabe);</b> <br><br>  Parameter: <br>  <b>Gruppe</b> - Der Index der Gruppe von Ereignisflags, √ºber die Informationen angefordert werden. <br>  <b>event_flags</b> - Zeiger auf eine Variable, die den aktuellen Wert der angegebenen Gruppe von Ereignisflags annimmt. <br>  <b>task_waiting</b> - Ein Zeiger auf eine Variable, die die Anzahl der angehaltenen Aufgaben in dieser Gruppe von Ereignisflags √ºbernimmt (wenn die Aufgabe angehalten wird, wird nichts zur√ºckgegeben). <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NUSE_TASK</b> , die den Index der ersten angehaltenen Aufgabe √ºbernimmt (nichts wird zur√ºckgegeben, wenn die Unterbrechung von Aufgaben deaktiviert ist). <br><br>  R√ºckgabewert: <br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_GROUP</b> - Ung√ºltiger Ereignisflag-Gruppenindex. <br><br>  <b><i>Implementierung von Ereignisgruppeninformationen in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist ziemlich einfach: <br><br><pre><code class="hljs pgsql">*event_flags = NUSE_Event_Group_Data[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { U8 <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>&lt;NUSE_TASK_NUMBER; <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((LONIB(NUSE_Task_Status[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]) == NUSE_EVENT_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]) == <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { *first_task = <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; break; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *first_task = <span class="hljs-number"><span class="hljs-number">0</span></span>; } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> *tasks_waiting = <span class="hljs-number"><span class="hljs-number">0</span></span>; *first_task = <span class="hljs-number"><span class="hljs-number">0</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS;</code> </pre> <br>  Die Funktion gibt den Wert der Gruppe von Ereignisflags zur√ºck.  Wenn dann API-Aufrufe zum Blockieren von Aufgaben aktiviert werden, werden die Anzahl der ausstehenden Aufgaben und der Index der ersten zur√ºckgegeben (andernfalls werden diese beiden Parameter auf Null gesetzt). <br><br><h3>  Abrufen der Anzahl der Ereignisflag-Gruppen </h3><br>  Dieser Dienstprogrammaufruf gibt die Anzahl der Ereignisflaggruppen in der Anwendung zur√ºck.  In Nucleus RTOS √§ndert sich dieser Wert im Laufe der Zeit, und der R√ºckgabewert zeigt die aktuelle Anzahl von Gruppen an, w√§hrend in Nucleus SE dieser Wert w√§hrend des Zusammenbaus bestimmt wird und sich nicht mit der Zeit √§ndert. <br><br>  <b><i>Aufrufen des Z√§hlers von Ereignisflag-Gruppen in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Establised_Event_Groups (VOID);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  R√ºckgabewert: <br>  Die aktuelle Anzahl der erstellten Ereignisflaggruppen. <br><br>  <b><i>Aufrufen des Z√§hlers der Ereignisflag-Gruppen in Nucleus SE</i></b> <br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Event_Group_Count (void);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  R√ºckgabewert: <br>  Die Anzahl der konfigurierten Ereignisflaggruppen. <br><br>  <b><i>Implementieren eines Ereignisflag-Gruppenz√§hlers in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist ziemlich trivial: Der Wert des Symbols <b>#define</b> <b>NUSE_EVENT_GROUP_NUMBER</b> wird <b>zur√ºckgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Wie alle anderen Nucleus SE-Objekte verwenden Ereignisflaggruppen ein oder zwei Arrays von Datenstrukturen (beide befinden sich im RAM). Die Gr√∂√üe der Arrays h√§ngt von der Anzahl der in den Einstellungen definierten Gruppen ab. <br><br>  Ich empfehle dringend, dass der Anwendungscode keinen direkten Zugriff auf diese Datenstrukturen verwendet, sondern √ºber die bereitgestellten API-Funktionen auf sie verweist.  Dies vermeidet Inkompatibilit√§t mit zuk√ºnftigen Versionen von Nucleus SE und unerw√ºnschte Nebenwirkungen und vereinfacht die Portierung der Anwendung auf Nucleus RTOS.  Zum besseren Verst√§ndnis des Serviceabrufcodes und des Debuggens wird im Folgenden eine detaillierte √úbersicht √ºber die Datenstrukturen bereitgestellt. <br><br><h3>  RAM-Daten </h3><br>  Diese Daten haben folgende Struktur: <br>  <b>NUSE_Event_Group_Data []</b> - ein Array von Daten vom Typ <b>U8</b> mit einem Datensatz f√ºr jede konfigurierte Gruppe von Flags;  Es speichert Ereignisflag-Daten. <br>  <b>NUSE_Event_Group_Blocking_Count []</b> - Ein Array vom Typ <b>U8,</b> das einen Z√§hler f√ºr blockierte Aufgaben in jeder Gruppe von Ereignisflags enth√§lt.  Dieses Array ist nur vorhanden, wenn die Sperrfunktion in der API aktiviert ist. <br><br>  Diese Datenstrukturen werden beim <b>Start von</b> Nucleus SE in der Funktion <b>NUSE_Init_Event_Group ()</b> mit Nullen initialisiert.  Einer der folgenden Artikel enth√§lt eine vollst√§ndige Beschreibung der Startvorg√§nge von Nucleus SE. <br><br>  Im Folgenden werden diese Datenstrukturen in der Datei <b>nuse_init.c beschrieben</b> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">RAM</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">U8</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">NUSE_Event_Group_Data</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[NUSE_EVENT_GROUP_NUMBER]</span></span>; <span class="hljs-selector-id"><span class="hljs-selector-id">#if</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">NUSE_BLOCKING_ENABLE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">RAM</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">U8</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">NUSE_Event_Group_Blocking_Count</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[NUSE_EVENT_GROUP_NUMBER]</span></span>; <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span></code> </pre><br><h3>  ROM-Daten </h3><br>  Zum Implementieren von Gruppen von Ereignisflags werden keine Daten im ROM verwendet. <br><br><h3>  Speichergr√∂√üe f√ºr Ereignisflaggruppen </h3><br>  Wie bei allen Nucleus SE-Kernelobjekten ist die f√ºr Ereignisflaggruppen erforderliche Speichermenge vorhersehbar. <br><br>  Die Datenmenge im ROM f√ºr alle Gruppen von Ereignisflags in der Anwendung betr√§gt 0. <br><br>  Die Speicherkapazit√§t im RAM f√ºr alle Gruppen von Ereignisflags mit aktivierter API- <b>Sperrfunktion</b> betr√§gt <b>NUSE_EVENT_GROUP_NUMBER * 2</b> . <br><br>  Andernfalls ist es <b>NUSE_EVENT_GROUP_NUMBER</b> . <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Drei API-Aufrufe f√ºr Ereignisflaggruppen, die in Nucleus RTOS zu finden sind, wurden in Nucleus SE nicht implementiert. <br><br><h3>  Erstellen einer Ereignisflag-Gruppe </h3><br>  Dieser API-Aufruf erstellt eine Gruppe von Ereignisflags.  Nucleus SE ben√∂tigt diesen Aufruf nicht, da Ereignisflaggruppen statisch erstellt werden. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Create_Event_Group (NU_EVENT_GROUP * Gruppe, CHAR * Name);</b> <br><br>  Parameter: <br><br>  <b>group</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock f√ºr eine Gruppe von Ereignisflags;  Wird als Deskriptor zum Verwalten von Gruppen von Ereignisflags in anderen API-Aufrufen verwendet <br>  <b>name</b> - Ein Zeiger auf den 8-stelligen Namen der Gruppe von Ereignisflags mit einem abschlie√üenden Nullbyte in diesem Bereich. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_GROUP</b> - Nullzeiger auf die Steuereinheit der Ereignisflaggruppe ( <b>NULL</b> ) oder bereits verwendet. <br><br><h3>  L√∂schen einer Gruppe von Ereignisflags </h3><br>  Dieser API-Aufruf entfernt die zuvor erstellte Ereignisflaggruppe.  Nucleus SE ben√∂tigt diesen Aufruf nicht, da Ereignisflaggruppen statisch erstellt werden und nicht gel√∂scht werden k√∂nnen. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Delete_Event_Group (Gruppe NU_EVENT_GROUP *);</b> <br><br>  Parameter: <br><br>  <b>group</b> - Ein Zeiger auf den Steuerblock der Gruppe von Ereignisflags. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_GROUP</b> - ung√ºltiger Zeiger auf eine Gruppe von Ereignisflags. <br><br><h3>  Ereignisflaggengruppenzeiger </h3><br>  Dieser API-Aufruf erstellt eine sequentielle Liste von Zeigern auf alle Gruppen von Ereignisflags im System.  Nucleus SE ben√∂tigt diesen Aufruf nicht, da Ereignisflaggruppen einfache Indizes und keine Zeiger haben. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>UNSIGNED NU_Event_Group_Pointers (NU_EVENT_GROUP * pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Parameter: <br><br>  <b>pointer_list</b> - ein Zeiger auf ein Array von Zeigern <b>NU_EVENT_GROUP</b> . Dieses Array ist mit Zeigern auf Gruppen von Ereignisflags gef√ºllt, die im System erstellt wurden. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von Zeigern im Array. <br><br>  R√ºckgabewert: <br><br>  Die Anzahl der <b>NU_EVENT_GROUP-</b> Zeiger im Array. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Bei der Entwicklung von Nucleus SE war es mein Ziel, ein H√∂chstma√ü an Codekompatibilit√§t mit Nucleus RTOS sicherzustellen.  Gruppen von Ereignisflags waren keine Ausnahme und werden aus Sicht des Entwicklers fast genauso implementiert wie in Nucleus RTOS.  Es gibt einige Inkompatibilit√§ten, die ich f√ºr g√ºltig gehalten habe, da der endg√ºltige Code in Bezug auf die erforderliche Speichermenge verst√§ndlicher und effizienter wird.  Andernfalls k√∂nnen Nucleus RTOS-API-Aufrufe fast direkt als Nucleus SE-Aufrufe verwendet werden. <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch Datenstrukturen (Steuereinheiten) eines bestimmten Typs beschrieben.  Ein Zeiger auf diese Steuereinheit ist eine Kennung f√ºr eine Gruppe von Ereignisflags.  Ich entschied, dass in Nucleus SE ein anderer Ansatz f√ºr eine effiziente Speichernutzung erforderlich ist: Alle Kernelobjekte werden durch mehrere Tabellen im RAM und / oder ROM beschrieben.  Die Gr√∂√üe dieser Tabellen wird durch die Anzahl der konfigurierten Objekte jedes Typs bestimmt.  Die Kennung eines bestimmten Objekts ist der Index in dieser Tabelle.  Daher habe ich <b>NUSE_EVENT_GROUP</b> als √Ñquivalent zu <b>U8 definiert</b> . Eine Variable dieses Typs (kein Zeiger) dient als Kennung f√ºr eine Gruppe von Ereignisflags.  Diese leichte Inkompatibilit√§t ist leicht zu handhaben, wenn der Code von Nucleus SE nach Nucleus RTOS und umgekehrt portiert wird.  In der Regel werden keine anderen Operationen an Objektkennungen als Verschieben und Speichern ausgef√ºhrt. <br><br>  Nucleus RTOS unterst√ºtzt auch das Benennen von Ereignisflaggruppen.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Die Anzahl der Flags in der Gruppe </h3><br>  In Nucleus RTOS enthalten Ereignisflag-Gruppen jeweils 32 Flags, in Nucleus SE habe ich ihre Anzahl auf acht reduziert, da dies f√ºr einfache Anwendungen ausreicht und RAM spart.  Nucleus SE kann leicht ge√§ndert werden, wenn gr√∂√üere Gruppen von Ereignisflags erforderlich sind. <br><br><h3>  Flag Absorptionsfunktion </h3><br>  Nucleus RTOS hat die Funktion, Ereignisflags nach dem Lesen zu l√∂schen (zu absorbieren).  Ich habe beschlossen, diese Funktion aus Nucleus SE auszuschlie√üen, um das System zu vereinfachen, da das Absorbieren (Entfernen) von Flags erfolgt, wenn alle blockierten Aufgaben Flags zum Lesen erhalten haben, und dies schwierig zu implementieren w√§re.  Bei Bedarf kann eine Flag-Leseaufgabe diese jederzeit mithilfe eines separaten API-Aufrufs l√∂schen. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterst√ºtzt sieben Dienstprogrammaufrufe f√ºr die Arbeit mit Ereignisflaggruppen.  Von diesen sind drei in Nucleus SE nicht implementiert.  Die Details dieser Herausforderungen sowie die Entscheidung, sie von Nucleus SE auszuschlie√üen, wurden oben beschrieben. <br>  Der n√§chste Artikel befasst sich mit Semaphoren. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428890/">https://habr.com/ru/post/de428890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428876/index.html">Es gibt kein Zur√ºck: die pers√∂nliche Erfahrung des Testers</a></li>
<li><a href="../de428878/index.html">Schweineflug oder Optimierung von Bytecode-Interpreten</a></li>
<li><a href="../de428880/index.html">Neue Authentifizierungsmethoden - eine Bedrohung f√ºr die Privatsph√§re?</a></li>
<li><a href="../de428882/index.html">Mobile Yandex. Blitz: Wir analysieren Aufgaben</a></li>
<li><a href="../de428888/index.html">qml: Kraft und Einfachheit</a></li>
<li><a href="../de428892/index.html">So erstellen Sie eine Spiel-KI: eine Anleitung f√ºr Anf√§nger</a></li>
<li><a href="../de428894/index.html">Mehrwertsteuer auf inl√§ndische Eink√§ufe</a></li>
<li><a href="../de428896/index.html">Neuronale Netze der Hentai-Zensur</a></li>
<li><a href="../de428898/index.html">Problematische Aspekte der Programmierung in C ++</a></li>
<li><a href="../de428900/index.html">Radroboter liefern Waren an Einwohner der USA und Gro√übritanniens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>