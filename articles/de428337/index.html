<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏼 🍉 🐘 Unterhaltsames JavaScript: Ohne geschweifte Klammern 🌇 🌌 👨🏾‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript hat mich vor allem immer überrascht, weil es wahrscheinlich wie keine andere weit verbreitete Sprache beide Paradigmen gleichzeitig unterst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unterhaltsames JavaScript: Ohne geschweifte Klammern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428337/"><p><img src="https://habrastorage.org/webt/dl/n7/qy/dln7qyv9wb8ysot5ip5th9nxocu.png" alt="Bild"></p><br><p>  <strong>JavaScript hat</strong> mich vor allem immer überrascht, weil es wahrscheinlich wie keine andere weit verbreitete Sprache beide Paradigmen gleichzeitig unterstützt: normale und abnormale Programmierung.  Und wenn fast alles über angemessene Best Practices und Vorlagen gelesen wurde, bleibt die wunderbare Welt, wie Sie keinen Code schreiben sollten, aber können, nur leicht angelehnt. </p><br><p>  In diesem Artikel analysieren wir eine weitere erfundene Aufgabe, die den unentschuldbaren Missbrauch einer normalen Lösung erfordert. </p><a name="habracut"></a><br><p>  Vorherige Aufgabe: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der kürzeste Memoizer</a> </li></ul><br><h2 id="formulirovka">  Formulierung </h2><br><blockquote> Implementieren Sie eine Dekorationsfunktion, die die Anzahl der Aufrufe der übergebenen Funktion zählt und die Möglichkeit bietet, diese Nummer bei Bedarf abzurufen.  Die Lösung verwendet <strong>keine</strong> geschweiften Klammern und globalen Variablen. </blockquote><p>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anrufzähler</a> ist nur eine Ausrede, denn es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">console.count ()</a> .  Unter dem Strich sammelt unsere Funktion beim Aufrufen einer umschlossenen Funktion einige Daten und bietet eine bestimmte Schnittstelle für den Zugriff darauf.  Dies kann die Aufbewahrung aller Ergebnisse des Aufrufs, das Sammeln von Protokollen und eine Art Memoisierung sein.  Nur ein Gegenmittel - primitiv und für alle verständlich. </p><br><p>  Alle Komplexität ist in einer abnormalen Einschränkung.  Sie können keine geschweiften Klammern verwenden, was bedeutet, dass Sie die alltäglichen Praktiken und die gewöhnliche Syntax überdenken müssen. </p><br><h2 id="privychnoe-reshenie">  Gewohnheitsmäßige Lösung </h2><br><p>  Zuerst müssen Sie einen Ausgangspunkt auswählen.  Wenn die Sprache oder ihre Erweiterung nicht die erforderliche Dekorationsfunktion bietet, implementieren wir normalerweise einen eigenen Container: eine umschlossene Funktion, akkumulierte Daten und eine Zugriffsschnittstelle auf diese.  Dies ist oft eine Klasse: </p><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CountFunction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = f; } invoke() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.calls += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f(...arguments); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csum = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountFunction(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x + y); csum.invoke(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 10 csum.invoke(9, 6); // 15 csum.calls; // 2</span></span></code> </pre> <br><p>  Dies passt nicht sofort zu uns, da: </p><br><ol><li>  In JavaScript können Sie eine private Eigenschaft nicht auf diese Weise implementieren: Wir können sowohl die <em>Aufrufe der</em> Instanz (die wir benötigen) lesen <em>als</em> auch den Wert von außen schreiben (was wir NICHT benötigen).  Natürlich können wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Closure im Konstruktor verwenden</a> , aber was bedeutet dann die Klasse?  Und ich hätte immer noch Angst, frische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Privatfelder</a> ohne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Babel 7 zu nutzen</a> . </li><li>  Die Sprache unterstützt ein funktionales Paradigma, und das Erstellen einer Instanz durch <em>neues</em> scheint hier nicht die beste Lösung zu sein.  Es ist schöner, eine Funktion zu schreiben, die eine andere Funktion zurückgibt.  Ja! </li><li>  Schließlich erlaubt uns die Syntax von <em>ClassDeclaration</em> und <em>MethodDefinition</em> nicht, alle geschweiften Klammern loszuwerden. </li></ol><br><p>  Aber wir haben ein wunderbares <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modulmuster</a> , das Datenschutz durch Schließen implementiert: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">invoke</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ calls += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(...arguments); }, <span class="hljs-attr"><span class="hljs-attr">getCalls</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> calls; } }; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csum = count(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x + y); csum.invoke(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 10 csum.invoke(9, 6); // 15 csum.getCalls(); // 2</span></span></code> </pre> <br><p>  Damit können Sie bereits arbeiten. </p><br><h2 id="zanimatelnoe-reshenie">  Unterhaltsame Entscheidung </h2><br><p>  Warum werden hier Zahnspangen verwendet?  Dies sind 4 verschiedene Fälle: </p><br><ol><li>  Definieren des Hauptteils einer Zählfunktion ( <em>FunctionDeclaration</em> ) </li><li>  Initialisierung des zurückgegebenen Objekts </li><li>  Die Definition des aufgerufenen Funktionskörpers ( <em>FunctionExpression</em> ) mit zwei Ausdrücken </li><li>  Definieren des Hauptteils einer <em>Funktion</em> getCalls ( <em>FunctionExpression</em> ) mit einem einzelnen Ausdruck </li></ol><br><p>  Beginnen wir mit dem <strong>zweiten</strong> Absatz.  Tatsächlich müssen wir kein neues Objekt zurückgeben, während der Aufruf der endgültigen Funktion durch <em>Aufrufen</em> erschwert wird.  Wir können die Tatsache ausnutzen, dass eine Funktion in JavaScript ein Objekt ist, was bedeutet, dass sie ihre eigenen Felder und Methoden enthalten kann.  Lassen Sie uns unsere return <em>df-</em> Funktion erstellen und die <em>getCalls-</em> Methode hinzufügen, die über den Abschluss wie zuvor auf <em>Aufrufe</em> zugreifen kann: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">df</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ calls += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(...arguments); } df.getCalls = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> calls; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; }</code> </pre> <br><p>  Es ist angenehmer, damit zu arbeiten: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csum = count(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x + y); csum(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 10 csum(9, 6); // 15 csum.getCalls(); // 2</span></span></code> </pre> <br><p>  Der <strong>vierte</strong> Punkt ist klar: Wir ersetzen nur <em>FunctionExpression</em> durch <em>ArrowFunction</em> .  Das Fehlen von geschweiften Klammern liefert uns eine kurze Aufzeichnung der Pfeilfunktion im Fall eines einzelnen Ausdrucks in seinem Körper: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">df</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ calls += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(...arguments); } df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; }</code> </pre> <br><p>  Mit dem <strong>dritten ist</strong> alles komplizierter.  Denken Sie daran, dass wir als erstes <em>FunctionExpression durch</em> <em>aufgerufene</em> Funktionen durch <em>FunctionDeclaration df ersetzt haben</em> .  Um dies in <em>ArrowFunction</em> umzuschreiben, <em>müssen</em> zwei Probleme gelöst werden: den Zugriff auf die Argumente nicht zu verlieren (jetzt ist es ein Pseudo-Array von <em>Argumenten</em> ) und den Funktionskörper zweier Ausdrücke zu vermeiden. </p><br><p>  Das erste Problem hilft uns, mit den explizit für den Funktionsparameter <em>args</em> mit dem <em>Spread-Operator</em> angegebenen Problemen <em>umzugehen</em> .  Um zwei Ausdrücke zu einem zu kombinieren, können Sie das <em>logische UND verwenden</em> .  Im Gegensatz zum klassischen logischen Konjunktionsoperator, der Boolean zurückgibt, berechnet er Operanden von links nach rechts bis zum ersten "false" und gibt sie zurück. Wenn alle "true" sind, dann der letzte Wert.  Das allererste Inkrement des Zählers ergibt 1, was bedeutet, dass dieser Unterausdruck immer auf true gesetzt wird.  Die Reduzierbarkeit des Ergebnisses des Funktionsaufrufs im zweiten Unterausdruck auf die „Wahrheit“ interessiert uns nicht: Auf jeden Fall bleibt der Rechner dabei stehen.  Jetzt können wir die <em>ArrowFunction verwenden</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> (calls += <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; f(...args); df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; }</code> </pre> <br><p>  Sie können einen Datensatz mit dem Präfix-Inkrement ein wenig dekorieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args); df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; }</code> </pre> <br><p>  Die Lösung für den <strong>ersten</strong> und schwierigsten Punkt beginnt mit dem Ersetzen von <em>FunctionDeclaration</em> durch <em>ArrowFunction</em> .  Aber wir haben den Körper immer noch in geschweiften Klammern: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> calls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args); df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; };</code> </pre> <br><p>  Wenn wir geschweifte Klammern entfernen möchten, die den Hauptteil der Funktion umrahmen, müssen wir vermeiden, Variablen durch <em>let</em> zu deklarieren und zu initialisieren.  Und wir haben zwei ganze Variablen: <em>Aufrufe</em> und <em>df</em> . </p><br><p>  Lassen Sie uns zuerst den Zähler behandeln.  Wir können eine lokale Variable erstellen, indem wir sie in der Liste der Funktionsparameter definieren und den Anfangswert übertragen, indem wir sie mit IIFE (Sofort aufgerufener Funktionsausdruck) aufrufen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">calls</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args); df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df; })(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Es bleibt, die drei Ausdrücke zu einem zu verketten.  Da wir alle drei Ausdrücke haben, die Funktionen darstellen, die immer auf wahr reduziert werden können, können wir auch das <em>logische UND verwenden</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">calls</span></span></span><span class="hljs-function"> =&gt;</span></span> (df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args)) &amp;&amp; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">df.getCalls = (</span></span></span><span class="hljs-function">) =&gt;</span></span> calls) &amp;&amp; df)(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Es gibt jedoch noch eine andere Option zum Verketten von Ausdrücken: Verwenden des <em>Kommaoperators</em> .  Dies ist vorzuziehen, da keine unnötigen logischen Transformationen behandelt werden und weniger Klammern erforderlich sind.  Die Operanden werden von links nach rechts ausgewertet, und das Ergebnis ist der Wert des letzteren: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">calls</span></span></span><span class="hljs-function"> =&gt;</span></span> (df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args), df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls, df))(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Ich glaube, ich habe es geschafft, dich zu täuschen?  Wir haben die Deklaration der Variablen <em>df</em> mutig losgeworden und nur die Zuweisung unserer <em>Pfeilfunktion</em> belassen.  In diesem Fall wird diese Variable global deklariert, was nicht akzeptabel ist!  Für <em>df</em> wiederholen wir die Initialisierung der lokalen Variablen in den Parametern unserer IIFE-Funktion, übergeben jedoch keinen Anfangswert: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">calls, df</span></span></span><span class="hljs-function">) =&gt;</span></span> (df = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> ++calls &amp;&amp; f(...args), df.getCalls = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> calls, df))(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Damit ist das Ziel erreicht. </p><br><h2 id="variacii-na-temu">  Variationen über ein Thema </h2><br><p>  Interessanterweise konnten wir vermeiden, lokale Variablen, mehrere Ausdrücke in Funktionsblöcken und ein Objektliteral zu erstellen und zu initialisieren.  Gleichzeitig wurde die ursprüngliche Lösung sauber gehalten: das Fehlen globaler Variablen, der Schutz der Privatsphäre und der Zugriff auf die Argumente der Funktion, die verpackt wird. </p><br><p>  Im Allgemeinen können Sie jede Implementierung übernehmen und versuchen, etwas Ähnliches zu tun.  Zum Beispiel ist die Polyfüllung für die <em>Bindungsfunktion</em> in dieser Hinsicht ziemlich einfach: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bind = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, ctx, ...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (...args) =&gt; f.apply(ctx, a.concat(args));</code> </pre> <br><p>  Wenn das Argument <em>f jedoch</em> keine Funktion ist, sollten wir auf gute Weise eine Ausnahme auslösen.  Und die <em>Wurfausnahme</em> kann nicht im Kontext des Ausdrucks ausgelöst werden.  Sie können auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wurfausdrücke</a> warten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Stufe 2)</a> und es erneut versuchen.  Oder hat jemand schon Gedanken? </p><br><p>  Oder betrachten Sie eine Klasse, die die Koordinaten eines Punktes beschreibt: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x, y) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.y}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br><p>  Was durch eine Funktion dargestellt werden kann: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function"> =&gt;</span></span> (px = x, py = y, p.toString = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> [<span class="hljs-string"><span class="hljs-string">'('</span></span>, x, <span class="hljs-string"><span class="hljs-string">', '</span></span>, y, <span class="hljs-string"><span class="hljs-string">')'</span></span>].join(<span class="hljs-string"><span class="hljs-string">''</span></span>), p))(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>);</code> </pre> <br><p>  Nur hier haben wir die Prototypvererbung verloren: <em>toString</em> ist eine Eigenschaft des <em>Point-</em> Prototypobjekts, kein separat erstelltes Objekt.  Kann dies vermieden werden, wenn Sie sich anstrengen? </p><br><p>  In den Ergebnissen der Transformationen erhalten wir eine ungesunde Mischung aus funktionaler Programmierung mit imperativen Hacks und einigen Merkmalen der Sprache selbst.  Wenn Sie darüber nachdenken, kann sich dies als interessanter (aber nicht praktischer) Verschleierer des Quellcodes herausstellen.  Sie können Ihre eigene Version der Aufgabe "Bracketing Obfuscator" erstellen und Kollegen und Freunde von JavaScript'ern in ihrer Freizeit von nützlicher Arbeit unterhalten. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die Frage ist, für wen ist es nützlich und warum wird es benötigt?  Dies ist für Anfänger völlig schädlich, da es eine falsche Vorstellung von der übermäßigen Komplexität und Abweichung der Sprache bildet.  Aber es kann für Praktiker nützlich sein, da Sie die Merkmale der Sprache von der anderen Seite betrachten können: Der Anruf ist nicht zu vermeiden, und der Anruf ist zu versuchen, in Zukunft zu vermeiden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428337/">https://habr.com/ru/post/de428337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428321/index.html">Predictive Data Analytics - Modellierung und Validierung</a></li>
<li><a href="../de428327/index.html">Worauf Sie achten sollten: Europäische eIDAS-Verordnung zur elektronischen Identifizierung</a></li>
<li><a href="../de428329/index.html">Verstärkungstraining: Parsen von Videospielen</a></li>
<li><a href="../de428333/index.html">2018 RAIF Hackathon AI Hackathon Ergebnisse</a></li>
<li><a href="../de428335/index.html">Siri Shortcut Update</a></li>
<li><a href="../de428339/index.html">Automatisieren Sie es nicht: Schlechte Geschäftstipps</a></li>
<li><a href="../de428341/index.html">Qsan RAID EE-Technologie</a></li>
<li><a href="../de428343/index.html">Ein interessantes Puzzle in C.</a></li>
<li><a href="../de428345/index.html">Anforderungen mit Fällen abdecken. SuperJob Realitäten</a></li>
<li><a href="../de428347/index.html">Die Zukunft von WebAssembly als „Skill Tree“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>