<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïì üîî ü•ù Modelamos el algoritmo MUSIC para determinar la direcci√≥n de llegada de una onda electromagn√©tica üßù üòù üë©üèæ‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo 


 Comenzar√© mi presentaci√≥n desde lejos. √ârase una vez, en el lejano 2016-2017, su humilde servidor logr√≥ ir a un curso de capacitaci√≥n de s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelamos el algoritmo MUSIC para determinar la direcci√≥n de llegada de una onda electromagn√©tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446674/"><p><img src="https://media.moddb.com/cache/images/groups/1/3/2392/thumb_620x2000/music-cats.jpg" alt="aaspcats"></p><br><h2 id="predislovie">  Pr√≥logo </h2><br><p>  Comenzar√© mi presentaci√≥n desde lejos.  √ârase una vez, en el lejano 2016-2017, su humilde servidor logr√≥ ir a un curso de capacitaci√≥n de seis meses a la lejana ciudad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Ilmenau</a> (Alemania), donde complet√≥ con √©xito (en general) el programa de maestr√≠a de <strong>Procesamiento de comunicaciones y se√±ales</strong> .  El programa no fue f√°cil, pero ahora es incluso agradable recordarlo.  A veces ... </p><a name="habracut"></a><br><p>  Entonces, al final de esta capacitaci√≥n, adem√°s del diploma, todav√≠a ten√≠a algunos materiales diferentes en mis manos, que pens√© que era incorrecto no compartir. </p><br><p>  Uno de estos materiales est√° frente a ti. </p><br><p>  <strong>¬øQu√© objetivos persegu√≠ mientras preparaba el seminario</strong> ? </p><br><ol><li>  hablar sobre algunos enfoques "inteligentes" ya establecidos en el tema de los conjuntos de antenas m√°s accesibles y hacerlo en ruso; </li><li>  realice una peque√±a simulaci√≥n en <strong><em>Python 3</em></strong> para agitar a otros ingenieros de radio para que echen un vistazo m√°s de cerca a los lenguajes de programaci√≥n (si a√∫n no lo ha examinado de cerca); </li><li>  proporcionar enlaces a buena literatura en ingl√©s, sin leer fuentes extranjeras, ahora, por desgracia, en ninguna parte. </li></ol><br><p>  <strong>Que considerar</strong> : </p><br><ul><li>  El m√©todo MUSIC (clasificaci√≥n m√∫ltiple m√∫ltiple): esto, de hecho, se refiere a la vista previa. </li></ul><br><blockquote>  Puede encontrar un ejemplo de formaci√≥n de gr√°ficos y el m√©todo MVDR <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aqu√≠</a> (si hay preguntas o sugerencias para material adicional, la discusi√≥n puede continuar en Github.Gist). </blockquote><p>  Como dije anteriormente, usaremos Python, a saber: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p>  ¬øPor qu√© no MATLAB, uno de los candidatos m√°s populares y convenientes para el modelado de √°lgebra lineal?  Porque quiero mostrar que se puede hacer un trabajo similar en Python, y el alcance de Python es mucho m√°s amplio que el de MATLAB.  Por lo tanto, estar familiarizado con la sintaxis de Python es algo √∫til, en mi opini√≥n. </p><br><p>  ¬°Empecemos! </p><br><blockquote>  Las f√≥rmulas se preparan a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">https://upmath.me/</a> .  ¬°Gracias a los creadores por una gran herramienta! </blockquote><br><h2 id="postanovka-zadachi">  Declaraci√≥n del problema. </h2><br><p>  Supongamos que hay un conjunto de antenas lineales que consta de una serie de elementos separados entre s√≠ <img src="https://tex.s2cms.ru/svg/%5CDelta%20%3D%20%5Cfrac%7B%5Clambda%7D%7B2%7D" alt="\ Delta = \ frac {\ lambda} {2}">  (paso del conjunto de antenas), donde <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  - la longitud de la onda portadora electromagn√©tica (EM). </p><br><p>  Las ondas electromagn√©ticas caen sobre este conjunto de antenas desde diferentes direcciones. </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote>  Fig.  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Sistema de antena adaptable.</a> </blockquote><p>  Como se puede ver en la figura, el conjunto de antenas se considera como un filtro adaptativo. </p><br><p>  En realidad, encontrar el vector √≥ptimo de coeficientes ( <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bw%7D_%7Bopt%7D" alt="\ mathbf {w} _ {opt}">  ) es la tarea principal de las matrices de antenas adaptativas desde un punto de vista matem√°tico. </p><br><p>  Inicialmente, no sabemos de qu√© direcciones particulares provienen las se√±ales y cu√°ntas de ellas.  Para resolver esta contradicci√≥n usaremos el algoritmo MUSIC, un algoritmo para estimar frecuencias espaciales con alta resoluci√≥n. </p><br><h2 id="modelirovanie-prinyatogo-signala">  Simulaci√≥n de se√±al recibida </h2><br><p>  Podemos presentar el modelo de la se√±al recibida a trav√©s de la f√≥rmula: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D%20%2B%20%5Cmathbf%7BN%7D%20" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><p></p><br><p>  donde <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BA%7D%20%3D%20%5B%5Cmathbf%7Ba%7D(%5Ctheta_1)%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_2)%20%5Cquad%20...%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_d)%5D" alt="\ mathbf {A} = [\ mathbf {a} (\ theta_1) \ quad \ mathbf {a} (\ theta_2) \ quad ... \ quad \ mathbf {a} (\ theta_d)]">  - matriz de vectores de exploraci√≥n (vectores de direcci√≥n) del conjunto de antenas ( <img src="https://tex.s2cms.ru/svg/%20a_i%20%3D%20%5Cexp(-j%20%5Cmu%20m_i)" alt="a_i = \ exp (-j \ mu m_i)">  , <img src="https://tex.s2cms.ru/svg/m%20%3D%200%2C%201%20...%20(M-1)" alt="m = 0, 1 ... (M-1)">  , <img src="https://tex.s2cms.ru/svg/M" alt="M">  - el n√∫mero de elementos del conjunto de antenas, <img src="https://tex.s2cms.ru/svg/d" alt="d">  - el n√∫mero de fuentes de ondas EM, <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  - √°ngulo de la direcci√≥n de llegada de la onda EM), <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BS%7D" alt="\ mathbf {S}">  - matriz de caracteres transmitidos, y <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BN%7D" alt="\ mathbf {N}">  - matriz de ruido aditivo. </p><br><img src="https://raw.githubusercontent.com/kirlf/CSP/master/Different/assets/ULA.png" alt="ULA" width="600"><br><blockquote>  Fig.  2. Conjunto de antenas lineales omnidireccionales (ULAA - conjunto de antenas lineal uniforme) [1, p.  32] </blockquote><p>  Replanteemos esta f√≥rmula de la manera "cotidiana": en nuestra cuadr√≠cula obtenemos algo de "desorden" a partir de varias se√±ales, que denotamos por <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BX%7D" alt="\ mathbf {X}">  .  No recibimos expl√≠citamente informaci√≥n sobre el n√∫mero de fuentes y direcciones, sin embargo, la informaci√≥n sobre esto est√° contenida en la se√±al recibida. </p><br><p>  Estamos empezando a buscar! </p><br><p>  Para hacer esto, generalmente proceden a manipulaciones no con las matrices de amplitudes de se√±al complejas, sino con sus covarianzas (es decir, en esencia, con poderes): </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5EH%20%3D%20%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BR%7D_%7Bss%7D%20%5Cmathbf%7BA%7D%5EH%20%2B%20%5Cmathbf%7BR%7D_%7Bnn%7D%20" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><p></p><br><h2 id="usloviya">  Condiciones </h2><br><p>  Introducimos una condici√≥n importante a considerar: el l√≠mite de resoluci√≥n del √°ngulo de Rayleigh: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/sin%20(%5Ctheta_R)%20%3D%20%5Cfrac%7B%5Clambda%7D%7BD%7D" alt="sin (\ theta_R) = \ frac {\ lambda} {D}"></div><p></p><br><p>  donde <img src="https://tex.s2cms.ru/svg/D%20%3D%20M%20%5CDelta" alt="D = M \ Delta">  Es la longitud de la red lineal. </p><br><p>  Redefinimos el √°ngulo de llegada de una onda electromagn√©tica a trav√©s del concepto de frecuencia espacial: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmu_R%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20sin(%5Ctheta_R)%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20%5Cfrac%7B%5Clambda%7D%7B%5CDelta%20M%7D%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7BM%7D" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta sin (\ theta_R) = \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><p></p><br><p>  donde <img src="https://tex.s2cms.ru/svg/%5Cmu_R" alt="\ mu_R">  - hay un ancho est√°ndar del l√≥bulo principal del haz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">ancho de haz est√°ndar</a> ). </p><br><p>  Para verificar cu√°n efectivo es nuestro m√©todo y bajo qu√© condiciones, presentamos algunos valores dados para la separaci√≥n angular: </p><br><ol><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%20%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = - \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = \ mu_R \ quad">  - divisi√≥n en un ancho de haz; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.5%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.5%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0.5 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0.5 \ mu_R \ quad">  - divisi√≥n en un segundo ancho de haz; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.3%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.3%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0.3 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0.3 \ mu_R \ quad">  - divisi√≥n en tres d√©cimas del ancho del haz. </p><br></li></ol><br><p>  Defina los par√°metros de entrada: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode">  Un poco de teor√≠a sobre el m√©todo en s√≠ </h2><br><p>  En primer lugar, observamos que el progenitor del m√©todo MUSIC es el m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Pisarenko</a> (1973).  El problema considerado del m√©todo Pisarenko era estimar las frecuencias de la suma de exponenciales complejos en ruido blanco.  V.F. Pisarenko demostr√≥ que se pueden encontrar frecuencias de vectores propios correspondientes al valor propio m√≠nimo de la matriz de autocorrelaci√≥n.  Posteriormente, este m√©todo se convirti√≥ en un caso especial del m√©todo MUSIC.  [2, p.  459] </p><br><p>  Schmidt y sus colegas propusieron el algoritmo de clasificaci√≥n de se√±al m√∫ltiple (MUSIC) en 1979 [4].  El enfoque principal de este algoritmo es descomponer la matriz de covarianza de la se√±al recibida en valores propios.  Dado que este algoritmo tiene en cuenta el ruido no correlacionado, la matriz de covarianza generada tiene una forma diagonal.  Aqu√≠, los subespacios de se√±al y ruido se calculan utilizando √°lgebra lineal y son ortogonales entre s√≠.  Por lo tanto, el algoritmo utiliza la propiedad de ortogonalidad para extraer subespacios de se√±al y ruido [5]. </p><br><p>  El algoritmo MUSIC generalizado se puede definir de la siguiente manera: </p><br><ul><li>  Encuentra la matriz de covarianza <img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20" alt="\ mathbf {R} _ {xx}"></li><li>  Encuentre vectores propios a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">EVD</a> u otro algoritmo num√©rico adecuado: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BU%7D%5Cmathbf%7B%5CLambda%7D%5Cmathbf%7BU%7D%5EH%20%5Cqquad(1)" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad (1)"></div><p></p><br><ul><li>  Encuentre el pseudo espectro (por qu√© con el prefijo pseudo, discutiremos a continuaci√≥n) M√öSICA a trav√©s de la siguiente f√≥rmula: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(e%5E%7Bj%5Comega%7D)%20%3D%20%5Cfrac%7B1%7D%7B%5Csum%20%5Climits_%7Bi%3Dd%2B1%7D%5E%7BM%7D%7C%5Cmathbf%7Ba%7D%5EH%5Cmathbf%7Bu%7D_i%7C%5E2%7D%20%5Cqquad(2)%20" alt="P_ {MU} (e ^ {j \ omega}) = \ frac {1} {\ sum \ limits_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad (2)"></div><p></p><br><p>  donde <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Ba%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20%20e%5E%7Bj0%5Comega%7D%20%26%20e%5E%7Bj1%5Comega%7D%20%26%20e%5E%7Bj2%5Comega%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Comega%7D%20%5Cend%7Bbmatrix%7D%5ET" alt="\ mathbf {a} = \ begin {bmatrix} e ^ {j0 \ omega} &amp; e ^ {j1 \ omega} &amp; e ^ {j2 \ omega} &amp; ... &amp; e ^ {j (M-1) \ omega } \ end {bmatrix} ^ T">  Es el vector de exponenciales para la frecuencia œâ que se encuentra en un rango dado, y <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bu%7D_i" alt="\ mathbf {u} _i">  - el i-√©simo vector propio (vector propio) de la matriz de covarianza (1) correspondiente al subespacio de ruido de la matriz (1) - de ah√≠ la indexaci√≥n con <img src="https://tex.s2cms.ru/svg/d%2B1" alt="d + 1">  ( <img src="https://tex.s2cms.ru/svg/d" alt="d">  Es el rango de la matriz (1)). </p><br><blockquote>  Para mayor claridad, intente ejecutar el script MATLAB apropiado proporcionado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">referencia</a> .  Presta atenci√≥n a dos puntos principales: <br><ul><li>  en lugar de calcular el cuadrado de la segunda norma en el denominador (2), los autores aplican el algoritmo FFT a vectores propios, lo que facilita el modelado mediante el uso de funciones integradas y, en general, no contradice la teor√≠a desde un punto de vista matem√°tico; </li><li>  la matriz de covarianza se calcula a trav√©s de matrices convolucionales; anteriormente se mostr√≥ un enfoque diferente para estimar las frecuencias espaciales. </li></ul><br></blockquote><p>  Como se puede adivinar por el nombre, MUSIC tambi√©n es un m√©todo cl√°sico para estimar la direcci√≥n de recepci√≥n con alta resoluci√≥n.  El algoritmo para calcular los pseudo-espectros en este contexto se da a continuaci√≥n: </p><br><ul><li><p>  encontramos la matriz de covarianza de la se√±al recibida; </p><br></li><li><p>  encuentra el subespacio cero <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D_0" alt="\ mathbf {U} _0">  : </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BU%7D%20%3D%20%5B%5Cmathbf%7BU%7D_s%20%5Cquad%20%5Cmathbf%7BU%7D_0%5D%20" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><p></p><br><ul><li>  seleccione un rango de b√∫squeda: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Cmu)%20%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7Bj0%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj0%5Cmu_Q%7D%20%5C%5C%20...%20%26...%26...%20%5C%5C%20e%5E%7Bj(M-1)%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Cmu_Q%7D%20%5Cend%7Bbmatrix%7D%20" alt="a (\ mu) = \ begin {bmatrix} e ^ {j0 \ mu_1} &amp; ... &amp; e ^ {j0 \ mu_Q} \\ ... &amp; ... &amp; ... \\ e ^ {j ( M-1) \ mu_1} &amp; ... &amp; e ^ {j (M-1) \ mu_Q} \ end {bmatrix}"></div><p></p><br><p>  donde <img src="https://tex.s2cms.ru/svg/%5Cmu%20%3D%20-%5Cfrac%7B2%5Cpi%20f_c%7D%7Bc%7D%5CDelta%20sin%5Ctheta%20%3D%20-%5Cfrac%7B2%5Cpi%20%7D%7B%5Clambda%20%7D%5CDelta%20sin%5Ctheta" alt="\ mu = - \ frac {2 \ pi f_c} {c} \ Delta sin \ theta = - \ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li>  calcular el pseudo espectro: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(%5Ctheta)%3D%5Cfrac%7B%5Cmathbf%7Ba%7D%5EH%20(%5Ctheta)%5Cmathbf%7Ba%7D(%5Ctheta)%7D%7B%5Cmathbf%7Ba%7D%5EH(%5Ctheta)%5Cmathbf%7BU%7D_0%20%5Cmathbf%7BU%7D_0%5EH%20%5Cmathbf%7Ba%7D(%5Ctheta)%7D%20" alt="P_ {MU} (\ theta) = \ frac {\ mathbf {a} ^ H (\ theta) \ mathbf {a} (\ theta)} {\ mathbf {a} ^ H (\ theta) \ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a} (\ theta)}"></div><p></p><br><p>  La relaci√≥n entre el an√°lisis espectral y el an√°lisis de √°ngulos de llegada (DoA - direcci√≥n de arriaval) de las ondas EM se describe en la tabla 1. </p><br><p>  Tabla 1 <strong>Comunicaci√≥n entre aplicaciones MUSIC</strong> : procesamiento de matriz de se√±al y b√∫squeda arm√≥nica [6]. </p><br><div class="scrollable-table"><table><thead><tr><th>  Variable </th><th>  Procesamiento de matriz de se√±al </th><th>  B√∫squeda arm√≥nica </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/M" alt="M"></div></td><td>  Numero de sensores </td><td>  El n√∫mero de per√≠odos de tiempo. </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/N" alt="N"></div></td><td>  El n√∫mero de per√≠odos de tiempo. </td><td>  Numero de experimentos </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/d" alt="d"></div></td><td>  N√∫mero de frentes de ola </td><td>  El n√∫mero de componentes complejos. </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cmu" alt="\ mu"></div></td><td>  Frecuencias espaciales </td><td>  Frecuencias normalizadas </td></tr></tbody></table></div><br><p>  En general, el proceso de recibir a trav√©s de matrices (rejillas) se puede comparar con el proceso de discretizaci√≥n cl√°sica, porque  de hecho, cada sensor, que recibe una onda con un cierto retraso de fase (es decir, con un cierto retraso de tiempo), realiza las funciones de un pulso delta de muestreo.  El n√∫mero de realizaciones (experimentos) del an√°lisis espectral cl√°sico corresponder√° al n√∫mero de segmentos de tiempo (instant√°neas).  Cada fuente tendr√° su propio frente de onda, que es equivalente al n√∫mero de sinusoides √∫nicos de la se√±al en el caso del an√°lisis espectral. </p><br><p>  Y ahora volviendo al momento de calcular los vectores propios.  Ya mencionamos anteriormente que los vectores <img src="https://tex.s2cms.ru/svg/a(%5Ctheta_i)%5Cepsilon%20A" alt="a (\ theta_i) \ epsilon A">  donde <img src="https://tex.s2cms.ru/svg/i%3D1%2C2%2C..%2Cd" alt="i = 1,2, .., d">  son ortogonales al subespacio de ruido de la matriz de covarianza, es decir: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Ctheta_i)%5ETU_0%3D0%5ET%20" alt="a (\ theta_i) ^ TU_0 = 0 ^ T"></div><p></p><br><p>  En realidad, vemos un sistema de ecuaciones, resolviendo en qu√© podemos encontrar las ra√≠ces: vectores propios.  Tal m√©todo, en contraste con los algoritmos num√©ricos (que, como se√±alamos anteriormente, se aplica a EVD), permite obtener valores propios reales en lugar de aproximados.  Es por eso que este enfoque nos permite obtener no un pseudoespectro, sino un espectro.  La misma idea form√≥ la base del algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Root MUSIC</a> . </p><br><h2 id="modelirovanie">  Modelado </h2><br><p>  Fuf!  Finalmente, todas las f√≥rmulas se describen y explican de alguna manera.  Podemos comenzar a modelar. </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles Œ∏ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p>  Como podemos ver, MUSIC tiene una resoluci√≥n m√°s alta y permite lograr, en general, mejores resultados que, por ejemplo, MVDR permite, el mismo representante de los m√©todos param√©tricos de an√°lisis espectral. </p><br><p>  Sin embargo, debe tenerse en cuenta que cuando usamos MUSIC usamos algoritmos m√°s computacionalmente caros, como EVD o SVD, que tiene un precio para una mayor precisi√≥n. </p><br><p>  Tales cosas </p><br><h2 id="spisok-ispolzovannoy-literatury">  Lista de literatura utilizada: </h2><br><ol><li>  Haykin, Simon y KJ Ray Liu.  Manual sobre procesamiento de matriz y redes de sensores.  Vol.  63. John Wiley &amp; Sons, 2010. pp.  102-107 </li><li>  Hayes MH Procesamiento y modelado estad√≠stico de se√±ales digitales.  - John Wiley &amp; Sons, 2009. </li><li>  Haykin, Simon S. Teor√≠a del filtro adaptativo.  Pearson Education India, 2008. pp.  422-427 </li><li>  Richmond, Christ D. "Umbral de error medio-cuadrado del algoritmo de cap√≥n predicci√≥n SNR y probabilidad de resoluci√≥n".  Transacciones IEEE sobre procesamiento de se√±ales 53.8 (2005): 2748-2764. </li><li>  SKP Gupta, MUSIC y algoritmo MUSIC mejorado para estimar la dorecci√≥n de llegada, IEEE, 2015. </li><li>  Conferencias del profesor Martin Haardt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">array array</a> ) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446674/">https://habr.com/ru/post/446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446660/index.html">IA, estudiante y gran premio: c√≥mo hacer aprendizaje autom√°tico en octavo grado</a></li>
<li><a href="../446662/index.html">Transacciones y mecanismos para su control.</a></li>
<li><a href="../446664/index.html">¬°SAP Forum 2019 est√° a solo 2 semanas! ¬øQu√© habr√° all√≠?</a></li>
<li><a href="../446666/index.html">Exprime al m√°ximo las calculadoras gr√°ficas: juegos en la TI-83</a></li>
<li><a href="../446668/index.html">Python para la web: lo que un junior necesita saber para trabajar y crecer</a></li>
<li><a href="../446676/index.html">Creaci√≥n de teclas faltantes para el teclado de goma Commodore 116</a></li>
<li><a href="../446678/index.html">Batalla en vivo: Finales de Porto ICPC</a></li>
<li><a href="../446680/index.html">El instinto principal del codificador es eliminar soluciones ineficaces de todas partes.</a></li>
<li><a href="../446682/index.html">Acelerar WebGL / Three.js con OffscreenCanvas y Web Workers</a></li>
<li><a href="../446688/index.html">Extensi√≥n SIMD a C ++ OpenMP en Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>