<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤑 🤓 🧒🏾 Dari Latensi Ceph Tinggi ke Patch Kernel dengan eBPF / BCC 🤟🏼 💅🏾 ⚾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak alat untuk debugging kernel dan program userspace di Linux. Kebanyakan dari mereka memiliki dampak kinerja dan tidak dapat dengan mudah dij...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari Latensi Ceph Tinggi ke Patch Kernel dengan eBPF / BCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/450818/"><img src="https://habrastorage.org/webt/-8/ok/na/-8okna9qfyroicvgoz-zenv7-si.png"><br><br>  Ada banyak alat untuk debugging kernel dan program userspace di Linux.  Kebanyakan dari mereka memiliki dampak kinerja dan tidak dapat dengan mudah dijalankan di lingkungan produksi.  Beberapa tahun yang lalu, eBPF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dikembangkan</a> , yang menyediakan kemampuan untuk melacak kernel dan ruang pengguna dengan overhead rendah, tanpa perlu mengkompilasi ulang program atau memuat modul kernel. <br><br>  Sekarang ada banyak alat yang menggunakan eBPF dan dalam artikel ini, kami akan menjelaskan cara menulis alat profil Anda sendiri menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka PythonBCC</a> .  Artikel ini didasarkan pada masalah nyata dari lingkungan produksi.  Kami akan memandu Anda menyelesaikan masalah dan menunjukkan bagaimana alat bcc yang ada dapat digunakan dalam beberapa kasus. <br><a name="habracut"></a><br><h2>  Ceph lambat </h2><br>  Platform baru ditambahkan ke ceph cluster.  Setelah memigrasi beberapa data ke platform, latensi permintaan tulis lebih tinggi daripada di server lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uk/de/-l/ukde-lsu9sjqnmci1ix942xzgie.png"></div><br><br>  Platform ini memiliki perangkat virtual caching baru - bcache, yang belum pernah kami gunakan di cluster ini sebelumnya - dan kernel baru - 4,15, yang masih tidak digunakan di tempat lain di cluster ini.  Akar masalahnya bisa di mana saja, jadi mari kita lihat lebih dalam. <br><br><h3>  Investigasi tuan rumah </h3><br>  Mari kita lihat apa yang terjadi di dalam proses ceph-osd.  Kami menggunakan alat tracing <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perf</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flamescope</a> untuk membuat flamegraph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/5k/nn/ch5knn22cmukd1oldmcozpxe98i.png"></div><br><br>  Seperti yang dapat kita lihat dari flamegraph, <b>fdatasync ()</b> menghabiskan banyak waktu mengirimkan bio dalam fungsi <b>generic_make_request ()</b> .  Jadi, akar masalah kita adalah di suatu tempat di luar daemon ceph.  Mungkin masalah kernel, bcache, atau disk.  Output iostat menunjukkan latensi tinggi untuk perangkat bcache. <br><br>  Temuan mencurigakan lainnya adalah bahwa daemon systemd-udevd mengkonsumsi CPU;  sekitar 20% pada banyak CPU.  Ini perilaku aneh, jadi kita harus mencari tahu apa yang terjadi.  Karena systemd-udevd bekerja dengan uevents, kita harus menggunakan <b>monitor udevadm</b> untuk mengetahui apakah ada uevents di sistem.  Setelah memeriksa, kami melihat bahwa banyak "perubahan" yang dihasilkan untuk setiap perangkat blok dalam sistem. <br><br>  Ini tidak biasa, jadi kami akan mencari tahu apa yang menyebabkan semua ini dikirim. <br><br>
<h3>  Menggunakan BCC Toolkit </h3><br>  Seperti yang sudah kita ketahui, kernel (dan ceph daemon) menghabiskan banyak waktu untuk menjalankan fungsi <b>generic_make_requst ()</b> .  Mari kita mengukur latensi menggunakan <b>funclatency</b> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BCC toolkit</a> , hanya untuk memastikan bahwa kita berada di jalur yang benar.  Kami akan melacak PID daemon ceph (argumen -p) dalam interval 1 detik (-i) dan mencetak latensi dalam milidetik (-m). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/cj/za/4ccjza8x8bq0vqkxfol2j5d9sva.png"></div><br><br>  Fungsi ini biasanya bekerja sangat cepat.  Yang dilakukannya hanyalah mengirimkan struktur bio ke antrian driver perangkat. <br><br>  <b>Bcache</b> adalah perangkat yang kompleks;  sebenarnya, ini terdiri dari 3 perangkat: perangkat pendukung, yang merupakan HDD lambat dalam kasus kami;  perangkat caching, yang merupakan partisi drive NVMe;  dan perangkat virtual bcache, yang digunakan oleh aplikasi.  Kami tahu pengiriman lambat, tetapi untuk perangkat apa?  Ini adalah sesuatu yang akan kita lihat nanti. <br><br>  Untuk saat ini, kita tahu bahwa uevents menyebabkan masalah pada daemon ceph dan kita harus menemukan perangkat lunak yang memicu uevents. Tidak mudah untuk menemukan apa yang menyebabkan uevents dihasilkan.  Kami menganggap itu perangkat lunak yang hanya berjalan secara berkala.  Untuk melihat apa yang sedang dieksekusi pada sistem, kami menggunakan <b>execsnoop</b> dari BCC toolkit.  Kita dapat menjalankannya dan mengarahkan <b>stdout</b> ke file. <br><br>  Sebagai contoh: <br><br><pre><code class="bash hljs">/usr/share/bcc/tools/execsnoop | tee ./execdump</code> </pre> <br>  Kami tidak akan memberikan output execsnoop penuh di sini, tetapi satu string menarik yang kami temukan di sana adalah: <br><br><pre> <code class="bash hljs">sh 1764905 5802 0 sudo arcconf getconfig 1 AD | grep Temperature | awk -F <span class="hljs-string"><span class="hljs-string">'[:/]'</span></span> <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/^ \([0-9]*\) C.*/\1/'</span></span></code> </pre> <br>  Kolom ketiga adalah PPID proses.  Kami memeriksa apa itu 5802 dan melihat bahwa itu adalah salah satu utas daemon pemantauan kami.  Melihat lebih jauh pada konfigurasi sistem pemantauan, kami menemukan parameter yang salah.  Suhu HBA sedang diambil setiap 30 detik, yang terlalu sering.  Setelah mengubah interval pemeriksaan ke nilai yang lebih tepat, kami melihat bahwa latensi kami cocok dengan platform lain. <br><br>  Tetapi kita masih tidak tahu mengapa latensi bcache tinggi.  Kami menyiapkan platform pengujian dengan konfigurasi yang sama dan mencoba mereproduksi masalah dengan fio pada perangkat bcache sementara secara bersamaan memicu udev dengan perintah memicu udevadm. <br><br><h3>  Menulis Alat Berbasis BCC </h3><br>  Apa yang akan kita lakukan di sini adalah menulis alat sederhana yang melacak panggilan generic_make_request () paling lambat dan mencetak nama disk yang dipanggil untuk fungsi tersebut. <br><br>  Rencananya sederhana: <br><br><ul><li>  Daftarkan <b>kprobe</b> di <b>generic_make_request ()</b> : <br><ul><li>  Simpan nama disk yang tersedia dari argumen fungsi </li><li>  Simpan cap waktu saat ini </li></ul></li><li>  Daftarkan <b>kretprobe</b> di pernyataan pengembalian <b>generic_make_request ()</b> : <br><ul><li>  Ambil stempel waktu saat ini </li><li>  Cari stempel waktu yang disimpan sebelumnya dan bandingkan dengan yang sekarang </li><li>  Jika hasilnya lebih tinggi dari ambang, cari nama disk yang disimpan sebelumnya dan cetak ke terminal dengan informasi tambahan </li></ul></li></ul><br>  <b>Kprobes</b> dan <b>kretprobes</b> menggunakan breakpoint untuk mengubah kode fungsi saat runtime.  Anda dapat menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> bagus tentang ini.  Jika Anda melihat kode untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat BCC yang</a> berbeda, Anda akan melihat bahwa mereka semua memiliki struktur yang sama.  Kami akan melewatkan argumen penguraian dan fokus pada program BPF itu sendiri. <br><br>  Teks program kami akan didefinisikan dalam python sebagai berikut: <br><br><pre> <code class="python hljs">bpf_text = “”” <span class="hljs-comment"><span class="hljs-comment"># Here will be the bpf program code “””</span></span></code> </pre> <br>  Program BPF menggunakan <a href="">hashmaps</a> untuk berbagi data antara berbagai fungsi.  Kami akan menggunakan PID sebagai struktur kunci dan yang didefinisikan sendiri sebagai nilai. <br><br><pre> <code class="python hljs">struct data_t { u64 pid; u64 ts; char comm[TASK_COMM_LEN]; u64 lat; char disk[DISK_NAME_LEN]; }; BPF_HASH(p, u64, struct data_t); BPF_PERF_OUTPUT(events);</code> </pre> <br>  Di sini kita mendaftarkan hashmap yang disebut <b>p</b> dengan <b>tipe</b> kunci <b>u64</b> dan tipe nilai <b>struct data_t</b> .  Peta ini dapat diakses dari konteks program BPF kami.  Makro <b>BPF_PERF_OUTPUT</b> mendaftarkan peta lain yang disebut <b>peristiwa</b> , yang digunakan untuk <a href="">mendorong data</a> ke ruang pengguna. <br><br>  Saat mengukur latensi antara panggilan fungsi dan pengembaliannya atau antara satu panggilan fungsi dan yang lain, Anda harus yakin bahwa data yang Anda simpan dan akses nanti terkait dengan konteks yang sama.  Dengan kata lain, Anda harus mengetahui eksekusi paralel lain dari fungsi yang sama.  Dimungkinkan untuk melacak latensi antara pemanggilan fungsi dari satu proses dan pengembalian fungsi yang sama dari proses lain, tetapi ini tidak membantu kami.  Contoh yang baik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat biolatensi di</a> mana pointer ke <b>permintaan struct</b> digunakan sebagai kunci hashmap. <br><br>  Selanjutnya, kita harus menulis kode yang akan dieksekusi pada panggilan fungsi melalui mekanisme kprobe: <br><br><pre> <code class="python hljs">void start(struct pt_regs *ctx, struct bio *bio) { u64 pid = bpf_get_current_pid_tgid(); struct data_t data = {}; u64 ts = bpf_ktime_get_ns(); data.pid = pid; data.ts = ts; bpf_probe_read_str(&amp;data.disk, sizeof(data.disk), (void*)bio-&gt;bi_disk-&gt;disk_name); p.update(&amp;pid, &amp;data); }</code> </pre> <br>  Di sini kita memiliki <a href="">argumen generic_make_request ()</a> pertama sebagai argumen kedua fungsi kita.  Kemudian kita mendapatkan PID dan cap waktu saat ini dalam nanodetik dan menulisnya ke <b>data data_t struct yang</b> baru dialokasikan.  Kami mendapatkan nama disk dari struktur bio, yang diteruskan ke <b>generic_make_request ()</b> , dan menyimpannya ke <b>data</b> kami.  Langkah terakhir adalah menambahkan entri ke hashmap yang kami jelaskan sebelumnya. <br><br>  Fungsi ini akan dieksekusi pada <b>generic_make_request ()</b> mengembalikan: <br><br><pre> <code class="python hljs">void stop(struct pt_regs *ctx) { u64 pid = bpf_get_current_pid_tgid(); u64 ts = bpf_ktime_get_ns(); struct data_t* data = p.lookup(&amp;pid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; data-&gt;ts &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { bpf_get_current_comm(&amp;data-&gt;comm, sizeof(data-&gt;comm)); data-&gt;lat = (ts - data-&gt;ts)/<span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data-&gt;lat &gt; MIN_US) { FACTOR data-&gt;pid &gt;&gt;= <span class="hljs-number"><span class="hljs-number">32</span></span>; events.perf_submit(ctx, data, sizeof(struct data_t)); } p.delete(&amp;pid); } }</code> </pre> <br>  Kami mendapatkan PID dan cap waktu dari output sebelumnya dan mencari peta hash untuk nilai di mana <b>kunci == PID saat ini</b> .  Jika ditemukan, kami mendapatkan nama proses yang sedang berjalan dan menambahkannya ke struktur <b>data</b> .  Apa yang kita lakukan dengan <b>data-&gt; pid di</b> sini memberi kita id grup utas.  Fungsi <a href="">bpf_get_current_pid_tgid () yang</a> sebelumnya disebut mengembalikan thread GID dan PID dari proses dalam nilai 64-bit yang sama. <br><br>  Kami tidak tertarik pada setiap ID utas, tetapi kami ingin mengetahui PID utas utama.  Setelah memeriksa bahwa latensi berada di atas ambang batas, kami mengirimkan struktur <b>data</b> kami ke userspace melalui peta <b>peristiwa</b> , lalu menghapus entri hashmap di bagian akhir. <br><br>  Dalam skrip python kami, kami harus mengganti <b>MIN_US</b> dan <b>FACTOR</b> sesuai dengan ambang yang kami inginkan dan satuan waktu yang ingin kami lihat dalam hasil kami: <br><br><pre> <code class="python hljs">bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'MIN_US'</span></span>,str(min_usec)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.milliseconds: bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'FACTOR'</span></span>,<span class="hljs-string"><span class="hljs-string">'data-&gt;lat /= 1000;'</span></span>) label = <span class="hljs-string"><span class="hljs-string">"msec"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'FACTOR'</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>) label = <span class="hljs-string"><span class="hljs-string">"usec"</span></span></code> </pre><br>  Maka kita harus menyiapkan program BPF dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makro BPF ()</a> dan mendaftarkan probe: <br><br><pre> <code class="python hljs">b = BPF(text=bpf_text) b.attach_kprobe(event=<span class="hljs-string"><span class="hljs-string">"generic_make_request"</span></span>,fn_name=<span class="hljs-string"><span class="hljs-string">"start"</span></span>) b.attach_kretprobe(event=<span class="hljs-string"><span class="hljs-string">"generic_make_request"</span></span>,fn_name=<span class="hljs-string"><span class="hljs-string">"stop"</span></span>)</code> </pre><br>  Kita juga perlu mendefinisikan struktur yang sama dengan <b>struct data_t</b> dalam skrip kami untuk membaca data dari program BPF: <br><br><pre> <code class="python hljs">TASK_COMM_LEN = <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-comment"><span class="hljs-comment"># linux/sched.h DISK_NAME_LEN = 32 # linux/genhd.h class Data(ct.Structure): _fields_ = [("pid", ct.c_ulonglong), ("ts", ct.c_ulonglong), ("comm", ct.c_char * TASK_COMM_LEN), ("lat", ct.c_ulonglong), ("disk",ct.c_char * DISK_NAME_LEN)]</span></span></code> </pre> <br>  Langkah terakhir adalah mencetak data yang kita inginkan: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, data, size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> start event = ct.cast(data, ct.POINTER(Data)).contents <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start == <span class="hljs-number"><span class="hljs-number">0</span></span>: start = event.ts time_s = (float(event.ts - start)) / <span class="hljs-number"><span class="hljs-number">1000000000</span></span> print(<span class="hljs-string"><span class="hljs-string">"%-18.9f %-16s %-6d %-1s %s %s"</span></span> % (time_s, event.comm, event.pid, event.lat, label, event.disk)) b[<span class="hljs-string"><span class="hljs-string">"events"</span></span>].open_perf_buffer(print_event) <span class="hljs-comment"><span class="hljs-comment"># format output start = 0 while 1: try: b.perf_buffer_poll() except KeyboardInterrupt: exit()</span></span></code> </pre><br>  Script lengkap tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Mari kita jalankan skrip dan memicu peristiwa udev sementara fio menulis ke perangkat bcache: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/ly/vf/tklyvf6i8rws0xu4gy3jothbxbi.png"></div><br><br>  Sukses!  Sekarang kita melihat bahwa apa yang tampak seperti latensi tinggi untuk bcache adalah <b>generic_make_request ()</b> latensi untuk perangkat pendukungnya. <br><br><h3>  Gali ke dalam kernel </h3><br>  Apa yang diseret saat mengirimkan permintaan?  Kita melihat bahwa lonjakan latensi terjadi sebelum permintaan akuntansi dimulai.  Ini dapat dengan mudah diperiksa dengan menjalankan iostat selama masalah atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip BCC biolatensi</a> , yang didasarkan pada permulaan permintaan akuntansi, sehingga tidak ada alat yang akan menunjukkan masalah disk. <br><br>  Jika kita melihat <b>generic_make_request ()</b> , kita melihat bahwa ada dua fungsi yang berjalan sebelum akuntansi dimulai.  Yang pertama adalah <b>generic_make_request_checks ()</b> , yang ringan dan memeriksa bio sesuai dengan pengaturan perangkat, dll.  Yang kedua adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_queue_enter ()</a> , yang memiliki panggilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wait_event_interruptible ()</a> : <br><br><pre> <code class="python hljs">ret = wait_event_interruptible(q-&gt;mq_freeze_wq, (atomic_read(&amp;q-&gt;mq_freeze_depth) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (preempt || !blk_queue_preempt_only(q))) || blk_queue_dying(q));</code> </pre><br>  Di sini kernel menunggu sampai antrian tidak beku.  Mari kita mengukur latensi blk_queue_enter (): <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /usr/share/bcc/tools/funclatency blk_queue_enter -i 1 -m Tracing 1 functions for "blk_queue_enter"... Hit Ctrl-C to end. msecs : count distribution 0 -&gt; 1 : 341 |****************************************| msecs : count distribution 0 -&gt; 1 : 316 |****************************************| msecs : count distribution 0 -&gt; 1 : 255 |****************************************| 2 -&gt; 3 : 0 | | 4 -&gt; 7 : 0 | | 8 -&gt; 15 : 1 | |</span></span></code> </pre><br>  Sepertinya kita sudah dekat.  Fungsi yang digunakan untuk membekukan / mencairkan antrian adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_mq_freeze_queue</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_mq_unfreeze_queue</a> .  Mereka digunakan untuk mengubah pengaturan antrian, yang dapat memengaruhi permintaan io yang saat ini dalam penerbangan.  Ketika <b>blk_mq_freeze_queue ()</b> dipanggil, <b>q-&gt; mq_freeze_depth</b> ditambahkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_freeze_queue_start ()</a> .  Setelah itu, kernel menunggu antrian menjadi kosong di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_mq_freeze_queue_wait ()</a> . <br><br>  Waktu tunggu ini sama dengan latensi disk, karena kernel harus menunggu semua operasi io selesai.  Ketika antrian kosong, perubahan dapat dilakukan.  Langkah terakhir adalah memanggil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blk_mq_unfreeze_queue ()</a> , yang menurunkan penghitung <b>freeze_depth</b> . <br><br>  Sekarang kita cukup tahu untuk memperbaiki masalah ini.  Perintah memicu udevadm mengubah pengaturan untuk perangkat blok.  Pengaturan tersebut dijelaskan dalam aturan udev.  Kita dapat mengetahui pengaturan apa yang membekukan antrian dengan mengubahnya melalui sysfs atau dengan melihat kode sumber kernel.  Atau, kita dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memanggil jejak</a> dari BCC toolkit untuk mencetak kernel dan tumpukan pengguna untuk setiap panggilan <b>blk_freeze_queue</b> : <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /usr/share/bcc/tools/trace blk_freeze_queue -K -U PID TID COMM FUNC 3809642 3809642 systemd-udevd blk_freeze_queue blk_freeze_queue+0x1 [kernel] elevator_switch+0x29 [kernel] elv_iosched_store+0x197 [kernel] queue_attr_store+0x5c [kernel] sysfs_kf_write+0x3c [kernel] kernfs_fop_write+0x125 [kernel] __vfs_write+0x1b [kernel] vfs_write+0xb8 [kernel] sys_write+0x55 [kernel] do_syscall_64+0x73 [kernel] entry_SYSCALL_64_after_hwframe+0x3d [kernel] __write_nocancel+0x7 [libc-2.23.so] [unknown] 3809631 3809631 systemd-udevd blk_freeze_queue blk_freeze_queue+0x1 [kernel] queue_requests_store+0xb6 [kernel] queue_attr_store+0x5c [kernel] sysfs_kf_write+0x3c [kernel] kernfs_fop_write+0x125 [kernel] __vfs_write+0x1b [kernel] vfs_write+0xb8 [kernel] sys_write+0x55 [kernel] do_syscall_64+0x73 [kernel] entry_SYSCALL_64_after_hwframe+0x3d [kernel] __write_nocancel+0x7 [libc-2.23.so] [unknown]</span></span></code> </pre> <br>  Aturan Udev tidak sering berubah, bahkan menetapkan nilai yang sudah ada ke parameter tertentu menyebabkan lonjakan pengiriman latensi untuk aplikasi.  Tentu saja menghasilkan peristiwa udev ketika tidak ada perubahan dalam konfigurasi perangkat (tidak ada perangkat yang terpasang atau terlepas) bukanlah praktik yang baik.  Namun, kita dapat mencegah kernel membekukan antrian jika tidak ada alasan untuk melakukan ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tiga</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komitmen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kecil</a> memperbaiki masalah ini. <br><br><h2>  Kesimpulan </h2><br>  eBPF adalah instrumen yang sangat fleksibel dan kuat.  Dalam artikel ini, kami hanya melihat satu kasus dan menunjukkan sedikit kemampuannya.  Jika Anda tertarik untuk mengembangkan alat berbasis BCC, Anda harus melihat pada <a href="">tutorial resmi</a> , yang menjelaskan konsep dasarnya. <br><br>  Ada juga alat berbasis eBPF menarik lainnya yang tersedia untuk profil dan debugging.  Salah satunya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bpftrace</a> , yang memungkinkan Anda menulis oneliner yang kuat dan program-program kecil dalam bahasa yang mirip bahasa awk.  Yang lainnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ebpf_exporter</a> , yang dapat mengumpulkan metrik resolusi tinggi tingkat rendah ke server prometheus Anda dengan visualisasi yang hebat dan kemampuan mengingatkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450818/">https://habr.com/ru/post/id450818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450806/index.html">Ketika variabel lingkungan mempercepat proses hingga 40 kali</a></li>
<li><a href="../id450810/index.html">7 cara teratas untuk dengan cepat memeriksa kompetensi spesialis TI sebelum wawancara</a></li>
<li><a href="../id450812/index.html">PSR-14 - acara utama dalam PHP</a></li>
<li><a href="../id450814/index.html">Bagaimana BGP Bekerja</a></li>
<li><a href="../id450816/index.html">Tajuk HTTP untuk pengembang yang bertanggung jawab</a></li>
<li><a href="../id450820/index.html">Komite program FrontendConf: kerangka kerja, cakrawala, pengalaman dunia dan misi konferensi</a></li>
<li><a href="../id450822/index.html">Kerangka kerja yang hilang</a></li>
<li><a href="../id450824/index.html">Keadaan css</a></li>
<li><a href="../id450826/index.html">Cara berbicara dengan mikrokontroler dari JS</a></li>
<li><a href="../id450828/index.html">Ketika kota tertidur ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>