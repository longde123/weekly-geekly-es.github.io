<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî† üïµüèø ü§ûüèº Hacer el bien haciendo el mal: escribir c√≥digo malvado con Go, Parte 1 üçà üñï ‚Ñ¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malos consejos para un programador de Go 


 Despu√©s de d√©cadas de programaci√≥n en Java, los √∫ltimos a√±os trabaj√© principalmente en Go. Trabajar con G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacer el bien haciendo el mal: escribir c√≥digo malvado con Go, Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460645/"><h4>  <i>Malos consejos para un programador de Go</i> </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/72b/d9b/1c972bd9b185f33a0348abfd7d81e470.png" alt="imagen"><br><br>  Despu√©s de d√©cadas de programaci√≥n en Java, los √∫ltimos a√±os trabaj√© principalmente en Go.  Trabajar con Go es excelente, principalmente porque el c√≥digo es muy f√°cil de seguir.  Java ha simplificado el modelo de programaci√≥n C ++ al eliminar la herencia m√∫ltiple, la administraci√≥n manual de memoria y la sobrecarga del operador.  Go hace lo mismo, contin√∫a avanzando hacia un estilo de programaci√≥n simple y directo, eliminando por completo la herencia y la sobrecarga de funciones.  El c√≥digo simple es un c√≥digo legible y el c√≥digo legible es un c√≥digo compatible.  Y esto es excelente para la empresa y mis empleados. <br><br>  Como en todas las culturas, el desarrollo de software tiene sus propias leyendas, historias que son contadas por el enfriador de agua.  Todos escuchamos acerca de desarrolladores que, en lugar de enfocarse en crear un producto de calidad, se enfocan en proteger su propio trabajo de personas externas.  No necesitan c√≥digo compatible, porque significa que otras personas podr√°n comprenderlo y modificarlo.  ¬øEs posible en Go?  ¬øEs posible hacer que el c√≥digo Go sea tan complicado?  Dir√© de inmediato: esta no es una tarea f√°cil.  Veamos las posibles opciones. <br><a name="habracut"></a><br>  Piensa: ‚Äú <i>¬øCu√°nto puede corroer el c√≥digo en un lenguaje de programaci√≥n?</i>  <i>¬øEs posible escribir un c√≥digo tan horrible en Go que su autor se vuelva indispensable en la empresa?</i>  ¬ªNo te preocupes.  Cuando era estudiante, ten√≠a un proyecto en el que apoyaba el c√≥digo Lisp-e de otra persona escrito por un estudiante graduado.  De hecho, logr√≥ escribir c√≥digo Fortran-e usando Lisp.  El c√≥digo se parec√≠a a esto: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> add-mult-pi (<span class="hljs-name"><span class="hljs-name">in1</span></span> in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> a in1) (<span class="hljs-name"><span class="hljs-name">setq</span></span> b in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> c (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> d (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">3.1415</span></span> c) d )</code> </pre> <br>  Hab√≠a docenas de archivos de dicho c√≥digo.  Era absolutamente terrible y absolutamente brillante al mismo tiempo.  Pas√© meses tratando de resolverlo.  Comparado con esto, escribir c√≥digo incorrecto en Go es solo una saliva. <br><br>  Hay muchas formas diferentes de hacer que su c√≥digo no sea compatible, pero solo veremos algunas.  Para hacer el mal, primero debes aprender a hacer el bien.  Por lo tanto, primero observamos c√≥mo escriben los "buenos" programadores de Go, y luego vemos c√≥mo hacer lo contrario. <br><br><h3>  Mal embalaje </h3><br>  Los paquetes son un tema √∫til para comenzar.  ¬øC√≥mo puede la organizaci√≥n del c√≥digo perjudicar la legibilidad? <br><br>  En Go, el nombre del paquete se usa para referirse a la entidad exportada (por ejemplo, ` <i>fmt.Println`</i> <i>o` http.RegisterFunc`</i> ).  Como podemos ver el nombre del paquete, los programadores "buenos" de Go se aseguran de que este nombre describa cu√°les son las entidades exportadas.  No deber√≠amos tener paquetes de <i>utilidades</i> , porque nombres como ` <i>util.JSONMarshal`</i> no funcionar√°n para nosotros, necesitamos` <i>json.Marshal`</i> . <br><br>  Los desarrolladores "buenos" de Go tampoco crean un paquete separado para el DAO o el modelo.  Para aquellos que no est√°n familiarizados con este t√©rmino, un DAO es un " <i>objeto de acceso a datos</i> ", una capa de c√≥digo que interact√∫a con su base de datos.  Sol√≠a ‚Äã‚Äãtrabajar para una compa√±√≠a donde 6 servicios Java importaron la misma biblioteca DAO para acceder a la misma base de datos, que compartieron, porque " <i>... bueno, ya sabes, los microservicios son los mismos ...</i> ". <br><br>  Si tiene un paquete separado con todos sus DAO, entonces es m√°s probable que obtenga una dependencia circular entre paquetes, lo cual est√° prohibido en Go.  Y si tiene varios servicios que incluyen este paquete DAO como biblioteca, tambi√©n puede encontrar una situaci√≥n en la que un cambio en un servicio requiere la actualizaci√≥n de todos sus servicios, de lo contrario, algo se romper√°.  Esto se llama un monolito distribuido y es incre√≠blemente dif√≠cil de actualizar. <br><br>  Cuando sabes c√≥mo deber√≠a funcionar el empaque y lo que lo empeora, "comenzar a servir al mal" se vuelve simple.  Organice mal su c√≥digo y d√© a sus paquetes nombres incorrectos.  Divide tu c√≥digo en paquetes como <i>model</i> , <i>util</i> y <i>dao</i> .  Si realmente quieres comenzar a crear caos, intenta crear paquetes en honor a tu gato o tu color favorito.  Cuando las personas se enfrentan a dependencias c√≠clicas o monolitos distribuidos debido a que intentan usar su c√≥digo, tienen que suspirar, poner los ojos en blanco y decirles que simplemente hacen mal ... <br><br><h3>  Interfaces inapropiadas </h3><br>  Ahora que todos nuestros paquetes est√°n da√±ados, podemos pasar a las interfaces.  Las interfaces en Go no son como las interfaces en otros idiomas.  El hecho de que no declare expl√≠citamente que este tipo implementa la interfaz al principio parece insignificante, pero de hecho revierte completamente el concepto de interfaces. <br><br>  En la mayor√≠a de los idiomas con tipos abstractos, una interfaz se define antes o al mismo tiempo que la implementaci√≥n.  Tendr√° que hacer esto al menos para las pruebas.  Si no crea la interfaz por adelantado, no puede insertarla m√°s tarde sin romper todo el c√≥digo que usa esta clase.  Porque debe reescribirlo con un enlace a la interfaz en lugar de un tipo espec√≠fico. <br><br>  Por esta raz√≥n, el c√≥digo Java a menudo tiene interfaces de servicio gigantescas con muchos m√©todos.  Las clases que implementan estas interfaces utilizan los m√©todos que necesitan e ignoran el resto.  Es posible escribir pruebas, pero agrega un nivel adicional de abstracci√≥n, y al escribir pruebas, a menudo recurre al uso de herramientas para generar implementaciones de esos m√©todos que no necesita. <br><br>  En Go, las interfaces impl√≠citas determinan qu√© m√©todos necesita usar.  El c√≥digo posee una interfaz, no al rev√©s.  Incluso si usa un tipo con muchos m√©todos definidos en √©l, puede especificar una interfaz que incluya solo los m√©todos que necesita.  Otro c√≥digo que use campos separados del mismo tipo definir√° otras interfaces que cubren solo la funcionalidad que se necesita.  Por lo general, estas interfaces tienen solo un par de m√©todos. <br><br>  Esto facilita la comprensi√≥n de su c√≥digo, ya que una declaraci√≥n de m√©todo no solo determina qu√© datos necesita, sino que tambi√©n indica con precisi√≥n qu√© funcionalidad va a utilizar.  Esta es una de las razones por las que los buenos desarrolladores de Go siguen el consejo: " <i>Aceptar interfaces, devolver estructuras</i> ". <br><br>  Pero solo porque esta sea una buena pr√°ctica no significa que debas hacer eso ... <br>  La mejor manera de hacer que sus interfaces sean "malvadas" es volver a los principios del uso de interfaces de otros idiomas, es decir.  Defina las interfaces de antemano como parte del c√≥digo que se llama.  Defina interfaces enormes con muchos m√©todos que utilizan todos los clientes de servicio.  No queda claro qu√© m√©todos son realmente necesarios.  Esto complica el c√≥digo, y la complicaci√≥n, como saben, es la mejor amiga de un programador "malvado". <br><br><h3>  Pasar punteros de mont√≥n </h3><br>  Antes de explicar lo que esto significa, debes filosofar un poco.  Si distrae y piensa, cada programa escrito hace lo mismo.  Recibe datos, los procesa y luego env√≠a los datos procesados ‚Äã‚Äãa otra ubicaci√≥n.  Esto es as√≠, independientemente de si escribe un sistema de n√≥mina, acepta solicitudes HTTP y devuelve p√°ginas web, o incluso comprueba el joystick para rastrear el clic de un bot√≥n: los programas procesan los datos. <br><br>  Si observamos los programas de esta manera, lo m√°s importante es asegurarnos de que nos sea f√°cil entender c√≥mo se convierten los datos.  Por lo tanto, es una buena pr√°ctica mantener los datos sin cambios durante el mayor tiempo posible durante el programa.  Porque los datos que no cambian son datos f√°ciles de rastrear. <br><br>  En Go, tenemos tipos de referencia y tipos de valores.  La diferencia entre los dos es si la variable se refiere a una copia de los datos o a la ubicaci√≥n de los datos en la memoria.  Los punteros, sectores, mapas, canales, interfaces y funciones son tipos de referencia, y todo lo dem√°s es un tipo de valor.  Si asigna una variable de tipo de valor a otra variable, se crea una copia del valor;  cambiar una variable no cambia el valor de otra. <br><br>  Asignar una variable de un tipo de referencia a otra variable de un tipo de referencia significa que ambas comparten la misma √°rea de memoria, por lo que si cambia los datos a los que apunta el primero, cambia los datos a los que apunta el segundo.  Esto es cierto tanto para las variables locales como para los par√°metros de la funci√≥n. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  a := 1 b := a b = 2 fmt.Println(a, b) // prints 1 2 //  c := &amp;a *c = 3 fmt.Println(a, b, *c) // prints 3 2 3 }</span></span></code> </pre> <br>  Los desarrolladores de Kind Go quieren que sea m√°s f√°cil entender c√≥mo se recopilan los datos.  Intentan utilizar el tipo de valores como par√°metros de funciones con la mayor frecuencia posible.  No hay forma en Ir de marcar campos en estructuras o par√°metros de funciones como finales.  Si una funci√≥n usa par√°metros de valor, cambiar los par√°metros no cambiar√° las variables en la funci√≥n de llamada.  Todo lo que puede hacer la funci√≥n llamada es devolver el valor a la funci√≥n de llamada.  Por lo tanto, si completa una estructura llamando a una funci√≥n con par√°metros de valor, no puede temer transferir datos a la estructura, porque comprende de d√≥nde proviene cada campo de la estructura. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,i*<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := Foo{} fA = getA() fB = getB(fA) <span class="hljs-comment"><span class="hljs-comment">//  ,    f fmt.Println(f) }</span></span></code> </pre> <br>  Bueno, ¬øc√≥mo nos convertimos en "malvados"?  Muy simple: darle la vuelta a este modelo. <br><br>  En lugar de llamar a funciones que devuelven los valores deseados, pasa un puntero a la estructura en la funci√≥n y les permite realizar cambios en la estructura.  Como cada funci√≥n tiene su propia estructura, la √∫nica forma de descubrir qu√© campos est√°n cambiando es mirar el c√≥digo completo.  Tambi√©n puede tener dependencias impl√≠citas entre funciones: la primera funci√≥n transfiere los datos que necesita la segunda funci√≥n.  Pero en el c√≥digo en s√≠, nada indica que primero debe llamar a la primera funci√≥n.  Si construye sus estructuras de datos de esta manera, puede estar seguro de que nadie entender√° lo que est√° haciendo su c√≥digo. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Foo)</span></span></span></span> { fA = <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   fA! func setB(f *Foo) { fB = fmt.Sprintf("%d", fA*2) } func main() { f := Foo{} setA(&amp;f) setB(&amp;f) // ,  setA  setB //    ? fmt.Println(f) }</span></span></code> </pre> <br><h3>  Superficie de p√°nico </h3><br>  Ahora estamos comenzando a manejar los errores.  Probablemente piense que es malo escribir programas que manejan errores en aproximadamente un 75%, y no dir√© que est√° equivocado.  El c√≥digo Go a menudo se completa con el manejo de errores de pies a cabeza.  Y, por supuesto, ser√≠a conveniente procesarlos de manera no tan sencilla.  Los errores suceden, y manejarlos es lo que diferencia a los profesionales de los principiantes.  El manejo de errores difusos conduce a programas inestables que son dif√≠ciles de depurar y dif√≠ciles de mantener.  A veces ser un "buen" programador significa "esforzarse". <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User, error)</span></span></span></span> { rows, err := dus.DB.Query(<span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> err = rows.Scan(&amp;name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } err = rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Muchos lenguajes, como C ++, Python, Ruby y Java, usan excepciones para manejar errores.  Si algo sale mal, los desarrolladores en estos idiomas lanzan o lanzan una excepci√≥n, esperando que alg√∫n c√≥digo lo maneje.  Por supuesto, el programa espera que el cliente est√© al tanto de un posible error que se produce en una ubicaci√≥n determinada para que sea posible lanzar una excepci√≥n.  Porque, excepto (sin un juego de palabras) excepciones marcadas en Java, no hay nada en la firma del m√©todo en idiomas o funciones que indique que puede ocurrir una excepci√≥n.  Entonces, ¬øc√≥mo saben los desarrolladores de qu√© excepciones preocuparse?  Tienen dos opciones: <br><br><ul><li>  En primer lugar, pueden leer todo el c√≥digo fuente de todas las bibliotecas a las que llama su c√≥digo, y todas las bibliotecas que llaman a las bibliotecas llamadas, etc. </li><li>  En segundo lugar, pueden confiar en la documentaci√≥n.  Puedo ser parcial, pero la experiencia personal no me permite confiar plenamente en la documentaci√≥n. </li></ul><br>  Entonces, ¬øc√≥mo llevamos este mal a Go?  Abusando del p√°nico ( <i>p√°nico</i> ) y la recuperaci√≥n ( <i>recuperaci√≥n</i> ), por supuesto.  El p√°nico est√° dise√±ado para situaciones como "la unidad se cay√≥" o "la tarjeta de red explot√≥".  Pero no para eso: "alguien pas√≥ cadena en lugar de int". <br><br>  Desafortunadamente, otros "desarrolladores menos ilustrados" devolver√°n errores de su c√≥digo.  Por lo tanto, aqu√≠ hay una peque√±a funci√≥n auxiliar de PanicIfErr.  √öselo para convertir los errores de otros desarrolladores en p√°nico. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicIfErr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br>  Puede usar PanicIfErr para envolver los errores de otras personas, comprimir el c√≥digo.  ¬°No m√°s manejo de errores feos!  Cualquier error es ahora un p√°nico.  ¬°Es muy productivo! <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadEvil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span> { rows, err := dus.DB.Query( <span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) PanicIfErr(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id)) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PanicIfErr(rows.Scan(&amp;name)) PanicIfErr(rows.Close()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name} }</code> </pre> <br>  Puede colocar la recuperaci√≥n en alg√∫n lugar m√°s cercano al comienzo del programa, tal vez en su propio <i>middleware</i> .  Y luego diga que no solo procesa errores, sino que tambi√©n limpia el c√≥digo de otra persona.  Hacer el mal haciendo el bien es el mejor tipo de maldad. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">", - ."</span></span>) } }() h.ServeHTTP(rw, req) } ) }</code> </pre> <br><h3>  Establecer efectos secundarios </h3><br>  A continuaci√≥n crearemos un efecto secundario.  Recuerde, el desarrollador "bueno" de Go quiere comprender c√≥mo pasan los datos a trav√©s del programa.  La mejor manera de saber por qu√© pasan los datos es configurar dependencias expl√≠citas en la aplicaci√≥n.  Incluso las entidades que corresponden a la misma interfaz pueden variar mucho en el comportamiento.  Por ejemplo, un c√≥digo que almacena datos en la memoria y un c√≥digo que accede a la base de datos para el mismo trabajo.  Sin embargo, hay formas de instalar dependencias en Go sin llamadas expl√≠citas. <br><br>  Al igual que muchos otros idiomas, Go tiene una forma de ejecutar c√≥digo m√°gicamente sin invocarlo directamente.  Si crea una funci√≥n llamada init sin par√°metros, se iniciar√° autom√°ticamente cuando se cargue el paquete.  Y, para confundir a√∫n m√°s, si en un archivo hay varias funciones con el nombre init o varios archivos en un paquete, todos comenzar√°n. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Account <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UserId <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"   ,     init()"</span></span>) }</code> </pre> <br>  Las funciones de inicio a menudo se asocian con importaciones vac√≠as.  Go tiene una forma especial de declarar importaciones, que se ve como `import _" github.com / lib / pq`.  Cuando configura un identificador de nombre vac√≠o para un paquete importado, el m√©todo init se ejecuta en √©l, pero no muestra ninguno de los identificadores de paquete.  Para algunas bibliotecas Go, como controladores de bases de datos o formatos de imagen, debe cargarlos habilitando la importaci√≥n de paquetes vac√≠os, solo para llamar a la funci√≥n init para que el paquete pueda registrar su c√≥digo. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := sql.Open( <span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgres://jon@localhost/evil?sslmode=disable"</span></span>) }</code> </pre><br>  Y esta es claramente una opci√≥n "malvada".  Cuando usa la inicializaci√≥n, el c√≥digo que funciona m√°gicamente est√° completamente fuera del control del desarrollador.  Las mejores pr√°cticas no recomiendan usar las funciones de inicializaci√≥n: estas son caracter√≠sticas no obvias, confunden el c√≥digo y son f√°ciles de ocultar en la biblioteca. <br><br>  En otras palabras, las funciones init son ideales para nuestros prop√≥sitos malvados.  En lugar de configurar o registrar expl√≠citamente entidades en paquetes, puede usar las funciones de inicializaci√≥n e importaci√≥n vac√≠a para configurar el estado de su aplicaci√≥n.  En este ejemplo, ponemos la cuenta a disposici√≥n del resto de la aplicaci√≥n a trav√©s del registro, y el paquete en s√≠ se coloca en el registro utilizando la funci√≥n init. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubAccountService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a StubAccountService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(accountId </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { registry.Register(<span class="hljs-string"><span class="hljs-string">"account"</span></span>, StubAccountService{}) }</code> </pre> <br>  Si desea utilizar una cuenta, coloque una importaci√≥n vac√≠a en su programa.  No tiene que ser el c√≥digo principal o relacionado, solo tiene que estar "en alguna parte".  Esto es magico! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/account"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Balancer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetBalance(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := registry.Get(<span class="hljs-string"><span class="hljs-string">"account"</span></span>).(Balancer) money := a.GetBalance(<span class="hljs-number"><span class="hljs-number">12345</span></span>) }</code> </pre> <br>  Si usa inits en sus bibliotecas para configurar dependencias, ver√° de inmediato que otros desarrolladores est√°n desconcertando c√≥mo se instalaron estas dependencias y c√≥mo cambiarlas.  Y nadie ser√° m√°s sabio que t√∫. <br><br><h3>  Configuraci√≥n complicada </h3><br>  Todav√≠a hay mucho de todo lo que podemos hacer con la configuraci√≥n.  Si es un desarrollador de Go "bueno", querr√° aislar la configuraci√≥n del resto del programa.  En la funci√≥n main (), obtiene variables del entorno y las convierte a los valores necesarios para los componentes que est√°n expl√≠citamente relacionados entre s√≠.  Sus componentes no saben nada acerca de los archivos de configuraci√≥n o c√≥mo se llaman sus propiedades.  Para componentes simples, establece propiedades p√∫blicas, y para las m√°s complejas, puede crear una funci√≥n de f√°brica que recibe informaci√≥n de configuraci√≥n y devuelve un componente configurado correctamente. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, err := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"error reading config file: %v"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) prefix := m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) maker := account.NewMaker(prefix) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Maker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { prefix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m Maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maker</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Maker{prefix: prefix} }</code> </pre> <br>  Pero los desarrolladores "malvados" saben que es mejor dispersar la informaci√≥n sobre la configuraci√≥n en todo el programa.  En lugar de tener una funci√≥n en un paquete que defina los nombres y los tipos de valor para su paquete, use una funci√≥n que tome la configuraci√≥n como est√° y la convierta por s√≠ sola. <br><br>  Si esto parece demasiado "malo", use la funci√≥n init para cargar el archivo de propiedades desde su paquete y establezca los valores usted mismo.  Puede parecer que ha facilitado la vida de otros desarrolladores, pero usted y yo sabemos ... <br><br>  Usando la funci√≥n init, puede definir nuevas propiedades en la parte posterior del c√≥digo, y nadie las encontrar√° hasta que entren en producci√≥n y todo se caiga, porque algo no entrar√° en una de las docenas de archivos de propiedades necesarios para ejecutarse.  Si desea a√∫n m√°s "poder maligno", puede sugerir crear un wiki para realizar un seguimiento de todas las propiedades en todas las bibliotecas y para "olvidar" agregar peri√≥dicamente nuevas.  Como Property Keeper, te conviertes en la √∫nica persona que puede ejecutar el software. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Maker maker <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, _ := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) Maker.prefix = m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) }</code> </pre> <br><h3>  Marcos de funcionalidad </h3><br>  Finalmente, llegamos al tema de frameworks vs bibliotecas.  La diferencia es muy sutil.  No se trata solo del tama√±o;  puede tener bibliotecas grandes y marcos peque√±os.  El marco llama a su c√≥digo mientras usted llama al c√≥digo de la biblioteca usted mismo.  Los marcos requieren que escriba su c√≥digo de cierta manera, ya sea nombrando sus m√©todos de acuerdo con reglas espec√≠ficas, o que correspondan a interfaces espec√≠ficas, o lo obliguen a registrar su c√≥digo en el marco.  Los marcos tienen sus propios requisitos para todo su c√≥digo.  Es decir, en general, los marcos lo mandan. <br><br>  Go fomenta el uso de bibliotecas porque las bibliotecas est√°n vinculadas.  Aunque, por supuesto, cada biblioteca espera que los datos se transmitan en un formato espec√≠fico, puede escribir alg√∫n c√≥digo de conexi√≥n para convertir la salida de una biblioteca en entrada para otra. <br>  Es dif√≠cil lograr que los marcos funcionen juntos sin problemas porque cada marco quiere un control completo sobre el ciclo de vida del c√≥digo.  A menudo, la √∫nica forma de lograr que los marcos funcionen juntos es que los autores del marco se re√∫nan y organicen claramente el apoyo mutuo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y la mejor manera de usar los "marcos malvados" para obtener poder a largo plazo es escribir su propio marco, que se usa solo dentro de la empresa. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mal actual y futuro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de dominar estos trucos, siempre se embarcar√° en el camino del mal. </font><font style="vertical-align: inherit;">En la segunda parte, le mostrar√© c√≥mo desplegar todo este "mal" y c√≥mo convertir un c√≥digo "bueno" en uno "malo".</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460645/">https://habr.com/ru/post/460645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460633/index.html">Detalles de implementaci√≥n para RSTP y redundancia de anillo extendida patentada</a></li>
<li><a href="../460635/index.html">CLRium # 6: concurrencia y paralelismo. Dos d√≠as: del procesador a as√≠ncrono / espera</a></li>
<li><a href="../460637/index.html">Control de luz en ZigBee</a></li>
<li><a href="../460641/index.html">YouTokenToMe: una herramienta para la tokenizaci√≥n r√°pida de texto del equipo de VKontakte</a></li>
<li><a href="../460643/index.html">Distribuci√≥n uniforme de puntos en una esfera.</a></li>
<li><a href="../460647/index.html">Resolver un trabajo con pwnable.kr 05 - c√≥digo de acceso. Vuelva a escribir la tabla de enlaces del procedimiento a trav√©s de la vulnerabilidad de cadena de formato</a></li>
<li><a href="../460651/index.html">Reuni√≥n de la Society of Anonymous Testers: TMS, monitoreo de monitoreo, evaluaci√≥n de calidad de b√∫squeda y pruebas nativas de iOS</a></li>
<li><a href="../460655/index.html">C√≥mo romp√≠ Telegram</a></li>
<li><a href="../460659/index.html">Usando tuber√≠as para pivotar</a></li>
<li><a href="../460661/index.html">Todo lo que necesitas saber sobre Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>