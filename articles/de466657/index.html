<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÇÔ∏è üôèüèΩ ü§∞üèº Dynamisches Detail: verdeckte Compiler-Spiele, Speicherverlust, Leistungsnuancen ü¶ç ‚ôèÔ∏è ü§®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorspiel 

 Betrachten Sie den folgenden Code: 



//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dynamisches Detail: verdeckte Compiler-Spiele, Speicherverlust, Leistungsnuancen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466657/"><h2>  Vorspiel </h2><br><br>  Betrachten Sie den folgenden Code: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  Die Signatur der <i>Marshal.FinalReleaseComObject-</i> Methode lautet wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalReleaseComObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object o</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><br>  Wir erstellen ein einfaches COM-Objekt, erledigen einige Arbeiten und geben es sofort frei.  Es scheint, dass was schief gehen k√∂nnte?  Ja, das Erstellen eines Objekts in einer Endlosschleife ist keine gute Vorgehensweise, aber der <i>GC</i> √ºbernimmt die gesamte Drecksarbeit.  Die Realit√§t sieht etwas anders aus: <br><br><img src="https://habrastorage.org/webt/mt/xo/rx/mtxorxomorvksyskqgtn3b3z7_g.png"><br><br>  Um zu verstehen, warum Speicherlecks auftreten, m√ºssen Sie verstehen, wie <i>Dynamik</i> funktioniert.  Es gibt bereits mehrere Artikel zu diesem Thema √ºber Habr√©, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen</a> , aber sie gehen nicht auf Details der Implementierung ein, daher werden wir unsere eigenen Forschungen durchf√ºhren. <br><br><a name="habracut"></a><br><br>  Zuerst werden wir den <i>dynamischen</i> Arbeitsmechanismus im Detail untersuchen, dann werden wir das erworbene Wissen auf ein einziges Bild reduzieren und am Ende werden wir die Gr√ºnde f√ºr dieses Leck diskutieren und wie es vermieden werden kann.  Lassen Sie uns vor dem Eintauchen in den Code die Quelldaten kl√§ren: Welche Kombination von Faktoren f√ºhrt zum Leck? <br><br><h2>  Die Experimente </h2><br><br>  Vielleicht ist das Erstellen vieler <i>nativer COM-</i> Objekte an sich eine schlechte Idee?  Lassen Sie uns √ºberpr√ºfen: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); }</span></span></code> </pre> <br><br>  Diesmal ist alles gut: <br><br><img src="https://habrastorage.org/webt/l2/x4/01/l2x401f_4vsbrysnx1zctwoyfjk.png"><br><br>  Kehren wir zur urspr√ºnglichen Version des Codes zur√ºck, √§ndern Sie jedoch den Objekttyp: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any managed type include managed COM var type = typeof(int); while (true) { dynamic com = Activator.CreateInstance(type); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  Und wieder keine √úberraschungen: <br><br><img src="https://habrastorage.org/webt/09/lm/bv/09lmbvpiklt9lo43b1fv9wzhdhu.png"><br><br>  Versuchen wir die dritte Option: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject((object) com); }</span></span></code> </pre> <br><br>  Nun, wir sollten definitiv das gleiche Verhalten bekommen!  Huh?  Nein :( <br><br><img src="https://habrastorage.org/webt/uu/2p/l1/uu2pl1_xtrmpc4kuuy3mwdh_7la.png"><br><br>  Ein √§hnliches Bild wird angezeigt, wenn Sie com als <i>Objekt</i> deklarieren oder mit <i>Managed COM arbeiten</i> .  Fassen Sie die experimentellen Ergebnisse zusammen: <br><br><ol><li>  Das Instanziieren <i>nativer COM-</i> Objekte selbst f√ºhrt nicht zu Lecks - <i>GC</i> bew√§ltigt erfolgreich das L√∂schen des Speichers </li><li>  Bei der Arbeit mit einer <i>verwalteten</i> Klasse treten keine Lecks auf </li><li>  Wenn Sie ein Objekt explizit in ein Objekt <i>umwandeln</i> , ist auch alles in Ordnung </li></ol><br><br>  Mit Blick auf die Zukunft k√∂nnen wir zum ersten Punkt hinzuf√ºgen, dass das Arbeiten mit <i>dynamischen</i> Objekten (Aufrufen von Methoden oder Arbeiten mit Eigenschaften) f√ºr sich genommen ebenfalls keine Lecks verursacht.  Die Schlussfolgerung bietet sich an: Ein Speicherverlust tritt auf, wenn wir ein <i>dynamisches</i> Objekt (ohne "manuelle" Typkonvertierung) √ºbergeben, das <i>natives COM</i> als Methodenparameter enth√§lt. <br><br><h2>  Wir m√ºssen tiefer gehen </h2><br><br>  Es ist Zeit, sich daran zu erinnern, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">worum es bei</a> dieser <i>Dynamik</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geht</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Kurzanleitung</b> <div class="spoiler_text"><blockquote>  C # 4.0 bietet eine neue Art von <b>Dynamik</b> .  Dieser Typ vermeidet die statische Typpr√ºfung durch den Compiler.  In den meisten F√§llen funktioniert es als <b>Objekttyp</b> .  Bei der Kompilierung wird davon ausgegangen, dass ein als <b>dynamisch</b> deklariertes Element jede Operation unterst√ºtzt.  Dies bedeutet, dass Sie nicht dar√ºber nachdenken m√ºssen, woher das Objekt stammt - von der COM-API, einer dynamischen Sprache wie IronPython, mithilfe von Reflection oder von einem anderen Ort.  Wenn der Code ung√ºltig ist, werden au√üerdem zur Laufzeit Fehler ausgegeben. <br><br>  Wenn beispielsweise die <b>exampleMethod1-</b> Methode im folgenden Code genau einen Parameter enth√§lt, erkennt der Compiler, dass der erste Aufruf der <b>ec.exampleMethod1 (10, 4)</b> -Methode ung√ºltig ist, da sie zwei Parameter enth√§lt.  Dies f√ºhrt zu einem Kompilierungsfehler.  Der zweite Methodenaufruf, <b>dynamic_ec.exampleMethod1 (10, 4), wird</b> vom Compiler nicht gepr√ºft, da <b>dynamic_ec daher</b> als <b>dynamisch</b> deklariert wird.  Es werden keine Kompilierungsfehler angezeigt.  Trotzdem bleibt der Fehler nicht f√ºr immer unbemerkt - er wird zur Laufzeit erkannt. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { ExampleClass ec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleClass(); <span class="hljs-comment"><span class="hljs-comment">//      ,  exampleMethod1    . //ec.exampleMethod1(10, 4); dynamic dynamic_ec = new ExampleClass(); //      ,  //      dynamic_ec.exampleMethod1(10, 4); //        ,  //  ,      dynamic_ec.someMethod("some argument", 7, null); dynamic_ec.nonexistentMethod(); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleClass</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br></blockquote><br></div></div><br><br>  Code, der <i>dynamische</i> Variablen verwendet, wird w√§hrend der Kompilierung erheblich ge√§ndert.  Dieser Code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); Marshal.FinalReleaseComObject(com);</code> </pre> <br><br>  Wird zu folgendem: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(typeFromClsid); <span class="hljs-comment"><span class="hljs-comment">// ISSUE: reference to a compiler-generated field if (Foo.o__0.p__0 == null) { // ISSUE: reference to a compiler-generated field Foo.o__0.p__0 = CallSite&lt;Action&lt;CallSite, Type, object&gt;&gt;.Create(Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "FinalReleaseComObject", (IEnumerable&lt;Type&gt;) null, typeof (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null) })); } // ISSUE: reference to a compiler-generated field // ISSUE: reference to a compiler-generated field Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, typeof (Marshal), instance);</span></span></code> </pre> <br><br>  Dabei ist <b>o__0</b> die generierte statische Klasse und <b>p__0</b> das statische Feld darin: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">o__0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite&lt;Action&lt;CallSite, Type, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt; p__0; }</code> </pre> <br><br>  <i>Hinweis: F√ºr jede Interaktion mit <i>Dynamic</i> wird ein CallSite-Feld erstellt.</i>  <i>Dies ist, wie sp√§ter zu sehen sein wird, erforderlich, um die Leistung zu optimieren.</i> <br><br>  Beachten Sie, dass keine Erw√§hnung von <i>Dynamik</i> √ºbrig bleibt - unser Objekt wird jetzt in einer Variablen vom Typ <i>Objekt</i> gespeichert.  Lassen Sie uns den generierten Code durchgehen.  Zun√§chst wird eine Bindung erstellt, die beschreibt, was und was wir tun: <br><br><pre> <code class="cs hljs">Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"FinalReleaseComObject"</span></span>, (IEnumerable&lt;Type&gt;) <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>) })</code> </pre> <br><br>  Dies ist eine Beschreibung unseres dynamischen Betriebs.  Ich <i>m√∂chte</i> Sie daran erinnern, dass wir eine <i>dynamische</i> Variable an die <i>FinalReleaseComObject-</i> Methode √ºbergeben. <br><br><ul><li>  CSharpBinderFlags.ResultDiscarded - Das Ergebnis der Methodenausf√ºhrung wird in Zukunft nicht mehr verwendet </li><li>  "FinalReleaseComObject" - der Name der aufgerufenen Methode </li><li>  typeof (Foo) - Operationskontext;  die Art des Anrufs </li></ul><br><br>  <b>CSharpArgumentInfo</b> - Beschreibung der Bindungsparameter.  In unserem Fall: <br><br><ul><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null) - Beschreibung des ersten Parameters - der Marshal-Klasse: Es ist statisch und sein Typ sollte beim Binden ber√ºcksichtigt werden </li><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.None, (string) null) - Beschreibung des Methodenparameters, normalerweise gibt es keine zus√§tzlichen Informationen. </li></ul><br><br>  Wenn es nicht darum geht, eine Methode aufzurufen, sondern beispielsweise eine Eigenschaft von einem <i>dynamischen</i> Objekt aus <b>aufzurufen</b> , gibt es nur eine <b>CSharpArgumentInfo</b> , die das <i>dynamische</i> Objekt selbst beschreibt. <br><br>  <b>CallSite</b> ist ein Wrapper √ºber einen dynamischen Ausdruck.  Es enth√§lt zwei wichtige Felder f√ºr uns: <br><br><ul><li>  √∂ffentliches T-Update </li><li>  √∂ffentliches T-Ziel </li></ul><br><br>  Aus dem generierten Code geht hervor, dass <b>Target</b> bei jeder Operation mit Parametern aufgerufen wird, die es beschreiben: <br><br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Marshal), instance);</code> </pre> <br><br>  In Verbindung mit der <b>oben</b> beschriebenen <b>CSharpArgumentInfo</b> bedeutet dieser Code Folgendes: Sie m√ºssen die FinalReleaseComObject-Methode f√ºr die statische Marshal-Klasse mit dem Instanzparameter aufrufen.  Zum Zeitpunkt des ersten Aufrufs wird in <b>Target</b> derselbe Delegat gespeichert wie in <b>Update</b> .  Der <b>Update-</b> Delegierte ist f√ºr zwei wichtige Aufgaben verantwortlich: <br><br><ol><li>  Binden einer dynamischen Operation an eine statische (der Biding-Mechanismus selbst geht √ºber den Rahmen dieses Artikels hinaus) </li><li>  Cache-Bildung </li></ol><br><br>  Wir interessieren uns f√ºr den zweiten Punkt.  Hierbei ist zu beachten, dass bei der Arbeit mit einem dynamischen Objekt jedes Mal die G√ºltigkeit der Operation √ºberpr√ºft werden muss.  Dies ist eine ziemlich ressourcenintensive Aufgabe, daher m√∂chte ich die Ergebnisse solcher √úberpr√ºfungen zwischenspeichern.  Beim Aufrufen einer Methode mit einem Parameter m√ºssen wir Folgendes beachten: <br><br><ol><li>  Der Typ, f√ºr den die Methode aufgerufen wird </li><li>  Der Objekttyp, der vom Parameter √ºbergeben wird (um sicherzustellen, dass er in den Typ des Parameters umgewandelt werden kann). </li><li>  Ist die Operation g√ºltig? </li></ol><br><br>  Wenn Sie <b>Target</b> erneut aufrufen, m√ºssen Sie keine relativ teuren Bindungen ausf√ºhren: Vergleichen Sie einfach die Typen und rufen Sie, wenn sie √ºbereinstimmen, die Zielfunktion auf.  Um dieses Problem zu l√∂sen, wird f√ºr jede dynamische Operation ein <i>ExpressionTree</i> erstellt, in dem die <i>Einschr√§nkungen</i> und die <i>Zielfunktion gespeichert sind,</i> an die der dynamische Ausdruck gebunden wurde. <br><br>  Es gibt zwei Arten von Funktionen: <br><br><ul><li>  <i>Bindungsfehler</i> : Beispielsweise wird eine Methode f√ºr ein <i>dynamisches</i> Objekt aufgerufen, das nicht vorhanden ist, oder ein <i>dynamisches</i> Objekt kann nicht in den Typ des Parameters konvertiert werden, an den es √ºbergeben wird. Anschlie√üend m√ºssen Sie eine Ausnahme wie <i>Microsoft.CSharp.RuntimeBinderException: 'NoSuchMember' ausl√∂sen.</i> </li><li>  Die Herausforderung ist legal: F√ºhren Sie dann einfach die erforderliche Aktion aus </li></ul><br><br>  Dieser <i>ExpressionTree</i> wird w√§hrend der Ausf√ºhrung des <b>Update-</b> Delegaten gebildet und in <b>Target</b> gespeichert.  <b>Ziel</b> - <i>L0-</i> Cache, wir werden sp√§ter mehr √ºber den Cache sprechen. <br><br>  Daher speichert <b>Target</b> den letzten <i>ExpressionTree</i> , der durch den <b>Update-</b> Delegaten generiert wurde.  Lassen Sie uns sehen, wie diese <i>Regel</i> wie ein Beispiel f√ºr einen <i>verwalteten</i> Typ aussieht, der an die <i>Boo-</i> Methode √ºbergeben wird: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> instance = Activator.CreateInstance(type); Boo(instance); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso ($arg1 TypeEqual Int32)), returnUnamedLabel_0 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  Der wichtigste Block f√ºr uns: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32)</code> </pre> <br><br>  <i>$$ arg0</i> und <i>$$ arg1</i> sind die Parameter, mit denen <b>Target</b> aufgerufen wird: <br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;);</code> </pre> <br><br>  In menschlich √ºbersetzt bedeutet dies Folgendes: <br><br>  Wir haben bereits √ºberpr√ºft, dass Sie <i>Boo ((Objekt) $$ arg1)</i> sicher aufrufen k√∂nnen, wenn der erste Parameter vom Typ <i>Foo</i> und der zweite <i>Int32</i> ist. <br><br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) }</span></span></code> </pre> <br><br>  <i>Hinweis: Im Falle eines Bindungsfehlers sieht der Label1-Block ungef√§hr so ‚Äã‚Äãaus:</i> <br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Throw .New Microsoft.CSharp.RuntimeBinderException("NoSuchMember")</span></span></code> </pre> <br><br>  Diese Pr√ºfungen werden als <b>Einschr√§nkungen bezeichnet</b> .  <b>Es</b> gibt zwei Arten von <b>Einschr√§nkungen</b> : nach Objekttyp und nach spezifischer Instanz des Objekts (das Objekt muss genau gleich sein).  Wenn mindestens eine der Einschr√§nkungen fehlschl√§gt, m√ºssen wir den dynamischen Ausdruck erneut auf G√ºltigkeit √ºberpr√ºfen. Dazu rufen wir den <b>Update-</b> Delegaten auf.  Nach dem uns bereits bekannten Schema wird er die Bindung mit neuen Typen durchf√ºhren und den neuen <i>ExpressionTree</i> in <b>Target</b> speichern. <br><br><h2>  Cache </h2><br><br>  Wir haben bereits herausgefunden, dass <b>Target</b> ein <b>L0-Cache ist</b> .  Jedes Mal, wenn <b>Target</b> aufgerufen wird, gehen wir zuerst die bereits darin gespeicherten Einschr√§nkungen durch.  Wenn die Einschr√§nkungen fehlschlagen und eine neue Bindung generiert wird, geht die alte Regel gleichzeitig zu <b>L1</b> und <b>L2</b> .  Wenn Sie in Zukunft den <i>L0-</i> Cache verpassen, werden die Regeln von <i>L1</i> und <i>L2</i> durchsucht, bis eine geeignete gefunden wird. <br><br><ul><li>  <i>L1</i> : Die letzten zehn Regeln, die <i>L0 verlassen haben</i> (direkt in <i>CallSite</i> gespeichert) </li><li>  <i>L2</i> : Die letzten 128 Regeln, die mit einer bestimmten Binder-Instanz erstellt wurden ( <i>CallSiteBinder</i> , die f√ºr jede <i>CallSite</i> eindeutig ist). </li></ul><br><br>  Jetzt k√∂nnen wir diese Details endlich zu einem Ganzen hinzuf√ºgen und in Form eines Algorithmus beschreiben, was passiert, wenn <i>Foo.Bar (someDynamicObject) aufgerufen wird</i> : <br><br>  1. Es wird ein Ordner erstellt, der den Kontext und die aufgerufene Methode auf der Ebene ihrer Signaturen speichert <br><br>  2. Beim ersten Aufruf der Operation wird <i>ExpressionTree</i> erstellt, in dem Folgendes gespeichert wird: <br>  2.1 <b>Einschr√§nkungen</b> .  In diesem Fall sind dies zwei Einschr√§nkungen f√ºr die Art der aktuellen Bindungsparameter <br>  2.2 <b>Zielfunktion</b> : entweder <i>eine Ausnahme ausl√∂sen</i> (in diesem Fall ist dies unm√∂glich, da jede <i>Dynamik</i> erfolgreich zum Objekt f√ºhrt) oder einen Aufruf der <i>Bar-</i> Methode <br><br>  3. Kompilieren Sie den resultierenden ExpressionTree und f√ºhren Sie ihn aus <br><br>  4. Wenn Sie sich an die Operation erinnern, sind zwei Optionen m√∂glich: <br>  4.1 <b>Einschr√§nkungen funktionierten</b> : Rufen Sie einfach <i>Bar an</i> <br>  4.2 <b>Einschr√§nkungen haben nicht funktioniert</b> : Wiederholen Sie Schritt 2 f√ºr neue Bindungsparameter <br><br>  Am Beispiel des <i>verwalteten</i> Typs wurde also ungef√§hr klar, wie <i>dynamisch</i> von innen funktioniert.  Im beschriebenen Fall wird der Cache nie √ºbersehen, da die Typen immer gleich sind *. Daher wird <b>Update</b> genau einmal aufgerufen, wenn <i>CallSite</i> initialisiert wird.  Dann werden f√ºr jeden Anruf nur Einschr√§nkungen √ºberpr√ºft und die Zielfunktion wird sofort aufgerufen.  Dies stimmt hervorragend mit unseren Beobachtungen des Ged√§chtnisses √ºberein: keine Berechnung - keine Lecks. <br><br>  <i>* Aus diesem Grund generiert der Compiler seine CallSites f√ºr jede einzelne: Die Wahrscheinlichkeit, dass der L0-Cache fehlt, ist extrem reduziert</i> <br><br>  Es ist Zeit herauszufinden, wie sich dieses Schema bei <i>nativen COM-</i> Objekten unterscheidet.  Werfen wir einen Blick auf <i>ExpressionTree</i> : <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 }) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.__ComObject)$$arg1); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso {var Param_0; ... }), returnUnamedLabel_1 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  Es ist ersichtlich, dass der Unterschied nur in der zweiten Einschr√§nkung liegt: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 })</code> </pre> <br><br>  Wenn wir im Fall von <i>verwaltetem</i> Code zwei Einschr√§nkungen f√ºr den <i>Objekttyp hatten,</i> sehen wir hier, dass die zweite Einschr√§nkung die √Ñquivalenz von Instanzen durch <i>WeakReference √ºberpr√ºft</i> . <br><br>  <i>Hinweis: Die Instanzbeschr√§nkung wird zus√§tzlich zu COM-Objekten auch f√ºr TransparentProxy verwendet</i> <br><br>  In der Praxis bedeutet dies, basierend auf unserem Wissen √ºber die Funktionsweise des Caches, dass jedes Mal, wenn wir ein <i>COM-</i> Objekt in einer Schleife neu erstellen, der <i>L0-</i> Cache (und auch <i>L1 / L2)</i> √ºbersehen wird, da die alten Regeln mit Links dort gespeichert werden zu alten Instanzen).  Die erste Annahme, die Sie im Kopf fragt, ist, dass der Regel-Cache flie√üt.  Aber der Code dort ist recht einfach und dort ist alles in Ordnung: Die alten Regeln werden korrekt gel√∂scht.  Gleichzeitig verhindert die Verwendung von <i>WeakReference</i> in <i>ExpressionTree</i> nicht, dass der <i>GC</i> unn√∂tige Objekte sammelt. <br><br>  <i>Der Mechanismus zum Speichern von Regeln im L1-Cache:</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxRules = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T newRule</span></span></span><span class="hljs-function">)</span></span> { T[] rules = Rules; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Rules = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { newRule }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } T[] temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules.Length &lt; (MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[rules.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, rules.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[MaxRules]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>); } temp[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newRule; Rules = temp; }</code> </pre> <br><br>  Also, was ist los?  Versuchen wir, die Hypothese zu kl√§ren: Beim Binden eines <i>COM-</i> Objekts tritt irgendwo ein Speicherverlust auf. <br><br><h2>  Experimente, Teil 2 </h2><br><br>  Gehen wir noch einmal von spekulativen Schlussfolgerungen zu Experimenten √ºber.  Wiederholen wir zun√§chst, was der Compiler f√ºr uns tut: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); var autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "Boo", null, typeof(Foo), new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }); var callSite = CallSite&lt;Action&lt;CallSite, Foo, object&gt;&gt;.Create(autogeneratedBinder); while (true) { object instance = Activator.CreateInstance(comType); callSite.Target(callSite, this, instance); }</span></span></code> </pre> <br><br>  Wir pr√ºfen: <br><br><img src="https://habrastorage.org/webt/bf/-u/k6/bf-uk6jtzrfh8_pyzaagi0p8cr4.png"><br><br>  Das Leck ist erhalten geblieben.  Fair.  Aber was ist der Grund?  Nach dem Studium des Codes der Ordner (die wir in Klammern lassen) ist klar, dass das einzige, was den Typ unseres Objekts beeinflusst, die Einschr√§nkungsoption ist.  Vielleicht handelt es sich nicht um <i>COM-</i> Objekte, sondern um einen Ordner?  Es gibt nicht viel Auswahl. Lassen Sie uns f√ºr den <i>verwalteten</i> Typ eine Mehrfachbindung provozieren: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"Boo"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Foo), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callSite = CallSite&lt;Action&lt;CallSite, Foo, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;.Create(autogeneratedBinder); callSite.Target(callSite, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, instance); }</code> </pre> <br><br><img src="https://habrastorage.org/webt/-y/an/hj/-yanhjj9jkmqr8bl2adf9rvjsvs.png"><br><br>  Wow!  Es scheint, wir haben ihn gefangen.  Das Problem liegt √ºberhaupt nicht beim <i>COM-Objekt</i> , wie es uns anfangs erschien, nur aufgrund der Einschr√§nkungen der Instanz ist dies der einzige Fall, in dem die Bindung innerhalb unserer Schleife viele Male auftritt.  In allen anderen F√§llen habe ich den <i>L0-Cache aufgerufen</i> und einmal gebunden. <br><br><h2>  Schlussfolgerungen </h2><br><br><h3>  Speicherverlust </h3><br><br>  Wenn Sie mit <i>dynamischen</i> Variablen arbeiten, die <i>natives COM</i> oder <i>TransparentProxy enthalten</i> , √ºbergeben Sie diese niemals als Methodenparameter.  Wenn Sie dies dennoch tun m√ºssen, verwenden Sie die explizite Umwandlung zum <i>Objekt,</i> und der Compiler bleibt hinter Ihnen zur√ºck <br><br>  <b>Falsch</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject(com);</span></span></code> </pre> <br><br>  <b>Richtig</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject((object) com);</span></span></code> </pre><br><br>  Versuchen Sie als zus√§tzliche Vorsichtsma√ünahme, solche Objekte so selten wie m√∂glich zu instanziieren.  Tats√§chlich f√ºr alle Versionen von <i>.NET Framework</i> .  (F√ºrs Erste) ist nicht sehr relevant f√ºr.  <i>NET Core</i> , da <i>dynamische COM-</i> Objekte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht unterst√ºtzt</a> werden. <br><br><h3>  Leistung </h3><br><br>  Es liegt in Ihrem Interesse, dass Cache-Fehler so selten wie m√∂glich auftreten, da in diesem Fall in Caches auf hoher Ebene keine geeignete Regel gefunden werden muss.  Fehler im <i>L0-</i> Cache treten haupts√§chlich bei einer Nicht√ºbereinstimmung des Typs des <i>dynamischen</i> Objekts auf, wobei die Einschr√§nkungen beibehalten werden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = GetSomeObject(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//:      //:         }</span></span></code> </pre> <br><br>  In der Praxis werden Sie den Leistungsunterschied jedoch wahrscheinlich nicht bemerken, es sei denn, die Anzahl der Aufrufe dieser Funktion wird in Millionen gemessen oder die Variabilit√§t der Typen ist nicht ungew√∂hnlich gro√ü.  Die Kosten im Falle eines Fehlschlags im <i>L0-</i> Cache sind solche, <i>N</i> ist die Anzahl der Typen: <br><br><ul><li>  <i>N</i> &lt;10.  Wenn Sie dies verpassen, durchlaufen Sie nur die vorhandenen <i>L1-</i> Cache-Regeln </li><li>  10 &lt; <i>N &lt;128</i> .  Aufz√§hlung des <i>L1-</i> und <i>L2-</i> Cache (maximal 10 und <i>N</i> Iterationen).  Erstellen und Auff√ºllen eines Arrays mit 10 Elementen </li><li>  <i>N</i> &gt; 128.  Iterieren Sie √ºber den <i>L1-</i> und <i>L2-</i> Cache.  Erstellen und f√ºllen Sie Arrays mit 10 und 128 Elementen.  Wenn Sie den <i>L2-</i> Cache verpassen, binden Sie ihn erneut </li></ul><br><br>  Im zweiten und dritten Fall erh√∂ht sich die Belastung des GC. <br><br><h2>  Fazit </h2><br><br>  Leider haben wir keinen wirklichen Grund f√ºr den Speicherverlust gefunden. Dies erfordert eine separate Untersuchung des Binders.  Gl√ºcklicherweise gibt <i>WinDbg</i> einen Hinweis f√ºr weitere Untersuchungen: Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DLR</a> passiert etwas Schlimmes.  Die erste Spalte gibt die Anzahl der Objekte an <br><br><img src="https://habrastorage.org/webt/n_/6g/xf/n_6gxf7etpsj2fg17odfa0varvy.png"><br><br><h2>  Bonus </h2><br><br>  <b>Warum verhindert das Gie√üen auf ein <i>Objekt</i> explizit ein Leck?</b> <br>  Jeder Typ kann in ein <i>Objekt umgewandelt werden</i> , sodass die Operation nicht mehr dynamisch ist. <br><br>  <b>Warum gibt es keine Lecks bei der Arbeit mit Feldern und Methoden eines COM-Objekts?</b> <br>  So sieht <i>ExpressionTree</i> f√ºr den Feldzugriff aus: <br><br><pre> <code class="cs hljs">.If ( .Call System.Dynamic.ComObject.IsComObject($$arg0) ) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Dynamic GetMember ComMarks(.Call System.Dynamic2.ComObject.ObjectToComObject($$arg0)) } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466657/">https://habr.com/ru/post/de466657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466643/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 314 (vom 2. bis 8. September)</a></li>
<li><a href="../de466647/index.html">Telefon f√ºr ein Pferd und ein Orchester ohne Pianisten. Wie man Sportaufgaben am Frontend macht</a></li>
<li><a href="../de466649/index.html">Wochenende mit Elektroauto</a></li>
<li><a href="../de466651/index.html">Auswahl zwischen XML und SQL zum Rollen von LiquiBase-Skripten am Beispiel von Java / Spring / H2</a></li>
<li><a href="../de466653/index.html">Debugging-Spiele f√ºr NES: wie es heute passiert</a></li>
<li><a href="../de466659/index.html">Kubecost Bewertung, um Geld f√ºr Kubernetes in den Wolken zu sparen</a></li>
<li><a href="../de466661/index.html">Fernstudium im Ausland: Notizen vor der Arbeit</a></li>
<li><a href="../de466663/index.html">Einfache Experimente mit dem Mikrocontroller STM32F103 (Blue Tablet)</a></li>
<li><a href="../de466665/index.html">CSS-√úberlauf und Datenverlust</a></li>
<li><a href="../de466667/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 379 (2. - 8. September 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>