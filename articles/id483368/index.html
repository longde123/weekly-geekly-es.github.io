<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹️ 🔹 😓 Membuat file packer ELF x86_64 untuk linux 🎫 👩🏽‍🏭 🥠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Posting ini akan menjelaskan pembuatan file packer sederhana yang dapat dieksekusi untuk linux x86_64. Diasumsikan bahwa pembaca sudah m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat file packer ELF x86_64 untuk linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483368/"><h2>  Pendahuluan </h2><br>  Posting ini akan menjelaskan pembuatan file packer sederhana yang dapat dieksekusi untuk linux x86_64.  Diasumsikan bahwa pembaca sudah mengenal bahasa pemrograman C, bahasa assembly untuk arsitektur x86_64, dan file perangkat ELF.  Untuk memastikan kejelasan, penanganan kesalahan dihapus dari kode di artikel dan implementasi beberapa fungsi tidak ditampilkan, kode lengkap dapat ditemukan dengan mengklik tautan ke github ( <a href="https://github.com/cyberfined/cryload">loader</a> , <a href="https://github.com/cyberfined/cryptor">packer</a> ). <br><br>  Idenya adalah ini: kami mentransfer file ELF ke packer, dan kami mendapatkan yang baru dengan struktur berikut pada output: <br><div class="scrollable-table"><table><tbody><tr><td colspan="2">  Header ELF </td></tr><tr><td colspan="2">  Judul program </td></tr><tr><td rowspan="3">  Segmen Kode </td><td>  Pengunduh File ELF yang Dikemas </td></tr><tr><td>  File ELF yang Dikemas <br></td></tr><tr><td>  256 byte data acak </td></tr></tbody></table></div><a name="habracut"></a><br>  Untuk kompresi, diputuskan untuk menggunakan algoritma Huffman, untuk enkripsi - AES-CTR dengan kunci 256-bit, yaitu implementasi dari kokke <a href="https://github.com/kokke/tiny-AES-c">tiny-AES-c</a> .  256 byte data acak digunakan untuk menginisialisasi kunci AES dan vektor inisialisasi menggunakan generator angka acak semu, seperti yang ditunjukkan di bawah ini: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) { seed = (<span class="hljs-number"><span class="hljs-number">1103515245</span></span>*seed + <span class="hljs-number"><span class="hljs-number">12345</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>; key[i] = buf[seed]; }</code> </pre> <br>  Keputusan ini disebabkan oleh keinginan untuk menyulitkan reverse engineering.  Sampai saat ini, saya menyadari bahwa komplikasi itu tidak signifikan, tetapi saya tidak mulai menghilangkannya, karena saya tidak ingin menghabiskan waktu dan energi untuk itu. <br><br><h2>  Bootloader </h2><br>  Pertama, boot loader akan ditinjau.  Loader tidak boleh memiliki dependensi, jadi semua fungsi yang diperlukan dari pustaka C standar harus ditulis secara independen (implementasi fungsi-fungsi ini tersedia dengan <a href="">referensi</a> ).  Itu juga harus mandiri secara posisi. <br><br><h3>  _Mulailah fungsi </h3><br>  Bootloader dimulai dari fungsi _start, yang hanya meneruskan argc dan argv ke main: <br><br><pre> <code class="plaintext hljs">.extern main .globl _start .text _start: movq (%rsp), %rdi movq %rsp, %rsi addq $8, %rsi call main</code> </pre><br><h3>  Fungsi utama </h3><br>  File main.c dimulai dengan mendefinisikan beberapa variabel eksternal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* loader_end; <span class="hljs-comment"><span class="hljs-comment">//    , .   //  ELF . extern size_t payload_size; //   ELF  extern size_t key_seed; //     // -   . extern size_t iv_seed; //     // -    </span></span></code> </pre><br>  Semua dari mereka dinyatakan sebagai eksternal untuk menemukan posisi karakter yang sesuai dengan variabel (Elf64_Sym) dalam paket dan mengubah nilainya. <br><br>  Fungsi utamanya sendiri cukup sederhana.  Langkah pertama adalah menginisialisasi pointer ke file ELF yang dikemas, buffer 256-byte, dan ke atas tumpukan.  Kemudian file ELF didekripsi dan diperluas, kemudian ditempatkan di tempat yang tepat di memori menggunakan fungsi load_elf, dan akhirnya, nilai register rsp kembali ke keadaan semula, dan lompatan ke titik entri program terjadi: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SET_STACK(sp) __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %0, %%rsp"</span></span></span><span class="hljs-meta">::</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta">(sp)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JMP(addr) __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmp *%0"</span></span></span><span class="hljs-meta">::</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta">(addr)) int main(int argc, char **argv) { uint8_t *payload = (uint8_t*)&amp;loader_end; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    // ELF  uint8_t *entropy_buf = payload + payload_size; //   256- //  void *rsp = argv-1; //     struct AES_ctx ctx; AES_init_ctx_iv(&amp;ctx, entropy_buf, key_seed, iv_seed); //  AES AES_CTR_xcrypt_buffer(&amp;ctx, payload, payload_size); //  ELF memset(&amp;ctx, 0, sizeof(ctx)); //   AES size_t decoded_payload_size; //  ELF char *decoded_payload = huffman_decode((char*)payload, payload_size, &amp;decoded_payload_size); //     ELF  , //   ET_EXEC  NULL. void *load_addr = elf_load_addr(rsp, decoded_payload, decoded_payload_size); load_addr = load_elf(load_addr, decoded_payload); //  ELF  , //    //  . memset(decoded_payload, 0, decoded_payload_size); //   ELF munmap(decoded_payload, decoded_payload_size); //   //    //  ELF     AES AES_init_ctx_iv(&amp;ctx, entropy_buf, key_seed, iv_seed); AES_CTR_xcrypt_buffer(&amp;ctx, payload, payload_size); memset(&amp;ctx, 0, sizeof(ctx)); SET_STACK(rsp); //    JMP(load_addr); //       }</span></span></span></span></code> </pre><br>  Menyetel ulang status AES dan file ELF yang dikompresi dilakukan untuk tujuan keamanan - sehingga data kunci dan dekripsi disimpan dalam memori hanya selama durasi penggunaan. <br><br>  Selanjutnya, kami akan mempertimbangkan implementasi beberapa fungsi. <br><br><h3>  load_elf </h3><br>  Saya mengambil fungsi ini dari pengguna github dengan nickname bediger dari repositori <a href="">userlandexec-</a> nya dan menyelesaikannya, karena fungsi aslinya macet pada file seperti ET_DYN.  Kegagalan terjadi karena fakta bahwa nilai argumen pertama dari panggilan sistem mmap diatur ke NULL, dan alamat dikembalikan cukup dekat dengan program utama, selama panggilan berikutnya ke mmap dan menyalin segmen ke alamat yang dikembalikan oleh mereka, kode program utama ditimpa, dan segfault terjadi.  Oleh karena itu, diputuskan untuk menambahkan alamat awal sebagai parameter ke fungsi load_elf.  Fungsi itu sendiri berjalan melalui semua tajuk program, mengalokasikan memori (jumlahnya harus merupakan kelipatan dari ukuran halaman) untuk segmen PT_LOAD dari file ELF, menyalin kontennya ke area memori yang dialokasikan dan menetapkan hak baca, tulis, eksekusi yang sesuai untuk area ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      #define PAGEUP(x) (((unsigned long)x + 4095)&amp;(~4095)) //      #define PAGEDOWN(x) ((unsigned long)x&amp;(~4095)) void* load_elf(void *load_addr, void *mapped) { Elf64_Ehdr *ehdr = mapped; Elf64_Phdr *phdr = mapped + ehdr-&gt;e_phoff; void *text_segment = NULL; unsigned long initial_vaddr = 0; unsigned long brk_addr = 0; for(size_t i = 0; i &lt; ehdr-&gt;e_phnum; i++, phdr++) { unsigned long rounded_len, k; void *segment; //   PT_LOAD,    if(phdr-&gt;p_type != PT_LOAD) continue; if(text_segment != 0 &amp;&amp; ehdr-&gt;e_type == ET_DYN) { //  ET_DYN phdr-&gt;p_vaddr    , //        //    ,      //     load_addr = text_segment + phdr-&gt;p_vaddr - initial_vaddr; load_addr = (void*)PAGEDOWN(load_addr); } else if(ehdr-&gt;e_type == ET_EXEC) { //  ET_EXEC phdr-&gt;p_vaddr     load_addr = (void*)PAGEDOWN(phdr-&gt;p_vaddr); } //        rounded_len = phdr-&gt;p_memsz + (phdr-&gt;p_vaddr % 4096); rounded_len = PAGEUP(rounded_len); //        segment = mmap(load_addr, rounded_len, PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); if(ehdr-&gt;e_type == ET_EXEC) load_addr = (void*)phdr-&gt;p_vaddr; else load_addr = segment + (phdr-&gt;p_vaddr % 4096); //         memcpy(load_addr, mapped + phdr-&gt;p_offset, phdr-&gt;p_filesz); if(!text_segment) { text_segment = segment; initial_vaddr = phdr-&gt;p_vaddr; } unsigned int protflags = 0; if(phdr-&gt;p_flags &amp; PF_R) protflags |= PROT_READ; if(phdr-&gt;p_flags &amp; PF_W) protflags |= PROT_WRITE; if(phdr-&gt;p_flags &amp; PF_X) protflags |= PROT_EXEC; mprotect(segment, rounded_len, protflags); //   // , ,  k = phdr-&gt;p_vaddr + phdr-&gt;p_memsz; if(k &gt; brk_addr) brk_addr = k; } if (ehdr-&gt;e_type == ET_EXEC) { brk(PAGEUP(brk_addr)); //  ET_EXEC ehdr-&gt;e_entry     load_addr = (void*)ehdr-&gt;e_entry; } else { //  ET_DYN ehdr-&gt;e_entry    , //           load_addr = (void*)ehdr + ehdr-&gt;e_entry; } return load_addr; //       }</span></span></code> </pre><br><h3>  elf_load_addr </h3><br>  Fungsi ini untuk file ET_EXEC ELF mengembalikan NULL, karena file jenis ini harus ditempatkan di alamat yang ditentukan di dalamnya.  Untuk file ET_DYN, alamat sama dengan perbedaan antara alamat dasar program utama (mis., Bootloader), jumlah memori yang diperlukan untuk menempatkan ELF dalam memori, dan 4096, 4096 - jarak yang diperlukan agar tidak menempatkan file ELF tepat di sebelah program utama dihitung pertama kali.  Setelah menghitung alamat ini, diperiksa apakah area memori berpotongan, dari alamat yang diberikan ke alamat dasar dari program utama, dengan area dari awal file ELF yang belum dibongkar sampai akhir.  Dalam hal persimpangan, alamat dikembalikan sama dengan perbedaan antara alamat awal ELF yang dibongkar dan jumlah memori yang diperlukan untuk meletakkannya, jika tidak, alamat yang dihitung sebelumnya dikembalikan. <br><br>  Alamat dasar program ditemukan dengan mengekstraksi alamat header program dari vektor bantu (vektor tambahan ELF), yang terletak setelah pointer ke variabel lingkungan di stack, dan mengurangi ukuran header ELF dari itu: <br><br><pre> <code class="plaintext hljs">      ---------------------------------------------------------------------------    -&gt; [ argc ] 8 [ argv[0] ] 8 [ argv[1] ] 8 [ argv[..] ] 8 * x [ argv[n – 1] ] 8 [ argv[n] ] 8 (= NULL) [ envp[0] ] 8 [ envp[1] ] 8 [ envp[..] ] 8 [ envp[term] ] 8 (= NULL) [ auxv[0] (Elf64_auxv_t) ] 16 [ auxv[1] (Elf64_auxv_t) ] 16 [ auxv[..] (Elf64_auxv_t) ] 16 [ auxv[term] (Elf64_auxv_t) ] 16 (= AT_NULL) [  ] 0 - 16 [    ] &gt;= 0 [   ] &gt;= 0 [   ] 8 (= NULL) &lt;    &gt; 0 ---------------------------------------------------------------------------</code> </pre><br>  Struktur dimana setiap elemen dari vektor bantu dijelaskan memiliki bentuk: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> a_type; <span class="hljs-comment"><span class="hljs-comment">//   union { uint64_t a_val; //  } a_un; } Elf64_auxv_t;</span></span></code> </pre><br>  Salah satu nilai a_type yang valid adalah AT_PHDR, a_val kemudian akan mengarah ke header program.  Berikut ini adalah kode untuk fungsi elf_load_addr: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_base_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *rsp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *base_addr = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> argc = *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)rsp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **envp = rsp + (argc+<span class="hljs-number"><span class="hljs-number">2</span></span>)*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    //   while(*envp++); //        Elf64_auxv_t *aux = (Elf64_auxv_t*)envp; //    //  for(; aux-&gt;a_type != AT_NULL; aux++) { //        if(aux-&gt;a_type == AT_PHDR) { //   ELF ,     //      base_addr = (void*)(aux-&gt;a_un.a_val – sizeof(Elf64_Ehdr)); break; } } return base_addr; } size_t elf_memory_size(void *mapped) { Elf64_Ehdr *ehdr = mapped; Elf64_Phdr *phdr = mapped + ehdr-&gt;e_phoff; size_t mem_size = 0, segment_len; for(size_t i = 0; i &lt; ehdr-&gt;e_phnum; i++, phdr++) { if(phdr-&gt;p_type != PT_LOAD) continue; segment_len = phdr-&gt;p_memsz + (phdr-&gt;p_vaddr % 4096); mem_size += PAGEUP(segment_len); } return mem_size; } void* elf_load_addr(void *rsp, void *mapped, size_t mapped_size) { Elf64_Ehdr *ehdr = mapped; if(ehdr-&gt;e_type == ET_EXEC) return NULL; size_t mem_size = elf_memory_size(mapped) + 0x1000; void *load_addr = elf_base_addr(rsp); if(mapped &lt; load_addr &amp;&amp; mapped + mapped_size &gt; load_addr - mem_size) load_addr = mapped; return load_addr - mem_size; }</span></span></code> </pre><br><h3>  Deskripsi Skrip Linker </h3><br>  Kita perlu mendefinisikan karakter untuk variabel eksternal yang dijelaskan di atas, dan juga memastikan bahwa kode dan data loader setelah kompilasi berada di bagian .text yang sama.  Ini diperlukan untuk mengekstrak kode mesin loader dengan mudah hanya dengan memotong konten bagian ini dari file.  Untuk mencapai tujuan ini, skrip tautan berikut ditulis: <br><br><pre> <code class="plaintext hljs">ENTRY(_start) SECTIONS { . = 0; .text :{ *(.text) *(.text.startup) *(.data) *(.rodata) payload_size = .; QUAD(0) key_seed = .; QUAD(0) iv_seed = .; QUAD(0) loader_end = .; } }</code> </pre><br>  Perlu dijelaskan bahwa QUAD (0) menempatkan 8 byte nol, alih-alih pengepak akan mengganti nilai-nilai tertentu.  Untuk memotong kode mesin, sebuah utilitas kecil ditulis yang juga menulis ke permulaan kode mesin pergeseran titik masuk ke bootloader dari awal bootloader, offset nilai nilai payload_size, key_seed dan karakter iv_seed dari awal bootloader.  Kode untuk utilitas ini tersedia di <a href="">sini</a> .  Ini mengakhiri deskripsi bootloader. <br><br><h2>  Pengepakan langsung </h2><br>  Pertimbangkan fungsi utama pengepak.  Ia menggunakan dua argumen baris perintah: nama file input adalah argv [1] dan nama file output adalah argv [2].  Pertama, file input ditampilkan dalam memori dan diperiksa kompatibilitasnya dengan pengepak.  Packer hanya berfungsi dengan dua jenis file ELF: ET_EXEC dan ET_DYN, dan hanya dengan yang dikompilasi secara statis.  Alasan untuk memperkenalkan pembatasan ini adalah kenyataan bahwa sistem linux yang berbeda memiliki versi yang berbeda dari pustaka bersama, yaitu  kemungkinan program yang dikompilasi secara dinamis tidak akan mulai pada sistem selain sistem induknya cukup tinggi.  Kode yang sesuai dalam fungsi utama: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mapped_size; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *mapped = map_file(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], &amp;mapped_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(check_elf(mapped) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Setelah itu, jika file input melewati pemeriksaan kompatibilitas, ia dikompres: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> comp_size; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *comp_buf = huffman_encode(mapped, &amp;comp_size);</code> </pre><br>  Kemudian keadaan AES dihasilkan, dan file ELF terkompresi dienkripsi.  Keadaan AES ditentukan oleh struktur berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AES_ENTROPY_BUFSIZE 256 typedef struct { uint8_t entropy_buf[AES_ENTROPY_BUFSIZE]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 256-  size_t key_seed; //      size_t iv_seed; //       struct AES_ctx ctx; //  AES-CTR } AES_state_t;</span></span></span></span></code> </pre><br>  Kode yang sesuai di utama: <br><br><pre> <code class="cpp hljs">AES_state_t aes_st; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; AES_ENTROPY_BUFSIZE; i++) state.entropy_buf[i] = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; state.key_seed = rand(); state.iv_seed = rand(); AES_init_ctx_iv(&amp;state.ctx, state.entropy_buf, state.key_seed, state.iv_seed); AES_CTR_xcrypt_buffer(&amp;aes_st.ctx, comp_buf, comp_size);</code> </pre><br>  Setelah itu, struktur yang menyimpan informasi tentang bootloader diinisialisasi, nilai payload_size, key_seed, dan iv_seed di bootloader diubah menjadi yang dihasilkan pada langkah sebelumnya, setelah itu keadaan AES diatur ulang.  Informasi tentang bootloader disimpan dalam struktur berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *loader_begin; <span class="hljs-comment"><span class="hljs-comment">//      size_t entry_offset; //       size_t *payload_size_patch_offset; //     // ELF    size_t *key_seed_pacth_offset; //     //       size_t *iv_seed_patch_offset; //     //     //    size_t loader_size; //     } loader_t;</span></span></code> </pre><br>  Kode yang sesuai di utama: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">loader_t</span></span> loader; init_loader(&amp;loader); *loader.payload_size_patch_offset = comp_size; *loader.key_seed_pacth_offset = aes_st.key_seed; *loader.iv_seed_patch_offset = aes_st.iv_seed; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;aes_st.ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(aes_st.ctx));</code> </pre><br>  Pada bagian terakhir, kita membuat file output, menulis header ELF, satu header program, kode loader, file ELF terkompresi dan terenkripsi, dan buffer 256-byte ke dalamnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> out_fd = open(argv[<span class="hljs-number"><span class="hljs-number">2</span></span>], O_WRONLY | O_CREAT | O_TRUNC, <span class="hljs-number"><span class="hljs-number">0755</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  //   write_elf_ehdr(out_fd, &amp;loader); //  ELF  write_elf_phdr(out_fd, &amp;loader, comp_size); //    write(out_fd, loader.loader_begin, loader.loader_size); //   write(out_fd, comp_buf, comp_size); //     ELF write(out_fd, aes_st.entropy_buf, AES_ENTROPY_BUFSIZE); //  // 256- </span></span></code> </pre><br>  Kode utama dari pengepak berakhir di sini, maka fungsi-fungsi berikut akan dipertimbangkan: fungsi menginisialisasi informasi tentang bootloader, fungsi penulisan header ELF dan fungsi penulisan header program. <br><br><h3>  Menginisialisasi informasi bootloader </h3><br>  Kode mesin loader tertanam dalam paket yang dapat dieksekusi menggunakan kode sederhana di bawah ini: <br><br><pre> <code class="plaintext hljs">.data .globl _loader_begin .globl _loader_end _loader_begin: .incbin "loader" _loader_end:</code> </pre><br>  Untuk menentukan alamatnya dalam memori, variabel berikut dideklarasikan dalam file main.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _loader_begin; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _loader_end;</code> </pre><br>  Selanjutnya, pertimbangkan fungsi init_loader.  Pertama, secara berurutan membaca nilai berikut: offset masukan dari awal titik bootloader (entry_offset), nilai dimensi offset dikemas berkas ELF dari awal loader (payload_size_patch_offset), perpindahan nilai pembangkit utama untuk kunci dari awal loader (key_seed_patch_offset), perpindahan nilai pembangkit utama untuk vektor inisialisasi dari awal bootloader (iv_seed_patch_offset).  Kemudian, alamat pemuat ditambahkan ke tiga nilai terakhir, jadi ketika menunjuk referensi dan menetapkan nilai padanya, kami akan mengganti nol yang ditetapkan pada tahap tata letak (QUAD (0)) dengan nilai yang kami butuhkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_loader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loader_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *loader_begin = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)&amp;_loader_begin; l-&gt;entry_offset = *(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>*)loader_begin; loader_begin += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>); l-&gt;payload_size_patch_offset = *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)loader_begin; loader_begin += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); l-&gt;key_seed_pacth_offset = *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)loader_begin; loader_begin += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); l-&gt;iv_seed_patch_offset = *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)loader_begin; loader_begin += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); l-&gt;payload_size_patch_offset = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)l-&gt;payload_size_patch_offset + loader_begin; l-&gt;key_seed_pacth_offset = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)l-&gt;key_seed_pacth_offset + loader_begin; l-&gt;iv_seed_patch_offset = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)l-&gt;iv_seed_patch_offset + loader_begin; l-&gt;loader_begin = loader_begin; l-&gt;loader_size = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)&amp;_loader_end - loader_begin; }</code> </pre><br><br><h3>  write_elf_ehdr </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_elf_ehdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loader_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *loader)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ELF  Elf64_Ehdr ehdr; memset(ehdr.e_ident, 0, sizeof(ehdr.e_ident)); memcpy(ehdr.e_ident, ELFMAG, SELFMAG); ehdr.e_ident[EI_CLASS] = ELFCLASS64; ehdr.e_ident[EI_DATA] = ELFDATA2LSB; ehdr.e_ident[EI_VERSION] = EV_CURRENT; ehdr.e_ident[EI_OSABI] = ELFOSABI_NONE; ehdr.e_type = ET_DYN; ehdr.e_machine = EM_X86_64; ehdr.e_version = EV_CURRENT; ehdr.e_entry = sizeof(Elf64_Ehdr) + sizeof(Elf64_Phdr) + loader-&gt;entry_offset; ehdr.e_phoff = sizeof(Elf64_Ehdr); ehdr.e_shoff = 0; ehdr.e_flags = 0; ehdr.e_ehsize = sizeof(Elf64_Ehdr); ehdr.e_phentsize = sizeof(Elf64_Phdr); ehdr.e_phnum = 1; ehdr.e_shentsize = sizeof(Elf64_Shdr); ehdr.e_shnum = 0; ehdr.e_shstrndx = 0; write(fd, &amp;ehdr, sizeof(ehdr)); //     return 0; }</span></span></code> </pre><br>  Di sini inisialisasi standar header ELF terjadi dan penulisan berikutnya ke file, satu-satunya hal yang perlu diperhatikan adalah kenyataan bahwa dalam file ET_DYN ELF segmen yang dijelaskan oleh header program pertama tidak hanya mencakup kode yang dapat dieksekusi, tetapi juga header ELF dan semua header. program.  Oleh karena itu, offsetnya dari awal harus sama dengan nol, ukurannya haruslah jumlah dari ukuran header ELF, semua header program dan kode yang dapat dieksekusi, dan titik masuk ditentukan sebagai jumlah dari ukuran header ELF, ukuran semua header program dan offset dari awal kode yang dapat dieksekusi. <br><br><h3>  write_elf_phdr </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_elf_phdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loader_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *loader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> payload_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Elf64_Phdr phdr; phdr.p_type = PT_LOAD; phdr.p_offset = 0; phdr.p_vaddr = 0; phdr.p_paddr = 0; phdr.p_filesz = sizeof(Elf64_Ehdr) + sizeof(Elf64_Phdr) + loader-&gt;loader_size + payload_size + AES_ENTROPY_BUFSIZE; phdr.p_memsz = phdr.p_filesz; phdr.p_flags = PF_R | PF_W | PF_X; phdr.p_align = 0x1000; write(fd, &amp;phdr, sizeof(phdr)); //      }</span></span></code> </pre><br>  Di sini, header program diinisialisasi dan kemudian ditulis ke file.  Anda harus memperhatikan offset relatif terhadap awal file dan ukuran segmen yang dijelaskan oleh header program.  Seperti dijelaskan dalam paragraf sebelumnya, segmen yang dijelaskan oleh tajuk ini tidak hanya mencakup kode yang dapat dieksekusi, tetapi juga tajuk ELF dan tajuk program.  Kami juga membuat segmen dengan kode yang dapat dieksekusi dapat diakses untuk ditulis, ini disebabkan oleh fakta bahwa implementasi AES yang digunakan dalam bootloader mengenkripsi dan mendekripsi data “di tempat”. <br><br><h2>  Beberapa fakta tentang hasil kerja pengepak </h2><br>  Selama pengujian, diketahui bahwa program yang dikompilasi secara statis dengan glibc pergi ke segfault saat memulai, dengan instruksi ini: <br><br><pre>  movq% fs: 0x28,% rax </pre><br>  Saya tidak dapat menemukan mengapa hal ini terjadi, saya akan senang jika Anda berbagi informasi tentang hal ini.  Alih-alih glibc, Anda dapat menggunakan musl-libc, semuanya bekerja dengannya tanpa gagal.  Juga, pengepak itu diuji dengan program golang yang dikompilasi secara statis, misalnya, server http.  Untuk crash statis penuh dari program golang, bendera berikut harus digunakan: <br><br><pre>  CGO_ENABLED = 0 buat build -a -ldflags '-extldflags "-static"'. </pre><br>  Hal terakhir yang diuji oleh packer adalah file ET_DYN ELF tanpa linker dinamis.  Benar, ketika bekerja dengan file-file ini, fungsi elf_load_addr mungkin gagal.  Dalam praktiknya, ini dapat dipotong dari bootloader dan menggunakan alamat tetap, misalnya 0x10000. <br><br><h2>  Kesimpulan </h2><br>  Packer ini, jelas, tidak masuk akal untuk digunakan untuk tujuan yang dimaksudkan, karena file yang dilindungi olehnya cukup mudah didekripsi.  Tujuan dari proyek ini adalah untuk menjadi master yang lebih baik dalam bekerja dengan file ELF, praktik pembuatannya, serta mempersiapkan penciptaan paket yang lebih lengkap. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483368/">https://habr.com/ru/post/id483368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483354/index.html">Kutukan bulan kedua</a></li>
<li><a href="../id483356/index.html">Hitungan Komunitas “Apa?” Dimana? Kapan? ”(ChGK) atau berapa banyak jabat tangan di depan seorang Teman?</a></li>
<li><a href="../id483360/index.html">Kontrol drive daya listrik. Pengalaman Amatir</a></li>
<li><a href="../id483364/index.html">Anda dapat menulis kode di tempat kerja untuk menghemat waktu luang Anda.</a></li>
<li><a href="../id483366/index.html">Sejarah Internet: Jaringan</a></li>
<li><a href="../id483372/index.html">Cara melatih jaringan saraf DeepPavlov di laptop menggunakan GPU</a></li>
<li><a href="../id483374/index.html">Rekomendasi API REST - Contoh Desain Layanan Web di Jawa dan Musim Semi</a></li>
<li><a href="../id483376/index.html">Di permukaan lubang hitam</a></li>
<li><a href="../id483378/index.html">Jenis-aman bekerja dengan register tanpa overhead di C ++ 17: metaprogramming berbasis nilai</a></li>
<li><a href="../id483380/index.html">Layanan Mikro: cara mematuhi kontrak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>