<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧤 👨🏿‍🍳 👡 Abonnez-vous à Kafka via HTTP ou comment simplifier vos hooks web 🎎 👩‍👩‍👦‍👦 👨🏼‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe de nombreuses façons de traiter les messages des systèmes Pub-Sub: en utilisant un service distinct, en isolant un processus isolé, en orche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abonnez-vous à Kafka via HTTP ou comment simplifier vos hooks web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435346/">  Il existe de nombreuses façons de traiter les messages des systèmes Pub-Sub: en utilisant un service distinct, en isolant un processus isolé, en orchestrant un pool de processus / threads, IPC complexe, Poll-over-Http et bien d'autres.  Aujourd'hui, je veux parler de la façon d'utiliser Pub-Sub sur HTTP et de mon service écrit spécifiquement pour cela. <br><br>  Dans certains cas, l'utilisation d'un backend de service HTTP prêt à l'emploi est une solution idéale pour traiter une file d'attente de messages: <br><br><ol><li>  Équilibrage hors de la boîte.  Habituellement, le backend est déjà derrière l'équilibreur et dispose d'une infrastructure prête à charger, ce qui simplifie considérablement le travail avec les messages. </li><li>  Utilisation d'un contrôleur REST standard (n'importe quelle ressource HTTP).  La consommation de messages HTTP minimise le coût d'implémentation de compumers pour différentes langues si le backend est mixte. </li><li>  Simplification de l'utilisation des hooks Web d'autres services.  Désormais, presque tous les services (Jira, Gitlab, Mattermost, Slack ...) prennent en charge les crochets Web pour interagir avec le monde extérieur.  Vous pouvez vous simplifier la vie si vous apprenez à la file d'attente à exécuter les fonctions d'un répartiteur HTTP. </li></ol><br>  Cette approche présente également des inconvénients: <br><br><ol><li>  Vous pouvez oublier la légèreté de la solution.  HTTP est un protocole lourd, et l'utilisation de frameworks du côté du consommateur augmentera instantanément la latence et la charge. </li><li>  Nous perdons les forces de l'approche Poll, obtenant les faiblesses de Push. </li><li>  Le traitement des messages par les mêmes instances de service qui traitent les clients peut affecter la réactivité.  Ce n'est pas significatif, car il est traité avec équilibrage et isolation. </li></ol><br>  J'ai implémenté l'idée en tant que service Queue-Over-Http, qui sera discuté plus tard.  Le projet est écrit en Kotlin en utilisant Spring Boot 2.1.  En tant que courtier, seul Apache Kafka est actuellement disponible. <br><a name="habracut"></a><br>  <i>Plus loin dans l'article, il est supposé que le lecteur connaît Kafka et connaît les validations (validation) et les décalages (décalage) des messages, les principes des groupes (groupe) et des consommateurs (consommateur), et comprend également en quoi la partition (partition) diffère du sujet (sujet) .</i>  <i>S'il y a des lacunes, je vous conseille de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> section de la documentation Kafka avant de continuer.</i> <br><br><h1>  Table des matières </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Revue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S'engage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gestion des erreurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Des messages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Performances</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Démonstration</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li></ul><br><a name="overview"></a><h1>  Revue </h1><br>  Queue-Over-Http est un service qui agit en tant qu'intermédiaire entre un courtier de messages et le consommateur HTTP final (le service facilite la mise en œuvre de la prise en charge de l'envoi de messages aux consommateurs de toute autre manière, par exemple, divers * RPC).  Pour le moment, seuls l'abonnement, le désabonnement et l'affichage de la liste des consommateurs sont disponibles. L'envoi de messages au courtier (produit) via HTTP n'a pas encore été mis en œuvre en raison de l'impossibilité de garantir l'ordre des messages sans un soutien spécial du producteur. <br><br>  Le personnage clé du service est le consommateur, qui peut s'abonner à des partitions spécifiques ou simplement à des sujets (le modèle de sujet est pris en charge).  Dans le premier cas, l'équilibre automatique des partitions est désactivé.  Après s'être abonné, la ressource HTTP spécifiée commence à recevoir des messages des partitions Kafka attribuées.  Sur le plan architectural, chaque abonné est associé à un client Java Kafka natif. <br><br><div class="spoiler">  <b class="spoiler_title">histoire divertissante sur KafkaConsumer</b> <div class="spoiler_text">  Kafka a un merveilleux client Java qui peut faire beaucoup.  Je l'utilise dans l'adaptateur de file d'attente pour recevoir des messages du courtier, puis je l'envoie aux files d'attente de service local.  Il est à noter que le client travaille exclusivement dans le cadre d'un seul thread. <br><br>  L'idée de l'adaptateur est simple.  Nous commençons dans un thread, nous écrivons le planificateur le plus simple des clients natifs, en nous concentrant sur la réduction de la latence.  Autrement dit, nous écrivons quelque chose de similaire: <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasWork = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (consumer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kafkaConsumers) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> queueGroup = consumers[consumer] ?: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> invalidateSubscription(consumer, queueGroup) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> records = consumer.poll(Duration.ZERO) <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!records.isEmpty) { hasWork = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> committed = doCommit() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasWork &amp;&amp; committed == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ,    Thread.sleep(1) } }</span></span></code> </pre> <br>  Il semblerait que tout soit merveilleux, la latence est minime même avec des dizaines de consommateurs.  En pratique, il s'est avéré que <code>KafkaConsumer</code> à ce mode de fonctionnement et donne un taux d'allocation d'environ 1,5 Mo / s en temps d'inactivité.  Avec 100 courriers, le taux d'allocation atteint 150 Mo / s et fait penser souvent à l'application GC.  Bien sûr, toutes ces ordures sont dans la zone jeune, GC est tout à fait capable de gérer cela, mais toujours, la solution n'est pas parfaite. <br><br>  Évidemment, vous devez suivre la voie typique de <code>KafkaConsumer</code> et maintenant je place chaque abonné dans mon flux.  Cela donne une surcharge pour la mémoire et la planification, mais il n'y a pas d'autre moyen. <br><br>  Je réécris le code d'en haut, supprimant la boucle interne et changeant <code>Duration.ZERO</code> en <code>Duration.ofMillis(100)</code> .  Il s'avère que le taux d'allocation tombe à un niveau acceptable de 80 à 150 Ko / s par consommateur.  Cependant, Poll avec un délai d'expiration de 100 ms retarde toute la file d'attente des validations sur ces mêmes 100 ms, ce qui est beaucoup inacceptable. <br><br>  Dans le processus de recherche de solutions au problème, je me souviens de <code>KafkaConsumer::wakeup</code> , qui lève une <code>WakeupException</code> et interrompt toute opération de blocage sur le consommateur.  Avec cette méthode, le chemin vers une faible latence est simple: lorsqu'une nouvelle demande de validation arrive, nous la mettons dans la file d'attente, et sur le consommateur natif, nous appelons le <code>wakeup</code> .  Dans le cycle de travail, <code>WakeupException</code> et allez valider ce qui s'est accumulé.  Pour le transfert de contrôle à l'aide d'exceptions, vous devez immédiatement le remettre entre vos mains, mais puisque rien d'autre ... <br><br>  Il s'avère que cette option est loin d'être parfaite, car toute opération sur le consommateur natif <code>WakeupException</code> désormais une <code>WakeupException</code> , y compris la validation elle-même.  Le traitement de cette situation encombrera le code avec un indicateur permettant d'effectuer le <code>wakeup</code> . <br><br>  J'arrive à la conclusion qu'il serait bien de modifier la méthode <code>KafkaConsumer::poll</code> afin qu'elle puisse être interrompue normalement, selon un indicateur supplémentaire.  En conséquence, <a href="https://github.com/viirtus/queue-over-">Frankenstein</a> est né de la réflexion, qui copie exactement la méthode de sondage d'origine, en ajoutant une sortie de la boucle par le drapeau.  Cet indicateur est défini par une méthode interruptPoll distincte, qui, en outre, appelle le réveil sur le sélecteur client pour libérer le verrou de thread sur les opérations d'E / S. <br><br>  Après avoir implémenté le client de cette manière, j'obtiens la vitesse de réaction à partir du moment où une demande de validation arrive jusqu'à ce qu'elle soit traitée jusqu'à 100 microsecondes, et une excellente latence pour récupérer les messages d'un courtier, ce qui est très bien. <br></div></div><br>  Chaque partition est représentée par une file d'attente locale distincte, où l'adaptateur écrit des messages à partir du courtier.  Le travailleur en prend des messages et les envoie pour exécution, c'est-à-dire pour l'envoi via HTTP. <br><br>  Le service prend en charge le traitement des messages par lots pour augmenter le débit.  Lors de l'abonnement, vous pouvez spécifier le <code>concurrencyFactor</code> chaque rubrique (s'applique à chaque partition affectée indépendamment).  Par exemple, <code>concurrencyFactor=1000</code> signifie que 1000 messages sous forme de requêtes HTTP peuvent être envoyés au consommateur en même temps.  Dès que tous les messages du pack ont ​​été établis sans ambiguïté par le consommateur, le service décide de la prochaine validation de l'offset du dernier message dans Kafka.  Par conséquent, la deuxième valeur de <code>concurrencyFactor</code> est le nombre maximal de messages traités par le consommateur en cas de panne de Kafka ou Queue-Over-Http. <br><br>  Pour réduire les délais, la file d'attente a <code>loadFactor = concurrencyFactor * 2</code> , ce qui vous permet de lire deux fois plus de messages du courtier que vous pouvez envoyer.  Étant donné que la validation automatique est désactivée sur le client natif, un tel schéma ne viole pas les garanties At-Least-Once. <br>  Une valeur <code>concurrencyFactor</code> élevée augmente le débit de la file d'attente en réduisant le nombre de validations qui prennent jusqu'à 10 ms dans le pire des cas.  Dans le même temps, la charge sur le consommateur augmente. <br><br>  L'ordre d'envoi des messages dans le bundle n'est pas garanti, mais il peut être atteint en définissant <code>concurrencyFactor=1</code> . <br><br><a name="commits"></a><h1>  S'engage </h1><br>  Les commits sont une partie importante du service.  Lorsque le prochain paquet de données est prêt, le décalage du dernier message du paquet est immédiatement validé dans Kafka, et ce n'est qu'après une validation réussie que le prochain paquet devient disponible pour le traitement.  Souvent, cela ne suffit pas et une validation automatique est requise.  Pour ce faire, il existe le paramètre <code>autoCommitPeriodMs</code> , qui a peu de choses en commun avec la période classique d'autocommit pour les clients natifs qui valident le dernier message lu depuis la partition.  Imaginez <code>concurrencyFactor=10</code> .  Le service a envoyé les 10 messages et attend que chacun d'eux soit prêt.  Le traitement du message 3 est terminé en premier, puis le message 1, puis le message 10. À ce stade, il est temps pour la validation automatique.  Il est important de ne pas violer la sémantique At-Least-Once.  Par conséquent, vous ne pouvez valider que le premier message, c'est-à-dire l'offset 2, car seul il a été traité avec succès à ce moment.  De plus, jusqu'à la prochaine validation automatique, les messages 2, 5, 6, 4 et 8. sont traités. Vous devez maintenant valider uniquement l'offset 7, etc.  Autocommit n'a presque aucun effet sur le débit. <br><br><a name="errors"></a><h1>  Gestion des erreurs </h1><br>  En mode de fonctionnement normal, le service envoie une fois un message au superviseur.  Si, pour une raison quelconque, il a provoqué une erreur 4xx ou 5xx, le service renverra le message en attendant la réussite du traitement.  Le temps entre les tentatives peut être configuré comme un paramètre distinct. <br><br>  Il est également possible de définir le nombre de tentatives après lesquelles le message sera marqué comme traité, ce qui arrêtera les retransmissions quel que soit l'état de la réponse.  Je déconseille de l'utiliser pour des données sensibles, les situations de défaillance des consommateurs doivent toujours être ajustées manuellement.  Les messages persistants peuvent être surveillés par les journaux de service et la surveillance de l'état de la réponse du consommateur. <br><br><div class="spoiler">  <b class="spoiler_title">de coller</b> <div class="spoiler_text">  Habituellement, le serveur HTTP, donnant à 4xx ou 5xx l'état de la réponse, envoie également l'en-tête <code>Connection: close</code> .  Une connexion TCP qui est fermée de cette manière reste à l'état <code>TIME_WAITED</code> jusqu'à ce qu'elle soit effacée par le système d'exploitation après un certain temps.  Le problème est que ces connexions occupent un port entier qui ne peut pas être réutilisé avant d'être libéré.  Cela peut entraîner l'absence de ports libres sur la machine pour établir une connexion TCP et le service sera levé avec des exceptions dans les journaux pour chaque envoi.  En pratique, sur Windows 10, les ports se terminent après 10 à 20 000 envois de messages erronés en 1 à 2 minutes.  En mode standard, ce n'est pas un problème. <br></div></div><br><a name="messages"></a><h1>  Des messages </h1><br>  Chaque message extrait du courtier est envoyé au conseiller via HTTP vers la ressource spécifiée lors de l'abonnement.  Par défaut, un message est envoyé par une requête POST dans le corps.  Ce comportement peut être modifié en spécifiant toute autre méthode.  Si la méthode ne prend pas en charge l'envoi de données dans le corps, vous pouvez spécifier le nom du paramètre de chaîne dans lequel le message sera envoyé.  De plus, lors de l'abonnement, vous pouvez spécifier des en-têtes supplémentaires qui seront ajoutés à chaque message, ce qui est pratique pour l'autorisation de base à l'aide de jetons.  Des en-têtes sont ajoutés à chaque message avec l'identifiant du consommateur, le sujet et la partition, d'où le message a été lu, le numéro du message, la clé de partition, le cas échéant, ainsi que le nom du courtier. <br><br><a name="performance"></a><h1>  Performances </h1><br>  Pour évaluer les performances, j'ai utilisé un PC (Windows 10, OpenJDK-11 (G1 sans réglage), i7-6700K, 16 Go), qui exécute le service et un ordinateur portable (Windows 10, i5-8250U, 8 Go), sur lequel le producteur de messages, HTTP Consommateur de ressources et Kafka avec les paramètres par défaut.  Le PC est connecté au routeur via une connexion filaire 1Gb / s, l'ordinateur portable via 802.11ac.  Le producteur écrit toutes les 110 ms toutes les 100 ms pour 110 octets de messages dans les sujets désignés pour lesquels les consommateurs sont abonnés ( <code>concurrencyFactor=500</code> , la validation automatique est désactivée) à partir de différents groupes.  Le support est loin d'être idéal, mais vous pouvez obtenir une image. <br><br>  Un paramètre de mesure clé est l'effet du service sur la latence. <br><br>  Soit: <br>  - t <sub>q</sub> - horodatage du service recevant les messages du client natif <br>  - d <sub>t0</sub> est le temps entre t <sub>q</sub> et le moment où le message a été envoyé de la file d'attente locale au pool de cadres <br>  - d <sub>t</sub> est le temps entre t <sub>q</sub> et le moment où la requête HTTP a été envoyée.  Ce d <sub>t</sub> est l'influence du service sur la latence du message. <br><br>  Au cours des mesures, les résultats suivants ont été obtenus (C - consommateurs, T - thèmes, M - messages): <br><br><img src="https://habrastorage.org/webt/p4/r7/pq/p4r7pqavkke1d3glzc7u8o6a5gu.png"><br><br>  En mode de fonctionnement standard, le service lui-même n'affecte presque pas la latence et la consommation de mémoire est minime.  Les valeurs maximales de d <sub>t</sub> (environ 60 ms) ne sont pas spécifiquement indiquées, car elles dépendent du fonctionnement du GC, et non du service lui-même.  Un réglage spécial de GC ou le remplacement de G1 par Shenandoah peut aider à lisser la propagation des valeurs maximales. <br><br>  Tout change radicalement lorsque le consommateur ne gère pas le flux de messages de la file d'attente et que le service active le mode de limitation.  Dans ce mode, la consommation de mémoire augmente, car le temps de réponse aux requêtes augmente considérablement, ce qui empêche un nettoyage rapide des ressources.  L'effet sur la latence reste ici au niveau des résultats précédents et les valeurs dt élevées sont causées par le préchargement des messages dans la file d'attente locale. <br><br>  Malheureusement, il n'est pas possible de tester à une charge plus élevée, car l'ordinateur portable se plie déjà à 1300 RPS.  Si quelqu'un peut aider à l'organisation des mesures à des charges élevées, je fournirai volontiers un ensemble pour les tests. <br><br><a name="demo"></a><h1>  Démonstration </h1><br>  Passons maintenant à la démonstration.  Pour cela, nous avons besoin de: <br><br><ul><li>  Courtier Kafka, prêt à partir.  Je prendrai l'instance déclenchée le 192.168.99.100:9092 de Bitnami. </li><li>  Une ressource HTTP qui recevra des messages.  Pour plus de clarté, j'ai pris des crochets Web de Slack. </li></ul><br>  Tout d'abord, vous devez augmenter le service Queue-Over-Http lui-même.  Pour ce faire, créez le contenu suivant dans un répertoire <code>application.yml</code> vide: <br><br><pre> <code class="plaintext hljs">spring: profiles: default logging: level: com: viirrtus: queueOverHttp: DEBUG app: persistence: file: storageDirectory: "persist" brokers: - name: "Kafka" origin: "kafka" config: bootstrap.servers: "192.168.99.100:9092"</code> </pre><br>  Ici, nous indiquons au service les paramètres de connexion d'un courtier spécifique, ainsi que l'emplacement de stockage des abonnés afin qu'ils ne soient pas perdus entre les démarrages.  Dans `app.brokers []. Config`, vous pouvez spécifier tous les paramètres de connexion pris en charge par le client Kafka natif; une liste complète peut être trouvée <a href="">ici</a> . <br><br>  Comme le fichier de configuration est traité par Spring, vous pouvez y écrire beaucoup de choses intéressantes.  Y compris, configurer la journalisation. <br><br>  Exécutez maintenant le service lui-même.  Nous utilisons le moyen le plus simple - <code>docker-compose.yml</code> : <br><br><pre> <code class="plaintext hljs">version: "2" services: app: image: viirrtus/queue-over-http:0.1.3 restart: unless-stopped command: --debug ports: - "8080:8080" volumes: - ./application.yml:/application.yml - ./persist:/persist</code> </pre><br>  <i>Si cette option ne vous convient pas, vous pouvez compiler le service à partir de la source.</i>  <i>Instructions d'assemblage dans le projet Readme, dont un lien est donné à la fin de l'article.</i> <br><br>  L'étape suivante consiste à enregistrer le premier abonné.  Pour ce faire, vous devez effectuer une demande HTTP auprès du service avec une description du consommateur: <br><br><pre> <code class="plaintext hljs">POST localhost:8080/broker/subscription Content-Type: application/json { "id": "my-first-consumer", "group": { "id": "consumers" }, "broker": "Kafka", "topics": [ { "name": "slack.test", "config": { "concurrencyFactor": 10, "autoCommitPeriodMs": 100 } } ], "subscriptionMethod": { "type": "http", "delayOnErrorMs": 1000, "retryBeforeCommit": 10, "uri": "&lt;slack-wh-uri&gt;", "additionalHeaders": { "Content-Type": "application/json" } } }</code> </pre><br>  Si tout s'est bien passé, la réponse sera presque le même contenu envoyé. <br><br>  Passons en revue chaque paramètre: <br><br><ul><li>  <code>Consumer.id</code> - ID de notre abonné </li><li>  <code>Consumer.group.id</code> - identifiant de groupe </li><li>  <code>Consumer.broker</code> - indiquez à quels courtiers de services vous devez vous abonner </li><li>  <code>Consumer.topics[0].name</code> - le nom du sujet à partir duquel nous voulons recevoir des messages </li><li> <code>Consumer.topics[0].config. concurrencyFactor</code>  <code>Consumer.topics[0].config. concurrencyFactor</code> - nombre maximum de messages envoyés simultanément </li><li> <code>Consumer.topics[0].config. autoCommitPeriodMs</code>  <code>Consumer.topics[0].config. autoCommitPeriodMs</code> - période de validation forcée pour les messages prêts </li><li>  <code>Consumer.subscriptionMethod.type</code> - type d'abonnement.  Seul HTTP est actuellement disponible. </li><li>  <code>Consumer.subscriptionMethod.delayOnErrorMs</code> - délai avant de renvoyer un message qui s'est terminé par une erreur </li><li>  <code>Consumer.subscriptionMethod.retryBeforeCommit</code> - le nombre de tentatives pour renvoyer le message d'erreur.  Si 0 - le message tournera jusqu'à ce que le traitement soit réussi.  Dans notre cas, la garantie d'une livraison complète n'est pas aussi importante que la constance du flux. </li><li>  <code>Consumer.subscriptionMethod.uri</code> - la ressource à laquelle les messages seront envoyés </li><li>  <code>Consumer.subscriptionMethod.additionalHeader</code> - en-têtes supplémentaires qui seront envoyés avec chaque message.  Notez qu'il y aura du JSON dans le corps de chaque message afin que Slack puisse interpréter correctement la demande. </li></ul><br>  <i>Dans cette demande, la méthode HTTP est omise, car la valeur par défaut, POST, Slack est assez bonne.</i> <br><br>  À partir de ce moment, le service surveille les partitions affectées de la rubrique slack.test pour les nouveaux messages. <br><br>  Pour écrire des messages sur le sujet, j'utiliserai les utilitaires intégrés dans Kafka qui se trouvent dans <code>/opt/bitnami/kafka/bin</code> image Kafka lancée (l'emplacement des utilitaires dans d'autres instances de Kafka peut différer): <br><br><pre> <code class="plaintext hljs">kafka-console-producer.sh --broker-list localhost:9092 --topic slack.test &gt; {“text”: “Hello!”}</code> </pre><br>  Dans le même temps, Slack vous informera d'un nouveau message: <br><br><img src="https://habrastorage.org/webt/kl/eh/z7/klehz7ev6x1y2eaqpf_ylpnjic4.png"><br><br>  <i>Pour désinscrire un consommateur, il suffit de faire une demande POST de «courtier / désinscrire» avec le même contenu que lors de l'abonnement.</i> <br><br><a name="the-end"></a><h1>  Conclusion </h1><br>  Pour le moment, seule la fonctionnalité de base est implémentée.  De plus, il est prévu d'améliorer le traitement par lots, d'essayer d'implémenter une sémantique exacte, d'ajouter la possibilité d'envoyer des messages au courtier via HTTP et, plus important encore, de prendre en charge d'autres Pub-Sub populaires. <br><br>  Le service Queue-Over-Http est actuellement en cours de développement.  La version 0.1.3 est suffisamment stable pour les tests sur les stands de développement et de scène.  Les performances ont été testées sur Windows 10, Debian 9 et Ubuntu 18.04.  Vous pouvez utiliser prod à vos risques et périls.  Si vous souhaitez aider au développement ou donner des commentaires sur le service - bienvenue dans le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/viirtus/queue-over-">Github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435346/">https://habr.com/ru/post/fr435346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435334/index.html">Réaction aux lettres froides</a></li>
<li><a href="../fr435336/index.html">Quelque chose a trouvé: papiers avec la rencontre Elasticsearch Moscou à OZON</a></li>
<li><a href="../fr435338/index.html">Nous créons un système de chronométrage électronique des courses</a></li>
<li><a href="../fr435340/index.html">Un chercheur publie un exemple de code de travail de ver pour Facebook</a></li>
<li><a href="../fr435344/index.html">Amazon a présenté Showroom, ou pourquoi nous allons bientôt acheter tous les meubles en ligne</a></li>
<li><a href="../fr435348/index.html">Simple MCerver - un petit shell pour le serveur Minecraft</a></li>
<li><a href="../fr435352/index.html">Conférence DEFCON 18. Espionnage pratique avec un téléphone portable. 2e partie</a></li>
<li><a href="../fr435354/index.html">Conférence DEFCON 18. Espionnage pratique avec un téléphone portable. Partie 1</a></li>
<li><a href="../fr435358/index.html">Antiquités: Minidisk à l'ère de l'iPod</a></li>
<li><a href="../fr435360/index.html">Snippets vs Clover - battez le quiz en temps réel le plus populaire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>