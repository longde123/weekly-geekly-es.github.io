<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤ üíû üï§ ¬øEs posible renderizar im√°genes realistas sin n√∫meros de punto flotante? ‚ÄºÔ∏è ü§® üè∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 

 "¬øQu√© sucede si reemplazamos los n√∫meros de coma flotante con n√∫meros racionales y tratamos de representar la imagen?" 

 Me hice esta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øEs posible renderizar im√°genes realistas sin n√∫meros de punto flotante?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448558/"><h2>  Introduccion </h2><br><hr><br>  "¬øQu√© sucede si reemplazamos los n√∫meros de coma flotante con n√∫meros racionales y tratamos de representar la imagen?" <br><br>  Me hice esta pregunta despu√©s de pensar en el tweet de un investigador y profesor de gr√°ficos por computadora Morgan McGwire.  Habl√≥ sobre cu√°nto se sorprenden los estudiantes de ciencias de la computaci√≥n cuando descubren que para almacenar los n√∫meros familiares de coma flotante en las computadoras modernas, deben hacerse compromisos.  Y estos compromisos dificultan las tareas simples, por ejemplo, verificar si un punto pertenece a un tri√°ngulo.  El problema, por supuesto, es que verificar que cuatro puntos est√©n en el mismo plano (coplanaridad) usando el determinante o alg√∫n tipo de multiplicaci√≥n vectorial (pero de hecho esto es lo mismo) nunca dar√° un valor exactamente igual a cero, lo cual es necesario Estos son m√©todos matem√°ticos.  Incluso si los c√°lculos reales de estar en el mismo plano fueran precisos, los mismos compromisos con una precisi√≥n de casi 1.0 dar√≠an la respuesta de que los cuatro puntos en s√≠ mismos no son coplanares. <br><br>  Esto dio origen a la idea en m√≠: si asumimos que todos los datos entrantes del renderizador (coordenadas de v√©rtice, transformaciones 3D, etc.) se configuraron como n√∫meros racionales, entonces crear√≠an todas las operaciones, desde crear un rayo, atravesando la estructura de aceleraci√≥n hasta la intersecci√≥n ¬ølos rayos con tri√°ngulos son solo n√∫meros racionales?  Si ese fuera el caso, ¬°podr√≠amos llevar a cabo una prueba de coplanaridad exactamente!  Quiz√°s se pregunte por qu√© una escena 3D expresada en n√∫meros racionales solo deber√≠a dar resultados en n√∫meros racionales ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/c79/14b/a99c7914bc94ae608f4215c34cbe4f66.jpg"></div><br>  <i>Una escena simple, el trazado de ruta en el que se realiza mediante aritm√©tica racional.</i>  <i>Utiliza un sistema de n√∫meros de <b>punto</b> flotante, no un <b>n√∫mero de punto</b> flotante.</i> <br><a name="habracut"></a><br>  En primer lugar, un n√∫mero racional es un n√∫mero que se puede expresar como la raz√≥n de dos enteros, por ejemplo 1/2 o 355/113.  En segundo lugar, las "operaciones de renderizado normales", como las pruebas de cuadro delimitador, la verificaci√≥n de la intersecci√≥n de un rayo con un tri√°ngulo, la reflexi√≥n de un rayo, etc., se basan en productos vectoriales y escalares, as√≠ como en la divisi√≥n escalar (esto incluye transformaci√≥n de coordenadas e inversi√≥n de matrices, cuaterniones, etc.), que a su vez se basan en cuatro operaciones b√°sicas: suma, resta, multiplicaci√≥n y divisi√≥n.  Al sumar, restar, multiplicar y dividir n√∫meros racionales, tambi√©n se obtienen n√∫meros racionales.  El matem√°tico dir√≠a que muchos n√∫meros racionales forman un campo que est√° cerrado bajo cuatro operaciones aritm√©ticas b√°sicas.  Para nosotros, esto significa que si nos adherimos a n√∫meros exclusivamente racionales, podemos pasar de los datos de entrada de la escena 3D a una imagen completamente renderizada sin abandonar el mundo de los n√∫meros racionales. <br><br>  Las excepciones a la regla "las acciones sobre n√∫meros racionales dan n√∫meros racionales" son las ra√≠ces cuadradas y las funciones trigonom√©tricas / trascendentales.  En cuanto a lo √∫ltimo, siempre digo que si tuvo que realizar c√°lculos trigonom√©tricos en los interiores geom√©tricos de su renderizador, lo m√°s probable es que est√© haciendo algo mal (y le mostr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo solucionar los casos m√°s est√°ndar</a> ) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> en Habr√©].  En cuanto a las ra√≠ces cuadradas, con la excepci√≥n de las secciones c√≥nicas (esferas, cilindros, etc.) y la realizaci√≥n de sombreado / DFOS / coloraci√≥n, no es necesario normalizar los rayos y normalizar las superficies con la frecuencia habitual.  Ciertamente no es necesario hacerlo para crear un rayo, su paso, intersecci√≥n, reflejos, etc.  Desafortunadamente, a menudo veo que los programadores normalizan los valores sin otra raz√≥n que "bueno, no lo s√©, lo hago para poder jugar de manera segura".  En la pr√°ctica, en la parte de la representaci√≥n en la que se traza la geometr√≠a, rara vez es necesario normalizar los valores, as√≠ que ten√≠a la esperanza de que pudieras rastrear toda la escena sin abandonar el mundo de los n√∫meros racionales; esto es lo que llamar√≠a "representaci√≥n racional". <br><br>  Para poner esto en pr√°ctica, necesito crear un sistema de n√∫meros basado en n√∫meros racionales que una computadora pueda usar.  Luego, adem√°s, podr√≠a implementar los algoritmos habituales de trazado de ruta, calcular im√°genes sin p√©rdida de precisi√≥n, realizar comprobaciones de coplanaridad que tengan respuestas precisas y hacer felices a todos los estudiantes que estudian gr√°ficos por computadora. <br><br>  Este art√≠culo es una historia sobre dos noches de investigaci√≥n sobre el realismo de tal idea.  Hablar√© sobre los muchos aspectos que aprend√≠, sobre lo que se me ocurri√≥ y sobre algunas sorpresas que descubr√≠ en el proceso.  El art√≠culo est√° escrito en un orden m√°s o menos cronol√≥gico de mi trabajo.  Adem√°s, fue escrito en mi estilo inusualmente informal y muy poco cient√≠fico (del cual estoy orgulloso).  La imagen que se muestra arriba es una especie de spoiler, pero lea el art√≠culo hasta el final, porque hablar√© sobre lo bueno y lo malo. <br><br><h2>  Preparaci√≥n </h2><br><hr><br>  Lo primero que hice fue implementar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shadertoy un</a> trazador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≠nimamente</a> limitado para una escena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extremadamente simple que</a> consta de un plano, una esfera, un paralelep√≠pedo rectangular y un tri√°ngulo, los bloques de construcci√≥n de los renderizadores reales.  Luego copi√© el c√≥digo en un archivo C ++ y, despu√©s de hacer un par de cambios menores, lo compil√© usando mi marco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">piLibs</a> .  Entonces, para comparar, obtuve una imagen trazada en la CPU usando n√∫meros regulares de acuerdo con el est√°ndar IEEE754 con un punto flotante.  Tambi√©n elimin√© toda la normalizaci√≥n de rayos del c√≥digo de seguimiento, porque, como se mencion√≥ anteriormente, ninguno de ellos es realmente necesario.  Perm√≠tame recordarle que se requiere una ra√≠z cuadrada para la normalizaci√≥n, y los n√∫meros racionales no se conservan cuando se usa (la ra√≠z cuadrada de un n√∫mero racional no es un n√∫mero racional).  Un poco m√°s tarde veremos que todav√≠a es posible aplicar ra√≠ces cuadradas, por supuesto, solo quer√≠a que el c√≥digo fuera lo m√°s matem√°ticamente posible para ver hasta d√≥nde puedo llegar con la aritm√©tica exacta de n√∫meros racionales sin redondear. <br><br>  El √∫ltimo paso preparatorio: tom√© todas las clases vec3, mat4x4 y otras clases b√°sicas de √°lgebra / matem√°ticas, y luego las cambi√© para que usaran racional en lugar de flotante.  Dado que mi estructura racional sobrecarga todos los operadores est√°ndar (suma, sub, mul, div, inversi√≥n de signos, comparaciones, etc.), el reemplazo se produjo sin problemas.  R√°pidamente implement√© las operaciones habituales restantes (abs, signo, mod, fract, piso, sqrt, etc.), lo que te√≥ricamente fue suficiente para obtener hermosas representaciones racionales. <br><br><h2>  Prueba 1 - La soluci√≥n ingenua </h2><br><hr><br>  Pero veamos c√≥mo fue esta primera implementaci√≥n.  Al principio siempre intento lo m√°s simple, y luego miro los resultados.  Y la forma m√°s sencilla de implementar valores racionales era usar dos enteros.  Como sugiere el nombre de la secci√≥n, esta no ser√° mi decisi√≥n final, pero para el primer intento fue una decisi√≥n razonable.  Entonces, cada n√∫mero <b>x</b> debe representarse como el numerador <b>N</b> y el denominador <b>D</b> , formando el valor <b>N</b> / <b>D.</b>  El valor <b>x</b> se aproxima por el mejor par <b>N</b> / <b>D</b> posible (dentro de la profundidad de bits especificada), que est√° m√°s cerca del valor <b>x</b> verdadero.  Decid√≠ que ambos n√∫meros deben ser positivos, y el signo del n√∫mero debe almacenarse en un bit separado para simplificar el trabajo y deshacerse de las ambig√ºedades, aunque esto no es muy importante.  En esta etapa, tanto los numeradores como los denominadores eran de tipo sin signo.  Pero incluso al separar el signo, <b>N</b> / <b>D</b> ten√≠a mucha redundancia: por ejemplo, 1/4 y 7/28 denotan el mismo n√∫mero, pero tienen representaciones de bits completamente diferentes.  Hablaremos de esto m√°s adelante, pero por ahora, no centremos nuestra atenci√≥n y veamos c√≥mo se ven las cuatro operaciones aritm√©ticas b√°sicas en esta forma racional. <br><br>  Primero, tenga en cuenta que restar <b>a</b> - <b>b</b> es simplemente la suma de <b>ay</b> el valor opuesto a <b>b</b> , es decir, <b>a</b> + ( <b>-b</b> ), donde <b>-b</b> se puede calcular simplemente cambiando el signo de <b>b</b> .  Del mismo modo, dividir <b>a</b> / <b>b</b> es lo mismo que multiplicar <b>ay</b> el inverso de <b>b</b> .  O, en otras palabras, <b>a</b> / <b>b</b> = <b>a</b> ¬∑ (1 / <b>b</b> ), donde (1 / <b>b</b> ) se puede calcular simplemente cambiando los lugares del numerador <b>b <sub>n</sub></b> y el denominador <b>b <sub>d del</sub></b> n√∫mero <b>b</b> .  Entonces, aqu√≠ est√° la primera propiedad interesante de la aritm√©tica racional: la divisi√≥n y la multiplicaci√≥n tienen los mismos costos, por lo tanto, a diferencia de la representaci√≥n de coma flotante habitual, en la que las divisiones generalmente se evitan, retrasan u ocultan bajo los retrasos de las solicitudes de textura lenta, no hay necesidad de temer estas operaciones en aritm√©tica racional . <br><br>  Pasamos a la suma con la multiplicaci√≥n: sabemos que los valores opuestos e inversos son trivialmente simples de calcular, por lo que obtenemos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20f/b96/9c6/20fb969c6d2d6ad899898575244a8d20.png"></div><br>  La preservaci√≥n de los signos durante la multiplicaci√≥n es trivial, es solo xor, porque dos valores positivos dan un resultado positivo, as√≠ como dos negativos.  Guardar un signo para sumar es un proceso m√°s complicado, y para una soluci√≥n r√°pida lo implement√© a trav√©s de tres ramas (la suma es trivial si los signos <b>a</b> y <b>b</b> coinciden, pero cuando no coinciden, entonces debe seleccionar un n√∫mero m√°s peque√±o y restarlo del m√°s grande; en el art√≠culo no Describir√© detalles tan peque√±os con m√°s detalle, pero solo tendr√© el c√≥digo fuente en alguna parte). <br><br>  Tambi√©n omitir√© la implementaci√≥n de fract () y floor ();  Si decide intentar implementarlos usted mismo, ver√° su simplicidad y belleza.  Tambi√©n se debe prestar atenci√≥n a los operadores de comparaci√≥n.  Despu√©s de ocuparse de los signos y asumir que <b>ayb son</b> positivos, obtenemos <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/b9c/831/6e4b9c831e9b49215c939fedc88ee0cd.png"></div><br>  Es importante se√±alar aqu√≠ que, incluso para la comparaci√≥n, necesitamos un par de operaciones de multiplicaci√≥n, que pueden conducir a la transici√≥n al siguiente tama√±o de palabra y ser√°n importantes un poco m√°s bajas. <br><br>  Finalmente, observamos las ra√≠ces cuadradas en una secci√≥n separada, sabiendo que en su mayor parte no las necesitamos (excepto la esfera de esta primera prueba). <br><br>  Esto fue suficiente para ejecutar el primer render y rastrear la escena de prueba (plano + esfera + tri√°ngulo + caja rectangular) para ver qu√© suced√≠a.  Generosamente utilic√© n√∫meros racionales de 65 bits para esta primera prueba, que en realidad representa una gran cantidad de datos (comparable al tipo de datos "doble"): 32 bits son tomados por el numerador, 32 bits son el denominador y otro bit es el signo.  La primera es la imagen obtenida con este enfoque ingenuo, la segunda es la imagen hecha con n√∫meros de punto flotante (referencia): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/628/aca/f79628aca052bc725fa16953c8939a5c.png"></div><br>  <i>N√∫meros racionales "ingenuos" de 65 bits</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Referencia de punto flotante</i> <br><br>  El resultado fue bastante malo, la caja y el tri√°ngulo ni siquiera aparec√≠an en el render, y la esfera y el plano del piso eran demasiado ruidosos.  El problema, por supuesto, era que cada vez que mis n√∫meros racionales realizaban cualquier operaci√≥n aritm√©tica b√°sica en cualquiera de las etapas algor√≠tmicas de representaci√≥n, el numerador y el denominador se volv√≠an cada vez m√°s incontrolables, porque se usaba la multiplicaci√≥n entera.  Piense en lo siguiente: si las unidades de nuestro mundo inicial fueran metros, y vinculamos la geometr√≠a fuente (v√©rtices y c√°mara) a una precisi√≥n milim√©trica, entonces solo los datos fuente ocupar√≠an un volumen de 16 bits para una escena bastante peque√±a.  Al mismo tiempo, con una resoluci√≥n de pantalla HD est√°ndar y un suavizado 4X, los n√∫meros de direcci√≥n de haz racionales requerir√≠an f√°cilmente 12 bits.  Es decir, durante la primera interacci√≥n del haz y la geometr√≠a, la operaci√≥n aritm√©tica m√°s simple que usa ambos conjuntos de datos de entrada convertir√≠a el resultado en longitudes de 28 bits, lo suficientemente cerca del l√≠mite de 32 bits que establec√≠ para m√≠ en esta primera implementaci√≥n.  Y esto es incluso antes de que realicemos el primer producto vectorial o escalar.  Para cuando el producto escalar est√© completo, el renderizador necesitar√≠a n√∫meros racionales de cientos de bits de longitud para representar los n√∫meros.  Por supuesto, este es el peor de los casos, pero el caso promedio estar√≠a cerca de esto.  Teniendo en cuenta que asign√© solo una capacidad de 32 bits para el numerador y el denominador, es f√°cil entender qu√© tan r√°pido los valores van m√°s all√° de los l√≠mites en esta prueba; no es sorprendente que, con la excepci√≥n del plano del piso y parte de la esfera, casi nada sea visible. <br><br><h2>  Prueba 2 - Reducci√≥n por el factor com√∫n m√°s grande </h2><br><hr><br>  Luego mejor√© el sistema usando la propiedad que mencion√© brevemente anteriormente: diferentes n√∫meros racionales pueden significar la misma cantidad.  Y, de hecho, 6/12 es el mismo valor que 1/2, pero utiliza muchos m√°s bits que el anterior.  Por lo tanto, la idea era la siguiente: si despu√©s de cada operaci√≥n aritm√©tica b√°sica (o despu√©s de ella) extraer√≠a todos los divisores comunes del numerador y los denominadores, y llevar√≠a la fracci√≥n a su forma m√°s simple, entonces quiz√°s pueda mantener todo bajo control y continuar las operaciones por m√°s tiempo con aritm√©tica exacta sin p√©rdida de precisi√≥n.  ¬øQuiz√°s pueda hacer esto el tiempo suficiente para obtener im√°genes limpias y renderizadas?  Har√© una peque√±a digresi√≥n para mostrar otro ejemplo: 588/910 se puede simplificar a 42/65, porque 14 es un divisor de 588 y 910. Pero para almacenar 42/65, obviamente, se necesitan menos bits que 588/910.  Encontrar el n√∫mero m√°s grande posible que divide simult√°neamente los otros dos n√∫meros se puede hacer usando el algoritmo del Gran Divisor Com√∫n (GCD), implementaciones efectivas que puedes encontrar en cualquier lugar (lo copi√© personalmente directamente de Wikipedia y lo aceler√© un poco realizando el paso de escaneo bits utilizando operaciones internas x64).  Entonces, armado con el algoritmo GCD, mi clase racional deber√≠a simplificar constantemente las fracciones generadas durante el proceso de renderizado.  Esto podr√≠a hacerse de dos maneras: <br><br>  El primero es convertir el resultado intermedio de los operadores de suma y multiplicaci√≥n al siguiente tipo de datos de bits (en mi soluci√≥n ingenua actual es uin64_t), buscar GCD en este tipo de datos m√°s voluminoso y luego reducir el resultado a la longitud de bits original (32).  La segunda forma es analizar c√≥mo <b>a <sub>n</sub></b> , <b>a <sub>d</sub></b> , <b>b <sub>n</sub></b> y <b>b <sub>d</sub></b> se combinan entre s√≠ en ambos operadores aritm√©ticos y extraer divisores comunes de ellos antes de realizar la multiplicaci√≥n.  El segundo enfoque b√°sicamente elimin√≥ la necesidad de grandes longitudes de bits.  Sabiendo que podr√≠a ser necesario usarlos de todos modos, decid√≠ elegir el primer m√©todo, porque era m√°s f√°cil de implementar y me permit√≠a acelerar mi trabajo (la noche vuela muy r√°pido).  Una vez hecho todo esto, veamos qu√© render puedo crear ahora: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb9/bc5/66f/eb9bc566f927cab52570332aff765d02.png"></div><br>  <i>N√∫meros racionales de 65 bits reducidos por GCD</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br>  <i>Referencia de punto flotante</i> <br><br>  Mucho mejor!  Hasta ahora, lejos de ser ideal, por supuesto, pero parece prometedor.  Hice aparecer la caja y el tri√°ngulo, y la esfera ahora parece mucho m√°s voluminosa.  Sin embargo, apareci√≥ un artefacto divertido en la esquina superior derecha, y los n√∫meros racionales para muchos p√≠xeles a√∫n van m√°s all√° de los l√≠mites, lo que conduce a muchos puntos en la imagen.  Sin embargo, vale la pena se√±alar que para algunos (muchos) p√≠xeles, ¬°comenc√© a obtener resultados <b>precisos</b> y perfectos!  Es decir, el trazador encontr√≥ intersecciones matem√°ticamente precisas de puntos y distancias, que fue la causa principal de tratar de usar n√∫meros racionales. <br><br>  Antes de proceder al siguiente paso en el proceso de probar la aplicabilidad de los n√∫meros racionales, quiero detenerme brevemente y compartir mis hallazgos con respecto a MCD y la reducci√≥n de n√∫meros racionales. <br><br>  El primer descubrimiento est√° relacionado con el volumen de bits de los n√∫meros racionales.  Aunque todav√≠a no puedo reproducir im√°genes hermosas y esto es m√°s importante que preocuparme por optimizar los vol√∫menes de datos, y aunque esta implementaci√≥n inicial todav√≠a usaba una gran cantidad de bits (1 + 32 + 32), ya estaba pensando en el desperdicio mencionado anteriormente bits en forma de fracciones en exceso.  En particular, despu√©s de agregar una etapa con un GCD, las combinaciones de bits como 2/4 ya no son aplicables, ya que se reducen autom√°ticamente a 1/2 antes de escribir en cualquier registro o variable.  Es decir, en cierto sentido, de las 2 <sup>64</sup> combinaciones de bits que podr√≠an ser un numerador y un denominador, muchas permanecieron sin usar.  Y no puedes desperdiciar trozos as√≠.  ¬øO es posible?  ¬øCu√°nto espacio pierdo realmente?  Hice una peque√±a digresi√≥n para explorar este problema. <br><br><h2>  Digresi√≥n - En n√∫meros primos mutuos </h2><br><hr><br>  Las siguientes ilustraciones muestran el uso de bits para n√∫meros racionales en 5/5 bits y 7/7 bits.  Los ejes horizontal y vertical de los gr√°ficos representan los valores del numerador y denominador de todos los n√∫meros racionales posibles que tienen numeradores y denominadores de hasta 5 bits (31) y 7 bits (127).  Los p√≠xeles negros son combinaciones no utilizadas, y los p√≠xeles blancos son fracciones utilizadas.  Por ejemplo, toda la diagonal es negra, excepto el p√≠xel 1/1, porque todas las fracciones de la forma n / n se reducen a 1/1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6c/f08/b9d/c6cf08b9df8d1adecee7836e92a228be.png"><br><br>  <i>Usando bits para 5/5 racional</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16e/79b/24b/16e79b24b234907f082af70a013ae971.png"><br><br>  <i>Usando bits para 7/7 racional</i> <br><br>  Si cuenta los p√≠xeles, como lo hice, entonces puede comprender r√°pidamente que la proporci√≥n de p√≠xeles √∫tiles con un aumento en el n√∫mero de bits tiende a 60.8%.  Una peque√±a investigaci√≥n en l√≠nea me mostr√≥ que esta relaci√≥n resulta ser exactamente 6 / œÄ <sup>2</sup> , porque tambi√©n es la probabilidad de ser relativamente primo (no tener divisores comunes) para dos n√∫meros aleatorios.  Usted puede preguntar, ¬øde d√≥nde vino el pi? ,  ¬´  ‚Äû‚Äú  ¬ª ‚Äî  ,  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- </a> ,    2, 1/Œ∂(2).      ,   -            . <br><br>     , ,          40%  .      ,      ,        ‚Ä¶      .  ,    ,  ,   ,  ,       .  -      -  -,          ,          ,          . ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     . <br><br>    ,   :      ,          .     ,       ‚Äî               (, , ),  ¬´¬ª  ,       ,     .      ,    .  ,   ,    ,             .             .     . <br><br> ,    ‚Äî  -      ,      ,       . ,    16/16-  ,              ,    16/16     ++    . <br><br><h2>  3 ‚Äî    </h2><br><hr><br> ,         . ,              .        <b></b> ,      ,           ,    ,  ,      ( ,     ‚Äî      ,            . ,     ,       ,           ). <br><br>     ,   ,     ,    -       .       ,         ,          .  ,      ,     ,  ,    <b></b> .        . <br><br>         ,     ,    ,        (       ).         ,     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/c9d/8db/912c9d8dbc165e2aa14843cb3b3ccd12.png"></div><br> <i>65-        </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i>   </i> <br><br>      ,               .     32/32 (65 ) 16/16 (33 ),      !    ,        ,        .     ,       .        . <br><br><h2>  4 ‚Äî    </h2><br><hr><br>           ‚Äî     -      ,     32    .      ,     (      ). <br><br>   ,       ,          . ,      ‚Äî        ,    . ,   ,    .    ,     ,  .             .   ,              ,  ¬´¬ª   .              .        16/16,     32-    16/16,   5/27  13/19,  . <br><br>   .      /        .       1|5|26,  : <br><br><blockquote> 1 :  <br> 5 :    (B) <br> 26 :     ;  ‚Äî   26-B ,  ‚Äî  B , </blockquote><br>    (B)   . ,  7/3    <br><br><blockquote> 7/3 = 0 00010 000000000000000000000111 11, </blockquote><br>   0   ,   2   ( 3),     2 ,       . <br><br>  ,     IEEE754,     :       ¬´1¬ª,           .       .     ¬´3¬ª      ¬´1¬ª     ¬´1¬ª: <br><br><blockquote> 7/3 = 0 00001 0000000000000000000000111 1 </blockquote><br>         ,       :      ,     ,    1        .  ,               ,       2 <sup>26</sup> ,      .   !           , ¬´rational¬ª,       ,              ‚Äî        ,       (¬´int¬ª  ¬´float¬ª)        !    ,          ¬´int¬ª  ¬´rational¬ª.    ,           . <br><br>  ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcb/a9b/34d/fcba9b34d81aae413f1288e6dcfcdf9b.png"></div><br> <i>32-     <b> </b> (1|5|26)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/e83/749/dcde8374930d99d48b070981d62043be.png"></div><br> <i>32-    <b></b></i> <br><br> --, !   -    ,           ,      - .       . ,  ,           ,    ,        .                (  ),  ,            . <br><br>           (     ‚Äî       ).         (      )           ,     GPU  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.shadertoy.com/view/Xd2fzR</a> . <br><br>       C++,         .    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b9/e7d/951/5b9e7d951bbef194094a389017433a50.jpg"></div><br> <i>32-     <b> </b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/58f/543/20d58f54338c93f88379f550faf52c51.jpg"></div><br> <i>32-    <b></b></i> <br><br> ,    !        ,      .     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36d/404/72d/36d40472de509e4fe6a7520c7e6df5a4.png"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/9da/0d6/ffd9da0d613a076c0c624e5a9b2c15e9.png"><img src="https://habrastorage.org/getpro/habr/post_images/273/84b/a41/27384ba41a08f4771f8cf6c6cddd129d.png"><br><br> ,           ,      ;     .   ,     ,     .     ,   .   ,       ,        : <br><br><h2>    </h2><br><hr><br><h3>    64  </h3><br>         64-  ,   32- (1|5|26)      .     64-     ? <br><br>      1|6|57 (       x64   ).  57  /      .              <b></b>  (         ,       ).    !   ,      ,       ,      .     ,    ,     ¬´¬ª  .  .  ,  ,  64      ,       .        :   - ,      ,     ,    ? ,        ¬´¬ª  ?        ,        . <br><br><h3>   </h3><br>   ()             .           .     ( <b></b> )       (  ),        .      ‚Äî       ,       ,      .             .      . <br><br>   :   ,       <b>x</b>  <b>y</b> , ,  <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/769/1eb/d9b/7691ebd9ba782aacba6bc480f13199a8.png"></div><br>          ()    (¬´¬ª ,      ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/9db/7db/aaf9db7db7d1ee8300d090ea1e97535b.png"></div><br>  Despu√©s de buscar en Wikipedia, descubr√≠ que esta ecuaci√≥n en particular es la llamada "ecuaci√≥n de Pell modificada".  Hay algoritmos que encuentran los valores m√°s peque√±os de <b>x</b> e <b>y</b> para resolver esta ecuaci√≥n.  Desafortunadamente, mi atenci√≥n cambi√≥ r√°pidamente a otras matem√°ticas diofantinas curiosas, y no proced√≠ con la implementaci√≥n de ninguno de estos algoritmos. <br><br><h3>  Reducci√≥n m√°s efectiva </h3><br>  En los √∫ltimos minutos de la noche, pens√© en explorar la idea de usar m√∫ltiples miembros que se combinen en operadores geom√©tricos complejos, por ejemplo, en un producto vectorial.  Digamos que el primer componente de un producto vectorial fue <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/4b5/c33/c844b5c33c70116474bbaa0c63273ad7.png"></div><br>  bajo el supuesto de que sy = a / b, tz = c / d, ty = e / f, sz = g / h <br><br>  Esto significa que ahora puedo intentar encontrar divisores comunes, por ejemplo, entre a y d, o e y h, y usarlos para la reducci√≥n preliminar. <br><br>  Ten√≠a otra idea: si en alg√∫n momento la velocidad de renderizado se convierte en un problema, puede deshabilitar por completo los pasos de b√∫squeda de GCD y aplicar solo la normalizaci√≥n.  Una comprobaci√≥n r√°pida mostr√≥ que, en este caso, los renderizados de im√°genes siguen siendo aceptables y funcionan bien a una velocidad mucho mayor.  Sin embargo, en este caso, por supuesto, obtenemos menos resultados aritm√©ticamente precisos. <br><br>  Como compromiso, puede negarse a implementar un procedimiento o un esquema GCD, y en su lugar usar algo matem√°ticamente simple, codificado en el c√≥digo y efectivo, determinando la divisibilidad solo por 2, 3 y 5. Aunque de esta manera no encontraremos un n√∫mero exhaustivo de divisores, por en la pr√°ctica, esto llevar√≠a a encontrar una gran cantidad de abreviaturas.  Pi√©nselo: ¬°la divisibilidad entre 2 ocurre tres veces m√°s que la divisibilidad entre 7 y 20 veces m√°s que la divisibilidad entre 41! <br><br><h2>  Conclusi√≥n </h2><br><hr><br>  Despu√©s de este experimento, comenc√© a creer que es bastante posible que una representaci√≥n de n√∫meros se base en n√∫meros racionales, similar a lo que yo llamo la "fracci√≥n de l√≠nea flotante".  Una representaci√≥n compatible con enteros y capaz de realizar muchas operaciones en aritm√©tica exacta para muchas tareas (siempre que los datos de entrada se presenten de forma racional).  La versi√≥n de 64 bits (1 | 6 | 57) tiene un gran potencial, aunque la versi√≥n de 32 bits (1 | 5 | 26) ya crea representaciones interesantes. <br><br>  Si no fue un experimento durante dos noches, sino algo profesional creado en un estudio o empresa, en el futuro se podr√≠an tomar los siguientes pasos: <br><br>  * Obtenga un histograma de la cantidad de p√≠xeles con precisi√≥n y no exactamente trazados (en otras palabras, la frecuencia de ejecuci√≥n de normalizaci√≥n) <br>  * Intente implementar una reducci√≥n codificada en los divisores 2, 3 y 5 y mida el porcentaje de p√≠xeles exactos perdidos <br>  * Muestra la diferencia de p√≠xeles entre el renderizado en coma flotante y el renderizado en fracci√≥n flotante <br>  * Encuentre formas ingeniosas de utilizar los valores no utilizados del formato de bits "fracciones de l√≠nea flotante", por ejemplo, para indicar Inf y NaN <br>  * Implementar la detecci√≥n de NaN, Inf, underflow, overflow. <br><br>  En general, fue un estudio fascinante.  En el proceso, descubr√≠ algunas sorpresas, se me ocurri√≥ una peque√±a invenci√≥n y aprend√≠ mucho sobre la ecuaci√≥n de Pell, ra√≠ces cuadradas, MCD, mecanismos internos x86_64, la funci√≥n zeta de Riemann y algunos otros aspectos.  Estoy muy contento con esto! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448558/">https://habr.com/ru/post/448558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448540/index.html">VMware NSX para los m√°s peque√±os. Parte 5. Configurar el equilibrador de carga</a></li>
<li><a href="../448544/index.html">Paquetes en acero. Como se forman</a></li>
<li><a href="../448546/index.html">UITableView tama√±os autom√°ticos de encabezado y pie de p√°gina con AutoLayout</a></li>
<li><a href="../448548/index.html">Construcci√≥n en el arte: de Brueghel a Vasya Lozhkin</a></li>
<li><a href="../448552/index.html">ProLiant Series 100 - El hermano menor perdido</a></li>
<li><a href="../448560/index.html">Plan de transformaci√≥n de IA: ¬øc√≥mo gestionar una empresa en la era de la IA?</a></li>
<li><a href="../448562/index.html">Google ayuda a la polic√≠a a localizar dispositivos cerca de escenas del crimen utilizando datos de ubicaci√≥n</a></li>
<li><a href="../448564/index.html">El primero en el grupo: el primero en caer: evaluaci√≥n de los riesgos de liderazgo en grupos de animales autoorganizados</a></li>
<li><a href="../448568/index.html">C√≥mo implementar ISO 27001: instrucciones de uso</a></li>
<li><a href="../448570/index.html">Estimamos el rendimiento del canal MIMO (se incluye el algoritmo de vertido de agua)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>