<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏼 🖖🏾 🍍 Probar el código de SQL Server con tSQLt 👉🏽 🚼 🤘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FYI: este artículo es una versión ampliada de mi charla en SQA Days # 25. 

 En base a mi experiencia con colegas, puedo afirmar: la prueba de código ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Probar el código de SQL Server con tSQLt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/465567/">  <i>FYI: este artículo es una versión ampliada de mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">charla</a> en SQA Days # 25.</i> <br><br>  En base a mi experiencia con colegas, puedo afirmar: la prueba de código de base de datos no es una práctica ampliamente difundida.  Esto puede ser potencialmente peligroso.  La lógica de DB está escrita por seres humanos al igual que todos los demás códigos "habituales".  Por lo tanto, puede haber fallas que pueden causar consecuencias negativas para un producto, empresa o usuarios.  Si estos son procedimientos almacenados que ayudan al backend o si se trata de modificar datos de ETL en un almacén, siempre existe un riesgo y las pruebas ayudan a disminuirlos.  Quiero decirte qué es tSQLt y cómo nos ayuda a probar el código DB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2e/-h/nx/2e-hnxb3bddbq3ck_8vi4jwah8i.jpeg"></div><a name="habracut"></a><br><h1>  El contexto </h1><br>  Hay un gran almacén que utiliza SQL Server y contiene diferentes datos de ensayos clínicos.  Se llena de una variedad de fuentes (bases de datos orientadas a documentos principalmente).  Muchas ETL transforman datos dentro del almacén en muchas ocasiones.  Estos datos se pueden cargar en bases de datos más pequeñas para que las utilicen las aplicaciones web orientadas a pequeñas tareas específicas.  Algunos de los clientes del cliente solicitaron implementar API para sus necesidades.  Dichas API a menudo usan procedimientos almacenados y consultas diferentes. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/iw/vu/rz/iwvurz8sbflhuz3mkj39ipf9rag.png"></div><br>  En general, hay una gran cantidad de código en el lado de DBMS. <br><br><h1>  ¿Por qué necesitamos esto? </h1><br>  Como puede ver en la introducción, el código DB es parte del código de la aplicación y también puede contener errores. <br><br>  Supongo que muchos de nosotros estamos familiarizados con la curva de Boehm: los errores siempre son más caros de solucionar más adelante en el proceso.  Un error que se realizó en una etapa de desarrollo anterior y se localizó en una posterior puede costar más.  Esto se debe a la necesidad de pasar por muchos pasos intermedios (codificación, prueba unitaria, prueba de integración, prueba del sistema, etc.) dos veces: para la depuración y para devolver el código a la etapa donde se encontró.  Este efecto también es cierto para el caso del almacén.  Si hay un error en un procedimiento ETL y los datos se modifican varias veces, debemos: <br><br><ol><li>  siga todos los pasos de transformación de datos de vuelta a la fuente del problema </li><li>  arreglar el problema </li><li>  derivar los datos correctos nuevamente (se pueden requerir ediciones manuales adicionales) </li><li>  asegúrese de que no haya otros datos rotos causados ​​por el error. </li></ol><br>  No olvides que no vendemos peluches.  Un error en un área como los ensayos clínicos puede dañar no solo los negocios sino también la salud humana. <br><br><h1>  ¿Cómo hacer la prueba? </h1><br>  Como estamos hablando de pruebas de código, nos referimos a pruebas de unidad e integración.  Estas cosas son muy repetitivas e implican una regresión persistente.  Estrictamente hablando, tales pruebas nunca se realizan manualmente (bueno, excepto algunos casos singulares probablemente). <br><br>  Bonificación adicional: las pruebas pueden ser materiales de apoyo para la documentación del código.  Por ejemplo, los requisitos pueden verse así (hacer clic): <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/fh/af/xb/fhafxb5yph-tgvy2zhka9jfcvmk.png"></a> </div><br>  Archivo XLS, 2 columnas con requisitos + información adicional fragmentada en otras columnas + marcado confuso.  Puede ser difícil restaurar los deseos iniciales si es necesario.  Las pruebas pueden ayudar a registrar los matices de implementación.  Por supuesto, no deben considerarse como un reemplazo de la documentación. <br><br>  Desafortunadamente, la complejidad de las pruebas aumenta con el crecimiento de la complejidad del código, por lo que este efecto se puede suavizar. <br><br>  Las pruebas pueden ser una capa de seguridad adicional contra fusiones espontáneas.  Las pruebas automáticas de CI ayudan con este problema debido a su formalismo. <br><br>  Entonces, si hemos decidido usar la automatización, debemos elegir una herramienta para ello. <br><br><h1>  ¿Qué usar para las pruebas? </h1><br>  En el caso de las pruebas de código DB, veo 2 enfoques: con tecnología SQL (cuando una herramienta funciona en DBMS directamente) y sin tecnología SQL.  Estas son las principales diferencias que encontré: <br><div class="scrollable-table"><table><tbody><tr><th>  Impulsado por SQL <br></th><th>  No alimentado por sql <br></th></tr><tr><td>  Requiere la instalación de objetos DB <br></td><td>  Requiere la instalación de herramientas externas (en relación con DB) <br></td></tr><tr><td>  Las pruebas son independientes de las tecnologías utilizadas fuera de DB <br></td><td>  Las pruebas pueden depender de tecnologías utilizadas fuera de DB <br></td></tr><tr><td>  El marco siempre está dedicado a un solo DBMS <br></td><td>  Framework a menudo soporta múltiples DBMS <br></td></tr><tr><td>  El conocimiento de DBMS es el único requisito para escribir pruebas;  Es posible utilizar probadores manuales o DBA <br></td><td>  Se requieren conocimientos adicionales de lenguajes o tecnologías de programación para escribir pruebas;  a menudo se necesita la ayuda de un desarrollador <br></td></tr><tr><td>  La ejecución a nivel de DBMS permite el uso avanzado de falsificaciones y aserciones. <br></td><td>  La ejecución fuera de un DBMS puede limitar las características de la herramienta <br></td></tr></tbody></table></div>  En el caso de SQL Server, tenemos varias opciones: <br><div class="scrollable-table"><table><tbody><tr><th colspan="6" align="center">  Información general </th></tr><tr><th>  Nombre </th><th>  Enfoque </th><th>  Arquitectura </th><th>  Lengua / Plataforma </th><th>  Idioma de las pruebas </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tSQLt</a> </td><td>  Impulsado por SQL </td><td>  xUnit </td><td>  T-SQL + CLR </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TSQLUnit</a> </td><td>  Impulsado por SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utTSQL</a> </td><td>  Impulsado por SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tst</a> </td><td>  Impulsado por SQL </td><td>  xUnit </td><td>  T-sql </td><td>  T-sql </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dbfit</a> </td><td>  No alimentado por sql </td><td>  Fitnessess </td><td>  C # / java </td><td>  Markdown de Wiki </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vago</a> </td><td>  No alimentado por sql </td><td>  RSpec (orientado a BDD) </td><td>  Rubí </td><td>  Rubí </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NUnit</a> , etc. </td><td>  No alimentado por sql </td><td>  xUnit </td><td>  N / a </td><td>  N / a </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="4" align="center">  Fechas </th></tr><tr><th>  Nombre </th><th>  Primera aparición </th><th>  Último compromiso </th><th>  Último lanzamiento </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tSQLt</a> </td><td>  2007-07-27 </td><td>  07/07/2019 </td><td>  31/01/2016 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TSQLUnit</a> </td><td>  2006-12-16 (0.9) <br>  2007-07-21 (0.91 rc1) </td><td>  26/04/2018 (GitHub) </td><td>  04/09/2011 (SourceForge) </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utTSQL</a> </td><td>  2003-03-12 </td><td>  2003-03-12 </td><td>  2003-03-12 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tst</a> </td><td>  02-03-2009 (v1.0) </td><td>  N / a </td><td>  30-03-2012 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dbfit</a> </td><td>  12-01-2009 </td><td>  10-09-2018 </td><td>  15/08/2015 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vago</a> </td><td>  23/06/2011 </td><td>  12-12-2018 </td><td>  12-12-2018 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NUnit</a> , etc. </td><td>  N / a </td><td>  N / a </td><td>  N / a </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="7" align="center">  Caracteristicas </th></tr><tr><th>  Nombre </th><th>  No se requiere CLR </th><th>  Salida XML </th><th>  Pruebas en transacciones separadas. </th><th>  Falsificaciones </th><th>  Manejadores de errores </th><th>  Aserciones </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tSQLt</a> </td><td>  - </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td><td>  Excelente </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TSQLUnit</a> </td><td>  + </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  Fallando </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utTSQL</a> </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  Por debajo del promedio </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tst</a> </td><td>  + </td><td>  + </td><td>  + (opcional) </td><td>  - </td><td>  + </td><td>  Excelente </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dbfit</a> </td><td>  + </td><td>  - </td><td>  + (opcional) </td><td>  - </td><td>  + </td><td>  Muy bueno  matizado </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vago</a> </td><td>  + </td><td>  - </td><td>  + (opcional) </td><td>  - </td><td>  - </td><td>  Muy bueno  matizado </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NUnit</a> , etc. </td><td>  + </td><td>  + </td><td>  N / a </td><td>  N / a </td><td>  N / a </td><td>  Excelente;  matizado </td></tr></tbody></table></div><div class="scrollable-table"><table><tbody><tr><th colspan="3" align="center">  Otros </th></tr><tr><th>  Nombre </th><th>  Documentación </th><th>  Comunidad </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tSQLt</a> </td><td>  Excelente;  matizado </td><td>  Excelente </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TSQLUnit</a> </td><td>  Por debajo del promedio </td><td>  Por debajo del promedio </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utTSQL</a> </td><td>  Excelente </td><td>  Por debajo del promedio </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tst</a> </td><td>  Excelente </td><td>  Por debajo del promedio </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dbfit</a> </td><td>  Excelente </td><td>  Media </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vago</a> </td><td>  Excelente </td><td>  Media </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NUnit</a> , etc. </td><td>  Excelente </td><td>  Excelente </td></tr></tbody></table></div>  La escala "Excelente - Fallido" es subjetiva, lo siento, es difícil encontrar una solución. <br><br>  "Primera aparición" - la fecha más temprana de aparición del framework que pude encontrar - la primera versión o confirmación. <br><br>  Como puede ver, las alternativas basadas en SQL fueron abandonadas hace bastante tiempo, y tSQLt es el único producto actualmente compatible.  Además, tSQLt gana funcionalmente.  Lo único es que TST cuenta con un conjunto de afirmaciones un poco más rico que tSQLt;  Sin embargo, dudo que esto pueda superar todas las desventajas. <br><br>  La documentación de tSQLt tiene algunos matices, los describiré más adelante. <br><br>  En el mundo sin SQL, las cosas no están tan claras.  Se están desarrollando alternativas, aunque no súper activas.  DbFit es una herramienta bastante interesante basada en el marco FitNesse.  Implica usar el marcado de wiki para escribir pruebas.  Slacker también es interesante: se sugiere el enfoque BDD para las pruebas de código DB. <br><br>  Debo decir sobre aserciones en soluciones no basadas en SQL.  A primera vista, la cantidad de afirmaciones es menor, y podemos pensar que tales herramientas son peores.  Pero debemos tener en cuenta que son fundamentalmente diferentes de tSQLt, por lo que una mirada tan superficial es incorrecta. <br><br>  La última fila: "NUnit, etc."  - Es más como un recordatorio.  Con la ayuda de bibliotecas adicionales, se pueden aplicar muchos marcos de pruebas unitarias habituales al código DB.  Hay muchas N / A en esta fila porque esta fila, de hecho, incluye múltiples herramientas.  Esa es la fuente de "matices" en la columna "aserciones": diferentes herramientas pueden proporcionar diferentes conjuntos y no hay garantía de que todas las aserciones puedan aplicarse a la base de datos. <br><br>  Como otra métrica interesante, podemos considerar las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tendencias de Google</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/2u/km/ud2ukmcoyjvstvhcu2taegpib34.png"></div><br>  Matices: <br><br><ol><li>  Decidí no incluir Slacker porque este nombre puede significar cosas diferentes (y consultas como "Slacker framework" apenas se ven en el gráfico). </li><li>  Solo por curiosidad (y porque una ranura permaneció vacía), agregué la tendencia TST.  Pero apenas nos muestra la imagen real porque es la abreviatura que también puede significar cosas diferentes. </li><li>  No he incluido NUnit y sus análogos.  Estas herramientas son marcos para pruebas de código "habituales", por lo que sus tendencias no son descriptivas para nuestro contexto. </li></ol><br>  Como puede ver, tSQLt es la herramienta más buscable en la lista.  Otra herramienta (menos) popular es DbFit.  Otras herramientas tienen una popularidad limitada. <br><br>  En general, podemos ver que tSQLt brilla en el fondo. <br><br><h1>  ¿Qué es tSQLt? </h1><br>  Es fácil adivinar que tSQLt es un marco de pruebas unitarias basado en SQL.  El sitio oficial es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tsqlt.org</a> . <br><br>  Se promete que tSQLt es compatible con SQL Server a partir de 2005 SP2.  No he revisado tales revisiones tempranas, pero no veo ningún problema con 2012 en nuestro servidor de desarrollo y 2017 en mi máquina local. <br><br>  Código abierto, licencia Apache 2.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">disponible en GitHub</a> .  Como de costumbre, podemos bifurcar, contribuir, usar de forma gratuita en proyectos comerciales y, lo que es más importante, no debemos temer al spyware en CLR. <br><br><h1>  Mecánica </h1><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/1v/kx/wi/1vkxwixwjyna756vsce7uhwqzw0.png"></div><br>  Los casos de prueba son procedimientos almacenados.  Se pueden combinar en clases de prueba (conjunto de pruebas en terminología xUnit). <br><br>  Las clases de prueba no son más que esquemas de base de datos.  tSQLt requiere registrarlos con el procedimiento NewTestClass que agrega clases de prueba a una tabla especial. <br><br>  Es posible determinar un procedimiento de configuración.  Dicho procedimiento se ejecutará antes de cada caso de prueba separado. <br><br>  No se requiere el procedimiento de desmontaje después de la ejecución del caso de prueba.  Cada caso de prueba con su configuración se ejecuta en una transacción separada que se revierte después de la recopilación de resultados.  Es muy conveniente pero tiene algunas consecuencias negativas: las describiré un poco más adelante. <br><br>  El marco permite ejecutar casos de prueba uno a la vez, todas las clases de prueba a la vez o incluso todas las clases de prueba registradas con un solo comando. <br><br><h1>  Características y ejemplos. </h1><br>  No dispuesto a repetir la guía oficial, mostraré las características de tSQLt en los ejemplos. <br><br>  <i>Descargo de responsabilidad:</i> <br><br><ul><li>  <i>los ejemplos son simplificados</i> </li><li>  <i>el código original no es completamente mío, son más bien creaciones colectivas</i> </li><li>  <i>el ejemplo 2 es ficcionalizado por mí para demostrar características más completamente.</i> </li></ul><br><h3>  Ejemplo # 1: CsvSql </h3><br>  Lo siguiente se implementó a pedido de uno de los clientes del cliente.  Hay consultas SQL almacenadas en los campos de Nvarchar (MAX).  Se crea una interfaz de usuario mínima para verlos.  Los conjuntos de resultados generados por estas consultas se utilizan en el backend para componer más como archivos CSV.  Los archivos CSV pueden solicitarse mediante una llamada API. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/5q/mu/oy/5qmuoyyjjvlphk79jt-xtawwjn8.png"></div><br>  Los conjuntos de resultados son grandes y contienen una gran cantidad de columnas.  Un ejemplo hipotético de tal conjunto de resultados: <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/dg/50/bb/dg50bbx25qaw6ycwpfqcsfj5kyk.png"></div><br>  Este conjunto de resultados representa datos de ensayos clínicos.  Echemos un vistazo más de cerca al cálculo [ClinicsNum].  Tenemos 2 tablas: [Trial] y [Clinic]. <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/qo/mu/n-/qomun-gdbdl05teniypbtzi8jio.png"></div><br>  Hay un FK: [Clínica]. [TrialID] -&gt; [Trial]. [TrialID].  Obviamente, es suficiente usar COUNT (*) para obtener varias clínicas: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*), ...  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.Trial  <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dbo.Clinic    <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Trial.ID = Clinic.TrialID  <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Trial.Name = @trialName  <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ...</code> </pre> <br>  ¿Cómo podemos probar tal consulta?  Primero, usemos stub FakeTable, lo que hará que nuestro trabajo posterior sea mucho más fácil. <br><br><pre> <code class="plaintext hljs">EXEC tSQLt.FakeTable 'dbo.Trial'; EXEC tSQLt.FakeTable 'dbo.Clinic';</code> </pre> <br>  FakeTable hace una cosa simple: renombra tablas viejas y crea nuevas con el mismo nombre.  Los mismos nombres, las mismas columnas, pero sin restricciones ni desencadenantes. <br><br>  Necesitamos esto porque: <br><br><ol><li>  Test DB puede contener algunos datos que pueden evitar una ejecución correcta de la prueba.  FakeTable nos permite no depender de ellos. </li><li>  Por lo general, solo necesitamos llenar unas pocas columnas para los propósitos de la prueba.  La tabla puede contener muchos de ellos, a menudo con restricciones y desencadenantes.  Hacemos que sea más fácil insertar datos más tarde: insertaremos solo lo requerido para la información de la prueba, manteniendo la prueba lo más minimalista posible. </li><li>  No habrá ejecuciones de disparador no deseadas, por lo que no debemos preocuparnos por los efectos posteriores. </li></ol><br>  Luego insertamos los datos de prueba requeridos: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.Trial ([<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-string"><span class="hljs-string">'Valerian'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.Clinic ([<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], [TrialID], [<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,   <span class="hljs-number"><span class="hljs-number">1</span></span>,        <span class="hljs-string"><span class="hljs-string">'Clinic1'</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,   <span class="hljs-number"><span class="hljs-number">1</span></span>,        <span class="hljs-string"><span class="hljs-string">'Clinic2'</span></span>);</code> </pre> <br>  Derivamos la consulta del DB, creamos la tabla [Actual] y la llenamos con el resultado <br>  establecido desde la consulta. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @sqlStatement <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>… <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> actual ([TrialID], ...); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> actual EXEC sp_executesql @sqlStatement, ...</code> </pre> <br>  Ahora, llenamos [Esperado] - nuestros valores esperados: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> expected (   ClinicsNum <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> expected <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Quiero llamar su atención de que solo tenemos una columna en la tabla [Esperado], aunque tenemos el conjunto completo en la columna [Actual]. <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/qd/gx/ga/qdgxgaqr4cjp2eayoz0eycjs8cg.png"></div><br>  Esto se debe a una característica útil del procedimiento AssertEqualsTable que usaremos para la verificación de valores. <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEqualsTable   'expected',   'actual',   'incorrect number of clinics';</code> </pre> <br>  Compara solo las columnas que se presentan en ambas tablas.  Es muy conveniente en nuestro caso porque la consulta bajo prueba devuelve muchas columnas, cada una conectada con una lógica bastante complicada.  No queremos inflar los casos de prueba, por lo que esta característica realmente ayuda.  Por supuesto, esta característica es una espada de doble filo.  Si se completa [Actual] a través de SELECT TOP 0 y en un momento aparece una columna inesperada, tal caso de prueba no captará esto.  Debe escribir cheques adicionales para cubrir esto. <br><br><h3>  AssertEqualsTable procedimientos gemelos </h3><br>  Vale la pena mencionar que tSQLt contiene 2 procedimientos como AssertEqualsTable.  Son AssertEqualsTableSchema y AssertResultSetsHaveSameMetaData.  El primero hace lo mismo que AssertEqualsTable pero en los metadatos de las tablas.  El segundo hace lo mismo pero en los metadatos de los conjuntos de resultados. <br><br><h3>  Ejemplo # 2: restricciones </h3><br>  El ejemplo anterior nos mostró cómo podemos eliminar restricciones.  Pero, ¿y si necesitamos verificarlos?  Técnicamente, las restricciones también son parte de la lógica, y pueden considerarse como un candidato para la cobertura mediante pruebas. <br><br>  Considere la situación del ejemplo anterior.  2 tablas: [Trial] y [Clinic];  [TrialID] FK: <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/-8/zu/v3/-8zuv3clqoo3ygm9wko5hpibc90.png"></div><br>  Intentemos escribir un caso de prueba para verificarlo.  Primero, como en el caso anterior, falsificamos las tablas: <br><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable '[dbo].[Trial]' EXEC tSQLt.FakeTable '[dbo].[Clinic]'</code> </pre> <br>  El objetivo es el mismo: deshacerse de los límites innecesarios.  Queremos cheques aislados sin esfuerzo excesivo. <br><br>  A continuación, devolvemos la restricción que queremos probar usando ApplyConstraint: <br><br><pre> <code class="sql hljs">EXEC tSQLt.ApplyConstraint   '[dbo].[Clinic]',   'Trial_FK';</code> </pre> <br>  Ahora tenemos una configuración para la verificación.  La comprobación en sí misma es que intentar insertar datos provocará una excepción.  Para el caso de prueba que pasa necesitamos capturar esta excepción.  El controlador de excepciones ExpectException puede ayudar. <br><br><pre> <code class="sql hljs">EXEC tSQLt.ExpectException   @ExpectedMessage = 'The <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> conflicted...<span class="hljs-string"><span class="hljs-string">',   @ExpectedSeverity = 16,   @ExpectedState = 0;</span></span></code> </pre> <br>  Podemos intentar insertar no insertables después de la configuración del controlador. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> [dbo].[Clinic] ([TrialID])   <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  La excepción fue atrapada.  Pase de prueba <br><br><h3>  Aplicar procedimientos gemelos de restricción </h3><br>  La forma de probar los desencadenantes propuestos por los autores de tSQLt es similar a las restricciones de prueba.  Podemos usar el procedimiento ApplyTrigger para devolver el activador a la tabla.  Después de eso, todo va como en el ejemplo anterior: inicie el disparador, verifique el resultado. <br><br><h3>  ExpectNoException - el antónimo de ExpectException </h3><br>  Existe un procedimiento ExpectNoException para los casos en que no debe ocurrir una excepción.  Funciona de la misma manera que ExpectException, excepto que la prueba falla en caso de que ocurra una excepción. <br><br><h3>  Ejemplo # 3: Semáforo </h3><br>  Hay algunos procedimientos almacenados y servicios de Windows.  El inicio de su ejecución puede ser causado por diferentes eventos externos.  Sin embargo, el orden de su ejecución es fijo.  Por lo tanto, es necesario implementar el control de acceso en el lado de la base de datos, es decir, un semáforo.  En nuestro caso, el semáforo es un grupo de procedimientos almacenados que trabajan juntos. <br><br>  Veamos un procedimiento dentro del semáforo.  Tenemos 2 tablas: [Proceso] y [ProcStatus]: <br><br><div style="text-align:center;"><img width="80%" height="80%" src="https://habrastorage.org/webt/-m/hz/8-/-mhz8-fm_n1w7njpryiv8z3epiw.png"></div><br>  La tabla [Proceso] contiene una lista de procesos permitidos para la ejecución.  [ProcStatus], obviamente, contiene la lista de estados del proceso de la tabla anterior. <br><br>  Entonces, ¿qué hace nuestro procedimiento?  Primero, realiza las siguientes verificaciones: <br><br><ol><li>  Hemos pasado un nombre de proceso como uno de los parámetros de entrada del procedimiento.  Este nombre se busca en el campo [Nombre] de la tabla [Proceso]. </li><li>  Si se ha encontrado el nombre del proceso, verifica el indicador [IsRunable] de la tabla [Proceso]. </li><li>  Si el indicador está activado, consideramos que el proceso puede ejecutarse.  La última comprobación se realiza en la tabla [ProcStatus].  Necesitamos asegurarnos de que el proceso no se esté ejecutando actualmente, lo que significa la ausencia de registros sobre el proceso con el estado "InProg" en la tabla [ProcStatus]. </li></ol><br>  Si todo está bien y se pasan todas las comprobaciones, agregamos un nuevo registro sobre nuestro proceso en la tabla [ProcStatus] con el estado "InProg".  El ID de este nuevo registro se devuelve con el parámetro de salida ProcStatusId. <br><br>  Si algo ha salido mal, esperamos lo siguiente: <br><br><ol><li>  Se envía un correo electrónico a un administrador del sistema. </li><li>  ProcStatusId = -1 se devuelve. </li><li>  No se agregaron nuevos registros [ProcStatus]. </li></ol><br>  Creemos un caso de prueba para verificar el caso de ausencia de proceso en la tabla [Proceso]. <br><br>  Usamos FakeTable nuevamente.  Aquí no es tan crítico, pero puede ser conveniente porque: <br><br><ol><li>  Se garantiza que no habrá datos que puedan interrumpir la ejecución del caso de prueba. </li><li>  La verificación adicional de la nueva ausencia de registros [ProcStatus] se simplificará. </li></ol><br><pre> <code class="sql hljs">EXEC tSQLt.FakeTable 'dbo.Process'; EXEC tSQLt.FakeTable 'dbo.ProcStatus';</code> </pre> <br>  Hay un procedimiento [SendEmail] cuyo nombre habla por sí mismo.  Necesitamos atender su llamada.  tSQLt sugiere usar el simulacro SpyProcedure para eso. <br><br><pre> <code class="plaintext hljs">EXEC tSQLt.SpyProcedure 'dbo.SendEmail'</code> </pre> <br>  SpyProcedure hace lo siguiente: <br><br><ol><li>  Crea una tabla con un nombre que se parece a [dbo]. [ProcedureName_SpyProcedureLog] </li><li>  Al igual que FakeTable, reemplaza el procedimiento original con uno generado automáticamente, con el mismo nombre, pero con lógica de registro en su interior.  También puede agregar su propia lógica al procedimiento generado si es necesario. </li></ol><br>  No es difícil adivinar que los registros se graban en la tabla [dbo]. [SendEmail_SpyProcedureLog].  Esta tabla contiene una columna [_ID_] que es para los números de secuencia de las llamadas.  Las columnas posteriores se nombran después de los parámetros pasados ​​al procedimiento y se utilizan para recopilarlos, por lo que los valores de los parámetros también se pueden verificar. <br><br><div style="text-align:center;"><img width="75%" height="75%" src="https://habrastorage.org/webt/ko/gh/4h/kogh4hgcdsxagldk2bmdcfrptzi.png"></div><br>  Lo último que debemos hacer antes de la llamada del semáforo es crear una variable para almacenar el valor [ProcStatusId] (para ser más exactos, -1, ya que el registro no se agregará). <br><br><pre> <code class="plaintext hljs">DECLARE @ProcStatusId BIGINT;</code> </pre> <br>  Llamamos al semáforo: <br><br><pre> <code class="plaintext hljs">EXEC dbo.[Semaphore_JobStarter]   'SomeProcess',   @ProcStatusId OUTPUT; -- here we get -1</code> </pre> <br>  Ahora tenemos todos los datos necesarios para las verificaciones.  Comencemos por verificar <br>  que el mensaje ha sido enviado. <br><br><pre> <code class="plaintext hljs">IF NOT EXISTS (   SELECT *   FROM dbo.SendEmail_SpyProcedureLog) EXEC tSQLt.Fail 'SendEmail has not been run.';</code> </pre> <br>  En este caso, no verificamos los parámetros pasados ​​y probamos solo el envío.  Quiero llamar su atención sobre el procedimiento de falla.  Nos permite "oficialmente" fallar un caso de prueba.  Si necesita construir una construcción sofisticada, Fail puede ayudarlo. <br><br>  Ahora verificamos la ausencia de registros en la tabla [ProcStatus] con el procedimiento AssertEmptyTable. <br><br><pre> <code class="plaintext hljs">EXEC tSQLt.AssertEmptyTable 'dbo.ProcStatus';</code> </pre> <br>  Aquí es donde FakeTable que utilizamos al principio nos ayudó.  Con él, podemos esperar una tabla vacía y probar usando una sola línea de código.  La forma correcta de verificar esto sin falsificar la tabla sería comparar el número de filas antes y después de la ejecución del procedimiento, y eso requeriría más acciones. <br><br>  Podemos verificar fácilmente la igualdad ProcStatusId = -1 con AssertEquals. <br><br><pre> <code class="sql hljs">EXEC tSQLt.AssertEquals   -1,       @ProcStatusId,       'Wrong ProcStatusId.';</code> </pre> <br>  AssertEquals es minimalista.  Simplemente compara 2 valores, nada extraordinario. <br><br><h3>  AssertEquals procedimientos gemelos </h3><br>  Tenemos los siguientes procedimientos para la comparación de valores: <br><br><ul><li>  AssertEquals </li><li>  AssertNotEquals </li><li>  AssertEqualsString </li><li>  Asertivo </li></ul><br>  Los nombres se explican por sí mismos, creo.  El único procedimiento que quiero enfatizar es AssertEqualsString.  Es el procedimiento dedicado a la verificación de valores de cadena.  ¿Por qué necesitamos un procedimiento más, considerando los AssertEquals universales dados?  La cuestión es que AssertEquals / AssertNotEquals / AssertLike funciona con el tipo SQL_VARIANT.  NVARCHAR (MAX) no está incluido en SQL_VARIANT, por lo que los desarrolladores de tSQLt tuvieron que realizar un procedimiento adicional. <br><br><h3>  Función falsa </h3><br>  En un momento, podemos llamar a FakeFunction un procedimiento similar a SpyProcedure.  Este falso permite reemplazar cualquier función por una más simple.  Como las funciones de SQL Server funcionan como un tubo de pasta de dientes (el resultado se devuelve a través del único "agujero"), es técnicamente imposible implementar una funcionalidad de registro.  El reemplazo de la lógica interna es la única forma disponible. <br><br><h1>  Trampas </h1><br>  Quiero contarte algunos problemas que puedes enfrentar durante el uso de tSQLt.  En este caso, "dificultades" significan algunos problemas causados ​​por restricciones de SQL Server y / o que los desarrolladores de framework no pueden resolver. <br><br><h3>  Transacciones de reversión y condena </h3><br>  El primer y principal problema que enfrenta nuestro equipo es la reversión de transacciones y la condena.  SQL Server no puede revertir la transacción anidada por separado.  Siempre revierte todas las transacciones hasta el extremo exterior.  Teniendo en cuenta que tSQLt envuelve cada prueba en una transacción separada, puede convertirse en un problema porque la reversión dentro de un procedimiento almacenado puede interrumpir una ejecución de prueba con un error de ejecución no descriptivo. <br><br>  Como solución alternativa, utilizamos puntos de guardado.  La idea es simple.  Al principio, verificamos si estamos dentro de una transacción o no.  En caso afirmativo, suponemos que es una transacción tSQLt y ponemos un punto de rescate, por lo que volveremos a hacerlo si es necesario.  Si no, comenzamos una nueva transacción.  De hecho, no permitimos anidar. <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/bu/ih/vl/buihvlf1ffnwuzbotecbqtev09o.png"></div><br>  El problema se complica por la cancelación de transacciones: puede suceder si se produce una excepción.  Una transacción condenada no puede confirmarse ni revertirse a un punto de rescate, por lo que debemos revertirla a la transacción más externa nuevamente. <br><br>  Teniendo en cuenta los puntos descritos anteriormente, debemos utilizar la siguiente estructura: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isNestedTransaction <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> @@trancount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY   <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @isNestedTransaction = <span class="hljs-string"><span class="hljs-string">'false'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;       <span class="hljs-comment"><span class="hljs-comment">-- something useful   IF @isNestedTransaction = 'false'   COMMIT TRANSACTION; END TRY BEGIN CATCH   DECLARE @isCommitable BIT =       CASE WHEN XACT_STATE() = 1           THEN 'true'           ELSE 'false'   END;   IF @isCommitable = 'true' AND @isNestedTransaction = 'true'       ROLLBACK TRANSACTION SavepointName;   ELSE       ROLLBACK;   THROW; END CATCH;</span></span></code> </pre> <br>  Repasemos el código pieza por pieza.  Primero, necesitamos determinar si estamos dentro de una transacción o no. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isNestedTransaction <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> @@trancount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br>  Después de obtener el indicador @isNestedTransaction, podemos iniciar el bloque TRY y establecer un punto de guardado o iniciar una transacción según la situación. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY   <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @isNestedTransaction = <span class="hljs-string"><span class="hljs-string">'false'</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;       <span class="hljs-comment"><span class="hljs-comment">-- something useful</span></span></code> </pre> <br>  Después de hacer algo útil, confirmamos los resultados si se trata de un procedimiento "real" ejecutado. <br><br><pre> <code class="sql hljs">       <span class="hljs-comment"><span class="hljs-comment">-- something useful   IF @isNestedTransaction = 'false'   COMMIT TRANSACTION; END TRY</span></span></code> </pre> <br>  Por supuesto, si se trata de un caso de prueba, no necesitamos comprometer nada.  tSQLt revertirá los cambios al final automáticamente. <br><br>  Si algo ha salido mal y nos metemos en el bloque CATCH, debemos determinar si la transacción es confirmable o no. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CATCH   <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @isCommitable <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> =       <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> XACT_STATE() = <span class="hljs-number"><span class="hljs-number">1</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'false'</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br>  Podemos retroceder al punto de guardado solo si: <br><br><ol><li>  La transacción es commitable </li><li>  Es una prueba de funcionamiento, entonces existe un punto de rescate. </li></ol><br>  En todos los demás casos, debemos revertir toda la transacción. <br><br><pre> <code class="sql hljs">   IF @isCommitable = 'true' AND @isNestedTransaction = 'true'       <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> SavepointName;   ELSE       <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;   THROW; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CATCH;</code> </pre> <br>  Sí, desafortunadamente, si hemos alcanzado un estado de transacción no confirmable durante una ejecución de prueba, aún obtenemos el error de ejecución. <br><br><h3>  Faketable y la cuestión de la clave extranjera </h3><br>  Repasemos las tablas familiares [Prueba] y [Clínica] <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/fy/k7/nm/fyk7nmhfha_fnezignyxclpflay.png"></div><br>  Recordamos sobre [TrialID] FK.  ¿Qué problema puede causar?  En los ejemplos anteriores, aplicamos FakeTable en ambas tablas.  Si lo usamos solo en uno de ellos, alcanzaremos la siguiente configuración: <br><br><div style="text-align:center;"><img width="85%" height="85%" src="https://habrastorage.org/webt/og/to/3-/ogto3-drjheieblpi1_gsyup4hs.png"></div><br>  Por lo tanto, un intento de insertar un registro en [Clínica] puede fallar incluso si hemos preparado los datos en la versión falsa de [Prueba]. <br><br><pre> <code class="sql hljs">[dbo].[Test_FK_Problem] failed: (Error) The <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> conflicted <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> <span class="hljs-string"><span class="hljs-string">"Trial_Fk"</span></span>. The conflict occurred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> <span class="hljs-string"><span class="hljs-string">"HabrDemo"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">"dbo.tSQLt_tempobject_ba8f36353f7a44f6a9176a7d1db02493"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">'TrialID'</span></span>.[<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]{Test_FK_Problem,<span class="hljs-number"><span class="hljs-number">14</span></span>}</code> </pre> <br>  Conclusión: falso todo o ninguno.  En caso de que ninguno, obviamente, debe preparar una base de datos con todos los datos de prueba requeridos. <br><br><h3>  SpyProcedure sobre procedimientos del sistema </h3><br>  Desafortunadamente, no podemos espiar los procedimientos del sistema: <br><br><pre> <code class="sql hljs">[HabrDemo].[test_test] failed: (Error) Cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> SpyProcedure <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sys.sp_help because the <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist[<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>] {tSQLt.Private_ValidateProcedureCanBeUsedWithSpyProcedure,<span class="hljs-number"><span class="hljs-number">7</span></span>}</code> </pre> <br>  En el ejemplo del semáforo, rastreamos llamadas del procedimiento [SendEmail], que fue creado por nuestros desarrolladores.  En este caso, no se requería solo mediante pruebas.  Era necesario crear un procedimiento separado porque es necesario preparar algunos datos antes de enviarlos.  Pero debe estar mentalmente preparado para escribir un procedimiento de capa intermedia para cumplir con los objetivos de la prueba. <br><br><h1>  Pros </h1><br><h3>  Instalación rápida </h3><br>  La instalación de tSQLt consta de 2 pasos y toma alrededor de 2 minutos.  Debe activar CLR si no está activo actualmente y ejecutar un solo script SQL.  Eso es todo: ahora puede agregar su primera clase de prueba y escribir casos de prueba. <br><br><h3>  Aprendizaje rápido </h3><br>  tSQLt es fácil de aprender.  Me llevó un poco más de un día de trabajo.  Le pregunté a mis colegas y parece que también toma alrededor de 1 día laboral para otros.  Dudo que pueda tomar mucho más tiempo. <br><br><h3>  Integración rápida de CI </h3><br>  Tomó alrededor de 2 horas configurar la integración de CI en nuestro proyecto.  El tiempo puede variar, por supuesto, pero no es un problema en general, y se puede hacer rápidamente. <br><br><h3>  Un amplio conjunto de instrumentos. </h3><br>  Es subjetivo, pero en mi opinión, la funcionalidad tSQLt es rica y la mayor parte de las necesidades pueden ser cubiertas por ella.  Si no es suficiente, siempre puede usar el procedimiento Fail para casos raros y sofisticados. <br><br><h3>  Documentación conveniente </h3><br>  Las guías oficiales son convenientes y consistentes.  Puede comprender fácilmente el uso de tSQLt en un período corto, incluso si es su primera herramienta de prueba de unidad. <br><br><h3>  Salida clara </h3><br>  La salida de prueba se puede tomar en un formato de texto ilustrativo: <br><br><pre> <code class="plaintext hljs">[tSQLtDemo].[test_error_messages] failed: (Failure) Expected an error to be raised. [tSQLtDemo].[test_tables_comparison] failed: (Failure) useful and descriptive error message Unexpected/missing resultset rows! |_m_|Column1|Column2| +---+-------+-------+ |&lt; |2 |Value2 | |= |1 |Value1 | |= |3 |Value3 | |&gt; |2 |Value3 | +----------------------+ |Test Execution Summary| +----------------------+ |No|Test Case Name |Dur(ms)|Result | +--+------------------------------------+-------+-------+ |1 |[tSQLtDemo].[test_constraint] | 83|Success| |2 |[tSQLtDemo].[test_trial_view] | 83|Success| |3 |[tSQLtDemo].[test_error_messages] | 127|Failure| |4 |[tSQLtDemo].[test_tables_comparison]| 147|Failure| ----------------------------------------------------------------------------- Msg 50000, Level 16, State 10, Line 1 Test Case Summary: 4 test case(s) executed, 2 succeeded, 2 failed, 0 errored. -----------------------------------------------------------------------------</code> </pre><br>  También se puede derivar del DB (cliqueable) ... <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/-f/83/la/-f83lajcz1mfcnkhtttz45b0x3g.png"></a> </div><br>  ... o incluso como XML. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuites</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuite</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tests</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"3"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">errors</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">failures</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">timestamp</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2019-06-22T16:46:06"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.433"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hostname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BLAHBLAHBLAH\SQL2017"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLt"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">properties</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_constraint"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.097"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_error_messages"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.153"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">failure</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">message</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Expected an error to be raised."</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLt.Fail"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testcase</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">classname</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"tSQLtDemo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"test_trial_view"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0.156"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system-out</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system-err</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuite</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">testsuites</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  El último formato permite la integración de CI sin ningún problema.  Específicamente, usamos tSQLt junto con Atlassian Bamboo. <br><br><h3>  Apoyo de redgate </h3><br>  Como uno de los profesionales, puedo nombrar el soporte de uno de los mayores proveedores de herramientas de DBA: RedGate.  Su complemento de SQL Server Management Studio llamado SQL Test funciona con tSQLt desde el principio.  Además, RedGate ayuda al desarrollador principal de tSQLt con dev-environment, según sus palabras en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grupos de Google</a> . <br><br><h1>  Contras </h1><br><h3>  No hay tablas temporales falsificadas </h3><br>  tSQLt no permite falsificar tablas temporales.  Pensamientos, en caso de necesidad, puede usar un complemento no oficial.  Desafortunadamente, este complemento funciona solo con SQL Server 2016+. <br><br><h3>  Trabajar con bases de datos externas </h3><br>  tSQLt está diseñado para funcionar con el código en la misma base de datos en la que está instalado el marco.  Por lo tanto, puede ser imposible usarlo con un DB externo.  Al menos, las falsificaciones no funcionarán. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [tSQLtDemo].[test_outer_db] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [AdventureWorks2017].[Person].[<span class="hljs-keyword"><span class="hljs-keyword">Password</span></span>]   EXEC tSQLt.FakeTable <span class="hljs-string"><span class="hljs-string">'[AdventureWorks2017].[Person].[Password]'</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [AdventureWorks2017].[Person].[<span class="hljs-keyword"><span class="hljs-keyword">Password</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ga/au/ny/gaaunygdr124sssxhonbb2s0b_0.png"></div><br>  Parece que las afirmaciones funcionan, pero su viabilidad no está garantizada, por supuesto. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [tSQLtDemo].[test_outer_db_assertions] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> *   <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-comment"><span class="hljs-comment">#Actual   FROM [AdventureWorks2017].[Person].[Password]   SELECT *   INTO #Expected   FROM (          SELECT 'bE3XiWw=' AS [PasswordSalt]   ) expectedresult;   EXEC tSQLt.AssertEqualsTable '#Expected', '#Actual', 'The salt is not salty'; END</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cg/dk/ow/cgdkowych69imevqmbirkkgsniq.png"></div><br><h3>  Errores de documentación </h3><br>  A pesar de que mencioné anteriormente que las guías son convenientes y consistentes, la documentación tiene algunos problemas.  Contiene partes obsoletas. <br><br>  Ejemplo 1. La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">“Guía de inicio rápido”</a> sugiere descargar el marco de SourceForge. <br>  Se mudaron de SourceForge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hasta 2015</a> . <br><br>  Ejemplo 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La guía ApplyConstraint</a> utiliza un diseño voluminoso con el procedimiento Fail dentro de un ejemplo de captura de excepción.  Esto se puede reemplazar con un código simple y claro usando ExpectException. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> ConstraintTests.[<span class="hljs-keyword"><span class="hljs-keyword">test</span></span> ReferencingTable_ReferencedTable_FK prevents <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> orphaned <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXEC tSQLt.FakeTable <span class="hljs-string"><span class="hljs-string">'dbo.ReferencedTable'</span></span>; EXEC tSQLt.FakeTable 'dbo.ReferencingTable'; EXEC tSQLt.ApplyConstraint 'dbo.ReferencingTable','ReferencingTable_ReferencedTable_FK'; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @ErrorMessage <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @ErrorMessage = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* [NB] Why don't we use ExceptException below? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRY <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.ReferencingTable ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, ReferencedTableId ) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> ( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span> ) ; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> TRY <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CATCH <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @ErrorMessage = ERROR_MESSAGE(); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CATCH <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @ErrorMessage <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%ReferencingTable_ReferencedTable_FK%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> EXEC tSQLt.Fail <span class="hljs-string"><span class="hljs-string">'Expected error message containing ''ReferencingTable_ReferencedTable_FK'' but got: '''</span></span>,@ErrorMessage,<span class="hljs-string"><span class="hljs-string">'''!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span></code> </pre><br>  Y esto se espera, debido a ... <br><br><h3>  Abandono parcial </h3><br>  Hubo una pausa prolongada en el desarrollo desde principios de 2016 hasta junio de 2019. Sí, desafortunadamente, esta herramienta está parcialmente abandonada.  El desarrollo comenzó lentamente en 2019, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">según GitHub</a> .  Aunque los Grupos de Google oficiales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tienen un hilo</a> en el que se le preguntó a Sebastian, el desarrollador principal de tSQLt, sobre el futuro del proyecto.  La última pregunta se hizo el 2 de marzo de 2019, sin respuesta. <br><br><h3>  Problema de SQL Server 2017 </h3><br>  La instalación de tSQLt puede requerir algunas acciones adicionales si está utilizando SQL Server 2017. Microsoft implementó el primer cambio de seguridad desde 2012 en esta versión.  Se ha agregado el indicador de nivel de servidor "Seguridad estricta CLR".  Este indicador no permite la creación de conjuntos sin firmar '(incluso SAFE).  La descripción detallada merece un artículo separado (y, afortunadamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya tenemos</a> uno bueno; vea también los siguientes artículos en la secuencia. Solo prepárese mentalmente para esto. <br><br>  Por supuesto, podría atribuir este problema a las "trampas", pero los desarrolladores de tSQLt pueden resolver este problema.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El problema de GitHub ya ha surgido</a> .  Aún así, no se ha resuelto desde octubre de 2017. <br><br><h1>  Alternativas (±) para otros DBMS </h1><br>  tSQLt no es único en su clase.  Aunque no puede usarlo en otros DBMS debido a los matices CLR y T-SQL, aún puede encontrar algo similar.  Vale la pena mencionar que estas alternativas no están muy cerca de tSQLt, por lo que me refiero al enfoque basado en SQL. <br><br>  Por ejemplo, los usuarios de PostgreSQL pueden probar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgTAP</a> .  Es una herramienta bien desarrollada y en desarrollo activo que utiliza PL / pgSQL nativo para pruebas y formato de salida TAP.  La herramienta similar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MyTap</a> puede ayudarlo con las pruebas en MySQL.  Este marco es un poco menos funcional que pgTAP pero aún puede ser útil.  Y también está en desarrollo activo.  Si es un usuario feliz de Oracle, tiene la oportunidad de usar la herramienta muy poderosa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utPLSQL</a> .  Se está desarrollando de manera muy activa y ofrece una gran cantidad de características. <br><br><h1>  Conclusión </h1><br>  Quería transmitir 2 ideas: <br><br>  El primero: la utilidad de las pruebas de código DB.  No es importante si está utilizando SQL Server, Oracle, MySQL u otra cosa.  Si su base de datos contiene lógica no probada, está tomando riesgos.  Como todos los demás errores en el resto del código, los errores del código DB pueden dañar el producto y la compañía que lo proporciona. <br><br>  El segundo: la elección de la herramienta.  Para aquellos que trabajan con SQL Server, tSQLt, incluso si no es un ganador del 100%, sin duda merece atención.  A pesar del lento desarrollo y algunos problemas, sigue siendo un marco práctico que podría hacer que su trabajo sea mucho más fácil. <br><br><div class="spoiler">  <b class="spoiler_title">Fuentes que me ayudaron (lista no exhaustiva)</b> <div class="spoiler_text">  DbFit - Pruebas automatizadas de bases de datos de código abierto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.methodsandtools.com/tools/dbfit.php</a> <br><br>  Documentación de DbFit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://dbfit.github.io/dbfit/docs/</a> <br><br>  Wiki de Slacker: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/vassilvk/slacker/wiki</a> <br><br>  Documentación de TST: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://archive.codeplex.com/projects/TST/4e04e281-9f35-4891-809a-15f09d304f4e</a> <br><br>  Afirmaciones de NUnit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/nunit/docs/wiki/Assertions</a> <br><br>  Código utTSQL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://sourceforge.net/p/uttsql/code/HEAD/tree/</a> <br><br>  Afirmación de clase Junit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://junit.org/junit4/javadoc/latest/org/junit/Assert.html</a> <br><br>  pgTap: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://pgtap.org/</a> <br><br>  utPLSQL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://utplsql.org/</a> <br><br>  MyTap: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/hepabolu/mytap</a> <br><br>  tSQLt Grupos de Google: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://groups.google.com/forum/#!forum/tsqlt</a> <br><br>  Sitio web oficial de tSQLt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tsqlt.org/</a> <br><br>  tSQLt GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/tSQLt-org/tSQLt</a> <br><br>  Tendencias de Google: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://bit.ly/2x7BQL6</a> <br><br>  Cómo ROLLBACK una transacción cuando se prueba usando tSQLt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://stackoverflow.com/questions/8973138/how-to-rollback-a-transaction-when-testing-using-tsqlt</a> <br><br>  ¿Cuáles son los pros y los contras de las pruebas unitarias manuales contra las pruebas unitarias automatizadas?: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Https://stackoverflow.com/questions/2948337/what-are-the-pros-and-cons-of-manual-unit-testing-against -the-automatic-unit-tes # 2948354</a> <br><br>  Lo bueno, lo malo y lo descuidado ¯¯¯: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://sqlquantumleap.com/2017/08/07/sqlclr-vs-sql-server-2017-part-1-clr-strict-security/</a> <br><br>  Rex Black, Erik Van Veenendal, Dorothy Graham, Fundamentos de las pruebas de software, Tercera edición, Cengage Learning EMEA 2012 <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465567/">https://habr.com/ru/post/465567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465551/index.html">Resumen de eventos de TI de septiembre (primera parte)</a></li>
<li><a href="../465553/index.html">Lenguaje de programación Ü. Introducción, motivación para crear, metas</a></li>
<li><a href="../465555/index.html">12 habilidades blandas que hacen que los gerentes de proyectos de TI sean imparables</a></li>
<li><a href="../465557/index.html">Plazos de desarrollo de productos</a></li>
<li><a href="../465561/index.html">Lo que aprendí de un programador líder</a></li>
<li><a href="../465569/index.html">Mapa de desarrollo para desarrolladores móviles</a></li>
<li><a href="../465571/index.html">Cómo vender cigarrillos de hombres para mujeres y hacer que los salvajes se protejan a sí mismos: redactores que podrían</a></li>
<li><a href="../465573/index.html">Todo el poder de IntelliJ IDEA en el ejemplo de un idioma (en imágenes)</a></li>
<li><a href="../465575/index.html">Operaciones de comparación en C ++ 20</a></li>
<li><a href="../465577/index.html">Nuevos tipos de micromarcado para fragmentos interactivos avanzados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>