<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö´Ô∏è üå† üë¥ Como criei um filtro que n√£o corrompe a imagem mesmo depois de um milh√£o de execu√ß√µes - parte 2 üì¢ ü§Ωüèª üë®‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na primeira parte deste post, falei sobre como o uso repetido de filtros halfpel padr√£o cria imagens distorcidas e, em seguida, mostrei um novo filtro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como criei um filtro que n√£o corrompe a imagem mesmo depois de um milh√£o de execu√ß√µes - parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468629/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" alt="imagem"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" alt="imagem"></div><br>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte</a> deste post, falei sobre como o uso repetido de filtros halfpel padr√£o cria imagens distorcidas e, em seguida, mostrei um novo filtro que n√£o possui esse problema. <br><br>  Estava um pouco mais emba√ßado e isso n√£o agradaria a todos.  No entanto, era melhor do que suas alternativas - na verdade, esse filtro foi usado na vers√£o original do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bink 2</a> .  Devido √† carga de trabalho constante, nunca consegui voltar a ele e examin√°-lo com mais detalhes. <br><br>  Mas agora que <i>encontrei</i> tempo para retornar a esse filtro e escrever um artigo sobre o assunto, devo finalmente fazer uma pergunta: existe um filtro <i>menos desfocado</i> que ainda retenha a propriedade de "estabilidade infinita"? <br><br>  Aviso de spoiler: a resposta correta √© "provavelmente n√£o" e "definitivamente existe".  Mas antes de entendermos por que existem duas respostas para essa pergunta e o que elas significam, vamos preparar melhor uma bancada de testes. <br><a name="habracut"></a><br><h2>  Ajuste de deslocamento </h2><br>  Quando trabalhei inicialmente nesse problema, n√£o fazia ideia do que estava procurando.  Eu nem sabia que <i>existia</i> um filtro de meio-tom "infinitamente est√°vel", por isso n√£o criei um sistema em sua pesquisa.  Eu estava apenas procurando por algo que resistisse √†s ‚Äúmuitas‚Äù itera√ß√µes de filtro sem distor√ß√£o da imagem.  Todas as imagens da primeira parte refletem essa metodologia: a imagem √© deslocada da direita para a esquerda meio pixel por vez, ou seja, se voc√™ aplicar o filtro 100 vezes, a imagem resultante ser√° deslocada em 50 pixels. <br><br>  Agora que sabemos o que <i>realmente estamos</i> procurando, podemos ser um pouco mais precisos.  Aplicando o filtro halfpel duas vezes, mudamos a imagem exatamente para um pixel.  Ou seja, se simplesmente <i>movermos a imagem um pixel para tr√°s</i> , ela permanecer√° no mesmo espa√ßo.  Gra√ßas a isso, o teste ficar√° muito mais bonito, porque n√£o apenas poderemos aplicar o filtro v√°rias vezes, sem medo de que a imagem "rasteje" para fora da tela, mas tamb√©m encontraremos a <i>diferen√ßa da</i> imagem nas vers√µes anteriores e com a original. <br><br>  Isso nos permitir√° testar os filtros automaticamente.  Simplesmente aplicamos o filtro v√°rias vezes e vemos uma de duas coisas: converg√™ncia para uma imagem inalterada, indicando que o filtro √© infinitamente est√°vel ou um desvio significativamente grande da imagem original, indicando que o filtro est√° "quebrado".  Para esses testes, escolhi o erro m√©dio por canal 64 (de 255) ou o erro m√°ximo em qualquer um dos canais at√© o total 255 como "significativamente grande". Se alguma dessas condi√ß√µes for verdadeira, assumiremos que o filtro "quebrou" " <br><br><h2>  Testando novamente os filtros da primeira parte </h2><br>  Ent√£o, agora entendemos melhor como testar esses filtros, ent√£o vamos dar uma nova olhada nos filtros da primeira parte.  Vamos come√ßar com um bilinear, o que, √© claro, n√£o √© muito interessante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/35a/e35/f0235ae35bdf31c9a6ed17f168681836.png" width="1016" height="284"></div><br>  Esta √© uma imagem ap√≥s 244 itera√ß√µes.  Como voc√™ pode esperar, a imagem "quebra" gradualmente devido √† m√©dia constante de pixels.  Mas mesmo ele atinge gradualmente o limite do erro m√©dio. <br><br>  Aqui est√° o h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/cb8/54b/91ecb854b5c9339b41d803a256176c31.png" width="1016" height="284"></div><br>  Para quebrar a imagem, 78 itera√ß√µes s√£o suficientes para ele.  O filtro HEVC com 8 amostras se comporta um pouco melhor, mas ainda quebra ap√≥s 150 itera√ß√µes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/d72/f5a/0add72f5ab060248be682d182abffd92.png" width="1016" height="284"></div><br>  Lanczos com 6 quebras de amostra ap√≥s 166 itera√ß√µes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e50/2c1/a52/e502c1a52ab5b8d0e9b2f253bf9654de.png" width="1016" height="284"></div><br>  S√£o todos os nossos filtros quebrados.  Tudo o que resta √© o meu filtro inteiro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/7be/511/0487be5114581255d15aa6f61c03d872.png" width="1016" height="284"></div><br>  Como esperado, ele <i>n√£o</i> foi <i>o</i> √∫nico <i>a</i> quebrar.  Ele converge para uma imagem infinitamente est√°vel ap√≥s 208 itera√ß√µes. <br><br>  O que sabemos √© bastante not√°vel aqui: pelo menos para uma ampla variedade de imagens de teste, este filtro √© <i>infinitamente est√°vel</i> , ou seja, nunca criar√° um artefato, n√£o importa quantas vezes seja usado. <br><br>  Isso nos leva de volta √† pergunta original: ele √© realmente o melhor?  E voc√™ j√° sabe as respostas, porque no come√ßo do artigo eu tamb√©m escrevi: "provavelmente n√£o" e "definitivamente, sim". <br><br>  Vamos primeiro olhar para a parte ‚Äúprovavelmente n√£o‚Äù primeiro. <br><br><h2>  Filtros de n√∫mero inteiro </h2><br>  Ent√£o, na primeira parte do post, mencionei que o n√∫cleo do filtro que encontrei era "o melhor dos detectados", e essa √© sua peculiaridade.  E aqui est√° o recurso: <br><br>  Quando eu estava procurando esse filtro, <i>na verdade</i> n√£o estava procurando o <i>melhor</i> filtro.  Eu estava procurando o melhor filtro <i>que pode ser expresso com um n√∫mero muito pequeno de turnos inteiros, adi√ß√µes e subtra√ß√µes</i> .  Pode parecer estranho, mas n√£o se apresse. <br><br>  Voc√™ deve ter notado que, quando mostrei os coeficientes de h.264, HEVC e o filtro bilinear, assim como meu filtro, eu os escrevi como numeradores inteiros sobre denominadores inteiros, assim: <br><br><pre><code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Mas no caso do windowed sinc, fiz diferente e escrevi assim: <br><br><pre> <code class="cpp hljs">LanczosKernel[] = {<span class="hljs-number"><span class="hljs-number">0.02446</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">0.61141</span></span>, <span class="hljs-number"><span class="hljs-number">-0.13587</span></span>, <span class="hljs-number"><span class="hljs-number">0.02446</span></span>};</code> </pre> <br>  A raz√£o para isso √© que o sinc em janela √© realmente deduzido de uma fun√ß√£o matem√°tica cont√≠nua que n√£o tem nada a ver com fra√ß√µes inteiras comuns.  Ao usar esse filtro, s√£o usados ‚Äã‚Äãn√∫meros de ponto flutuante (com a maior precis√£o poss√≠vel) que correspondem aos valores da fun√ß√£o sinc.  Se voc√™ se esfor√ßar para aplic√°-las com precis√£o, n√£o dever√° arredond√°-las para fra√ß√µes comuns, pois isso adicionar√° um erro. <br><br>  Os codecs de v√≠deo tradicionalmente n√£o podem se dar ao luxo de executar essas opera√ß√µes.  Opera√ß√µes de ponto flutuante em tarefas ‚Äúpesadas‚Äù como compensa√ß√£o de movimento s√£o simplesmente imposs√≠veis de usar em equipamentos especializados ou de baixa pot√™ncia.  Isso √© <i>especialmente</i> verdadeiro se estivermos falando de codecs padr√£o do setor que devem ser executados em uma ampla gama de dispositivos, incluindo chips embarcados de baixo custo e baixo custo. <br><br>  Al√©m disso, mesmo se voc√™ execut√°-los na CPU, os conjuntos de instru√ß√µes modernos s√£o baseados no SIMD, ou seja, opera√ß√µes inteiras na CPU ainda podem ser executadas mais rapidamente: voc√™ pode ajustar dois n√∫meros inteiros de 16 bits no espa√ßo de um flutuador de 32 bits, basicamente duplicando o desempenho das opera√ß√µes, portanto, se considerarmos o n√∫mero exato de ciclos por opera√ß√£o, um ponto flutuante nem sempre √© a op√ß√£o mais r√°pida. <br><br>  Agora voc√™ v√™ por que esse recurso era importante.  Como eu precisava apenas de opera√ß√µes inteiras simples de 16 bits, procurei os kernels que podem ser expressos como pequenos n√∫meros inteiros sobre divisores na pot√™ncia de dois a 64 e n√£o mais.  Este √© um conjunto de filtros muito mais limitado do que se eu estivesse considerando <i>um</i> conjunto de 6 coeficientes de ponto flutuante. <br><br>  Da mesma forma, por raz√µes de efici√™ncia, n√£o considerei nenhum <i>outro</i> n√∫mero de amostras.  A √∫nica op√ß√£o era 6 ou menos, ent√£o nem testei vers√µes com 8 ou 10 amostras. <br><br>  Assim, chegamos √† primeira resposta: "provavelmente n√£o".  Se aderirmos a essas restri√ß√µes, provavelmente n√£o encontraremos um filtro melhor que possa ser aplicado um n√∫mero infinito de vezes sem degrada√ß√£o.  O n√∫cleo do filtro da primeira parte √© <i>provavelmente o</i> melhor que podemos encontrar, embora deva admitir que n√£o posso provar exaustivamente. <br><br>  Mas e se <i>n√£o precisarmos</i> aderir a essas restri√ß√µes? <br><br><h2>  Vers√£o de ponto flutuante </h2><br>  Se nos livrarmos das limita√ß√µes espec√≠ficas da vers√£o original do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bink 2</a> (que agora est√° bastante desatualizada - muitas revis√µes foram lan√ßadas) e usarmos coeficientes arbitr√°rios de ponto flutuante, como podemos melhorar os resultados? <br><br>  Bem, como sabemos que meu n√∫cleo inteiro nunca se degrada e sabemos que Lanczos √© mais n√≠tido, mas se degrada, √© l√≥gico que podemos encontrar um lugar <i>entre os</i> dois conjuntos de coeficientes onde a degrada√ß√£o come√ßa.  Ent√£o, eu escrevi um programa que me ajudou a encontrar esse ponto em particular, e aqui est√° o kernel que encontrei: <br><br><pre> <code class="cpp hljs">MyFloatKernel6[] = {<span class="hljs-number"><span class="hljs-number">0.027617</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">0.603198</span></span>, <span class="hljs-number"><span class="hljs-number">-0.130815</span></span>, <span class="hljs-number"><span class="hljs-number">0.027617</span></span>};</code> </pre> <br>  Este kernel requer 272 itera√ß√µes para convergir, mas √© infinitamente est√°vel e parece <i>muito</i> mais n√≠tido que meu filtro inteiro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/855/81c/e4885581cec995e7aabc0a845ac92868.png" width="1016" height="284"></div><br>  De fato, √© quase indistingu√≠vel do original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Quase ... mas n√£o exatamente.  Se voc√™ observar atentamente, ainda poder√° ver emba√ßamento e atenua√ß√£o em √°reas de alto contraste.  A maneira mais f√°cil de ver isso √© nos olhos de um "dinossauro" laranja e em √°reas de muita luz atr√°s do bambu. <br><br>  Ou seja, um filtro de ponto flutuante de 6 amostras √© definitivamente melhor, mas n√£o √© perfeito.  Ainda pode ser melhorado? <br><br><h2>  Aumentar a largura do filtro </h2><br>  Inicialmente, um filtro com 6 amostras foi selecionado pelos mesmos motivos que as fra√ß√µes com n√∫meros inteiros pequenos: eu estava procurando por um filtro extremamente eficiente.  Mas agora estamos pesquisando e j√° passamos para n√∫meros de ponto flutuante. Por que n√£o considerar um filtro mais amplo? <br><br>  Combinando nosso filtro inteiro de 6 amostras com o Lanczos de 6 amostras, obtivemos um filtro muito bom.  Por que n√£o combinamos com o Lanczos de 8 amostras? <br><br>  O Lanczos de 8 amostras √© assim: <br><br><pre> <code class="cpp hljs">Lanczos8[] = {<span class="hljs-number"><span class="hljs-number">-0.01263</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">0.61888</span></span>, <span class="hljs-number"><span class="hljs-number">-0.16601</span></span>, <span class="hljs-number"><span class="hljs-number">0.05976</span></span>, <span class="hljs-number"><span class="hljs-number">-0.01263</span></span>};</code> </pre> <br>  Como o Lanczos de 6 amostras, √© muito inst√°vel e entra em colapso ap√≥s 178 itera√ß√µes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/38f/1c6/2c538f1c656fbd96798b8e3a82205c11.png" width="1016" height="284"></div><br>  Se procurarmos um filtro melhor entre um filtro inteiro de 6 amostras e um Lanczos de 8 amostras, encontraremos este not√°vel filtro de 8 amostras: <br><br><pre> <code class="cpp hljs">MyFloatKernel8[] = {<span class="hljs-number"><span class="hljs-number">-0.010547</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">0.614844</span></span>, <span class="hljs-number"><span class="hljs-number">-0.156641</span></span>, <span class="hljs-number"><span class="hljs-number">0.052344</span></span>, <span class="hljs-number"><span class="hljs-number">-0.010547</span></span>};</code> </pre> <br>  Como um filtro infinitamente est√°vel, ele tem um desempenho incr√≠vel.  Ele converge ap√≥s 202 itera√ß√µes (a converg√™ncia √© mais r√°pida que meus dois filtros) e √© t√£o parecido com o original que √© dif√≠cil distinguir qual deles √© qual: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/a04/ca5/bdda04ca55350f0ca71566187e25f38a.png" width="1016" height="284"></div><br>  Aqui est√° o original para refer√™ncia novamente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/053/1d5/0840531d5fdb3982f40aac382174e5f0.png" width="1024" height="284"></div><br>  Comparado ao meu filtro inteiro original, h√° uma melhoria significativa. <br><br><h2>  Como funcionam os filtros infinitamente est√°veis? </h2><br>  Eu estava indo para terminar este post algo como isto: <br><br>  "N√£o sei exatamente como tudo funciona.  Em outras √°reas em que trabalhei com as transforma√ß√µes infinitamente aplic√°veis, sei como a matem√°tica de fronteira √© realizada e a an√°lise √∫til √© criada.  Em primeiro lugar, trata-se da an√°lise da superf√≠cie limite para superf√≠cies de subdivis√£o, onde s√£o calculados os autovalores e autovetores da matriz de subdivis√£o, ap√≥s os quais √© poss√≠vel levar com precis√£o o limite em um grau infinito.  Mas n√£o tenho experi√™ncia em realizar essa an√°lise para filtros halfpel, porque eles n√£o deixam os pixels no lugar, mas os deslocam para o lado ". <br><br>  Esse era o meu plano.  Por√©m, entre a reda√ß√£o da primeira e da segunda partes, enviei os resultados do filtro aprimorado para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fabien Giessen</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Charles Bloom</a> .  N√£o √© de surpreender que <i>eles</i> soubessem a matem√°tica necess√°ria para o estudo anal√≠tico desse problema.  Descobriu-se que, para os filtros, existe realmente uma an√°lise de autovalores e vetores, mas n√£o √© bem assim. <br><br>  Mas <i>pode ser</i> facilmente executado - na verdade, √© incorporado aos programas CAM como um processo trivial de uma etapa e podemos realmente observar os autovalores de filtros.  Ele n√£o nos fornece respostas completas, porque aqui o fato de <i>arredondar</i> (ou truncar) para 8 bits (ou 10 bits ou 12 bits) ap√≥s cada filtragem √© importante, porque o truncamento afeta o m√©todo de acumular erros em compara√ß√£o com a √°lgebra infinitamente precisa. <br><br>  Infelizmente, como essa n√£o √© minha √°rea de especializa√ß√£o, n√£o posso nem obter uma vis√£o geral detalhada dessa an√°lise.  Perguntei a Fabien e Charles se eles poderiam escrever posts com as boas informa√ß√µes que me enviaram pelo correio (ambos t√™m blogs t√©cnicos - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o ryg blog</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cbloom rants</a> ), e Fabien escreveu uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelente s√©rie de artigos sobre os fundamentos matem√°ticos dos filtros est√°veis</a> .  Se voc√™ est√° interessado na estrutura te√≥rica do que est√° acontecendo nos meus dois posts, recomendo a leitura desta s√©rie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468629/">https://habr.com/ru/post/pt468629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468615/index.html">Os 10 principais idiomas para localiza√ß√£o de aplicativos</a></li>
<li><a href="../pt468621/index.html">Traduzimos a rede dom√©stica para DoH, ou outro clique no nariz do filtro</a></li>
<li><a href="../pt468623/index.html">Quero resenhas sobre Habr</a></li>
<li><a href="../pt468625/index.html">Sem servidor: 15% mais lento e oito vezes mais caro</a></li>
<li><a href="../pt468627/index.html">M√≥dulos de E / S ADAM-6200</a></li>
<li><a href="../pt468631/index.html">Testando aplicativos Flutter. Iniciar</a></li>
<li><a href="../pt468635/index.html">Dichalcogenetos de metais de transi√ß√£o: desvendando os segredos do crescimento de cristais WS2</a></li>
<li><a href="../pt468637/index.html">Como lidar com grandes conjuntos de dados em pandas. Trabalhamos com o banco de dados FIAS usando python e 8 GB de mem√≥ria</a></li>
<li><a href="../pt468639/index.html">Novidades nos consoles da web 2019</a></li>
<li><a href="../pt468641/index.html">Tutorial para criar solu√ß√£o Blockchain no Hyperledger Composer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>