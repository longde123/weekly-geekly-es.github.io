<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚕️ 👈🏾 ✊🏽 So arbeiten Sie mit Postgres in Go: Praktiken, Funktionen, Nuancen 👨‍💻 🤘🏾 🦈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das unerwartete Verhalten der Anwendung in Bezug auf die Arbeit mit der Datenbank führt zu einem Krieg zwischen dem DBA und den Entwicklern: DBA-Ruf: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So arbeiten Sie mit Postgres in Go: Praktiken, Funktionen, Nuancen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461935/"><p><img src="https://habrastorage.org/webt/yg/8e/hm/yg8ehmpmicsm7ye6fwju6kwog14.png"></p><br><p>  Das unerwartete Verhalten der Anwendung in Bezug auf die Arbeit mit der Datenbank führt zu einem Krieg zwischen dem DBA und den Entwicklern: DBA-Ruf: "Ihre Anwendung löscht die Datenbank", die Entwickler - "Aber alles hat vorher funktioniert!"  Am schlimmsten ist, dass DBA und Entwickler sich nicht gegenseitig helfen können: Einige kennen die Nuancen der Anwendung und des Treibers nicht, andere kennen die Funktionen der Infrastruktur nicht.  Es wäre schön, eine solche Situation zu vermeiden. </p><br><p>  Sie müssen verstehen, dass es oft nicht ausreicht, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-database-sql.org zu durchsuchen</a> .  Es ist besser, sich mit den Erfahrungen anderer zu bewaffnen.  Noch besser, wenn es sich um eine Erfahrung handelt, die durch Blut und Geldverlust gewonnen wurde. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Uojy57I-xP0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Mein Name ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ryabinkov Artemy</a> und dieser Artikel ist eine freie Interpretation meines Berichts von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saints HighLoad 2019-</a> Konferenz. </p><br><h1 id="instrumenty">  Die Werkzeuge </h1><br><p>  Die minimal erforderlichen Informationen zum Arbeiten mit einer SQL-ähnlichen Datenbank finden Sie in Go unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">go-database-sql.org</a> .  Wenn Sie es nicht gelesen haben, lesen Sie es. </p><br><h2 id="sqlx">  sqlx </h2><br><p>  Meiner Meinung nach ist die Kraft von Go die Einfachheit.  Dies wird zum Beispiel dadurch ausgedrückt, dass es für Go üblich ist, Abfragen in Bare-SQL zu schreiben (ORM ist nicht in Ehren).  Dies ist sowohl ein Vorteil als auch eine Quelle zusätzlicher Schwierigkeiten. </p><br><p> Wenn Sie das Standard- <code>database/sql</code> Sprachpaket verwenden, möchten Sie daher die Schnittstellen erweitern.  Schauen Sie sich in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fall github.com/jmoiron/sqlx an</a> .  Lassen Sie mich Ihnen einige Beispiele zeigen, wie diese Erweiterung Ihr Leben vereinfachen kann. </p><br><p>  Durch die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StructScan</a> müssen Daten aus Spalten nicht mehr manuell in Struktureigenschaften verschoben werden. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Place <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Country <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> City sql.NullString TelephoneCode <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`db:"telcode"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place err = rows.StructScan(&amp;p)</code> </pre> <br><p>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NamedQuery</a> können Sie Struktureigenschaften als Platzhalter in einer Abfrage verwenden. </p><br><pre> <code class="go hljs">p := Place{Country: <span class="hljs-string"><span class="hljs-string">"South Africa"</span></span>} sql := <span class="hljs-string"><span class="hljs-string">`.. WHERE country=:country`</span></span> rows, err := db.NamedQuery(sql, p)</code> </pre> <br><p>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Get</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Select</a> können Sie die Notwendigkeit beseitigen, Schleifen, die Zeilen aus der Datenbank abrufen, manuell zu schreiben. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pp []Place <span class="hljs-comment"><span class="hljs-comment">// Get   p     err = db.Get(&amp;p, ".. LIMIT 1") // Select   pp   . err = db.Select(&amp;pp, ".. WHERE telcode &gt; ?", 50)</span></span></code> </pre> <br><h1 id="drayvery">  Treiber </h1><br><p>  <code>database/sql</code> ist eine Reihe von Schnittstellen für die Arbeit mit der Datenbank, und <code>sqlx</code> ist ihre Erweiterung.  Damit diese Schnittstellen funktionieren, benötigen sie eine Implementierung.  Die Treiber sind für die Implementierung verantwortlich. </p><br><p>  Beliebteste Treiber: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/lib/pq</a> - <code>pure Go Postgres driver for database/sql.</code>  Dieser Treiber ist seit langem der Standard.  Aber heute hat es seine Relevanz verloren und wird vom Autor nicht weiterentwickelt. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/jackc/pgx</a> - <code>PostgreSQL driver and toolkit for Go.</code>  Heute ist es besser, dieses Tool zu wählen. </li></ul><br><p>  <strong>github.com/jackc/pgx</strong> - Dies ist der Treiber, den Sie verwenden möchten.  Warum? </p><br><ul><li>  Aktiv <strong>unterstützt und weiterentwickelt</strong> . </li><li>  Es kann <strong>produktiver sein,</strong> wenn es ohne <code>database/sql</code> Schnittstellen verwendet wird. </li><li>  Unterstützung für über <strong>60 PostgreSQL-Typen</strong> , die <code>PostgreSQL</code> außerhalb des <code>SQL</code> Standards implementiert. </li><li>  Die Möglichkeit, die <strong>Protokollierung</strong> der Vorgänge im Treiber bequem zu implementieren. </li><li>  <code>pgx</code> <strong>Menschen lesbare Fehler</strong> , während nur <code>lib/pq</code> Panikattacken <code>pgx</code> .  Wenn Sie nicht in Panik geraten, stürzt das Programm ab.  ( <em>Sie sollten in Go keine Panik verwenden, dies ist nicht dasselbe wie eine Ausnahme.</em> ) </li><li>  Mit <code>pgx</code> können wir <strong>jede Verbindung</strong> unabhängig <strong>konfigurieren</strong> . </li><li>  <strong>Das logische Replikationsprotokoll von</strong> <code>PostgreSQL</code> wird unterstützt. </li></ul><br><h2 id="4kb">  4 KB </h2><br><p>  Normalerweise schreiben wir diese Schleife, um Daten aus der Datenbank abzurufen: </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, sql) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { err = rows.Scan(...) }</code> </pre> <br><p>  Im Treiber erhalten wir Daten, indem wir sie in <strong>einem 4-KB-Puffer</strong> speichern.  <code>rows.Next()</code> erzeugt eine Netzwerkreise und füllt den Puffer.  Wenn der Puffer nicht ausreicht, gehen wir zum Netzwerk, um die verbleibenden Daten zu erhalten.  Mehr Netzwerkbesuche - weniger Verarbeitungsgeschwindigkeit.  Vergessen wir andererseits nicht den gesamten Prozessspeicher, da die Puffergrenze 4 KB beträgt. </p><br><p>  Aber natürlich möchte ich das Puffervolumen maximal abschrauben, um die Anzahl der Anforderungen an das Netzwerk und die Latenz unseres Dienstes zu verringern.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir fügen</a> diese Gelegenheit hinzu und versuchen, die erwartete Beschleunigung bei <a href="">synthetischen Tests</a> herauszufinden: </p><br><pre> <code class="bash hljs">$ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v -run=XXX -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/furdarius/pgxexperiments/bufsize BenchmarkBufferSize/4KB 5 315763978 ns/op 53112832 B/op 12967 allocs/op BenchmarkBufferSize/8KB 5 300140961 ns/op 53082521 B/op 6479 allocs/op BenchmarkBufferSize/16KB 5 298477972 ns/op 52910489 B/op 3229 allocs/op BenchmarkBufferSize/1MB 5 299602670 ns/op 52848230 B/op 50 allocs/op PASS ok github.com/furdarius/pgxexperiments/bufsize 10.964s</code> </pre> <br><p>  Es ist ersichtlich, dass es keinen großen Unterschied in der Verarbeitungsgeschwindigkeit gibt.  Warum so? </p><br><p>  Es stellt sich heraus, dass wir durch die Größe des Puffers zum Senden von Daten innerhalb von Postgres selbst begrenzt sind.  Dieser Puffer hat eine <a href="">feste</a> Größe von <strong>8 KB</strong> .  Mit <code>strace</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie sehen,</a> dass das Betriebssystem beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen des</a> Systemaufrufs <code>8192</code> Byte zurückgibt.  Und <code>tcpdump</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bestätigt</a> dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit der</a> Größe der Pakete. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tom Lane</a> ( <em>einer der Hauptentwickler des Postgres-Kernels</em> ) <a href="">kommentiert</a> dies folgendermaßen: </p><br><blockquote>  Zumindest war dies traditionell die Größe von Pipe-Puffern in Unix-Maschinen. Im Prinzip ist dies also die optimalste Blockgröße für das Senden von Daten über einen Unix-Socket. </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andres Freund</a> ( <em>Postgres-Entwickler von EnterpriseDB</em> ) ist der <a href="">Ansicht,</a> dass ein 8-KB-Puffer nicht die bisher beste Implementierungsoption ist, und Sie müssen das Verhalten auf verschiedenen Größen und mit einer anderen Socket-Konfiguration testen. </p><br><p>  Wir müssen uns auch daran erinnern, dass PgBouncer auch einen Puffer hat und seine Größe mit dem Parameter <code>pkt_buf</code> konfiguriert werden kann. </p><br><h2 id="oids">  OIDs </h2><br><p>  Ein weiteres Merkmal des pgx ( <em>v3</em> ) -Treibers: Für jede Verbindung fordert er die Datenbank an, Informationen über die <strong>Objekt-ID</strong> ( <em>OID</em> ) <em>abzurufen</em> . </p><br><p>  Diese Bezeichner wurden Postgres hinzugefügt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> interne Objekte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eindeutig zu identifizieren</a> : Zeilen, Tabellen, Funktionen usw. </p><br><p>  Der Treiber verwendet Kenntnisse über <code>OIDs</code> zu verstehen, welche Datenbankspalte in welchem ​​Sprachprimitiv Daten hinzugefügt werden sollen.  Zu diesem <code>pgx</code> unterstützt <code>pgx</code> eine solche Tabelle (der <em>Schlüssel ist der</em> <code>pgx</code> <em>, der Wert ist die Objekt-ID</em> ). </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]Value{ <span class="hljs-string"><span class="hljs-string">"_aclitem"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"_bool"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"_int4"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"_int8"</span></span>: <span class="hljs-number"><span class="hljs-number">55</span></span>, ... }</code> </pre> <br><p>  Diese Implementierung führt dazu, dass der Treiber für jede hergestellte Verbindung mit der Datenbank ungefähr drei Anforderungen stellt, um eine Tabelle mit einer <code>Object ID</code> .  Im normalen Betriebsmodus der Datenbank und der Anwendung können Sie mit dem Verbindungspool in Go keine neuen Verbindungen zur Datenbank generieren.  Bei der geringsten Verschlechterung der Datenbank ist der Verbindungspool auf der Anwendungsseite jedoch erschöpft und die Anzahl der generierten Verbindungen pro Zeiteinheit nimmt erheblich zu.  Die Anforderungen an <code>OIDs</code> sehr <code>OIDs</code> Daher kann der Treiber die Datenbank in einen kritischen Zustand versetzen. </p><br><p>  Hier ist der Moment, in dem solche Anfragen in eine unserer Datenbanken eingespeist wurden: </p><br><p><img src="https://habrastorage.org/webt/lm/ra/vb/lmravbubtqb2ah8dvbvvpklbz8m.png"></p><br><p>  <strong>15 Transaktionen pro Minute</strong> im normalen Modus, ein Sprung von bis zu <strong>6500 Transaktionen</strong> während der Verschlechterung. </p><br><p>  <strong>Was zu tun ist?</strong> </p><br><p>  Begrenzen Sie in erster Linie die Größe Ihres Pools von oben. </p><br><p>  Für <code>database/sql</code> kann dies mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DB.SetMaxOpenConns erfolgen</a> .  Wenn Sie die <code>database/sql</code> Schnittstellen verlassen und <code>pgx.ConnPool</code> (den <em>vom Treiber selbst implementierten Verbindungspool</em> ) verwenden, können Sie <code>MaxConnections</code> angeben ( <em>Standard ist 5</em> ). </p><br><p>  Übrigens verwendet <code>pgx.ConnPool</code> Treiber bei Verwendung von <code>pgx.ConnPool</code> Informationen zu empfangenen <code>OIDs</code> und stellt nicht bei jeder neuen Verbindung Abfragen an die Datenbank. </p><br><p>  Wenn Sie <code>database/sql</code> nicht ablehnen <code>database/sql</code> , können Sie Informationen zu <code>OIDs</code> selbst zwischenspeichern. </p><br><pre> <code class="go hljs">github.com/jackc/pgx/stdlib.OpenDB(pgx.ConnConfig{ CustomConnInfo: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pgtype.ConnInfo, error)</span></span></span></span> { cachedOids = <span class="hljs-comment"><span class="hljs-comment">//  OIDs   . info := pgtype.NewConnInfo() info.InitializeDataTypes(cachedOids) return info, nil } })</span></span></code> </pre> <br><p>  Dies ist eine Arbeitsmethode, deren Verwendung jedoch unter zwei Bedingungen gefährlich sein kann: </p><br><ul><li>  Sie verwenden Enum- oder Domain-Typen in Postgres. </li><li>  Wenn der Assistent fehlschlägt, wechseln Sie die Anwendung zum Replikat, das durch logische Replikation übertragen wird. </li></ul><br><p>  Die Erfüllung dieser Bedingungen führt dazu, dass zwischengespeicherte <code>OIDs</code> ungültig werden.  Wir können sie jedoch nicht reinigen, da wir den Zeitpunkt des Wechsels zu einer neuen Basis nicht kennen. </p><br><p>  In der <code>Postgres</code> Welt wird die physische Replikation normalerweise verwendet, um eine hohe Verfügbarkeit zu organisieren, bei der die Datenbankinstanzen Stück für Stück kopiert werden, sodass Probleme mit dem <code>OIDs</code> Caching in freier Wildbahn selten auftreten.  ( <em>Es ist jedoch besser, mit Ihrem DBA zu klären, wie Standby für Sie funktioniert</em> .) </p><br><p>  In der nächsten Hauptversion des <code>pgx</code> Treibers - <code>v4</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es keine</a> Kampagnen für <code>OIDs</code> .  Jetzt verlässt sich der Treiber nur noch auf die Liste der <code>OIDs</code> , die im Code fest <code>OIDs</code> sind.  Bei benutzerdefinierten Typen müssen Sie die Deserialisierung auf Ihrer Anwendungsseite steuern: Der Treiber gibt einfach ein Stück Speicher als Array von Bytes auf. </p><br><h1 id="logirovanie-i-monitoring">  Protokollierung und Überwachung </h1><br><p>  Durch Überwachung und Protokollierung können Probleme erkannt werden, bevor die Basis abstürzt. </p><br><p>  <code>database/sql</code> bietet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DB.Stats ()</a> -Methode.  Der zurückgegebene Status-Snapshot gibt Ihnen eine Vorstellung davon, was im Treiber vor sich geht. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DBStats <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxOpenConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// Pool State OpenConnections int InUse int Idle int // Counters WaitCount int64 WaitDuration time.Duration MaxIdleClosed int64 MaxLifetimeClosed int64 }</span></span></code> </pre> <br><p>  Wenn Sie den Pool in <code>pgx</code> direkt verwenden, erhalten Sie mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ConnPool.Stat ()</a> -Methode ähnliche Informationen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ConnPoolStat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AvailableConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  Die Protokollierung ist ebenso wichtig, und mit <code>pgx</code> können Sie dies tun.  Der Treiber akzeptiert die <code>Logger</code> Schnittstelle, indem er implementiert, dass Sie alle Ereignisse erhalten, die im Treiber auftreten. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Log a message at the given level with data key/value pairs. // data may be nil. Log(level LogLevel, msg string, data map[string]interface{}) }</span></span></code> </pre> <br><p>  Höchstwahrscheinlich müssen Sie diese Schnittstelle nicht einmal selbst implementieren.  In <code>pgx</code> out of the box gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Adaptern</a> für die gängigsten Logger, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uber-go / zap</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sirupsen / logrus</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rs / zerolog</a> . </p><br><h1 id="infrastruktura">  Die Infrastruktur </h1><br><p>  Fast immer, wenn Sie mit <code>Postgres</code> Sie den <strong>Verbindungspooler</strong> und es wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PgBouncer</a> ( <em>oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Odyssee</a> - wenn Sie Yandex sind</em> ) sein. </p><br><p>  Warum so, können Sie in dem ausgezeichneten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brandur.org/postgres-connections lesen</a> .  Kurz gesagt, wenn die Anzahl der Clients <strong>100 überschreitet,</strong> beginnt sich <strong>die</strong> Geschwindigkeit der Verarbeitungsanforderungen zu verschlechtern.  Dies geschieht aufgrund der Funktionen der Implementierung von Postgres selbst: dem Start eines separaten Prozesses für jede Verbindung, dem Mechanismus zum Entfernen von Snapshots und der Verwendung des gemeinsam genutzten Speichers für die Interaktion - all dies wirkt sich aus. </p><br><p>  Hier ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchmark</a> verschiedener Implementierungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> Verbindungspoolern: <br><img src="https://habrastorage.org/webt/im/p1/-n/imp1-nuasdxn1wmve7l89rrvmbw.png"></p><br><p>  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchmark-</a> Bandbreite mit und ohne PgBouncer. </p><br><p><img src="https://habrastorage.org/webt/jc/cp/21/jccp2150oefyeiixeu005lpsl_0.png"></p><br><p>  Infolgedessen sieht Ihre Infrastruktur folgendermaßen aus: </p><br><p><img src="https://habrastorage.org/webt/bf/ee/ok/bfeeokt_cdojbuddo7_rhzddjis.png"></p><br><p>  Wobei <code>Server</code> der Prozess ist, der Benutzeranforderungen verarbeitet.  Dieser Prozess dreht sich in <code>kubernetes</code> in 3 Kopien ( <em>mindestens</em> ).  Auf einem <code>PgBouncer'</code> befindet sich <code>PgBouncer'</code> <code>Postgres</code> , das von <code>PgBouncer'</code> abgedeckt wird.  <code>PgBouncer</code> selbst <code>PgBouncer</code> Single-Threaded, daher starten wir mehrere Bouncer, deren Datenverkehr wir mit <code>HAProxy</code> ausgleichen.  Als Ergebnis erhalten wir eine solche Kette der Abfrageausführung in der Datenbank: <code>   → HAProxy → PgBouncer → Postgres</code> . </p><br><p>  <code>PgBouncer</code> kann in drei Modi arbeiten: </p><br><ul><li>  <strong>Sitzungspooling</strong> - Für jede Sitzung wird eine Verbindung ausgegeben und ihr für die gesamte Lebensdauer zugewiesen. </li><li>  <strong>Transaktionspooling</strong> - Die Verbindung bleibt bestehen, während die Transaktion ausgeführt wird.  Sobald die Transaktion abgeschlossen ist, nimmt <code>PgBouncer</code> diese Verbindung und gibt sie an eine andere Transaktion zurück.  Dieser Modus ermöglicht eine sehr gute Entsorgung von Verbindungen. </li><li>  <strong>Anweisungspooling</strong> - <strong>veralteter</strong> Modus.  Es wurde nur zur Unterstützung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL / Proxy erstellt</a> . </li></ul><br><p>  Sie können die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matrix sehen,</a> welche Eigenschaften in jedem Modus verfügbar sind.  Wir wählen <strong>Transaktionspooling</strong> , aber es gibt Einschränkungen beim Arbeiten mit <code>Prepared Statements</code> . </p><br><h2 id="transaction-pooling--prepared-statements">  Transaktionspooling + vorbereitete Anweisungen </h2><br><p>  Stellen wir uns vor, wir möchten eine Anfrage vorbereiten und dann ausführen.  Irgendwann starten wir eine Transaktion, in der wir eine Vorbereitungsanforderung senden, und wir erhalten die ID der vorbereiteten Anforderung aus der Datenbank. </p><br><p><img src="https://habrastorage.org/webt/pb/tu/bq/pbtubqa7cvmly0ntnhs0dwc9etc.png"></p><br><p>  Nachdem wir zu einem anderen Zeitpunkt eine weitere Transaktion generiert haben.  Darin wenden wir uns der Datenbank zu und möchten die Anforderung unter Verwendung des Bezeichners mit den angegebenen Parametern erfüllen. </p><br><p><img src="https://habrastorage.org/webt/uy/ci/h4/uycih4iuh8aasw43aqodbsxolac.png"></p><br><p>  Im <strong>Transaktionspooling-</strong> Modus können zwei Transaktionen in unterschiedlichen Verbindungen ausgeführt werden, die <strong>Anweisungs-ID ist jedoch</strong> nur innerhalb einer Verbindung gültig.  Wir erhalten eine <code>prepared statement does not exist</code> beim Versuch, eine Anforderung auszuführen, <code>prepared statement does not exist</code> Fehler <code>prepared statement does not exist</code> . </p><br><p>  Das Unangenehmste: Da während der Entwicklung und des Testens die Last gering ist, stellt <code>PgBouncer</code> häufig dieselbe Verbindung her und alles funktioniert ordnungsgemäß.  Sobald wir uns jedoch auf den Weg machen, beginnen die Anfragen mit einem Fehler zu fallen. </p><br><p>  Finden Sie nun <code>Prepared Statements</code> in diesem Code: </p><br><pre> <code class="go hljs">sql := <span class="hljs-string"><span class="hljs-string">`select * from places where city = ?`</span></span> rows, err := s.db.Query(sql, city)</code> </pre> <br><p>  Du wirst ihn nicht sehen!  Die Abfragevorbereitung erfolgt implizit in <code>Query()</code> .  Gleichzeitig erfolgt die Vorbereitung und Ausführung der Anfrage in verschiedenen Transaktionen, und wir erhalten alles, was ich oben beschrieben habe, vollständig. </p><br><p>  <strong>Was zu tun ist?</strong> </p><br><p>  Die erste und einfachste Option besteht darin <strong>, <code>PgBouncer</code> auf <code>Session pooling</code> <code>PgBouncer</code></strong> .  Der Sitzung wird eine Verbindung zugewiesen, alle Transaktionen beginnen mit dieser Verbindung und vorbereitete Anforderungen funktionieren ordnungsgemäß.  In diesem Modus lässt die Effizienz der Verwendung von Verbindungen jedoch zu wünschen übrig.  Daher wird diese Option nicht berücksichtigt. </p><br><p>  Die zweite Möglichkeit besteht <strong>darin, eine Anfrage auf der Clientseite vorzubereiten</strong> .  Ich möchte dies aus zwei Gründen nicht tun: </p><br><ul><li>  Mögliche SQL-Schwachstellen.  Der Entwickler kann das Entkommen vergessen oder falsch machen. </li><li>  Entkommen Sie den Abfrageparametern jedes Mal, wenn Sie mit Ihren Händen schreiben müssen. </li></ul><br><p>  Eine andere Möglichkeit besteht darin, <strong>jede Anforderung explizit in eine Transaktion einzuschließen</strong> .  Schließlich nimmt <code>PgBouncer</code> die Verbindung nicht auf, solange die Transaktion <code>PgBouncer</code> ist.  Dies funktioniert, aber zusätzlich zur Ausführlichkeit in unserem Code erhalten wir auch mehr Netzwerkanrufe: Beginnen, Vorbereiten, Ausführen, Festschreiben.  Insgesamt 4 Netzwerkanrufe pro Anfrage.  Die Latenz wächst. </p><br><p>  Aber ich möchte es sowohl sicher als auch bequem und effizient.  Und es gibt eine solche Option!  Sie können dem Treiber explizit mitteilen, dass Sie den <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfachen Abfragemodus verwenden</a></strong> möchten.  In diesem Modus erfolgt keine Vorbereitung und die gesamte Anforderung wird in einem Netzwerkanruf weitergeleitet.  In diesem Fall nimmt der Treiber die Abschirmung für jeden der Parameter selbst vor ( <em><code>standard_conforming_strings</code> muss auf der Basisebene oder beim Herstellen einer Verbindung aktiviert werden</em> ). </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... RuntimeParams: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"standard_conforming_strings"</span></span>: <span class="hljs-string"><span class="hljs-string">"on"</span></span>, }, PreferSimpleProtocol: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }</code> </pre> <br><h1 id="otmena-zaprosov">  Anfragen abbrechen </h1><br><p>  Die folgenden Probleme beziehen sich auf das Abbrechen von Anforderungen auf der Anwendungsseite. </p><br><p>  Schauen Sie sich diesen Code an.  Wo sind die Fallstricke? </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, ...)</code> </pre> <br><p>  Go verfügt über eine Methode zur Steuerung des Programmablaufs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">context.Context</a> .  In diesem Code übergeben wir den <code>ctx</code> Treiber, sodass <code>ctx</code> Treiber beim Schließen des Kontexts die Anforderung auf Datenbankebene abbricht. </p><br><p>  Gleichzeitig wird erwartet, dass wir Ressourcen sparen, indem wir Anfragen stornieren, auf die niemand wartet.  Wenn Sie jedoch eine Anforderung <code>PgBouncer</code> sendet <code>PgBouncer</code> Version <em>1.7</em> Informationen an die Verbindung, dass diese Verbindung zur Verwendung bereit ist, und gibt sie anschließend an den Pool zurück.  Dieses Verhalten von <code>PgBouncer'</code> führt den Treiber in die Irre, der beim Senden der nächsten Anforderung sofort <code>ReadyForQuery</code> als Antwort erhält.  Am Ende stellen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unerwartete ReadyForQuery-Fehler fest</a> . </p><br><p>  Ab <code>PgBouncer</code> Version <em>1.8 wurde</em> dieses Verhalten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">behoben</a> .  Verwenden Sie die aktuelle Version von <code>PgBouncer</code> . </p><br><p>  Und obwohl in diesem Fall die Fehler verschwinden, bleibt ein interessantes Verhalten bestehen.  In einigen Fällen erhält unsere Anwendung möglicherweise Antworten nicht auf ihre Anfrage, sondern auf die benachbarte (Hauptsache, die Anfragen stimmen mit der Art und Reihenfolge der angeforderten Daten überein).  <code>where user_id = 2</code> ist beispielsweise für die Abfrage <code>where user_id = 2</code> die Antwort der Abfrage <code>where user_id = 42</code> .  Dies ist auf die Verarbeitung von Stornierungsanforderungen auf verschiedenen Ebenen zurückzuführen: auf der Ebene des Treiberpools und des Bouncer-Pools. </p><br><h3 id="otlozhennaya-otmena">  Verspätete Stornierung </h3><br><p>  Um die Anfrage abzubrechen, müssen wir eine neue Verbindung zur Datenbank herstellen und eine Stornierung anfordern.  <code>Postgres</code> erstellt für jede Verbindung einen eigenen Prozess.  Wir senden einen Befehl, um die <strong>aktuelle</strong> Anfrage in einem bestimmten Prozess abzubrechen.  Erstellen Sie dazu eine neue Verbindung und übertragen Sie darin die interessierende Prozess-ID (PID) an uns.  Während der Stornierungsbefehl zur Basis fliegt, kann die stornierte Anforderung von selbst enden. </p><br><p><img src="https://habrastorage.org/webt/us/xf/v_/usxfv_i0ze_axpmjtlir183reiu.png"></p><br><p>  <code>Postgres</code> führt den Befehl aus und bricht die <strong>aktuelle</strong> Anforderung im angegebenen Prozess ab.  Die aktuelle Anfrage ist jedoch nicht die, die wir ursprünglich stornieren wollten.  Aufgrund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Verhaltens</a> bei der Arbeit mit <code>Postgres</code> mit <code>PgBouncer</code> sicherer, die Anforderung nicht auf Treiberebene abzubrechen.  Dazu können Sie die <code>CustomCancel</code> , die die Anforderung auch dann nicht <code>context.Context</code> , wenn <code>context.Context</code> verwendet wird. </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... CustomCancel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, }</code> </pre> <br><h1 id="cheklist-po-rabote-s-postgres">  Postgres Checkliste </h1><br><p>  Anstelle von Schlussfolgerungen habe ich beschlossen, eine Checkliste für die Arbeit mit Postgres zu erstellen.  Dies sollte dazu beitragen, dass der Artikel in meinen Kopf passt. </p><br><ul><li>  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/jackc/pgx</a> als Treiber für die Arbeit mit Postgres. </li><li>  Begrenzen Sie die Größe des Verbindungspools von oben. </li><li>  Cache- <code>OIDs</code> oder verwende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pgx.ConnPool,</a> wenn du mit <code>pgx</code> Version 3 <code>pgx</code> . </li><li>  Sammeln Sie Metriken aus dem Verbindungspool mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DB.Stats ()</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ConnPool.Stat ()</a> . </li><li>  Protokollieren Sie, was im Treiber passiert. </li><li>  Verwenden Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfachen</a> Abfragemodus, um Probleme bei der <code>PgBouncer</code> im <code>PgBouncer</code> Transaktionsmodus zu vermeiden. </li><li>  Aktualisieren Sie <code>PgBouncer</code> auf die neueste Version. </li><li>  Seien Sie vorsichtig beim Abbrechen von Anfragen aus der Anwendung. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461935/">https://habr.com/ru/post/de461935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461919/index.html">Formulare bei React wiederverwenden</a></li>
<li><a href="../de461921/index.html">HDMI-LVDS. Entwicklung auf TSUMV59 von MStar</a></li>
<li><a href="../de461923/index.html">JetBrains Open Day in St. Petersburg: Video</a></li>
<li><a href="../de461927/index.html">Aktives Ranking-Lernen</a></li>
<li><a href="../de461929/index.html">Überwachen und Überprüfen des SSD-Status unter Linux</a></li>
<li><a href="../de461937/index.html">Parkinson-Gesetz und wie man es bricht</a></li>
<li><a href="../de461939/index.html">Jahr des Abenteuers mit Graphen-Python</a></li>
<li><a href="../de461941/index.html">Massieren Sie es</a></li>
<li><a href="../de461945/index.html">Die Zusammenfassung der Ereignisse für HR-Fachkräfte im Bereich IT für August 2019</a></li>
<li><a href="../de461949/index.html">AppCode 2019.2: Swift 5.1, Analyse der Codeabdeckung durch Tests, Anzeige von zerlegtem Code und mehr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>