<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèª ü§ö üçº Entwicklung eines neuen statischen Analysators: PVS-Studio Java ‚ÅâÔ∏è üòè üì¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der statische Analysator PVS-Studio ist in der Welt von C, C ++ und C # als Werkzeug zum Erkennen von Fehlern und potenziellen Schwachstellen bekannt....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines neuen statischen Analysators: PVS-Studio Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/414669/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c9/ccb/b07/9c9ccbb070ea671cf64a42a257727397.png" alt="Bild 3"></div><br>  Der statische Analysator PVS-Studio ist in der Welt von C, C ++ und C # als Werkzeug zum Erkennen von Fehlern und potenziellen Schwachstellen bekannt.  Wir haben jedoch nur wenige Kunden aus dem Finanzsektor, da sich herausstellte, dass Java und IBM RPG (!) Dort jetzt gefragt sind.  Wir wollten jedoch immer n√§her an die Enterprise-Welt heranr√ºcken. Deshalb haben wir uns nach einiger √úberlegung entschlossen, einen Java-Analysator zu erstellen. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Nat√ºrlich gab es Bedenken.  Es ist einfach, den Analysatormarkt im IBM RPG zu erobern.  Ich bin mir √ºberhaupt nicht sicher, ob es vern√ºnftige Werkzeuge f√ºr die statische Analyse dieser Sprache gibt.  In der Java-Welt sieht das ganz anders aus.  Es gibt bereits eine Reihe von Tools f√ºr die statische Analyse. Um weiterzukommen, m√ºssen Sie einen wirklich leistungsstarken und coolen Analysator erstellen. <br><br>  Trotzdem hat unser Unternehmen Erfahrung mit verschiedenen Tools zur statischen Analyse von Java und wir sind sicher, dass wir viele Dinge besser machen k√∂nnen. <br><br>  Au√üerdem hatten wir eine Idee, wie wir die volle Leistung unseres C ++ - Analysators in einem Java-Analysator nutzen k√∂nnen.  Aber das Wichtigste zuerst. <br><br><h2>  Baum </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/0e0/546/bc10e054614c4a1e6bf2d122659ef7fe.png" alt="Bild 6"></div><br><br>  Zun√§chst musste entschieden werden, wie wir den Syntaxbaum und das semantische Modell erhalten. <br><br>  Der Syntaxbaum ist das Grundelement, um das der Analysator aufgebaut ist.  Bei der Durchf√ºhrung von √úberpr√ºfungen durchl√§uft der Analysator den Syntaxbaum und untersucht seine einzelnen Knoten.  Ohne einen solchen Baum ist eine ernsthafte statische Analyse praktisch nicht m√∂glich.  Beispielsweise ist die Suche nach Fehlern mit regul√§ren Ausdr√ºcken nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vielversprechend</a> . <br><br>  Es ist erw√§hnenswert, dass nur ein Syntaxbaum nicht ausreicht.  Der Analysator ben√∂tigt auch semantische Informationen.  Zum Beispiel m√ºssen wir die Typen aller Elemente des Baums kennen, zur Variablendeklaration gehen k√∂nnen usw. <br><br>  Wir haben verschiedene Optionen untersucht, um einen Syntaxbaum und ein semantisches Modell zu erhalten: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ANTLR</a> (mit Grammatik f√ºr Java) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaParser und JavaSymbolSolver</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ASTParser von Eclipse von Eclipse JDT</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">L√∂ffel</a> </li></ul><br>  Wir haben die Idee, ANTLR zu verwenden, fast sofort aufgegeben, da dies die Entwicklung des Analysators unn√∂tig erschweren w√ºrde (die semantische Analyse m√ºsste selbst implementiert werden).  Am Ende beschlossen wir, in der Spoon-Bibliothek Halt zu machen: <br><br><ul><li> Es ist nicht nur ein Parser, sondern ein ganzes √ñkosystem - es bietet nicht nur einen Analysebaum, sondern auch M√∂glichkeiten zur semantischen Analyse. So k√∂nnen Sie beispielsweise Informationen zu den Variablentypen abrufen, zur Variablendeklaration gehen, Informationen zur √ºbergeordneten Klasse abrufen usw. </li><li>  Es basiert auf Eclipse JDT und kann Code kompilieren. </li><li>  Es unterst√ºtzt die neueste Version von Java und wird st√§ndig aktualisiert. </li><li>  Gute Dokumentation und klare API. </li></ul><br>  Hier ist ein Beispiel f√ºr ein Metamodell, das Spoon bereitstellt und mit dem wir beim Erstellen von Diagnoseregeln arbeiten: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bd/aa0/794/2bdaa079486dd102f2734eec55221c6f.png" alt="Bild 10"></div><br><br>  Dieses Metamodell entspricht dem folgenden Code: <br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (a + b) * <span class="hljs-number"><span class="hljs-number">4</span></span>; System.out.println(x); } }</code> </pre> <br>  Eines der sch√∂nen Dinge an Spoon ist, dass es den Syntaxbaum (Entfernen und Hinzuf√ºgen von Knoten) vereinfacht, um die Arbeit zu vereinfachen.  Gleichzeitig ist die semantische √Ñquivalenz des vereinfachten Metamodells des Originals gew√§hrleistet. <br><br>  F√ºr uns bedeutet dies zum Beispiel, dass wir uns beim √úberqueren eines Baumes keine Sorgen mehr machen m√ºssen, zus√§tzliche Klammern zu √ºberspringen.  Au√üerdem wird jeder Ausdruck in einen Block eingef√ºgt, Importe werden angezeigt und einige andere √§hnliche Vereinfachungen vorgenommen. <br><br>  Zum Beispiel ein Code wie dieser: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = ((<span class="hljs-number"><span class="hljs-number">0</span></span>)); (i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((<span class="hljs-number"><span class="hljs-number">42</span></span>)));</code> </pre> <br>  wird wie folgt dargestellt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } }</code> </pre> <br>  Basierend auf dem Syntaxbaum wird eine sogenannte musterbasierte Analyse durchgef√ºhrt.  Dies ist eine Suche nach Fehlern im Quellcode eines Programms unter Verwendung bekannter Fehlercodemuster.  Im einfachsten Fall sucht der Analysator nach Stellen, die wie ein Fehler im Baum aussehen, gem√§√ü den in der entsprechenden Diagnose beschriebenen Regeln.  Die Anzahl solcher Muster ist gro√ü und ihre Komplexit√§t kann stark variieren. <br><br>  Das einfachste Beispiel f√ºr einen Fehler, der durch eine musterbasierte Analyse erkannt wurde, ist der folgende Code aus dem jMonkeyEngine-Projekt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.isConnected()) { log.log(Level.FINE, <span class="hljs-string"><span class="hljs-string">"Connection closed:{0}."</span></span>, p); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.log(Level.FINE, <span class="hljs-string"><span class="hljs-string">"Connection closed:{0}."</span></span>, p); }</code> </pre> <br>  Die <i>then-</i> und <i>else-</i> Bl√∂cke der <i>if-Anweisung</i> sind identisch, h√∂chstwahrscheinlich liegt ein logischer Fehler vor. <br><br>  Hier ist ein weiteres √§hnliches Beispiel aus dem Hive-Projekt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Number) { <span class="hljs-comment"><span class="hljs-comment">// widening conversion return ((Number) obj).doubleValue(); } else if (obj instanceof HiveDecimal) { // &lt;= return ((HiveDecimal) obj).doubleValue(); } else if (obj instanceof String) { return Double.valueOf(obj.toString()); } else if (obj instanceof Timestamp) { return new TimestampWritable((Timestamp)obj).getDouble(); } else if (obj instanceof HiveDecimal) { // &lt;= return ((HiveDecimal) obj).doubleValue(); } else if (obj instanceof BigDecimal) { return ((BigDecimal) obj).doubleValue(); }</span></span></code> </pre> <br>  Dieser Code enth√§lt zwei identische Bedingungen in einer Folge der Form <i>if (....) else if (....) else if (....)</i> .  Es lohnt sich, diesen Abschnitt des Codes auf einen logischen Fehler zu √ºberpr√ºfen oder den doppelten Code zu entfernen. <br><br><h2>  Datenflussanalyse </h2><br>  Neben dem Syntaxbaum und dem semantischen Modell ben√∂tigt der Analysator einen Mechanismus zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analyse des Datenflusses</a> . <br><br>  Durch die Analyse des Datenflusses k√∂nnen Sie die g√ºltigen Werte von Variablen und Ausdr√ºcken an jedem Punkt im Programm berechnen und dadurch Fehler finden.  Wir nennen diese g√ºltigen Werte virtuelle Werte. <br><br>  Bei der ersten Erw√§hnung werden virtuelle Werte f√ºr Variablen, Klassenfelder, Methodenparameter und andere Dinge erstellt.  Wenn es sich um eine Zuweisung handelt, berechnet der Datenflussmechanismus den virtuellen Wert durch Analysieren des Ausdrucks auf der rechten Seite. Andernfalls wird der gesamte g√ºltige Wertebereich f√ºr diesen Variablentyp als virtueller Wert verwendet.  Zum Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// x: [-128..127] { int y = 5; // y: [5] ... }</span></span></span></span></code> </pre> <br>  Jedes Mal, wenn sich der Wert einer Variablen √§ndert, berechnet die Datenfluss-Engine den virtuellen Wert neu.  Zum Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// x: [5] x += 7; // x: [12] ... }</span></span></code> </pre> <br>  Die Datenfluss-Engine verarbeitet auch Steueranweisungen: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// x: [-2147483648..2147483647] { if (x &gt; 3) { // x: [4..2147483647] if (x &lt; 10) { // x: [4..9] } } else { // x: [-2147483648..3] } ... }</span></span></span></span></code> </pre> <br>  In diesem Beispiel gibt es beim Eingeben der Funktion keine Informationen √ºber den Wertebereich der Variablen <i>x</i> , daher wird sie entsprechend dem Typ der Variablen festgelegt (von -2147483648 bis 2147483647).  Dann legt der erste bedingte Block eine Einschr√§nkung <i>x</i> &gt; 3 fest, und die Bereiche werden kombiniert.  Infolgedessen liegt der Wertebereich f√ºr <i>x</i> im <i>then-</i> Block zwischen 4 und 2147483647 und im <i>else-</i> Block zwischen -2147483648 und 3. Die zweite Bedingung <i>x</i> &lt;10 wird auf die gleiche Weise verarbeitet. <br><br>  Dar√ºber hinaus m√ºssen Sie rein symbolische Berechnungen durchf√ºhren k√∂nnen.  Das einfachste Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ a = c; b = c; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) <span class="hljs-comment"><span class="hljs-comment">// &lt;= always true .... }</span></span></code> </pre> <br>  Hier wird der Variablen <i>a</i> der Wert <i>c</i> zugewiesen, der Variablen <i>b wird</i> auch der Wert <i>c</i> zugewiesen, wonach <i>a</i> und <i>b</i> verglichen werden.  Um den Fehler zu finden, denken Sie in diesem Fall einfach an das Holzst√ºck auf der rechten Seite. <br><br>  Hier ist ein etwas komplexeres Beispiel mit Zeichenberechnungen: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; c) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; a) <span class="hljs-comment"><span class="hljs-comment">// &lt;= always false .... } } }</span></span></code> </pre> <br>  In solchen F√§llen ist es bereits notwendig, das Ungleichungssystem in symbolischer Form zu l√∂sen. <br><br>  Der Datenflussmechanismus hilft dem Analysator, Fehler zu finden, die mit der musterbasierten Analyse nur sehr schwer zu finden sind. <br><br>  Diese Fehler umfassen: <br><br><ul><li>  √úberl√§ufe; </li><li>  Das Array ins Ausland gehen; </li><li>  Zugriff durch Null- oder potenziell Nullreferenz; </li><li>  Bedeutungslose Bedingungen (immer wahr / falsch); </li><li>  Speicher- und Ressourcenlecks; </li><li>  Division durch 0; </li><li>  Und einige andere. </li></ul><br>  Die Datenflussanalyse ist besonders wichtig bei der Suche nach Schwachstellen.  Wenn beispielsweise ein bestimmtes Programm Eingaben vom Benutzer empf√§ngt, wird die Eingabe wahrscheinlich verwendet, um einen Denial-of-Service zu verursachen oder die Kontrolle √ºber das System zu erlangen.  Beispiele hierf√ºr sind Fehler, die bei einigen Eingaben zu Puffer√ºberl√§ufen f√ºhren, oder beispielsweise SQL-Injektionen.  In beiden F√§llen m√ºssen der Datenfluss und m√∂gliche Werte von Variablen √ºberwacht werden, damit der statische Analysator solche Fehler und Schwachstellen erkennen kann. <br><br>  Ich muss sagen, dass der Mechanismus zur Datenflussanalyse ein komplexer und umfassender Mechanismus ist, und in diesem Artikel habe ich nur die Grundlagen angesprochen. <br><br>  Schauen wir uns einige Beispiele f√ºr Fehler an, die mithilfe des Datenflussmechanismus erkannt werden k√∂nnen. <br><br>  Hive-Projekt: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] arg2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len1 != len2) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } if (len1 == 0) { return true; } .... if (len1 == len2) { // &lt;= .... } }</span></span></code> </pre> <br>  Die Bedingung <i>len1 == len2</i> ist immer erf√ºllt, da die entgegengesetzte Pr√ºfung oben bereits durchgef√ºhrt wurde. <br><br>  Ein weiteres Beispiel aus demselben Projekt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instances != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Set&lt;String&gt; oldKeys = new HashSet&lt;&gt;(instances.keySet()); if (oldKeys.removeAll(latestKeys)) { .... } this.instances.keySet().removeAll(oldKeys); this.instances.putAll(freshInstances); } else { this.instances.putAll(freshInstances); // &lt;= }</span></span></code> </pre> <br>  Hier im <i>else-</i> Block ist die Dereferenzierung des Nullzeigers garantiert.  Hinweis: Hier sind <i>Instanzen</i> dieselben wie <i>this.instances</i> . <br><br>  Beispiel aus dem JMonkeyEngine-Projekt: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertNewtKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key &gt;= <span class="hljs-number"><span class="hljs-number">0x10000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key - <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Hier wird die <i>Schl√ºsselvariable</i> mit der Nummer 65536 verglichen, sie ist jedoch vom Typ <i>short</i> , und der maximal m√∂gliche Wert f√ºr <i>short</i> ist 32767. Dementsprechend ist die Bedingung niemals erf√ºllt. <br><br>  Ein Beispiel aus dem Jenkins-Projekt: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeBuildWithWorkspace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (R b = getLastBuild(); cnt &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; b ! = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; b = b.getPreviousBuild()) { FilePath ws = b.getWorkspace(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ws != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Die Variable <i>cnt</i> wurde in diesen Code eingef√ºhrt, um die Anzahl der Durchg√§nge auf f√ºnf zu begrenzen. Sie hat jedoch vergessen, sie zu erh√∂hen, wodurch die Pr√ºfung unbrauchbar wird. <br><br><h2>  Anmerkungsmechanismus </h2><br>  Zus√§tzlich ben√∂tigt der Analysator einen Anmerkungsmechanismus.  Annotations ist ein Markup-System, das dem Analysator zus√§tzliche Informationen zu den verwendeten Methoden und Klassen liefert, zus√§tzlich zu den Informationen, die durch die Analyse ihrer Signatur erhalten werden k√∂nnen.  Das Markup erfolgt manuell, es ist ein langer und m√ºhsamer Prozess, da zur Erzielung der besten Ergebnisse eine gro√üe Anzahl von Standardklassen und -methoden der Java-Sprache mit Anmerkungen versehen werden muss.  Es ist auch sinnvoll, beliebte Bibliotheken mit Anmerkungen zu versehen.  Im Allgemeinen k√∂nnen Anmerkungen als Wissensbasis des Analysators √ºber die Vertr√§ge von Standardmethoden und -klassen betrachtet werden. <br><br>  Hier ist ein kleines Beispiel f√ºr einen Fehler, der mithilfe von Anmerkungen erkannt werden kann: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.max(a, a); }</code> </pre> <br>  In diesem Beispiel wurde aufgrund eines Tippfehlers dieselbe Variable als zweites Argument an die <i>Math.max-</i> Methode als erstes Argument √ºbergeben.  Ein solcher Ausdruck ist bedeutungslos und verd√§chtig. <br><br>  In dem Wissen, dass die Argumente der <i>Math.max-</i> Methode immer unterschiedlich sein sollten, kann der statische Analysator eine Warnung f√ºr diesen Code ausgeben. <br><br>  Mit Blick auf die Zukunft werde ich einige Beispiele f√ºr unser Markup von integrierten Klassen und Methoden (C ++ - Code) geben: <br><br><pre> <code class="cpp hljs">Class(<span class="hljs-string"><span class="hljs-string">"java.lang.Math"</span></span>) - Function(<span class="hljs-string"><span class="hljs-string">"abs"</span></span>, Type::Int32) .Pure() .Set(FunctionClassification::NoDiscard) .Returns(Arg1, [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Int &amp;v) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v.Abs(); }) - Function(<span class="hljs-string"><span class="hljs-string">"max"</span></span>, Type::Int32, Type::Int32) .Pure() .Set(FunctionClassification::NoDiscard) .Requires(NotEquals(Arg1, Arg2) .Returns(Arg1, Arg2, [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Int &amp;v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Int &amp;v2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1.Max(v2); }) Class(<span class="hljs-string"><span class="hljs-string">"java.lang.String"</span></span>, TypeClassification::String) - Function(<span class="hljs-string"><span class="hljs-string">"split"</span></span>, Type::Pointer) .Pure() .Set(FunctionClassification::NoDiscard) .Requires(NotNull(Arg1)) .Returns(Ptr(NotNullPointer)) Class(<span class="hljs-string"><span class="hljs-string">"java.lang.Object"</span></span>) - Function(<span class="hljs-string"><span class="hljs-string">"equals"</span></span>, Type::Pointer) .Pure() .Set(FunctionClassification::NoDiscard) .Requires(NotEquals(This, Arg1)) Class(<span class="hljs-string"><span class="hljs-string">"java.lang.System"</span></span>) - Function(<span class="hljs-string"><span class="hljs-string">"exit"</span></span>, Type::Int32) .Set(FunctionClassification::NoReturn)</code> </pre> <br>  Erkl√§rungen: <br><br><ul><li>  <i>Klasse</i> - kommentierte Klasse; </li><li>  <i>Funktion</i> - Methode der annotierten Klasse; </li><li>  <i>Reine</i> Anmerkung, die zeigt, dass das Verfahren sauber ist, d.h.  deterministisch und ohne Nebenwirkungen; </li><li>  <i>Setzen</i> - Setzen eines beliebigen Flags f√ºr die Methode. </li><li>  <i>FunctionClassification :: NoDiscard</i> - Ein Flag, das bedeutet, dass der R√ºckgabewert der Methode verwendet werden muss. </li><li>  <i>FunctionClassification :: NoReturn</i> - Ein Flag, das angibt, dass die Methode keine Kontrolle zur√ºckgibt. </li><li>  <i>Arg1</i> , <i>Arg2</i> , <i>...</i> , <i>ArgN</i> - Argumente f√ºr die Methode; </li><li>  R√ºckgabe - der R√ºckgabewert der Methode; </li><li>  <i>Ben√∂tigt</i> - einen Vertrag f√ºr die Methode. </li></ul><br>  Es ist erw√§hnenswert, dass es neben dem manuellen Markup einen anderen Ansatz f√ºr die Annotation gibt - die automatische Ausgabe von Vertr√§gen basierend auf Bytecode.  Es ist klar, dass Sie mit diesem Ansatz nur bestimmte Vertragsarten anzeigen k√∂nnen, aber es ist m√∂glich, zus√§tzliche Informationen im Allgemeinen aus allen Abh√§ngigkeiten zu erhalten, und nicht nur aus denen, die manuell mit Anmerkungen versehen wurden. <br><br>  √úbrigens gibt es bereits ein Tool, das Vertr√§ge wie <i>@Nullable</i> , <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">NotNull</a></i> basierend auf Bytecode - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FABA anzeigen kann</a> .  Soweit ich wei√ü, wird das FABA-Derivat in IntelliJ IDEA verwendet. <br><br>  Jetzt erw√§gen wir auch, eine Bytecode-Analyse hinzuzuf√ºgen, um Vertr√§ge f√ºr alle Methoden zu erhalten, da diese Vertr√§ge unsere manuellen Anmerkungen gut erg√§nzen k√∂nnten. <br><br>  Diagnoseregeln bei der Arbeit beziehen sich h√§ufig auf Anmerkungen.  Neben der Diagnose verwenden Anmerkungen den Datenflussmechanismus.  Mithilfe der Annotation der Methode <i>java.lang.Math.abs</i> kann beispielsweise der Wert f√ºr das <i>Zahlenmodul</i> genau berechnet werden.  Gleichzeitig m√ºssen Sie keinen zus√§tzlichen Code schreiben - markieren Sie einfach die Methode korrekt. <br><br>  Betrachten Sie ein Beispiel f√ºr einen Fehler aus dem Ruhezustand-Projekt, der durch Anmerkungen erkannt werden kann: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  In diesem Code vergleicht die <i>equals ()</i> -Methode das <i>purchaseSequence-</i> Objekt mit sich selbst.  Sicher ist dies ein Tippfehler und auf der rechten Seite sollte das sein. <i>Kaufsequenz</i> , nicht <i>Kaufsequenz</i> . <br><br><h2>  Wie Dr. Frankenstein einen Analysator aus Teilen zusammenbaute </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/a6a/e05/113a6ae05b7bd0502e1d631746c26ea0.png" alt="Bild 2"></div><br><br>  Da die Mechanismen des Datenflusses und der Anmerkungen selbst nicht sehr stark an eine bestimmte Sprache gebunden sind, wurde beschlossen, diese Mechanismen aus unserem C ++ - Analysator wiederzuverwenden.  Dadurch konnten wir schnell die gesamte Leistung des C ++ - Analysatorkerns in unserem Java-Analysator nutzen.  Dar√ºber hinaus wurde diese Entscheidung auch durch die Tatsache beeinflusst, dass diese Mechanismen in modernem C ++ mit einer Reihe von Metaprogrammier- und Vorlagenmagie geschrieben wurden und dementsprechend nicht sehr gut f√ºr die √úbertragung in eine andere Sprache geeignet sind. <br><br>  Um den Java-Teil mit dem C ++ - Kernel zu verkn√ºpfen, haben wir uns f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWIG (Simplified Wrapper and Interface Generator) entschieden</a> - ein Tool zum automatischen Generieren von Wrappern und Schnittstellen zum Verkn√ºpfen von C- und C ++ - Programmen mit Programmen, die in anderen Sprachen geschrieben sind.  F√ºr Java generiert SWIG <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JNI-</a> Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Java Native Interface)</a> . <br><br>  SWIG eignet sich hervorragend f√ºr F√§lle, in denen bereits eine gro√üe Menge an C ++ - Code in ein Java-Projekt integriert werden muss. <br><br>  Ich werde ein minimales Beispiel f√ºr die Arbeit mit SWIG geben.  Angenommen, wir haben eine C ++ - Klasse, die wir in einem Java-Projekt verwenden m√∂chten: <br><br>  CoolClass.h <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; CoolClass(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br>  CoolClass.cpp <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "CoolClass.h" CoolClass::CoolClass(int v) : val(v) {} void CoolClass::printMe() { std::cout &lt;&lt; "val: " &lt;&lt; val &lt;&lt; '\n'; }</span></span></span></span></code> </pre> <br>  Zuerst m√ºssen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine SWIG-Schnittstellendatei</a> mit einer Beschreibung aller exportierten Funktionen und Klassen erstellen.  Auch in dieser Datei werden bei Bedarf zus√§tzliche Einstellungen vorgenommen. <br><br>  Beispiel.i <br><br><pre> <code class="cpp hljs">%<span class="hljs-keyword"><span class="hljs-keyword">module</span></span> MyModule %{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoolClass.h"</span></span></span><span class="hljs-meta"> %} %</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoolClass.h"</span></span></span></span></code> </pre> <br>  Danach k√∂nnen Sie SWIG ausf√ºhren: <br><br><pre> <code class="cpp hljs">$ swig -c++ -java Example.i</code> </pre> <br>  Es werden die folgenden Dateien generiert: <br><br><ul><li>  CoolClass.java - eine Klasse, mit der wir direkt in einem Java-Projekt arbeiten werden; </li><li>  MyModule.java - eine Modulklasse, in der alle freien Funktionen und Variablen platziert sind; </li><li>  MyModuleJNI.java - Java-Wrapper; </li><li>  Example_wrap.cxx - C ++ - Wrapper. </li></ul><br>  Jetzt m√ºssen Sie nur noch die resultierenden Java-Dateien zum Java-Projekt und die CXX-Datei zum C ++ - Projekt hinzuf√ºgen. <br><br>  Schlie√ülich m√ºssen Sie das C ++ - Projekt als dynamische Bibliothek kompilieren und mit <i>System.loadLibary ()</i> in das Java-Projekt <i>laden</i> : <br><br>  App.java <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibary(<span class="hljs-string"><span class="hljs-string">"example"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ CoolClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CoolClass(<span class="hljs-number"><span class="hljs-number">42</span></span>); obj.printMe(); } }</code> </pre> <br>  Schematisch kann dies wie folgt dargestellt werden: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/35f/b36/20135fb369602791a32d405f5f1231de.png" alt="Bild 8"></div><br><br>  Nat√ºrlich ist in einem realen Projekt nicht alles so einfach und Sie m√ºssen sich etwas mehr anstrengen: <br><br><ul><li>  Um Vorlagenklassen und -methoden aus C ++ verwenden zu k√∂nnen, m√ºssen sie f√ºr alle akzeptierten Vorlagenparameter mithilfe der <i>% template-</i> Direktive instanziiert werden. </li><li>  In einigen F√§llen m√ºssen Sie m√∂glicherweise Ausnahmen abfangen, die vom C ++ - Teil im Java-Teil ausgel√∂st werden.  Standardm√§√üig f√§ngt SWIG keine Ausnahmen von C ++ ab (Segfault tritt auf). Dies ist jedoch mit der <i>%</i> -Ausnahme-Direktive m√∂glich. </li><li>  Mit SWIG k√∂nnen Sie den Plus-Code auf der Java-Seite mit der Direktive <i>% expand erweitern</i> .  In unserem Projekt f√ºgen wir beispielsweise virtuellen Methoden die Methode <i>toString () hinzu</i> , damit wir sie im Java-Debugger anzeigen k√∂nnen. </li><li>  Um das RAII-Verhalten aus C ++ zu emulieren, ist die <i>AutoClosable-</i> Schnittstelle in allen interessierenden Klassen implementiert. </li><li>  Der Direktorenmechanismus erm√∂glicht die Verwendung eines sprach√ºbergreifenden Polymorphismus. </li><li>  Bei Typen, die nur in C ++ (in ihrem Speicherpool) zugewiesen sind, werden Konstruktoren und Finalizer entfernt, um die Leistung zu verbessern.  Der Garbage Collector ignoriert diese Typen. </li></ul><br>  Weitere Informationen zu all diesen Mechanismen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWIG-Dokumentation</a> . <br><br>  Unser Analysator basiert auf gradle, das CMake aufruft, das wiederum SWIG aufruft und den C ++ - Teil kompiliert.  F√ºr Programmierer geschieht dies fast unmerklich, sodass wir w√§hrend der Entwicklung keine besonderen Unannehmlichkeiten haben. <br><br>  Der Kern unseres C ++ - Analysators basiert auf Windows, Linux und MacOS, sodass der Java-Analysator auch in diesen Betriebssystemen funktioniert. <br><br><h2>  Was ist eine Diagnoseregel? </h2><br>  Die Diagnose selbst und der Code f√ºr die Analyse sind in Java geschrieben.  Dies ist auf die enge Interaktion mit Spoon zur√ºckzuf√ºhren.  Jede Diagnoseregel ist ein Besucher, dessen Methoden √ºberladen sind und bei dem die f√ºr uns interessanten Elemente umgangen werden: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a79/427/b94/a79427b9408443a75477c583be7bdd7e.png" alt="Bild 9"></div><br>  Das V6004-Diagnoseframework sieht beispielsweise folgenderma√üen aus: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V6004</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PvsStudioRule</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visitCtIf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CtIf ifElement)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// if ifElement.thenStatement statement is equivalent to // ifElement.elseStatement statement =&gt; add warning V6004 } }</span></span></code> </pre> <br><h2>  Plugins </h2><br>  F√ºr die einfachste Integration des statischen Analysators in das Projekt haben wir Plugins f√ºr die Montagesysteme Maven und Gradle entwickelt.  Der Benutzer kann nur unser Plugin zum Projekt hinzuf√ºgen. <br><br>  F√ºr Gradle: <br><br><pre> <code class="java hljs">.... apply plugin: com.pvsstudio.PvsStudioGradlePlugin pvsstudio { outputFile = <span class="hljs-string"><span class="hljs-string">'path/to/output.json'</span></span> .... }</code> </pre> <br>  F√ºr Maven: <br><br><pre> <code class="java hljs">.... &lt;plugin&gt; &lt;groupId&gt;com.pvsstudio&lt;/groupId&gt; &lt;artifactId&gt;pvsstudio-maven-plugin&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">0.1</span></span>&lt;/version&gt; &lt;configuration&gt; &lt;analyzer&gt; &lt;outputFile&gt;path/to/output.json&lt;/outputFile&gt; .... &lt;/analyzer&gt; &lt;/configuration&gt; &lt;/plugin&gt;</code> </pre> <br>  Danach erh√§lt das Plugin unabh√§ngig die Projektstruktur und startet die Analyse. <br><br>  Zus√§tzlich haben wir ein Prototyp-Plugin f√ºr IntelliJ IDEA entwickelt. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/383/e20/908/383e209083b59831ec5cb84945704752.png" alt="Bild 1"></div><br>  Dieses Plugin funktioniert auch in Android Studio. <br><br>  Ein Plugin f√ºr Eclipse befindet sich derzeit in der Entwicklung. <br><br><h2>  Inkrementelle Analyse </h2><br>  Wir haben einen inkrementellen Analysemodus bereitgestellt, mit dem Sie nur ge√§nderte Dateien √ºberpr√ºfen und dadurch die f√ºr die Code-Analyse erforderliche Zeit erheblich reduzieren k√∂nnen.  Dank dessen k√∂nnen Entwickler die Analyse so oft wie n√∂tig ausf√ºhren. <br><br>  Die inkrementelle Analyse umfasst mehrere Phasen: <br><br><ul><li>  L√∂ffel Metamodell Caching; </li><li>  Wiederaufbau des ge√§nderten Teils des Metamodells; </li><li>  Analyse ge√§nderter Dateien. </li></ul><br><h2>  Unser Testsystem </h2><br>  Um den Java Analyzer an realen Projekten zu testen, haben wir ein spezielles Toolkit geschrieben, mit dem Sie mit der Datenbank offener Projekte arbeiten k√∂nnen.  Es wurde in ^ W Python + Tkinter geschrieben und ist plattform√ºbergreifend. <br><br>  Es funktioniert wie folgt: <br><br><ul><li>  Das Testprojekt einer bestimmten Version wird aus dem Repository auf GitHub heruntergeladen. </li><li>  Das Projekt wird zusammengestellt; </li><li>  Unser Plugin wird zu <i>pom.xml</i> oder <i>build.gradle hinzugef√ºgt</i> (mit git apply); </li><li>  Der statische Analysator wird √ºber das Plugin gestartet. </li><li>  Der resultierende Bericht wird mit dem Benchmark f√ºr dieses Projekt verglichen. </li></ul><br>  Dieser Ansatz stellt sicher, dass durch die √Ñnderung des Analysatorcodes keine guten Antworten verloren gehen.  Unten finden Sie die Benutzeroberfl√§che unseres Testdienstprogramms. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/a8a/3e1/4f3a8a3e1a356cdf4df865d1e3b50417.png" alt="Bild 11"></div><br>  Projekte in Berichten, die vom Standard abweichen, sind rot markiert.  Mit der Schaltfl√§che Genehmigen k√∂nnen Sie die aktuelle Version des Berichts als Referenz speichern. <br><br><h2>  Fehlerbeispiele </h2><br>  Aus Tradition werde ich einige Fehler aus verschiedenen offenen Projekten zitieren, die unser Java-Analysator gefunden hat.  In Zukunft ist geplant, Artikel mit einem detaillierteren Bericht √ºber jedes Projekt zu schreiben. <br><br><h3>  Projekt im Ruhezustand </h3><br>  <b>PVS-Studio Warnung:</b> V6009 Funktion 'gleich' empf√§ngt ungerade Argumente.  √úberpr√ºfen Sie die Argumente: dies, 1. PurchaseRecord.java 57 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  In diesem Code vergleicht die <i>equals ()</i> -Methode das <i>purchaseSequence-</i> Objekt mit sich selbst.  H√∂chstwahrscheinlich ist dies ein Tippfehler und auf der rechten Seite sollte das sein. <i>PurchaseSequence</i> , nicht <i>PurchaseSequence</i> . <br><br>  <b>PVS-Studio Warnung:</b> V6009 Funktion 'gleich' empf√§ngt ungerade Argumente.  √úberpr√ºfen Sie die Argumente: this, 1. ListHashcodeChangeTest.java 232 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeBook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( Iterator&lt;Book&gt; it = books.iterator(); it.hasNext(); ) { Book book = it.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( title.equals( title ) ) { it.remove(); } } }</code> </pre> <br>  Eine <i>Operation</i> √§hnlich der vorherigen - rechts sollte <i>book.title sein</i> , nicht <i>title</i> . <br><br><h3>  Projektstock </h3><br>  <b>PVS-Studio-</b> Warnung <b>:</b> V6007-Ausdruck 'colOrScalar1.equals ("Column")' ist immer falsch.  GenVectorCode.java 2768 <br><br>  <b>PVS-Studio-</b> Warnung <b>: Der</b> V6007-Ausdruck 'colOrScalar1.equals ("Scalar")' ist immer falsch.  GenVectorCode.java 2774 <br><br>  <b>PVS-Studio-</b> Warnung <b>:</b> V6007-Ausdruck 'colOrScalar1.equals ("Column")' ist immer falsch.  GenVectorCode.java 2785 <br><br><pre> <code class="java hljs">String colOrScalar1 = tdesc[<span class="hljs-number"><span class="hljs-number">4</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Scalar"</span></span>)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Scalar"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) { .... }</code> </pre> <br>  Die Operatoren sind hier eindeutig verwirrt und anstelle von ' <i>||'</i>  verwendet ' <i>&amp;&amp;'</i> . <br><br><h3>  JavaParser-Projekt </h3><br>  <b>PVS-Studio-</b> Warnung <b>:</b> V6001 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke 'tokenRange.getBegin (). GetRange (). IsPresent ()'.  Node.java 213 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTokenRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TokenRange tokenRange)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tokenRange = tokenRange; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tokenRange == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !(tokenRange.getBegin().getRange().isPresent() &amp;&amp; tokenRange.getBegin().getRange().isPresent())) { range = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { range = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Range( tokenRange.getBegin().getRange().get().begin, tokenRange.getEnd().getRange().get().end); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  Der Analysator stellte fest, dass sich die gleichen Ausdr√ºcke links und rechts vom Operator <i>&amp;&amp; befinden</i> (w√§hrend alle Methoden in der Aufrufkette sauber sind).  Im zweiten Fall muss h√∂chstwahrscheinlich <i>tokenRange.getEnd ()</i> und nicht <i>tokenRange.getBegin () verwendet werden</i> . <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6016 Verd√§chtiger Zugriff auf das Element des Objekts 'typeDeclaration.getTypeParameters ()' durch einen konstanten Index innerhalb einer Schleife. </font><font style="vertical-align: inherit;">ResolvedReferenceType.java 265</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isRawType()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;typeDeclaration.getTypeParams().size(); i++) { typeParametersMap.add( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(typeDeclaration.getTypeParams().get(<span class="hljs-number"><span class="hljs-number">0</span></span>), typeParametersValues().get(i))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Analysator hat einen verd√§chtigen Zugriff auf das Sammlungsobjekt an einem konstanten Index innerhalb der Schleife festgestellt. </font><font style="vertical-align: inherit;">M√∂glicherweise liegt ein Fehler in diesem Code vor.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jenkins-Projekt </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warnung </font><b><font style="vertical-align: inherit;">:</font></b><font style="vertical-align: inherit;"> V6007 Ausdruck 'cnt &lt;5' ist immer wahr. </font><font style="vertical-align: inherit;">AbstractProject.java 557</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeBuildWithWorkspace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (R b = getLastBuild(); cnt &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; b ! = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; b = b.getPreviousBuild()) { FilePath ws = b.getWorkspace(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ws != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cnt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde in diesen Code eingef√ºhrt </font><font style="vertical-align: inherit;">, um die Anzahl der Durchg√§nge auf f√ºnf zu begrenzen. Sie hat jedoch vergessen, sie zu erh√∂hen, wodurch die Pr√ºfung unbrauchbar wird.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spark-Projekt </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warnung </font><b><font style="vertical-align: inherit;">:</font></b><font style="vertical-align: inherit;"> V6007-Ausdruck 'sparkApplications! = Null' ist immer wahr. </font><font style="vertical-align: inherit;">SparkFilter.java 127</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringUtils.isNotBlank(applications)) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String[] sparkApplications = applications.split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sparkApplications != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; sparkApplications.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die √úberpr√ºfung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Split-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode zur√ºckgegebenen Ergebnisses </font><font style="vertical-align: inherit;">auf </font><i><font style="vertical-align: inherit;">Null</font></i><font style="vertical-align: inherit;"> ist bedeutungslos, da diese Methode immer eine Sammlung zur√ºckgibt und niemals </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur√ºckgibt </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√∂ffelprojekt </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6001 Es gibt identische Unterausdr√ºcke '! M.getSimpleName (). StartsWith ("set")' links und rechts vom Operator '&amp;&amp;'. </font><font style="vertical-align: inherit;">SpoonTestHelpers.java 108</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m.getSimpleName().startsWith(<span class="hljs-string"><span class="hljs-string">"set"</span></span>) &amp;&amp; !m.getSimpleName().startsWith(<span class="hljs-string"><span class="hljs-string">"set"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Code befinden sich dieselben Ausdr√ºcke links und rechts vom Operator &amp;&amp; (alle Methoden in der Aufrufkette sind sauber). </font><font style="vertical-align: inherit;">H√∂chstwahrscheinlich enth√§lt der Code einen logischen Fehler. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warnung </font><b><font style="vertical-align: inherit;">:</font></b><font style="vertical-align: inherit;"> V6007 Der Ausdruck 'idxOfScopeBoundTypeParam&gt; = 0' ist immer wahr. </font><font style="vertical-align: inherit;">MethodTypingContext.java 243</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isSameMethodFormalTypeParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idxOfScopeBoundTypeParam = getIndexOfTypeParam(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idxOfScopeBoundTypeParam &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int idxOfSuperBoundTypeParam = getIndexOfTypeParam(....); if (idxOfScopeBoundTypeParam &gt;= 0) { // &lt;= return idxOfScopeBoundTypeParam == idxOfSuperBoundTypeParam; } } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier versiegelten sie die zweite Bedingung und </font><font style="vertical-align: inherit;">schrieben </font><font style="vertical-align: inherit;">anstelle von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idxOfSuperBoundTypeParam </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idxOfScopeBoundTypeParam</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fr√ºhlingssicherheitsprojekt </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6001 Links und rechts vom '||' befinden sich identische Unterausdr√ºcke. </font><font style="vertical-align: inherit;">Betreiber. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 38, 39. AnyRequestMatcher.java 38</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"deprecation"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AnyRequestMatcher || obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> security.web.util.matcher.AnyRequestMatcher; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Operation √§hnelt der vorherigen - hier wird der Name derselben Klasse unterschiedlich geschrieben. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6006 Das Objekt wurde erstellt, wird jedoch nicht verwendet. </font><font style="vertical-align: inherit;">Das Schl√ºsselwort 'throw' k√∂nnte fehlen. </font><font style="vertical-align: inherit;">DigestAuthenticationFilter.java 434</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!expectedNonceSignature.equals(nonceTokens[<span class="hljs-number"><span class="hljs-number">1</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BadCredentialsException( DigestAuthenticationFilter.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.messages .getMessage(<span class="hljs-string"><span class="hljs-string">"DigestAuthenticationFilter.nonceCompromised"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[] { nonceAsPlainText }, <span class="hljs-string"><span class="hljs-string">"Nonce token compromised {0}"</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Code haben sie vergessen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vor der Ausnahme </font><font style="vertical-align: inherit;">einen </font><i><font style="vertical-align: inherit;">Wurf</font></i><font style="vertical-align: inherit;"> hinzuzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infolgedessen wird das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BadCredentialsException-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausnahmeobjekt </font><i><font style="vertical-align: inherit;">ausgel√∂st</font></i><font style="vertical-align: inherit;"> , aber in keiner Weise verwendet, d. H. </font><font style="vertical-align: inherit;">Eine Ausnahme wird nicht ausgel√∂st. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6030 Die Methode rechts neben dem '|' </font><font style="vertical-align: inherit;">Operatoren werden unabh√§ngig vom Wert des linken Operanden aufgerufen. </font><font style="vertical-align: inherit;">Vielleicht ist es besser, '||' zu verwenden. </font><font style="vertical-align: inherit;">RedirectUrlBuilder.java 38</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setScheme</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String scheme)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-string"><span class="hljs-string">"http"</span></span>.equals(scheme) | <span class="hljs-string"><span class="hljs-string">"https"</span></span>.equals(scheme))) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme = scheme; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Code wird die Verwendung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ungerechtfertigt, da bei der Verwendung die rechte Seite berechnet wird, auch wenn die linke Seite bereits wahr ist. </font><font style="vertical-align: inherit;">In diesem Fall macht dies keinen praktischen Sinn, daher der Bediener </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es lohnt sich durch </font><i><font style="vertical-align: inherit;">||</font></i><font style="vertical-align: inherit;"> zu ersetzen</font></font><i><font style="vertical-align: inherit;"></font></i>  . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IntelliJ IDEA-Projekt </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6008 M√∂gliche Null-Dereferenzierung von 'Editor'. </font><font style="vertical-align: inherit;">IntroduceVariableBase.java:609</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PsiElement nameSuggestionContext = editor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : file.findElementAt(...); <span class="hljs-comment"><span class="hljs-comment">// &lt;= final RefactoringSupportProvider supportProvider = LanguageRefactoringSupport.INSTANCE.forLanguage(...); final boolean isInplaceAvailableOnDataContext = supportProvider != null &amp;&amp; editor.getSettings().isVariableInplaceRenameEnabled() &amp;&amp; // &lt;= ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Analysator hat festgestellt, dass in diesem Code eine Dereferenzierung des Nullzeigers des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editors</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auftreten kann </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es lohnt sich, einen zus√§tzlichen Scheck hinzuzuf√ºgen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warnung:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V6007 Ausdruck ist immer falsch. </font><font style="vertical-align: inherit;">RefResolveServiceImpl.java:814</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull VirtualFile file)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> &amp; !myProjectFileIndex.isUnderSourceRootOfType(....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es f√§llt mir schwer zu sagen, was der Autor vorhatte, aber ein solcher Code sieht sehr verd√§chtig aus. </font><font style="vertical-align: inherit;">Auch wenn hier pl√∂tzlich kein Fehler mehr auftritt, lohnt es sich, diesen Ort neu zu schreiben, um den Analysator und andere Programmierer nicht zu verwirren. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warnung </font><b><font style="vertical-align: inherit;">:</font></b><font style="vertical-align: inherit;"> V6007 Ausdruck 'Ergebnis [0]' ist immer falsch. </font><font style="vertical-align: inherit;">CopyClassesHandler.java:298</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[] {<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Runnable command = () -&gt; { PsiDirectory target; if (targetDirectory instanceof PsiDirectory) { target = (PsiDirectory)targetDirectory; } else { target = WriteAction.compute(() -&gt; ((MoveDestination)targetDirectory).getTargetDirectory( defaultTargetDirectory)); } try { Collection&lt;PsiFile&gt; files = doCopyClasses(classes, map, copyClassName, target, project); if (files != null) { if (openInEditor) { for (PsiFile file : files) { CopyHandler.updateSelectionInActiveProjectView( file, project, selectInActivePanel); } EditorHelper.openFilesInEditor( files.toArray(PsiFile.EMPTY_ARRAY)); } } } catch (IncorrectOperationException ex) { Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message("error.title"), Messages.getErrorIcon()); } }; CommandProcessor processor = CommandProcessor.getInstance(); processor.executeCommand(project, command, commandName, null); if (result[0]) { // &lt;= ToolWindowManager.getInstance(project).invokeLater(() -&gt; ToolWindowManager.getInstance(project) .activateEditorComponent()); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich vermute, dass sie hier vergessen haben, den Wert im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> irgendwie zu √§ndern </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aus diesem Grund meldet der Analysator, dass die √úberpr√ºfung, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ob (Ergebnis [0])</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sinnlos ist.</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Java-Richtung ist sehr vielseitig - sie ist Desktop, Android, Web und vieles mehr, sodass wir viel Raum f√ºr Aktivit√§ten haben. </font><font style="vertical-align: inherit;">Zun√§chst werden wir nat√ºrlich die Bereiche entwickeln, die am gefragtesten sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind unsere Pl√§ne f√ºr die nahe Zukunft:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausgabeanmerkungen basierend auf Bytecode; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integration in Projekte auf Ant (jemand anderes nutzt es 2018?); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plugin f√ºr Eclipse (in Entwicklung); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Noch mehr Diagnosen und Anmerkungen; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbesserung des Datenflussmechanismus. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich empfehle auch diejenigen, die am Testen der Alpha-Version unseres Java-Analysators teilnehmen m√∂chten, sobald diese verf√ºgbar ist. </font><font style="vertical-align: inherit;">Schreiben Sie uns dazu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Unterst√ºtzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir werden Ihren Kontakt zur Liste hinzuf√ºgen und Ihnen schreiben, wenn wir die erste Alpha-Version vorbereiten.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Egor Bredikhin. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwicklung eines neuen statischen Analysators:</font></font></a> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haben Sie den Artikel gelesen und eine Frage?</font></font></b> <div class="spoiler_text">          .      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">      PVS-Studio,  2015</a> . ,   . </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414669/">https://habr.com/ru/post/de414669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414655/index.html">Virtueller Router DD-WRT x86 auf VirtualBox</a></li>
<li><a href="../de414657/index.html">Gef√§hrliches AMF3-Protokoll</a></li>
<li><a href="../de414661/index.html">Die Tr√§gerrakete Sojus-5SL wird mit sowjetischen Motoren arbeiten</a></li>
<li><a href="../de414663/index.html">Professioneller Burnout: ein Wort an Experten</a></li>
<li><a href="../de414667/index.html">[Mini-Fan-Thema] FIFA-Meisterschaftstabelle im Terminal</a></li>
<li><a href="../de414673/index.html">Nicht mehr Abibas: Chinas technologisches Wunder</a></li>
<li><a href="../de414675/index.html">IT Manager Karriere: Von der Kommandozeile zur Teamarbeit</a></li>
<li><a href="../de414677/index.html">Siri-Schnellbefehle</a></li>
<li><a href="../de414679/index.html">Box-shadow.css</a></li>
<li><a href="../de414683/index.html">Die Geschichte der Erstellung einer mobilen Anwendung f√ºr Kinder, mit der Sie mit Ihrem Verstand Geld verdienen k√∂nnen. Fortsetzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>