<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèΩ üçØ ü§ñ Partie 1. QInst: il vaut mieux perdre une journ√©e, puis voler en cinq minutes (√©crire des instruments est trivial) üé≥ üåñ üéõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la partie pr√©c√©dente, j'ai d√©crit en gros comment vous pouvez charger des fonctions eBPF √† partir d'un fichier ELF. Il est maintenant temps de pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Partie 1. QInst: il vaut mieux perdre une journ√©e, puis voler en cinq minutes (√©crire des instruments est trivial)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452608/"><p>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie pr√©c√©dente,</a> j'ai d√©crit en gros comment vous pouvez charger des fonctions eBPF √† partir d'un fichier ELF.  Il est maintenant temps de passer de la fantaisie aux dessins anim√©s sovi√©tiques, et en suivant de sages conseils, apr√®s avoir d√©pens√© une certaine quantit√© d'efforts une fois, faites un outil d'instrumentation universel <del>  <em>(ou, en bref, UII !!!)</em> </del>  .  Ce faisant, je profiterai de la conception anti-mod√®le Golden Hammer et construirai un outil √† partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QEMU</a> relativement famili√®re.  En prime, nous obtenons une instrumentation trans-architecturale, ainsi qu'une instrumentation au niveau de l'ensemble de l'ordinateur virtuel.  L'instrumentation sera de la forme ¬´un petit fichier natif + un petit fichier .o avec eBPF¬ª.  Dans ce cas, les fonctions eBPF seront substitu√©es avant les instructions correspondantes de la repr√©sentation interne de QEMU avant optimisation et g√©n√©ration de code. </p><br><p>  En cons√©quence, l'instrumentation elle-m√™me, qui est <strong>ajout√©e lors de la g√©n√©ration de code</strong> (c'est-√†-dire sans compter quelques kilo-octets de temps d'ex√©cution syst√®me normal), ressemble √† ceci, et ce n'est <strong>pas un</strong> pseudo-code: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Eh bien, il est temps de charger notre elfe dans la matrice.  Eh bien, comment t√©l√©charger, plut√¥t <del>  claquer </del>  pulv√©risation. </p><a name="habracut"></a><br><p>  Comme d√©j√† mentionn√© dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur QEMU.js</a> , l'un des modes de fonctionnement QEMU est la g√©n√©ration JIT de code machine h√¥te √† partir de l'invit√© (potentiellement, pour une architecture compl√®tement diff√©rente).  Si la derni√®re fois que j'ai impl√©ment√© mon backend de g√©n√©ration de code, cette fois, je vais traiter la repr√©sentation interne en la pla√ßant juste devant l'optimiseur.  Est-ce une d√©cision arbitraire?  Non.  Il y a un espoir que l'optimiseur coupe les coins exc√©dentaires, √©limine les variables inutiles, etc.  Pour autant que je sache, il fait en fait des choses simples et rapidement r√©alisables: pousser des constantes, lancer des expressions comme ¬´x: = x + 0¬ª et supprimer du code inaccessible.  Et nous pouvons en obtenir une quantit√© d√©cente. </p><br><h1 id="konfiguraciya-sborochnyh-skriptov">  Configuration du script d'assemblage </h1><br><p>  Tout d'abord, ajoutons nos fichiers sources: <code>tcg/bpf-loader.c</code> et <code>tcg/instrument.c</code> aux Makefiles.  D'une mani√®re g√©n√©rale, il y a un d√©sir de pousser un jour cela en amont, vous devrez donc le faire √† la fin avec sagesse, mais pour l'instant je vais simplement ajouter ces fichiers √† l'assemblage sans condition.  Et je prendrai les param√®tres dans les meilleures traditions de l'AFL - √† travers les variables d'environnement.  Soit dit en passant, je vais tester √† nouveau cela sur l'instrumentation pour AFL. </p><br><p>  Cherchez juste la mention du "voisin" - le fichier <code>optimize.c</code> avec <code>grep -R</code> et nous ne trouverons rien.  Parce qu'il √©tait n√©cessaire de rechercher <code>optimize.o</code> : </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/Makefile.target +++ b/Makefile.target @@ -110,7 +110,7 @@ obj-y += trace/ obj-y += exec.o obj-y += accel/ obj-$(CONFIG_TCG) += tcg/tcg.o tcg/tcg-op.o tcg/tcg-op-vec.o tcg/tcg-op-gvec.o -obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o +obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o tcg/instrument.o tcg/bpf-loader.o obj-$(CONFIG_TCG_INTERPRETER) += tcg/tci.o obj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o obj-$(CONFIG_TCG) += fpu/softfloat.o</span></span></code> </pre> <br><h1 id="tak-vot-ty-kakoe-metaprogrammirovanie-na-c">  Alors voil√†, m√©taprogrammation en C ... </h1><br><p>  Tout d'abord, ajoutons <code>bpf-loader.c</code> de la derni√®re s√©rie avec un code qui extrait les points d'entr√©e correspondant aux op√©rations QEMU.  Et le myst√©rieux fichier <code>tcg-opc.h</code> nous y aidera.  Cela ressemble √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * DEF(name, oargs, iargs, cargs, flags) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* predefined ops */</span></span> DEF(discard, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TCG_OPF_NOT_PRESENT) DEF(set_label, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT) <span class="hljs-comment"><span class="hljs-comment">/* variable number of parameters */</span></span> DEF(call, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, TCG_OPF_CALL_CLOBBER | TCG_OPF_NOT_PRESENT) DEF(br, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END) <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Quelle absurdit√©?  Et le fait est simplement qu'il n'est pas connect√© dans l'en-t√™te source - vous devez d√©finir la macro <code>DEF</code> , inclure ce fichier et supprimer imm√©diatement la macro.  Vous voyez, il n'a m√™me pas de garde. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *inst_function_names[] = { #define DEF(name, a, b, c, d) stringify(inst_qemu_##name), #include <span class="hljs-string"><span class="hljs-string">"tcg-opc.h"</span></span> #undef DEF <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre> <br><p>  En cons√©quence, nous obtenons un tableau soign√© de noms de fonctions cibles, index√©s par des opcodes et se terminant par NULL, que nous pouvons ex√©cuter pour chaque caract√®re du fichier.  Je comprends que ce n'est pas efficace.  Mais c'est simple, ce qui est important, √©tant donn√© le caract√®re ponctuel de cette op√©ration.  Ensuite, nous sautons juste tous les personnages pour lesquels </p><br><pre> <code class="cpp hljs">ELF64_ST_BIND(sym-&gt;st_info) == STB_LOCAL || ELF64_ST_TYPE(sym-&gt;st_info) != STT_FUNC</code> </pre> <br><p>  Le reste est v√©rifi√© par rapport √† la liste. </p><br><h1 id="privyazyvaemsya-k-potoku-vypolneniya">  Nous sommes attach√©s √† un flux d'ex√©cution </h1><br><p>  Maintenant, vous devez vous lever quelque part sur le flux du m√©canisme de g√©n√©ration de code et attendre que l'instruction d'int√©r√™t passe.  Mais vous devez d'abord d√©finir vos fonctions <code>instrumentation_init</code> , <code>tcg_instrument</code> et <code>instrumentation_shutdown</code> dans le <code>tcg/tcg.h</code> et noter leurs appels: initialisation - une fois le backend initialis√©, instrumentation - juste avant l'appel <code>tcg_optimize</code> .  Il semblerait que <code>instrumentation_shutdown</code> puisse √™tre accroch√© dans <code>instrumentation_init</code> sur <code>atexit</code> et ne pas <code>atexit</code> en fl√®che.  Je le pensais aussi, et tr√®s probablement, cela fonctionnera en mode d'√©mulation syst√®me complet, mais en mode d'√©mulation en mode utilisateur QEMU traduit les <code>exit_group</code> syst√®me <code>exit_group</code> et parfois <code>_exit</code> dans l' <code>_exit</code> fonction <code>_exit</code> , qui ignore tous ces gestionnaires atexit, par cons√©quent, nous allons le rechercher dans <code>linux-user/syscall.c</code> et <code>linux-user/syscall.c</code> appel √† notre code devant lui. </p><br><h1 id="interpretiruem-baytkod">  Interpr√©ter le Bytecode </h1><br><p>  Il est donc temps de lire ce que le compilateur a g√©n√©r√© pour nous.  Ceci est commod√©ment fait en utilisant <code>llvm-objdump</code> avec l'option <code>-x</code> , ou mieux, imm√©diatement <code>-d -t -r</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Exemple de sortie</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./compile-bpf.sh test-bpf.o: file format ELF64-BPF Disassembly of section .text: 0000000000000000 inst_brcond_i64: 0: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000000: R_BPF_64_64 prev 2: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 3: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 4: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 5: af 13 00 00 00 00 00 00 r3 ^= r1 6: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 7: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 0000000000000038: R_BPF_64_64 __afl_area_ptr 9: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 10: 0f 34 00 00 00 00 00 00 r4 += r3 11: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 12: 07 03 00 00 01 00 00 00 r3 += 1 13: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 14: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 15: 95 00 00 00 00 00 00 00 exit 0000000000000080 inst_brcond_i32: 16: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000080: R_BPF_64_64 prev 18: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 19: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 20: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 21: af 13 00 00 00 00 00 00 r3 ^= r1 22: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 23: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 00000000000000b8: R_BPF_64_64 __afl_area_ptr 25: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 26: 0f 34 00 00 00 00 00 00 r4 += r3 27: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 28: 07 03 00 00 01 00 00 00 r3 += 1 29: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 30: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 31: 95 00 00 00 00 00 00 00 exit SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 test-bpf.c 0000000000000000 ld .text 00000000 .text 0000000000000000 *UND* 00000000 __afl_area_ptr 0000000000000080 g F .text 00000080 inst_brcond_i32 0000000000000000 g F .text 00000080 inst_brcond_i64 0000000000000008 g O *COM* 00000008 prev</code> </pre> </div></div><br><p>  Si vous essayez de chercher une description des opcodes eBPF, il s'av√®re que dans des endroits √©vidents (source et pages de manuel du noyau Linux), il y a des descriptions de la fa√ßon de l'utiliser, de la compilation, etc.  Ensuite, vous tombez sur la <a href="">page d'</a> √©quipe de l'outil iovisor avec une r√©f√©rence eBPF non officielle pratique. </p><br><p>  L'instruction occupe un mot de 64 bits (environ deux) et a la forme </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> src:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> imm; };</code> </pre> <br><p>  Ceux qui occupent deux mots se composent simplement de la premi√®re instruction avec toute la logique et d'une ¬´bande-annonce¬ª avec 32 bits de plus de valeur imm√©diate et sont tr√®s clairement visibles sur le d√©sassembleur objdump. </p><br><p>  Les opcodes eux-m√™mes ont √©galement une structure r√©guli√®re: les trois bits inf√©rieurs sont la classe d'op√©ration: ALU 32 bits, ALU 64 bits, chargement / stockage, branchement conditionnel.  Par cons√©quent, il est tr√®s pratique de les impl√©menter sur des macros dans les meilleures traditions de QEMU.  Je ne conduirai pas d'instructions d√©taill√©es sur la base de code <del>  nous ne sommes pas en r√©vision de code </del>  Je ferais mieux de vous parler des pi√®ges. </p><br><p>  Mon premier probl√®me √©tait que j'ai cr√©√© un allocateur de registre eBPF paresseux sous la forme de QEMU- <code>local_temp</code> , et <code>local_temp</code> commenc√© √† transf√©rer sans <code>local_temp</code> l'appel de cette fonction √† la macro.  Il s'est av√©r√© comme dans un meme c√©l√®bre: "Nous avons ins√©r√© une abstraction dans une abstraction afin que vous puissiez g√©n√©rer une instruction pendant que vous g√©n√©rez une instruction."  Post factum, je ne comprends d√©j√† pas tr√®s bien ce qui a √©t√© cass√© √† l'√©poque, mais quelque chose d'√©trange se passait apparemment avec l'ordre des instructions g√©n√©r√©es.  Apr√®s cela, j'ai cr√©√© des analogues de fonction <code>tcg_gen_...</code> pour pousser de nouvelles instructions au milieu de la liste, en prenant les op√©randes comme arguments de fonction, et l'ordre est automatiquement devenu comme il se doit (car les arguments sont enti√®rement calcul√©s exactement une fois avant l'appel). </p><br><p>  Le deuxi√®me probl√®me essayait de pousser la const TCG comme l'op√©rande d'une instruction arbitraire en regardant l'op√©rande imm√©diat dans eBPF.  Invitant le <code>tcg-opc.h</code> d√©j√† mentionn√©, la composition de la liste d'arguments de l'op√©ration est strictement fixe: <code>n</code> arguments d'entr√©e, <code>m</code> sortie et <code>k</code> constante.  Par ailleurs, lors du d√©bogage d'un tel code, il est utile de passer √† QEMU l'argument de ligne de commande <code>-d op,op_opt</code> ou m√™me <code>-d op,op_opt,out_asm</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Arguments possibles</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./x86_64-linux-user/qemu-x86_64 -d help Log items (comma separated): out_asm show generated host assembly code for each compiled TB in_asm show target assembly code for each compiled TB op show micro ops for each compiled TB op_opt show micro ops after optimization op_ind show micro ops before indirect lowering int show interrupts/exceptions in short format exec show trace before each executed TB (lots of logs) cpu show CPU registers before entering a TB (lots of logs) fpu include FPU registers in the 'cpu' logging mmu log MMU-related activities pcall x86 only: show protected mode far calls/returns/exceptions cpu_reset show CPU state before CPU resets unimp log unimplemented functionality guest_errors log when the guest OS does something invalid (eg accessing a non-existent register) page dump pages at beginning of user mode emulation nochain do not chain compiled TBs so that "exec" and "cpu" show complete traces trace:PATTERN enable trace events Use "-d trace:help" to get a list of trace events.</code> </pre> </div></div><br><p>  Eh bien, ne r√©p√©tez pas mes erreurs: le d√©sassembleur d'instructions internes est assez avanc√©, et si vous voyez quelque chose comme <code>add_i64 loc15,loc15,$554412123213</code> , alors cette chose apr√®s le signe dollar n'est pas un pointeur.  Plus pr√©cis√©ment, il s'agit bien s√ªr d'un pointeur, mais peut-√™tre accroch√© avec des drapeaux et dans le r√¥le de la valeur litt√©rale de l'op√©rande, et non du pointeur.  Tout cela s'applique, bien s√ªr, si vous savez qu'il devrait y avoir un certain nombre sp√©cifique, comme <code>$0</code> <code>$ff</code> ou <code>$ff</code> , vous n'avez pas du tout √† avoir peur des pointeurs.  :) Comment faire <code>movi</code> √† cela - il vous suffit de cr√©er une fonction qui renvoie une nouvelle <code>temp</code> , dans laquelle, √† travers <code>movi</code> met la constante souhait√©e. </p><br><p>  Soit dit en passant, si vous commentez <code>#define USE_TCG_OPTIMIZATIONS</code> dans l'en <code>tcg/tcg.c</code> <code>#define USE_TCG_OPTIMIZATIONS</code> <code>tcg/tcg.c</code> , puis, soudainement, l'optimisation sera d√©sactiv√©e et il sera plus facile d'analyser les transformations de code. </p><br><p>  Pour sim, j'enverrai un lecteur int√©ress√© √† choisir QEMU dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> , m√™me officielle!  Pour le reste, je ferai la d√©monstration de l'instrumentation promise pour AFL. </p><br><h1 id="te-zhe-i-krolik">  Le m√™me et le lapin </h1><br><p>  Pour le texte int√©gral de l'ex√©cution, j'enverrai √† nouveau le lecteur au r√©f√©rentiel, car il (le texte) n'a pas de valeur artistique et est honn√™tement durci √† partir de <code>qemu_mode</code> de la livraison AFL, et en g√©n√©ral, est un morceau r√©gulier de code C. Mais voici √† quoi ressemble l'instrumentation elle-m√™me : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Il est important que les fonctions de hook aient autant d'arguments que d' <code>iargs</code> pour l'op√©ration QEMU correspondante.  Deux <code>extern</code> dans l'en-t√™te seront li√©s √† l'ex√©cution pendant le processus de relocalisation.  En principe, <code>prev</code> pourrait √™tre d√©fini ici, mais il doit ensuite √™tre d√©fini comme <code>static</code> , sinon il tombera dans la section COMMUN que je ne supporte pas.  En fait, nous avons en fait simplement r√©√©crit le pseudo-code de la documentation, mais ici il est lisible par machine! </p><br><p>  Pour v√©rifier, cr√©ez le fichier <code>bug.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { char buf[16]; int res = read(0, buf, 4); if (buf[0] == 'T' &amp;&amp; buf[1] == 'E' &amp;&amp; buf[2] == 'S' &amp;&amp; buf[3] == 'T') abort(); return res * 0; }</span></span></span></span></code> </pre> <br><p>  Et aussi - fichier <code>forksrv</code> , qui est pratique pour alimenter AFL: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash export NATIVE_INST=./instrumentation-examples/afl/afl-native.so export BPF_INST=./instrumentation-examples/afl/afl-bpf.co exec ./x86_64-linux-user/qemu-x86_64 ./instrumentation-examples/afl/bug</span></span></code> </pre> <br><p>  Et lancez le fuzzing: </p><br><pre> <code class="bash hljs">AFL_SKIP_BIN_CHECK=1 afl-fuzz -i ../input -o ../output -m none -- ./forksrv</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">American Fuzzy Lop</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1234 T234 TE34 TES4 TEST &lt;-     crashes,    2200  </code> </pre> </div></div><br><p>  Jusqu'√† pr√©sent, la vitesse n'est pas si √©lev√©e, mais comme excuse, je dirai qu'ici (pour l'instant) une caract√©ristique importante du <code>qemu_mode</code> original <code>qemu_mode</code> pas utilis√©e: l'envoi d'adresses de code ex√©cutable au serveur fork.  Mais il n'y a rien d'AFL dans la base de code QEMU maintenant, et il y a un espoir que cette instrumentation g√©n√©ralis√©e soit un jour entass√©e en amont. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projet GitHub</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452608/">https://habr.com/ru/post/fr452608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452592/index.html">Partie 0. N√©cessite un elfe pour travailler dans la matrice. La r√©installation est possible</a></li>
<li><a href="../fr452596/index.html">735 000 adresses IPv4 ont √©t√© prises par un escroc et renvoy√©es au registre</a></li>
<li><a href="../fr452598/index.html">Management d'une √©quipe de programmeurs: comment et comment les motiver correctement? Premi√®re partie</a></li>
<li><a href="../fr452602/index.html">Cisco Hyperflex pour les syst√®mes de gestion de bases de donn√©es √† charge √©lev√©e</a></li>
<li><a href="../fr452606/index.html">UDB. Qu'est-ce que c'est? Partie 8. Adressage UDB</a></li>
<li><a href="../fr452610/index.html">Aide et demande pour elle. Article sur la s√©curit√© des informations pour les utilisateurs ordinaires</a></li>
<li><a href="../fr452612/index.html">Apprentissage automatique renforc√© des r√©seaux de neurones profonds sur tensorflow.js: Astuces</a></li>
<li><a href="../fr452614/index.html">Comment d√©marrer la programmation dans Adobe Illustrator. Deuxi√®me partie</a></li>
<li><a href="../fr452618/index.html">Ce qui a √©t√© dit sur Google I / O 2019: Android 10, AR-applications et bien plus encore</a></li>
<li><a href="../fr452620/index.html">D√©rivation d'un type d'action √† l'aide de Typescript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>