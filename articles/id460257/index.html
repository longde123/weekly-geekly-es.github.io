<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🚒 🏜️ 🚴🏼 Halo Dunia! Perendaman dalam di Terminal ◻️ 🔱 👩🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya terinspirasi untuk menulis artikel ini oleh sebuah artikel tentang analisis Sishny printf . Namun, ada yang terlewatkan sesaat ke arah mana data ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Halo Dunia! Perendaman dalam di Terminal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460257/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ha/5f/0v/ha5f0vjiijc9c92bnnt56z7jcpg.jpeg"></a> </p><br><p>  Saya terinspirasi untuk menulis artikel ini oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel tentang analisis Sishny printf</a> .  Namun, ada yang terlewatkan sesaat ke arah mana data berjalan setelah memasuki perangkat terminal.  Pada artikel ini saya ingin memperbaiki cacat ini dan menganalisis jalur data di terminal.  Kami juga akan mencari tahu bagaimana Terminal berbeda dari Shell, apa Pseudoterminal itu, bagaimana emulator terminal bekerja, dan banyak lagi. </p><a name="habracut"></a><br><h2 id="osnovy">  Dasar-dasarnya </h2><br><p>  Pertama mari kita pahami apa itu Terminal, Shell, Console, bagaimana Terminal Emulator berbeda dari Terminal biasa, dan mengapa namanya demikian.  Cukup banyak informasi yang telah ditulis tentang ini, jadi Anda tidak akan mendengar sesuatu yang baru di sini.  Hampir semua informasi di sini diambil dari Internet, saya akan memberikan tautan di akhir artikel.  Siapa yang sudah tahu apa arti semua hal ini, dapat melewati bagian ini dengan aman. </p><br><hr><br><h3 id="terminal">  Terminal </h3><br><p>  <strong>Terminal</strong> adalah kombinasi tampilan dan keyboard, yaitu perangkat fisik.  Sebelum terminal menjadi kombinasi khusus ini, mereka adalah jenis perangkat yang disebut teleprinter (teletype, teletypewriter atau TTY), yaitu kombinasi printer dan keyboard.  Biasanya, beberapa terminal terhubung ke komputer yang sama.  Dengan demikian, dimungkinkan untuk bekerja untuk beberapa pengguna di komputer yang sama, dan masing-masing memiliki sesi sendiri, terlepas dari yang lain.  Terminal dinamai demikian karena terletak di ujung kabel terminal. </p><br><p>  Ini adalah <strong>Teletype</strong> : </p><br><img src="https://habrastorage.org/webt/m3/_3/yt/m3_3ytmmoofzwgpr3dpu78w8m7i.jpeg" alt="Teletype" title="Teletype" width="430" height="370"><br><br><p>  Dan ini <strong>Terminal</strong> : </p><br><img src="https://habrastorage.org/webt/pz/lj/eu/pzljeumccjvqmrunt-pqolnyx-c.jpeg" alt="Terminal" title="Terminal" width="430" height="370"><br><br><hr><br><h3 id="console">  Konsol </h3><br><p>  <strong>Konsol (konsol)</strong> - terminal yang terhubung langsung ke komputer.  Faktanya adalah bahwa sebagian besar terminal terhubung secara implisit, tetapi setidaknya satu terminal terhubung langsung ke komputer.  Konsol diizinkan untuk menggunakan lingkaran orang yang didefinisikan secara ketat, karena memungkinkan Anda untuk mengkonfigurasi komputer. </p><br><hr><br><h3 id="shell">  Shell </h3><br><p>  Jika dua sebelumnya adalah perangkat fisik, maka definisi ini merujuk secara eksklusif ke perangkat lunak. </p><br><p>  <strong>Shell</strong> adalah penerjemah baris perintah.  Tujuan utamanya adalah menjalankan program lain.  Ada sejumlah besar Kerang berbeda.  Yang paling umum adalah Bash (dari bahasa Inggris Bourne Again SHell, yang, seperti yang disarankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> , adalah permainan kata-kata untuk Shell "Born again", yaitu Shell yang "dihidupkan kembali").  Contoh lain: Dash (Shell ringan, tersedia jika Anda menjalankan biner di / bin / sh), Zsh. </p><br><hr><br><p>  Tentu saja, baik terminal dan konsol tidak bisa tidak menemukan refleksi mereka di zaman modern.  Oleh karena itu, lebih lanjut kami akan mempertimbangkan hal-hal seperti <em>Terminal Emulator</em> dan <em>Virtual Console</em> . </p><br><h3 id="terminal-emulator">  Terminal emulator </h3><br><p>  <strong>Terminal Emulator</strong> - emulator dari terminal lama yang bagus.  Emulator terminal diperlukan untuk program yang tidak dapat berinteraksi langsung dengan Sistem X Window - Bash, Vim, dan lainnya. </p><br><p>  Mari kita pertama-tama menetapkan tanggung jawab terminal: </p><br><ol><li>  Transfer input pengguna ke komputer </li><li>  Pengiriman output komputer ke layar </li></ol><br><p>  Jadi Terminal Emulator kami melakukan hal yang persis sama: itu memberikan input pengguna ke program yang sedang berjalan, dan juga menampilkan output dari program pada layar.  Bagaimanapun, artinya tetap - antara pengguna dan program yang sedang berjalan, ada beberapa jenis lapisan yang bertanggung jawab untuk input / output.  Contoh Emulator Terminal: gnome-terminal, xterm, konsole. </p><br><p>  <strong>Tolong jangan bingung Shell dan Terminal Emulator!</strong> <br>  Terminal Emulator adalah aplikasi GUI, yaitu jendela di Sistem X Window.  Shell adalah interpreter baris perintah, yaitu, hanya pelaksana perintah, tidak memiliki shell grafis.  Berbicara dengan benar, Anda <strong>tidak meluncurkan Bash</strong> , Anda <strong>menjalankan Terminal Emulator, yang meluncurkan Bash di dalamnya</strong> .  Terminal Emulator dan Bash benar-benar 2 program yang berbeda.  Yang pertama bertanggung jawab untuk input / output, yang kedua - untuk memproses perintah. </p><br><p>  Lebih lanjut dalam artikel ini, semua referensi ke terminal akan merujuk ke emulator terminal. </p><br><hr><br><h3 id="virtual-console-virtual-terminal">  Konsol Virtual (Terminal Virtual) </h3><br><p>  Tekan Ctrl + Alt + FN, di mana N biasanya memiliki nilai dari 1 hingga 6. Apa yang baru saja Anda lihat disebut Konsol Virtual (konsol virtual) atau Terminal Virtual (terminal virtual).  Ingat apa yang saya katakan sebelumnya tentang terminal?  Banyak terminal terhubung ke satu komputer dan masing-masing terminal adalah sesi yang terpisah, terpisah dari yang lain.  Konsol Virtual mengulangi gagasan ini: mungkin ada beberapa sesi independen di dalam komputer Anda (namun, sumber daya komputer masih jelas dibagikan). </p><br><p>  Anda dapat memberi nama entitas ini Konsol Virtual dan Terminal Virtual, karena menurut definisi, konsol adalah terminal yang terhubung langsung ke komputer, tetapi semua terminal virtual, dalam arti tertentu, terhubung langsung ke komputer. </p><br><hr><br><h3 id="tty-ustroystva">  Perangkat TTY </h3><br><p>  Setiap terminal diberi <em>perangkat TTY</em> sendiri (perangkat terminal), yang menyediakan konsol.  Meskipun Anda tidak mungkin menemukan teletype, tetapi pengurangan TTY tetap bertahan hingga hari ini. </p><br><p>  Perangkat TTY terdiri dari dua komponen mendasar: </p><br><ol><li>  <strong>Driver perangkat</strong>  Dia bertanggung jawab untuk mengirimkan input keyboard ke program dan untuk menampilkan output program di layar. </li><li>  <strong>Disiplin Garis TTY</strong> (disiplin garis Rusia).  Disiplin garis adalah antarmuka akses driver, yang, bagaimanapun, membawa banyak logika ke perangkat TTY.  Kita dapat mengatakan bahwa disiplin garis proksi panggilan ke pengemudi.  Apa bidang tanggung jawab dari komponen ini, kami akan mencari tahu selama artikel. </li></ol><br><p>  Bangun perangkat TTY: </p><br><p><img src="https://habrastorage.org/webt/zn/zw/dy/znzwdyjadyeidyogqoap8kfvgng.jpeg" title="Bangun perangkat TTY"></p><br><p>  Ada 3 jenis perangkat TTY: </p><br><ol><li>  <em>Perangkat konsol</em> - menyediakan operasi Konsol Virtual.  Input dan output perangkat ini sepenuhnya dikendalikan oleh kernel. </li><li>  <em>Perangkat PTY</em> (pseudo-terminal) - menyediakan operasi terminal di antarmuka jendela.  Input dan output perangkat ini dikendalikan oleh emulator terminal yang beroperasi di ruang pengguna. </li><li>  <em>Serial device</em> - berkomunikasi langsung dengan perangkat keras.  Biasanya tidak digunakan secara langsung, tetapi ada sebagai level terendah dalam organisasi arsitektur perangkat terminal. </li></ol><br><p>  Pada artikel ini, kita akan berbicara secara spesifik tentang tipe kedua perangkat TTY - pseudo-terminal. </p><br><hr><br><h2 id="tty-line-discipline">  Disiplin Garis TTY </h2><br><p>  Kami mulai memeriksa disiplin garis perangkat TTY. </p><br><p>  Fitur penting pertama dari disiplin garis adalah bahwa ia bertanggung jawab untuk memproses I / O.  Ini termasuk, misalnya, memproses karakter kontrol (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="Kontrol karakter">Karakter kontrol</a> ) dan memformat output.  Misalnya, Anda memasukkan teks apa pun, tetapi tiba-tiba Anda menyadari bahwa Anda keliru dalam menulis sesuatu dan ingin menghapusnya - di sinilah disiplin garis berperan. </p><br><p>  Kami akan menganalisis secara terperinci apa yang sebenarnya terjadi ketika kami bekerja di Bash yang berjalan di terminal.  Secara default, perangkat TTY beroperasi dalam mode kanonik dengan <em>gema diaktifkan</em> .  Gema adalah tampilan karakter yang Anda masukkan di layar. </p><br><p> Ketika kita memasukkan, misalnya, karakter <code>a</code> , karakter ini dikirim ke perangkat TTY, tetapi dicegat oleh disiplin garis TTY perangkat.  Dia membaca karakter ke buffer internal, melihat bahwa mode <code>echo</code> aktif, dan menampilkan karakter di layar.  Pada saat ini, tidak ada yang masih tersedia untuk dibaca dalam program di mana perangkat terminal terpasang.  Mari kita tekan <code>backspace</code> pada keyboard.  Simbol <code>^?</code>  sekali lagi dicegat oleh disiplin garis, dan yang terakhir, menyadari bahwa pengguna ingin menghapus karakter yang dimasukkan terakhir, menghapus karakter ini dari buffer internal dan menghapus karakter ini juga dari layar.  Sekarang, jika kita menekan Enter, Disiplin Garis TTY akhirnya mengirim ke buffer baca dari perangkat terminal segala sesuatu yang ditulis sebelumnya ke buffer internal disiplin, termasuk LF.  Pada saat yang sama, karakter CR dan LF ditampilkan di layar untuk memindahkan kursor ke baris baru - ini adalah format dari output. </p><br><p>  Ini adalah cara kerja mode kanonik - ini mentransfer semua karakter yang dimasukkan ke perangkat hanya setelah menekan <code>Enter</code> , memproses karakter kontrol dan memformat output. </p><br><h3 id="tty-line-editing">  Editing Baris TTY </h3><br><p>  <strong>Pengeditan Baris TTY</strong> adalah komponen yang bertanggung jawab untuk memproses input dalam disiplin jalur.  Harus dikatakan bahwa <em>Editing Lini</em> adalah konsep umum dan berkaitan dengan pemrosesan input.  Misalnya, Bash dan Vim memiliki Penyuntingan Baris sendiri. </p><br><p>  Kita dapat mengontrol pengaturan disiplin garis perangkat TTY saat ini menggunakan program <strong>stty</strong> .  Mari kita bereksperimen sedikit. </p><br><p>  Open Bash atau Shell lain dan ketik: </p><br><pre> <code class="plaintext hljs">stty icanon -echo</code> </pre> <br><p>  Sekarang coba ketikkan sesuatu dan Anda tidak akan melihat input Anda (jangan khawatir, Anda masih bisa meneruskan input ke program).  Anda baru saja menonaktifkan gema - yaitu, tampilan karakter yang dimasukkan di layar.  Sekarang masukkan: </p><br><pre> <code class="plaintext hljs">stty raw echo</code> </pre> <br><p>  Coba ketikkan sesuatu.  Anda lihat bagaimana kesimpulannya dipatahkan.  Tetapi untuk efek yang lebih, mari kita masuk ke Dash - type <code>/bin/sh</code> .  Sekarang coba masukkan karakter khusus ( <code>Ctrl</code> + karakter apa saja di keyboard) atau cukup tekan <code>Enter</code> .  Anda bingung - apa saja karakter aneh ini di layar?  Faktanya adalah bahwa, setelah memasuki Shell paling sederhana, selain Pengeditan Garis dari disiplin itu sendiri, kami juga menonaktifkan Pengeditan Garis Bash, dan sekarang kita dapat mengamati dengan kuat dan utama efek dari dimasukkannya mode <em>baku</em> disiplin garis.  Mode ini tidak memproses input sama sekali dan tidak memformat output.  Mengapa mode mentah diperlukan?  Misalnya, untuk <em>Vim</em> : ia membuka ke seluruh jendela terminal dan memproses input itu sendiri, setidaknya sehingga simbol disiplin garis khusus tidak berpotongan dengan simbol khusus Vim itu sendiri. </p><br><p>  Untuk lebih memahami, mari kita lihat mengkustomisasi karakter kontrol.  Perintah <code>stty &lt;control-character&gt; &lt;string&gt;</code> akan membantu kita dengan ini. <br>  Masukkan di Bash: </p><br><pre> <code class="bash hljs">stty erase 0</code> </pre> <br><p>  Sekarang karakter kontrol <code>erase</code> akan ditetapkan ke karakter <code>0</code> .  Tombol <code>backspace</code> biasanya penting <code>^?</code>  , tetapi sekarang karakter khusus ini akan dikirim ke buffer baca PTS secara harfiah - coba sendiri.  Sekarang Anda dapat menghapus karakter menggunakan tombol <code>0</code> pada keyboard, karena Anda sendiri meminta disiplin garis tty untuk mengenali karakter yang dimasukkan sebagai karakter kontrol <code>erase</code> .  Anda dapat mengembalikan pengaturan menggunakan perintah <code>stty erase ^\?</code>  atau hanya menutup terminal, karena kami hanya memengaruhi perangkat tty saat ini. </p><br><p>  Anda dapat menemukan informasi lebih lanjut dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="man stty">man stty</a> . </p><br><hr><br><h2 id="terminal-emulator-i-pseudoterminal">  Terminal Emulator dan Pseudoterminal </h2><br><p>  Setiap kali kita membuka terminal baru di Sistem X Window, Server Terminal GNOME memunculkan proses baru dan meluncurkan program default di dalamnya.  Biasanya, ini semacam Shell (misalnya, Bash). </p><br><p>  Komunikasi dengan program yang berjalan terjadi melalui apa yang disebut <strong>Pseudoterminal</strong> (pseudo-terminal, PTY).  Pseudo-terminal itu sendiri ada di kernel, namun, ia menerima input dari ruang pengguna - dari emulator terminal. </p><br><p>  Terminal pseudo terdiri dari dua <em>perangkat TTY virtual</em> berikut: <br>  1) <strong>PTY master (PTM)</strong> - bagian terkemuka dari pseudo-terminal.  Digunakan oleh Terminal Terminal GNOME untuk mentransfer input keyboard ke program yang berjalan di dalam terminal, serta untuk membaca output program dan menampilkan output.  Server Terminal GNOME, pada gilirannya, berkomunikasi dengan Sistem X Window melalui protokol X. <br>  2) <strong>PTY slave (PTS)</strong> - slave bagian dari pseudo-terminal.  Digunakan oleh program yang berjalan di dalam terminal untuk membaca input keyboard dan menampilkan output di layar.  Setidaknya, program itu sendiri berpikir begitu (saya akan menjelaskan apa artinya ini, sedikit lebih jauh). </p><br><p>  Data apa pun yang direkam dalam perangkat PTS adalah input dari perangkat PTM, sehingga dapat dibaca pada perangkat PTM.  Dan sebaliknya: setiap data yang direkam dalam perangkat PTM adalah input dari perangkat PTS.  Ini adalah bagaimana Terminal Terminal GNOME dan program yang berjalan di dalam terminal berkomunikasi.  Setiap perangkat PTM dikaitkan dengan perangkat PTS-nya sendiri. </p><br><p>  Proses meluncurkan terminal baru terlihat seperti ini: <br>  1) Server Terminal GNOME menciptakan perangkat master dan slave dengan memanggil fungsi open () pada perangkat khusus <strong>/ dev / ptmx</strong> .  Panggilan terbuka () mengembalikan deskriptor file dari perangkat PTM yang dibuat - <em>master_fd</em> . <br>  2) Server Terminal GNOME menciptakan proses baru dengan memanggil <code>fork()</code> .  Proses ini akan menjadi terminal baru. <br>  3) Di terminal PTS, perangkat terbuka pada deskriptor file 0, 1, 2 (masing-masing stdin, stdout dan stderr).  Sekarang, terminal I / O standar mengalir ke perangkat ini. <br>  4) Program yang diinginkan diluncurkan di terminal dengan memanggil fungsi <code>exec()</code> .  Beberapa Shell biasanya dimulai (misalnya, Bash).  Setiap program yang kemudian diluncurkan dari Bash akan memiliki deskriptor file yang sama dengan Bash itu sendiri, yaitu aliran program akan diarahkan ke perangkat PTS. </p><br><p>  Anda dapat melihat sendiri di mana arus keluaran terminal standar diarahkan menggunakan <code>ls -la /proc/self/fd</code> : <br><img src="https://habrastorage.org/webt/nr/dx/97/nrdx97wllflvapnt76p3qqki3fw.jpeg"></p><br><p>  Perangkat PTS terletak di jalur <strong>/ dev / pts / N</strong> , dan jalur ke perangkat PTM sama sekali tidak menarik bagi kami.  Faktanya adalah bahwa Terminal Terminal GNOME sudah memiliki deskriptor file untuk perangkat PTM terbuka dan tidak memerlukan jalur untuk itu, namun, dalam proses anak, kita harus membuka perangkat PTS pada stream output standar dengan memanggil fungsi <code>open()</code> , yang memerlukan path file. </p><br><p>  Ingat, saya mengatakan bahwa program yang menggunakan perangkat PTS hanya berpikir bahwa itu berkomunikasi langsung dengan terminal?  Faktanya adalah bahwa PTS juga merupakan <em>perangkat terminal</em> ( <em>perangkat</em> TTY), tetapi perbedaan antara perangkat PTS dan perangkat TTY yang sebenarnya adalah bahwa perangkat PTS menerima input bukan dari keyboard, tetapi dari perangkat master, dan output tidak ke layar, tetapi ke perangkat master.  Itulah sebabnya terminal semu diberi nama seperti ini - terminal semu hanya meniru (lagi ??) terminal.  Perbedaan antara terminal emulator dan pseudo-terminal adalah bahwa terminal emulator hanyalah sebuah program grafis yang memungkinkan Anda untuk menjalankan terminal langsung di dalam antarmuka jendela, tetapi fitur ini diimplementasikan menggunakan pseudo-terminal. </p><br><p>  Fakta bahwa <em>perangkat PTS adalah perangkat TTY</em> sangat penting.  Inilah alasannya: </p><br><ol><li>  Program tempat perangkat terminal terpasang memiliki semua kemampuan terminal konvensional.  Misalnya: nonaktifkan gema, nonaktifkan / aktifkan tampilan kanonik. </li><li>  Program, mengetahui bahwa perangkat terminal terpasang padanya (dikatakan bahwa program memiliki terminal kontrol), dapat bekerja secara interaktif dan meminta input dari pengguna.  Misalnya, minta nama pengguna dan kata sandi. </li><li>  Ada juga Disiplin Garis TTY, jadi kami memiliki kemampuan untuk memproses karakter kontrol sebelum mereka mencapai program, serta memformat output dari program. </li></ol><br><p>  Perangkat PTM juga merupakan perangkat TTY, tetapi ini tidak memainkan peran apa pun, karena tidak digunakan sebagai terminal kontrol.  Selain itu, disiplin garis perangkat PTM diatur ke mode mentah, oleh karena itu, pemrosesan tidak dilakukan saat mentransfer data dari PTS ke perangkat PTM.  Namun, panggilan untuk <code>read()</code> dan <code>write()</code> dari ruang pengguna masih terlebih dahulu dilayani oleh garis disiplin pada kedua perangkat.  Momen ini akan memainkan peran yang bahkan lebih besar, seperti yang akan kita lihat nanti. </p><br><p>  Proses komunikasi antara Terminal Terminal GNOME dan program yang berjalan di dalam terminal adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/jz/y0/sg/jzy0sg0zjcceaflg6wyg7d5lkti.jpeg" title="Terminal Terminal Proses. GNOME dan program yang berjalan di dalam terminal"></p><br><p>  Penting untuk memeriksa secara lebih rinci peran yang dimainkan disiplin lini dalam berkomunikasi antara kedua bagian dari terminal semu.  Di sini, disiplin garis bertanggung jawab untuk pemrosesan data yang <em>lewat dari PTM ke perangkat PTS</em> , serta untuk pengiriman data dari satu bagian terminal pseudo ke yang lain.  Ketika kami berada di driver perangkat PTS, kami menggunakan disiplin garis perangkat PTM, dan sebaliknya. </p><br><hr><br><h2 id="virtualnye-ustroystva">  Perangkat virtual </h2><br><p>  Anda mungkin berpikir bahwa Anda dapat membuka file di sepanjang path <em>/ dev / pts / N</em> dan menulis atau membaca data darinya, seperti dari file teks biasa?  Ya, semua perangkat pada sistem mirip Unix adalah file, berkat prinsip dasar Unix, yang menyatakan bahwa semuanya adalah file.  Namun, tidak ada file perangkat khusus (Bahasa Inggris - file perangkat) adalah file teks.  Perangkat tersebut disebut <strong>perangkat virtual</strong> - yaitu, mereka ada secara eksklusif di memori, bukan pada disk. </p><br><p>  Jangan mencoba membuka file-file ini sebagai file teks biasa.  Namun, Anda dapat menggunakan perangkat ini melalui operasi <code>write()</code> dan <code>read()</code> , yang panggilannya akan dilayani oleh driver perangkat.  Mari kita coba melakukannya. </p><br><p>  Buka dua terminal windows dan masukkan <code>tty</code> di setiap perintah.  Perintah ini akan menunjukkan perangkat TTY mana yang melayani terminal yang sedang aktif.  Sekarang masukkan <code>echo "Hello, World!" &gt; /dev/pts/N</code>  <code>echo "Hello, World!" &gt; /dev/pts/N</code> di jendela terminal pertama, di mana N adalah indeks PTS dari perangkat jendela kedua, beralih ke jendela kedua dan Anda akan melihat input Anda dari jendela pertama.  Sekarang Anda telah menulis data ke perangkat PTS dari jendela kedua <em>seolah-olah itu dilakukan oleh program yang berjalan di terminal itu</em> . </p><br><p><img src="https://habrastorage.org/webt/nj/3s/rp/nj3srpuzyahyvukzicfr0b5wnja.png"></p><br><hr><br><h2 id="ustroystvo-psevdoterminala">  Perangkat terminal semu </h2><br><p>  Kami semakin dekat dengan bagian akhir artikel, tetapi sebelum itu kita melihat "di balik tudung" Linux - pertimbangkan perangkat terminal pseudo di tingkat kernel.  Akan ada banyak kode, tetapi saya akan mencoba menjelaskan setiap blok kode yang diberikan sedetail mungkin, mengurangi detail yang tidak penting dan masuk berurutan. </p><br><p>  Sebelum Anda mulai, kami memperkenalkan apa yang disebut "keranjang komponen".  Saat kita bergerak di sepanjang inti, kita akan menambah lebih banyak komponen ke dalamnya dan menemukan koneksi di antara mereka.  Saya harap ini membantu Anda lebih memahami perangkat pseudo-terminal.  Mari kita mulai. </p><br><p>  Ketika Linux dimulai, ia memuat driver perangkat yang diperlukan.  Terminal semu kami juga memiliki driver seperti itu.  Pendaftarannya dimulai dengan panggilan ke fungsi ini: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { legacy_pty_init(); unix98_pty_init(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- ,    return 0; } device_initcall(pty_init); // ,      </span></span></code> </pre> <br><p>  Untuk semua sistem modern, fungsi <code>unix98_pty_init()</code> akan dipanggil: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __init unix98_pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 ptm driver"</span></span>); pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 pts driver"</span></span>); ptm_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_master"</span></span>; ptm_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"ptm"</span></span>; ptm_driver-&gt;major = UNIX98_PTY_MASTER_MAJOR; ptm_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;type = TTY_DRIVER_TYPE_PTY; ptm_driver-&gt;subtype = PTY_TYPE_MASTER; ptm_driver-&gt;init_termios = tty_std_termios; ptm_driver-&gt;init_termios.c_iflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_oflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; ptm_driver-&gt;init_termios.c_lflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;other = pts_driver; tty_set_operations(ptm_driver, &amp;ptm_unix98_ops); pts_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_slave"</span></span>; pts_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"pts"</span></span>; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; pts_driver-&gt;init_termios = tty_std_termios; pts_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; pts_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;other = ptm_driver; tty_set_operations(pts_driver, &amp;pty_unix98_ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 ptm driver"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 pts driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Now create the /dev/ptmx special device */</span></span> tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cdev_add(&amp;ptmx_cdev, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) || register_chrdev_region(<span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/ptmx"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register /dev/ptmx driver"</span></span>); device_create(tty_class, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"ptmx"</span></span>);</code> </pre> <br><p>  Di sini kami tertarik pada 3 hal: </p><br><ol><li>  Panggilan <code>tty_set_operatons</code> untuk driver master pty dan perangkat pty slave. </li><li>  Fungsi <code>ptmx_open</code> , yang bertanggung jawab untuk membuat kedua bagian pseudo-terminal ketika membuka perangkat khusus <em>/ dev / ptmx</em> .  Penting: / dev / ptmx bukan perangkat PTM, tetapi hanya sebuah antarmuka untuk membuat pseudo-terminal baru. </li><li>  Daftarkan driver perangkat PTM dan PTS. </li></ol><br><p>  Mari kita mulai: </p><br><h4 id="1-tty_set_operations">  1. operasi tty_set_ </h4><br><p>  Fungsi <strong>tty_set_operations ()</strong> hanya menyiapkan tabel fungsi untuk driver saat ini: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_set_operations(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations *op) { driver-&gt;ops = op; };</code> </pre> <br><p>  Struktur <strong>tty_operations</strong> adalah tabel fungsi yang digunakan untuk mengakses fungsi driver TTY perangkat. </p><br><p>  Saya akan memilih hal yang paling penting dalam struktur <code>pty_unix98_ops</code> dan <code>ptm_unix98_ops</code> , yang merupakan tabel fungsi untuk bagian-bagian terminal pseudo yang sesuai: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }; static const struct tty_operations pty_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, // ... };</span></span></code> </pre> <br><p>  Di sini Anda dapat mengamati fungsi pty_write, <code>pty_write</code> sudah akrab dari artikel di Sishny printf - kami akan kembali lagi nanti. </p><br><p>  Mari tambahkan struktur ini ke keranjang komponen kami: <br><img src="https://habrastorage.org/webt/o8/e-/kc/o8e-kcpqestn7f481gcx38qmzuo.jpeg"></p><br><p>  Seperti yang Anda lihat, metode utama kedua driver sama sekali tidak berbeda.  Omong-omong, perhatikan bahwa tidak ada fungsi untuk operasi read () - tidak ada yang seperti <code>pty_read()</code> .  Faktanya adalah bahwa membaca hanya akan dilayani oleh disiplin garis.  Dengan demikian, kita belajar tentang fitur penting kedua dari disiplin garis - membaca data dari perangkat TTY. </p><br><hr><br><h4 id="2-ptmx_open">  2. ptmx_open </h4><br><p>  Sekarang mari kita beralih ke <strong>ptmx_open ()</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptmx_open(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *filp) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; <span class="hljs-comment"><span class="hljs-comment">//    -   ! fsi = devpts_acquire(filp); //     devpts index = devpts_new_index(fsi); //       /dev/pts // ... tty = tty_init_dev(ptm_driver, index); // ... devpts_pty_new(fsi, index, tty-&gt;link); //     /dev/pts retval = ptm_driver-&gt;ops-&gt;open(tty, filp); //  PTM ,   }</span></span></code> </pre> <br><p>  Kami tertarik pada fungsi <code>tty_init_dev()</code> , di mana argumen pertama adalah driver perangkat PTM, dan yang kedua adalah indeks perangkat.  Di sini kita meninggalkan zona tanggung jawab driver PTY dan pergi ke file, yang hanya bertanggung jawab untuk perangkat TTY umum dan tidak tahu apa-apa tentang pseudo-terminal kami. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty_init_dev(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = alloc_tty_struct(driver, idx); retval = tty_driver_install_tty(driver, tty); <span class="hljs-comment"><span class="hljs-comment">/* * Structures all installed ... call the ldisc open routines. */</span></span> retval = tty_ldisc_setup(tty, tty-&gt;link); <span class="hljs-comment"><span class="hljs-comment">//  ,       return tty; }</span></span></code> </pre> <br><p>  Pertama, kami akan <code>alloc_tty_struct()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *alloc_tty_struct(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*tty), GFP_KERNEL); <span class="hljs-comment"><span class="hljs-comment">//  tty_struct tty_ldisc_init(tty) //      tty_struct tty-&gt;driver = driver; //       tty_struct tty-&gt;ops = driver-&gt;ops; //        tty_struct.     tty-&gt;index = idx; //   tty  return tty; }</span></span></code> </pre> <br><p>  Satu-satunya hal yang menarik bagi kami di sini adalah fungsi <code>tty_ldisc_init()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_ldisc_init(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld = tty_ldisc_get(tty, N_TTY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ld)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(ld); tty-&gt;ldisc = ld; <span class="hljs-comment"><span class="hljs-comment">//        tty_struct return 0; }</span></span></code> </pre> <br><p>  Yang memanggil <code>tty_ldisc_get()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *tty_ldisc_get(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> disc) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_ldisc_ops *ldops; //     ldops = get_ldops(disc); //      .   ,       .   - N_TTY ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL); ld-&gt;ops = ldops; //       ld-&gt;tty = tty; //    tty_struct   .          return ld; }</span></span></code> </pre> <br><p>  Jadi, kami memeriksa panggilan ke fungsi <code>alloc_tty_struct()</code> , yang membuat struktur <em>tty_struct</em> bersama dengan disiplin garis - struktur <em>tty_ldisc</em> .  Kedua struktur memiliki hubungan satu sama lain.  Mari kita lihat lebih dekat struktur-struktur ini. </p><br><ul><li>  <strong>tty_struct</strong> adalah struktur untuk mengakses driver perangkat TTY dan beberapa bidang lainnya.  Ini terlihat seperti ini: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver; <span class="hljs-comment"><span class="hljs-comment">//  TTY  const struct tty_operations *ops; //  .    ,   driver-&gt;ops,       int index; //   struct tty_ldisc *ldisc; //     struct tty_struct *link; //     PTY // ... }</span></span></code> </pre> <br><ul><li>  <strong>tty_ldisc</strong> adalah struktur untuk disiplin garis TTY perangkat.  Ini terdiri dari hanya dua bidang dan terlihat sebagai berikut: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops *ops; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_struct *tty; //   tty_struct  .       };</span></span></code> </pre> <br><p>  Sepertinya tidak ada yang rumit?  Mari kita tambahkan semua struktur yang dianggap sampai saat ini ke keranjang kami dan tautkan dengan cara yang sama seperti mereka terhubung dalam kode: <br><img src="https://habrastorage.org/webt/1d/bt/n4/1dbtn4m_6c6i4n7oaohoguci2m0.jpeg" alt="Bangun tty_struct" title="Bangun tty_struct"></p><br><p>  Tapi kami membuat tty_struct hanya untuk perangkat PTM.  Bagaimana dengan perangkat PTS?  Untuk melakukan ini, kita kembali ke fungsi <code>tty_init_dev()</code> dan ingat bahwa kita kemudian diharapkan memanggil fungsi <code>tty_driver_install_tty()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This method is responsible * for ensuring any need additional structures are allocated and configured. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_driver_install_tty(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver-&gt;ops-&gt;install ? driver-&gt;ops-&gt;install(driver, tty) : tty_standard_install(driver, tty); }</code> </pre> <br><p>  Komentar tersebut memberi tahu kita bahwa metode ini bertanggung jawab untuk membuat berbagai struktur tambahan.  Perangkat PTS dan akan menjadi struktur tambahan kami.  Saya akui, itu sangat mengejutkan bagi saya, karena itu adalah, neraka, seluruh perangkat, dan bukan hanya semacam struktur tambahan!  Tapi kita semua mengerti bahwa semua perangkat hanyalah semacam struktur, jadi teruskan saja.  Ok, apa <em>driver-&gt; ops-&gt; instal di sini</em> ?  Untuk melakukan ini, lihat kembali tabel fungsi untuk driver PTM: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Dan kami memahami bahwa kami tertarik dengan fungsi <code>pty_unix98_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_unix98_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pty_common_install(driver, tty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Yang memanggil fungsi <code>pty_common_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_common_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> legacy) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *o_tty; <span class="hljs-comment"><span class="hljs-comment">// tty_struct    PTY -    PTS  //    ,       install.   ,   PTM     tty_struct,        if (driver-&gt;subtype != PTY_TYPE_MASTER) return -EIO; o_tty = alloc_tty_struct(driver-&gt;other, idx); tty-&gt;link = o_tty; o_tty-&gt;link = tty; }</span></span></code> </pre> <br><p>  ,   PTS       <em>tty_struct</em>   ,       PTS .           .  tty_struct  PTS    . </p><br><hr><br><h4 id="registraciya-drayvera">   </h4><br><p>        ,           TTY  (   -         ?). <br>  —  ,       PTM,   PTS : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { .llseek = no_llseek, .read = tty_read, .write = tty_write, .poll = tty_poll, .unlocked_ioctl = tty_ioctl, .compat_ioctl = tty_compat_ioctl, .open = tty_open, .release = tty_release, .fasync = tty_fasync, .show_fdinfo = tty_show_fdinfo, };</code> </pre> <br><p>         ,                  TTY . </p><br><hr><br><p> .      ,       <em>/dev/ptmx</em> .  ,   PTS ,      ,   PTM ,      : </p><br><p><img src="https://habrastorage.org/webt/5w/aw/rg/5wawrgbqqw1_llmi1r8g2kbwrzc.jpeg" title="Bangun PTY"></p><br><hr><br><h2 id="hello-world">  Halo Dunia! </h2><br><p>        .          "Hello, World!",        . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> void main() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello, World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre> <br><p> ,   "Hello, World!"    .   ,    ,  ,       .    ,    .  stdout  <em>/dev/null</em> —       .          ,       Linux. </p><br><p>      Unix        <em>write()</em> , <em>read()</em> , <em>close()</em>  ,    write()  /dev/pts/0         <code>__vfs_write()</code> : </p><br><pre> <code class="objectivec hljs">ssize_t __vfs_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *pos) { ssize_t ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br><p>     write()      .   ,            : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { <span class="hljs-comment"><span class="hljs-comment">// ... .write = tty_write, // ...</span></span></code> </pre> <br><p>  <code>tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *ppos) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty = file_tty(file); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; ssize_t ret; ld = tty_ldisc_ref_wait(tty); ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count); tty_ldisc_deref(ld); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>     <em>tty_struct</em>    TTY ,           write()  .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops n_tty_ops = { .write = n_tty_write, <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>    <code>n_tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * n_tty_write - write function for tty * @tty: tty device * @file: file object * @buf: userspace buffer pointer * @nr: size of I/O */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t n_tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, size_t nr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *b = buf; <span class="hljs-comment"><span class="hljs-comment">// b - ,       "Hello, World!".          int c; //    //     PTS ,  write()    0,  ,     while (nr &gt; 0) { c = tty-&gt;ops-&gt;write(tty, b, nr); //  write()       TTY  if (!c) break; b += c; //     nr -= c; //      :  -  -  -  } }</span></span></code> </pre> <br><p> ,  "Hello, World!"    write()   PTS .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations pty_unix98_ops = { .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  <code>pty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *to = tty-&gt;link; <span class="hljs-comment"><span class="hljs-comment">//      PTY.    -  PTM  if (c &gt; 0) { //    PTM  c = tty_insert_flip_string(to-&gt;port, buf, c); //     ,       if (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } return c; }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="objectivec hljs"> __vfs_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 1- :   tty_write() -&gt; do_tty_write() -&gt; n_tty_write() -&gt; // 2- :   pty_write() // 3- : </span></span></code> </pre> <br><p>     . ,       PTM . ,    . </p><br><p>  ,          <em>flip buffer</em> . <strong>Flip buffer</strong> —   ,    .  tty driver   ,      .   ,              .      ,        ,       .     ,      ,            .  -        flip buffer —       (,    -  ,         flip). </p><br><p>          ,       .  <code>tty_insert_flip_string()</code>         <code>tty_insert_flip_string_fixed_flag()</code> ,           PTM : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_insert_flip_string_fixed_flag(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *chars, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag, size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> copied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); <span class="hljs-comment"><span class="hljs-comment">//      int space = __tty_buffer_request_room(port, goal, flags); //     struct tty_buffer *tb = port-&gt;buf.tail; //       if (unlikely(space == 0)) break; memcpy(char_buf_ptr(tb, tb-&gt;used), chars, space); //      tb-&gt;used += space; copied += space; chars += space; /* There is a small chance that we need to split the data over several buffers. If this is the case we must loop */ } while (unlikely(size &gt; copied)); return copied; }</span></span></code> </pre> <br><p>   , flip buffer        ,       ,         .        ,   —        PTM ,             . </p><br><p> ,   "Hello, World!"   PTM .    GNOME Terminal Server    <em>poll()</em> (  I/O)        master .  ,         ?  Bagaimanapun caranya.      ,     ,      —        . </p><br><p>            <code>tty_flip_buffer_push()</code> (   pty_write): </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_flip_buffer_push - terminal * @port: tty port to push * * Queue a push of the terminal flip buffers to the line discipline. * Can be called from IRQ/atomic context. * * In the event of the queue being busy for flipping the work will be * held off and retried later. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_flip_buffer_push(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { tty_schedule_flip(port); }</code> </pre> <br><p>  <code>tty_schedule_flip()</code> ,   ,        : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_schedule_flip - push characters to ldisc * @port: tty port to push from * * Takes any pending buffers and transfers their ownership to the * ldisc side of the queue. It then schedules those characters for * processing by the line discipline. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_schedule_flip(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_bufhead *buf = &amp;port-&gt;buf; <span class="hljs-comment"><span class="hljs-comment">/* paired w/ acquire in flush_to_ldisc(); ensures * flush_to_ldisc() sees buffer data. */</span></span> smp_store_release(&amp;buf-&gt;tail-&gt;commit, buf-&gt;tail-&gt;used); queue_work(system_unbound_wq, &amp;buf-&gt;work); }</code> </pre> <br><p>   ,     <em>work</em> (,   -       )       ,      —    ,    <code>flush_to_ldisc()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> flush_to_ldisc(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> work_struct *work) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port = container_of(work, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port, buf.work); <span class="hljs-comment"><span class="hljs-comment">//   tty_port PTM . tty_port -       TTY  struct tty_bufhead *buf = &amp;port-&gt;buf; struct tty_buffer *head = buf-&gt;head; // ... receive_buf(port, head); // ... }</span></span></code> </pre> <br><p>  <code>receive_buf()</code>          <code>__receive_buf()</code> ,      : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __receive_buf(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fp, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> n_tty_data *ldata = tty-&gt;disc_data; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preops = I_ISTRIP(tty) || (I_IUCLC(tty) &amp;&amp; L_IEXTEN(tty)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;real_raw) n_tty_receive_buf_real_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;raw || (L_EXTPROC(tty) &amp;&amp; !preops)) n_tty_receive_buf_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;closing &amp;&amp; !L_EXTPROC(tty)) n_tty_receive_buf_closing(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;lnext) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag = TTY_NORMAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp) flag = *fp++; n_tty_receive_char_lnext(tty, *cp++, flag); count--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preops &amp;&amp; !I_PARMRK(tty)) n_tty_receive_buf_fast(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n_tty_receive_buf_standard(tty, cp, fp, count); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_cnt(ldata)) { kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN); wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN); } }</code> </pre> <br><p>  ,   <em>n_tty_receive_buf</em> ( ,    _raw)           <strong>read_buf</strong> ,         TTY .      PTM    raw ,           read_buf. ,        PTM  PTS ,     . </p><br><p>       ,   : </p><br><pre> <code class="objectivec hljs"> ... pty_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 3- :  PTS  tty_insert_flip_string + tty_flip_buffer_push() -&gt; tty_schedule_flip() -&gt; --- //    PTM  flush_to_ldisc() -&gt; // 2- :   PTM  receive_buf() -&gt; n_tty_receive_buf -&gt; n_tty_receive_buf_common -&gt; __receive_buf()</span></span></code> </pre> <br><p> ,   PTM        —         PTS . </p><br><p>  :       PTM .  GNOME Terminal Server      "Hello, World!",  read()  PTM .  read()    write()    —  <code>n_tty_read()</code> .      ,  ,          — <em>read_buf</em> —   .  GNOME Terminal Server    X Server,     . </p><br><p>  ,   "Hello, World!"   : </p><br><pre> <code class="plaintext hljs"> -&gt; PTY slave -&gt; PTY master -&gt; GNOME-TERMINAl-SERVER -&gt; X Server -&gt; -&gt; </code> </pre> <br><hr><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  .     : </p><br><ol><li>     </li><li>     </li><li>   TTY  </li><li>    </li><li>    ,         </li></ol><br><p>   ,   !     -  —     ,   ! </p><br><h3 id="istochniki">  Sumber </h3><br><ul><li> Linux man pages </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://unix.stackexchange.com/q/96694/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://unix.stackexchange.com/q/93531/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://unix.stackexchange.com/q/117981/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://askubuntu.com/q/506510</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.linusakesson.net/programming/tty/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/ru/company/neobit/blog/330764/</a> </li><li>  Advanced Programming in the UNIX Environment, 3rd Edition </li></ul><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460257/">https://habr.com/ru/post/id460257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460247/index.html">Resep untuk ELF</a></li>
<li><a href="../id460249/index.html">Solusi tugas dengan pwnable.kr 07 - input. Memahami pwntools</a></li>
<li><a href="../id460251/index.html">Kebodohan Buatan: bot yang tidak membantu saya</a></li>
<li><a href="../id460253/index.html">10 alasan untuk menjadikan keterampilan Anda sebagai asisten suara</a></li>
<li><a href="../id460255/index.html">Backdoor di Node.js: mengapa, mengapa, dan cara kerjanya</a></li>
<li><a href="../id460259/index.html">Apa itu desain UI dan UX? Apa yang umum dan berbeda?</a></li>
<li><a href="../id460261/index.html">Amazon: 25 Tahun Sukses E-commerce</a></li>
<li><a href="../id460263/index.html">Membuat pencarian yang benar-benar cerdas: panduan langkah demi langkah</a></li>
<li><a href="../id460265/index.html">Buat template proyek Xcode</a></li>
<li><a href="../id460273/index.html">Otorisasi di Apple Pay untuk yang terkecil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>