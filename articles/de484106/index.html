<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖊️ 🤩 🔒 MVCC in PostgreSQL-6. Vakuum 👨🏼‍✈️ 👯 👨🏼‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir begannen mit Problemen im Zusammenhang mit der Isolation , machten einen Exkurs über die Datenstruktur auf niedriger Ebene , diskutierten dann Zei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-6. Vakuum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/484106/">  Wir begannen mit Problemen im Zusammenhang mit der <a href="https://habr.com/ru/company/postgrespro/blog/467437/">Isolation</a> , machten einen Exkurs über die <a href="https://habr.com/ru/company/postgrespro/blog/469087/">Datenstruktur auf niedriger Ebene</a> , diskutierten dann <a href="https://habr.com/ru/company/postgrespro/blog/477648/">Zeilenversionen</a> und beobachteten, wie <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Datenschnappschüsse</a> aus Zeilenversionen erhalten werden. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Das letzte Mal haben</a> wir über HOT-Updates und In-Page-Staubsaugen gesprochen, und heute werden wir zu einer bekannten <em>Vakuum-Vulgaris übergehen</em> .  Wirklich, es ist bereits so viel darüber geschrieben worden, dass ich kaum etwas Neues hinzufügen kann, aber die Schönheit eines vollständigen Bildes erfordert Opfer.  Also haltet euch geduldig. <br><br><h1>  Vakuum </h1><br><h2>  Was macht Vakuum? </h2><br>  Der In-Page-Unterdruck arbeitet schnell, gibt jedoch nur einen Teil des Speicherplatzes frei.  Es funktioniert innerhalb einer Tabellenseite und berührt keine Indizes. <br><br>  Das "normale" Grundvakuum wird mit dem Befehl VACUUM erzeugt, und wir werden es nur "Vakuum" nennen ("Autovakuum" für eine separate Diskussion belassen). <br><br>  Vakuum bearbeitet also den gesamten Tisch.  Es saugt nicht nur tote Tupel weg, sondern verweist auch auf sie aus allen Indizes. <br><br>  Das Staubsaugen erfolgt gleichzeitig mit anderen Aktivitäten im System.  Die Tabelle und die Indizes können regelmäßig sowohl zum Lesen als auch zum Aktualisieren verwendet werden (die gleichzeitige Ausführung von Befehlen wie CREATE INDEX, ALTER TABLE und einigen anderen ist jedoch nicht möglich). <br><br>  Es werden nur die Tabellenseiten durchgesehen, auf denen einige Aktivitäten stattgefunden haben.  Um sie zu erkennen, wird die <em>Sichtbarkeitskarte</em> verwendet (um Sie daran zu erinnern, verfolgt die Karte die Seiten, die ziemlich alte Tupel enthalten, die auf jeden Fall in allen Datenschnappschüssen sichtbar sind).  Es werden nur die Seiten verarbeitet, die von der Sichtbarkeitskarte nicht erfasst werden, und die Karte selbst wird aktualisiert. <br><br>  Die <em>Zuordnung</em> des <em>freien Speicherplatzes wird dabei</em> ebenfalls aktualisiert, um den zusätzlichen freien Speicherplatz auf den Seiten widerzuspiegeln. <br><a name="habracut"></a><br>  Wie üblich erstellen wir eine Tabelle: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Wir verwenden den Parameter <em>autovacuum_enabled</em> , um den Autovakuum-Prozess auszuschalten.  Wir werden es das nächste Mal diskutieren, und jetzt ist es für unsere Experimente entscheidend, dass wir das Staubsaugen manuell steuern. <br><br>  Die Tabelle enthält jetzt drei Tupel, von denen jedes aus dem Index referenziert wird: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Nach dem Staubsaugen werden tote Tupel abgesaugt, und es bleibt nur ein lebendes Tupel übrig.  Und nur eine Referenz bleibt im Index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Beachten Sie, dass die ersten beiden Zeiger den Status "unbenutzt" anstelle von "tot" erhielten, den sie mit In-Page-Vakuum erhalten würden. <br><br><h2>  Über den Transaktionshorizont noch einmal </h2><br>  Wie erkennt PostgreSQL, welche Tupel als tot angesehen werden können?  Wir haben das Konzept des Transaktionshorizonts bereits bei der Erörterung von <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Datenschnappschüssen</a> angesprochen, aber es wird nicht schaden, eine so wichtige Angelegenheit zu wiederholen. <br><br>  Beginnen wir noch einmal mit dem vorherigen Experiment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Bevor Sie die Zeile erneut aktualisieren, müssen Sie eine weitere Transaktion starten (aber nicht beenden).  In diesem Beispiel wird die Ebene "Read Committed" verwendet, es muss jedoch eine echte (nicht virtuelle) Transaktionsnummer angegeben werden.  Beispielsweise kann die Transaktion bestimmte Zeilen in einer beliebigen Tabelle ändern und sogar sperren, die nicht obligatorisch ist. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Die Tabelle enthält drei Zeilen und der Index enthält drei Verweise.  Was passiert nach dem Staubsaugen? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Es verbleiben zwei Tupel in der Tabelle: VACUUM hat entschieden, dass das (0,2) -Tupel noch nicht gesaugt werden kann.  Der Grund liegt sicherlich im Transaktionshorizont der Datenbank, der in diesem Beispiel durch die nicht abgeschlossene Transaktion bestimmt wird: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Wir können VACUUM bitten zu melden, was gerade passiert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Beachten Sie, dass: <br><br><ul><li>  <code>2 nonremovable row versions</code> - zwei Tupel, die nicht gelöscht werden können, sind in der Tabelle enthalten. </li><li>  <code>1 dead row versions cannot be removed yet</code> - eine davon ist tot. </li><li>  <code>oldest xmin</code> zeigt den aktuellen Horizont. </li></ul><br>  Lassen Sie uns die Schlussfolgerung wiederholen: Wenn eine Datenbank über langlebige Transaktionen verfügt (die nicht abgeschlossen wurden oder sehr lange ausgeführt werden), kann dies zu einer Aufblähung der Tabelle führen, unabhängig davon, wie oft gesaugt wird.  Aus diesem Grund existieren OLTP- und OLAP-Workloads in einer PostgreSQL-Datenbank nur unzureichend zusammen: Berichte, die stundenlang ausgeführt werden, lassen aktualisierte Tabellen nicht ordnungsgemäß staubsaugen.  Die Erstellung eines separaten Replikats für Berichtszwecke kann eine mögliche Lösung dafür sein. <br><br>  Nach Abschluss einer offenen Transaktion verschiebt sich der Horizont und die Situation wird behoben: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Jetzt verbleibt nur noch die neueste Live-Version der Zeile auf der Seite: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Der Index hat auch nur eine Zeile: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Was passiert drinnen? </h2><br>  Das Staubsaugen muss die Tabelle und die Indizes gleichzeitig verarbeiten und dies tun, um die anderen Prozesse nicht zu sperren.  Wie kann das gehen? <br><br>  Alles beginnt mit der <strong>Scan-Heap-</strong> Phase (die bereits erwähnte Sichtbarkeitskarte wird berücksichtigt).  Auf den gelesenen Seiten werden tote Tupel erkannt und ihre <code>tid</code> in ein spezielles Array geschrieben.  Das Array wird im lokalen Speicher des Vakuumprozesses abgelegt, wo ihm die Bytes des Speichers <em>maintenance_work_mem</em> zugewiesen werden.  Der Standardwert dieses Parameters beträgt 64 MB.  Beachten Sie, dass die gesamte Speicherkapazität sofort zugewiesen wird und nicht nach Bedarf.  Wenn die Tabelle jedoch nicht groß ist, wird weniger Speicher zugewiesen. <br><br>  Dann erreichen wir entweder das Ende der Tabelle oder der für das Array zugewiesene Speicher ist vorbei.  In beiden Fällen beginnt die Phase der <strong>Vakuumindizes</strong> .  Zu diesem Zweck wird <em>jeder</em> für die Tabelle erstellte Index <em>vollständig</em> auf die Zeilen durchsucht, die auf die gespeicherten Tupel verweisen.  Die gefundenen Zeilen werden von den Indexseiten entfernt. <br><br>  Hier stellen wir uns dem Folgenden: Die Indizes haben noch keine Referenzen auf tote Tupel, während die Tabelle sie noch enthält.  Und das steht im Widerspruch zu nichts: Wenn wir eine Abfrage ausführen, treffen wir entweder keine toten Tupel (mit Indexzugriff) oder lehnen sie bei der Sichtbarkeitskontrolle ab (beim Scannen der Tabelle). <br><br>  Danach beginnt die Phase des <strong>Staubsaugens</strong> .  Die Tabelle wird erneut gescannt, um die entsprechenden Seiten zu lesen, sie von den erinnerten Tupeln zu saugen und die Zeiger freizugeben.  Wir können dies tun, da es keine Referenzen mehr aus den Indizes gibt. <br><br>  Wenn die Tabelle während des ersten Zyklus nicht vollständig gelesen wurde, wird das Array gelöscht und alles wird an der Stelle wiederholt, an der wir angekommen sind. <br><br>  Zusammenfassend: <br><br><ul><li>  Der Tisch wird immer zweimal gescannt. </li><li>  Wenn beim Staubsaugen so viele Tupel gelöscht werden, dass sie nicht alle in den Speicher der Größe <em>maintenance_work_mem</em> passen, werden alle Indizes so oft wie nötig gescannt. </li></ul><br>  Bei großen Tabellen kann dies viel Zeit in Anspruch nehmen und eine erhebliche Systemauslastung verursachen.  Natürlich werden Abfragen nicht gesperrt, aber eine zusätzliche Eingabe / Ausgabe ist definitiv unerwünscht. <br><br>  Um den Vorgang zu beschleunigen, ist es sinnvoll, entweder öfter VACUUM aufzurufen (damit nicht zu viele Tupel jedes Mal abgesaugt werden) oder mehr Speicher zuzuweisen. <br><br>  Ab Version 11 kann PostgreSQL <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dcommit%3Bh%3D857f9c36cda520030381bd8c2af20adf0ce0e1d4">Index-Scans überspringen,</a> sofern kein zwingender Bedarf besteht.  Dies muss den Eigentümern großer Tabellen, in denen nur Zeilen hinzugefügt (aber nicht geändert) werden, das Leben erleichtern. <br><br><h2>  Überwachung </h2><br>  Wie können wir herausfinden, dass VACUUM seine Arbeit nicht in einem Zyklus erledigen kann? <br><br>  Wir haben bereits den ersten Weg gesehen: den Befehl VACUUM mit der Option VERBOSE aufzurufen.  In diesem Fall werden Informationen zu den Phasen des Prozesses an die Konsole ausgegeben. <br><br>  Zweitens ist ab Version 9.6 die Ansicht <code>pg_stat_progress_vacuum</code> verfügbar, die auch alle erforderlichen Informationen enthält. <br><br>  (Der dritte Weg ist ebenfalls verfügbar: Die Informationen in das Nachrichtenprotokoll ausgeben, dies funktioniert jedoch nur für das automatische Vakuum, das beim nächsten Mal besprochen wird.) <br><br>  Fügen wir einige Zeilen in die Tabelle ein, damit der Vakuumprozess ziemlich lange dauert, und aktualisieren wir alle Zeilen, damit VACUUM Aufgaben erledigt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Reduzieren Sie die für das Array von Bezeichnern zugewiesene Speichergröße: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Starten wir VACUUM und greifen wir während des <code>pg_stat_progress_vacuum</code> mehrmals auf die Ansicht <code>pg_stat_progress_vacuum</code> : <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Hier können wir insbesondere sehen: <br><br><ul><li>  Der Name der aktuellen Phase - wir haben drei Hauptphasen besprochen, aber es gibt <a href="https://postgrespro.com/docs/postgresql/11/progress-reporting">mehr</a> davon im Allgemeinen. </li><li>  Die Gesamtzahl der Tabellenseiten ( <code>heap_blks_total</code> ). </li><li>  Die Anzahl der gescannten Seiten ( <code>heap_blks_scanned</code> ). </li><li>  Die Anzahl der bereits <code>heap_blks_vacuumed</code> Seiten ( <code>heap_blks_vacuumed</code> ). </li><li>  Die Anzahl der <code>index_vacuum_count</code> ( <code>index_vacuum_count</code> ). </li></ul><br>  Der allgemeine Fortschritt wird durch das Verhältnis von <code>heap_blks_vacuumed</code> zu <code>heap_blks_total</code> . Wir sollten jedoch berücksichtigen, dass sich dieser Wert aufgrund des Scannens der Indizes nicht reibungslos, sondern in großen Schritten ändert.  Das Hauptaugenmerk sollte jedoch auf die Anzahl der Vakuumzyklen gelegt werden: Eine Zahl größer als 1 bedeutet, dass der zugewiesene Speicher nicht ausreicht, um das Saugen in einem Zyklus abzuschließen. <br><br>  Die Ausgabe des zu diesem Zeitpunkt bereits abgeschlossenen Befehls VACUUM VERBOSE zeigt das allgemeine Bild: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Wir können hier sehen, dass drei Zyklen über die Indizes durchgeführt wurden und in jedem Zyklus 174480 Zeiger auf tote Tupel abgesaugt wurden.  Warum genau diese Nummer?  Ein <code>tid</code> belegt 6 Bytes und 1024 * 1024/6 = 174762, die Zahl, die wir in <code>pg_stat_progress_vacuum.max_dead_tuples</code> .  In der Realität kann etwas weniger verwendet werden: Dies stellt sicher, dass alle Zeiger auf tote Tupel in den Speicher passen, wenn eine nächste Seite gelesen wird. <br><br><h2>  Analyse </h2><br>  Die Analyse oder mit anderen Worten das Sammeln von Statistiken für den Abfrageplaner hat formal überhaupt nichts mit dem Staubsaugen zu tun.  Trotzdem können wir die Analyse nicht nur mit dem Befehl ANALYZE durchführen, sondern auch Staubsaugen und Analyse in VACUUM ANALYZE kombinieren.  Hier wird zuerst das Vakuum und dann die Analyse durchgeführt, so dass dies keine Gewinne ergibt. <br><br>  Wie wir später sehen werden, werden Autovakuum und automatische Analyse in einem Prozess durchgeführt und auf ähnliche Weise gesteuert. <br><br><h1>  VAKUUM VOLL </h1><br>  Wie oben erwähnt, gibt Vakuum mehr Platz frei als In-Page-Vakuum, löst jedoch das Problem nicht vollständig. <br><br>  Wenn die Größe einer Tabelle oder eines Index aus bestimmten Gründen stark zugenommen hat, gibt VACUUM Speicherplatz auf den vorhandenen Seiten frei: Dort treten "Löcher" auf, die dann zum Einfügen neuer Tupel verwendet werden.  Die Anzahl der Seiten ändert sich jedoch nicht. Aus Sicht des Betriebssystems belegen die Dateien daher genau den gleichen Platz wie vor dem Vakuum.  Und das ist nicht gut, weil: <br><br><ul><li>  Der vollständige Scan der Tabelle (oder des Index) wird langsamer. </li><li>  Möglicherweise ist ein größerer Puffercache erforderlich (da die Seiten dort gespeichert werden und die Dichte der nützlichen Informationen abnimmt). </li><li>  Im Indexbaum kann eine zusätzliche Ebene auftreten, die den Indexzugriff verlangsamt. </li><li>  Die Dateien belegen zusätzlichen Speicherplatz auf der Festplatte und in Sicherungskopien. </li></ul><br>  (Die einzige Ausnahme sind vollständig gesaugte Seiten am Ende der Datei. Diese Seiten werden aus der Datei entfernt und an das Betriebssystem zurückgegeben.) <br><br>  Wenn der Anteil nützlicher Informationen in den Dateien eine angemessene Grenze unterschreitet, kann der Administrator VACUUM FULL für die Tabelle ausführen.  In diesem Fall werden die Tabelle und alle ihre Indizes von Grund auf neu erstellt und die Daten werden größtenteils kompakt gepackt (natürlich unter Berücksichtigung des <code>fillfactor</code> Parameters).  Während der Neuerstellung erstellt PostgreSQL zuerst die Tabelle und dann jeden Index einzeln neu.  Für jedes Objekt werden neue Dateien erstellt und alte Dateien am Ende der Neuerstellung entfernt.  Wir sollten berücksichtigen, dass dabei zusätzlicher Speicherplatz benötigt wird. <br><br>  Um dies zu veranschaulichen, fügen wir noch einmal eine bestimmte Anzahl von Zeilen in die Tabelle ein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Wie können wir die Informationsdichte abschätzen?  Dazu ist es bequem, eine spezielle Erweiterung zu verwenden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  Die Funktion liest die gesamte Tabelle und zeigt Statistiken an: Welche Daten belegen wie viel Platz in den Dateien.  Die Hauptinformation, die uns jetzt interessiert, ist das Feld <code>tuple_percent</code> : der Prozentsatz nützlicher Daten.  Es ist weniger als 100 wegen des unvermeidlichen Informationsaufwands innerhalb einer Seite, aber es ist immer noch ziemlich hoch. <br><br>  Für den Index werden unterschiedliche Informationen ausgegeben, aber das Feld <code>avg_leaf_density</code> hat dieselbe Bedeutung: den Prozentsatz nützlicher Informationen (in Blattseiten). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Und dies sind die Größen der Tabelle und der Indizes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Jetzt löschen wir 90% aller Zeilen.  Wir wählen die zu löschenden Zeilen nach dem Zufallsprinzip aus, sodass mit hoher Wahrscheinlichkeit mindestens eine Zeile auf jeder Seite verbleibt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Welche Größe haben die Objekte nach VACUUM? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Wir können sehen, dass sich die Größe nicht geändert hat: VACUUM kann auf keinen Fall die Größe von Dateien reduzieren.  Und das, obwohl die Informationsdichte um das Zehnfache abnahm: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Lassen Sie uns nun überprüfen, was wir nach VACUUM FULL erhalten.  Jetzt verwenden die Tabelle und die Indizes die folgenden Dateien: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Die Dateien werden jetzt durch neue ersetzt.  Die Tabellen- und Indexgrößen nahmen erheblich ab, während sich die Informationsdichte entsprechend erhöhte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Beachten Sie, dass die Informationsdichte im Index noch größer als die ursprüngliche ist.  Es ist vorteilhafter, einen Index (B-Tree) aus den verfügbaren Daten neu zu erstellen, als die Daten zeilenweise in einen vorhandenen Index einzufügen. <br><br>  Die Funktionen der <a href="https://postgrespro.com/docs/postgresql/11/pgstattuple">pgstattuple-</a> Erweiterung, die wir verwendet haben, haben die gesamte Tabelle gelesen.  Dies ist jedoch unpraktisch, wenn die Tabelle groß ist. <code>pgstattuple_approx</code> verfügt die Erweiterung über die Funktion <code>pgstattuple_approx</code> , mit der die in der Sichtbarkeitskarte markierten Seiten <code>pgstattuple_approx</code> und ungefähre Zahlen <code>pgstattuple_approx</code> werden. <br><br>  Eine weitere Möglichkeit, die jedoch noch ungenauer ist, ist die Verwendung des Systemkatalogs, um das Verhältnis der Datengröße zur Dateigröße grob abzuschätzen.  Beispiele für solche Abfragen finden Sie <a href="https://wiki.postgresql.org/wiki/Show_database_bloat">im Wiki</a> . <br><br>  VACUUM FULL ist nicht für den regulären Gebrauch vorgesehen, da es die Arbeit mit der Tabelle (einschließlich Abfrage) für die gesamte Dauer des Prozesses blockiert.  Es ist klar, dass dies für ein stark genutztes System nicht akzeptabel erscheint.  Sperren werden separat behandelt, und jetzt erwähnen wir nur die Erweiterung <a href="https://github.com/reorg/pg_repack">pg_repack</a> , die die Tabelle am Ende der Arbeit nur für einen kurzen Zeitraum sperrt. <br><br><h2>  Ähnliche Befehle </h2><br>  Es gibt einige Befehle, die auch Tabellen und Indizes vollständig neu erstellen und daher VACUUM FULL ähneln.  Alle blockieren die Arbeit mit der Tabelle vollständig, alle entfernen alte Datendateien und erstellen neue. <br><br>  Der Befehl CLUSTER ähnelt in allen Punkten VACUUM FULL, ordnet jedoch Tupel physisch gemäß einem der verfügbaren Indizes an.  Dies ermöglicht es dem Planer, den Indexzugriff in einigen Fällen effizienter zu nutzen.  Wir sollten jedoch bedenken, dass die Clusterbildung nicht aufrechterhalten wird: Die physikalische Reihenfolge der Tupel wird bei nachfolgenden Änderungen der Tabelle unterbrochen. <br><br>  Der Befehl REINDEX erstellt einen separaten Index für die Tabelle neu.  VACUUM FULL und CLUSTER verwenden diesen Befehl tatsächlich, um Indizes neu zu erstellen. <br><br>  Die Logik des Befehls TRUNCATE ähnelt der von DELETE - es werden alle Tabellenzeilen gelöscht.  Aber DELETE markiert, wie bereits erwähnt, nur Tupel als gelöscht, und dies erfordert ein weiteres Staubsaugen.  Und TRUNCATE erstellt stattdessen nur eine neue, saubere Datei.  In der Regel funktioniert dies schneller, aber wir sollten bedenken, dass TRUNCATE jede Arbeit mit der Tabelle bis zum Ende der Transaktion blockiert. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/486104/">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484106/">https://habr.com/ru/post/de484106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484090/index.html">Neue IT-Infrastruktur für das Russian Post Data Center</a></li>
<li><a href="../de484092/index.html">Etwas gekleidete Fürsten und Adlige</a></li>
<li><a href="../de484096/index.html">Die Schlacht der beiden Yakozun oder Cassandra gegen HBase. Erfahrung im Sberbank-Team</a></li>
<li><a href="../de484100/index.html">Arbeiten mit der Oberfläche im Google Maps SDK für Android</a></li>
<li><a href="../de484102/index.html">PHP vs Python vs Ruby on Rails: Detaillierter Vergleich</a></li>
<li><a href="../de484108/index.html">Etherblade.net-Encapsulator und Importersetzung für Netzwerkkomponenten (Teil 2)</a></li>
<li><a href="../de484112/index.html">Kann man ein Flugzeug hacken?</a></li>
<li><a href="../de484114/index.html">Eine Auswahl von 143 Übersetzungen des Aufsatzes von Paul Graham (von 184)</a></li>
<li><a href="../de484118/index.html">32 Januar</a></li>
<li><a href="../de484120/index.html">Die gefragtesten Fähigkeiten im Beruf des Dateningenieurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>