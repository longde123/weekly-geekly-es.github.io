<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñäÔ∏è ü§© üîí MVCC in PostgreSQL-6. Vakuum üë®üèº‚Äç‚úàÔ∏è üëØ üë®üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir begannen mit Problemen im Zusammenhang mit der Isolation , machten einen Exkurs √ºber die Datenstruktur auf niedriger Ebene , diskutierten dann Zei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-6. Vakuum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/484106/">  Wir begannen mit Problemen im Zusammenhang mit der <a href="https://habr.com/ru/company/postgrespro/blog/467437/">Isolation</a> , machten einen Exkurs √ºber die <a href="https://habr.com/ru/company/postgrespro/blog/469087/">Datenstruktur auf niedriger Ebene</a> , diskutierten dann <a href="https://habr.com/ru/company/postgrespro/blog/477648/">Zeilenversionen</a> und beobachteten, wie <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Datenschnappsch√ºsse</a> aus Zeilenversionen erhalten werden. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Das letzte Mal haben</a> wir √ºber HOT-Updates und In-Page-Staubsaugen gesprochen, und heute werden wir zu einer bekannten <em>Vakuum-Vulgaris √ºbergehen</em> .  Wirklich, es ist bereits so viel dar√ºber geschrieben worden, dass ich kaum etwas Neues hinzuf√ºgen kann, aber die Sch√∂nheit eines vollst√§ndigen Bildes erfordert Opfer.  Also haltet euch geduldig. <br><br><h1>  Vakuum </h1><br><h2>  Was macht Vakuum? </h2><br>  Der In-Page-Unterdruck arbeitet schnell, gibt jedoch nur einen Teil des Speicherplatzes frei.  Es funktioniert innerhalb einer Tabellenseite und ber√ºhrt keine Indizes. <br><br>  Das "normale" Grundvakuum wird mit dem Befehl VACUUM erzeugt, und wir werden es nur "Vakuum" nennen ("Autovakuum" f√ºr eine separate Diskussion belassen). <br><br>  Vakuum bearbeitet also den gesamten Tisch.  Es saugt nicht nur tote Tupel weg, sondern verweist auch auf sie aus allen Indizes. <br><br>  Das Staubsaugen erfolgt gleichzeitig mit anderen Aktivit√§ten im System.  Die Tabelle und die Indizes k√∂nnen regelm√§√üig sowohl zum Lesen als auch zum Aktualisieren verwendet werden (die gleichzeitige Ausf√ºhrung von Befehlen wie CREATE INDEX, ALTER TABLE und einigen anderen ist jedoch nicht m√∂glich). <br><br>  Es werden nur die Tabellenseiten durchgesehen, auf denen einige Aktivit√§ten stattgefunden haben.  Um sie zu erkennen, wird die <em>Sichtbarkeitskarte</em> verwendet (um Sie daran zu erinnern, verfolgt die Karte die Seiten, die ziemlich alte Tupel enthalten, die auf jeden Fall in allen Datenschnappsch√ºssen sichtbar sind).  Es werden nur die Seiten verarbeitet, die von der Sichtbarkeitskarte nicht erfasst werden, und die Karte selbst wird aktualisiert. <br><br>  Die <em>Zuordnung</em> des <em>freien Speicherplatzes wird dabei</em> ebenfalls aktualisiert, um den zus√§tzlichen freien Speicherplatz auf den Seiten widerzuspiegeln. <br><a name="habracut"></a><br>  Wie √ºblich erstellen wir eine Tabelle: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Wir verwenden den Parameter <em>autovacuum_enabled</em> , um den Autovakuum-Prozess auszuschalten.  Wir werden es das n√§chste Mal diskutieren, und jetzt ist es f√ºr unsere Experimente entscheidend, dass wir das Staubsaugen manuell steuern. <br><br>  Die Tabelle enth√§lt jetzt drei Tupel, von denen jedes aus dem Index referenziert wird: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Nach dem Staubsaugen werden tote Tupel abgesaugt, und es bleibt nur ein lebendes Tupel √ºbrig.  Und nur eine Referenz bleibt im Index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Beachten Sie, dass die ersten beiden Zeiger den Status "unbenutzt" anstelle von "tot" erhielten, den sie mit In-Page-Vakuum erhalten w√ºrden. <br><br><h2>  √úber den Transaktionshorizont noch einmal </h2><br>  Wie erkennt PostgreSQL, welche Tupel als tot angesehen werden k√∂nnen?  Wir haben das Konzept des Transaktionshorizonts bereits bei der Er√∂rterung von <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Datenschnappsch√ºssen</a> angesprochen, aber es wird nicht schaden, eine so wichtige Angelegenheit zu wiederholen. <br><br>  Beginnen wir noch einmal mit dem vorherigen Experiment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Bevor Sie die Zeile erneut aktualisieren, m√ºssen Sie eine weitere Transaktion starten (aber nicht beenden).  In diesem Beispiel wird die Ebene "Read Committed" verwendet, es muss jedoch eine echte (nicht virtuelle) Transaktionsnummer angegeben werden.  Beispielsweise kann die Transaktion bestimmte Zeilen in einer beliebigen Tabelle √§ndern und sogar sperren, die nicht obligatorisch ist. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Die Tabelle enth√§lt drei Zeilen und der Index enth√§lt drei Verweise.  Was passiert nach dem Staubsaugen? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Es verbleiben zwei Tupel in der Tabelle: VACUUM hat entschieden, dass das (0,2) -Tupel noch nicht gesaugt werden kann.  Der Grund liegt sicherlich im Transaktionshorizont der Datenbank, der in diesem Beispiel durch die nicht abgeschlossene Transaktion bestimmt wird: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Wir k√∂nnen VACUUM bitten zu melden, was gerade passiert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Beachten Sie, dass: <br><br><ul><li>  <code>2 nonremovable row versions</code> - zwei Tupel, die nicht gel√∂scht werden k√∂nnen, sind in der Tabelle enthalten. </li><li>  <code>1 dead row versions cannot be removed yet</code> - eine davon ist tot. </li><li>  <code>oldest xmin</code> zeigt den aktuellen Horizont. </li></ul><br>  Lassen Sie uns die Schlussfolgerung wiederholen: Wenn eine Datenbank √ºber langlebige Transaktionen verf√ºgt (die nicht abgeschlossen wurden oder sehr lange ausgef√ºhrt werden), kann dies zu einer Aufbl√§hung der Tabelle f√ºhren, unabh√§ngig davon, wie oft gesaugt wird.  Aus diesem Grund existieren OLTP- und OLAP-Workloads in einer PostgreSQL-Datenbank nur unzureichend zusammen: Berichte, die stundenlang ausgef√ºhrt werden, lassen aktualisierte Tabellen nicht ordnungsgem√§√ü staubsaugen.  Die Erstellung eines separaten Replikats f√ºr Berichtszwecke kann eine m√∂gliche L√∂sung daf√ºr sein. <br><br>  Nach Abschluss einer offenen Transaktion verschiebt sich der Horizont und die Situation wird behoben: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Jetzt verbleibt nur noch die neueste Live-Version der Zeile auf der Seite: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Der Index hat auch nur eine Zeile: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Was passiert drinnen? </h2><br>  Das Staubsaugen muss die Tabelle und die Indizes gleichzeitig verarbeiten und dies tun, um die anderen Prozesse nicht zu sperren.  Wie kann das gehen? <br><br>  Alles beginnt mit der <strong>Scan-Heap-</strong> Phase (die bereits erw√§hnte Sichtbarkeitskarte wird ber√ºcksichtigt).  Auf den gelesenen Seiten werden tote Tupel erkannt und ihre <code>tid</code> in ein spezielles Array geschrieben.  Das Array wird im lokalen Speicher des Vakuumprozesses abgelegt, wo ihm die Bytes des Speichers <em>maintenance_work_mem</em> zugewiesen werden.  Der Standardwert dieses Parameters betr√§gt 64 MB.  Beachten Sie, dass die gesamte Speicherkapazit√§t sofort zugewiesen wird und nicht nach Bedarf.  Wenn die Tabelle jedoch nicht gro√ü ist, wird weniger Speicher zugewiesen. <br><br>  Dann erreichen wir entweder das Ende der Tabelle oder der f√ºr das Array zugewiesene Speicher ist vorbei.  In beiden F√§llen beginnt die Phase der <strong>Vakuumindizes</strong> .  Zu diesem Zweck wird <em>jeder</em> f√ºr die Tabelle erstellte Index <em>vollst√§ndig</em> auf die Zeilen durchsucht, die auf die gespeicherten Tupel verweisen.  Die gefundenen Zeilen werden von den Indexseiten entfernt. <br><br>  Hier stellen wir uns dem Folgenden: Die Indizes haben noch keine Referenzen auf tote Tupel, w√§hrend die Tabelle sie noch enth√§lt.  Und das steht im Widerspruch zu nichts: Wenn wir eine Abfrage ausf√ºhren, treffen wir entweder keine toten Tupel (mit Indexzugriff) oder lehnen sie bei der Sichtbarkeitskontrolle ab (beim Scannen der Tabelle). <br><br>  Danach beginnt die Phase des <strong>Staubsaugens</strong> .  Die Tabelle wird erneut gescannt, um die entsprechenden Seiten zu lesen, sie von den erinnerten Tupeln zu saugen und die Zeiger freizugeben.  Wir k√∂nnen dies tun, da es keine Referenzen mehr aus den Indizes gibt. <br><br>  Wenn die Tabelle w√§hrend des ersten Zyklus nicht vollst√§ndig gelesen wurde, wird das Array gel√∂scht und alles wird an der Stelle wiederholt, an der wir angekommen sind. <br><br>  Zusammenfassend: <br><br><ul><li>  Der Tisch wird immer zweimal gescannt. </li><li>  Wenn beim Staubsaugen so viele Tupel gel√∂scht werden, dass sie nicht alle in den Speicher der Gr√∂√üe <em>maintenance_work_mem</em> passen, werden alle Indizes so oft wie n√∂tig gescannt. </li></ul><br>  Bei gro√üen Tabellen kann dies viel Zeit in Anspruch nehmen und eine erhebliche Systemauslastung verursachen.  Nat√ºrlich werden Abfragen nicht gesperrt, aber eine zus√§tzliche Eingabe / Ausgabe ist definitiv unerw√ºnscht. <br><br>  Um den Vorgang zu beschleunigen, ist es sinnvoll, entweder √∂fter VACUUM aufzurufen (damit nicht zu viele Tupel jedes Mal abgesaugt werden) oder mehr Speicher zuzuweisen. <br><br>  Ab Version 11 kann PostgreSQL <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dcommit%3Bh%3D857f9c36cda520030381bd8c2af20adf0ce0e1d4">Index-Scans √ºberspringen,</a> sofern kein zwingender Bedarf besteht.  Dies muss den Eigent√ºmern gro√üer Tabellen, in denen nur Zeilen hinzugef√ºgt (aber nicht ge√§ndert) werden, das Leben erleichtern. <br><br><h2>  √úberwachung </h2><br>  Wie k√∂nnen wir herausfinden, dass VACUUM seine Arbeit nicht in einem Zyklus erledigen kann? <br><br>  Wir haben bereits den ersten Weg gesehen: den Befehl VACUUM mit der Option VERBOSE aufzurufen.  In diesem Fall werden Informationen zu den Phasen des Prozesses an die Konsole ausgegeben. <br><br>  Zweitens ist ab Version 9.6 die Ansicht <code>pg_stat_progress_vacuum</code> verf√ºgbar, die auch alle erforderlichen Informationen enth√§lt. <br><br>  (Der dritte Weg ist ebenfalls verf√ºgbar: Die Informationen in das Nachrichtenprotokoll ausgeben, dies funktioniert jedoch nur f√ºr das automatische Vakuum, das beim n√§chsten Mal besprochen wird.) <br><br>  F√ºgen wir einige Zeilen in die Tabelle ein, damit der Vakuumprozess ziemlich lange dauert, und aktualisieren wir alle Zeilen, damit VACUUM Aufgaben erledigt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Reduzieren Sie die f√ºr das Array von Bezeichnern zugewiesene Speichergr√∂√üe: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Starten wir VACUUM und greifen wir w√§hrend des <code>pg_stat_progress_vacuum</code> mehrmals auf die Ansicht <code>pg_stat_progress_vacuum</code> : <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Hier k√∂nnen wir insbesondere sehen: <br><br><ul><li>  Der Name der aktuellen Phase - wir haben drei Hauptphasen besprochen, aber es gibt <a href="https://postgrespro.com/docs/postgresql/11/progress-reporting">mehr</a> davon im Allgemeinen. </li><li>  Die Gesamtzahl der Tabellenseiten ( <code>heap_blks_total</code> ). </li><li>  Die Anzahl der gescannten Seiten ( <code>heap_blks_scanned</code> ). </li><li>  Die Anzahl der bereits <code>heap_blks_vacuumed</code> Seiten ( <code>heap_blks_vacuumed</code> ). </li><li>  Die Anzahl der <code>index_vacuum_count</code> ( <code>index_vacuum_count</code> ). </li></ul><br>  Der allgemeine Fortschritt wird durch das Verh√§ltnis von <code>heap_blks_vacuumed</code> zu <code>heap_blks_total</code> . Wir sollten jedoch ber√ºcksichtigen, dass sich dieser Wert aufgrund des Scannens der Indizes nicht reibungslos, sondern in gro√üen Schritten √§ndert.  Das Hauptaugenmerk sollte jedoch auf die Anzahl der Vakuumzyklen gelegt werden: Eine Zahl gr√∂√üer als 1 bedeutet, dass der zugewiesene Speicher nicht ausreicht, um das Saugen in einem Zyklus abzuschlie√üen. <br><br>  Die Ausgabe des zu diesem Zeitpunkt bereits abgeschlossenen Befehls VACUUM VERBOSE zeigt das allgemeine Bild: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Wir k√∂nnen hier sehen, dass drei Zyklen √ºber die Indizes durchgef√ºhrt wurden und in jedem Zyklus 174480 Zeiger auf tote Tupel abgesaugt wurden.  Warum genau diese Nummer?  Ein <code>tid</code> belegt 6 Bytes und 1024 * 1024/6 = 174762, die Zahl, die wir in <code>pg_stat_progress_vacuum.max_dead_tuples</code> .  In der Realit√§t kann etwas weniger verwendet werden: Dies stellt sicher, dass alle Zeiger auf tote Tupel in den Speicher passen, wenn eine n√§chste Seite gelesen wird. <br><br><h2>  Analyse </h2><br>  Die Analyse oder mit anderen Worten das Sammeln von Statistiken f√ºr den Abfrageplaner hat formal √ºberhaupt nichts mit dem Staubsaugen zu tun.  Trotzdem k√∂nnen wir die Analyse nicht nur mit dem Befehl ANALYZE durchf√ºhren, sondern auch Staubsaugen und Analyse in VACUUM ANALYZE kombinieren.  Hier wird zuerst das Vakuum und dann die Analyse durchgef√ºhrt, so dass dies keine Gewinne ergibt. <br><br>  Wie wir sp√§ter sehen werden, werden Autovakuum und automatische Analyse in einem Prozess durchgef√ºhrt und auf √§hnliche Weise gesteuert. <br><br><h1>  VAKUUM VOLL </h1><br>  Wie oben erw√§hnt, gibt Vakuum mehr Platz frei als In-Page-Vakuum, l√∂st jedoch das Problem nicht vollst√§ndig. <br><br>  Wenn die Gr√∂√üe einer Tabelle oder eines Index aus bestimmten Gr√ºnden stark zugenommen hat, gibt VACUUM Speicherplatz auf den vorhandenen Seiten frei: Dort treten "L√∂cher" auf, die dann zum Einf√ºgen neuer Tupel verwendet werden.  Die Anzahl der Seiten √§ndert sich jedoch nicht. Aus Sicht des Betriebssystems belegen die Dateien daher genau den gleichen Platz wie vor dem Vakuum.  Und das ist nicht gut, weil: <br><br><ul><li>  Der vollst√§ndige Scan der Tabelle (oder des Index) wird langsamer. </li><li>  M√∂glicherweise ist ein gr√∂√üerer Puffercache erforderlich (da die Seiten dort gespeichert werden und die Dichte der n√ºtzlichen Informationen abnimmt). </li><li>  Im Indexbaum kann eine zus√§tzliche Ebene auftreten, die den Indexzugriff verlangsamt. </li><li>  Die Dateien belegen zus√§tzlichen Speicherplatz auf der Festplatte und in Sicherungskopien. </li></ul><br>  (Die einzige Ausnahme sind vollst√§ndig gesaugte Seiten am Ende der Datei. Diese Seiten werden aus der Datei entfernt und an das Betriebssystem zur√ºckgegeben.) <br><br>  Wenn der Anteil n√ºtzlicher Informationen in den Dateien eine angemessene Grenze unterschreitet, kann der Administrator VACUUM FULL f√ºr die Tabelle ausf√ºhren.  In diesem Fall werden die Tabelle und alle ihre Indizes von Grund auf neu erstellt und die Daten werden gr√∂√ütenteils kompakt gepackt (nat√ºrlich unter Ber√ºcksichtigung des <code>fillfactor</code> Parameters).  W√§hrend der Neuerstellung erstellt PostgreSQL zuerst die Tabelle und dann jeden Index einzeln neu.  F√ºr jedes Objekt werden neue Dateien erstellt und alte Dateien am Ende der Neuerstellung entfernt.  Wir sollten ber√ºcksichtigen, dass dabei zus√§tzlicher Speicherplatz ben√∂tigt wird. <br><br>  Um dies zu veranschaulichen, f√ºgen wir noch einmal eine bestimmte Anzahl von Zeilen in die Tabelle ein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Wie k√∂nnen wir die Informationsdichte absch√§tzen?  Dazu ist es bequem, eine spezielle Erweiterung zu verwenden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  Die Funktion liest die gesamte Tabelle und zeigt Statistiken an: Welche Daten belegen wie viel Platz in den Dateien.  Die Hauptinformation, die uns jetzt interessiert, ist das Feld <code>tuple_percent</code> : der Prozentsatz n√ºtzlicher Daten.  Es ist weniger als 100 wegen des unvermeidlichen Informationsaufwands innerhalb einer Seite, aber es ist immer noch ziemlich hoch. <br><br>  F√ºr den Index werden unterschiedliche Informationen ausgegeben, aber das Feld <code>avg_leaf_density</code> hat dieselbe Bedeutung: den Prozentsatz n√ºtzlicher Informationen (in Blattseiten). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Und dies sind die Gr√∂√üen der Tabelle und der Indizes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Jetzt l√∂schen wir 90% aller Zeilen.  Wir w√§hlen die zu l√∂schenden Zeilen nach dem Zufallsprinzip aus, sodass mit hoher Wahrscheinlichkeit mindestens eine Zeile auf jeder Seite verbleibt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Welche Gr√∂√üe haben die Objekte nach VACUUM? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Wir k√∂nnen sehen, dass sich die Gr√∂√üe nicht ge√§ndert hat: VACUUM kann auf keinen Fall die Gr√∂√üe von Dateien reduzieren.  Und das, obwohl die Informationsdichte um das Zehnfache abnahm: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Lassen Sie uns nun √ºberpr√ºfen, was wir nach VACUUM FULL erhalten.  Jetzt verwenden die Tabelle und die Indizes die folgenden Dateien: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Die Dateien werden jetzt durch neue ersetzt.  Die Tabellen- und Indexgr√∂√üen nahmen erheblich ab, w√§hrend sich die Informationsdichte entsprechend erh√∂hte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Beachten Sie, dass die Informationsdichte im Index noch gr√∂√üer als die urspr√ºngliche ist.  Es ist vorteilhafter, einen Index (B-Tree) aus den verf√ºgbaren Daten neu zu erstellen, als die Daten zeilenweise in einen vorhandenen Index einzuf√ºgen. <br><br>  Die Funktionen der <a href="https://postgrespro.com/docs/postgresql/11/pgstattuple">pgstattuple-</a> Erweiterung, die wir verwendet haben, haben die gesamte Tabelle gelesen.  Dies ist jedoch unpraktisch, wenn die Tabelle gro√ü ist. <code>pgstattuple_approx</code> verf√ºgt die Erweiterung √ºber die Funktion <code>pgstattuple_approx</code> , mit der die in der Sichtbarkeitskarte markierten Seiten <code>pgstattuple_approx</code> und ungef√§hre Zahlen <code>pgstattuple_approx</code> werden. <br><br>  Eine weitere M√∂glichkeit, die jedoch noch ungenauer ist, ist die Verwendung des Systemkatalogs, um das Verh√§ltnis der Datengr√∂√üe zur Dateigr√∂√üe grob abzusch√§tzen.  Beispiele f√ºr solche Abfragen finden Sie <a href="https://wiki.postgresql.org/wiki/Show_database_bloat">im Wiki</a> . <br><br>  VACUUM FULL ist nicht f√ºr den regul√§ren Gebrauch vorgesehen, da es die Arbeit mit der Tabelle (einschlie√ülich Abfrage) f√ºr die gesamte Dauer des Prozesses blockiert.  Es ist klar, dass dies f√ºr ein stark genutztes System nicht akzeptabel erscheint.  Sperren werden separat behandelt, und jetzt erw√§hnen wir nur die Erweiterung <a href="https://github.com/reorg/pg_repack">pg_repack</a> , die die Tabelle am Ende der Arbeit nur f√ºr einen kurzen Zeitraum sperrt. <br><br><h2>  √Ñhnliche Befehle </h2><br>  Es gibt einige Befehle, die auch Tabellen und Indizes vollst√§ndig neu erstellen und daher VACUUM FULL √§hneln.  Alle blockieren die Arbeit mit der Tabelle vollst√§ndig, alle entfernen alte Datendateien und erstellen neue. <br><br>  Der Befehl CLUSTER √§hnelt in allen Punkten VACUUM FULL, ordnet jedoch Tupel physisch gem√§√ü einem der verf√ºgbaren Indizes an.  Dies erm√∂glicht es dem Planer, den Indexzugriff in einigen F√§llen effizienter zu nutzen.  Wir sollten jedoch bedenken, dass die Clusterbildung nicht aufrechterhalten wird: Die physikalische Reihenfolge der Tupel wird bei nachfolgenden √Ñnderungen der Tabelle unterbrochen. <br><br>  Der Befehl REINDEX erstellt einen separaten Index f√ºr die Tabelle neu.  VACUUM FULL und CLUSTER verwenden diesen Befehl tats√§chlich, um Indizes neu zu erstellen. <br><br>  Die Logik des Befehls TRUNCATE √§hnelt der von DELETE - es werden alle Tabellenzeilen gel√∂scht.  Aber DELETE markiert, wie bereits erw√§hnt, nur Tupel als gel√∂scht, und dies erfordert ein weiteres Staubsaugen.  Und TRUNCATE erstellt stattdessen nur eine neue, saubere Datei.  In der Regel funktioniert dies schneller, aber wir sollten bedenken, dass TRUNCATE jede Arbeit mit der Tabelle bis zum Ende der Transaktion blockiert. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/486104/">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484106/">https://habr.com/ru/post/de484106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484090/index.html">Neue IT-Infrastruktur f√ºr das Russian Post Data Center</a></li>
<li><a href="../de484092/index.html">Etwas gekleidete F√ºrsten und Adlige</a></li>
<li><a href="../de484096/index.html">Die Schlacht der beiden Yakozun oder Cassandra gegen HBase. Erfahrung im Sberbank-Team</a></li>
<li><a href="../de484100/index.html">Arbeiten mit der Oberfl√§che im Google Maps SDK f√ºr Android</a></li>
<li><a href="../de484102/index.html">PHP vs Python vs Ruby on Rails: Detaillierter Vergleich</a></li>
<li><a href="../de484108/index.html">Etherblade.net-Encapsulator und Importersetzung f√ºr Netzwerkkomponenten (Teil 2)</a></li>
<li><a href="../de484112/index.html">Kann man ein Flugzeug hacken?</a></li>
<li><a href="../de484114/index.html">Eine Auswahl von 143 √úbersetzungen des Aufsatzes von Paul Graham (von 184)</a></li>
<li><a href="../de484118/index.html">32 Januar</a></li>
<li><a href="../de484120/index.html">Die gefragtesten F√§higkeiten im Beruf des Dateningenieurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>