<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎣 🍹 🗺️ 3D游戏渲染如何工作：顶点处理 ♐️ 🛀🏿 👲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在这篇文章中，我们将考虑顶点的工作阶段。 也就是说，我们将不得不再次获得有关数学的教科书，并回顾线性代数，矩阵和三角学。 万岁！ 

 我们将了解如何转换3D模型并考虑光源。 我们还将详细说明顶点着色器和几何着色器之间的区别，您将了解到在哪个阶段进行镶嵌。 为了便于理解，我们使用图表和代码示例来演示...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3D游戏渲染如何工作：顶点处理</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472688/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/070/e30/bd5/070e30bd57f6af2d7c1e36abe15f949b.jpg" alt="图片"></div><br> 在这篇文章中，我们将考虑顶点的工作阶段。 也就是说，我们将不得不再次获得有关数学的教科书，并回顾线性代数，矩阵和三角学。 万岁！ <br><br> 我们将了解如何转换3D模型并考虑光源。 我们还将详细说明顶点着色器和几何着色器之间的区别，您将了解到在哪个阶段进行镶嵌。 为了便于理解，我们使用图表和代码示例来演示游戏如何执行计算和处理值。 <br><br> 帖子开头的屏幕截图以线框显示模式显示了GTA V游戏。 将其与不太复杂的Half-Life 2线框进行比较，图像由thalixte与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReShade</a>共同创建。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/562/7ee/4c45627ee9916f0bcdce6858b510b6a6.jpg"></div><a name="habracut"></a><br><h2> 有什么意义？ </h2><br> 在数学世界中，点仅仅是几何空间中的一个位置。 没有什么比一个点还小，它没有大小，因此可以使用点来指定对象的起点和终点的精确位置，例如线段，平面和体积。 <br><br> 对于3D图形，此类信息至关重要，因为所有对象都显示为线段，平面等的集合，所以一切的外观都取决于它。 下图显示了Bethesda 2015 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fallout 4</a>的屏幕截图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87b/33c/f82/87b33cf825a8ed9d87b7c8a7cc873e69.jpg"></div><br> 您可能不容易看出这只是一大堆点和线，因此我们将向您展示在线框模式下相同场景的外观。 在此模式下，3D渲染引擎将跳过在像素阶段执行的纹理和效果，仅绘制连接点的多色线。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/8a0/f67/4308a0f6729ff459c600275d8755f12c.jpg"></div><br> 现在一切看起来都完全不同，但是我们看到了如何将所有线条组合在一起以形成各种对象，环境和背景。 有些仅由几十条线组成，例如前景中的石头，而另一些则包含许多线条，看起来很坚实。 <br><br> 每行开始和结束处的每个点都通过执行一堆计算来处理。 有些计算非常简单快捷，而另一些则更为复杂。 通过成组地处理点，尤其是三角形的点，可以显着提高生产率，因此让我们仔细研究一下它们。 <br><br><h2> 三角形需要什么？ </h2><br> 名称<em>三角形</em>清楚地表明该图形具有三个内部角； 为此，她需要三个角点和三个连接它们的线段。 将角点称为<em>顶点（顶点）</em>是正确的（复数形式为-顶点）； 每个顶点由一个点定义。 由于我们处于三维几何世界中，因此将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">笛卡尔坐标系</a>用于点。 通常，坐标以三个值的形式编写，例如（1，8，-3）或一般而言（ <em>x，y，z</em> ）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/b9e/77f/64cb9e77ffcc16159b4d201026a4ba04.png"></div><br> 接下来，我们可以再添加两个顶点以形成三角形： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/732/482/c6b/732482c6b6faef01c7a7281f9b30da31.png"></div><br> 请注意，显示的线是可选的-我们可以设置点并告诉系统这三个顶点形成一个三角形。 所有顶点数据存储在一个连续的内存块中，称为<em>顶点缓冲区</em> ; 关于它们形成的图形的信息或者直接在渲染程序中编码，或者存储在另一个称为<em>索引缓冲区</em>的内存块中。 <br><br> 如果信息是在渲染程序中编码的，则可以由顶点形成的各种形状称为<em>图元</em> 。  Direct3D建议以点，线和三角形的形式为它们，条带和扇形使用列表。 如果使用正确，三角形的条纹会使用多个三角形的顶点，从而提高了生产率。 在下面的示例中，我们看到要创建连接在一起的两个三角形，只需要四个顶点-如果将它们分开，则需要六个顶点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/9cb/a1e/41e9cba1ee23a0b9787994ef7249d6ff.png"></div><br>  <i>从左至右：点列表，线列表和三角形带</i> <br><br> 例如，如果我们需要处理更大的一组顶点，则在游戏NPC模型中，最好使用一个称为<em>Mesh</em>的对象，另一个内存块，但由多个缓冲区（顶点，索引等）和模型纹理资源组成。  Microsoft的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在线文档</a>简要说明了如何使用这些缓冲区。 <br><br> 现在，让我们集中讨论3D游戏中渲染每个新帧时这些顶点所发生的情况。 简而言之，它们执行以下两种操作之一： <br><br><ul><li> 顶点移动到新位置。 </li><li> 顶点颜色变化 </li></ul><br> 准备好数学了吗？ 优秀，因为我们需要它。 <br><br><h2> 矢量出现在舞台上。 </h2><br> 假设您在屏幕上有一个三角形，然后按一个键将其向左移动。 自然，我们希望每个顶点的数字（ <em>x，y，z</em> ）相应地发生变化； 就是这样，但这是实现更改的一种非常意外的<em>方式</em> 。 绝大多数3D图形渲染系统不是简单地更改坐标，而是使用一种特殊的数学工具：我们指的是<em>vectors</em> 。 <br><br> 向量可以表示为指向空间中特定点并具有所需长度的箭头。 通常使用基于笛卡尔坐标的向量来设置顶点： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/5e4/79d/1c55e479dbf4da359cfa6ef7e3d55e8f.png"></div><br> 请注意，蓝色箭头始于一个位置（在本例中为<em>原点</em> ），并一直延伸到顶部。 为了设置向量，我们<em>在列中</em>使用了一条<em>记录</em> ，但是<em>在行中</em>使用<em>记录</em>也是很有可能的。 您可能已经注意到，还有另一个第四值，通常称为<em>w-component</em> 。 它用于显示向量代表什么：点位置（ <em>位置向量</em> ）或大方向（ <em>方向</em>向量）。 在方向矢量的情况下，它将如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/73e/525/bb273e52588aa21666075a11a34ee32d.png"></div><br> 该向量指向相同的方向，并且与先前的位置向量具有相同的长度，即，值（ <em>x，y，z</em> ）相同； 但是， <em>w</em>分量不是1，而是零。 稍后我们将解释方向矢量的用法，但是现在，请记住一个事实，即将以这种方式描述3D场景中的所有顶点。 怎么了 因为以这种格式移动它们要容易得多。 <br><br><h2> 数学，数学以及数学 </h2><br> 回想一下，我们有一个简单的三角形，我们想将其向左移动。 每个顶点由一个位置矢量描述；因此，“运动数学”（称为“ <em>转换”</em> ）必须与这些矢量一起使用。 出现一个新工具： <em>矩阵</em> （ <em>矩阵</em>为单数）。 这是一组以类似于Excel电子表格的格式编写的值数组，带有行和列。 <br><br> 对于每种类型的变换，都有一个对应的矩阵，对于一个变换，只需将变换矩阵与位置矢量相乘就足够了。 我们不会详细介绍这种情况的发生方式和原因，而只是看看它的外观。 <br><br> 在3D空间中移动顶点称为<em>平移，</em>它需要进行以下计算： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/c9b/eca/530c9beca19d9b0c8d61db78ecb8682a.png"></div><br> 值<em>x <sub>0</sub></em> ，等等。 表示向量的原始坐标；  <em>delta</em> - <em>x</em>值表示顶点需要移动的量。 矩阵和向量的相乘导致将它们简单地求和（请注意<em>w</em>分量保持不变，因此完成的答案仍然像以前一样是位置向量）。 <br><br> 除了移动之外，我们可能还需要旋转三角形或更改其比例-对于这些操作，还需要进行变换。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fc/ba4/d0b/1fcba4d0b2a678e94c17c49a09af0591.png"></div><br>  <i>此变换使顶点绕XY平面中的z轴旋转</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5eb/1d5/26e/5eb1d526eb15b522f3fddb0dadffa8cf.png"></div><br>  <em>如果需要更改图形的比例，则使用此选项</em> <br><br> 我们可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实时渲染中</a>基于WebGL的图形工具来可视化整个图形的这些计算。 让我们从处于标准位置的盒子开始： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/5d7/3d2/2205d73d2920758e3fb11f6829cb924d.jpg"></div><br> 在此在线工具中，模型点是位置矢量，世界矩阵是转换矩阵，世界空间点是转换顶点的位置矢量。 <br><br> 让我们将各种变换应用于框： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/820/d7b/5d6/820d7b5d618f68de9446d0ee005a50da.jpg"></div><br> 在上图中，该图沿每个轴<em>移动了</em> 5个单位。 这些值可以在中大型矩阵的最后一栏中看到。 原始位置矢量（4、5、3、1）保持应有的相同，但是现在将转换后的顶点移至（9、10、8、1）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a1/8c4/6fd/9a18c46fd6df9936f3632fd4e4b2a287.jpg"></div><br> 在此转换中，所有内容的缩放比例为2：现在，盒子的侧面已经变成两倍长。 最后，看一下轮换示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/beb/340/21cbeb3409b55b736d2dd1322a1d80b0.jpg"></div><br><br> 平行六面体旋转了45°的角度，但矩阵中使用<em>了</em>该角度的<em>正弦</em>和<em>余弦</em> 。 在使用科学计算器检查后，我们可以看到<em>sin（45°）</em> = 0.7071 ...，该值四舍五入为显示的值0.71。 对于<em>余弦</em>值，我们得到相同的答案。 <br><br> 矩阵和向量是可选的； 对于它们而言，一种流行的替代方法是使用复数和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">四元数</a> ，尤其是在处理复杂的转弯时。 这些计算与向量有很大不同，因此我们将不考虑它们，而是继续进行转换。 <br><br><h2> 顶点着色器功率 </h2><br> 在此阶段，我们需要了解所有这些工作都是由对渲染代码进行编程的人员完成的。 如果游戏开发人员使用第三方引擎（例如Unity或Unreal），则所有这些工作已经为他完成； 但是如果有人从头开始制作引擎，那么他将不得不使用顶点执行所有这些计算。 <br><br> 但是所有这些在代码方面如何看待？ <br><br> 为了理解这一点，我们将使用来自惊人的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Braynzar Soft</a>网站的示例。 如果您想自己开始进行3D编程，那么这里是学习基础知识以及更复杂内容的正确地方... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/99f/664/72699f66423a8f3094cb911bc99a18e2.png"></div><br> 这是多合一转换的示例。 它根据键盘输入创建适当的变换矩阵，然后通过一次操作将其应用于原始位置矢量。 请注意，这总是按照给定的顺序（缩放-旋转-传输）完成，因为任何其他方式都会完全破坏结果。 <br><br> 此类代码块称为<em>顶点着色器</em> ，其复杂性和大小可能相差很大。 上面的示例很简单，它<em>只是一个</em>顶点着色器，没有使用着色器的完全可编程特性。 更复杂的着色器序列可以在3D空间中变换对象，从场景摄影机的角度处理它们的外观，然后将数据传输到渲染过程的下一个阶段。 考虑到顶点处理的顺序，我们将研究其他示例。 <br><br> 当然，它们的用途还很多，因此在玩3D游戏时，请不要忘记您看到的所有动作都是由执行顶点着色器命令的GPU进行的。 <br><br> 但是，情况并非总是如此。 如果您回到1990年代中期，那么那个时代的图形卡就没有能力独立处理顶点和图元，仅中央处理器就可以完成所有这些工作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/954/1d1/c15/9541d1c150a6ef926d98449addf51206.jpg"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2000年发布的Nvidia GeForce</a>是最早具有此过程自身硬件加速功能的处理器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">之一</a> ，该功能称为<em>硬件变换和照明</em> （简称为Hardware TnL）。 就团队而言，该设备可以处理的过程非常有限，但是随着新芯片的发布，情况迅速改变。 如今，没有单独的设备可以处理顶点，而一个设备可以一次完成所有操作：点，图元，像素，纹理等。 <br><br> 顺便说一下，关于<em>照明</em> ：值得一提的是，借助光，我们可以看到一切，因此，让我们看看如何在顶点阶段对其进行处理。 为此，我们需要利用我们先前讨论的内容。 <br><br><h2> 灯光，相机，马达！ </h2><br> 想象一下这张图片：玩家正站在一个黑暗的房间里，被一个右侧的光源照亮。 在房间中间是一个巨大的水壶。 您可能需要与此相关的帮助，因此让我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实时渲染</a>网站，看看它的外观： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/6a4/5f4/b1a6a45f47e81bec587c4f7bda1bf3ae.jpg"></div><br> 不要忘了这个对象是一组连接在一起的平面三角形。 也就是说，每个三角形的平面将指向某个方向。 它们中的一些对准照相机，另一些-对准另一些，会失真。 来自光源的光落在每个平面上，并以一定角度从该平面反射。 <br><br> 根据反射光的位置，平面的颜色和亮度可能会发生变化，并且为了使对象的颜色看起来正确，所有这些都需要计算并考虑在内。 <br><br> 首先，我们需要找出每个平面的方向，为此，我们需要平面<em>的法向矢量</em> 。 这是另一个箭头，但是与位置向量不同，它的大小并不重要（实际上，在计算法向向量的比例后，总会减小以使其长度为1），并且它始终<em>垂直</em>于平面（成直角）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/84c/836/22884c83697e201f3b00bb7d06f6f95f.png"></div><br> 通过确定形成三角形边的两个方向向量（在<strong>p</strong>和<strong>q</strong>上方显示）的向量积，可以计算出每个三角形平面的法线。 实际上，最好是为每个顶点而不是三角形计算它们，但是由于前者总是比后者更多，因此计算三角形的法线会更快。 <br><br> 接收到表面的法线后，就可以开始考虑光源和摄像机了。 在3D渲染中，光源可以是不同的类型，但是在本文中，我们将仅考虑<em>定向</em>光源，例如聚光灯。 像三角形的平面一样，聚光灯和照相机将指向某个方向，如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/f24/b91/3a8f24b915d631a9608faaf106b04300.png"></div><br> 光源矢量和法线矢量可用于计算光入射到表面的角度（使用矢量的标量乘积与其大小的乘积之间的关系）。 三角形的顶点将包含有关其颜色和材质的其他信息。 材料描述了当光击中表面时会发生什么。 <br><br> 光滑的金属表面将以其落入的角度反射几乎所有入射光，几乎不会改变物体的颜色。 粗糙的哑光材料以较难预测的方式散射光，并且颜色略有变化。 要考虑到这一点，您需要向顶点添加其他值： <br><br><ul><li> 原始底色 </li><li> 环境材料属性-一个值，该值确定“背景”照明可以吸收和反射顶点的数量 </li><li> 漫反射材质的属性是另一个值，但这一次确定顶点的“粗糙度”，进而影响散射光的吸收和反射量 </li><li> 高光材质属性-指定顶点光泽的两个值 </li></ul><br> 不同的照明模型使用不同的数学公式对所有这些属性进行分组，并且计算结果是输出的照明矢量。 结合相机矢量，可以确定三角形的整体外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/648/a21/627648a213ed357982314f7ed7fdd915.jpg"></div><br>  <i>一个定向光源照亮了许多不同的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nvidia演示</a></i> <br><br> 我们省略了许多详细信息，这是有充分理由的：打开任何3D渲染教程，您将看到整章都专门介绍了此过程。 但是，在现代游戏中，所有照明和材质效果的计算大部分都是在像素处理阶段执行的，因此我们将在下一篇文章中再次进行介绍。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/8b7/3b0/d7c8b73b0185c20eb23b2a9fdee1cba6.png"></div><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例代码</a> B. Anguelov显示了如何在顶点着色器中处理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Phong光反射模型</a> 。</i> <br><br> 上面我们检查的所有事情都是由顶点着色器完成的，似乎它们对它来说是不可能的。 不幸的是事实并非如此。 顶点着色器无法创建新的顶点，并且每个着色器必须处理每个单独的顶点。 如果您可以使用该代码在我们已经拥有的三角形之间创建新的三角形（以提高视觉质量），并使用可以处理整个图元的着色器（以加快处理速度），将非常方便。 好吧，在现代GPU中，我们<em>可以</em>做到！ <br><br><h2> 先生，我想要更多（三角形） </h2><br> 现代图形芯片功能非常强大，能够每秒执行数百万个矩阵矢量计算。 他们轻松地一次应对一大堆山峰。 另一方面，创建用于渲染的高度详细的模型是一个很长的过程，如果模型与场景相距一定距离，那么所有这些细节都将被浪费。 <br><br> 也就是说，我们需要以某种方式命令处理器将一个较大的图元（例如，一个平面三角形）拆分为位于原始三角形内部的一组较小的三角形。 这样的过程称为<em>镶嵌效果，</em>图形芯片已经学会了很好地执行它。 在多年的发展中，程序员对该过程的控制程度有所提高。 <br><br> 为了实际观察这一点，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unigine引擎</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Heaven基准测试工具</a> ，因为它允许我们将不同的细分值应用于测试中使用的模型。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/630/5fd/d116305fd0fa789635bc3631a4463829.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，让我们在基准测试中占有一席之地，并在不使用细分的情况下对其进行研究。</font><font style="vertical-align: inherit;">请注意，地面上的鹅卵石看起来非常不自然-所使用的纹理有效，但似乎错了。</font><font style="vertical-align: inherit;">让我们将细分应用于场景：Unigine引擎仅将细分应用于各个部分，但差异会很大。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1c/8fb/399/e1c8fb3998d448711164832c4b3af2ff.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">土地，建筑物的边缘和门看起来更加真实。</font><font style="vertical-align: inherit;">我们可以看到通过再次启动该过程是如何实现的，但是这次选择了所有原语（即在线框模式下）：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c2/691/fec/0c2691fec046708d4c65058ed3cec016.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以清楚地看到为什么地球看起来如此奇怪-它是完全平坦的！门与墙合并，建筑物的边缘是简单的平行六面体。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Direct3D中，可以</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行三步过程</font><font style="vertical-align: inherit;">将基元分为一组较小的部分（此过程称为</font><em><font style="vertical-align: inherit;">细分）</font></em><font style="vertical-align: inherit;">。首先，程序员编写一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表面着色器（hull shader）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -实际上，此代码创建了一个称为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geometry patch</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结构</font><font style="vertical-align: inherit;">。您可以将其视为告诉处理器新点和线将出现在初始图元中的地图。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，GPU内的镶嵌细分将此补丁应用于图元。最后，执行</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域着色器</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算所有新顶点的位置。如有必要，可以将这些数据传输回顶点缓冲区，以便可以重新执行照明计算，但是这次结果更好。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看起来像什么？让我们启动镶嵌场景的线框版本：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c0/ca9/5af/3c0ca95af3ce89f1ae854706dfd04adc.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坦率地说，我们设置了较高的细分水平，以使对过程的解释更加明显。不管现代图形芯片的质量如何，都不应在每个场景中都做到这一点-例如，看门旁的灯。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在禁用线框的图像中，您很难在此距离找到差异，并且我们看到这种细分水平添加了太多三角形，以至于很难将它们彼此分开。但是，正确使用此顶点处理功能可以创建出色的视觉效果，尤其是在模拟软体碰撞时。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看它在Direct3D代码方面的外观；为此，我们使用另一个很棒的网站</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RasterTek的示例</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是一个细分为许多小三角形的简单绿色三角形... </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/3bd/3d4/13a3bd3d482f26404d92d3ab60694fa3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顶点</font><font style="vertical-align: inherit;">处理由三个单独的着色器执行（请参见</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码示例</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：准备用于镶嵌的三角形的顶点着色器，生成面片的表面着色器和处理新顶点的域着色器。</font><font style="vertical-align: inherit;">这个结果是可以理解的，但是Unigine的例子证明了细分方法广泛使用的潜在好处和危险。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “铁”受不了了！ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还记得我们说过的顶点着色器总是处理场景中的每个顶点吗？不难理解，镶嵌细分在这里可能是一个严重的问题。在许多视觉效果中，您需要处理一个原语的不同版本，但无需一开始就创建它们，例如，头发，毛皮，草和爆炸粒子。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幸运的是，特别是对于此类事物，还有另一个着色器- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几何着色器</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是顶点着色器的一个更受限的版本，但是它可以应用于整个图元。与曲面细分结合使用时，它使程序员可以更好地控制大组顶点。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/602/97d/f09/60297df09a132ab07b00140fa2a07b77.jpg"></div><br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与所有现代图形API一样，</font><i><font style="vertical-align: inherit;">UL Benchmark的3DMark Vantage-几何着色器可处理粒子和</font></i><font style="vertical-align: inherit;"> Direct3D </font><i><font style="vertical-align: inherit;">标志</font></i><font style="vertical-align: inherit;">，它使您可以对顶点执行大量计算。可以将完成的数据传输到渲染过程的下一个阶段（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光栅化</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），也可以将其返回到内存池以进行重新处理或由中央处理器读取以用于其他目的。正如Microsoft关于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct3D的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档所述</font><font style="vertical-align: inherit;">，可以将其实现为数据流：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/134/de2/638134de2960977f2847aab27c88df84.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">步骤</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出流（流输出）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可选的，特别是因为它可以返回到渲染图元整个周期只（而不是单独的顶点），但它是对于需要大量粒子的影响是有用的。使用可变或</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顶点缓冲区</font><font style="vertical-align: inherit;">可以完成相同的操作</font><font style="vertical-align: inherit;">，但是最好保持输入缓冲区不变，因为打开它们进行编辑时，性能会降低。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顶点处理是渲染的关键部分，因为它可以从相机的角度确定场景的外观。在现代游戏中，数百万个三角形可用于构建世界，并且每个顶点都以某种方式进行了变形和照明。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/760/829/bdd760829e81753b4938fd8ff3076b6d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三角形。</font><font style="vertical-align: inherit;">有数百万。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理所有这些计算和数学似乎是后勤上的噩梦，但是在设计图形处理器（GPU）和API时要牢记所有这些-假设一个运作良好的工厂一次将一个产品通过生产管道。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经验丰富的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D游戏渲染</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序员</font><font style="vertical-align: inherit;">具有数学和物理方面的基础知识；</font><font style="vertical-align: inherit;">他们使用所有可能的技巧和工具来优化操作，将顶点处理阶段压缩到仅几毫秒。</font><font style="vertical-align: inherit;">但这仅仅是构建3D帧的开始-下一步是光栅化，然后是极其复杂的像素和纹理处理，然后图像才能进入监视器。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472688/">https://habr.com/ru/post/zh-CN472688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472674/index.html">Python项目的环境变量</a></li>
<li><a href="../zh-CN472676/index.html">我们创建了琼斯部门来帮助主要团队，仅使用Slack，Jira和蓝色胶带</a></li>
<li><a href="../zh-CN472682/index.html">线虫的药物协同作用延缓衰老</a></li>
<li><a href="../zh-CN472684/index.html">给fsync（）惊喜PostgreSQL</a></li>
<li><a href="../zh-CN472686/index.html">基于i486的Video Studio</a></li>
<li><a href="../zh-CN472690/index.html">Zabbix 4.4的新增功能</a></li>
<li><a href="../zh-CN472694/index.html">不仅仅是Ceph：MCS块云存储</a></li>
<li><a href="../zh-CN472702/index.html">JH Rainwater“如何放牧猫”：程序员的种类及其繁殖的特征</a></li>
<li><a href="../zh-CN472708/index.html">Imperva透露了Cloud WAF黑客的技术细节</a></li>
<li><a href="../zh-CN472714/index.html">前端工作者在哪里寻找工作而不会迷恋的地方：Telegram，Slack不仅</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>