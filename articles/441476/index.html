<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíë üï∫üèæ üë©üèΩ‚Äçüè´ Hacer JaCarta Editor üë®‚Äçüíª ‚ò¶Ô∏è üë®‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúSolo puedo decir una cosa sobre el Reino de las Sombras: hay realidad y hay su Sombra; Esta es la esencia de todo. En el mundo real, solo hay Amber, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacer JaCarta Editor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441476/">  <i>‚ÄúSolo puedo decir una cosa sobre el Reino de las Sombras: hay realidad y hay su Sombra;</i>  <i>Esta es la esencia de todo.</i>  <i>En el mundo real, solo hay Amber, la ciudad real en la Tierra real, en la que todo se recoge.</i>  <i>Y el Reino de las Sombras es solo el infinito de la irrealidad.</i>  <i>Aqu√≠ tambi√©n puedes encontrar todo, pero ser√°n sombras, un reflejo distorsionado de la realidad.</i>  <i>El Reino de las Sombras rodea a Amber por todos lados.</i>  <i>Y m√°s all√°, reina el caos.</i>  <i>Todo es posible en el camino de Amber al Reino del Caos ".</i> <br>  Roger Zhelyazny.  Los nueve pr√≠ncipes de √°mbar <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hi/kl/ek/hiklekzlry8wpcjn7hg3nroukac.jpeg"></div><br>  Todo comenz√≥ con la necesidad de trabajar con la misma clave en etoken desde diferentes estaciones de trabajo significativamente remotas (USB sobre IP ser√° un poco caro para un par de tokens) y mi gran deseo de abrir este mundo cerrado.  Encontr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el</a> trabajo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/post/276057</a> por el cual su autor tiene un gran respeto, en mi proyecto se utiliz√≥ una parte significativa de las funciones que invirti√≥ (el c√≥digo est√° abierto).  Es cierto que result√≥ que todo lo que funciona con etsdk.dll solo funciona con pescado azul.  Por lo tanto, para JaCarta, las nuevas funciones tuvieron que ser reescritas y parte de la edici√≥n. <br><br>  Como resultado de una larga investigaci√≥n, apareci√≥ el Editor JaCarta, un programa que muestra y le permite editar entidades (as√≠ es como se llaman los objetos del sistema de archivos de tokens en la documentaci√≥n oficial, aparentemente insinuando su ef√≠mera e irrealidad) en tokens de Aladdin, incluidos los m√°s modernos. <br><a name="habracut"></a><br>  Una aplicaci√≥n similar para Rutoken est√° disponible p√∫blicamente como parte del Rutoken SDK (Rutoken Editor), pero para Aladdin, al menos no est√° en el dominio p√∫blico, aunque hace unos 15 a√±os, a juzgar por la documentaci√≥n que se encontr√≥ en Internet, s√≠ lo estaba (ETEditor). <br><br>  El programa est√° escrito en Autoit, probado con EToken PRO Java 72 K, JaCarta LT, JaCarta Pro, JaCarta GOST-2. <br><br>  El programa no funcionar√° si los controladores Rutoken est√°n instalados en la computadora (se requiere que EToken o Ja Carta tengan el lector n√∫mero 0). <br><br>  Por la misma raz√≥n, solo se debe conectar un token para un funcionamiento correcto. <br><br>  La secuencia de comandos utiliza las llamadas al sistema Window $ y se prob√≥ solo con esta familia de sistemas operativos. <br><br>  <b>Para trabajar, debe instalar el "JaCarta Single Client"</b> (descarga gratuita desde el sitio web del fabricante), cuando lo instala, la versi√≥n significativamente m√°s nueva de etsdk.dll y jcFS.dll que contiene las funciones del sistema de archivos JaCarta (muy similar a aquellos en etsdk.dll, pero en jcFS hay muchas m√°s funciones sin las cuales trabajar con algunos jakarts modernos, como GOST-2, ser√≠a imposible).  Cuando se instala Unified Client, naturalmente no es necesario buscar y colocar este dll en la carpeta con el programa, de lo contrario, con el controlador instalado el tipo espec√≠fico de token, este dll debe estar en la carpeta del programa. <br><br>  Todas las funciones de jcFS se describen en detalle en el sitio web del fabricante, pero, sin embargo, algunos par√°metros de estas funciones tuvieron que seleccionarse experimentalmente. <br><br>  Para acceder al directorio ra√≠z del token, debe llamar a la funci√≥n ETRootDirOpen o JCRootDirOpen (que es la misma, ya que el primero en el dll llama al segundo, esto es cierto para casi todas las funciones, pero hay algunas excepciones) con un identificador de proveedor de 0 (constantes como 0xF007 permitir√° vea solo directorios individuales de eToken en su mayor√≠a antiguos que almacenan claves bancarias generadas mediante utilidades como PKIAdmin y MessagePRO). <br><br>  La siguiente caracter√≠stica importante de la jakarta moderna es la necesidad de conocer la identificaci√≥n del applet que est√° instalado en el token, la funci√≥n JCSelectApplet es responsable de esto. <br><br>  Los tokens m√°s antiguos generalmente tienen un applet predeterminado y no se requiere llamar a esta funci√≥n espec√≠ficamente, pero los jakarts nuevos y relativamente nuevos sin saber la identificaci√≥n del applet no funcionan m√°s.  Llamar a todas las funciones que reciben informaci√≥n del token en este caso devuelve False.  En mi proyecto, en este caso, se implementa una fuerza bruta de dos etapas (el token siempre responde a dos id, pero solo uno de ellos funciona) id y funciona con el valor deseado. <br><br>  Toda la informaci√≥n se muestra en la ventana de resultados ubicada debajo del √°rbol de directorios. <br>  Se ingres√≥ el c√≥digo PIN, tambi√©n se muestra informaci√≥n sobre los intentos restantes de ingresarlo. <br>  Se muestra el contenido de los directorios y una breve informaci√≥n sobre los archivos: el nombre, si el archivo es informaci√≥n privada es un c√≥digo PIN privado, la letra p: (el archivo es p√∫blico despu√©s, la unidad es privada) y el tama√±o del archivo en bytes despu√©s de "s:".  El archivo se abre haciendo doble clic. <br><br>  Puede ver y, si es necesario, copiar el contenido de los archivos de token al b√∫fer en formato hexadecimal o guardarlo en forma binaria en una computadora. <br><br>  Tambi√©n puede cambiar el contenido del archivo y seleccionar "Guardar cambios" en el men√∫ (el c√≥digo PIN debe ingresarse primero, si no se ingres√≥, se mostrar√° un mensaje apropiado, en cuyo caso los datos editados se pueden seleccionar y copiar en el portapapeles). <br><br>  Para eliminar un archivo, selecci√≥nelo y haga clic en "Eliminar", despu√©s de lo cual aparecer√° una ventana de confirmaci√≥n. <br><br>  JaCarta File System tiene una caracter√≠stica interesante, que est√° presente en todos los tokens que prob√©.  Si crea un directorio o varios directorios sin archivos en el token, durante la pr√≥xima sesi√≥n de trabajo con el token desaparecer√°n, aparentemente de esta manera el sistema de archivos se encarga de guardar la memoria del token y limpia toda la basura. <br><br>  Por lo tanto, cuando hace clic en el bot√≥n Crear en el programa, se crea una cadena inmediatamente desde un directorio o dos directorios y un archivo.  La profundidad de anidamiento de directorios en el programa es dos, sin contar la ra√≠z.  En el directorio ra√≠z, solo puede crear directorios, pero no archivos. <br>  Antes de crear, editar o eliminar entidades, debe ingresar un c√≥digo PIN. <br><br>  ¬°Una nota muy importante sobre los nombres de directorio! <br><br>  En los tokens donde el contenido es creado por el fabricante, nunca ver√° directorios con el mismo nombre, est√©n donde est√©n.  Esto se debe a las caracter√≠sticas del sistema de archivos. <br><br>  Supongamos que tenemos la siguiente entidad en el token: // <u>0001</u> / A001 / 0008 (es decir, la carpeta 0001 est√° en el directorio ra√≠z, la carpeta A001 est√° en √©l y el archivo 0008 est√° en √©l) y creamos una nueva entidad en el token: // CC00 / <u>0001/1010</u> .  Al acceder al archivo 1010, comenzar√° la b√∫squeda del directorio 0001, que se encuentra en la ra√≠z y se encontrar√° primero, pero no hay tal archivo en √©l.  Como resultado, la funci√≥n devuelve False y la entidad se pierde; tampoco puede acceder a ella ni eliminarla.  Solo la inicializaci√≥n de token ayudar√°. <br><br>  De particular inter√©s es EToken PRO y JA Carta Pro, que solo difieren en apariencia, tienen archivos del sistema en el directorio ra√≠z (se muestran en la pantalla), en uno de los cuales se almacena el hash del c√≥digo pin, cambiando estos archivos conduce al hecho de que la autorizaci√≥n se vuelve imposible (el c√≥digo PIN se vuelve incorrecto) y despu√©s de eso solo ayudar√° la inicializaci√≥n. <br><br>  Con respecto a las claves privadas, fue posible establecer lo siguiente: si un contenedor creado por un proveedor criptogr√°fico de terceros, como CryptoPro, se almacena en el token, entonces todo su contenido, incluidas las claves privadas, estar√° disponible, es solo una unidad flash con un c√≥digo PIN (como se muestra en la imagen).  Si el par de claves se gener√≥ a bordo del token utilizando PKCS11, solo estar√°n disponibles el certificado y la clave p√∫blica. <br><br>  Dado que este es un programa experimental, no recomiendo usarlo con tokens que contengan claves EDS v√°lidas, todas las operaciones se realizan por miedo y riesgo del experimentador.  Esto es especialmente cierto para la creaci√≥n de nuevas entidades, en algunos casos el resultado es dif√≠cil de predecir. <br><br>  Toda la informaci√≥n para crear el programa se obtuvo de fuentes abiertas, el prop√≥sito de su creaci√≥n es puramente de investigaci√≥n. <br><br>  El gui√≥n en s√≠ <br><br><div class="spoiler">  <b class="spoiler_title">JACartaEditor.au3</b> <div class="spoiler_text"><pre><code class="vbscript hljs">#include &lt;GUIConstantsEx.au3&gt; #include &lt;WindowsConstants.au3&gt; #include &lt;EditConstants.au3&gt; #include &lt;TreeViewConstants.au3&gt; #include &lt;GuiTreeView.au3&gt; #include &lt;GuiMenu.au3&gt; #include &lt;MsgBoxConstants.au3&gt; #include &lt;StaticConstants.au3&gt; #include &lt;GuiButton.au3&gt; #NoTrayIcon ;  jcFS.dll <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> $ETSdkDll=DllOpen(<span class="hljs-comment"><span class="hljs-comment">'jcFS.dll') Func ETTokenLock($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLock', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenUnLock($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenUnLock', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETReadersEnumOpen() Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETReadersEnumOpen', _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETReadersEnumNext($EnumId) Local $Reader=DllStructCreate('CHAR name[260]; BYTE etoken;') Local $CallRes=DllCall($ETSdkDll,'WORD','ETReadersEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Reader) _ ) Local $Result[2]=[ DllStructGetData($reader,'name'), _ DllStructGetData($reader,'etoken')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func ETReadersEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETReadersEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenBind($ReaderName) Local $In=DllStructCreate('BYTE['&amp;(StringLen($ReaderName)+1)&amp;']') Local $Out=DllStructCreate('DWORD') DllStructSetData($In,1,$ReaderName) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenBind', _ 'PTR',DllStructGetPtr($Out), _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETTokenRebind($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenRebind', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenUnbind($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenUnbind', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenLogin($BindId,$Pin='') Local $In=DllStructCreate('BYTE['&amp;(StringLen($Pin)+1)&amp;']') DllStructSetData($In,1,$Pin) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLogin', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenPinChange($BindId,$Pin) Local $In=DllStructCreate('CHAR['&amp;(StringLen($Pin)+1)&amp;']') DllStructSetData($In,1,$Pin) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenPinChange', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenLogout($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLogout', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETRootDirOpen($BindId,$Dir=0xF007) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETRootDirOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$BindId, _ 'DWORD',$Dir _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirOpen($Dir,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$Dir, _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirCreate($Dir,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirCreate', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$Dir, _ 'DWORD',$DirId, _ 'DWORD',0 _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirGetInfo($DirId) Local $Out=DllStructCreate('WORD wDirName; WORD wSize') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirGetInfo', _ 'DWORD',$DirId, _ 'PTR',DllStructGetPtr($Out) _ ) Local $Result[2]=[ DllStructGetData($Out,'wDirName'), _ DllStructGetData($Out,'wSize')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func ETDirClose($DirId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirClose', _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETDirDelete($DirId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirDelete', _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETDirEnumOpen($DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirEnumOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirEnumNext($EnumId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETFileOpen($File,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId, _ 'DWORD',$File _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFileCreate($File,$DirId,$Size,$Private=0) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileCreate', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId, _ 'DWORD',$File, _ 'DWORD',$Size, _ 'DWORD',$Private _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFileGetInfo($FileId) Local $Out=DllStructCreate('WORD name;WORD private;WORD;WORD size') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileGetInfo', _ 'DWORD',$FileId, _ 'PTR',DllStructGetPtr($Out) _ ) Local $Result[3]=[ DllStructGetData($Out,'name'), _ DllStructGetData($Out,'private'), _ DllStructGetData($Out,'size')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func ETFileRead($FileId) Local $FileInfo=ETFileGetInfo($FileId) If @error Then Return SetError(@error,0,False) Local $Out=DllStructCreate('BYTE ['&amp;$FileInfo[2]&amp;']') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileRead', _ 'DWORD',$FileId, _ 'DWORD',0, _ 'DWORD',0xFFFF, _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$FileInfo[2] _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFileWrite($FileId,$Data,$Pos=0) $Data=Binary($Data) Local $DataSize=BinaryLen($Data) Local $In=DllStructCreate('BYTE['&amp;$DataSize&amp;']') DllStructSetData($In,1,$Data) Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileWrite', _ 'DWORD',$FileId, _ 'DWORD',$Pos, _ 'PTR',DllStructGetPtr($In), _ 'DWORD',$DataSize _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETFileClose($FileId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileClose', _ 'DWORD',$FileId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETFileDelete($FileId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileDelete', _ 'DWORD',$FileId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETFilesEnumOpen($DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFilesEnumOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFilesEnumNext($EnumId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFilesEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFilesEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETFilesEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenLabelGet($BindId) Local $Out1=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLabelGet', _ 'DWORD',$BindId, _ 'PTR',0, _ 'PTR',DllStructGetPtr($Out1) _ ) If $CallRes[0] Then Return SetError($CallRes[0],0,False) Local $Out2=DllStructCreate('CHAR['&amp;DllStructGetData($Out1,1)&amp;']') $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLabelGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out2), _ 'PTR',DllStructGetPtr($Out1) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out2,1) EndFunc Func ETTokenIDGet($BindId) Local $Out1=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenIDGet', _ 'DWORD',$BindId, _ 'PTR',0, _ 'PTR',DllStructGetPtr($Out1) _ ) If $CallRes[0] Then Return SetError($CallRes[0],0,False) Local $Out2=DllStructCreate('CHAR['&amp;DllStructGetData($Out1,1)&amp;']') $CallRes=DllCall($ETSdkDll,'WORD','ETTokenIDGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out2), _ 'PTR',DllStructGetPtr($Out1) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out2,1) EndFunc Func ETTokenMaxPinGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenMaxPinGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETTokenMinPinGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenMinPinGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETSelectApplet($BindId, $Applet) Local $In=DllStructCreate('DWORD') DllStructSetData($In,1,$Applet) Local $CallRes=DllCall($ETSdkDll,'WORD','ETSelectApplet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Applet) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCSelectApplet($BindId, $Applet) Local $In=DllStructCreate('WORD') DllStructSetData($In,1,$Applet) Local $CallRes=DllCall($ETSdkDll,'WORD','JCSelectApplet', _ 'DWORD',$BindId, _ 'WORD',$Applet _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCReadersEnumOpen() Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCReadersEnumOpen', _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCReadersEnumNext($EnumId) Local $Reader=DllStructCreate('CHAR name[260]; BYTE etoken;') Local $CallRes=DllCall($ETSdkDll,'WORD','JCReadersEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Reader) _ ) Local $Result[2]=[ DllStructGetData($reader,'name'), _ DllStructGetData($reader,'etoken')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func JCReadersEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCReadersEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenBind($ReaderName) Local $In=DllStructCreate('CHAR['&amp;(StringLen($ReaderName)+1)&amp;']') Local $Out=DllStructCreate('DWORD') DllStructSetData($In,1,$ReaderName) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenBind', _ 'PTR',DllStructGetPtr($Out), _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCTokenRebind($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenRebind', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenUnbind($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenUnbind', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenLogin($BindId,$Pin) Local $In=DllStructCreate('CHAR['&amp;(StringLen($Pin)+1)&amp;']') DllStructSetData($In,1,$Pin) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLogin', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenPinChange($BindId,$Pin) Local $In=DllStructCreate('CHAR['&amp;(StringLen($Pin)+1)&amp;']') DllStructSetData($In,1,$Pin) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenPinChange', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenLogout($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLogout', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCRootDirOpen($BindId,$Dir=0) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCRootDirOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$BindId, _ 'WORD',$Dir _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirOpen($Dir,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$Dir, _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirCreate($Dir,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirCreate', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$Dir, _ 'DWORD',$DirId, _ 'DWORD',0 _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirGetInfo($DirId) Local $Out=DllStructCreate('BYTE[8]') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirGetInfo', _ 'DWORD',$DirId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirClose($DirId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirClose', _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCDirDelete($DirId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirDelete', _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCDirEnumOpen($DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirEnumOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirEnumNext($EnumId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCFileOpen($File,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId, _ 'DWORD',$File _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFileCreate($File,$DirId,$Size,$Private=0) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileCreate', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId, _ 'DWORD',$File, _ 'DWORD',$Size, _ 'DWORD',$Private _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFileGetInfo($FileId) Local $Out=DllStructCreate('WORD name;WORD private;WORD;WORD size') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileGetInfo', _ 'DWORD',$FileId, _ 'PTR',DllStructGetPtr($Out) _ ) Local $Result[3]=[ DllStructGetData($Out,'name'), _ DllStructGetData($Out,'private'), _ DllStructGetData($Out,'size')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func JCFileRead($FileId) Local $FileInfo=JCFileGetInfo($FileId) If @error Then Return SetError(@error,0,False) Local $Out=DllStructCreate('BYTE ['&amp;$FileInfo[2]&amp;']') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileRead', _ 'DWORD',$FileId, _ 'DWORD',0, _ 'DWORD',0xFFFF, _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$FileInfo[2] _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFileWrite($FileId,$Data,$Pos=0) $Data=Binary($Data) Local $DataSize=BinaryLen($Data) Local $In=DllStructCreate('BYTE['&amp;$DataSize&amp;']') DllStructSetData($In,1,$Data) Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileWrite', _ 'DWORD',$FileId, _ 'DWORD',$Pos, _ 'PTR',DllStructGetPtr($In), _ 'DWORD',$DataSize _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCFileClose($FileId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileClose', _ 'DWORD',$FileId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCFileDelete($FileId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileDelete', _ 'DWORD',$FileId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCFilesEnumOpen($DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFilesEnumOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFilesEnumNext($EnumId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFilesEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFilesEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCFilesEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenLabelGet($BindId) Local $Out1=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLabelGet', _ 'DWORD',$BindId, _ 'PTR',0, _ 'PTR',DllStructGetPtr($Out1) _ ) If $CallRes[0] Then Return SetError($CallRes[0],0,False) Local $Out2=DllStructCreate('CHAR['&amp;DllStructGetData($Out1,1)&amp;']') $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLabelGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out2), _ 'PTR',DllStructGetPtr($Out1) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out2,1) EndFunc Func JCTokenIDGet($BindId) Local $Out1=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenIDGet', _ 'DWORD',$BindId, _ 'PTR',0, _ 'PTR',DllStructGetPtr($Out1) _ ) If $CallRes[0] Then Return SetError($CallRes[0],0,False) Local $Out2=DllStructCreate('CHAR['&amp;DllStructGetData($Out1,1)&amp;']') $CallRes=DllCall($ETSdkDll,'WORD','JCTokenIDGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out2), _ 'PTR',DllStructGetPtr($Out1) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out2,1) EndFunc Func JCTokenMaxPinGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenMaxPinGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCTokenMinPinGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenMinPinGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCTokenUnLock($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenUnLock', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenLock($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLock', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenPinAttemptsGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenPinAttemptsGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc ;  Opt("GUIOnEventMode", 1) Dim $BindId, $filelog, $Result, $DirIdRoot=False, $Edit, $msg, $Fileinfo, $treeview, $generalitem, $displayitem, $diritem, $Edit, $SrcSubId, $Output, $pinbutton, $hPinWin, $PinEdit, $pinokbutton, $pincancelbutton, $Pin, $Edit1, $Reader, $Applet, $AppletID, $text, $CreateDirWin Global $Dir1, $Dir2 Dim $hParentWin, $hChildWin, $sItemText, $folderbutton, $filebutton, $deletebutton, $CreateFileWin, $FileEdit, $fileokbutton, $filecancelbutton, $publicbutton, $privatebutton, $sizefile Dim $hFile, $hMain Global Enum $idSave= 1000, $Save Dim $Appname = 'JaCarta Editor' ;  applet ID  Func Applet() GUICtrlSetData($Output, '  applet ID... '&amp;@CRLF,1) Local $Result, $AppletTemp= 0 For $Applet = 0 To 65535 Step 1 $Result = 0 $Result=JCSelectApplet($BindId,$Applet) ; 0x2001 PROJAVA  E-token, 0x1002 PRO, 0x1001 R2, 0x2202 GOST, 0x2205 DATASTORE, 0x2206 -2, 0x2201, 0x2204 ( JaCarta) If $Result = True Then $AppletTemp=$Applet $AppletID=$Applet ExitLoop EndIf Next Local $Id=ETTokenLabelGet($BindId) if $Id= False Then For $Applet=$AppletTemp+1 To 65535 Step 1 $Result=0 $Result=JCSelectApplet($BindId,$Applet) If $Result = True Then ExitLoop EndIf Next EndIf JCSelectApplet($BindId,$Applet) GUICtrlSetData($Output, 'Select applet 0x'&amp;hex($Applet,4)&amp;@CRLF,1) $AppletID=$Applet EndFunc ;      Func PrintDir($Id,$Prefix) Local $EnumId=ETDirEnumOpen($Id) While 1 Local $dir=ETDirEnumNext($EnumId) If @error Then ExitLoop Local $DirId=ETDirOpen($dir,$Id) Local $Dirinfo $Dirinfo=ETDirGetInfo($DirId) Local $Dirtext='(dir)'&amp;hex($dir,4) $diritem = _GUICtrlTreeView_AddChild($treeview,$Prefix, $Dirtext) PrintDir($DirId,$diritem) ETDirClose($DirId) WEnd ETDirEnumClose($EnumId) $EnumId=ETFilesEnumOpen($Id) While 1 Local $file=ETFilesEnumNext($EnumId) If @error Then ExitLoop Local $FileId=ETFileOpen($file,$Id) $Fileinfo=ETFileGetInfo($FileId) Local $filetext='(file)'&amp;hex($file,5)&amp;' '&amp;'p: '&amp;$Fileinfo[1]&amp;' s: '&amp;$Fileinfo[2]&amp;@CRLF _GUICtrlTreeView_AddChild($treeview,$Prefix,$filetext) WEnd ETFilesEnumClose($EnumId) EndFunc ;         Func List() GUICtrlSetData($Output, '') Local $text Local $EnumId=ETReadersEnumOpen() GUICtrlSetData($Output, '   :'&amp;@CRLF,1) While 1 $Reader=ETReadersEnumNext($EnumId) If @error Then ExitLoop GUICtrlSetData($Output, $Reader[0]&amp;@CRLF,1) WEnd ETReadersEnumClose($EnumId) Local $EnumId=ETReadersEnumOpen() $Reader=ETReadersEnumNext($EnumId) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) GUICtrlSetData($Output, '  '&amp;$Reader[0]&amp;@CRLF,1) ;    ID ,    AppletID $Result=ETTokenIDGet($BindId) if $Result= False Then if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) Else Applet() EndIf EndIf $Result=ETTokenIDGet($BindId) $text=$Reader[0]&amp;' ID '&amp;$Result $generalitem = _GUICtrlTreeView_AddChild($treeview,0,$text) $Result=ETTokenLabelGet($BindId) GUICtrlSetData($Output, 'Label: '&amp;$Result&amp;@CRLF,1) $DirIdRoot=ETRootDirOpen($BindId,0) ;0xF007   0x0001    $Result=JCTokenPinAttemptsGet($BindId) ;       If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result ) Else GUICtrlSetData($Output, 'Login OK'&amp;@CRLF,1) EndIf EndIf $Result=JCTokenPinAttemptsGet($BindId) GUICtrlSetData($Output, '   PIN : '&amp;$Result&amp;@CRLF,1) PrintDir($DirIdRoot,0) ETTokenUnbind($BindId) ETReadersEnumClose($EnumId) EndFunc ;     Func onClose() GUISetState(@SW_HIDE, $hPinWin) GUISetState(@SW_HIDE, $hChildWin) GUISetState(@SW_HIDE, $CreateFileWin) if @GUI_WinHandle=$hParentWin Then Exit EndIf EndFunc ;     Func onPin() GUISetState(@SW_SHOW, $hPinWin ) EndFunc ;       Func onPinOK() $Pin=GUICtrlRead($PinEdit) GUISetState(@SW_HIDE, $hPinWin) _GUICtrlTreeView_DeleteAll ($treeview) List() EndFunc ;    Func onPinCancel() GUISetState(@SW_HIDE, $hPinWin) EndFunc ;  Func Delete() If $Pin=0 Then MsgBox(0x10,$Appname,'      ' ) Else Local $hItem = _GUICtrlTreeView_GetSelection($treeview) Local $Del = _GUICtrlTreeView_GetText($treeview, $hItem) if _GUICtrlTreeView_GetChildren($treeview, $hItem)=False Then $Del=StringTrimLeft ( $Del, 6 ) Local $p=0 $p=StringInStr ($Del,"p:") $Del=StringMid ( $Del, 1, $p-2 ) if MsgBox(4 + 32, $Appname, ' '&amp; $Del &amp;' ?') = 6 Then Local $DirID=_GUICtrlTreeView_GetParentHandle($treeview, $hItem) Local $Dir= _GUICtrlTreeView_GetText($treeview, $DirID) $Dir=StringTrimLeft ( $Dir, 5 ) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) EndIf If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result) EndIf EndIf Local $HDir=GetDir(ETRootDirOpen($BindId,0), $Dir) Local $DELFile =JCFileOpen(Dec ($Del), $HDir) JCFileDelete($DELFile ) ETDirClose($HDir) ETTokenUnbind($BindId) _GUICtrlTreeView_DeleteAll ($treeview) List() EndIf Else MsgBox(0x10,$Appname,'           ' ) EndIf EndIf EndFunc ;     Func onFileCreate() If $Pin=0 Then MsgBox(0x10,$Appname,'      ' ) Else Local $hItem = _GUICtrlTreeView_GetSelection($treeview) Local $FileText = 0, $Dir1=0, $Dir2=0 $FileText = _GUICtrlTreeView_GetText($treeview, $hItem) ;      if StringLen($FileText) &gt;20 Then GUICtrlSetData($FileEdit, '') GUICtrlSetData($FileEdit, '//',0) Else $Dir1=StringTrimLeft ( $FileText, 5 ) Local $ParentID=_GUICtrlTreeView_GetParentHandle($treeview, $hItem) Local $ParentDir= _GUICtrlTreeView_GetText($treeview, $ParentID) if StringInStr ($ParentDir,"Dir")=0 Then $ParentDir='' GUICtrlSetData($FileEdit, '') GUICtrlSetData($FileEdit, '//'&amp;$Dir1&amp;'/',0) Else $Dir2=StringTrimLeft ( $ParentDir, 5 ) $Dir2='/'&amp;$Dir2 GUICtrlSetData($FileEdit, '') GUICtrlSetData($FileEdit, '/'&amp;$Dir2&amp;'/'&amp;$Dir1&amp;'/',0) EndIf EndIf GUISetState(@SW_SHOW, $CreateFileWin) EndIf EndFunc ;   Func onFileCancel() GUISetState(@SW_HIDE, $CreateFileWin) EndFunc ;   Func onFileOK() Local $filename=GUICtrlRead($FileEdit) Local $isPrivate=_GUICtrlButton_GetCheck($privatebutton) Local $fileSize=GUICtrlRead($sizefile) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) EndIf If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result ) EndIf EndIf Local $rootdir=ETRootDirOpen($BindId,0) Local $text=StringTrimLeft ( $filename, 2 ) Local $text1=StringLeft($text, 4) $dir1=JCDirOpen(Dec ($text1), $rootdir) if $dir1=false Then $dir1= ETDirCreate(Dec ($text1), $rootdir) EndIf if StringLen($text) &gt;12 Then $text=StringTrimLeft ( $text, 5 ) $text1=StringLeft($text, 4) $dir2=JCDirOpen(Dec ($text1), $dir1) if $dir2=false Then $dir2= ETDirCreate(Dec ($text1), $dir1) EndIf $text=StringTrimLeft ( $text, 5 ) Local $DstFile=JCFileCreate(Dec ($text),$Dir2,$fileSize,$isPrivate) JCFileClose($DstFile) Else $text=StringTrimLeft ( $text, 5 ) Local $DstFile=JCFileCreate(Dec ($text),$Dir1,$fileSize,$isPrivate) JCFileClose($DstFile) EndIf ETTokenUnbind($BindId) GUISetState(@SW_HIDE, $CreateFileWin) GUISetState(@SW_SHOW, $hParentWin) _GUICtrlTreeView_DeleteAll ($treeview) List() EndFunc ;     Func SaveFile() If $Pin=0 Then MsgBox(0x10,$Appname,'      ' ) Else Local $filebody=GUICtrlRead($Edit1) Local $hItem = _GUICtrlTreeView_GetSelection($treeview) Local $FileEd = _GUICtrlTreeView_GetText($treeview, $hItem) $FileEd=StringTrimLeft ( $FileEd, 6 ) Local $p=0 $p=StringInStr ($FileEd,"p:") $FileEd=StringMid ( $FileEd, 1, $p-2 ) Local $DirID=_GUICtrlTreeView_GetParentHandle($treeview, $hItem) Local $Dir= _GUICtrlTreeView_GetText($treeview, $DirID) $Dir=StringTrimLeft ( $Dir, 5 ) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) EndIf If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result) EndIf EndIf Local $HDir=GetDir(ETRootDirOpen($BindId,0), $Dir) Local $File=JCFileOpen(Dec ($FileEd),$HDir) Local $Data =Binary('0x' &amp; $filebody) JCFileWrite($File, $Data) JCFileClose($File) ETDirClose($HDir) ETTokenUnbind($BindId) GUISetState(@SW_HIDE, $hChildWin) _GUICtrlTreeView_DeleteAll ($treeview) List() EndIf EndFunc ;       Func SaveFileAs() Local $varFile = 0 $varFile = FileSaveDialog( " ", @MyDocumentsDir &amp; "\", "  (*.bin)", 16,'',$hParentWin) If StringLen($varFile) &gt; 3 Then Local $filedest $filedest = FileOpen($varFile, 17) ; Check if file open If $filedest = -1 Then MsgBox(0, "Error", "Unable to open file.") Exit EndIf FileWrite($filedest, $text) FileClose($filedest) EndIf EndFunc ;        Func WM_COMMAND($hWnd, $iMsg, $wParam, $lParam) #forceref $hWnd, $iMsg, $lParam Switch $wParam Case $Save SaveFile() Case $idSave SaveFileAs() EndSwitch EndFunc ;==&gt;WM_COMMAND ;   Func GUIInit() $hParentWin= GUICreate($Appname, 560, 400) GUISetOnEvent($GUI_EVENT_CLOSE,'onClose') ;   $treeview = GUICtrlCreateTreeView(6, 6, 400, 300, BitOR($TVS_HASBUTTONS, $TVS_HASLINES, $TVS_LINESATROOT, $TVS_DISABLEDRAGDROP, $TVS_SHOWSELALWAYS), $WS_EX_CLIENTEDGE) $Output = GUICtrlCreateEdit("" , 6, 320, 400, 70, $ES_AUTOVSCROLL + $WS_VSCROLL + $ES_NOHIDESEL + $ES_WANTRETURN) $pinbutton = GUICtrlCreateButton("&amp; PIN ", 430, 20, 100, 50) $filebutton = GUICtrlCreateButton("&amp;", 430, 80, 100, 50) $deletebutton = GUICtrlCreateButton("&amp;", 430, 140, 100, 50) ;     $hPinWin = GUICreate(' PIN ', 200, 200, -1, -1, $WS_SYSMENU, -1, $hParentWin) $PinEdit = GUICtrlCreateInput ("" , 50, 40, 100, 25, $ES_PASSWORD + $ES_NOHIDESEL + $ES_WANTRETURN) $pinokbutton = GUICtrlCreateButton("&amp;OK", 20, 100, 60, 40) $pincancelbutton = GUICtrlCreateButton("&amp;", 110, 100, 60, 40) ;   $CreateFileWin = GUICreate('   ', 340, 350, -1, -1, $WS_SYSMENU, -1, $hParentWin) $FileEdit = GUICtrlCreateInput ("" , 50, 70, 230, 25) $fileokbutton= GUICtrlCreateButton("&amp;OK", 70, 240, 60, 40) $filecancelbutton = GUICtrlCreateButton("&amp;", 210, 240, 60, 40) $publicbutton= _GUICtrlButton_Create($CreateFileWin, "Public", 100, 120, 50, 30, $BS_AUTORADIOBUTTON, 0) $privatebutton=_GUICtrlButton_Create($CreateFileWin, "Private", 160, 120, 50, 30, $BS_AUTORADIOBUTTON, 0) _GUICtrlButton_SetCheck($publicbutton, $BST_CHECKED) Local $label=GUICtrlCreateLabel('      hex  1001 ', 70, 20, 170, 40, $SS_CENTER) $sizefile = GUICtrlCreateInput ("10" , 220, 175, 50, 20) Local $label1=GUICtrlCreateLabel('    ', 20, 180, 200, 60, $SS_CENTER) ;   $hChildWin = GUICreate($sItemText, 300, 230, -1, -1, $WS_SYSMENU, -1, $hParentWin) $Edit1 = GUICtrlCreateEdit("", 10, 10, 240, 160, $ES_AUTOVSCROLL + $WS_VSCROLL + $ES_NOHIDESEL + $ES_WANTRETURN) ;   ""     $hFile = _GUICtrlMenu_CreateMenu () _GUICtrlMenu_InsertMenuItem ($hFile, 0, ' ...', $idSave) _GUICtrlMenu_InsertMenuItem ($hFile, 1, ' ', $Save) $hMain = _GUICtrlMenu_CreateMenu () _GUICtrlMenu_InsertMenuItem ($hMain, 0, '', 0, $hFile) _GUICtrlMenu_SetMenu ($hChildWin, $hMain) ;  GUICtrlSetOnEvent($filebutton,'onFileCreate') GUICtrlSetOnEvent($deletebutton,'Delete') GUICtrlSetOnEvent($pinbutton,'onPin') GUICtrlSetOnEvent($pinokbutton,'onPinOK') GUICtrlSetOnEvent($pincancelbutton,'onPinCancel') GUICtrlSetOnEvent($fileokbutton,'onFileOK') GUICtrlSetOnEvent($filecancelbutton,'onFileCancel') GUISetOnEvent($GUI_EVENT_CLOSE,'onClose') GUISetState(@SW_SHOW, $hParentWin) GUIRegisterMsg(0x0111, "WM_COMMAND") EndFunc ;    GUIInit() List() ;          GUIRegisterMsg($WM_NOTIFY, "MY_WM_NOTIFY") Global $iDoubleClick = 0 Func MY_WM_NOTIFY($hWnd, $Msg, $wParam, $lParam) Local $tagNMHDR, $vEvent Switch $wParam Case $treeview $tagNMHDR = DllStructCreate("int;int;int", $lParam) If @error Then Return $vEvent = DllStructGetData($tagNMHDR, 3) If $vEvent = $NM_DBLCLK Then $iDoubleClick = 1 EndIf EndSwitch $tagNMHDR = 0 EndFunc ;==&gt;MY_WM_NOTIFY ;  ,      Func GetDir( $Id,$Dir_Id) Local $DirId=0 Local $DirResult=0 Local $EnumId=ETDirEnumOpen($Id) While 1 Local $dir=ETDirEnumNext($EnumId) If @error Then ExitLoop $DirId=ETDirOpen($dir,$Id) if hex($dir,4)=$Dir_Id Then $DirResult=$DirId ExitLoop EndIf $DirResult=GetDir( $DirId, $Dir_Id) ETDirClose($DirId) WEnd ETDirEnumClose($EnumId) Return $DirResult EndFunc ;            Func ListFile($file, $Dir_Id) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) EndIf If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result ) EndIf EndIf if StringLen($Dir_Id)&gt;10 Then $HDir=ETRootDirOpen($BindId,0) Else Local $HDir=GetDir(ETRootDirOpen($BindId,0), $Dir_Id) EndIf $SrcSubId=JCFileOpen(Dec ($file), $HDir) $text=JCFileRead($SrcSubId) GUICtrlSetData($Edit1, hex($text)) JCFileClose($SrcSubId) ETDirClose($HDir) ETTokenUnbind($BindId) EndFunc ;          While 1 if $iDoubleClick Then Local $hItem = _GUICtrlTreeView_GetSelection($treeview) if _GUICtrlTreeView_GetChildren($treeview, $hItem)=False Then Local $hItem = _GUICtrlTreeView_GetSelection($treeview) $sItemText = _GUICtrlTreeView_GetText($treeview, $hItem) if StringInStr ($sItemText,"Dir")=0 Then Local $text1=0 $text1=StringTrimLeft ( $sItemText, 6 ) Local $p=0 $p=StringInStr ($text1,"p:") $sItemText=0 $sItemText=StringMid ( $text1, 1, $p-2 ) GUISetState(@SW_SHOW, $hChildWin) GUISetOnEvent($GUI_EVENT_CLOSE,'onClose') Local $DirID=_GUICtrlTreeView_GetParentHandle($treeview, $hItem) Local $Dir= _GUICtrlTreeView_GetText($treeview, $DirID) $text1=StringTrimLeft ( $Dir, 5 ) $Dir=$text1 ListFile($sItemText, $Dir) EndIf EndIf $iDoubleClick = 0 EndIf WEnd</span></span></code> </pre> <br></div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes de informacion</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eToken Developer's Guide Versi√≥n 3.50 (diciembre de 2003)</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441476/">https://habr.com/ru/post/441476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441456/index.html">Seis historias de c√≥mo se reescribi√≥ el c√≥digo desde cero</a></li>
<li><a href="../441458/index.html">Brazos mecanizados y manipuladores: le dicen lo que hace el laboratorio de rob√≥tica de la Universidad ITMO</a></li>
<li><a href="../441460/index.html">¬øY c√≥mo ves la educaci√≥n en TI?</a></li>
<li><a href="../441468/index.html">Facebook cerrar√° su spyware VPN Onavo</a></li>
<li><a href="../441472/index.html">Red neuronal ense√±ada a dibujar los detalles que faltan en la foto de personas</a></li>
<li><a href="../441478/index.html">Juego interactivo en XSLT</a></li>
<li><a href="../441482/index.html">La nueva cronolog√≠a de Iyon the Pacific</a></li>
<li><a href="../441484/index.html">Los empleados de Microsoft se opusieron al uso de HoloLens en el ej√©rcito, porque la guerra se convierte en un juego de computadora</a></li>
<li><a href="../441490/index.html">Qu√© buscar al elegir un lector: sistemas operativos y hardware</a></li>
<li><a href="../441496/index.html">Sonido en el cable: la historia del tel√©grafo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>