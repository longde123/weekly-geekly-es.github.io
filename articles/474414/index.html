<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîì üñãÔ∏è ‚õ≤Ô∏è Escribimos nuestro propio motor voxel üöå üë©üèº‚Äçüè≠ üç≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota: el c√≥digo fuente completo para este proyecto est√° disponible aqu√≠: [ fuente ]. 

 Cuando el proyecto en el que estoy trabajando comienza a agota...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos nuestro propio motor voxel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474414/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/e5f/dea/a53e5fdeab8992f2b647feb66ccf126b.png" alt="imagen"></div><br>  <em><strong>Nota: el</strong> c√≥digo fuente completo para este proyecto est√° disponible aqu√≠: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente</a> ].</em> <br><br>  Cuando el proyecto en el que estoy trabajando comienza a agotarse, agrego nuevas visualizaciones que me dan motivaci√≥n para seguir adelante. <br><br>  Despu√©s del lanzamiento del concepto original de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Task-Bot</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> al Habr√©], sent√≠ que estaba limitado por el espacio bidimensional en el que trabajaba.  Parec√≠a que estaba frenando las posibilidades del comportamiento emergente de los bots. <br><br>  Los anteriores intentos fallidos de aprender OpenGL moderno me pusieron ante m√≠ una barrera mental, pero a fines de julio finalmente la romp√≠.  Hoy, a fines de octubre, ya tengo una comprensi√≥n bastante segura de los conceptos, as√≠ que lanc√© mi propio motor simple de v√≥xel, que ser√° el entorno para la vida y la prosperidad de mis Task-Bots. <br><br>  Decid√≠ crear mi propio motor, porque necesitaba un control total sobre los gr√°ficos;  Adem√°s, quer√≠a ponerme a prueba.  En cierto modo, estaba inventando una bicicleta, ¬°pero realmente me gust√≥ este proceso! <br><br>  El objetivo final de todo el proyecto era una simulaci√≥n completa del ecosistema, donde los bots como agentes manipulan el entorno e interact√∫an con √©l. <br><br>  Dado que el motor ya se ha movido un poco hacia adelante y pasar√© a programar bots nuevamente, decid√≠ escribir una publicaci√≥n sobre el motor, sus funciones e implementaci√≥n para centrarme en tareas de nivel superior en el futuro. <br><a name="habracut"></a><br><h2>  Concepto del motor </h2><br>  El motor est√° completamente escrito desde cero en C ++ (con algunas excepciones, como encontrar una ruta).  Utilizo SDL2 para representar el contexto y procesar la entrada, OpenGL para representar una escena 3D y DearImgui para controlar la simulaci√≥n. <br><br>  Decid√≠ usar voxels principalmente porque quer√≠a trabajar con una cuadr√≠cula que tiene muchas ventajas: <br><br><ul><li>  La creaci√≥n de mallas para renderizar me es bien entendida. </li><li>  Las capacidades de almacenamiento de datos del mundo son m√°s diversas y comprensibles. </li><li>  Ya he creado sistemas para generar simulaciones de terreno y clima basadas en mallas. </li><li>  Las tareas de los bots en la cuadr√≠cula son m√°s f√°ciles de parametrizar. </li></ul><br>  El motor consta de un sistema de datos mundial, un sistema de representaci√≥n y varias clases auxiliares (por ejemplo, para el procesamiento de sonido y entrada). <br><br>  En el art√≠culo hablar√© sobre la lista actual de caracter√≠sticas, y tambi√©n examinar√© m√°s de cerca los subsistemas m√°s complejos. <br><br><h3>  Clase mundial </h3><br>  La clase mundial sirve como la clase base para almacenar toda la informaci√≥n del mundo.  Maneja la generaci√≥n, carga y almacenamiento de datos de bloque. <br><br>  Los datos del bloque se almacenan en fragmentos de tama√±o constante (16 ^ 3), y el mundo almacena el vector de fragmentos cargado en la memoria virtual.  En mundos grandes, es pr√°cticamente necesario recordar solo una cierta parte del mundo, por eso eleg√≠ este enfoque. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">World</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: World(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> _saveFile){ saveFile = _saveFile; loadWorld(); } <span class="hljs-comment"><span class="hljs-comment">//Data Storage std::vector&lt;Chunk&gt; chunks; //Loaded Chunks std::stack&lt;int&gt; updateModels; //Models to be re-meshed void bufferChunks(View view); //Generation void generate(); Blueprint blueprint; bool evaluateBlueprint(Blueprint &amp;_blueprint); //File IO Management std::string saveFile; bool loadWorld(); bool saveWorld(); //other... int SEED = 100; int chunkSize = 16; int tickLength = 1; glm::vec3 dim = glm::vec3(20, 5, 20); //...</span></span></code> </pre> <br>  Los fragmentos almacenan datos de bloque, as√≠ como algunos otros metadatos, en una matriz plana.  Inicialmente, implement√© mi propio √°rbol de octree escaso para almacenar fragmentos, pero result√≥ que el tiempo de acceso aleatorio es demasiado alto para crear mallas.  Y aunque una matriz plana no es √≥ptima desde el punto de vista de la memoria, proporciona la capacidad de construir muy r√°pidamente mallas y manipulaciones con bloques, as√≠ como acceso a la ruta de b√∫squeda. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Position information and size information glm::vec3 pos; int size; BiomeType biome; //Data Storage Member int data[16*16*16] = {0}; bool refreshModel = false; //Get the Flat-Array Index int getIndex(glm::vec3 _p); void setPosition(glm::vec3 _p, BlockType _type); BlockType getPosition(glm::vec3 _p); glm::vec4 getColorByID(BlockType _type); };</span></span></code> </pre> <br>  Si alguna vez implemento guardar y cargar fragmentos con varios subprocesos, convertir una matriz plana en un √°rbol de octree escaso y viceversa puede ser una opci√≥n completamente posible para ahorrar memoria.  ¬°Todav√≠a hay espacio para la optimizaci√≥n! <br><br>  Mi implementaci√≥n del √°rbol de octree escaso se almacena en el c√≥digo, por lo que puede usarlo con seguridad. <br><br><h4>  Almacenamiento de fragmentos y manejo de memoria </h4><br>  Los fragmentos son visibles solo cuando est√°n dentro de la distancia de representaci√≥n de la posici√≥n actual de la c√°mara.  Esto significa que cuando la c√°mara se mueve, debe cargar din√°micamente y componer fragmentos en las mallas. <br><br>  Los fragmentos se serializan utilizando la biblioteca de impulso, y los datos mundiales se almacenan como un archivo de texto simple, en el que cada fragmento es una l√≠nea del archivo.  Se generan en un orden espec√≠fico para que se puedan "ordenar" en un archivo mundial.  Esto es importante para futuras optimizaciones. <br><br>  En el caso de un mundo grande, el cuello de botella principal es leer el archivo mundial y cargar / escribir fragmentos.  Idealmente, solo necesitamos descargar y transferir el archivo mundial. <br><br>  Para hacer esto, el m√©todo <code>World::bufferChunks()</code> elimina fragmentos que est√°n en la memoria virtual pero que son invisibles, y carga de manera inteligente nuevos fragmentos del archivo mundial. <br><br>  Por inteligencia se entiende que simplemente decide qu√© nuevos fragmentos cargar, orden√°ndolos por su posici√≥n en el archivo guardado y luego haciendo una pasada.  Todo es muy sencillo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::bufferChunks(View view){ <span class="hljs-comment"><span class="hljs-comment">//Load / Reload all Visible Chunks evaluateBlueprint(blueprint); //Chunks that should be loaded glm::vec3 a = glm::floor(view.viewPos/glm::vec3(chunkSize))-view.renderDistance; glm::vec3 b = glm::floor(view.viewPos/glm::vec3(chunkSize))+view.renderDistance; //Can't exceed a certain size a = glm::clamp(a, glm::vec3(0), dim-glm::vec3(1)); b = glm::clamp(b, glm::vec3(0), dim-glm::vec3(1)); //Chunks that need to be removed / loaded std::stack&lt;int&gt; remove; std::vector&lt;glm::vec3&gt; load; //Construct the Vector of chunks we should load for(int i = ax; i &lt;= bx; i ++){ for(int j = ay; j &lt;= by; j ++){ for(int k = az; k &lt;= bz; k ++){ //Add the vector that we should be loading load.push_back(glm::vec3(i, j, k)); } } } //Loop over all existing chunks for(unsigned int i = 0; i &lt; chunks.size(); i++){ //Check if any of these chunks are outside of the limits if(glm::any(glm::lessThan(chunks[i].pos, a)) || glm::any(glm::greaterThan(chunks[i].pos, b))){ //Add the chunk to the erase pile remove.push(i); } //Don't reload chunks that remain for(unsigned int j = 0; j &lt; load.size(); j++){ if(glm::all(glm::equal(load[j], chunks[i].pos))){ //Remove the element from load load.erase(load.begin()+j); } } //Flags for the Viewclass to use later updateModels = remove; //Loop over the erase pile, delete the relevant chunks. while(!remove.empty()){ chunks.erase(chunks.begin()+remove.top()); remove.pop(); } //Check if we want to load any guys if(!load.empty()){ //Sort the loading vector, for single file-pass std::sort(load.begin(), load.end(), [](const glm::vec3&amp; a, const glm::vec3&amp; b) { if(ax &gt; bx) return true; if(ax &lt; bx) return false; if(ay &gt; by) return true; if(ay &lt; by) return false; if(az &gt; bz) return true; if(az &lt; bz) return false; return false; }); boost::filesystem::path data_dir( boost::filesystem::current_path() ); data_dir /= "save"; data_dir /= saveFile; std::ifstream in((data_dir/"world.region").string()); Chunk _chunk; int n = 0; while(!load.empty()){ //Skip Lines (this is dumb) while(n &lt; load.back().x*dim.z*dim.y+load.back().y*dim.z+load.back().z){ in.ignore(1000000,'\n'); n++; } //Load the Chunk { boost::archive::text_iarchive ia(in); ia &gt;&gt; _chunk; chunks.push_back(_chunk); load.pop_back(); } } in.close(); } }</span></span></code> </pre> <br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Su navegador no admite video HTML5. <source src="http://weigert.vsos.ethz.ch/wp-content/uploads/2019/10/chunkload.mp4" type="video/mp4"></video></div></div></div><br>  <i>Un ejemplo de carga de fragmentos con una peque√±a distancia de representaci√≥n.</i>  <i>Los artefactos de distorsi√≥n de pantalla son causados ‚Äã‚Äãpor el software de grabaci√≥n de video.</i>  <i>A veces se producen picos notables en las descargas, principalmente causados ‚Äã‚Äãpor mallas</i> <br><br>  Adem√°s, configur√© una bandera que indica que el renderizador debe recrear la malla del fragmento cargado. <br><br><h4>  Blueprint Class y editBuffer </h4><br>  editBuffer es un contenedor ordenable de bufferObjects que contiene informaci√≥n sobre la edici√≥n en el espacio mundial y el espacio de fragmentos. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//EditBuffer Object Struct struct bufferObject { glm::vec3 pos; glm::vec3 cpos; BlockType type; }; //Edit Buffer! std::vector&lt;bufferObject&gt; editBuffer;</span></span></code> </pre> <br>  Si, al realizar cambios en el mundo, escribirlos en un archivo inmediatamente despu√©s de realizar el cambio, tendremos que transferir todo el archivo de texto y escribir CADA cambio.  Esto es terrible en t√©rminos de rendimiento. <br><br>  Entonces, primero escribo todos los cambios que deben hacerse para editBuffer usando el m√©todo addEditBuffer (que tambi√©n calcula la posici√≥n de los cambios en el espacio de fragmentos).  Antes de escribirlos en un archivo, clasifico los cambios en el orden de los fragmentos a los que pertenecen seg√∫n su ubicaci√≥n en el archivo. <br><br>  La escritura de cambios en un archivo consiste en una transferencia de archivos, cargando cada l√≠nea (es decir, un fragmento), para la cual hay cambios en editBuffer, haciendo todos los cambios y escribi√©ndolos en un archivo temporal hasta que editBuffer se vac√≠e.  Esto se hace en la funci√≥n <code>evaluateBlueprint()</code> , que es lo suficientemente r√°pida. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> World::evaluateBlueprint(Blueprint &amp;_blueprint){ <span class="hljs-comment"><span class="hljs-comment">//Check if the editBuffer isn't empty! if(_blueprint.editBuffer.empty()){ return false; } //Sort the editBuffer std::sort(_blueprint.editBuffer.begin(), _blueprint.editBuffer.end(), std::greater&lt;bufferObject&gt;()); //Open the File boost::filesystem::path data_dir(boost::filesystem::current_path()); data_dir /= "save"; data_dir /= saveFile; //Load File and Write File std::ifstream in((data_dir/"world.region").string()); std::ofstream out((data_dir/"world.region.temp").string(), std::ofstream::app); //Chunk for Saving Data Chunk _chunk; int n_chunks = 0; //Loop over the Guy while(n_chunks &lt; dim.x*dim.y*dim.z){ if(in.eof()){ return false; } //Archive Serializers boost::archive::text_oarchive oa(out); boost::archive::text_iarchive ia(in); //Load the Chunk ia &gt;&gt; _chunk; //Overwrite relevant portions while(!_blueprint.editBuffer.empty() &amp;&amp; glm::all(glm::equal(_chunk.pos, _blueprint.editBuffer.back().cpos))){ //Change the Guy _chunk.setPosition(glm::mod(_blueprint.editBuffer.back().pos, glm::vec3(chunkSize)), _blueprint.editBuffer.back().type); _blueprint.editBuffer.pop_back(); } //Write the chunk back oa &lt;&lt; _chunk; n_chunks++; } //Close the fstream and ifstream in.close(); out.close(); //Delete the first file, rename the temp file boost::filesystem::remove_all((data_dir/"world.region").string()); boost::filesystem::rename((data_dir/"world.region.temp").string(),(data_dir/"world.region").string()); //Success! return true; }</span></span></code> </pre> <br>  La clase blueprint contiene editBuffer, as√≠ como varios m√©todos que le permiten crear editBuffers para objetos espec√≠ficos (√°rboles, cactus, chozas, etc.).  Luego, el plano se puede convertir a la posici√≥n donde desea colocar el objeto, y luego simplemente escribirlo en la memoria del mundo. <br><br>  Una de las mayores dificultades cuando se trabaja con fragmentos es que los cambios en varios bloques entre los l√≠mites de los fragmentos pueden resultar un proceso mon√≥tono con una gran cantidad de m√≥dulo aritm√©tico y dividir los cambios en varias partes.  Este es el principal problema que la clase de anteproyecto maneja brillantemente. <br><br>  Lo uso activamente en la etapa de generaci√≥n mundial para expandir el "cuello de botella" de escribir cambios en un archivo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::generate(){ <span class="hljs-comment"><span class="hljs-comment">//Create an editBuffer that contains a flat surface! blueprint.flatSurface(dim.x*chunkSize, dim.z*chunkSize); //Write the current blueprint to the world file. evaluateBlueprint(blueprint); //Add a tree Blueprint _tree; evaluateBlueprint(_tree.translate(glm::vec3(x, y, z))); }</span></span></code> </pre> <br>  La clase mundial almacena su propio modelo de cambios realizados en el mundo, de modo que cuando se llama a bufferChunks (), todos los cambios se escriben en el disco duro en una sola pasada y luego se eliminan de la memoria virtual. <br><br><h3>  Renderizado </h3><br>  El renderizador en su estructura no es muy complicado, pero requiere conocimiento de OpenGL para entenderlo.  No todas sus partes son interesantes, principalmente son envoltorios de funcionalidad OpenGL.  Experiment√© con la visualizaci√≥n durante bastante tiempo para obtener lo que me gusta. <br><br>  Como la simulaci√≥n no es de la primera persona, eleg√≠ la proyecci√≥n ortogr√°fica.  Podr√≠a implementarse en formato pseudo-3D (es decir, para preproyectar mosaicos y superponerlos en un procesador de software), pero me pareci√≥ una tonter√≠a.  Me alegro de haber cambiado a usar OpenGL. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61e/923/40e/61e92340e2801dc8f6dd63b54badc438.png"></div><br>  La clase base para renderizar se llama Ver, contiene la mayor√≠a de las variables importantes que controlan la visualizaci√≥n de la simulaci√≥n: <br><br><ul><li>  Tama√±o de pantalla y textura de sombra </li><li>  Objetos de sombreado, c√°mara, matriz, etc. factores de zoom </li><li>  Valores booleanos para casi todas las funciones de renderizador <ul><li>  Men√∫, niebla, profundidad de campo, textura de grano, etc. </li></ul></li><li>  Colores para iluminaci√≥n, niebla, cielo, selecci√≥n de ventanas, etc. </li></ul><br>  Adem√°s, hay varias clases auxiliares que realizan la representaci√≥n y el ajuste de OpenGL. <br><br><ul><li>  Sombreador de clase <ul><li>  Carga, compila, compila y usa sombreadores GLSL </li></ul></li><li>  Clase de modelo <ul><li>  Contiene fragmentos de datos VAO (objeto de matrices de v√©rtices) para renderizar, la funci√≥n de crear mallas y el m√©todo de renderizado. </li></ul></li><li>  Cartelera de clase <ul><li>  Contiene el FBO (objeto FrameBuffer) para renderizar, √∫til para crear efectos de procesamiento posterior y sombreado. </li></ul></li><li>  Clase de sprites <ul><li>  Dibuja un cuadril√°tero orientado en relaci√≥n con la c√°mara, cargado desde un archivo de textura (para bots y objetos).  ¬°Tambi√©n puede manejar animaciones! </li></ul></li><li>  Clase de interfaz <ul><li>  Para trabajar con ImGUI </li></ul></li><li>  Clase de audio <ul><li>  Soporte de sonido muy rudimentario (si compila el motor, presione "M") </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/0f3/ef6/6e50f3ef66d7d71dd5ae76b94b3c168a.png"></div><br>  <i>Alta profundidad de campo (DOF).</i>  <i>A grandes distancias de renderizado, puede ser lento, pero hice todo esto en mi computadora port√°til.</i>  <i>Quiz√°s en una buena computadora los frenos sean invisibles.</i>  <i>Entiendo que me fatiga los ojos y lo hice solo por diversi√≥n.</i> <br><br>  La imagen de arriba muestra algunos par√°metros que se pueden cambiar durante la manipulaci√≥n.  Tambi√©n implement√© el cambio al modo de pantalla completa.  La imagen muestra un ejemplo de un sprite bot representado como un cuadril√°tero texturizado dirigido hacia la c√°mara.  Las casas y los cactus de la imagen est√°n construidos con planos. <br><br><h4>  Crear mallas de fragmentos </h4><br>  Inicialmente, utilic√© la versi√≥n ingenua de crear mallas: simplemente cre√© un cubo y descart√© v√©rtices que no tocaban el espacio vac√≠o.  Sin embargo, esta soluci√≥n fue lenta, y al cargar nuevos fragmentos, la creaci√≥n de mallas result√≥ ser "cuellos de botella" a√∫n m√°s estrechos que el acceso al archivo. <br><br>  El principal problema fue la creaci√≥n eficiente de fragmentos de VBO renderizados, pero logr√© implementar en C ++ mi propia versi√≥n de "mallado codicioso" (mallado codicioso), compatible con OpenGL (sin estructuras extra√±as con bucles).  Puedes usar mi c√≥digo con la conciencia tranquila. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Model::fromChunkGreedy(Chunk chunk){ <span class="hljs-comment"><span class="hljs-comment">//... (this is part of the model class - find on github!) }</span></span></code> </pre> <br>  En general, la transici√≥n a mallas codiciosas redujo el n√∫mero de cuadr√°ngulos dibujados en un promedio del 60%.  Luego, despu√©s de otras optimizaciones menores (indexaci√≥n VBO), el n√∫mero se redujo en otro 1/3 (de 6 v√©rtices al borde a 4 v√©rtices). <br><br>  Cuando renderizo una escena de fragmentos de 5x1x5 en una ventana que no est√° maximizada, obtengo un promedio de aproximadamente 140 FPS (con VSYNC deshabilitado). <br><br>  Aunque estoy bastante contento con este resultado, todav√≠a me gustar√≠a encontrar un sistema para renderizar modelos no c√∫bicos a partir de datos mundiales.  No es tan f√°cil integrarse con mallas codiciosas, por lo que vale la pena considerarlo. <br><br><h4>  Sombreadores y resaltado de v√≥xel </h4><br>  La implementaci√≥n de sombreadores GLSL es una de las partes m√°s interesantes y al mismo tiempo m√°s molestas de escribir el motor debido a la complejidad de la depuraci√≥n en la GPU.  No soy especialista en GLSL, as√≠ que tuve que aprender mucho sobre la marcha. <br><br>  Los efectos que he implementado usan activamente FBO y muestreo de textura (por ejemplo, desenfoque, sombreado y uso de informaci√≥n de profundidad). <br><br>  Todav√≠a no me gusta el modelo de iluminaci√≥n actual, porque no maneja muy bien el "oscuro".  Espero que esto se solucione en el futuro cuando trabaje en el ciclo de cambiar el d√≠a y la noche. <br><br>  Tambi√©n implement√© una funci√≥n de selecci√≥n de voxel simple usando el algoritmo de Bresenham modificado (esta es otra ventaja de usar voxels).  Es √∫til para obtener informaci√≥n espacial durante la simulaci√≥n.  Mi implementaci√≥n solo funciona para proyecciones ortogr√°ficas, pero puede usarla. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/020/f2c/c60020f2cd1b4507152fdee4ef16e0ea.png"></div><br>  <i>Calabaza "resaltada".</i> <br><br><h3>  Clases de juego </h3><br>  Se han creado varias clases auxiliares para procesar entradas, depurar mensajes, as√≠ como una clase de elemento separada con funcionalidad b√°sica (que se ampliar√° a√∫n m√°s). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventHandler</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">/* This class handles user input, creates an appropriate stack of activated events and handles them so that user inputs have continuous effect. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Queued Inputs std::deque&lt;SDL_Event*&gt; inputs; //General Key Inputs std::deque&lt;SDL_Event*&gt; scroll; //General Key Inputs std::deque&lt;SDL_Event*&gt; rotate; //Rotate Key Inputs SDL_Event* mouse; //Whatever the mouse is doing at a moment SDL_Event* windowevent; //Whatever the mouse is doing at a moment bool _window; bool move = false; bool click = false; bool fullscreen = false; //Take inputs and add them to stack void input(SDL_Event *e, bool &amp;quit, bool &amp;paused); //Handle the existing stack every tick void update(World &amp;world, Player &amp;player, Population &amp;population, View &amp;view, Audio &amp;audio); //Handle Individual Types of Events void handlePlayerMove(World &amp;world, Player &amp;player, View &amp;view, int a); void handleCameraMove(World &amp;world, View &amp;view); };</span></span></code> </pre> <br>  Mi controlador de eventos es feo, pero funcional.  Con mucho gusto aceptar√© recomendaciones para su mejora, especialmente en el uso de SDL Poll Event. <br><br><h2>  √öltimas notas </h2><br>  El motor en s√≠ mismo es solo un sistema en el que pongo mis bots de tareas (hablar√© de ellos en detalle en la pr√≥xima publicaci√≥n).  Pero si encontraste mis m√©todos interesantes y quieres saber m√°s, escr√≠beme. <br><br>  Luego port√© el sistema de bot de tareas (el coraz√≥n real de este proyecto) al mundo 3D y expand√≠ significativamente sus capacidades, pero m√°s sobre eso m√°s tarde (sin embargo, ¬°el c√≥digo ya se public√≥ en l√≠nea)! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474414/">https://habr.com/ru/post/474414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474400/index.html">Mitos sobre la disponibilidad de contraste de color.</a></li>
<li><a href="../474402/index.html">Vavr Collections API Guide</a></li>
<li><a href="../474404/index.html">An√°lisis de los problemas resueltos del campeonato de programaci√≥n de Yandex (desarrollo front-end) 2019</a></li>
<li><a href="../474406/index.html">La primera aparici√≥n de BlueKeep en la naturaleza registrada</a></li>
<li><a href="../474408/index.html">¬øRevoluci√≥n o evoluci√≥n del modelo de objeto de p√°gina?</a></li>
<li><a href="../474418/index.html">Conferencia 27 de DEFCON. Beneficios de los productos hacker para macOS. Parte 1</a></li>
<li><a href="../474420/index.html">Formaci√≥n del termostato: como sucedi√≥</a></li>
<li><a href="../474422/index.html">Fascinantes plataformas de c√≥digo abierto para desarrollar aplicaciones m√≥viles</a></li>
<li><a href="../474424/index.html">Entrenamiento combinado: qu√© es y c√≥mo funciona</a></li>
<li><a href="../474426/index.html">La serie animada "C√≠rculo matem√°tico"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>